/home/phantom/Documents/azemora/azemora-contracts/lib/forge-std/src/Base.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | pragma solidity >=0.6.2 <0.9.0;
  3 |     | 
  4 |     | import {StdStorage} from "./StdStorage.sol";
  5 |     | import {Vm, VmSafe} from "./Vm.sol";
  6 |     | 
  7 |     | abstract contract CommonBase {
  8 |     |     /// @dev Cheat code address.
  9 |     |     /// Calculated as `address(uint160(uint256(keccak256("hevm cheat code"))))`.
 10 | *   |     address internal constant VM_ADDRESS = 0x7109709ECfa91a80626fF3989D68f67F5b1DD12D;
 11 |     |     /// @dev console.sol and console2.sol work by executing a staticcall to this address.
 12 |     |     /// Calculated as `address(uint160(uint88(bytes11("console.log"))))`.
 13 |     |     address internal constant CONSOLE = 0x000000000000000000636F6e736F6c652e6c6f67;
 14 |     |     /// @dev Used when deploying with create2.
 15 |     |     /// Taken from https://github.com/Arachnid/deterministic-deployment-proxy.
 16 |     |     address internal constant CREATE2_FACTORY = 0x4e59b44847b379578588920cA78FbF26c0B4956C;
 17 |     |     /// @dev The default address for tx.origin and msg.sender.
 18 |     |     /// Calculated as `address(uint160(uint256(keccak256("foundry default caller"))))`.
 19 |     |     address internal constant DEFAULT_SENDER = 0x1804c8AB1F12E6bbf3894d4083f33e07309d1f38;
 20 |     |     /// @dev The address of the first contract `CREATE`d by a running test contract.
 21 |     |     /// When running tests, each test contract is `CREATE`d by `DEFAULT_SENDER` with nonce 1.
 22 |     |     /// Calculated as `VM.computeCreateAddress(VM.computeCreateAddress(DEFAULT_SENDER, 1), 1)`.
 23 |     |     address internal constant DEFAULT_TEST_CONTRACT = 0x5615dEB798BB3E4dFa0139dFa1b3D433Cc23b72f;
 24 |     |     /// @dev Deterministic deployment address of the Multicall3 contract.
 25 |     |     /// Taken from https://www.multicall3.com.
 26 |     |     address internal constant MULTICALL3_ADDRESS = 0xcA11bde05977b3631167028862bE2a173976CA11;
 27 |     |     /// @dev The order of the secp256k1 curve.
 28 |     |     uint256 internal constant SECP256K1_ORDER =
 29 |     |         115792089237316195423570985008687907852837564279074904382605163141518161494337;
 30 |     | 
 31 |     |     uint256 internal constant UINT256_MAX =
 32 |     |         115792089237316195423570985008687907853269984665640564039457584007913129639935;
 33 |     | 
 34 |     |     Vm internal constant vm = Vm(VM_ADDRESS);
 35 |     |     StdStorage internal stdstore;
 36 |     | }
 37 |     | 
 38 |     | abstract contract TestBase is CommonBase {}
 39 |     | 
 40 |     | abstract contract ScriptBase is CommonBase {
 41 |     |     VmSafe internal constant vmSafe = VmSafe(VM_ADDRESS);
 42 |     | }
 43 |     | 

/home/phantom/Documents/azemora/azemora-contracts/lib/forge-std/src/StdAssertions.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | pragma solidity >=0.6.2 <0.9.0;
   3 |     | pragma experimental ABIEncoderV2;
   4 |     | 
   5 |     | import {Vm} from "./Vm.sol";
   6 |     | 
   7 |     | abstract contract StdAssertions {
   8 |     |     Vm private constant vm = Vm(address(uint160(uint256(keccak256("hevm cheat code")))));
   9 |     | 
  10 |     |     event log(string);
  11 |     |     event logs(bytes);
  12 |     | 
  13 |     |     event log_address(address);
  14 |     |     event log_bytes32(bytes32);
  15 |     |     event log_int(int256);
  16 |     |     event log_uint(uint256);
  17 |     |     event log_bytes(bytes);
  18 |     |     event log_string(string);
  19 |     | 
  20 |     |     event log_named_address(string key, address val);
  21 |     |     event log_named_bytes32(string key, bytes32 val);
  22 |     |     event log_named_decimal_int(string key, int256 val, uint256 decimals);
  23 |     |     event log_named_decimal_uint(string key, uint256 val, uint256 decimals);
  24 |     |     event log_named_int(string key, int256 val);
  25 |     |     event log_named_uint(string key, uint256 val);
  26 |     |     event log_named_bytes(string key, bytes val);
  27 |     |     event log_named_string(string key, string val);
  28 |     | 
  29 |     |     event log_array(uint256[] val);
  30 |     |     event log_array(int256[] val);
  31 |     |     event log_array(address[] val);
  32 |     |     event log_named_array(string key, uint256[] val);
  33 |     |     event log_named_array(string key, int256[] val);
  34 |     |     event log_named_array(string key, address[] val);
  35 |     | 
  36 |     |     bool private _failed;
  37 |     | 
  38 | *   |     function failed() public view returns (bool) {
  39 | *   |         if (_failed) {
  40 |     |             return _failed;
  41 |     |         } else {
  42 | *   |             return vm.load(address(vm), bytes32("failed")) != bytes32(0);
  43 |     |         }
  44 |     |     }
  45 |     | 
  46 |     |     function fail() internal virtual {
  47 |     |         vm.store(address(vm), bytes32("failed"), bytes32(uint256(1)));
  48 |     |         _failed = true;
  49 |     |     }
  50 |     | 
  51 |     |     function assertTrue(bool data) internal pure virtual {
  52 |     |         vm.assertTrue(data);
  53 |     |     }
  54 |     | 
  55 |     |     function assertTrue(bool data, string memory err) internal pure virtual {
  56 |     |         vm.assertTrue(data, err);
  57 |     |     }
  58 |     | 
  59 |     |     function assertFalse(bool data) internal pure virtual {
  60 |     |         vm.assertFalse(data);
  61 |     |     }
  62 |     | 
  63 |     |     function assertFalse(bool data, string memory err) internal pure virtual {
  64 |     |         vm.assertFalse(data, err);
  65 |     |     }
  66 |     | 
  67 |     |     function assertEq(bool left, bool right) internal pure virtual {
  68 |     |         vm.assertEq(left, right);
  69 |     |     }
  70 |     | 
  71 |     |     function assertEq(bool left, bool right, string memory err) internal pure virtual {
  72 |     |         vm.assertEq(left, right, err);
  73 |     |     }
  74 |     | 
  75 |     |     function assertEq(uint256 left, uint256 right) internal pure virtual {
  76 |     |         vm.assertEq(left, right);
  77 |     |     }
  78 |     | 
  79 |     |     function assertEq(uint256 left, uint256 right, string memory err) internal pure virtual {
  80 |     |         vm.assertEq(left, right, err);
  81 |     |     }
  82 |     | 
  83 |     |     function assertEqDecimal(uint256 left, uint256 right, uint256 decimals) internal pure virtual {
  84 |     |         vm.assertEqDecimal(left, right, decimals);
  85 |     |     }
  86 |     | 
  87 |     |     function assertEqDecimal(uint256 left, uint256 right, uint256 decimals, string memory err) internal pure virtual {
  88 |     |         vm.assertEqDecimal(left, right, decimals, err);
  89 |     |     }
  90 |     | 
  91 |     |     function assertEq(int256 left, int256 right) internal pure virtual {
  92 |     |         vm.assertEq(left, right);
  93 |     |     }
  94 |     | 
  95 |     |     function assertEq(int256 left, int256 right, string memory err) internal pure virtual {
  96 |     |         vm.assertEq(left, right, err);
  97 |     |     }
  98 |     | 
  99 |     |     function assertEqDecimal(int256 left, int256 right, uint256 decimals) internal pure virtual {
 100 |     |         vm.assertEqDecimal(left, right, decimals);
 101 |     |     }
 102 |     | 
 103 |     |     function assertEqDecimal(int256 left, int256 right, uint256 decimals, string memory err) internal pure virtual {
 104 |     |         vm.assertEqDecimal(left, right, decimals, err);
 105 |     |     }
 106 |     | 
 107 |     |     function assertEq(address left, address right) internal pure virtual {
 108 |     |         vm.assertEq(left, right);
 109 |     |     }
 110 |     | 
 111 |     |     function assertEq(address left, address right, string memory err) internal pure virtual {
 112 |     |         vm.assertEq(left, right, err);
 113 |     |     }
 114 |     | 
 115 |     |     function assertEq(bytes32 left, bytes32 right) internal pure virtual {
 116 |     |         vm.assertEq(left, right);
 117 |     |     }
 118 |     | 
 119 |     |     function assertEq(bytes32 left, bytes32 right, string memory err) internal pure virtual {
 120 |     |         vm.assertEq(left, right, err);
 121 |     |     }
 122 |     | 
 123 |     |     function assertEq32(bytes32 left, bytes32 right) internal pure virtual {
 124 |     |         assertEq(left, right);
 125 |     |     }
 126 |     | 
 127 |     |     function assertEq32(bytes32 left, bytes32 right, string memory err) internal pure virtual {
 128 |     |         assertEq(left, right, err);
 129 |     |     }
 130 |     | 
 131 |     |     function assertEq(string memory left, string memory right) internal pure virtual {
 132 |     |         vm.assertEq(left, right);
 133 |     |     }
 134 |     | 
 135 |     |     function assertEq(string memory left, string memory right, string memory err) internal pure virtual {
 136 |     |         vm.assertEq(left, right, err);
 137 |     |     }
 138 |     | 
 139 |     |     function assertEq(bytes memory left, bytes memory right) internal pure virtual {
 140 |     |         vm.assertEq(left, right);
 141 |     |     }
 142 |     | 
 143 |     |     function assertEq(bytes memory left, bytes memory right, string memory err) internal pure virtual {
 144 |     |         vm.assertEq(left, right, err);
 145 |     |     }
 146 |     | 
 147 |     |     function assertEq(bool[] memory left, bool[] memory right) internal pure virtual {
 148 |     |         vm.assertEq(left, right);
 149 |     |     }
 150 |     | 
 151 |     |     function assertEq(bool[] memory left, bool[] memory right, string memory err) internal pure virtual {
 152 |     |         vm.assertEq(left, right, err);
 153 |     |     }
 154 |     | 
 155 |     |     function assertEq(uint256[] memory left, uint256[] memory right) internal pure virtual {
 156 |     |         vm.assertEq(left, right);
 157 |     |     }
 158 |     | 
 159 |     |     function assertEq(uint256[] memory left, uint256[] memory right, string memory err) internal pure virtual {
 160 |     |         vm.assertEq(left, right, err);
 161 |     |     }
 162 |     | 
 163 |     |     function assertEq(int256[] memory left, int256[] memory right) internal pure virtual {
 164 |     |         vm.assertEq(left, right);
 165 |     |     }
 166 |     | 
 167 |     |     function assertEq(int256[] memory left, int256[] memory right, string memory err) internal pure virtual {
 168 |     |         vm.assertEq(left, right, err);
 169 |     |     }
 170 |     | 
 171 |     |     function assertEq(address[] memory left, address[] memory right) internal pure virtual {
 172 |     |         vm.assertEq(left, right);
 173 |     |     }
 174 |     | 
 175 |     |     function assertEq(address[] memory left, address[] memory right, string memory err) internal pure virtual {
 176 |     |         vm.assertEq(left, right, err);
 177 |     |     }
 178 |     | 
 179 |     |     function assertEq(bytes32[] memory left, bytes32[] memory right) internal pure virtual {
 180 |     |         vm.assertEq(left, right);
 181 |     |     }
 182 |     | 
 183 |     |     function assertEq(bytes32[] memory left, bytes32[] memory right, string memory err) internal pure virtual {
 184 |     |         vm.assertEq(left, right, err);
 185 |     |     }
 186 |     | 
 187 |     |     function assertEq(string[] memory left, string[] memory right) internal pure virtual {
 188 |     |         vm.assertEq(left, right);
 189 |     |     }
 190 |     | 
 191 |     |     function assertEq(string[] memory left, string[] memory right, string memory err) internal pure virtual {
 192 |     |         vm.assertEq(left, right, err);
 193 |     |     }
 194 |     | 
 195 |     |     function assertEq(bytes[] memory left, bytes[] memory right) internal pure virtual {
 196 |     |         vm.assertEq(left, right);
 197 |     |     }
 198 |     | 
 199 |     |     function assertEq(bytes[] memory left, bytes[] memory right, string memory err) internal pure virtual {
 200 |     |         vm.assertEq(left, right, err);
 201 |     |     }
 202 |     | 
 203 |     |     // Legacy helper
 204 |     |     function assertEqUint(uint256 left, uint256 right) internal pure virtual {
 205 |     |         assertEq(left, right);
 206 |     |     }
 207 |     | 
 208 |     |     function assertNotEq(bool left, bool right) internal pure virtual {
 209 |     |         vm.assertNotEq(left, right);
 210 |     |     }
 211 |     | 
 212 |     |     function assertNotEq(bool left, bool right, string memory err) internal pure virtual {
 213 |     |         vm.assertNotEq(left, right, err);
 214 |     |     }
 215 |     | 
 216 |     |     function assertNotEq(uint256 left, uint256 right) internal pure virtual {
 217 |     |         vm.assertNotEq(left, right);
 218 |     |     }
 219 |     | 
 220 |     |     function assertNotEq(uint256 left, uint256 right, string memory err) internal pure virtual {
 221 |     |         vm.assertNotEq(left, right, err);
 222 |     |     }
 223 |     | 
 224 |     |     function assertNotEqDecimal(uint256 left, uint256 right, uint256 decimals) internal pure virtual {
 225 |     |         vm.assertNotEqDecimal(left, right, decimals);
 226 |     |     }
 227 |     | 
 228 |     |     function assertNotEqDecimal(uint256 left, uint256 right, uint256 decimals, string memory err)
 229 |     |         internal
 230 |     |         pure
 231 |     |         virtual
 232 |     |     {
 233 |     |         vm.assertNotEqDecimal(left, right, decimals, err);
 234 |     |     }
 235 |     | 
 236 |     |     function assertNotEq(int256 left, int256 right) internal pure virtual {
 237 |     |         vm.assertNotEq(left, right);
 238 |     |     }
 239 |     | 
 240 |     |     function assertNotEq(int256 left, int256 right, string memory err) internal pure virtual {
 241 |     |         vm.assertNotEq(left, right, err);
 242 |     |     }
 243 |     | 
 244 |     |     function assertNotEqDecimal(int256 left, int256 right, uint256 decimals) internal pure virtual {
 245 |     |         vm.assertNotEqDecimal(left, right, decimals);
 246 |     |     }
 247 |     | 
 248 |     |     function assertNotEqDecimal(int256 left, int256 right, uint256 decimals, string memory err) internal pure virtual {
 249 |     |         vm.assertNotEqDecimal(left, right, decimals, err);
 250 |     |     }
 251 |     | 
 252 |     |     function assertNotEq(address left, address right) internal pure virtual {
 253 |     |         vm.assertNotEq(left, right);
 254 |     |     }
 255 |     | 
 256 |     |     function assertNotEq(address left, address right, string memory err) internal pure virtual {
 257 |     |         vm.assertNotEq(left, right, err);
 258 |     |     }
 259 |     | 
 260 |     |     function assertNotEq(bytes32 left, bytes32 right) internal pure virtual {
 261 |     |         vm.assertNotEq(left, right);
 262 |     |     }
 263 |     | 
 264 |     |     function assertNotEq(bytes32 left, bytes32 right, string memory err) internal pure virtual {
 265 |     |         vm.assertNotEq(left, right, err);
 266 |     |     }
 267 |     | 
 268 |     |     function assertNotEq32(bytes32 left, bytes32 right) internal pure virtual {
 269 |     |         assertNotEq(left, right);
 270 |     |     }
 271 |     | 
 272 |     |     function assertNotEq32(bytes32 left, bytes32 right, string memory err) internal pure virtual {
 273 |     |         assertNotEq(left, right, err);
 274 |     |     }
 275 |     | 
 276 |     |     function assertNotEq(string memory left, string memory right) internal pure virtual {
 277 |     |         vm.assertNotEq(left, right);
 278 |     |     }
 279 |     | 
 280 |     |     function assertNotEq(string memory left, string memory right, string memory err) internal pure virtual {
 281 |     |         vm.assertNotEq(left, right, err);
 282 |     |     }
 283 |     | 
 284 |     |     function assertNotEq(bytes memory left, bytes memory right) internal pure virtual {
 285 |     |         vm.assertNotEq(left, right);
 286 |     |     }
 287 |     | 
 288 |     |     function assertNotEq(bytes memory left, bytes memory right, string memory err) internal pure virtual {
 289 |     |         vm.assertNotEq(left, right, err);
 290 |     |     }
 291 |     | 
 292 |     |     function assertNotEq(bool[] memory left, bool[] memory right) internal pure virtual {
 293 |     |         vm.assertNotEq(left, right);
 294 |     |     }
 295 |     | 
 296 |     |     function assertNotEq(bool[] memory left, bool[] memory right, string memory err) internal pure virtual {
 297 |     |         vm.assertNotEq(left, right, err);
 298 |     |     }
 299 |     | 
 300 |     |     function assertNotEq(uint256[] memory left, uint256[] memory right) internal pure virtual {
 301 |     |         vm.assertNotEq(left, right);
 302 |     |     }
 303 |     | 
 304 |     |     function assertNotEq(uint256[] memory left, uint256[] memory right, string memory err) internal pure virtual {
 305 |     |         vm.assertNotEq(left, right, err);
 306 |     |     }
 307 |     | 
 308 |     |     function assertNotEq(int256[] memory left, int256[] memory right) internal pure virtual {
 309 |     |         vm.assertNotEq(left, right);
 310 |     |     }
 311 |     | 
 312 |     |     function assertNotEq(int256[] memory left, int256[] memory right, string memory err) internal pure virtual {
 313 |     |         vm.assertNotEq(left, right, err);
 314 |     |     }
 315 |     | 
 316 |     |     function assertNotEq(address[] memory left, address[] memory right) internal pure virtual {
 317 |     |         vm.assertNotEq(left, right);
 318 |     |     }
 319 |     | 
 320 |     |     function assertNotEq(address[] memory left, address[] memory right, string memory err) internal pure virtual {
 321 |     |         vm.assertNotEq(left, right, err);
 322 |     |     }
 323 |     | 
 324 |     |     function assertNotEq(bytes32[] memory left, bytes32[] memory right) internal pure virtual {
 325 |     |         vm.assertNotEq(left, right);
 326 |     |     }
 327 |     | 
 328 |     |     function assertNotEq(bytes32[] memory left, bytes32[] memory right, string memory err) internal pure virtual {
 329 |     |         vm.assertNotEq(left, right, err);
 330 |     |     }
 331 |     | 
 332 |     |     function assertNotEq(string[] memory left, string[] memory right) internal pure virtual {
 333 |     |         vm.assertNotEq(left, right);
 334 |     |     }
 335 |     | 
 336 |     |     function assertNotEq(string[] memory left, string[] memory right, string memory err) internal pure virtual {
 337 |     |         vm.assertNotEq(left, right, err);
 338 |     |     }
 339 |     | 
 340 |     |     function assertNotEq(bytes[] memory left, bytes[] memory right) internal pure virtual {
 341 |     |         vm.assertNotEq(left, right);
 342 |     |     }
 343 |     | 
 344 |     |     function assertNotEq(bytes[] memory left, bytes[] memory right, string memory err) internal pure virtual {
 345 |     |         vm.assertNotEq(left, right, err);
 346 |     |     }
 347 |     | 
 348 |     |     function assertLt(uint256 left, uint256 right) internal pure virtual {
 349 |     |         vm.assertLt(left, right);
 350 |     |     }
 351 |     | 
 352 |     |     function assertLt(uint256 left, uint256 right, string memory err) internal pure virtual {
 353 |     |         vm.assertLt(left, right, err);
 354 |     |     }
 355 |     | 
 356 |     |     function assertLtDecimal(uint256 left, uint256 right, uint256 decimals) internal pure virtual {
 357 |     |         vm.assertLtDecimal(left, right, decimals);
 358 |     |     }
 359 |     | 
 360 |     |     function assertLtDecimal(uint256 left, uint256 right, uint256 decimals, string memory err) internal pure virtual {
 361 |     |         vm.assertLtDecimal(left, right, decimals, err);
 362 |     |     }
 363 |     | 
 364 |     |     function assertLt(int256 left, int256 right) internal pure virtual {
 365 |     |         vm.assertLt(left, right);
 366 |     |     }
 367 |     | 
 368 |     |     function assertLt(int256 left, int256 right, string memory err) internal pure virtual {
 369 |     |         vm.assertLt(left, right, err);
 370 |     |     }
 371 |     | 
 372 |     |     function assertLtDecimal(int256 left, int256 right, uint256 decimals) internal pure virtual {
 373 |     |         vm.assertLtDecimal(left, right, decimals);
 374 |     |     }
 375 |     | 
 376 |     |     function assertLtDecimal(int256 left, int256 right, uint256 decimals, string memory err) internal pure virtual {
 377 |     |         vm.assertLtDecimal(left, right, decimals, err);
 378 |     |     }
 379 |     | 
 380 |     |     function assertGt(uint256 left, uint256 right) internal pure virtual {
 381 |     |         vm.assertGt(left, right);
 382 |     |     }
 383 |     | 
 384 |     |     function assertGt(uint256 left, uint256 right, string memory err) internal pure virtual {
 385 |     |         vm.assertGt(left, right, err);
 386 |     |     }
 387 |     | 
 388 |     |     function assertGtDecimal(uint256 left, uint256 right, uint256 decimals) internal pure virtual {
 389 |     |         vm.assertGtDecimal(left, right, decimals);
 390 |     |     }
 391 |     | 
 392 |     |     function assertGtDecimal(uint256 left, uint256 right, uint256 decimals, string memory err) internal pure virtual {
 393 |     |         vm.assertGtDecimal(left, right, decimals, err);
 394 |     |     }
 395 |     | 
 396 |     |     function assertGt(int256 left, int256 right) internal pure virtual {
 397 |     |         vm.assertGt(left, right);
 398 |     |     }
 399 |     | 
 400 |     |     function assertGt(int256 left, int256 right, string memory err) internal pure virtual {
 401 |     |         vm.assertGt(left, right, err);
 402 |     |     }
 403 |     | 
 404 |     |     function assertGtDecimal(int256 left, int256 right, uint256 decimals) internal pure virtual {
 405 |     |         vm.assertGtDecimal(left, right, decimals);
 406 |     |     }
 407 |     | 
 408 |     |     function assertGtDecimal(int256 left, int256 right, uint256 decimals, string memory err) internal pure virtual {
 409 |     |         vm.assertGtDecimal(left, right, decimals, err);
 410 |     |     }
 411 |     | 
 412 |     |     function assertLe(uint256 left, uint256 right) internal pure virtual {
 413 |     |         vm.assertLe(left, right);
 414 |     |     }
 415 |     | 
 416 |     |     function assertLe(uint256 left, uint256 right, string memory err) internal pure virtual {
 417 |     |         vm.assertLe(left, right, err);
 418 |     |     }
 419 |     | 
 420 |     |     function assertLeDecimal(uint256 left, uint256 right, uint256 decimals) internal pure virtual {
 421 |     |         vm.assertLeDecimal(left, right, decimals);
 422 |     |     }
 423 |     | 
 424 |     |     function assertLeDecimal(uint256 left, uint256 right, uint256 decimals, string memory err) internal pure virtual {
 425 |     |         vm.assertLeDecimal(left, right, decimals, err);
 426 |     |     }
 427 |     | 
 428 |     |     function assertLe(int256 left, int256 right) internal pure virtual {
 429 |     |         vm.assertLe(left, right);
 430 |     |     }
 431 |     | 
 432 |     |     function assertLe(int256 left, int256 right, string memory err) internal pure virtual {
 433 |     |         vm.assertLe(left, right, err);
 434 |     |     }
 435 |     | 
 436 |     |     function assertLeDecimal(int256 left, int256 right, uint256 decimals) internal pure virtual {
 437 |     |         vm.assertLeDecimal(left, right, decimals);
 438 |     |     }
 439 |     | 
 440 |     |     function assertLeDecimal(int256 left, int256 right, uint256 decimals, string memory err) internal pure virtual {
 441 |     |         vm.assertLeDecimal(left, right, decimals, err);
 442 |     |     }
 443 |     | 
 444 |     |     function assertGe(uint256 left, uint256 right) internal pure virtual {
 445 |     |         vm.assertGe(left, right);
 446 |     |     }
 447 |     | 
 448 |     |     function assertGe(uint256 left, uint256 right, string memory err) internal pure virtual {
 449 |     |         vm.assertGe(left, right, err);
 450 |     |     }
 451 |     | 
 452 |     |     function assertGeDecimal(uint256 left, uint256 right, uint256 decimals) internal pure virtual {
 453 |     |         vm.assertGeDecimal(left, right, decimals);
 454 |     |     }
 455 |     | 
 456 |     |     function assertGeDecimal(uint256 left, uint256 right, uint256 decimals, string memory err) internal pure virtual {
 457 |     |         vm.assertGeDecimal(left, right, decimals, err);
 458 |     |     }
 459 |     | 
 460 |     |     function assertGe(int256 left, int256 right) internal pure virtual {
 461 |     |         vm.assertGe(left, right);
 462 |     |     }
 463 |     | 
 464 |     |     function assertGe(int256 left, int256 right, string memory err) internal pure virtual {
 465 |     |         vm.assertGe(left, right, err);
 466 |     |     }
 467 |     | 
 468 |     |     function assertGeDecimal(int256 left, int256 right, uint256 decimals) internal pure virtual {
 469 |     |         vm.assertGeDecimal(left, right, decimals);
 470 |     |     }
 471 |     | 
 472 |     |     function assertGeDecimal(int256 left, int256 right, uint256 decimals, string memory err) internal pure virtual {
 473 |     |         vm.assertGeDecimal(left, right, decimals, err);
 474 |     |     }
 475 |     | 
 476 |     |     function assertApproxEqAbs(uint256 left, uint256 right, uint256 maxDelta) internal pure virtual {
 477 |     |         vm.assertApproxEqAbs(left, right, maxDelta);
 478 |     |     }
 479 |     | 
 480 |     |     function assertApproxEqAbs(uint256 left, uint256 right, uint256 maxDelta, string memory err)
 481 |     |         internal
 482 |     |         pure
 483 |     |         virtual
 484 |     |     {
 485 |     |         vm.assertApproxEqAbs(left, right, maxDelta, err);
 486 |     |     }
 487 |     | 
 488 |     |     function assertApproxEqAbsDecimal(uint256 left, uint256 right, uint256 maxDelta, uint256 decimals)
 489 |     |         internal
 490 |     |         pure
 491 |     |         virtual
 492 |     |     {
 493 |     |         vm.assertApproxEqAbsDecimal(left, right, maxDelta, decimals);
 494 |     |     }
 495 |     | 
 496 |     |     function assertApproxEqAbsDecimal(
 497 |     |         uint256 left,
 498 |     |         uint256 right,
 499 |     |         uint256 maxDelta,
 500 |     |         uint256 decimals,
 501 |     |         string memory err
 502 |     |     ) internal pure virtual {
 503 |     |         vm.assertApproxEqAbsDecimal(left, right, maxDelta, decimals, err);
 504 |     |     }
 505 |     | 
 506 |     |     function assertApproxEqAbs(int256 left, int256 right, uint256 maxDelta) internal pure virtual {
 507 |     |         vm.assertApproxEqAbs(left, right, maxDelta);
 508 |     |     }
 509 |     | 
 510 |     |     function assertApproxEqAbs(int256 left, int256 right, uint256 maxDelta, string memory err) internal pure virtual {
 511 |     |         vm.assertApproxEqAbs(left, right, maxDelta, err);
 512 |     |     }
 513 |     | 
 514 |     |     function assertApproxEqAbsDecimal(int256 left, int256 right, uint256 maxDelta, uint256 decimals)
 515 |     |         internal
 516 |     |         pure
 517 |     |         virtual
 518 |     |     {
 519 |     |         vm.assertApproxEqAbsDecimal(left, right, maxDelta, decimals);
 520 |     |     }
 521 |     | 
 522 |     |     function assertApproxEqAbsDecimal(int256 left, int256 right, uint256 maxDelta, uint256 decimals, string memory err)
 523 |     |         internal
 524 |     |         pure
 525 |     |         virtual
 526 |     |     {
 527 |     |         vm.assertApproxEqAbsDecimal(left, right, maxDelta, decimals, err);
 528 |     |     }
 529 |     | 
 530 |     |     function assertApproxEqRel(
 531 |     |         uint256 left,
 532 |     |         uint256 right,
 533 |     |         uint256 maxPercentDelta // An 18 decimal fixed point number, where 1e18 == 100%
 534 |     |     ) internal pure virtual {
 535 |     |         vm.assertApproxEqRel(left, right, maxPercentDelta);
 536 |     |     }
 537 |     | 
 538 |     |     function assertApproxEqRel(
 539 |     |         uint256 left,
 540 |     |         uint256 right,
 541 |     |         uint256 maxPercentDelta, // An 18 decimal fixed point number, where 1e18 == 100%
 542 |     |         string memory err
 543 |     |     ) internal pure virtual {
 544 |     |         vm.assertApproxEqRel(left, right, maxPercentDelta, err);
 545 |     |     }
 546 |     | 
 547 |     |     function assertApproxEqRelDecimal(
 548 |     |         uint256 left,
 549 |     |         uint256 right,
 550 |     |         uint256 maxPercentDelta, // An 18 decimal fixed point number, where 1e18 == 100%
 551 |     |         uint256 decimals
 552 |     |     ) internal pure virtual {
 553 |     |         vm.assertApproxEqRelDecimal(left, right, maxPercentDelta, decimals);
 554 |     |     }
 555 |     | 
 556 |     |     function assertApproxEqRelDecimal(
 557 |     |         uint256 left,
 558 |     |         uint256 right,
 559 |     |         uint256 maxPercentDelta, // An 18 decimal fixed point number, where 1e18 == 100%
 560 |     |         uint256 decimals,
 561 |     |         string memory err
 562 |     |     ) internal pure virtual {
 563 |     |         vm.assertApproxEqRelDecimal(left, right, maxPercentDelta, decimals, err);
 564 |     |     }
 565 |     | 
 566 |     |     function assertApproxEqRel(int256 left, int256 right, uint256 maxPercentDelta) internal pure virtual {
 567 |     |         vm.assertApproxEqRel(left, right, maxPercentDelta);
 568 |     |     }
 569 |     | 
 570 |     |     function assertApproxEqRel(
 571 |     |         int256 left,
 572 |     |         int256 right,
 573 |     |         uint256 maxPercentDelta, // An 18 decimal fixed point number, where 1e18 == 100%
 574 |     |         string memory err
 575 |     |     ) internal pure virtual {
 576 |     |         vm.assertApproxEqRel(left, right, maxPercentDelta, err);
 577 |     |     }
 578 |     | 
 579 |     |     function assertApproxEqRelDecimal(
 580 |     |         int256 left,
 581 |     |         int256 right,
 582 |     |         uint256 maxPercentDelta, // An 18 decimal fixed point number, where 1e18 == 100%
 583 |     |         uint256 decimals
 584 |     |     ) internal pure virtual {
 585 |     |         vm.assertApproxEqRelDecimal(left, right, maxPercentDelta, decimals);
 586 |     |     }
 587 |     | 
 588 |     |     function assertApproxEqRelDecimal(
 589 |     |         int256 left,
 590 |     |         int256 right,
 591 |     |         uint256 maxPercentDelta, // An 18 decimal fixed point number, where 1e18 == 100%
 592 |     |         uint256 decimals,
 593 |     |         string memory err
 594 |     |     ) internal pure virtual {
 595 |     |         vm.assertApproxEqRelDecimal(left, right, maxPercentDelta, decimals, err);
 596 |     |     }
 597 |     | 
 598 |     |     // Inherited from DSTest, not used but kept for backwards-compatibility
 599 |     |     function checkEq0(bytes memory left, bytes memory right) internal pure returns (bool) {
 600 |     |         return keccak256(left) == keccak256(right);
 601 |     |     }
 602 |     | 
 603 |     |     function assertEq0(bytes memory left, bytes memory right) internal pure virtual {
 604 |     |         assertEq(left, right);
 605 |     |     }
 606 |     | 
 607 |     |     function assertEq0(bytes memory left, bytes memory right, string memory err) internal pure virtual {
 608 |     |         assertEq(left, right, err);
 609 |     |     }
 610 |     | 
 611 |     |     function assertNotEq0(bytes memory left, bytes memory right) internal pure virtual {
 612 |     |         assertNotEq(left, right);
 613 |     |     }
 614 |     | 
 615 |     |     function assertNotEq0(bytes memory left, bytes memory right, string memory err) internal pure virtual {
 616 |     |         assertNotEq(left, right, err);
 617 |     |     }
 618 |     | 
 619 |     |     function assertEqCall(address target, bytes memory callDataA, bytes memory callDataB) internal virtual {
 620 |     |         assertEqCall(target, callDataA, target, callDataB, true);
 621 |     |     }
 622 |     | 
 623 |     |     function assertEqCall(address targetA, bytes memory callDataA, address targetB, bytes memory callDataB)
 624 |     |         internal
 625 |     |         virtual
 626 |     |     {
 627 |     |         assertEqCall(targetA, callDataA, targetB, callDataB, true);
 628 |     |     }
 629 |     | 
 630 |     |     function assertEqCall(address target, bytes memory callDataA, bytes memory callDataB, bool strictRevertData)
 631 |     |         internal
 632 |     |         virtual
 633 |     |     {
 634 |     |         assertEqCall(target, callDataA, target, callDataB, strictRevertData);
 635 |     |     }
 636 |     | 
 637 |     |     function assertEqCall(
 638 |     |         address targetA,
 639 |     |         bytes memory callDataA,
 640 |     |         address targetB,
 641 |     |         bytes memory callDataB,
 642 |     |         bool strictRevertData
 643 |     |     ) internal virtual {
 644 |     |         (bool successA, bytes memory returnDataA) = address(targetA).call(callDataA);
 645 |     |         (bool successB, bytes memory returnDataB) = address(targetB).call(callDataB);
 646 |     | 
 647 |     |         if (successA && successB) {
 648 |     |             assertEq(returnDataA, returnDataB, "Call return data does not match");
 649 |     |         }
 650 |     | 
 651 |     |         if (!successA && !successB && strictRevertData) {
 652 |     |             assertEq(returnDataA, returnDataB, "Call revert data does not match");
 653 |     |         }
 654 |     | 
 655 |     |         if (!successA && successB) {
 656 |     |             emit log("Error: Calls were not equal");
 657 |     |             emit log_named_bytes("  Left call revert data", returnDataA);
 658 |     |             emit log_named_bytes(" Right call return data", returnDataB);
 659 |     |             revert("assertion failed");
 660 |     |         }
 661 |     | 
 662 |     |         if (successA && !successB) {
 663 |     |             emit log("Error: Calls were not equal");
 664 |     |             emit log_named_bytes("  Left call return data", returnDataA);
 665 |     |             emit log_named_bytes(" Right call revert data", returnDataB);
 666 |     |             revert("assertion failed");
 667 |     |         }
 668 |     |     }
 669 |     | }
 670 |     | 

/home/phantom/Documents/azemora/azemora-contracts/lib/forge-std/src/StdChains.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | pragma solidity >=0.6.2 <0.9.0;
   3 |     | 
   4 |     | import {VmSafe} from "./Vm.sol";
   5 |     | 
   6 |     | /**
   7 |     |  * StdChains provides information about EVM compatible chains that can be used in scripts/tests.
   8 |     |  * For each chain, the chain's name, chain ID, and a default RPC URL are provided. Chains are
   9 |     |  * identified by their alias, which is the same as the alias in the `[rpc_endpoints]` section of
  10 |     |  * the `foundry.toml` file. For best UX, ensure the alias in the `foundry.toml` file match the
  11 |     |  * alias used in this contract, which can be found as the first argument to the
  12 |     |  * `setChainWithDefaultRpcUrl` call in the `initializeStdChains` function.
  13 |     |  *
  14 |     |  * There are two main ways to use this contract:
  15 |     |  *   1. Set a chain with `setChain(string memory chainAlias, ChainData memory chain)` or
  16 |     |  *      `setChain(string memory chainAlias, Chain memory chain)`
  17 |     |  *   2. Get a chain with `getChain(string memory chainAlias)` or `getChain(uint256 chainId)`.
  18 |     |  *
  19 |     |  * The first time either of those are used, chains are initialized with the default set of RPC URLs.
  20 |     |  * This is done in `initializeStdChains`, which uses `setChainWithDefaultRpcUrl`. Defaults are recorded in
  21 |     |  * `defaultRpcUrls`.
  22 |     |  *
  23 |     |  * The `setChain` function is straightforward, and it simply saves off the given chain data.
  24 |     |  *
  25 |     |  * The `getChain` methods use `getChainWithUpdatedRpcUrl` to return a chain. For example, let's say
  26 |     |  * we want to retrieve the RPC URL for `mainnet`:
  27 |     |  *   - If you have specified data with `setChain`, it will return that.
  28 |     |  *   - If you have configured a mainnet RPC URL in `foundry.toml`, it will return the URL, provided it
  29 |     |  *     is valid (e.g. a URL is specified, or an environment variable is given and exists).
  30 |     |  *   - If neither of the above conditions is met, the default data is returned.
  31 |     |  *
  32 |     |  * Summarizing the above, the prioritization hierarchy is `setChain` -> `foundry.toml` -> environment variable -> defaults.
  33 |     |  */
  34 |     | abstract contract StdChains {
  35 |     |     VmSafe private constant vm = VmSafe(address(uint160(uint256(keccak256("hevm cheat code")))));
  36 |     | 
  37 |     |     bool private stdChainsInitialized;
  38 |     | 
  39 |     |     struct ChainData {
  40 |     |         string name;
  41 |     |         uint256 chainId;
  42 |     |         string rpcUrl;
  43 |     |     }
  44 |     | 
  45 |     |     struct Chain {
  46 |     |         // The chain name.
  47 |     |         string name;
  48 |     |         // The chain's Chain ID.
  49 |     |         uint256 chainId;
  50 |     |         // The chain's alias. (i.e. what gets specified in `foundry.toml`).
  51 |     |         string chainAlias;
  52 |     |         // A default RPC endpoint for this chain.
  53 |     |         // NOTE: This default RPC URL is included for convenience to facilitate quick tests and
  54 |     |         // experimentation. Do not use this RPC URL for production test suites, CI, or other heavy
  55 |     |         // usage as you will be throttled and this is a disservice to others who need this endpoint.
  56 |     |         string rpcUrl;
  57 |     |     }
  58 |     | 
  59 |     |     // Maps from the chain's alias (matching the alias in the `foundry.toml` file) to chain data.
  60 |     |     mapping(string => Chain) private chains;
  61 |     |     // Maps from the chain's alias to it's default RPC URL.
  62 |     |     mapping(string => string) private defaultRpcUrls;
  63 |     |     // Maps from a chain ID to it's alias.
  64 |     |     mapping(uint256 => string) private idToAlias;
  65 |     | 
  66 | *   |     bool private fallbackToDefaultRpcUrls = true;
  67 |     | 
  68 |     |     // The RPC URL will be fetched from config or defaultRpcUrls if possible.
  69 |     |     function getChain(string memory chainAlias) internal virtual returns (Chain memory chain) {
  70 |     |         require(bytes(chainAlias).length != 0, "StdChains getChain(string): Chain alias cannot be the empty string.");
  71 |     | 
  72 |     |         initializeStdChains();
  73 |     |         chain = chains[chainAlias];
  74 |     |         require(
  75 |     |             chain.chainId != 0,
  76 |     |             string(abi.encodePacked("StdChains getChain(string): Chain with alias \"", chainAlias, "\" not found."))
  77 |     |         );
  78 |     | 
  79 |     |         chain = getChainWithUpdatedRpcUrl(chainAlias, chain);
  80 |     |     }
  81 |     | 
  82 |     |     function getChain(uint256 chainId) internal virtual returns (Chain memory chain) {
  83 |     |         require(chainId != 0, "StdChains getChain(uint256): Chain ID cannot be 0.");
  84 |     |         initializeStdChains();
  85 |     |         string memory chainAlias = idToAlias[chainId];
  86 |     | 
  87 |     |         chain = chains[chainAlias];
  88 |     | 
  89 |     |         require(
  90 |     |             chain.chainId != 0,
  91 |     |             string(abi.encodePacked("StdChains getChain(uint256): Chain with ID ", vm.toString(chainId), " not found."))
  92 |     |         );
  93 |     | 
  94 |     |         chain = getChainWithUpdatedRpcUrl(chainAlias, chain);
  95 |     |     }
  96 |     | 
  97 |     |     // set chain info, with priority to argument's rpcUrl field.
  98 |     |     function setChain(string memory chainAlias, ChainData memory chain) internal virtual {
  99 |     |         require(
 100 |     |             bytes(chainAlias).length != 0,
 101 |     |             "StdChains setChain(string,ChainData): Chain alias cannot be the empty string."
 102 |     |         );
 103 |     | 
 104 |     |         require(chain.chainId != 0, "StdChains setChain(string,ChainData): Chain ID cannot be 0.");
 105 |     | 
 106 |     |         initializeStdChains();
 107 |     |         string memory foundAlias = idToAlias[chain.chainId];
 108 |     | 
 109 |     |         require(
 110 |     |             bytes(foundAlias).length == 0 || keccak256(bytes(foundAlias)) == keccak256(bytes(chainAlias)),
 111 |     |             string(
 112 |     |                 abi.encodePacked(
 113 |     |                     "StdChains setChain(string,ChainData): Chain ID ",
 114 |     |                     vm.toString(chain.chainId),
 115 |     |                     " already used by \"",
 116 |     |                     foundAlias,
 117 |     |                     "\"."
 118 |     |                 )
 119 |     |             )
 120 |     |         );
 121 |     | 
 122 |     |         uint256 oldChainId = chains[chainAlias].chainId;
 123 |     |         delete idToAlias[oldChainId];
 124 |     | 
 125 |     |         chains[chainAlias] =
 126 |     |             Chain({name: chain.name, chainId: chain.chainId, chainAlias: chainAlias, rpcUrl: chain.rpcUrl});
 127 |     |         idToAlias[chain.chainId] = chainAlias;
 128 |     |     }
 129 |     | 
 130 |     |     // set chain info, with priority to argument's rpcUrl field.
 131 |     |     function setChain(string memory chainAlias, Chain memory chain) internal virtual {
 132 |     |         setChain(chainAlias, ChainData({name: chain.name, chainId: chain.chainId, rpcUrl: chain.rpcUrl}));
 133 |     |     }
 134 |     | 
 135 |     |     function _toUpper(string memory str) private pure returns (string memory) {
 136 |     |         bytes memory strb = bytes(str);
 137 |     |         bytes memory copy = new bytes(strb.length);
 138 |     |         for (uint256 i = 0; i < strb.length; i++) {
 139 |     |             bytes1 b = strb[i];
 140 |     |             if (b >= 0x61 && b <= 0x7A) {
 141 |     |                 copy[i] = bytes1(uint8(b) - 32);
 142 |     |             } else {
 143 |     |                 copy[i] = b;
 144 |     |             }
 145 |     |         }
 146 |     |         return string(copy);
 147 |     |     }
 148 |     | 
 149 |     |     // lookup rpcUrl, in descending order of priority:
 150 |     |     // current -> config (foundry.toml) -> environment variable -> default
 151 |     |     function getChainWithUpdatedRpcUrl(string memory chainAlias, Chain memory chain)
 152 |     |         private
 153 |     |         view
 154 |     |         returns (Chain memory)
 155 |     |     {
 156 |     |         if (bytes(chain.rpcUrl).length == 0) {
 157 |     |             try vm.rpcUrl(chainAlias) returns (string memory configRpcUrl) {
 158 |     |                 chain.rpcUrl = configRpcUrl;
 159 |     |             } catch (bytes memory err) {
 160 |     |                 string memory envName = string(abi.encodePacked(_toUpper(chainAlias), "_RPC_URL"));
 161 |     |                 if (fallbackToDefaultRpcUrls) {
 162 |     |                     chain.rpcUrl = vm.envOr(envName, defaultRpcUrls[chainAlias]);
 163 |     |                 } else {
 164 |     |                     chain.rpcUrl = vm.envString(envName);
 165 |     |                 }
 166 |     |                 // Distinguish 'not found' from 'cannot read'
 167 |     |                 // The upstream error thrown by forge for failing cheats changed so we check both the old and new versions
 168 |     |                 bytes memory oldNotFoundError =
 169 |     |                     abi.encodeWithSignature("CheatCodeError", string(abi.encodePacked("invalid rpc url ", chainAlias)));
 170 |     |                 bytes memory newNotFoundError = abi.encodeWithSignature(
 171 |     |                     "CheatcodeError(string)", string(abi.encodePacked("invalid rpc url: ", chainAlias))
 172 |     |                 );
 173 |     |                 bytes32 errHash = keccak256(err);
 174 |     |                 if (
 175 |     |                     (errHash != keccak256(oldNotFoundError) && errHash != keccak256(newNotFoundError))
 176 |     |                         || bytes(chain.rpcUrl).length == 0
 177 |     |                 ) {
 178 |     |                     /// @solidity memory-safe-assembly
 179 |     |                     assembly {
 180 |     |                         revert(add(32, err), mload(err))
 181 |     |                     }
 182 |     |                 }
 183 |     |             }
 184 |     |         }
 185 |     |         return chain;
 186 |     |     }
 187 |     | 
 188 |     |     function setFallbackToDefaultRpcUrls(bool useDefault) internal {
 189 |     |         fallbackToDefaultRpcUrls = useDefault;
 190 |     |     }
 191 |     | 
 192 |     |     function initializeStdChains() private {
 193 |     |         if (stdChainsInitialized) return;
 194 |     | 
 195 |     |         stdChainsInitialized = true;
 196 |     | 
 197 |     |         // If adding an RPC here, make sure to test the default RPC URL in `test_Rpcs` in `StdChains.t.sol`
 198 |     |         setChainWithDefaultRpcUrl("anvil", ChainData("Anvil", 31337, "http://127.0.0.1:8545"));
 199 |     |         setChainWithDefaultRpcUrl("mainnet", ChainData("Mainnet", 1, "https://eth.llamarpc.com"));
 200 |     |         setChainWithDefaultRpcUrl(
 201 |     |             "sepolia", ChainData("Sepolia", 11155111, "https://sepolia.infura.io/v3/b9794ad1ddf84dfb8c34d6bb5dca2001")
 202 |     |         );
 203 |     |         setChainWithDefaultRpcUrl("holesky", ChainData("Holesky", 17000, "https://rpc.holesky.ethpandaops.io"));
 204 |     |         setChainWithDefaultRpcUrl("hoodi", ChainData("Hoodi", 560048, "https://rpc.hoodi.ethpandaops.io"));
 205 |     |         setChainWithDefaultRpcUrl("optimism", ChainData("Optimism", 10, "https://mainnet.optimism.io"));
 206 |     |         setChainWithDefaultRpcUrl(
 207 |     |             "optimism_sepolia", ChainData("Optimism Sepolia", 11155420, "https://sepolia.optimism.io")
 208 |     |         );
 209 |     |         setChainWithDefaultRpcUrl("arbitrum_one", ChainData("Arbitrum One", 42161, "https://arb1.arbitrum.io/rpc"));
 210 |     |         setChainWithDefaultRpcUrl(
 211 |     |             "arbitrum_one_sepolia", ChainData("Arbitrum One Sepolia", 421614, "https://sepolia-rollup.arbitrum.io/rpc")
 212 |     |         );
 213 |     |         setChainWithDefaultRpcUrl("arbitrum_nova", ChainData("Arbitrum Nova", 42170, "https://nova.arbitrum.io/rpc"));
 214 |     |         setChainWithDefaultRpcUrl("polygon", ChainData("Polygon", 137, "https://polygon-rpc.com"));
 215 |     |         setChainWithDefaultRpcUrl(
 216 |     |             "polygon_amoy", ChainData("Polygon Amoy", 80002, "https://rpc-amoy.polygon.technology")
 217 |     |         );
 218 |     |         setChainWithDefaultRpcUrl("avalanche", ChainData("Avalanche", 43114, "https://api.avax.network/ext/bc/C/rpc"));
 219 |     |         setChainWithDefaultRpcUrl(
 220 |     |             "avalanche_fuji", ChainData("Avalanche Fuji", 43113, "https://api.avax-test.network/ext/bc/C/rpc")
 221 |     |         );
 222 |     |         setChainWithDefaultRpcUrl(
 223 |     |             "bnb_smart_chain", ChainData("BNB Smart Chain", 56, "https://bsc-dataseed1.binance.org")
 224 |     |         );
 225 |     |         setChainWithDefaultRpcUrl(
 226 |     |             "bnb_smart_chain_testnet",
 227 |     |             ChainData("BNB Smart Chain Testnet", 97, "https://rpc.ankr.com/bsc_testnet_chapel")
 228 |     |         );
 229 |     |         setChainWithDefaultRpcUrl("gnosis_chain", ChainData("Gnosis Chain", 100, "https://rpc.gnosischain.com"));
 230 |     |         setChainWithDefaultRpcUrl("moonbeam", ChainData("Moonbeam", 1284, "https://rpc.api.moonbeam.network"));
 231 |     |         setChainWithDefaultRpcUrl(
 232 |     |             "moonriver", ChainData("Moonriver", 1285, "https://rpc.api.moonriver.moonbeam.network")
 233 |     |         );
 234 |     |         setChainWithDefaultRpcUrl("moonbase", ChainData("Moonbase", 1287, "https://rpc.testnet.moonbeam.network"));
 235 |     |         setChainWithDefaultRpcUrl("base_sepolia", ChainData("Base Sepolia", 84532, "https://sepolia.base.org"));
 236 |     |         setChainWithDefaultRpcUrl("base", ChainData("Base", 8453, "https://mainnet.base.org"));
 237 |     |         setChainWithDefaultRpcUrl("blast_sepolia", ChainData("Blast Sepolia", 168587773, "https://sepolia.blast.io"));
 238 |     |         setChainWithDefaultRpcUrl("blast", ChainData("Blast", 81457, "https://rpc.blast.io"));
 239 |     |         setChainWithDefaultRpcUrl("fantom_opera", ChainData("Fantom Opera", 250, "https://rpc.ankr.com/fantom/"));
 240 |     |         setChainWithDefaultRpcUrl(
 241 |     |             "fantom_opera_testnet", ChainData("Fantom Opera Testnet", 4002, "https://rpc.ankr.com/fantom_testnet/")
 242 |     |         );
 243 |     |         setChainWithDefaultRpcUrl("fraxtal", ChainData("Fraxtal", 252, "https://rpc.frax.com"));
 244 |     |         setChainWithDefaultRpcUrl("fraxtal_testnet", ChainData("Fraxtal Testnet", 2522, "https://rpc.testnet.frax.com"));
 245 |     |         setChainWithDefaultRpcUrl(
 246 |     |             "berachain_bartio_testnet", ChainData("Berachain bArtio Testnet", 80084, "https://bartio.rpc.berachain.com")
 247 |     |         );
 248 |     |         setChainWithDefaultRpcUrl("flare", ChainData("Flare", 14, "https://flare-api.flare.network/ext/C/rpc"));
 249 |     |         setChainWithDefaultRpcUrl(
 250 |     |             "flare_coston2", ChainData("Flare Coston2", 114, "https://coston2-api.flare.network/ext/C/rpc")
 251 |     |         );
 252 |     | 
 253 |     |         setChainWithDefaultRpcUrl("mode", ChainData("Mode", 34443, "https://mode.drpc.org"));
 254 |     |         setChainWithDefaultRpcUrl("mode_sepolia", ChainData("Mode Sepolia", 919, "https://sepolia.mode.network"));
 255 |     | 
 256 |     |         setChainWithDefaultRpcUrl("zora", ChainData("Zora", 7777777, "https://zora.drpc.org"));
 257 |     |         setChainWithDefaultRpcUrl(
 258 |     |             "zora_sepolia", ChainData("Zora Sepolia", 999999999, "https://sepolia.rpc.zora.energy")
 259 |     |         );
 260 |     | 
 261 |     |         setChainWithDefaultRpcUrl("race", ChainData("Race", 6805, "https://racemainnet.io"));
 262 |     |         setChainWithDefaultRpcUrl("race_sepolia", ChainData("Race Sepolia", 6806, "https://racemainnet.io"));
 263 |     | 
 264 |     |         setChainWithDefaultRpcUrl("metal", ChainData("Metal", 1750, "https://metall2.drpc.org"));
 265 |     |         setChainWithDefaultRpcUrl("metal_sepolia", ChainData("Metal Sepolia", 1740, "https://testnet.rpc.metall2.com"));
 266 |     | 
 267 |     |         setChainWithDefaultRpcUrl("binary", ChainData("Binary", 624, "https://rpc.zero.thebinaryholdings.com"));
 268 |     |         setChainWithDefaultRpcUrl(
 269 |     |             "binary_sepolia", ChainData("Binary Sepolia", 625, "https://rpc.zero.thebinaryholdings.com")
 270 |     |         );
 271 |     | 
 272 |     |         setChainWithDefaultRpcUrl("orderly", ChainData("Orderly", 291, "https://rpc.orderly.network"));
 273 |     |         setChainWithDefaultRpcUrl(
 274 |     |             "orderly_sepolia", ChainData("Orderly Sepolia", 4460, "https://testnet-rpc.orderly.org")
 275 |     |         );
 276 |     |     }
 277 |     | 
 278 |     |     // set chain info, with priority to chainAlias' rpc url in foundry.toml
 279 |     |     function setChainWithDefaultRpcUrl(string memory chainAlias, ChainData memory chain) private {
 280 |     |         string memory rpcUrl = chain.rpcUrl;
 281 |     |         defaultRpcUrls[chainAlias] = rpcUrl;
 282 |     |         chain.rpcUrl = "";
 283 |     |         setChain(chainAlias, chain);
 284 |     |         chain.rpcUrl = rpcUrl; // restore argument
 285 |     |     }
 286 |     | }
 287 |     | 

/home/phantom/Documents/azemora/azemora-contracts/lib/forge-std/src/StdCheats.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | pragma solidity >=0.6.2 <0.9.0;
   3 |     | 
   4 |     | pragma experimental ABIEncoderV2;
   5 |     | 
   6 |     | import {StdStorage, stdStorage} from "./StdStorage.sol";
   7 |     | import {console2} from "./console2.sol";
   8 |     | import {Vm} from "./Vm.sol";
   9 |     | 
  10 |     | abstract contract StdCheatsSafe {
  11 |     |     Vm private constant vm = Vm(address(uint160(uint256(keccak256("hevm cheat code")))));
  12 |     | 
  13 |     |     uint256 private constant UINT256_MAX =
  14 |     |         115792089237316195423570985008687907853269984665640564039457584007913129639935;
  15 |     | 
  16 |     |     bool private gasMeteringOff;
  17 |     | 
  18 |     |     // Data structures to parse Transaction objects from the broadcast artifact
  19 |     |     // that conform to EIP1559. The Raw structs is what is parsed from the JSON
  20 |     |     // and then converted to the one that is used by the user for better UX.
  21 |     | 
  22 |     |     struct RawTx1559 {
  23 |     |         string[] arguments;
  24 |     |         address contractAddress;
  25 |     |         string contractName;
  26 |     |         // json value name = function
  27 |     |         string functionSig;
  28 |     |         bytes32 hash;
  29 |     |         // json value name = tx
  30 |     |         RawTx1559Detail txDetail;
  31 |     |         // json value name = type
  32 |     |         string opcode;
  33 |     |     }
  34 |     | 
  35 |     |     struct RawTx1559Detail {
  36 |     |         AccessList[] accessList;
  37 |     |         bytes data;
  38 |     |         address from;
  39 |     |         bytes gas;
  40 |     |         bytes nonce;
  41 |     |         address to;
  42 |     |         bytes txType;
  43 |     |         bytes value;
  44 |     |     }
  45 |     | 
  46 |     |     struct Tx1559 {
  47 |     |         string[] arguments;
  48 |     |         address contractAddress;
  49 |     |         string contractName;
  50 |     |         string functionSig;
  51 |     |         bytes32 hash;
  52 |     |         Tx1559Detail txDetail;
  53 |     |         string opcode;
  54 |     |     }
  55 |     | 
  56 |     |     struct Tx1559Detail {
  57 |     |         AccessList[] accessList;
  58 |     |         bytes data;
  59 |     |         address from;
  60 |     |         uint256 gas;
  61 |     |         uint256 nonce;
  62 |     |         address to;
  63 |     |         uint256 txType;
  64 |     |         uint256 value;
  65 |     |     }
  66 |     | 
  67 |     |     // Data structures to parse Transaction objects from the broadcast artifact
  68 |     |     // that DO NOT conform to EIP1559. The Raw structs is what is parsed from the JSON
  69 |     |     // and then converted to the one that is used by the user for better UX.
  70 |     | 
  71 |     |     struct TxLegacy {
  72 |     |         string[] arguments;
  73 |     |         address contractAddress;
  74 |     |         string contractName;
  75 |     |         string functionSig;
  76 |     |         string hash;
  77 |     |         string opcode;
  78 |     |         TxDetailLegacy transaction;
  79 |     |     }
  80 |     | 
  81 |     |     struct TxDetailLegacy {
  82 |     |         AccessList[] accessList;
  83 |     |         uint256 chainId;
  84 |     |         bytes data;
  85 |     |         address from;
  86 |     |         uint256 gas;
  87 |     |         uint256 gasPrice;
  88 |     |         bytes32 hash;
  89 |     |         uint256 nonce;
  90 |     |         bytes1 opcode;
  91 |     |         bytes32 r;
  92 |     |         bytes32 s;
  93 |     |         uint256 txType;
  94 |     |         address to;
  95 |     |         uint8 v;
  96 |     |         uint256 value;
  97 |     |     }
  98 |     | 
  99 |     |     struct AccessList {
 100 |     |         address accessAddress;
 101 |     |         bytes32[] storageKeys;
 102 |     |     }
 103 |     | 
 104 |     |     // Data structures to parse Receipt objects from the broadcast artifact.
 105 |     |     // The Raw structs is what is parsed from the JSON
 106 |     |     // and then converted to the one that is used by the user for better UX.
 107 |     | 
 108 |     |     struct RawReceipt {
 109 |     |         bytes32 blockHash;
 110 |     |         bytes blockNumber;
 111 |     |         address contractAddress;
 112 |     |         bytes cumulativeGasUsed;
 113 |     |         bytes effectiveGasPrice;
 114 |     |         address from;
 115 |     |         bytes gasUsed;
 116 |     |         RawReceiptLog[] logs;
 117 |     |         bytes logsBloom;
 118 |     |         bytes status;
 119 |     |         address to;
 120 |     |         bytes32 transactionHash;
 121 |     |         bytes transactionIndex;
 122 |     |     }
 123 |     | 
 124 |     |     struct Receipt {
 125 |     |         bytes32 blockHash;
 126 |     |         uint256 blockNumber;
 127 |     |         address contractAddress;
 128 |     |         uint256 cumulativeGasUsed;
 129 |     |         uint256 effectiveGasPrice;
 130 |     |         address from;
 131 |     |         uint256 gasUsed;
 132 |     |         ReceiptLog[] logs;
 133 |     |         bytes logsBloom;
 134 |     |         uint256 status;
 135 |     |         address to;
 136 |     |         bytes32 transactionHash;
 137 |     |         uint256 transactionIndex;
 138 |     |     }
 139 |     | 
 140 |     |     // Data structures to parse the entire broadcast artifact, assuming the
 141 |     |     // transactions conform to EIP1559.
 142 |     | 
 143 |     |     struct EIP1559ScriptArtifact {
 144 |     |         string[] libraries;
 145 |     |         string path;
 146 |     |         string[] pending;
 147 |     |         Receipt[] receipts;
 148 |     |         uint256 timestamp;
 149 |     |         Tx1559[] transactions;
 150 |     |         TxReturn[] txReturns;
 151 |     |     }
 152 |     | 
 153 |     |     struct RawEIP1559ScriptArtifact {
 154 |     |         string[] libraries;
 155 |     |         string path;
 156 |     |         string[] pending;
 157 |     |         RawReceipt[] receipts;
 158 |     |         TxReturn[] txReturns;
 159 |     |         uint256 timestamp;
 160 |     |         RawTx1559[] transactions;
 161 |     |     }
 162 |     | 
 163 |     |     struct RawReceiptLog {
 164 |     |         // json value = address
 165 |     |         address logAddress;
 166 |     |         bytes32 blockHash;
 167 |     |         bytes blockNumber;
 168 |     |         bytes data;
 169 |     |         bytes logIndex;
 170 |     |         bool removed;
 171 |     |         bytes32[] topics;
 172 |     |         bytes32 transactionHash;
 173 |     |         bytes transactionIndex;
 174 |     |         bytes transactionLogIndex;
 175 |     |     }
 176 |     | 
 177 |     |     struct ReceiptLog {
 178 |     |         // json value = address
 179 |     |         address logAddress;
 180 |     |         bytes32 blockHash;
 181 |     |         uint256 blockNumber;
 182 |     |         bytes data;
 183 |     |         uint256 logIndex;
 184 |     |         bytes32[] topics;
 185 |     |         uint256 transactionIndex;
 186 |     |         uint256 transactionLogIndex;
 187 |     |         bool removed;
 188 |     |     }
 189 |     | 
 190 |     |     struct TxReturn {
 191 |     |         string internalType;
 192 |     |         string value;
 193 |     |     }
 194 |     | 
 195 |     |     struct Account {
 196 |     |         address addr;
 197 |     |         uint256 key;
 198 |     |     }
 199 |     | 
 200 |     |     enum AddressType {
 201 |     |         Payable,
 202 |     |         NonPayable,
 203 |     |         ZeroAddress,
 204 |     |         Precompile,
 205 |     |         ForgeAddress
 206 |     |     }
 207 |     | 
 208 |     |     // Checks that `addr` is not blacklisted by token contracts that have a blacklist.
 209 |     |     function assumeNotBlacklisted(address token, address addr) internal view virtual {
 210 |     |         // Nothing to check if `token` is not a contract.
 211 |     |         uint256 tokenCodeSize;
 212 |     |         assembly {
 213 |     |             tokenCodeSize := extcodesize(token)
 214 |     |         }
 215 |     |         require(tokenCodeSize > 0, "StdCheats assumeNotBlacklisted(address,address): Token address is not a contract.");
 216 |     | 
 217 |     |         bool success;
 218 |     |         bytes memory returnData;
 219 |     | 
 220 |     |         // 4-byte selector for `isBlacklisted(address)`, used by USDC.
 221 |     |         (success, returnData) = token.staticcall(abi.encodeWithSelector(0xfe575a87, addr));
 222 |     |         vm.assume(!success || abi.decode(returnData, (bool)) == false);
 223 |     | 
 224 |     |         // 4-byte selector for `isBlackListed(address)`, used by USDT.
 225 |     |         (success, returnData) = token.staticcall(abi.encodeWithSelector(0xe47d6060, addr));
 226 |     |         vm.assume(!success || abi.decode(returnData, (bool)) == false);
 227 |     |     }
 228 |     | 
 229 |     |     // Checks that `addr` is not blacklisted by token contracts that have a blacklist.
 230 |     |     // This is identical to `assumeNotBlacklisted(address,address)` but with a different name, for
 231 |     |     // backwards compatibility, since this name was used in the original PR which already has
 232 |     |     // a release. This function can be removed in a future release once we want a breaking change.
 233 |     |     function assumeNoBlacklisted(address token, address addr) internal view virtual {
 234 |     |         assumeNotBlacklisted(token, addr);
 235 |     |     }
 236 |     | 
 237 |     |     function assumeAddressIsNot(address addr, AddressType addressType) internal virtual {
 238 |     |         if (addressType == AddressType.Payable) {
 239 |     |             assumeNotPayable(addr);
 240 |     |         } else if (addressType == AddressType.NonPayable) {
 241 |     |             assumePayable(addr);
 242 |     |         } else if (addressType == AddressType.ZeroAddress) {
 243 |     |             assumeNotZeroAddress(addr);
 244 |     |         } else if (addressType == AddressType.Precompile) {
 245 |     |             assumeNotPrecompile(addr);
 246 |     |         } else if (addressType == AddressType.ForgeAddress) {
 247 |     |             assumeNotForgeAddress(addr);
 248 |     |         }
 249 |     |     }
 250 |     | 
 251 |     |     function assumeAddressIsNot(address addr, AddressType addressType1, AddressType addressType2) internal virtual {
 252 |     |         assumeAddressIsNot(addr, addressType1);
 253 |     |         assumeAddressIsNot(addr, addressType2);
 254 |     |     }
 255 |     | 
 256 |     |     function assumeAddressIsNot(
 257 |     |         address addr,
 258 |     |         AddressType addressType1,
 259 |     |         AddressType addressType2,
 260 |     |         AddressType addressType3
 261 |     |     ) internal virtual {
 262 |     |         assumeAddressIsNot(addr, addressType1);
 263 |     |         assumeAddressIsNot(addr, addressType2);
 264 |     |         assumeAddressIsNot(addr, addressType3);
 265 |     |     }
 266 |     | 
 267 |     |     function assumeAddressIsNot(
 268 |     |         address addr,
 269 |     |         AddressType addressType1,
 270 |     |         AddressType addressType2,
 271 |     |         AddressType addressType3,
 272 |     |         AddressType addressType4
 273 |     |     ) internal virtual {
 274 |     |         assumeAddressIsNot(addr, addressType1);
 275 |     |         assumeAddressIsNot(addr, addressType2);
 276 |     |         assumeAddressIsNot(addr, addressType3);
 277 |     |         assumeAddressIsNot(addr, addressType4);
 278 |     |     }
 279 |     | 
 280 |     |     // This function checks whether an address, `addr`, is payable. It works by sending 1 wei to
 281 |     |     // `addr` and checking the `success` return value.
 282 |     |     // NOTE: This function may result in state changes depending on the fallback/receive logic
 283 |     |     // implemented by `addr`, which should be taken into account when this function is used.
 284 |     |     function _isPayable(address addr) private returns (bool) {
 285 |     |         require(
 286 |     |             addr.balance < UINT256_MAX,
 287 |     |             "StdCheats _isPayable(address): Balance equals max uint256, so it cannot receive any more funds"
 288 |     |         );
 289 |     |         uint256 origBalanceTest = address(this).balance;
 290 |     |         uint256 origBalanceAddr = address(addr).balance;
 291 |     | 
 292 |     |         vm.deal(address(this), 1);
 293 |     |         (bool success,) = payable(addr).call{value: 1}("");
 294 |     | 
 295 |     |         // reset balances
 296 |     |         vm.deal(address(this), origBalanceTest);
 297 |     |         vm.deal(addr, origBalanceAddr);
 298 |     | 
 299 |     |         return success;
 300 |     |     }
 301 |     | 
 302 |     |     // NOTE: This function may result in state changes depending on the fallback/receive logic
 303 |     |     // implemented by `addr`, which should be taken into account when this function is used. See the
 304 |     |     // `_isPayable` method for more information.
 305 |     |     function assumePayable(address addr) internal virtual {
 306 |     |         vm.assume(_isPayable(addr));
 307 |     |     }
 308 |     | 
 309 |     |     function assumeNotPayable(address addr) internal virtual {
 310 |     |         vm.assume(!_isPayable(addr));
 311 |     |     }
 312 |     | 
 313 |     |     function assumeNotZeroAddress(address addr) internal pure virtual {
 314 |     |         vm.assume(addr != address(0));
 315 |     |     }
 316 |     | 
 317 |     |     function assumeNotPrecompile(address addr) internal pure virtual {
 318 |     |         assumeNotPrecompile(addr, _pureChainId());
 319 |     |     }
 320 |     | 
 321 |     |     function assumeNotPrecompile(address addr, uint256 chainId) internal pure virtual {
 322 |     |         // Note: For some chains like Optimism these are technically predeploys (i.e. bytecode placed at a specific
 323 |     |         // address), but the same rationale for excluding them applies so we include those too.
 324 |     | 
 325 |     |         // These are reserved by Ethereum and may be on all EVM-compatible chains.
 326 |     |         vm.assume(addr < address(0x1) || addr > address(0xff));
 327 |     | 
 328 |     |         // forgefmt: disable-start
 329 |     |         if (chainId == 10 || chainId == 420) {
 330 |     |             // https://github.com/ethereum-optimism/optimism/blob/eaa371a0184b56b7ca6d9eb9cb0a2b78b2ccd864/op-bindings/predeploys/addresses.go#L6-L21
 331 |     |             vm.assume(addr < address(0x4200000000000000000000000000000000000000) || addr > address(0x4200000000000000000000000000000000000800));
 332 |     |         } else if (chainId == 42161 || chainId == 421613) {
 333 |     |             // https://developer.arbitrum.io/useful-addresses#arbitrum-precompiles-l2-same-on-all-arb-chains
 334 |     |             vm.assume(addr < address(0x0000000000000000000000000000000000000064) || addr > address(0x0000000000000000000000000000000000000068));
 335 |     |         } else if (chainId == 43114 || chainId == 43113) {
 336 |     |             // https://github.com/ava-labs/subnet-evm/blob/47c03fd007ecaa6de2c52ea081596e0a88401f58/precompile/params.go#L18-L59
 337 |     |             vm.assume(addr < address(0x0100000000000000000000000000000000000000) || addr > address(0x01000000000000000000000000000000000000ff));
 338 |     |             vm.assume(addr < address(0x0200000000000000000000000000000000000000) || addr > address(0x02000000000000000000000000000000000000FF));
 339 |     |             vm.assume(addr < address(0x0300000000000000000000000000000000000000) || addr > address(0x03000000000000000000000000000000000000Ff));
 340 |     |         }
 341 |     |         // forgefmt: disable-end
 342 |     |     }
 343 |     | 
 344 |     |     function assumeNotForgeAddress(address addr) internal pure virtual {
 345 |     |         // vm, console, and Create2Deployer addresses
 346 |     |         vm.assume(
 347 |     |             addr != address(vm) && addr != 0x000000000000000000636F6e736F6c652e6c6f67
 348 |     |                 && addr != 0x4e59b44847b379578588920cA78FbF26c0B4956C
 349 |     |         );
 350 |     |     }
 351 |     | 
 352 |     |     function assumeUnusedAddress(address addr) internal view virtual {
 353 |     |         uint256 size;
 354 |     |         assembly {
 355 |     |             size := extcodesize(addr)
 356 |     |         }
 357 |     |         vm.assume(size == 0);
 358 |     | 
 359 |     |         assumeNotPrecompile(addr);
 360 |     |         assumeNotZeroAddress(addr);
 361 |     |         assumeNotForgeAddress(addr);
 362 |     |     }
 363 |     | 
 364 |     |     function readEIP1559ScriptArtifact(string memory path)
 365 |     |         internal
 366 |     |         view
 367 |     |         virtual
 368 |     |         returns (EIP1559ScriptArtifact memory)
 369 |     |     {
 370 |     |         string memory data = vm.readFile(path);
 371 |     |         bytes memory parsedData = vm.parseJson(data);
 372 |     |         RawEIP1559ScriptArtifact memory rawArtifact = abi.decode(parsedData, (RawEIP1559ScriptArtifact));
 373 |     |         EIP1559ScriptArtifact memory artifact;
 374 |     |         artifact.libraries = rawArtifact.libraries;
 375 |     |         artifact.path = rawArtifact.path;
 376 |     |         artifact.timestamp = rawArtifact.timestamp;
 377 |     |         artifact.pending = rawArtifact.pending;
 378 |     |         artifact.txReturns = rawArtifact.txReturns;
 379 |     |         artifact.receipts = rawToConvertedReceipts(rawArtifact.receipts);
 380 |     |         artifact.transactions = rawToConvertedEIPTx1559s(rawArtifact.transactions);
 381 |     |         return artifact;
 382 |     |     }
 383 |     | 
 384 |     |     function rawToConvertedEIPTx1559s(RawTx1559[] memory rawTxs) internal pure virtual returns (Tx1559[] memory) {
 385 |     |         Tx1559[] memory txs = new Tx1559[](rawTxs.length);
 386 |     |         for (uint256 i; i < rawTxs.length; i++) {
 387 |     |             txs[i] = rawToConvertedEIPTx1559(rawTxs[i]);
 388 |     |         }
 389 |     |         return txs;
 390 |     |     }
 391 |     | 
 392 |     |     function rawToConvertedEIPTx1559(RawTx1559 memory rawTx) internal pure virtual returns (Tx1559 memory) {
 393 |     |         Tx1559 memory transaction;
 394 |     |         transaction.arguments = rawTx.arguments;
 395 |     |         transaction.contractName = rawTx.contractName;
 396 |     |         transaction.functionSig = rawTx.functionSig;
 397 |     |         transaction.hash = rawTx.hash;
 398 |     |         transaction.txDetail = rawToConvertedEIP1559Detail(rawTx.txDetail);
 399 |     |         transaction.opcode = rawTx.opcode;
 400 |     |         return transaction;
 401 |     |     }
 402 |     | 
 403 |     |     function rawToConvertedEIP1559Detail(RawTx1559Detail memory rawDetail)
 404 |     |         internal
 405 |     |         pure
 406 |     |         virtual
 407 |     |         returns (Tx1559Detail memory)
 408 |     |     {
 409 |     |         Tx1559Detail memory txDetail;
 410 |     |         txDetail.data = rawDetail.data;
 411 |     |         txDetail.from = rawDetail.from;
 412 |     |         txDetail.to = rawDetail.to;
 413 |     |         txDetail.nonce = _bytesToUint(rawDetail.nonce);
 414 |     |         txDetail.txType = _bytesToUint(rawDetail.txType);
 415 |     |         txDetail.value = _bytesToUint(rawDetail.value);
 416 |     |         txDetail.gas = _bytesToUint(rawDetail.gas);
 417 |     |         txDetail.accessList = rawDetail.accessList;
 418 |     |         return txDetail;
 419 |     |     }
 420 |     | 
 421 |     |     function readTx1559s(string memory path) internal view virtual returns (Tx1559[] memory) {
 422 |     |         string memory deployData = vm.readFile(path);
 423 |     |         bytes memory parsedDeployData = vm.parseJson(deployData, ".transactions");
 424 |     |         RawTx1559[] memory rawTxs = abi.decode(parsedDeployData, (RawTx1559[]));
 425 |     |         return rawToConvertedEIPTx1559s(rawTxs);
 426 |     |     }
 427 |     | 
 428 |     |     function readTx1559(string memory path, uint256 index) internal view virtual returns (Tx1559 memory) {
 429 |     |         string memory deployData = vm.readFile(path);
 430 |     |         string memory key = string(abi.encodePacked(".transactions[", vm.toString(index), "]"));
 431 |     |         bytes memory parsedDeployData = vm.parseJson(deployData, key);
 432 |     |         RawTx1559 memory rawTx = abi.decode(parsedDeployData, (RawTx1559));
 433 |     |         return rawToConvertedEIPTx1559(rawTx);
 434 |     |     }
 435 |     | 
 436 |     |     // Analogous to readTransactions, but for receipts.
 437 |     |     function readReceipts(string memory path) internal view virtual returns (Receipt[] memory) {
 438 |     |         string memory deployData = vm.readFile(path);
 439 |     |         bytes memory parsedDeployData = vm.parseJson(deployData, ".receipts");
 440 |     |         RawReceipt[] memory rawReceipts = abi.decode(parsedDeployData, (RawReceipt[]));
 441 |     |         return rawToConvertedReceipts(rawReceipts);
 442 |     |     }
 443 |     | 
 444 |     |     function readReceipt(string memory path, uint256 index) internal view virtual returns (Receipt memory) {
 445 |     |         string memory deployData = vm.readFile(path);
 446 |     |         string memory key = string(abi.encodePacked(".receipts[", vm.toString(index), "]"));
 447 |     |         bytes memory parsedDeployData = vm.parseJson(deployData, key);
 448 |     |         RawReceipt memory rawReceipt = abi.decode(parsedDeployData, (RawReceipt));
 449 |     |         return rawToConvertedReceipt(rawReceipt);
 450 |     |     }
 451 |     | 
 452 |     |     function rawToConvertedReceipts(RawReceipt[] memory rawReceipts) internal pure virtual returns (Receipt[] memory) {
 453 |     |         Receipt[] memory receipts = new Receipt[](rawReceipts.length);
 454 |     |         for (uint256 i; i < rawReceipts.length; i++) {
 455 |     |             receipts[i] = rawToConvertedReceipt(rawReceipts[i]);
 456 |     |         }
 457 |     |         return receipts;
 458 |     |     }
 459 |     | 
 460 |     |     function rawToConvertedReceipt(RawReceipt memory rawReceipt) internal pure virtual returns (Receipt memory) {
 461 |     |         Receipt memory receipt;
 462 |     |         receipt.blockHash = rawReceipt.blockHash;
 463 |     |         receipt.to = rawReceipt.to;
 464 |     |         receipt.from = rawReceipt.from;
 465 |     |         receipt.contractAddress = rawReceipt.contractAddress;
 466 |     |         receipt.effectiveGasPrice = _bytesToUint(rawReceipt.effectiveGasPrice);
 467 |     |         receipt.cumulativeGasUsed = _bytesToUint(rawReceipt.cumulativeGasUsed);
 468 |     |         receipt.gasUsed = _bytesToUint(rawReceipt.gasUsed);
 469 |     |         receipt.status = _bytesToUint(rawReceipt.status);
 470 |     |         receipt.transactionIndex = _bytesToUint(rawReceipt.transactionIndex);
 471 |     |         receipt.blockNumber = _bytesToUint(rawReceipt.blockNumber);
 472 |     |         receipt.logs = rawToConvertedReceiptLogs(rawReceipt.logs);
 473 |     |         receipt.logsBloom = rawReceipt.logsBloom;
 474 |     |         receipt.transactionHash = rawReceipt.transactionHash;
 475 |     |         return receipt;
 476 |     |     }
 477 |     | 
 478 |     |     function rawToConvertedReceiptLogs(RawReceiptLog[] memory rawLogs)
 479 |     |         internal
 480 |     |         pure
 481 |     |         virtual
 482 |     |         returns (ReceiptLog[] memory)
 483 |     |     {
 484 |     |         ReceiptLog[] memory logs = new ReceiptLog[](rawLogs.length);
 485 |     |         for (uint256 i; i < rawLogs.length; i++) {
 486 |     |             logs[i].logAddress = rawLogs[i].logAddress;
 487 |     |             logs[i].blockHash = rawLogs[i].blockHash;
 488 |     |             logs[i].blockNumber = _bytesToUint(rawLogs[i].blockNumber);
 489 |     |             logs[i].data = rawLogs[i].data;
 490 |     |             logs[i].logIndex = _bytesToUint(rawLogs[i].logIndex);
 491 |     |             logs[i].topics = rawLogs[i].topics;
 492 |     |             logs[i].transactionIndex = _bytesToUint(rawLogs[i].transactionIndex);
 493 |     |             logs[i].transactionLogIndex = _bytesToUint(rawLogs[i].transactionLogIndex);
 494 |     |             logs[i].removed = rawLogs[i].removed;
 495 |     |         }
 496 |     |         return logs;
 497 |     |     }
 498 |     | 
 499 |     |     // Deploy a contract by fetching the contract bytecode from
 500 |     |     // the artifacts directory
 501 |     |     // e.g. `deployCode(code, abi.encode(arg1,arg2,arg3))`
 502 |     |     function deployCode(string memory what, bytes memory args) internal virtual returns (address addr) {
 503 |     |         bytes memory bytecode = abi.encodePacked(vm.getCode(what), args);
 504 |     |         /// @solidity memory-safe-assembly
 505 |     |         assembly {
 506 |     |             addr := create(0, add(bytecode, 0x20), mload(bytecode))
 507 |     |         }
 508 |     | 
 509 |     |         require(addr != address(0), "StdCheats deployCode(string,bytes): Deployment failed.");
 510 |     |     }
 511 |     | 
 512 |     |     function deployCode(string memory what) internal virtual returns (address addr) {
 513 |     |         bytes memory bytecode = vm.getCode(what);
 514 |     |         /// @solidity memory-safe-assembly
 515 |     |         assembly {
 516 |     |             addr := create(0, add(bytecode, 0x20), mload(bytecode))
 517 |     |         }
 518 |     | 
 519 |     |         require(addr != address(0), "StdCheats deployCode(string): Deployment failed.");
 520 |     |     }
 521 |     | 
 522 |     |     /// @dev deploy contract with value on construction
 523 |     |     function deployCode(string memory what, bytes memory args, uint256 val) internal virtual returns (address addr) {
 524 |     |         bytes memory bytecode = abi.encodePacked(vm.getCode(what), args);
 525 |     |         /// @solidity memory-safe-assembly
 526 |     |         assembly {
 527 |     |             addr := create(val, add(bytecode, 0x20), mload(bytecode))
 528 |     |         }
 529 |     | 
 530 |     |         require(addr != address(0), "StdCheats deployCode(string,bytes,uint256): Deployment failed.");
 531 |     |     }
 532 |     | 
 533 |     |     function deployCode(string memory what, uint256 val) internal virtual returns (address addr) {
 534 |     |         bytes memory bytecode = vm.getCode(what);
 535 |     |         /// @solidity memory-safe-assembly
 536 |     |         assembly {
 537 |     |             addr := create(val, add(bytecode, 0x20), mload(bytecode))
 538 |     |         }
 539 |     | 
 540 |     |         require(addr != address(0), "StdCheats deployCode(string,uint256): Deployment failed.");
 541 |     |     }
 542 |     | 
 543 |     |     // creates a labeled address and the corresponding private key
 544 |     |     function makeAddrAndKey(string memory name) internal virtual returns (address addr, uint256 privateKey) {
 545 |     |         privateKey = uint256(keccak256(abi.encodePacked(name)));
 546 |     |         addr = vm.addr(privateKey);
 547 |     |         vm.label(addr, name);
 548 |     |     }
 549 |     | 
 550 |     |     // creates a labeled address
 551 |     |     function makeAddr(string memory name) internal virtual returns (address addr) {
 552 |     |         (addr,) = makeAddrAndKey(name);
 553 |     |     }
 554 |     | 
 555 |     |     // Destroys an account immediately, sending the balance to beneficiary.
 556 |     |     // Destroying means: balance will be zero, code will be empty, and nonce will be 0
 557 |     |     // This is similar to selfdestruct but not identical: selfdestruct destroys code and nonce
 558 |     |     // only after tx ends, this will run immediately.
 559 |     |     function destroyAccount(address who, address beneficiary) internal virtual {
 560 |     |         uint256 currBalance = who.balance;
 561 |     |         vm.etch(who, abi.encode());
 562 |     |         vm.deal(who, 0);
 563 |     |         vm.resetNonce(who);
 564 |     | 
 565 |     |         uint256 beneficiaryBalance = beneficiary.balance;
 566 |     |         vm.deal(beneficiary, currBalance + beneficiaryBalance);
 567 |     |     }
 568 |     | 
 569 |     |     // creates a struct containing both a labeled address and the corresponding private key
 570 |     |     function makeAccount(string memory name) internal virtual returns (Account memory account) {
 571 |     |         (account.addr, account.key) = makeAddrAndKey(name);
 572 |     |     }
 573 |     | 
 574 |     |     function deriveRememberKey(string memory mnemonic, uint32 index)
 575 |     |         internal
 576 |     |         virtual
 577 |     |         returns (address who, uint256 privateKey)
 578 |     |     {
 579 |     |         privateKey = vm.deriveKey(mnemonic, index);
 580 |     |         who = vm.rememberKey(privateKey);
 581 |     |     }
 582 |     | 
 583 |     |     function _bytesToUint(bytes memory b) private pure returns (uint256) {
 584 |     |         require(b.length <= 32, "StdCheats _bytesToUint(bytes): Bytes length exceeds 32.");
 585 |     |         return abi.decode(abi.encodePacked(new bytes(32 - b.length), b), (uint256));
 586 |     |     }
 587 |     | 
 588 |     |     function isFork() internal view virtual returns (bool status) {
 589 |     |         try vm.activeFork() {
 590 |     |             status = true;
 591 |     |         } catch (bytes memory) {}
 592 |     |     }
 593 |     | 
 594 |     |     modifier skipWhenForking() {
 595 |     |         if (!isFork()) {
 596 |     |             _;
 597 |     |         }
 598 |     |     }
 599 |     | 
 600 |     |     modifier skipWhenNotForking() {
 601 |     |         if (isFork()) {
 602 |     |             _;
 603 |     |         }
 604 |     |     }
 605 |     | 
 606 |     |     modifier noGasMetering() {
 607 |     |         vm.pauseGasMetering();
 608 |     |         // To prevent turning gas monitoring back on with nested functions that use this modifier,
 609 |     |         // we check if gasMetering started in the off position. If it did, we don't want to turn
 610 |     |         // it back on until we exit the top level function that used the modifier
 611 |     |         //
 612 |     |         // i.e. funcA() noGasMetering { funcB() }, where funcB has noGasMetering as well.
 613 |     |         // funcA will have `gasStartedOff` as false, funcB will have it as true,
 614 |     |         // so we only turn metering back on at the end of the funcA
 615 |     |         bool gasStartedOff = gasMeteringOff;
 616 |     |         gasMeteringOff = true;
 617 |     | 
 618 |     |         _;
 619 |     | 
 620 |     |         // if gas metering was on when this modifier was called, turn it back on at the end
 621 |     |         if (!gasStartedOff) {
 622 |     |             gasMeteringOff = false;
 623 |     |             vm.resumeGasMetering();
 624 |     |         }
 625 |     |     }
 626 |     | 
 627 |     |     // We use this complex approach of `_viewChainId` and `_pureChainId` to ensure there are no
 628 |     |     // compiler warnings when accessing chain ID in any solidity version supported by forge-std. We
 629 |     |     // can't simply access the chain ID in a normal view or pure function because the solc View Pure
 630 |     |     // Checker changed `chainid` from pure to view in 0.8.0.
 631 |     |     function _viewChainId() private view returns (uint256 chainId) {
 632 |     |         // Assembly required since `block.chainid` was introduced in 0.8.0.
 633 |     |         assembly {
 634 |     |             chainId := chainid()
 635 |     |         }
 636 |     | 
 637 |     |         address(this); // Silence warnings in older Solc versions.
 638 |     |     }
 639 |     | 
 640 |     |     function _pureChainId() private pure returns (uint256 chainId) {
 641 |     |         function() internal view returns (uint256) fnIn = _viewChainId;
 642 |     |         function() internal pure returns (uint256) pureChainId;
 643 |     |         assembly {
 644 |     |             pureChainId := fnIn
 645 |     |         }
 646 |     |         chainId = pureChainId();
 647 |     |     }
 648 |     | }
 649 |     | 
 650 |     | // Wrappers around cheatcodes to avoid footguns
 651 |     | abstract contract StdCheats is StdCheatsSafe {
 652 |     |     using stdStorage for StdStorage;
 653 |     | 
 654 |     |     StdStorage private stdstore;
 655 |     |     Vm private constant vm = Vm(address(uint160(uint256(keccak256("hevm cheat code")))));
 656 |     |     address private constant CONSOLE2_ADDRESS = 0x000000000000000000636F6e736F6c652e6c6f67;
 657 |     | 
 658 |     |     // Skip forward or rewind time by the specified number of seconds
 659 |     |     function skip(uint256 time) internal virtual {
 660 |     |         vm.warp(vm.getBlockTimestamp() + time);
 661 |     |     }
 662 |     | 
 663 |     |     function rewind(uint256 time) internal virtual {
 664 |     |         vm.warp(vm.getBlockTimestamp() - time);
 665 |     |     }
 666 |     | 
 667 |     |     // Setup a prank from an address that has some ether
 668 |     |     function hoax(address msgSender) internal virtual {
 669 |     |         vm.deal(msgSender, 1 << 128);
 670 |     |         vm.prank(msgSender);
 671 |     |     }
 672 |     | 
 673 |     |     function hoax(address msgSender, uint256 give) internal virtual {
 674 |     |         vm.deal(msgSender, give);
 675 |     |         vm.prank(msgSender);
 676 |     |     }
 677 |     | 
 678 |     |     function hoax(address msgSender, address origin) internal virtual {
 679 |     |         vm.deal(msgSender, 1 << 128);
 680 |     |         vm.prank(msgSender, origin);
 681 |     |     }
 682 |     | 
 683 |     |     function hoax(address msgSender, address origin, uint256 give) internal virtual {
 684 |     |         vm.deal(msgSender, give);
 685 |     |         vm.prank(msgSender, origin);
 686 |     |     }
 687 |     | 
 688 |     |     // Start perpetual prank from an address that has some ether
 689 |     |     function startHoax(address msgSender) internal virtual {
 690 |     |         vm.deal(msgSender, 1 << 128);
 691 |     |         vm.startPrank(msgSender);
 692 |     |     }
 693 |     | 
 694 |     |     function startHoax(address msgSender, uint256 give) internal virtual {
 695 |     |         vm.deal(msgSender, give);
 696 |     |         vm.startPrank(msgSender);
 697 |     |     }
 698 |     | 
 699 |     |     // Start perpetual prank from an address that has some ether
 700 |     |     // tx.origin is set to the origin parameter
 701 |     |     function startHoax(address msgSender, address origin) internal virtual {
 702 |     |         vm.deal(msgSender, 1 << 128);
 703 |     |         vm.startPrank(msgSender, origin);
 704 |     |     }
 705 |     | 
 706 |     |     function startHoax(address msgSender, address origin, uint256 give) internal virtual {
 707 |     |         vm.deal(msgSender, give);
 708 |     |         vm.startPrank(msgSender, origin);
 709 |     |     }
 710 |     | 
 711 |     |     function changePrank(address msgSender) internal virtual {
 712 |     |         console2_log_StdCheats("changePrank is deprecated. Please use vm.startPrank instead.");
 713 |     |         vm.stopPrank();
 714 |     |         vm.startPrank(msgSender);
 715 |     |     }
 716 |     | 
 717 |     |     function changePrank(address msgSender, address txOrigin) internal virtual {
 718 |     |         vm.stopPrank();
 719 |     |         vm.startPrank(msgSender, txOrigin);
 720 |     |     }
 721 |     | 
 722 |     |     // The same as Vm's `deal`
 723 |     |     // Use the alternative signature for ERC20 tokens
 724 |     |     function deal(address to, uint256 give) internal virtual {
 725 |     |         vm.deal(to, give);
 726 |     |     }
 727 |     | 
 728 |     |     // Set the balance of an account for any ERC20 token
 729 |     |     // Use the alternative signature to update `totalSupply`
 730 |     |     function deal(address token, address to, uint256 give) internal virtual {
 731 |     |         deal(token, to, give, false);
 732 |     |     }
 733 |     | 
 734 |     |     // Set the balance of an account for any ERC1155 token
 735 |     |     // Use the alternative signature to update `totalSupply`
 736 |     |     function dealERC1155(address token, address to, uint256 id, uint256 give) internal virtual {
 737 |     |         dealERC1155(token, to, id, give, false);
 738 |     |     }
 739 |     | 
 740 |     |     function deal(address token, address to, uint256 give, bool adjust) internal virtual {
 741 |     |         // get current balance
 742 |     |         (, bytes memory balData) = token.staticcall(abi.encodeWithSelector(0x70a08231, to));
 743 |     |         uint256 prevBal = abi.decode(balData, (uint256));
 744 |     | 
 745 |     |         // update balance
 746 |     |         stdstore.target(token).sig(0x70a08231).with_key(to).checked_write(give);
 747 |     | 
 748 |     |         // update total supply
 749 |     |         if (adjust) {
 750 |     |             (, bytes memory totSupData) = token.staticcall(abi.encodeWithSelector(0x18160ddd));
 751 |     |             uint256 totSup = abi.decode(totSupData, (uint256));
 752 |     |             if (give < prevBal) {
 753 |     |                 totSup -= (prevBal - give);
 754 |     |             } else {
 755 |     |                 totSup += (give - prevBal);
 756 |     |             }
 757 |     |             stdstore.target(token).sig(0x18160ddd).checked_write(totSup);
 758 |     |         }
 759 |     |     }
 760 |     | 
 761 |     |     function dealERC1155(address token, address to, uint256 id, uint256 give, bool adjust) internal virtual {
 762 |     |         // get current balance
 763 |     |         (, bytes memory balData) = token.staticcall(abi.encodeWithSelector(0x00fdd58e, to, id));
 764 |     |         uint256 prevBal = abi.decode(balData, (uint256));
 765 |     | 
 766 |     |         // update balance
 767 |     |         stdstore.target(token).sig(0x00fdd58e).with_key(to).with_key(id).checked_write(give);
 768 |     | 
 769 |     |         // update total supply
 770 |     |         if (adjust) {
 771 |     |             (, bytes memory totSupData) = token.staticcall(abi.encodeWithSelector(0xbd85b039, id));
 772 |     |             require(
 773 |     |                 totSupData.length != 0,
 774 |     |                 "StdCheats deal(address,address,uint,uint,bool): target contract is not ERC1155Supply."
 775 |     |             );
 776 |     |             uint256 totSup = abi.decode(totSupData, (uint256));
 777 |     |             if (give < prevBal) {
 778 |     |                 totSup -= (prevBal - give);
 779 |     |             } else {
 780 |     |                 totSup += (give - prevBal);
 781 |     |             }
 782 |     |             stdstore.target(token).sig(0xbd85b039).with_key(id).checked_write(totSup);
 783 |     |         }
 784 |     |     }
 785 |     | 
 786 |     |     function dealERC721(address token, address to, uint256 id) internal virtual {
 787 |     |         // check if token id is already minted and the actual owner.
 788 |     |         (bool successMinted, bytes memory ownerData) = token.staticcall(abi.encodeWithSelector(0x6352211e, id));
 789 |     |         require(successMinted, "StdCheats deal(address,address,uint,bool): id not minted.");
 790 |     | 
 791 |     |         // get owner current balance
 792 |     |         (, bytes memory fromBalData) =
 793 |     |             token.staticcall(abi.encodeWithSelector(0x70a08231, abi.decode(ownerData, (address))));
 794 |     |         uint256 fromPrevBal = abi.decode(fromBalData, (uint256));
 795 |     | 
 796 |     |         // get new user current balance
 797 |     |         (, bytes memory toBalData) = token.staticcall(abi.encodeWithSelector(0x70a08231, to));
 798 |     |         uint256 toPrevBal = abi.decode(toBalData, (uint256));
 799 |     | 
 800 |     |         // update balances
 801 |     |         stdstore.target(token).sig(0x70a08231).with_key(abi.decode(ownerData, (address))).checked_write(--fromPrevBal);
 802 |     |         stdstore.target(token).sig(0x70a08231).with_key(to).checked_write(++toPrevBal);
 803 |     | 
 804 |     |         // update owner
 805 |     |         stdstore.target(token).sig(0x6352211e).with_key(id).checked_write(to);
 806 |     |     }
 807 |     | 
 808 |     |     function deployCodeTo(string memory what, address where) internal virtual {
 809 |     |         deployCodeTo(what, "", 0, where);
 810 |     |     }
 811 |     | 
 812 |     |     function deployCodeTo(string memory what, bytes memory args, address where) internal virtual {
 813 |     |         deployCodeTo(what, args, 0, where);
 814 |     |     }
 815 |     | 
 816 |     |     function deployCodeTo(string memory what, bytes memory args, uint256 value, address where) internal virtual {
 817 |     |         bytes memory creationCode = vm.getCode(what);
 818 |     |         vm.etch(where, abi.encodePacked(creationCode, args));
 819 |     |         (bool success, bytes memory runtimeBytecode) = where.call{value: value}("");
 820 |     |         require(success, "StdCheats deployCodeTo(string,bytes,uint256,address): Failed to create runtime bytecode.");
 821 |     |         vm.etch(where, runtimeBytecode);
 822 |     |     }
 823 |     | 
 824 |     |     // Used to prevent the compilation of console, which shortens the compilation time when console is not used elsewhere.
 825 |     |     function console2_log_StdCheats(string memory p0) private view {
 826 |     |         (bool status,) = address(CONSOLE2_ADDRESS).staticcall(abi.encodeWithSignature("log(string)", p0));
 827 |     |         status;
 828 |     |     }
 829 |     | }
 830 |     | 

/home/phantom/Documents/azemora/azemora-contracts/lib/forge-std/src/StdConstants.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | pragma solidity >=0.6.2 <0.9.0;
  3 |     | 
  4 |     | import {IMulticall3} from "./interfaces/IMulticall3.sol";
  5 |     | import {Vm} from "./Vm.sol";
  6 |     | 
  7 |     | library StdConstants {
  8 |     |     /// @dev Cheat code address.
  9 |     |     /// Calculated as `address(uint160(uint256(keccak256("hevm cheat code"))))`.
 10 |     |     Vm internal constant VM = Vm(0x7109709ECfa91a80626fF3989D68f67F5b1DD12D);
 11 |     |     /// @dev console.sol and console2.sol work by executing a staticcall to this address.
 12 |     |     /// Calculated as `address(uint160(uint88(bytes11("console.log"))))`.
 13 |     |     address internal constant CONSOLE = 0x000000000000000000636F6e736F6c652e6c6f67;
 14 |     |     /// @dev Used when deploying with create2.
 15 |     |     /// Taken from https://github.com/Arachnid/deterministic-deployment-proxy.
 16 |     |     address internal constant CREATE2_FACTORY = 0x4e59b44847b379578588920cA78FbF26c0B4956C;
 17 |     |     /// @dev The default address for tx.origin and msg.sender.
 18 |     |     /// Calculated as `address(uint160(uint256(keccak256("foundry default caller"))))`.
 19 |     |     address internal constant DEFAULT_SENDER = 0x1804c8AB1F12E6bbf3894d4083f33e07309d1f38;
 20 |     |     /// @dev The address of the first contract `CREATE`d by a running test contract.
 21 |     |     /// When running tests, each test contract is `CREATE`d by `DEFAULT_SENDER` with nonce 1.
 22 |     |     /// Calculated as `VM.computeCreateAddress(VM.computeCreateAddress(DEFAULT_SENDER, 1), 1)`.
 23 |     |     address internal constant DEFAULT_TEST_CONTRACT = 0x5615dEB798BB3E4dFa0139dFa1b3D433Cc23b72f;
 24 |     |     /// @dev Deterministic deployment address of the Multicall3 contract.
 25 |     |     /// Taken from https://www.multicall3.com.
 26 |     |     IMulticall3 internal constant MULTICALL3_ADDRESS = IMulticall3(0xcA11bde05977b3631167028862bE2a173976CA11);
 27 |     |     /// @dev The order of the secp256k1 curve.
 28 |     |     uint256 internal constant SECP256K1_ORDER =
 29 |     |         115792089237316195423570985008687907852837564279074904382605163141518161494337;
 30 |     | }
 31 |     | 

/home/phantom/Documents/azemora/azemora-contracts/lib/forge-std/src/StdError.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | // Panics work for versions >=0.8.0, but we lowered the pragma to make this compatible with Test
  3 |     | pragma solidity >=0.6.2 <0.9.0;
  4 |     | 
  5 |     | library stdError {
  6 |     |     bytes public constant assertionError = abi.encodeWithSignature("Panic(uint256)", 0x01);
  7 |     |     bytes public constant arithmeticError = abi.encodeWithSignature("Panic(uint256)", 0x11);
  8 |     |     bytes public constant divisionError = abi.encodeWithSignature("Panic(uint256)", 0x12);
  9 |     |     bytes public constant enumConversionError = abi.encodeWithSignature("Panic(uint256)", 0x21);
 10 |     |     bytes public constant encodeStorageError = abi.encodeWithSignature("Panic(uint256)", 0x22);
 11 |     |     bytes public constant popError = abi.encodeWithSignature("Panic(uint256)", 0x31);
 12 |     |     bytes public constant indexOOBError = abi.encodeWithSignature("Panic(uint256)", 0x32);
 13 |     |     bytes public constant memOverflowError = abi.encodeWithSignature("Panic(uint256)", 0x41);
 14 |     |     bytes public constant zeroVarError = abi.encodeWithSignature("Panic(uint256)", 0x51);
 15 |     | }
 16 |     | 

/home/phantom/Documents/azemora/azemora-contracts/lib/forge-std/src/StdInvariant.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | pragma solidity >=0.6.2 <0.9.0;
   3 |     | 
   4 |     | pragma experimental ABIEncoderV2;
   5 |     | 
   6 |     | abstract contract StdInvariant {
   7 |     |     struct FuzzSelector {
   8 |     |         address addr;
   9 |     |         bytes4[] selectors;
  10 |     |     }
  11 |     | 
  12 |     |     struct FuzzArtifactSelector {
  13 |     |         string artifact;
  14 |     |         bytes4[] selectors;
  15 |     |     }
  16 |     | 
  17 |     |     struct FuzzInterface {
  18 |     |         address addr;
  19 |     |         string[] artifacts;
  20 |     |     }
  21 |     | 
  22 |     |     address[] private _excludedContracts;
  23 |     |     address[] private _excludedSenders;
  24 |     |     address[] private _targetedContracts;
  25 |     |     address[] private _targetedSenders;
  26 |     | 
  27 |     |     string[] private _excludedArtifacts;
  28 |     |     string[] private _targetedArtifacts;
  29 |     | 
  30 |     |     FuzzArtifactSelector[] private _targetedArtifactSelectors;
  31 |     | 
  32 |     |     FuzzSelector[] private _excludedSelectors;
  33 |     |     FuzzSelector[] private _targetedSelectors;
  34 |     | 
  35 |     |     FuzzInterface[] private _targetedInterfaces;
  36 |     | 
  37 |     |     // Functions for users:
  38 |     |     // These are intended to be called in tests.
  39 |     | 
  40 |     |     function excludeContract(address newExcludedContract_) internal {
  41 |     |         _excludedContracts.push(newExcludedContract_);
  42 |     |     }
  43 |     | 
  44 |     |     function excludeSelector(FuzzSelector memory newExcludedSelector_) internal {
  45 |     |         _excludedSelectors.push(newExcludedSelector_);
  46 |     |     }
  47 |     | 
  48 |     |     function excludeSender(address newExcludedSender_) internal {
  49 |     |         _excludedSenders.push(newExcludedSender_);
  50 |     |     }
  51 |     | 
  52 |     |     function excludeArtifact(string memory newExcludedArtifact_) internal {
  53 |     |         _excludedArtifacts.push(newExcludedArtifact_);
  54 |     |     }
  55 |     | 
  56 |     |     function targetArtifact(string memory newTargetedArtifact_) internal {
  57 |     |         _targetedArtifacts.push(newTargetedArtifact_);
  58 |     |     }
  59 |     | 
  60 |     |     function targetArtifactSelector(FuzzArtifactSelector memory newTargetedArtifactSelector_) internal {
  61 |     |         _targetedArtifactSelectors.push(newTargetedArtifactSelector_);
  62 |     |     }
  63 |     | 
  64 |     |     function targetContract(address newTargetedContract_) internal {
  65 |     |         _targetedContracts.push(newTargetedContract_);
  66 |     |     }
  67 |     | 
  68 |     |     function targetSelector(FuzzSelector memory newTargetedSelector_) internal {
  69 |     |         _targetedSelectors.push(newTargetedSelector_);
  70 |     |     }
  71 |     | 
  72 |     |     function targetSender(address newTargetedSender_) internal {
  73 |     |         _targetedSenders.push(newTargetedSender_);
  74 |     |     }
  75 |     | 
  76 |     |     function targetInterface(FuzzInterface memory newTargetedInterface_) internal {
  77 |     |         _targetedInterfaces.push(newTargetedInterface_);
  78 |     |     }
  79 |     | 
  80 |     |     // Functions for forge:
  81 |     |     // These are called by forge to run invariant tests and don't need to be called in tests.
  82 |     | 
  83 |     |     function excludeArtifacts() public view returns (string[] memory excludedArtifacts_) {
  84 |     |         excludedArtifacts_ = _excludedArtifacts;
  85 |     |     }
  86 |     | 
  87 | *   |     function excludeContracts() public view returns (address[] memory excludedContracts_) {
  88 | *   |         excludedContracts_ = _excludedContracts;
  89 |     |     }
  90 |     | 
  91 | *   |     function excludeSelectors() public view returns (FuzzSelector[] memory excludedSelectors_) {
  92 | *   |         excludedSelectors_ = _excludedSelectors;
  93 |     |     }
  94 |     | 
  95 | *   |     function excludeSenders() public view returns (address[] memory excludedSenders_) {
  96 | *   |         excludedSenders_ = _excludedSenders;
  97 |     |     }
  98 |     | 
  99 | *   |     function targetArtifacts() public view returns (string[] memory targetedArtifacts_) {
 100 | *   |         targetedArtifacts_ = _targetedArtifacts;
 101 |     |     }
 102 |     | 
 103 | *   |     function targetArtifactSelectors() public view returns (FuzzArtifactSelector[] memory targetedArtifactSelectors_) {
 104 | *   |         targetedArtifactSelectors_ = _targetedArtifactSelectors;
 105 |     |     }
 106 |     | 
 107 | *   |     function targetContracts() public view returns (address[] memory targetedContracts_) {
 108 | *   |         targetedContracts_ = _targetedContracts;
 109 |     |     }
 110 |     | 
 111 | *   |     function targetSelectors() public view returns (FuzzSelector[] memory targetedSelectors_) {
 112 | *   |         targetedSelectors_ = _targetedSelectors;
 113 |     |     }
 114 |     | 
 115 | *   |     function targetSenders() public view returns (address[] memory targetedSenders_) {
 116 | *   |         targetedSenders_ = _targetedSenders;
 117 |     |     }
 118 |     | 
 119 | *   |     function targetInterfaces() public view returns (FuzzInterface[] memory targetedInterfaces_) {
 120 | *   |         targetedInterfaces_ = _targetedInterfaces;
 121 |     |     }
 122 |     | }
 123 |     | 

/home/phantom/Documents/azemora/azemora-contracts/lib/forge-std/src/StdJson.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | pragma solidity >=0.6.0 <0.9.0;
   3 |     | 
   4 |     | pragma experimental ABIEncoderV2;
   5 |     | 
   6 |     | import {VmSafe} from "./Vm.sol";
   7 |     | 
   8 |     | // Helpers for parsing and writing JSON files
   9 |     | // To parse:
  10 |     | // ```
  11 |     | // using stdJson for string;
  12 |     | // string memory json = vm.readFile("<some_path>");
  13 |     | // json.readUint("<json_path>");
  14 |     | // ```
  15 |     | // To write:
  16 |     | // ```
  17 |     | // using stdJson for string;
  18 |     | // string memory json = "json";
  19 |     | // json.serialize("a", uint256(123));
  20 |     | // string memory semiFinal = json.serialize("b", string("test"));
  21 |     | // string memory finalJson = json.serialize("c", semiFinal);
  22 |     | // finalJson.write("<some_path>");
  23 |     | // ```
  24 |     | 
  25 |     | library stdJson {
  26 |     |     VmSafe private constant vm = VmSafe(address(uint160(uint256(keccak256("hevm cheat code")))));
  27 |     | 
  28 |     |     function keyExists(string memory json, string memory key) internal view returns (bool) {
  29 |     |         return vm.keyExistsJson(json, key);
  30 |     |     }
  31 |     | 
  32 |     |     function parseRaw(string memory json, string memory key) internal pure returns (bytes memory) {
  33 |     |         return vm.parseJson(json, key);
  34 |     |     }
  35 |     | 
  36 |     |     function readUint(string memory json, string memory key) internal pure returns (uint256) {
  37 |     |         return vm.parseJsonUint(json, key);
  38 |     |     }
  39 |     | 
  40 |     |     function readUintArray(string memory json, string memory key) internal pure returns (uint256[] memory) {
  41 |     |         return vm.parseJsonUintArray(json, key);
  42 |     |     }
  43 |     | 
  44 |     |     function readInt(string memory json, string memory key) internal pure returns (int256) {
  45 |     |         return vm.parseJsonInt(json, key);
  46 |     |     }
  47 |     | 
  48 |     |     function readIntArray(string memory json, string memory key) internal pure returns (int256[] memory) {
  49 |     |         return vm.parseJsonIntArray(json, key);
  50 |     |     }
  51 |     | 
  52 |     |     function readBytes32(string memory json, string memory key) internal pure returns (bytes32) {
  53 |     |         return vm.parseJsonBytes32(json, key);
  54 |     |     }
  55 |     | 
  56 |     |     function readBytes32Array(string memory json, string memory key) internal pure returns (bytes32[] memory) {
  57 |     |         return vm.parseJsonBytes32Array(json, key);
  58 |     |     }
  59 |     | 
  60 |     |     function readString(string memory json, string memory key) internal pure returns (string memory) {
  61 |     |         return vm.parseJsonString(json, key);
  62 |     |     }
  63 |     | 
  64 |     |     function readStringArray(string memory json, string memory key) internal pure returns (string[] memory) {
  65 |     |         return vm.parseJsonStringArray(json, key);
  66 |     |     }
  67 |     | 
  68 |     |     function readAddress(string memory json, string memory key) internal pure returns (address) {
  69 |     |         return vm.parseJsonAddress(json, key);
  70 |     |     }
  71 |     | 
  72 |     |     function readAddressArray(string memory json, string memory key) internal pure returns (address[] memory) {
  73 |     |         return vm.parseJsonAddressArray(json, key);
  74 |     |     }
  75 |     | 
  76 |     |     function readBool(string memory json, string memory key) internal pure returns (bool) {
  77 |     |         return vm.parseJsonBool(json, key);
  78 |     |     }
  79 |     | 
  80 |     |     function readBoolArray(string memory json, string memory key) internal pure returns (bool[] memory) {
  81 |     |         return vm.parseJsonBoolArray(json, key);
  82 |     |     }
  83 |     | 
  84 |     |     function readBytes(string memory json, string memory key) internal pure returns (bytes memory) {
  85 |     |         return vm.parseJsonBytes(json, key);
  86 |     |     }
  87 |     | 
  88 |     |     function readBytesArray(string memory json, string memory key) internal pure returns (bytes[] memory) {
  89 |     |         return vm.parseJsonBytesArray(json, key);
  90 |     |     }
  91 |     | 
  92 |     |     function readUintOr(string memory json, string memory key, uint256 defaultValue) internal view returns (uint256) {
  93 |     |         return keyExists(json, key) ? readUint(json, key) : defaultValue;
  94 |     |     }
  95 |     | 
  96 |     |     function readUintArrayOr(string memory json, string memory key, uint256[] memory defaultValue)
  97 |     |         internal
  98 |     |         view
  99 |     |         returns (uint256[] memory)
 100 |     |     {
 101 |     |         return keyExists(json, key) ? readUintArray(json, key) : defaultValue;
 102 |     |     }
 103 |     | 
 104 |     |     function readIntOr(string memory json, string memory key, int256 defaultValue) internal view returns (int256) {
 105 |     |         return keyExists(json, key) ? readInt(json, key) : defaultValue;
 106 |     |     }
 107 |     | 
 108 |     |     function readIntArrayOr(string memory json, string memory key, int256[] memory defaultValue)
 109 |     |         internal
 110 |     |         view
 111 |     |         returns (int256[] memory)
 112 |     |     {
 113 |     |         return keyExists(json, key) ? readIntArray(json, key) : defaultValue;
 114 |     |     }
 115 |     | 
 116 |     |     function readBytes32Or(string memory json, string memory key, bytes32 defaultValue)
 117 |     |         internal
 118 |     |         view
 119 |     |         returns (bytes32)
 120 |     |     {
 121 |     |         return keyExists(json, key) ? readBytes32(json, key) : defaultValue;
 122 |     |     }
 123 |     | 
 124 |     |     function readBytes32ArrayOr(string memory json, string memory key, bytes32[] memory defaultValue)
 125 |     |         internal
 126 |     |         view
 127 |     |         returns (bytes32[] memory)
 128 |     |     {
 129 |     |         return keyExists(json, key) ? readBytes32Array(json, key) : defaultValue;
 130 |     |     }
 131 |     | 
 132 |     |     function readStringOr(string memory json, string memory key, string memory defaultValue)
 133 |     |         internal
 134 |     |         view
 135 |     |         returns (string memory)
 136 |     |     {
 137 |     |         return keyExists(json, key) ? readString(json, key) : defaultValue;
 138 |     |     }
 139 |     | 
 140 |     |     function readStringArrayOr(string memory json, string memory key, string[] memory defaultValue)
 141 |     |         internal
 142 |     |         view
 143 |     |         returns (string[] memory)
 144 |     |     {
 145 |     |         return keyExists(json, key) ? readStringArray(json, key) : defaultValue;
 146 |     |     }
 147 |     | 
 148 |     |     function readAddressOr(string memory json, string memory key, address defaultValue)
 149 |     |         internal
 150 |     |         view
 151 |     |         returns (address)
 152 |     |     {
 153 |     |         return keyExists(json, key) ? readAddress(json, key) : defaultValue;
 154 |     |     }
 155 |     | 
 156 |     |     function readAddressArrayOr(string memory json, string memory key, address[] memory defaultValue)
 157 |     |         internal
 158 |     |         view
 159 |     |         returns (address[] memory)
 160 |     |     {
 161 |     |         return keyExists(json, key) ? readAddressArray(json, key) : defaultValue;
 162 |     |     }
 163 |     | 
 164 |     |     function readBoolOr(string memory json, string memory key, bool defaultValue) internal view returns (bool) {
 165 |     |         return keyExists(json, key) ? readBool(json, key) : defaultValue;
 166 |     |     }
 167 |     | 
 168 |     |     function readBoolArrayOr(string memory json, string memory key, bool[] memory defaultValue)
 169 |     |         internal
 170 |     |         view
 171 |     |         returns (bool[] memory)
 172 |     |     {
 173 |     |         return keyExists(json, key) ? readBoolArray(json, key) : defaultValue;
 174 |     |     }
 175 |     | 
 176 |     |     function readBytesOr(string memory json, string memory key, bytes memory defaultValue)
 177 |     |         internal
 178 |     |         view
 179 |     |         returns (bytes memory)
 180 |     |     {
 181 |     |         return keyExists(json, key) ? readBytes(json, key) : defaultValue;
 182 |     |     }
 183 |     | 
 184 |     |     function readBytesArrayOr(string memory json, string memory key, bytes[] memory defaultValue)
 185 |     |         internal
 186 |     |         view
 187 |     |         returns (bytes[] memory)
 188 |     |     {
 189 |     |         return keyExists(json, key) ? readBytesArray(json, key) : defaultValue;
 190 |     |     }
 191 |     | 
 192 |     |     function serialize(string memory jsonKey, string memory rootObject) internal returns (string memory) {
 193 |     |         return vm.serializeJson(jsonKey, rootObject);
 194 |     |     }
 195 |     | 
 196 |     |     function serialize(string memory jsonKey, string memory key, bool value) internal returns (string memory) {
 197 |     |         return vm.serializeBool(jsonKey, key, value);
 198 |     |     }
 199 |     | 
 200 |     |     function serialize(string memory jsonKey, string memory key, bool[] memory value)
 201 |     |         internal
 202 |     |         returns (string memory)
 203 |     |     {
 204 |     |         return vm.serializeBool(jsonKey, key, value);
 205 |     |     }
 206 |     | 
 207 |     |     function serialize(string memory jsonKey, string memory key, uint256 value) internal returns (string memory) {
 208 |     |         return vm.serializeUint(jsonKey, key, value);
 209 |     |     }
 210 |     | 
 211 |     |     function serialize(string memory jsonKey, string memory key, uint256[] memory value)
 212 |     |         internal
 213 |     |         returns (string memory)
 214 |     |     {
 215 |     |         return vm.serializeUint(jsonKey, key, value);
 216 |     |     }
 217 |     | 
 218 |     |     function serialize(string memory jsonKey, string memory key, int256 value) internal returns (string memory) {
 219 |     |         return vm.serializeInt(jsonKey, key, value);
 220 |     |     }
 221 |     | 
 222 |     |     function serialize(string memory jsonKey, string memory key, int256[] memory value)
 223 |     |         internal
 224 |     |         returns (string memory)
 225 |     |     {
 226 |     |         return vm.serializeInt(jsonKey, key, value);
 227 |     |     }
 228 |     | 
 229 |     |     function serialize(string memory jsonKey, string memory key, address value) internal returns (string memory) {
 230 |     |         return vm.serializeAddress(jsonKey, key, value);
 231 |     |     }
 232 |     | 
 233 |     |     function serialize(string memory jsonKey, string memory key, address[] memory value)
 234 |     |         internal
 235 |     |         returns (string memory)
 236 |     |     {
 237 |     |         return vm.serializeAddress(jsonKey, key, value);
 238 |     |     }
 239 |     | 
 240 |     |     function serialize(string memory jsonKey, string memory key, bytes32 value) internal returns (string memory) {
 241 |     |         return vm.serializeBytes32(jsonKey, key, value);
 242 |     |     }
 243 |     | 
 244 |     |     function serialize(string memory jsonKey, string memory key, bytes32[] memory value)
 245 |     |         internal
 246 |     |         returns (string memory)
 247 |     |     {
 248 |     |         return vm.serializeBytes32(jsonKey, key, value);
 249 |     |     }
 250 |     | 
 251 |     |     function serialize(string memory jsonKey, string memory key, bytes memory value) internal returns (string memory) {
 252 |     |         return vm.serializeBytes(jsonKey, key, value);
 253 |     |     }
 254 |     | 
 255 |     |     function serialize(string memory jsonKey, string memory key, bytes[] memory value)
 256 |     |         internal
 257 |     |         returns (string memory)
 258 |     |     {
 259 |     |         return vm.serializeBytes(jsonKey, key, value);
 260 |     |     }
 261 |     | 
 262 |     |     function serialize(string memory jsonKey, string memory key, string memory value)
 263 |     |         internal
 264 |     |         returns (string memory)
 265 |     |     {
 266 |     |         return vm.serializeString(jsonKey, key, value);
 267 |     |     }
 268 |     | 
 269 |     |     function serialize(string memory jsonKey, string memory key, string[] memory value)
 270 |     |         internal
 271 |     |         returns (string memory)
 272 |     |     {
 273 |     |         return vm.serializeString(jsonKey, key, value);
 274 |     |     }
 275 |     | 
 276 |     |     function write(string memory jsonKey, string memory path) internal {
 277 |     |         vm.writeJson(jsonKey, path);
 278 |     |     }
 279 |     | 
 280 |     |     function write(string memory jsonKey, string memory path, string memory valueKey) internal {
 281 |     |         vm.writeJson(jsonKey, path, valueKey);
 282 |     |     }
 283 |     | }
 284 |     | 

/home/phantom/Documents/azemora/azemora-contracts/lib/forge-std/src/StdMath.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | pragma solidity >=0.6.2 <0.9.0;
  3 |     | 
  4 |     | library stdMath {
  5 |     |     int256 private constant INT256_MIN = -57896044618658097711785492504343953926634992332820282019728792003956564819968;
  6 |     | 
  7 |     |     function abs(int256 a) internal pure returns (uint256) {
  8 |     |         // Required or it will fail when `a = type(int256).min`
  9 |     |         if (a == INT256_MIN) {
 10 |     |             return 57896044618658097711785492504343953926634992332820282019728792003956564819968;
 11 |     |         }
 12 |     | 
 13 |     |         return uint256(a > 0 ? a : -a);
 14 |     |     }
 15 |     | 
 16 |     |     function delta(uint256 a, uint256 b) internal pure returns (uint256) {
 17 |     |         return a > b ? a - b : b - a;
 18 |     |     }
 19 |     | 
 20 |     |     function delta(int256 a, int256 b) internal pure returns (uint256) {
 21 |     |         // a and b are of the same sign
 22 |     |         // this works thanks to two's complement, the left-most bit is the sign bit
 23 |     |         if ((a ^ b) > -1) {
 24 |     |             return delta(abs(a), abs(b));
 25 |     |         }
 26 |     | 
 27 |     |         // a and b are of opposite signs
 28 |     |         return abs(a) + abs(b);
 29 |     |     }
 30 |     | 
 31 |     |     function percentDelta(uint256 a, uint256 b) internal pure returns (uint256) {
 32 |     |         uint256 absDelta = delta(a, b);
 33 |     | 
 34 |     |         return absDelta * 1e18 / b;
 35 |     |     }
 36 |     | 
 37 |     |     function percentDelta(int256 a, int256 b) internal pure returns (uint256) {
 38 |     |         uint256 absDelta = delta(a, b);
 39 |     |         uint256 absB = abs(b);
 40 |     | 
 41 |     |         return absDelta * 1e18 / absB;
 42 |     |     }
 43 |     | }
 44 |     | 

/home/phantom/Documents/azemora/azemora-contracts/lib/forge-std/src/StdStorage.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | pragma solidity >=0.6.2 <0.9.0;
   3 |     | 
   4 |     | import {Vm} from "./Vm.sol";
   5 |     | 
   6 |     | struct FindData {
   7 |     |     uint256 slot;
   8 |     |     uint256 offsetLeft;
   9 |     |     uint256 offsetRight;
  10 |     |     bool found;
  11 |     | }
  12 |     | 
  13 |     | struct StdStorage {
  14 |     |     mapping(address => mapping(bytes4 => mapping(bytes32 => FindData))) finds;
  15 |     |     bytes32[] _keys;
  16 |     |     bytes4 _sig;
  17 |     |     uint256 _depth;
  18 |     |     address _target;
  19 |     |     bytes32 _set;
  20 |     |     bool _enable_packed_slots;
  21 |     |     bytes _calldata;
  22 |     | }
  23 |     | 
  24 |     | library stdStorageSafe {
  25 |     |     event SlotFound(address who, bytes4 fsig, bytes32 keysHash, uint256 slot);
  26 |     |     event WARNING_UninitedSlot(address who, uint256 slot);
  27 |     | 
  28 |     |     Vm private constant vm = Vm(address(uint160(uint256(keccak256("hevm cheat code")))));
  29 |     |     uint256 constant UINT256_MAX = 115792089237316195423570985008687907853269984665640564039457584007913129639935;
  30 |     | 
  31 |     |     function sigs(string memory sigStr) internal pure returns (bytes4) {
  32 |     |         return bytes4(keccak256(bytes(sigStr)));
  33 |     |     }
  34 |     | 
  35 |     |     function getCallParams(StdStorage storage self) internal view returns (bytes memory) {
  36 |     |         if (self._calldata.length == 0) {
  37 |     |             return flatten(self._keys);
  38 |     |         } else {
  39 |     |             return self._calldata;
  40 |     |         }
  41 |     |     }
  42 |     | 
  43 |     |     // Calls target contract with configured parameters
  44 |     |     function callTarget(StdStorage storage self) internal view returns (bool, bytes32) {
  45 |     |         bytes memory cald = abi.encodePacked(self._sig, getCallParams(self));
  46 |     |         (bool success, bytes memory rdat) = self._target.staticcall(cald);
  47 |     |         bytes32 result = bytesToBytes32(rdat, 32 * self._depth);
  48 |     | 
  49 |     |         return (success, result);
  50 |     |     }
  51 |     | 
  52 |     |     // Tries mutating slot value to determine if the targeted value is stored in it.
  53 |     |     // If current value is 0, then we are setting slot value to type(uint256).max
  54 |     |     // Otherwise, we set it to 0. That way, return value should always be affected.
  55 |     |     function checkSlotMutatesCall(StdStorage storage self, bytes32 slot) internal returns (bool) {
  56 |     |         bytes32 prevSlotValue = vm.load(self._target, slot);
  57 |     |         (bool success, bytes32 prevReturnValue) = callTarget(self);
  58 |     | 
  59 |     |         bytes32 testVal = prevReturnValue == bytes32(0) ? bytes32(UINT256_MAX) : bytes32(0);
  60 |     |         vm.store(self._target, slot, testVal);
  61 |     | 
  62 |     |         (, bytes32 newReturnValue) = callTarget(self);
  63 |     | 
  64 |     |         vm.store(self._target, slot, prevSlotValue);
  65 |     | 
  66 |     |         return (success && (prevReturnValue != newReturnValue));
  67 |     |     }
  68 |     | 
  69 |     |     // Tries setting one of the bits in slot to 1 until return value changes.
  70 |     |     // Index of resulted bit is an offset packed slot has from left/right side
  71 |     |     function findOffset(StdStorage storage self, bytes32 slot, bool left) internal returns (bool, uint256) {
  72 |     |         for (uint256 offset = 0; offset < 256; offset++) {
  73 |     |             uint256 valueToPut = left ? (1 << (255 - offset)) : (1 << offset);
  74 |     |             vm.store(self._target, slot, bytes32(valueToPut));
  75 |     | 
  76 |     |             (bool success, bytes32 data) = callTarget(self);
  77 |     | 
  78 |     |             if (success && (uint256(data) > 0)) {
  79 |     |                 return (true, offset);
  80 |     |             }
  81 |     |         }
  82 |     |         return (false, 0);
  83 |     |     }
  84 |     | 
  85 |     |     function findOffsets(StdStorage storage self, bytes32 slot) internal returns (bool, uint256, uint256) {
  86 |     |         bytes32 prevSlotValue = vm.load(self._target, slot);
  87 |     | 
  88 |     |         (bool foundLeft, uint256 offsetLeft) = findOffset(self, slot, true);
  89 |     |         (bool foundRight, uint256 offsetRight) = findOffset(self, slot, false);
  90 |     | 
  91 |     |         // `findOffset` may mutate slot value, so we are setting it to initial value
  92 |     |         vm.store(self._target, slot, prevSlotValue);
  93 |     |         return (foundLeft && foundRight, offsetLeft, offsetRight);
  94 |     |     }
  95 |     | 
  96 |     |     function find(StdStorage storage self) internal returns (FindData storage) {
  97 |     |         return find(self, true);
  98 |     |     }
  99 |     | 
 100 |     |     /// @notice find an arbitrary storage slot given a function sig, input data, address of the contract and a value to check against
 101 |     |     // slot complexity:
 102 |     |     //  if flat, will be bytes32(uint256(uint));
 103 |     |     //  if map, will be keccak256(abi.encode(key, uint(slot)));
 104 |     |     //  if deep map, will be keccak256(abi.encode(key1, keccak256(abi.encode(key0, uint(slot)))));
 105 |     |     //  if map struct, will be bytes32(uint256(keccak256(abi.encode(key1, keccak256(abi.encode(key0, uint(slot)))))) + structFieldDepth);
 106 |     |     function find(StdStorage storage self, bool _clear) internal returns (FindData storage) {
 107 |     |         address who = self._target;
 108 |     |         bytes4 fsig = self._sig;
 109 |     |         uint256 field_depth = self._depth;
 110 |     |         bytes memory params = getCallParams(self);
 111 |     | 
 112 |     |         // calldata to test against
 113 |     |         if (self.finds[who][fsig][keccak256(abi.encodePacked(params, field_depth))].found) {
 114 |     |             if (_clear) {
 115 |     |                 clear(self);
 116 |     |             }
 117 |     |             return self.finds[who][fsig][keccak256(abi.encodePacked(params, field_depth))];
 118 |     |         }
 119 |     |         vm.record();
 120 |     |         (, bytes32 callResult) = callTarget(self);
 121 |     |         (bytes32[] memory reads,) = vm.accesses(address(who));
 122 |     | 
 123 |     |         if (reads.length == 0) {
 124 |     |             revert("stdStorage find(StdStorage): No storage use detected for target.");
 125 |     |         } else {
 126 |     |             for (uint256 i = reads.length; --i >= 0;) {
 127 |     |                 bytes32 prev = vm.load(who, reads[i]);
 128 |     |                 if (prev == bytes32(0)) {
 129 |     |                     emit WARNING_UninitedSlot(who, uint256(reads[i]));
 130 |     |                 }
 131 |     | 
 132 |     |                 if (!checkSlotMutatesCall(self, reads[i])) {
 133 |     |                     continue;
 134 |     |                 }
 135 |     | 
 136 |     |                 (uint256 offsetLeft, uint256 offsetRight) = (0, 0);
 137 |     | 
 138 |     |                 if (self._enable_packed_slots) {
 139 |     |                     bool found;
 140 |     |                     (found, offsetLeft, offsetRight) = findOffsets(self, reads[i]);
 141 |     |                     if (!found) {
 142 |     |                         continue;
 143 |     |                     }
 144 |     |                 }
 145 |     | 
 146 |     |                 // Check that value between found offsets is equal to the current call result
 147 |     |                 uint256 curVal = (uint256(prev) & getMaskByOffsets(offsetLeft, offsetRight)) >> offsetRight;
 148 |     | 
 149 |     |                 if (uint256(callResult) != curVal) {
 150 |     |                     continue;
 151 |     |                 }
 152 |     | 
 153 |     |                 emit SlotFound(who, fsig, keccak256(abi.encodePacked(params, field_depth)), uint256(reads[i]));
 154 |     |                 self.finds[who][fsig][keccak256(abi.encodePacked(params, field_depth))] =
 155 |     |                     FindData(uint256(reads[i]), offsetLeft, offsetRight, true);
 156 |     |                 break;
 157 |     |             }
 158 |     |         }
 159 |     | 
 160 |     |         require(
 161 |     |             self.finds[who][fsig][keccak256(abi.encodePacked(params, field_depth))].found,
 162 |     |             "stdStorage find(StdStorage): Slot(s) not found."
 163 |     |         );
 164 |     | 
 165 |     |         if (_clear) {
 166 |     |             clear(self);
 167 |     |         }
 168 |     |         return self.finds[who][fsig][keccak256(abi.encodePacked(params, field_depth))];
 169 |     |     }
 170 |     | 
 171 |     |     function target(StdStorage storage self, address _target) internal returns (StdStorage storage) {
 172 |     |         self._target = _target;
 173 |     |         return self;
 174 |     |     }
 175 |     | 
 176 |     |     function sig(StdStorage storage self, bytes4 _sig) internal returns (StdStorage storage) {
 177 |     |         self._sig = _sig;
 178 |     |         return self;
 179 |     |     }
 180 |     | 
 181 |     |     function sig(StdStorage storage self, string memory _sig) internal returns (StdStorage storage) {
 182 |     |         self._sig = sigs(_sig);
 183 |     |         return self;
 184 |     |     }
 185 |     | 
 186 |     |     function with_calldata(StdStorage storage self, bytes memory _calldata) internal returns (StdStorage storage) {
 187 |     |         self._calldata = _calldata;
 188 |     |         return self;
 189 |     |     }
 190 |     | 
 191 |     |     function with_key(StdStorage storage self, address who) internal returns (StdStorage storage) {
 192 |     |         self._keys.push(bytes32(uint256(uint160(who))));
 193 |     |         return self;
 194 |     |     }
 195 |     | 
 196 |     |     function with_key(StdStorage storage self, uint256 amt) internal returns (StdStorage storage) {
 197 |     |         self._keys.push(bytes32(amt));
 198 |     |         return self;
 199 |     |     }
 200 |     | 
 201 |     |     function with_key(StdStorage storage self, bytes32 key) internal returns (StdStorage storage) {
 202 |     |         self._keys.push(key);
 203 |     |         return self;
 204 |     |     }
 205 |     | 
 206 |     |     function enable_packed_slots(StdStorage storage self) internal returns (StdStorage storage) {
 207 |     |         self._enable_packed_slots = true;
 208 |     |         return self;
 209 |     |     }
 210 |     | 
 211 |     |     function depth(StdStorage storage self, uint256 _depth) internal returns (StdStorage storage) {
 212 |     |         self._depth = _depth;
 213 |     |         return self;
 214 |     |     }
 215 |     | 
 216 |     |     function read(StdStorage storage self) private returns (bytes memory) {
 217 |     |         FindData storage data = find(self, false);
 218 |     |         uint256 mask = getMaskByOffsets(data.offsetLeft, data.offsetRight);
 219 |     |         uint256 value = (uint256(vm.load(self._target, bytes32(data.slot))) & mask) >> data.offsetRight;
 220 |     |         clear(self);
 221 |     |         return abi.encode(value);
 222 |     |     }
 223 |     | 
 224 |     |     function read_bytes32(StdStorage storage self) internal returns (bytes32) {
 225 |     |         return abi.decode(read(self), (bytes32));
 226 |     |     }
 227 |     | 
 228 |     |     function read_bool(StdStorage storage self) internal returns (bool) {
 229 |     |         int256 v = read_int(self);
 230 |     |         if (v == 0) return false;
 231 |     |         if (v == 1) return true;
 232 |     |         revert("stdStorage read_bool(StdStorage): Cannot decode. Make sure you are reading a bool.");
 233 |     |     }
 234 |     | 
 235 |     |     function read_address(StdStorage storage self) internal returns (address) {
 236 |     |         return abi.decode(read(self), (address));
 237 |     |     }
 238 |     | 
 239 |     |     function read_uint(StdStorage storage self) internal returns (uint256) {
 240 |     |         return abi.decode(read(self), (uint256));
 241 |     |     }
 242 |     | 
 243 |     |     function read_int(StdStorage storage self) internal returns (int256) {
 244 |     |         return abi.decode(read(self), (int256));
 245 |     |     }
 246 |     | 
 247 |     |     function parent(StdStorage storage self) internal returns (uint256, bytes32) {
 248 |     |         address who = self._target;
 249 |     |         uint256 field_depth = self._depth;
 250 |     |         vm.startMappingRecording();
 251 |     |         uint256 child = find(self, true).slot - field_depth;
 252 |     |         (bool found, bytes32 key, bytes32 parent_slot) = vm.getMappingKeyAndParentOf(who, bytes32(child));
 253 |     |         if (!found) {
 254 |     |             revert(
 255 |     |                 "stdStorage read_bool(StdStorage): Cannot find parent. Make sure you give a slot and startMappingRecording() has been called."
 256 |     |             );
 257 |     |         }
 258 |     |         return (uint256(parent_slot), key);
 259 |     |     }
 260 |     | 
 261 |     |     function root(StdStorage storage self) internal returns (uint256) {
 262 |     |         address who = self._target;
 263 |     |         uint256 field_depth = self._depth;
 264 |     |         vm.startMappingRecording();
 265 |     |         uint256 child = find(self, true).slot - field_depth;
 266 |     |         bool found;
 267 |     |         bytes32 root_slot;
 268 |     |         bytes32 parent_slot;
 269 |     |         (found,, parent_slot) = vm.getMappingKeyAndParentOf(who, bytes32(child));
 270 |     |         if (!found) {
 271 |     |             revert(
 272 |     |                 "stdStorage read_bool(StdStorage): Cannot find parent. Make sure you give a slot and startMappingRecording() has been called."
 273 |     |             );
 274 |     |         }
 275 |     |         while (found) {
 276 |     |             root_slot = parent_slot;
 277 |     |             (found,, parent_slot) = vm.getMappingKeyAndParentOf(who, bytes32(root_slot));
 278 |     |         }
 279 |     |         return uint256(root_slot);
 280 |     |     }
 281 |     | 
 282 |     |     function bytesToBytes32(bytes memory b, uint256 offset) private pure returns (bytes32) {
 283 |     |         bytes32 out;
 284 |     | 
 285 |     |         uint256 max = b.length > 32 ? 32 : b.length;
 286 |     |         for (uint256 i = 0; i < max; i++) {
 287 |     |             out |= bytes32(b[offset + i] & 0xFF) >> (i * 8);
 288 |     |         }
 289 |     |         return out;
 290 |     |     }
 291 |     | 
 292 |     |     function flatten(bytes32[] memory b) private pure returns (bytes memory) {
 293 |     |         bytes memory result = new bytes(b.length * 32);
 294 |     |         for (uint256 i = 0; i < b.length; i++) {
 295 |     |             bytes32 k = b[i];
 296 |     |             /// @solidity memory-safe-assembly
 297 |     |             assembly {
 298 |     |                 mstore(add(result, add(32, mul(32, i))), k)
 299 |     |             }
 300 |     |         }
 301 |     | 
 302 |     |         return result;
 303 |     |     }
 304 |     | 
 305 |     |     function clear(StdStorage storage self) internal {
 306 |     |         delete self._target;
 307 |     |         delete self._sig;
 308 |     |         delete self._keys;
 309 |     |         delete self._depth;
 310 |     |         delete self._enable_packed_slots;
 311 |     |         delete self._calldata;
 312 |     |     }
 313 |     | 
 314 |     |     // Returns mask which contains non-zero bits for values between `offsetLeft` and `offsetRight`
 315 |     |     // (slotValue & mask) >> offsetRight will be the value of the given packed variable
 316 |     |     function getMaskByOffsets(uint256 offsetLeft, uint256 offsetRight) internal pure returns (uint256 mask) {
 317 |     |         // mask = ((1 << (256 - (offsetRight + offsetLeft))) - 1) << offsetRight;
 318 |     |         // using assembly because (1 << 256) causes overflow
 319 |     |         assembly {
 320 |     |             mask := shl(offsetRight, sub(shl(sub(256, add(offsetRight, offsetLeft)), 1), 1))
 321 |     |         }
 322 |     |     }
 323 |     | 
 324 |     |     // Returns slot value with updated packed variable.
 325 |     |     function getUpdatedSlotValue(bytes32 curValue, uint256 varValue, uint256 offsetLeft, uint256 offsetRight)
 326 |     |         internal
 327 |     |         pure
 328 |     |         returns (bytes32 newValue)
 329 |     |     {
 330 |     |         return bytes32((uint256(curValue) & ~getMaskByOffsets(offsetLeft, offsetRight)) | (varValue << offsetRight));
 331 |     |     }
 332 |     | }
 333 |     | 
 334 |     | library stdStorage {
 335 |     |     Vm private constant vm = Vm(address(uint160(uint256(keccak256("hevm cheat code")))));
 336 |     | 
 337 |     |     function sigs(string memory sigStr) internal pure returns (bytes4) {
 338 |     |         return stdStorageSafe.sigs(sigStr);
 339 |     |     }
 340 |     | 
 341 |     |     function find(StdStorage storage self) internal returns (uint256) {
 342 |     |         return find(self, true);
 343 |     |     }
 344 |     | 
 345 |     |     function find(StdStorage storage self, bool _clear) internal returns (uint256) {
 346 |     |         return stdStorageSafe.find(self, _clear).slot;
 347 |     |     }
 348 |     | 
 349 |     |     function target(StdStorage storage self, address _target) internal returns (StdStorage storage) {
 350 |     |         return stdStorageSafe.target(self, _target);
 351 |     |     }
 352 |     | 
 353 |     |     function sig(StdStorage storage self, bytes4 _sig) internal returns (StdStorage storage) {
 354 |     |         return stdStorageSafe.sig(self, _sig);
 355 |     |     }
 356 |     | 
 357 |     |     function sig(StdStorage storage self, string memory _sig) internal returns (StdStorage storage) {
 358 |     |         return stdStorageSafe.sig(self, _sig);
 359 |     |     }
 360 |     | 
 361 |     |     function with_key(StdStorage storage self, address who) internal returns (StdStorage storage) {
 362 |     |         return stdStorageSafe.with_key(self, who);
 363 |     |     }
 364 |     | 
 365 |     |     function with_key(StdStorage storage self, uint256 amt) internal returns (StdStorage storage) {
 366 |     |         return stdStorageSafe.with_key(self, amt);
 367 |     |     }
 368 |     | 
 369 |     |     function with_key(StdStorage storage self, bytes32 key) internal returns (StdStorage storage) {
 370 |     |         return stdStorageSafe.with_key(self, key);
 371 |     |     }
 372 |     | 
 373 |     |     function with_calldata(StdStorage storage self, bytes memory _calldata) internal returns (StdStorage storage) {
 374 |     |         return stdStorageSafe.with_calldata(self, _calldata);
 375 |     |     }
 376 |     | 
 377 |     |     function enable_packed_slots(StdStorage storage self) internal returns (StdStorage storage) {
 378 |     |         return stdStorageSafe.enable_packed_slots(self);
 379 |     |     }
 380 |     | 
 381 |     |     function depth(StdStorage storage self, uint256 _depth) internal returns (StdStorage storage) {
 382 |     |         return stdStorageSafe.depth(self, _depth);
 383 |     |     }
 384 |     | 
 385 |     |     function clear(StdStorage storage self) internal {
 386 |     |         stdStorageSafe.clear(self);
 387 |     |     }
 388 |     | 
 389 |     |     function checked_write(StdStorage storage self, address who) internal {
 390 |     |         checked_write(self, bytes32(uint256(uint160(who))));
 391 |     |     }
 392 |     | 
 393 |     |     function checked_write(StdStorage storage self, uint256 amt) internal {
 394 |     |         checked_write(self, bytes32(amt));
 395 |     |     }
 396 |     | 
 397 |     |     function checked_write_int(StdStorage storage self, int256 val) internal {
 398 |     |         checked_write(self, bytes32(uint256(val)));
 399 |     |     }
 400 |     | 
 401 |     |     function checked_write(StdStorage storage self, bool write) internal {
 402 |     |         bytes32 t;
 403 |     |         /// @solidity memory-safe-assembly
 404 |     |         assembly {
 405 |     |             t := write
 406 |     |         }
 407 |     |         checked_write(self, t);
 408 |     |     }
 409 |     | 
 410 |     |     function checked_write(StdStorage storage self, bytes32 set) internal {
 411 |     |         address who = self._target;
 412 |     |         bytes4 fsig = self._sig;
 413 |     |         uint256 field_depth = self._depth;
 414 |     |         bytes memory params = stdStorageSafe.getCallParams(self);
 415 |     | 
 416 |     |         if (!self.finds[who][fsig][keccak256(abi.encodePacked(params, field_depth))].found) {
 417 |     |             find(self, false);
 418 |     |         }
 419 |     |         FindData storage data = self.finds[who][fsig][keccak256(abi.encodePacked(params, field_depth))];
 420 |     |         if ((data.offsetLeft + data.offsetRight) > 0) {
 421 |     |             uint256 maxVal = 2 ** (256 - (data.offsetLeft + data.offsetRight));
 422 |     |             require(
 423 |     |                 uint256(set) < maxVal,
 424 |     |                 string(
 425 |     |                     abi.encodePacked(
 426 |     |                         "stdStorage find(StdStorage): Packed slot. We can't fit value greater than ",
 427 |     |                         vm.toString(maxVal)
 428 |     |                     )
 429 |     |                 )
 430 |     |             );
 431 |     |         }
 432 |     |         bytes32 curVal = vm.load(who, bytes32(data.slot));
 433 |     |         bytes32 valToSet = stdStorageSafe.getUpdatedSlotValue(curVal, uint256(set), data.offsetLeft, data.offsetRight);
 434 |     | 
 435 |     |         vm.store(who, bytes32(data.slot), valToSet);
 436 |     | 
 437 |     |         (bool success, bytes32 callResult) = stdStorageSafe.callTarget(self);
 438 |     | 
 439 |     |         if (!success || callResult != set) {
 440 |     |             vm.store(who, bytes32(data.slot), curVal);
 441 |     |             revert("stdStorage find(StdStorage): Failed to write value.");
 442 |     |         }
 443 |     |         clear(self);
 444 |     |     }
 445 |     | 
 446 |     |     function read_bytes32(StdStorage storage self) internal returns (bytes32) {
 447 |     |         return stdStorageSafe.read_bytes32(self);
 448 |     |     }
 449 |     | 
 450 |     |     function read_bool(StdStorage storage self) internal returns (bool) {
 451 |     |         return stdStorageSafe.read_bool(self);
 452 |     |     }
 453 |     | 
 454 |     |     function read_address(StdStorage storage self) internal returns (address) {
 455 |     |         return stdStorageSafe.read_address(self);
 456 |     |     }
 457 |     | 
 458 |     |     function read_uint(StdStorage storage self) internal returns (uint256) {
 459 |     |         return stdStorageSafe.read_uint(self);
 460 |     |     }
 461 |     | 
 462 |     |     function read_int(StdStorage storage self) internal returns (int256) {
 463 |     |         return stdStorageSafe.read_int(self);
 464 |     |     }
 465 |     | 
 466 |     |     function parent(StdStorage storage self) internal returns (uint256, bytes32) {
 467 |     |         return stdStorageSafe.parent(self);
 468 |     |     }
 469 |     | 
 470 |     |     function root(StdStorage storage self) internal returns (uint256) {
 471 |     |         return stdStorageSafe.root(self);
 472 |     |     }
 473 |     | }
 474 |     | 

/home/phantom/Documents/azemora/azemora-contracts/lib/forge-std/src/StdStyle.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | pragma solidity >=0.4.22 <0.9.0;
   3 |     | 
   4 |     | import {VmSafe} from "./Vm.sol";
   5 |     | 
   6 |     | library StdStyle {
   7 |     |     VmSafe private constant vm = VmSafe(address(uint160(uint256(keccak256("hevm cheat code")))));
   8 |     | 
   9 |     |     string constant RED = "\u001b[91m";
  10 |     |     string constant GREEN = "\u001b[92m";
  11 |     |     string constant YELLOW = "\u001b[93m";
  12 |     |     string constant BLUE = "\u001b[94m";
  13 |     |     string constant MAGENTA = "\u001b[95m";
  14 |     |     string constant CYAN = "\u001b[96m";
  15 |     |     string constant BOLD = "\u001b[1m";
  16 |     |     string constant DIM = "\u001b[2m";
  17 |     |     string constant ITALIC = "\u001b[3m";
  18 |     |     string constant UNDERLINE = "\u001b[4m";
  19 |     |     string constant INVERSE = "\u001b[7m";
  20 |     |     string constant RESET = "\u001b[0m";
  21 |     | 
  22 |     |     function styleConcat(string memory style, string memory self) private pure returns (string memory) {
  23 |     |         return string(abi.encodePacked(style, self, RESET));
  24 |     |     }
  25 |     | 
  26 |     |     function red(string memory self) internal pure returns (string memory) {
  27 |     |         return styleConcat(RED, self);
  28 |     |     }
  29 |     | 
  30 |     |     function red(uint256 self) internal pure returns (string memory) {
  31 |     |         return red(vm.toString(self));
  32 |     |     }
  33 |     | 
  34 |     |     function red(int256 self) internal pure returns (string memory) {
  35 |     |         return red(vm.toString(self));
  36 |     |     }
  37 |     | 
  38 |     |     function red(address self) internal pure returns (string memory) {
  39 |     |         return red(vm.toString(self));
  40 |     |     }
  41 |     | 
  42 |     |     function red(bool self) internal pure returns (string memory) {
  43 |     |         return red(vm.toString(self));
  44 |     |     }
  45 |     | 
  46 |     |     function redBytes(bytes memory self) internal pure returns (string memory) {
  47 |     |         return red(vm.toString(self));
  48 |     |     }
  49 |     | 
  50 |     |     function redBytes32(bytes32 self) internal pure returns (string memory) {
  51 |     |         return red(vm.toString(self));
  52 |     |     }
  53 |     | 
  54 |     |     function green(string memory self) internal pure returns (string memory) {
  55 |     |         return styleConcat(GREEN, self);
  56 |     |     }
  57 |     | 
  58 |     |     function green(uint256 self) internal pure returns (string memory) {
  59 |     |         return green(vm.toString(self));
  60 |     |     }
  61 |     | 
  62 |     |     function green(int256 self) internal pure returns (string memory) {
  63 |     |         return green(vm.toString(self));
  64 |     |     }
  65 |     | 
  66 |     |     function green(address self) internal pure returns (string memory) {
  67 |     |         return green(vm.toString(self));
  68 |     |     }
  69 |     | 
  70 |     |     function green(bool self) internal pure returns (string memory) {
  71 |     |         return green(vm.toString(self));
  72 |     |     }
  73 |     | 
  74 |     |     function greenBytes(bytes memory self) internal pure returns (string memory) {
  75 |     |         return green(vm.toString(self));
  76 |     |     }
  77 |     | 
  78 |     |     function greenBytes32(bytes32 self) internal pure returns (string memory) {
  79 |     |         return green(vm.toString(self));
  80 |     |     }
  81 |     | 
  82 |     |     function yellow(string memory self) internal pure returns (string memory) {
  83 |     |         return styleConcat(YELLOW, self);
  84 |     |     }
  85 |     | 
  86 |     |     function yellow(uint256 self) internal pure returns (string memory) {
  87 |     |         return yellow(vm.toString(self));
  88 |     |     }
  89 |     | 
  90 |     |     function yellow(int256 self) internal pure returns (string memory) {
  91 |     |         return yellow(vm.toString(self));
  92 |     |     }
  93 |     | 
  94 |     |     function yellow(address self) internal pure returns (string memory) {
  95 |     |         return yellow(vm.toString(self));
  96 |     |     }
  97 |     | 
  98 |     |     function yellow(bool self) internal pure returns (string memory) {
  99 |     |         return yellow(vm.toString(self));
 100 |     |     }
 101 |     | 
 102 |     |     function yellowBytes(bytes memory self) internal pure returns (string memory) {
 103 |     |         return yellow(vm.toString(self));
 104 |     |     }
 105 |     | 
 106 |     |     function yellowBytes32(bytes32 self) internal pure returns (string memory) {
 107 |     |         return yellow(vm.toString(self));
 108 |     |     }
 109 |     | 
 110 |     |     function blue(string memory self) internal pure returns (string memory) {
 111 |     |         return styleConcat(BLUE, self);
 112 |     |     }
 113 |     | 
 114 |     |     function blue(uint256 self) internal pure returns (string memory) {
 115 |     |         return blue(vm.toString(self));
 116 |     |     }
 117 |     | 
 118 |     |     function blue(int256 self) internal pure returns (string memory) {
 119 |     |         return blue(vm.toString(self));
 120 |     |     }
 121 |     | 
 122 |     |     function blue(address self) internal pure returns (string memory) {
 123 |     |         return blue(vm.toString(self));
 124 |     |     }
 125 |     | 
 126 |     |     function blue(bool self) internal pure returns (string memory) {
 127 |     |         return blue(vm.toString(self));
 128 |     |     }
 129 |     | 
 130 |     |     function blueBytes(bytes memory self) internal pure returns (string memory) {
 131 |     |         return blue(vm.toString(self));
 132 |     |     }
 133 |     | 
 134 |     |     function blueBytes32(bytes32 self) internal pure returns (string memory) {
 135 |     |         return blue(vm.toString(self));
 136 |     |     }
 137 |     | 
 138 |     |     function magenta(string memory self) internal pure returns (string memory) {
 139 |     |         return styleConcat(MAGENTA, self);
 140 |     |     }
 141 |     | 
 142 |     |     function magenta(uint256 self) internal pure returns (string memory) {
 143 |     |         return magenta(vm.toString(self));
 144 |     |     }
 145 |     | 
 146 |     |     function magenta(int256 self) internal pure returns (string memory) {
 147 |     |         return magenta(vm.toString(self));
 148 |     |     }
 149 |     | 
 150 |     |     function magenta(address self) internal pure returns (string memory) {
 151 |     |         return magenta(vm.toString(self));
 152 |     |     }
 153 |     | 
 154 |     |     function magenta(bool self) internal pure returns (string memory) {
 155 |     |         return magenta(vm.toString(self));
 156 |     |     }
 157 |     | 
 158 |     |     function magentaBytes(bytes memory self) internal pure returns (string memory) {
 159 |     |         return magenta(vm.toString(self));
 160 |     |     }
 161 |     | 
 162 |     |     function magentaBytes32(bytes32 self) internal pure returns (string memory) {
 163 |     |         return magenta(vm.toString(self));
 164 |     |     }
 165 |     | 
 166 |     |     function cyan(string memory self) internal pure returns (string memory) {
 167 |     |         return styleConcat(CYAN, self);
 168 |     |     }
 169 |     | 
 170 |     |     function cyan(uint256 self) internal pure returns (string memory) {
 171 |     |         return cyan(vm.toString(self));
 172 |     |     }
 173 |     | 
 174 |     |     function cyan(int256 self) internal pure returns (string memory) {
 175 |     |         return cyan(vm.toString(self));
 176 |     |     }
 177 |     | 
 178 |     |     function cyan(address self) internal pure returns (string memory) {
 179 |     |         return cyan(vm.toString(self));
 180 |     |     }
 181 |     | 
 182 |     |     function cyan(bool self) internal pure returns (string memory) {
 183 |     |         return cyan(vm.toString(self));
 184 |     |     }
 185 |     | 
 186 |     |     function cyanBytes(bytes memory self) internal pure returns (string memory) {
 187 |     |         return cyan(vm.toString(self));
 188 |     |     }
 189 |     | 
 190 |     |     function cyanBytes32(bytes32 self) internal pure returns (string memory) {
 191 |     |         return cyan(vm.toString(self));
 192 |     |     }
 193 |     | 
 194 |     |     function bold(string memory self) internal pure returns (string memory) {
 195 |     |         return styleConcat(BOLD, self);
 196 |     |     }
 197 |     | 
 198 |     |     function bold(uint256 self) internal pure returns (string memory) {
 199 |     |         return bold(vm.toString(self));
 200 |     |     }
 201 |     | 
 202 |     |     function bold(int256 self) internal pure returns (string memory) {
 203 |     |         return bold(vm.toString(self));
 204 |     |     }
 205 |     | 
 206 |     |     function bold(address self) internal pure returns (string memory) {
 207 |     |         return bold(vm.toString(self));
 208 |     |     }
 209 |     | 
 210 |     |     function bold(bool self) internal pure returns (string memory) {
 211 |     |         return bold(vm.toString(self));
 212 |     |     }
 213 |     | 
 214 |     |     function boldBytes(bytes memory self) internal pure returns (string memory) {
 215 |     |         return bold(vm.toString(self));
 216 |     |     }
 217 |     | 
 218 |     |     function boldBytes32(bytes32 self) internal pure returns (string memory) {
 219 |     |         return bold(vm.toString(self));
 220 |     |     }
 221 |     | 
 222 |     |     function dim(string memory self) internal pure returns (string memory) {
 223 |     |         return styleConcat(DIM, self);
 224 |     |     }
 225 |     | 
 226 |     |     function dim(uint256 self) internal pure returns (string memory) {
 227 |     |         return dim(vm.toString(self));
 228 |     |     }
 229 |     | 
 230 |     |     function dim(int256 self) internal pure returns (string memory) {
 231 |     |         return dim(vm.toString(self));
 232 |     |     }
 233 |     | 
 234 |     |     function dim(address self) internal pure returns (string memory) {
 235 |     |         return dim(vm.toString(self));
 236 |     |     }
 237 |     | 
 238 |     |     function dim(bool self) internal pure returns (string memory) {
 239 |     |         return dim(vm.toString(self));
 240 |     |     }
 241 |     | 
 242 |     |     function dimBytes(bytes memory self) internal pure returns (string memory) {
 243 |     |         return dim(vm.toString(self));
 244 |     |     }
 245 |     | 
 246 |     |     function dimBytes32(bytes32 self) internal pure returns (string memory) {
 247 |     |         return dim(vm.toString(self));
 248 |     |     }
 249 |     | 
 250 |     |     function italic(string memory self) internal pure returns (string memory) {
 251 |     |         return styleConcat(ITALIC, self);
 252 |     |     }
 253 |     | 
 254 |     |     function italic(uint256 self) internal pure returns (string memory) {
 255 |     |         return italic(vm.toString(self));
 256 |     |     }
 257 |     | 
 258 |     |     function italic(int256 self) internal pure returns (string memory) {
 259 |     |         return italic(vm.toString(self));
 260 |     |     }
 261 |     | 
 262 |     |     function italic(address self) internal pure returns (string memory) {
 263 |     |         return italic(vm.toString(self));
 264 |     |     }
 265 |     | 
 266 |     |     function italic(bool self) internal pure returns (string memory) {
 267 |     |         return italic(vm.toString(self));
 268 |     |     }
 269 |     | 
 270 |     |     function italicBytes(bytes memory self) internal pure returns (string memory) {
 271 |     |         return italic(vm.toString(self));
 272 |     |     }
 273 |     | 
 274 |     |     function italicBytes32(bytes32 self) internal pure returns (string memory) {
 275 |     |         return italic(vm.toString(self));
 276 |     |     }
 277 |     | 
 278 |     |     function underline(string memory self) internal pure returns (string memory) {
 279 |     |         return styleConcat(UNDERLINE, self);
 280 |     |     }
 281 |     | 
 282 |     |     function underline(uint256 self) internal pure returns (string memory) {
 283 |     |         return underline(vm.toString(self));
 284 |     |     }
 285 |     | 
 286 |     |     function underline(int256 self) internal pure returns (string memory) {
 287 |     |         return underline(vm.toString(self));
 288 |     |     }
 289 |     | 
 290 |     |     function underline(address self) internal pure returns (string memory) {
 291 |     |         return underline(vm.toString(self));
 292 |     |     }
 293 |     | 
 294 |     |     function underline(bool self) internal pure returns (string memory) {
 295 |     |         return underline(vm.toString(self));
 296 |     |     }
 297 |     | 
 298 |     |     function underlineBytes(bytes memory self) internal pure returns (string memory) {
 299 |     |         return underline(vm.toString(self));
 300 |     |     }
 301 |     | 
 302 |     |     function underlineBytes32(bytes32 self) internal pure returns (string memory) {
 303 |     |         return underline(vm.toString(self));
 304 |     |     }
 305 |     | 
 306 |     |     function inverse(string memory self) internal pure returns (string memory) {
 307 |     |         return styleConcat(INVERSE, self);
 308 |     |     }
 309 |     | 
 310 |     |     function inverse(uint256 self) internal pure returns (string memory) {
 311 |     |         return inverse(vm.toString(self));
 312 |     |     }
 313 |     | 
 314 |     |     function inverse(int256 self) internal pure returns (string memory) {
 315 |     |         return inverse(vm.toString(self));
 316 |     |     }
 317 |     | 
 318 |     |     function inverse(address self) internal pure returns (string memory) {
 319 |     |         return inverse(vm.toString(self));
 320 |     |     }
 321 |     | 
 322 |     |     function inverse(bool self) internal pure returns (string memory) {
 323 |     |         return inverse(vm.toString(self));
 324 |     |     }
 325 |     | 
 326 |     |     function inverseBytes(bytes memory self) internal pure returns (string memory) {
 327 |     |         return inverse(vm.toString(self));
 328 |     |     }
 329 |     | 
 330 |     |     function inverseBytes32(bytes32 self) internal pure returns (string memory) {
 331 |     |         return inverse(vm.toString(self));
 332 |     |     }
 333 |     | }
 334 |     | 

/home/phantom/Documents/azemora/azemora-contracts/lib/forge-std/src/StdToml.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | pragma solidity >=0.6.0 <0.9.0;
   3 |     | 
   4 |     | pragma experimental ABIEncoderV2;
   5 |     | 
   6 |     | import {VmSafe} from "./Vm.sol";
   7 |     | 
   8 |     | // Helpers for parsing and writing TOML files
   9 |     | // To parse:
  10 |     | // ```
  11 |     | // using stdToml for string;
  12 |     | // string memory toml = vm.readFile("<some_path>");
  13 |     | // toml.readUint("<json_path>");
  14 |     | // ```
  15 |     | // To write:
  16 |     | // ```
  17 |     | // using stdToml for string;
  18 |     | // string memory json = "json";
  19 |     | // json.serialize("a", uint256(123));
  20 |     | // string memory semiFinal = json.serialize("b", string("test"));
  21 |     | // string memory finalJson = json.serialize("c", semiFinal);
  22 |     | // finalJson.write("<some_path>");
  23 |     | // ```
  24 |     | 
  25 |     | library stdToml {
  26 |     |     VmSafe private constant vm = VmSafe(address(uint160(uint256(keccak256("hevm cheat code")))));
  27 |     | 
  28 |     |     function keyExists(string memory toml, string memory key) internal view returns (bool) {
  29 |     |         return vm.keyExistsToml(toml, key);
  30 |     |     }
  31 |     | 
  32 |     |     function parseRaw(string memory toml, string memory key) internal pure returns (bytes memory) {
  33 |     |         return vm.parseToml(toml, key);
  34 |     |     }
  35 |     | 
  36 |     |     function readUint(string memory toml, string memory key) internal pure returns (uint256) {
  37 |     |         return vm.parseTomlUint(toml, key);
  38 |     |     }
  39 |     | 
  40 |     |     function readUintArray(string memory toml, string memory key) internal pure returns (uint256[] memory) {
  41 |     |         return vm.parseTomlUintArray(toml, key);
  42 |     |     }
  43 |     | 
  44 |     |     function readInt(string memory toml, string memory key) internal pure returns (int256) {
  45 |     |         return vm.parseTomlInt(toml, key);
  46 |     |     }
  47 |     | 
  48 |     |     function readIntArray(string memory toml, string memory key) internal pure returns (int256[] memory) {
  49 |     |         return vm.parseTomlIntArray(toml, key);
  50 |     |     }
  51 |     | 
  52 |     |     function readBytes32(string memory toml, string memory key) internal pure returns (bytes32) {
  53 |     |         return vm.parseTomlBytes32(toml, key);
  54 |     |     }
  55 |     | 
  56 |     |     function readBytes32Array(string memory toml, string memory key) internal pure returns (bytes32[] memory) {
  57 |     |         return vm.parseTomlBytes32Array(toml, key);
  58 |     |     }
  59 |     | 
  60 |     |     function readString(string memory toml, string memory key) internal pure returns (string memory) {
  61 |     |         return vm.parseTomlString(toml, key);
  62 |     |     }
  63 |     | 
  64 |     |     function readStringArray(string memory toml, string memory key) internal pure returns (string[] memory) {
  65 |     |         return vm.parseTomlStringArray(toml, key);
  66 |     |     }
  67 |     | 
  68 |     |     function readAddress(string memory toml, string memory key) internal pure returns (address) {
  69 |     |         return vm.parseTomlAddress(toml, key);
  70 |     |     }
  71 |     | 
  72 |     |     function readAddressArray(string memory toml, string memory key) internal pure returns (address[] memory) {
  73 |     |         return vm.parseTomlAddressArray(toml, key);
  74 |     |     }
  75 |     | 
  76 |     |     function readBool(string memory toml, string memory key) internal pure returns (bool) {
  77 |     |         return vm.parseTomlBool(toml, key);
  78 |     |     }
  79 |     | 
  80 |     |     function readBoolArray(string memory toml, string memory key) internal pure returns (bool[] memory) {
  81 |     |         return vm.parseTomlBoolArray(toml, key);
  82 |     |     }
  83 |     | 
  84 |     |     function readBytes(string memory toml, string memory key) internal pure returns (bytes memory) {
  85 |     |         return vm.parseTomlBytes(toml, key);
  86 |     |     }
  87 |     | 
  88 |     |     function readBytesArray(string memory toml, string memory key) internal pure returns (bytes[] memory) {
  89 |     |         return vm.parseTomlBytesArray(toml, key);
  90 |     |     }
  91 |     | 
  92 |     |     function readUintOr(string memory toml, string memory key, uint256 defaultValue) internal view returns (uint256) {
  93 |     |         return keyExists(toml, key) ? readUint(toml, key) : defaultValue;
  94 |     |     }
  95 |     | 
  96 |     |     function readUintArrayOr(string memory toml, string memory key, uint256[] memory defaultValue)
  97 |     |         internal
  98 |     |         view
  99 |     |         returns (uint256[] memory)
 100 |     |     {
 101 |     |         return keyExists(toml, key) ? readUintArray(toml, key) : defaultValue;
 102 |     |     }
 103 |     | 
 104 |     |     function readIntOr(string memory toml, string memory key, int256 defaultValue) internal view returns (int256) {
 105 |     |         return keyExists(toml, key) ? readInt(toml, key) : defaultValue;
 106 |     |     }
 107 |     | 
 108 |     |     function readIntArrayOr(string memory toml, string memory key, int256[] memory defaultValue)
 109 |     |         internal
 110 |     |         view
 111 |     |         returns (int256[] memory)
 112 |     |     {
 113 |     |         return keyExists(toml, key) ? readIntArray(toml, key) : defaultValue;
 114 |     |     }
 115 |     | 
 116 |     |     function readBytes32Or(string memory toml, string memory key, bytes32 defaultValue)
 117 |     |         internal
 118 |     |         view
 119 |     |         returns (bytes32)
 120 |     |     {
 121 |     |         return keyExists(toml, key) ? readBytes32(toml, key) : defaultValue;
 122 |     |     }
 123 |     | 
 124 |     |     function readBytes32ArrayOr(string memory toml, string memory key, bytes32[] memory defaultValue)
 125 |     |         internal
 126 |     |         view
 127 |     |         returns (bytes32[] memory)
 128 |     |     {
 129 |     |         return keyExists(toml, key) ? readBytes32Array(toml, key) : defaultValue;
 130 |     |     }
 131 |     | 
 132 |     |     function readStringOr(string memory toml, string memory key, string memory defaultValue)
 133 |     |         internal
 134 |     |         view
 135 |     |         returns (string memory)
 136 |     |     {
 137 |     |         return keyExists(toml, key) ? readString(toml, key) : defaultValue;
 138 |     |     }
 139 |     | 
 140 |     |     function readStringArrayOr(string memory toml, string memory key, string[] memory defaultValue)
 141 |     |         internal
 142 |     |         view
 143 |     |         returns (string[] memory)
 144 |     |     {
 145 |     |         return keyExists(toml, key) ? readStringArray(toml, key) : defaultValue;
 146 |     |     }
 147 |     | 
 148 |     |     function readAddressOr(string memory toml, string memory key, address defaultValue)
 149 |     |         internal
 150 |     |         view
 151 |     |         returns (address)
 152 |     |     {
 153 |     |         return keyExists(toml, key) ? readAddress(toml, key) : defaultValue;
 154 |     |     }
 155 |     | 
 156 |     |     function readAddressArrayOr(string memory toml, string memory key, address[] memory defaultValue)
 157 |     |         internal
 158 |     |         view
 159 |     |         returns (address[] memory)
 160 |     |     {
 161 |     |         return keyExists(toml, key) ? readAddressArray(toml, key) : defaultValue;
 162 |     |     }
 163 |     | 
 164 |     |     function readBoolOr(string memory toml, string memory key, bool defaultValue) internal view returns (bool) {
 165 |     |         return keyExists(toml, key) ? readBool(toml, key) : defaultValue;
 166 |     |     }
 167 |     | 
 168 |     |     function readBoolArrayOr(string memory toml, string memory key, bool[] memory defaultValue)
 169 |     |         internal
 170 |     |         view
 171 |     |         returns (bool[] memory)
 172 |     |     {
 173 |     |         return keyExists(toml, key) ? readBoolArray(toml, key) : defaultValue;
 174 |     |     }
 175 |     | 
 176 |     |     function readBytesOr(string memory toml, string memory key, bytes memory defaultValue)
 177 |     |         internal
 178 |     |         view
 179 |     |         returns (bytes memory)
 180 |     |     {
 181 |     |         return keyExists(toml, key) ? readBytes(toml, key) : defaultValue;
 182 |     |     }
 183 |     | 
 184 |     |     function readBytesArrayOr(string memory toml, string memory key, bytes[] memory defaultValue)
 185 |     |         internal
 186 |     |         view
 187 |     |         returns (bytes[] memory)
 188 |     |     {
 189 |     |         return keyExists(toml, key) ? readBytesArray(toml, key) : defaultValue;
 190 |     |     }
 191 |     | 
 192 |     |     function serialize(string memory jsonKey, string memory rootObject) internal returns (string memory) {
 193 |     |         return vm.serializeJson(jsonKey, rootObject);
 194 |     |     }
 195 |     | 
 196 |     |     function serialize(string memory jsonKey, string memory key, bool value) internal returns (string memory) {
 197 |     |         return vm.serializeBool(jsonKey, key, value);
 198 |     |     }
 199 |     | 
 200 |     |     function serialize(string memory jsonKey, string memory key, bool[] memory value)
 201 |     |         internal
 202 |     |         returns (string memory)
 203 |     |     {
 204 |     |         return vm.serializeBool(jsonKey, key, value);
 205 |     |     }
 206 |     | 
 207 |     |     function serialize(string memory jsonKey, string memory key, uint256 value) internal returns (string memory) {
 208 |     |         return vm.serializeUint(jsonKey, key, value);
 209 |     |     }
 210 |     | 
 211 |     |     function serialize(string memory jsonKey, string memory key, uint256[] memory value)
 212 |     |         internal
 213 |     |         returns (string memory)
 214 |     |     {
 215 |     |         return vm.serializeUint(jsonKey, key, value);
 216 |     |     }
 217 |     | 
 218 |     |     function serialize(string memory jsonKey, string memory key, int256 value) internal returns (string memory) {
 219 |     |         return vm.serializeInt(jsonKey, key, value);
 220 |     |     }
 221 |     | 
 222 |     |     function serialize(string memory jsonKey, string memory key, int256[] memory value)
 223 |     |         internal
 224 |     |         returns (string memory)
 225 |     |     {
 226 |     |         return vm.serializeInt(jsonKey, key, value);
 227 |     |     }
 228 |     | 
 229 |     |     function serialize(string memory jsonKey, string memory key, address value) internal returns (string memory) {
 230 |     |         return vm.serializeAddress(jsonKey, key, value);
 231 |     |     }
 232 |     | 
 233 |     |     function serialize(string memory jsonKey, string memory key, address[] memory value)
 234 |     |         internal
 235 |     |         returns (string memory)
 236 |     |     {
 237 |     |         return vm.serializeAddress(jsonKey, key, value);
 238 |     |     }
 239 |     | 
 240 |     |     function serialize(string memory jsonKey, string memory key, bytes32 value) internal returns (string memory) {
 241 |     |         return vm.serializeBytes32(jsonKey, key, value);
 242 |     |     }
 243 |     | 
 244 |     |     function serialize(string memory jsonKey, string memory key, bytes32[] memory value)
 245 |     |         internal
 246 |     |         returns (string memory)
 247 |     |     {
 248 |     |         return vm.serializeBytes32(jsonKey, key, value);
 249 |     |     }
 250 |     | 
 251 |     |     function serialize(string memory jsonKey, string memory key, bytes memory value) internal returns (string memory) {
 252 |     |         return vm.serializeBytes(jsonKey, key, value);
 253 |     |     }
 254 |     | 
 255 |     |     function serialize(string memory jsonKey, string memory key, bytes[] memory value)
 256 |     |         internal
 257 |     |         returns (string memory)
 258 |     |     {
 259 |     |         return vm.serializeBytes(jsonKey, key, value);
 260 |     |     }
 261 |     | 
 262 |     |     function serialize(string memory jsonKey, string memory key, string memory value)
 263 |     |         internal
 264 |     |         returns (string memory)
 265 |     |     {
 266 |     |         return vm.serializeString(jsonKey, key, value);
 267 |     |     }
 268 |     | 
 269 |     |     function serialize(string memory jsonKey, string memory key, string[] memory value)
 270 |     |         internal
 271 |     |         returns (string memory)
 272 |     |     {
 273 |     |         return vm.serializeString(jsonKey, key, value);
 274 |     |     }
 275 |     | 
 276 |     |     function write(string memory jsonKey, string memory path) internal {
 277 |     |         vm.writeToml(jsonKey, path);
 278 |     |     }
 279 |     | 
 280 |     |     function write(string memory jsonKey, string memory path, string memory valueKey) internal {
 281 |     |         vm.writeToml(jsonKey, path, valueKey);
 282 |     |     }
 283 |     | }
 284 |     | 

/home/phantom/Documents/azemora/azemora-contracts/lib/forge-std/src/StdUtils.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | pragma solidity >=0.6.2 <0.9.0;
   3 |     | 
   4 |     | pragma experimental ABIEncoderV2;
   5 |     | 
   6 |     | import {IMulticall3} from "./interfaces/IMulticall3.sol";
   7 |     | import {VmSafe} from "./Vm.sol";
   8 |     | 
   9 |     | abstract contract StdUtils {
  10 |     |     /*//////////////////////////////////////////////////////////////////////////
  11 |     |                                      CONSTANTS
  12 |     |     //////////////////////////////////////////////////////////////////////////*/
  13 |     | 
  14 |     |     IMulticall3 private constant multicall = IMulticall3(0xcA11bde05977b3631167028862bE2a173976CA11);
  15 |     |     VmSafe private constant vm = VmSafe(address(uint160(uint256(keccak256("hevm cheat code")))));
  16 |     |     address private constant CONSOLE2_ADDRESS = 0x000000000000000000636F6e736F6c652e6c6f67;
  17 |     |     uint256 private constant INT256_MIN_ABS =
  18 |     |         57896044618658097711785492504343953926634992332820282019728792003956564819968;
  19 |     |     uint256 private constant SECP256K1_ORDER =
  20 |     |         115792089237316195423570985008687907852837564279074904382605163141518161494337;
  21 |     |     uint256 private constant UINT256_MAX =
  22 |     |         115792089237316195423570985008687907853269984665640564039457584007913129639935;
  23 |     | 
  24 |     |     // Used by default when deploying with create2, https://github.com/Arachnid/deterministic-deployment-proxy.
  25 |     |     address private constant CREATE2_FACTORY = 0x4e59b44847b379578588920cA78FbF26c0B4956C;
  26 |     | 
  27 |     |     /*//////////////////////////////////////////////////////////////////////////
  28 |     |                                  INTERNAL FUNCTIONS
  29 |     |     //////////////////////////////////////////////////////////////////////////*/
  30 |     | 
  31 |     |     function _bound(uint256 x, uint256 min, uint256 max) internal pure virtual returns (uint256 result) {
  32 |     |         require(min <= max, "StdUtils bound(uint256,uint256,uint256): Max is less than min.");
  33 |     |         // If x is between min and max, return x directly. This is to ensure that dictionary values
  34 |     |         // do not get shifted if the min is nonzero. More info: https://github.com/foundry-rs/forge-std/issues/188
  35 |     |         if (x >= min && x <= max) return x;
  36 |     | 
  37 |     |         uint256 size = max - min + 1;
  38 |     | 
  39 |     |         // If the value is 0, 1, 2, 3, wrap that to min, min+1, min+2, min+3. Similarly for the UINT256_MAX side.
  40 |     |         // This helps ensure coverage of the min/max values.
  41 |     |         if (x <= 3 && size > x) return min + x;
  42 |     |         if (x >= UINT256_MAX - 3 && size > UINT256_MAX - x) return max - (UINT256_MAX - x);
  43 |     | 
  44 |     |         // Otherwise, wrap x into the range [min, max], i.e. the range is inclusive.
  45 |     |         if (x > max) {
  46 |     |             uint256 diff = x - max;
  47 |     |             uint256 rem = diff % size;
  48 |     |             if (rem == 0) return max;
  49 |     |             result = min + rem - 1;
  50 |     |         } else if (x < min) {
  51 |     |             uint256 diff = min - x;
  52 |     |             uint256 rem = diff % size;
  53 |     |             if (rem == 0) return min;
  54 |     |             result = max - rem + 1;
  55 |     |         }
  56 |     |     }
  57 |     | 
  58 |     |     function bound(uint256 x, uint256 min, uint256 max) internal pure virtual returns (uint256 result) {
  59 |     |         result = _bound(x, min, max);
  60 |     |         console2_log_StdUtils("Bound result", result);
  61 |     |     }
  62 |     | 
  63 |     |     function _bound(int256 x, int256 min, int256 max) internal pure virtual returns (int256 result) {
  64 |     |         require(min <= max, "StdUtils bound(int256,int256,int256): Max is less than min.");
  65 |     | 
  66 |     |         // Shifting all int256 values to uint256 to use _bound function. The range of two types are:
  67 |     |         // int256 : -(2**255) ~ (2**255 - 1)
  68 |     |         // uint256:     0     ~ (2**256 - 1)
  69 |     |         // So, add 2**255, INT256_MIN_ABS to the integer values.
  70 |     |         //
  71 |     |         // If the given integer value is -2**255, we cannot use `-uint256(-x)` because of the overflow.
  72 |     |         // So, use `~uint256(x) + 1` instead.
  73 |     |         uint256 _x = x < 0 ? (INT256_MIN_ABS - ~uint256(x) - 1) : (uint256(x) + INT256_MIN_ABS);
  74 |     |         uint256 _min = min < 0 ? (INT256_MIN_ABS - ~uint256(min) - 1) : (uint256(min) + INT256_MIN_ABS);
  75 |     |         uint256 _max = max < 0 ? (INT256_MIN_ABS - ~uint256(max) - 1) : (uint256(max) + INT256_MIN_ABS);
  76 |     | 
  77 |     |         uint256 y = _bound(_x, _min, _max);
  78 |     | 
  79 |     |         // To move it back to int256 value, subtract INT256_MIN_ABS at here.
  80 |     |         result = y < INT256_MIN_ABS ? int256(~(INT256_MIN_ABS - y) + 1) : int256(y - INT256_MIN_ABS);
  81 |     |     }
  82 |     | 
  83 |     |     function bound(int256 x, int256 min, int256 max) internal pure virtual returns (int256 result) {
  84 |     |         result = _bound(x, min, max);
  85 |     |         console2_log_StdUtils("Bound result", vm.toString(result));
  86 |     |     }
  87 |     | 
  88 |     |     function boundPrivateKey(uint256 privateKey) internal pure virtual returns (uint256 result) {
  89 |     |         result = _bound(privateKey, 1, SECP256K1_ORDER - 1);
  90 |     |     }
  91 |     | 
  92 |     |     function bytesToUint(bytes memory b) internal pure virtual returns (uint256) {
  93 |     |         require(b.length <= 32, "StdUtils bytesToUint(bytes): Bytes length exceeds 32.");
  94 |     |         return abi.decode(abi.encodePacked(new bytes(32 - b.length), b), (uint256));
  95 |     |     }
  96 |     | 
  97 |     |     /// @dev Compute the address a contract will be deployed at for a given deployer address and nonce
  98 |     |     /// @notice adapted from Solmate implementation (https://github.com/Rari-Capital/solmate/blob/main/src/utils/LibRLP.sol)
  99 |     |     function computeCreateAddress(address deployer, uint256 nonce) internal pure virtual returns (address) {
 100 |     |         console2_log_StdUtils("computeCreateAddress is deprecated. Please use vm.computeCreateAddress instead.");
 101 |     |         return vm.computeCreateAddress(deployer, nonce);
 102 |     |     }
 103 |     | 
 104 |     |     function computeCreate2Address(bytes32 salt, bytes32 initcodeHash, address deployer)
 105 |     |         internal
 106 |     |         pure
 107 |     |         virtual
 108 |     |         returns (address)
 109 |     |     {
 110 |     |         console2_log_StdUtils("computeCreate2Address is deprecated. Please use vm.computeCreate2Address instead.");
 111 |     |         return vm.computeCreate2Address(salt, initcodeHash, deployer);
 112 |     |     }
 113 |     | 
 114 |     |     /// @dev returns the address of a contract created with CREATE2 using the default CREATE2 deployer
 115 |     |     function computeCreate2Address(bytes32 salt, bytes32 initCodeHash) internal pure returns (address) {
 116 |     |         console2_log_StdUtils("computeCreate2Address is deprecated. Please use vm.computeCreate2Address instead.");
 117 |     |         return vm.computeCreate2Address(salt, initCodeHash);
 118 |     |     }
 119 |     | 
 120 |     |     /// @dev returns the hash of the init code (creation code + no args) used in CREATE2 with no constructor arguments
 121 |     |     /// @param creationCode the creation code of a contract C, as returned by type(C).creationCode
 122 |     |     function hashInitCode(bytes memory creationCode) internal pure returns (bytes32) {
 123 |     |         return hashInitCode(creationCode, "");
 124 |     |     }
 125 |     | 
 126 |     |     /// @dev returns the hash of the init code (creation code + ABI-encoded args) used in CREATE2
 127 |     |     /// @param creationCode the creation code of a contract C, as returned by type(C).creationCode
 128 |     |     /// @param args the ABI-encoded arguments to the constructor of C
 129 |     |     function hashInitCode(bytes memory creationCode, bytes memory args) internal pure returns (bytes32) {
 130 |     |         return keccak256(abi.encodePacked(creationCode, args));
 131 |     |     }
 132 |     | 
 133 |     |     // Performs a single call with Multicall3 to query the ERC-20 token balances of the given addresses.
 134 |     |     function getTokenBalances(address token, address[] memory addresses)
 135 |     |         internal
 136 |     |         virtual
 137 |     |         returns (uint256[] memory balances)
 138 |     |     {
 139 |     |         uint256 tokenCodeSize;
 140 |     |         assembly {
 141 |     |             tokenCodeSize := extcodesize(token)
 142 |     |         }
 143 |     |         require(tokenCodeSize > 0, "StdUtils getTokenBalances(address,address[]): Token address is not a contract.");
 144 |     | 
 145 |     |         // ABI encode the aggregate call to Multicall3.
 146 |     |         uint256 length = addresses.length;
 147 |     |         IMulticall3.Call[] memory calls = new IMulticall3.Call[](length);
 148 |     |         for (uint256 i = 0; i < length; ++i) {
 149 |     |             // 0x70a08231 = bytes4("balanceOf(address)"))
 150 |     |             calls[i] = IMulticall3.Call({target: token, callData: abi.encodeWithSelector(0x70a08231, (addresses[i]))});
 151 |     |         }
 152 |     | 
 153 |     |         // Make the aggregate call.
 154 |     |         (, bytes[] memory returnData) = multicall.aggregate(calls);
 155 |     | 
 156 |     |         // ABI decode the return data and return the balances.
 157 |     |         balances = new uint256[](length);
 158 |     |         for (uint256 i = 0; i < length; ++i) {
 159 |     |             balances[i] = abi.decode(returnData[i], (uint256));
 160 |     |         }
 161 |     |     }
 162 |     | 
 163 |     |     /*//////////////////////////////////////////////////////////////////////////
 164 |     |                                  PRIVATE FUNCTIONS
 165 |     |     //////////////////////////////////////////////////////////////////////////*/
 166 |     | 
 167 |     |     function addressFromLast20Bytes(bytes32 bytesValue) private pure returns (address) {
 168 |     |         return address(uint160(uint256(bytesValue)));
 169 |     |     }
 170 |     | 
 171 |     |     // This section is used to prevent the compilation of console, which shortens the compilation time when console is
 172 |     |     // not used elsewhere. We also trick the compiler into letting us make the console log methods as `pure` to avoid
 173 |     |     // any breaking changes to function signatures.
 174 |     |     function _castLogPayloadViewToPure(function(bytes memory) internal view fnIn)
 175 |     |         internal
 176 |     |         pure
 177 |     |         returns (function(bytes memory) internal pure fnOut)
 178 |     |     {
 179 |     |         assembly {
 180 |     |             fnOut := fnIn
 181 |     |         }
 182 |     |     }
 183 |     | 
 184 |     |     function _sendLogPayload(bytes memory payload) internal pure {
 185 |     |         _castLogPayloadViewToPure(_sendLogPayloadView)(payload);
 186 |     |     }
 187 |     | 
 188 |     |     function _sendLogPayloadView(bytes memory payload) private view {
 189 |     |         uint256 payloadLength = payload.length;
 190 |     |         address consoleAddress = CONSOLE2_ADDRESS;
 191 |     |         /// @solidity memory-safe-assembly
 192 |     |         assembly {
 193 |     |             let payloadStart := add(payload, 32)
 194 |     |             let r := staticcall(gas(), consoleAddress, payloadStart, payloadLength, 0, 0)
 195 |     |         }
 196 |     |     }
 197 |     | 
 198 |     |     function console2_log_StdUtils(string memory p0) private pure {
 199 |     |         _sendLogPayload(abi.encodeWithSignature("log(string)", p0));
 200 |     |     }
 201 |     | 
 202 |     |     function console2_log_StdUtils(string memory p0, uint256 p1) private pure {
 203 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,uint256)", p0, p1));
 204 |     |     }
 205 |     | 
 206 |     |     function console2_log_StdUtils(string memory p0, string memory p1) private pure {
 207 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,string)", p0, p1));
 208 |     |     }
 209 |     | }
 210 |     | 

/home/phantom/Documents/azemora/azemora-contracts/lib/forge-std/src/Test.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | pragma solidity >=0.6.2 <0.9.0;
  3 |     | 
  4 |     | pragma experimental ABIEncoderV2;
  5 |     | 
  6 |     | //  ABOUT
  7 |     | // Forge Std's default Test.
  8 |     | 
  9 |     | //  MODULES
 10 |     | import {console} from "./console.sol";
 11 |     | import {console2} from "./console2.sol";
 12 |     | import {safeconsole} from "./safeconsole.sol";
 13 |     | import {StdAssertions} from "./StdAssertions.sol";
 14 |     | import {StdChains} from "./StdChains.sol";
 15 |     | import {StdCheats} from "./StdCheats.sol";
 16 |     | import {StdConstants} from "./StdConstants.sol";
 17 |     | import {stdError} from "./StdError.sol";
 18 |     | import {StdInvariant} from "./StdInvariant.sol";
 19 |     | import {stdJson} from "./StdJson.sol";
 20 |     | import {stdMath} from "./StdMath.sol";
 21 |     | import {StdStorage, stdStorage} from "./StdStorage.sol";
 22 |     | import {StdStyle} from "./StdStyle.sol";
 23 |     | import {stdToml} from "./StdToml.sol";
 24 |     | import {StdUtils} from "./StdUtils.sol";
 25 |     | import {Vm} from "./Vm.sol";
 26 |     | 
 27 |     | //  BOILERPLATE
 28 |     | import {TestBase} from "./Base.sol";
 29 |     | 
 30 |     | //  TEST
 31 |     | abstract contract Test is TestBase, StdAssertions, StdChains, StdCheats, StdInvariant, StdUtils {
 32 |     |     // Note: IS_TEST() must return true.
 33 | *   |     bool public IS_TEST = true;
 34 |     | }
 35 |     | 

/home/phantom/Documents/azemora/azemora-contracts/lib/forge-std/src/Vm.sol
    1 |     | // Automatically @generated by scripts/vm.py. Do not modify manually.
    2 |     | 
    3 |     | // SPDX-License-Identifier: MIT OR Apache-2.0
    4 |     | pragma solidity >=0.6.2 <0.9.0;
    5 |     | pragma experimental ABIEncoderV2;
    6 |     | 
    7 |     | /// The `VmSafe` interface does not allow manipulation of the EVM state or other actions that may
    8 |     | /// result in Script simulations differing from on-chain execution. It is recommended to only use
    9 |     | /// these cheats in scripts.
   10 |     | interface VmSafe {
   11 |     |     /// A modification applied to either `msg.sender` or `tx.origin`. Returned by `readCallers`.
   12 |     |     enum CallerMode {
   13 |     |         // No caller modification is currently active.
   14 |     |         None,
   15 |     |         // A one time broadcast triggered by a `vm.broadcast()` call is currently active.
   16 |     |         Broadcast,
   17 |     |         // A recurrent broadcast triggered by a `vm.startBroadcast()` call is currently active.
   18 |     |         RecurrentBroadcast,
   19 |     |         // A one time prank triggered by a `vm.prank()` call is currently active.
   20 |     |         Prank,
   21 |     |         // A recurrent prank triggered by a `vm.startPrank()` call is currently active.
   22 |     |         RecurrentPrank
   23 |     |     }
   24 |     | 
   25 |     |     /// The kind of account access that occurred.
   26 |     |     enum AccountAccessKind {
   27 |     |         // The account was called.
   28 |     |         Call,
   29 |     |         // The account was called via delegatecall.
   30 |     |         DelegateCall,
   31 |     |         // The account was called via callcode.
   32 |     |         CallCode,
   33 |     |         // The account was called via staticcall.
   34 |     |         StaticCall,
   35 |     |         // The account was created.
   36 |     |         Create,
   37 |     |         // The account was selfdestructed.
   38 |     |         SelfDestruct,
   39 |     |         // Synthetic access indicating the current context has resumed after a previous sub-context (AccountAccess).
   40 |     |         Resume,
   41 |     |         // The account's balance was read.
   42 |     |         Balance,
   43 |     |         // The account's codesize was read.
   44 |     |         Extcodesize,
   45 |     |         // The account's codehash was read.
   46 |     |         Extcodehash,
   47 |     |         // The account's code was copied.
   48 |     |         Extcodecopy
   49 |     |     }
   50 |     | 
   51 |     |     /// Forge execution contexts.
   52 |     |     enum ForgeContext {
   53 |     |         // Test group execution context (test, coverage or snapshot).
   54 |     |         TestGroup,
   55 |     |         // `forge test` execution context.
   56 |     |         Test,
   57 |     |         // `forge coverage` execution context.
   58 |     |         Coverage,
   59 |     |         // `forge snapshot` execution context.
   60 |     |         Snapshot,
   61 |     |         // Script group execution context (dry run, broadcast or resume).
   62 |     |         ScriptGroup,
   63 |     |         // `forge script` execution context.
   64 |     |         ScriptDryRun,
   65 |     |         // `forge script --broadcast` execution context.
   66 |     |         ScriptBroadcast,
   67 |     |         // `forge script --resume` execution context.
   68 |     |         ScriptResume,
   69 |     |         // Unknown `forge` execution context.
   70 |     |         Unknown
   71 |     |     }
   72 |     | 
   73 |     |     /// The transaction type (`txType`) of the broadcast.
   74 |     |     enum BroadcastTxType {
   75 |     |         // Represents a CALL broadcast tx.
   76 |     |         Call,
   77 |     |         // Represents a CREATE broadcast tx.
   78 |     |         Create,
   79 |     |         // Represents a CREATE2 broadcast tx.
   80 |     |         Create2
   81 |     |     }
   82 |     | 
   83 |     |     /// An Ethereum log. Returned by `getRecordedLogs`.
   84 |     |     struct Log {
   85 |     |         // The topics of the log, including the signature, if any.
   86 |     |         bytes32[] topics;
   87 |     |         // The raw data of the log.
   88 |     |         bytes data;
   89 |     |         // The address of the log's emitter.
   90 |     |         address emitter;
   91 |     |     }
   92 |     | 
   93 |     |     /// An RPC URL and its alias. Returned by `rpcUrlStructs`.
   94 |     |     struct Rpc {
   95 |     |         // The alias of the RPC URL.
   96 |     |         string key;
   97 |     |         // The RPC URL.
   98 |     |         string url;
   99 |     |     }
  100 |     | 
  101 |     |     /// An RPC log object. Returned by `eth_getLogs`.
  102 |     |     struct EthGetLogs {
  103 |     |         // The address of the log's emitter.
  104 |     |         address emitter;
  105 |     |         // The topics of the log, including the signature, if any.
  106 |     |         bytes32[] topics;
  107 |     |         // The raw data of the log.
  108 |     |         bytes data;
  109 |     |         // The block hash.
  110 |     |         bytes32 blockHash;
  111 |     |         // The block number.
  112 |     |         uint64 blockNumber;
  113 |     |         // The transaction hash.
  114 |     |         bytes32 transactionHash;
  115 |     |         // The transaction index in the block.
  116 |     |         uint64 transactionIndex;
  117 |     |         // The log index.
  118 |     |         uint256 logIndex;
  119 |     |         // Whether the log was removed.
  120 |     |         bool removed;
  121 |     |     }
  122 |     | 
  123 |     |     /// A single entry in a directory listing. Returned by `readDir`.
  124 |     |     struct DirEntry {
  125 |     |         // The error message, if any.
  126 |     |         string errorMessage;
  127 |     |         // The path of the entry.
  128 |     |         string path;
  129 |     |         // The depth of the entry.
  130 |     |         uint64 depth;
  131 |     |         // Whether the entry is a directory.
  132 |     |         bool isDir;
  133 |     |         // Whether the entry is a symlink.
  134 |     |         bool isSymlink;
  135 |     |     }
  136 |     | 
  137 |     |     /// Metadata information about a file.
  138 |     |     /// This structure is returned from the `fsMetadata` function and represents known
  139 |     |     /// metadata about a file such as its permissions, size, modification
  140 |     |     /// times, etc.
  141 |     |     struct FsMetadata {
  142 |     |         // True if this metadata is for a directory.
  143 |     |         bool isDir;
  144 |     |         // True if this metadata is for a symlink.
  145 |     |         bool isSymlink;
  146 |     |         // The size of the file, in bytes, this metadata is for.
  147 |     |         uint256 length;
  148 |     |         // True if this metadata is for a readonly (unwritable) file.
  149 |     |         bool readOnly;
  150 |     |         // The last modification time listed in this metadata.
  151 |     |         uint256 modified;
  152 |     |         // The last access time of this metadata.
  153 |     |         uint256 accessed;
  154 |     |         // The creation time listed in this metadata.
  155 |     |         uint256 created;
  156 |     |     }
  157 |     | 
  158 |     |     /// A wallet with a public and private key.
  159 |     |     struct Wallet {
  160 |     |         // The wallet's address.
  161 |     |         address addr;
  162 |     |         // The wallet's public key `X`.
  163 |     |         uint256 publicKeyX;
  164 |     |         // The wallet's public key `Y`.
  165 |     |         uint256 publicKeyY;
  166 |     |         // The wallet's private key.
  167 |     |         uint256 privateKey;
  168 |     |     }
  169 |     | 
  170 |     |     /// The result of a `tryFfi` call.
  171 |     |     struct FfiResult {
  172 |     |         // The exit code of the call.
  173 |     |         int32 exitCode;
  174 |     |         // The optionally hex-decoded `stdout` data.
  175 |     |         bytes stdout;
  176 |     |         // The `stderr` data.
  177 |     |         bytes stderr;
  178 |     |     }
  179 |     | 
  180 |     |     /// Information on the chain and fork.
  181 |     |     struct ChainInfo {
  182 |     |         // The fork identifier. Set to zero if no fork is active.
  183 |     |         uint256 forkId;
  184 |     |         // The chain ID of the current fork.
  185 |     |         uint256 chainId;
  186 |     |     }
  187 |     | 
  188 |     |     /// Information about a blockchain.
  189 |     |     struct Chain {
  190 |     |         // The chain name.
  191 |     |         string name;
  192 |     |         // The chain's Chain ID.
  193 |     |         uint256 chainId;
  194 |     |         // The chain's alias. (i.e. what gets specified in `foundry.toml`).
  195 |     |         string chainAlias;
  196 |     |         // A default RPC endpoint for this chain.
  197 |     |         string rpcUrl;
  198 |     |     }
  199 |     | 
  200 |     |     /// The result of a `stopAndReturnStateDiff` call.
  201 |     |     struct AccountAccess {
  202 |     |         // The chain and fork the access occurred.
  203 |     |         ChainInfo chainInfo;
  204 |     |         // The kind of account access that determines what the account is.
  205 |     |         // If kind is Call, DelegateCall, StaticCall or CallCode, then the account is the callee.
  206 |     |         // If kind is Create, then the account is the newly created account.
  207 |     |         // If kind is SelfDestruct, then the account is the selfdestruct recipient.
  208 |     |         // If kind is a Resume, then account represents a account context that has resumed.
  209 |     |         AccountAccessKind kind;
  210 |     |         // The account that was accessed.
  211 |     |         // It's either the account created, callee or a selfdestruct recipient for CREATE, CALL or SELFDESTRUCT.
  212 |     |         address account;
  213 |     |         // What accessed the account.
  214 |     |         address accessor;
  215 |     |         // If the account was initialized or empty prior to the access.
  216 |     |         // An account is considered initialized if it has code, a
  217 |     |         // non-zero nonce, or a non-zero balance.
  218 |     |         bool initialized;
  219 |     |         // The previous balance of the accessed account.
  220 |     |         uint256 oldBalance;
  221 |     |         // The potential new balance of the accessed account.
  222 |     |         // That is, all balance changes are recorded here, even if reverts occurred.
  223 |     |         uint256 newBalance;
  224 |     |         // Code of the account deployed by CREATE.
  225 |     |         bytes deployedCode;
  226 |     |         // Value passed along with the account access
  227 |     |         uint256 value;
  228 |     |         // Input data provided to the CREATE or CALL
  229 |     |         bytes data;
  230 |     |         // If this access reverted in either the current or parent context.
  231 |     |         bool reverted;
  232 |     |         // An ordered list of storage accesses made during an account access operation.
  233 |     |         StorageAccess[] storageAccesses;
  234 |     |         // Call depth traversed during the recording of state differences
  235 |     |         uint64 depth;
  236 |     |     }
  237 |     | 
  238 |     |     /// The storage accessed during an `AccountAccess`.
  239 |     |     struct StorageAccess {
  240 |     |         // The account whose storage was accessed.
  241 |     |         address account;
  242 |     |         // The slot that was accessed.
  243 |     |         bytes32 slot;
  244 |     |         // If the access was a write.
  245 |     |         bool isWrite;
  246 |     |         // The previous value of the slot.
  247 |     |         bytes32 previousValue;
  248 |     |         // The new value of the slot.
  249 |     |         bytes32 newValue;
  250 |     |         // If the access was reverted.
  251 |     |         bool reverted;
  252 |     |     }
  253 |     | 
  254 |     |     /// Gas used. Returned by `lastCallGas`.
  255 |     |     struct Gas {
  256 |     |         // The gas limit of the call.
  257 |     |         uint64 gasLimit;
  258 |     |         // The total gas used.
  259 |     |         uint64 gasTotalUsed;
  260 |     |         // DEPRECATED: The amount of gas used for memory expansion. Ref: <https://github.com/foundry-rs/foundry/pull/7934#pullrequestreview-2069236939>
  261 |     |         uint64 gasMemoryUsed;
  262 |     |         // The amount of gas refunded.
  263 |     |         int64 gasRefunded;
  264 |     |         // The amount of gas remaining.
  265 |     |         uint64 gasRemaining;
  266 |     |     }
  267 |     | 
  268 |     |     /// The result of the `stopDebugTraceRecording` call
  269 |     |     struct DebugStep {
  270 |     |         // The stack before executing the step of the run.
  271 |     |         // stack\[0\] represents the top of the stack.
  272 |     |         // and only stack data relevant to the opcode execution is contained.
  273 |     |         uint256[] stack;
  274 |     |         // The memory input data before executing the step of the run.
  275 |     |         // only input data relevant to the opcode execution is contained.
  276 |     |         // e.g. for MLOAD, it will have memory\[offset:offset+32\] copied here.
  277 |     |         // the offset value can be get by the stack data.
  278 |     |         bytes memoryInput;
  279 |     |         // The opcode that was accessed.
  280 |     |         uint8 opcode;
  281 |     |         // The call depth of the step.
  282 |     |         uint64 depth;
  283 |     |         // Whether the call end up with out of gas error.
  284 |     |         bool isOutOfGas;
  285 |     |         // The contract address where the opcode is running
  286 |     |         address contractAddr;
  287 |     |     }
  288 |     | 
  289 |     |     /// Represents a transaction's broadcast details.
  290 |     |     struct BroadcastTxSummary {
  291 |     |         // The hash of the transaction that was broadcasted
  292 |     |         bytes32 txHash;
  293 |     |         // Represent the type of transaction among CALL, CREATE, CREATE2
  294 |     |         BroadcastTxType txType;
  295 |     |         // The address of the contract that was called or created.
  296 |     |         // This is address of the contract that is created if the txType is CREATE or CREATE2.
  297 |     |         address contractAddress;
  298 |     |         // The block number the transaction landed in.
  299 |     |         uint64 blockNumber;
  300 |     |         // Status of the transaction, retrieved from the transaction receipt.
  301 |     |         bool success;
  302 |     |     }
  303 |     | 
  304 |     |     /// Holds a signed EIP-7702 authorization for an authority account to delegate to an implementation.
  305 |     |     struct SignedDelegation {
  306 |     |         // The y-parity of the recovered secp256k1 signature (0 or 1).
  307 |     |         uint8 v;
  308 |     |         // First 32 bytes of the signature.
  309 |     |         bytes32 r;
  310 |     |         // Second 32 bytes of the signature.
  311 |     |         bytes32 s;
  312 |     |         // The current nonce of the authority account at signing time.
  313 |     |         // Used to ensure signature can't be replayed after account nonce changes.
  314 |     |         uint64 nonce;
  315 |     |         // Address of the contract implementation that will be delegated to.
  316 |     |         // Gets encoded into delegation code: 0xef0100 || implementation.
  317 |     |         address implementation;
  318 |     |     }
  319 |     | 
  320 |     |     /// Represents a "potential" revert reason from a single subsequent call when using `vm.assumeNoReverts`.
  321 |     |     /// Reverts that match will result in a FOUNDRY::ASSUME rejection, whereas unmatched reverts will be surfaced
  322 |     |     /// as normal.
  323 |     |     struct PotentialRevert {
  324 |     |         // The allowed origin of the revert opcode; address(0) allows reverts from any address
  325 |     |         address reverter;
  326 |     |         // When true, only matches on the beginning of the revert data, otherwise, matches on entire revert data
  327 |     |         bool partialMatch;
  328 |     |         // The data to use to match encountered reverts
  329 |     |         bytes revertData;
  330 |     |     }
  331 |     | 
  332 |     |     /// An EIP-2930 access list item.
  333 |     |     struct AccessListItem {
  334 |     |         // The address to be added in access list.
  335 |     |         address target;
  336 |     |         // The storage keys to be added in access list.
  337 |     |         bytes32[] storageKeys;
  338 |     |     }
  339 |     | 
  340 |     |     // ======== Crypto ========
  341 |     | 
  342 |     |     /// Derives a private key from the name, labels the account with that name, and returns the wallet.
  343 |     |     function createWallet(string calldata walletLabel) external returns (Wallet memory wallet);
  344 |     | 
  345 |     |     /// Generates a wallet from the private key and returns the wallet.
  346 |     |     function createWallet(uint256 privateKey) external returns (Wallet memory wallet);
  347 |     | 
  348 |     |     /// Generates a wallet from the private key, labels the account with that name, and returns the wallet.
  349 |     |     function createWallet(uint256 privateKey, string calldata walletLabel) external returns (Wallet memory wallet);
  350 |     | 
  351 |     |     /// Derive a private key from a provided mnenomic string (or mnenomic file path)
  352 |     |     /// at the derivation path `m/44'/60'/0'/0/{index}`.
  353 |     |     function deriveKey(string calldata mnemonic, uint32 index) external pure returns (uint256 privateKey);
  354 |     | 
  355 |     |     /// Derive a private key from a provided mnenomic string (or mnenomic file path)
  356 |     |     /// at `{derivationPath}{index}`.
  357 |     |     function deriveKey(string calldata mnemonic, string calldata derivationPath, uint32 index)
  358 |     |         external
  359 |     |         pure
  360 |     |         returns (uint256 privateKey);
  361 |     | 
  362 |     |     /// Derive a private key from a provided mnenomic string (or mnenomic file path) in the specified language
  363 |     |     /// at the derivation path `m/44'/60'/0'/0/{index}`.
  364 |     |     function deriveKey(string calldata mnemonic, uint32 index, string calldata language)
  365 |     |         external
  366 |     |         pure
  367 |     |         returns (uint256 privateKey);
  368 |     | 
  369 |     |     /// Derive a private key from a provided mnenomic string (or mnenomic file path) in the specified language
  370 |     |     /// at `{derivationPath}{index}`.
  371 |     |     function deriveKey(string calldata mnemonic, string calldata derivationPath, uint32 index, string calldata language)
  372 |     |         external
  373 |     |         pure
  374 |     |         returns (uint256 privateKey);
  375 |     | 
  376 |     |     /// Derives secp256r1 public key from the provided `privateKey`.
  377 |     |     function publicKeyP256(uint256 privateKey) external pure returns (uint256 publicKeyX, uint256 publicKeyY);
  378 |     | 
  379 |     |     /// Adds a private key to the local forge wallet and returns the address.
  380 |     |     function rememberKey(uint256 privateKey) external returns (address keyAddr);
  381 |     | 
  382 |     |     /// Derive a set number of wallets from a mnemonic at the derivation path `m/44'/60'/0'/0/{0..count}`.
  383 |     |     /// The respective private keys are saved to the local forge wallet for later use and their addresses are returned.
  384 |     |     function rememberKeys(string calldata mnemonic, string calldata derivationPath, uint32 count)
  385 |     |         external
  386 |     |         returns (address[] memory keyAddrs);
  387 |     | 
  388 |     |     /// Derive a set number of wallets from a mnemonic in the specified language at the derivation path `m/44'/60'/0'/0/{0..count}`.
  389 |     |     /// The respective private keys are saved to the local forge wallet for later use and their addresses are returned.
  390 |     |     function rememberKeys(
  391 |     |         string calldata mnemonic,
  392 |     |         string calldata derivationPath,
  393 |     |         string calldata language,
  394 |     |         uint32 count
  395 |     |     ) external returns (address[] memory keyAddrs);
  396 |     | 
  397 |     |     /// Signs data with a `Wallet`.
  398 |     |     /// Returns a compact signature (`r`, `vs`) as per EIP-2098, where `vs` encodes both the
  399 |     |     /// signature's `s` value, and the recovery id `v` in a single bytes32.
  400 |     |     /// This format reduces the signature size from 65 to 64 bytes.
  401 |     |     function signCompact(Wallet calldata wallet, bytes32 digest) external returns (bytes32 r, bytes32 vs);
  402 |     | 
  403 |     |     /// Signs `digest` with `privateKey` using the secp256k1 curve.
  404 |     |     /// Returns a compact signature (`r`, `vs`) as per EIP-2098, where `vs` encodes both the
  405 |     |     /// signature's `s` value, and the recovery id `v` in a single bytes32.
  406 |     |     /// This format reduces the signature size from 65 to 64 bytes.
  407 |     |     function signCompact(uint256 privateKey, bytes32 digest) external pure returns (bytes32 r, bytes32 vs);
  408 |     | 
  409 |     |     /// Signs `digest` with signer provided to script using the secp256k1 curve.
  410 |     |     /// Returns a compact signature (`r`, `vs`) as per EIP-2098, where `vs` encodes both the
  411 |     |     /// signature's `s` value, and the recovery id `v` in a single bytes32.
  412 |     |     /// This format reduces the signature size from 65 to 64 bytes.
  413 |     |     /// If `--sender` is provided, the signer with provided address is used, otherwise,
  414 |     |     /// if exactly one signer is provided to the script, that signer is used.
  415 |     |     /// Raises error if signer passed through `--sender` does not match any unlocked signers or
  416 |     |     /// if `--sender` is not provided and not exactly one signer is passed to the script.
  417 |     |     function signCompact(bytes32 digest) external pure returns (bytes32 r, bytes32 vs);
  418 |     | 
  419 |     |     /// Signs `digest` with signer provided to script using the secp256k1 curve.
  420 |     |     /// Returns a compact signature (`r`, `vs`) as per EIP-2098, where `vs` encodes both the
  421 |     |     /// signature's `s` value, and the recovery id `v` in a single bytes32.
  422 |     |     /// This format reduces the signature size from 65 to 64 bytes.
  423 |     |     /// Raises error if none of the signers passed into the script have provided address.
  424 |     |     function signCompact(address signer, bytes32 digest) external pure returns (bytes32 r, bytes32 vs);
  425 |     | 
  426 |     |     /// Signs `digest` with `privateKey` using the secp256r1 curve.
  427 |     |     function signP256(uint256 privateKey, bytes32 digest) external pure returns (bytes32 r, bytes32 s);
  428 |     | 
  429 |     |     /// Signs data with a `Wallet`.
  430 |     |     function sign(Wallet calldata wallet, bytes32 digest) external returns (uint8 v, bytes32 r, bytes32 s);
  431 |     | 
  432 |     |     /// Signs `digest` with `privateKey` using the secp256k1 curve.
  433 |     |     function sign(uint256 privateKey, bytes32 digest) external pure returns (uint8 v, bytes32 r, bytes32 s);
  434 |     | 
  435 |     |     /// Signs `digest` with signer provided to script using the secp256k1 curve.
  436 |     |     /// If `--sender` is provided, the signer with provided address is used, otherwise,
  437 |     |     /// if exactly one signer is provided to the script, that signer is used.
  438 |     |     /// Raises error if signer passed through `--sender` does not match any unlocked signers or
  439 |     |     /// if `--sender` is not provided and not exactly one signer is passed to the script.
  440 |     |     function sign(bytes32 digest) external pure returns (uint8 v, bytes32 r, bytes32 s);
  441 |     | 
  442 |     |     /// Signs `digest` with signer provided to script using the secp256k1 curve.
  443 |     |     /// Raises error if none of the signers passed into the script have provided address.
  444 |     |     function sign(address signer, bytes32 digest) external pure returns (uint8 v, bytes32 r, bytes32 s);
  445 |     | 
  446 |     |     // ======== Environment ========
  447 |     | 
  448 |     |     /// Gets the environment variable `name` and parses it as `address`.
  449 |     |     /// Reverts if the variable was not found or could not be parsed.
  450 |     |     function envAddress(string calldata name) external view returns (address value);
  451 |     | 
  452 |     |     /// Gets the environment variable `name` and parses it as an array of `address`, delimited by `delim`.
  453 |     |     /// Reverts if the variable was not found or could not be parsed.
  454 |     |     function envAddress(string calldata name, string calldata delim) external view returns (address[] memory value);
  455 |     | 
  456 |     |     /// Gets the environment variable `name` and parses it as `bool`.
  457 |     |     /// Reverts if the variable was not found or could not be parsed.
  458 |     |     function envBool(string calldata name) external view returns (bool value);
  459 |     | 
  460 |     |     /// Gets the environment variable `name` and parses it as an array of `bool`, delimited by `delim`.
  461 |     |     /// Reverts if the variable was not found or could not be parsed.
  462 |     |     function envBool(string calldata name, string calldata delim) external view returns (bool[] memory value);
  463 |     | 
  464 |     |     /// Gets the environment variable `name` and parses it as `bytes32`.
  465 |     |     /// Reverts if the variable was not found or could not be parsed.
  466 |     |     function envBytes32(string calldata name) external view returns (bytes32 value);
  467 |     | 
  468 |     |     /// Gets the environment variable `name` and parses it as an array of `bytes32`, delimited by `delim`.
  469 |     |     /// Reverts if the variable was not found or could not be parsed.
  470 |     |     function envBytes32(string calldata name, string calldata delim) external view returns (bytes32[] memory value);
  471 |     | 
  472 |     |     /// Gets the environment variable `name` and parses it as `bytes`.
  473 |     |     /// Reverts if the variable was not found or could not be parsed.
  474 |     |     function envBytes(string calldata name) external view returns (bytes memory value);
  475 |     | 
  476 |     |     /// Gets the environment variable `name` and parses it as an array of `bytes`, delimited by `delim`.
  477 |     |     /// Reverts if the variable was not found or could not be parsed.
  478 |     |     function envBytes(string calldata name, string calldata delim) external view returns (bytes[] memory value);
  479 |     | 
  480 |     |     /// Gets the environment variable `name` and returns true if it exists, else returns false.
  481 |     |     function envExists(string calldata name) external view returns (bool result);
  482 |     | 
  483 |     |     /// Gets the environment variable `name` and parses it as `int256`.
  484 |     |     /// Reverts if the variable was not found or could not be parsed.
  485 |     |     function envInt(string calldata name) external view returns (int256 value);
  486 |     | 
  487 |     |     /// Gets the environment variable `name` and parses it as an array of `int256`, delimited by `delim`.
  488 |     |     /// Reverts if the variable was not found or could not be parsed.
  489 |     |     function envInt(string calldata name, string calldata delim) external view returns (int256[] memory value);
  490 |     | 
  491 |     |     /// Gets the environment variable `name` and parses it as `bool`.
  492 |     |     /// Reverts if the variable could not be parsed.
  493 |     |     /// Returns `defaultValue` if the variable was not found.
  494 |     |     function envOr(string calldata name, bool defaultValue) external view returns (bool value);
  495 |     | 
  496 |     |     /// Gets the environment variable `name` and parses it as `uint256`.
  497 |     |     /// Reverts if the variable could not be parsed.
  498 |     |     /// Returns `defaultValue` if the variable was not found.
  499 |     |     function envOr(string calldata name, uint256 defaultValue) external view returns (uint256 value);
  500 |     | 
  501 |     |     /// Gets the environment variable `name` and parses it as an array of `address`, delimited by `delim`.
  502 |     |     /// Reverts if the variable could not be parsed.
  503 |     |     /// Returns `defaultValue` if the variable was not found.
  504 |     |     function envOr(string calldata name, string calldata delim, address[] calldata defaultValue)
  505 |     |         external
  506 |     |         view
  507 |     |         returns (address[] memory value);
  508 |     | 
  509 |     |     /// Gets the environment variable `name` and parses it as an array of `bytes32`, delimited by `delim`.
  510 |     |     /// Reverts if the variable could not be parsed.
  511 |     |     /// Returns `defaultValue` if the variable was not found.
  512 |     |     function envOr(string calldata name, string calldata delim, bytes32[] calldata defaultValue)
  513 |     |         external
  514 |     |         view
  515 |     |         returns (bytes32[] memory value);
  516 |     | 
  517 |     |     /// Gets the environment variable `name` and parses it as an array of `string`, delimited by `delim`.
  518 |     |     /// Reverts if the variable could not be parsed.
  519 |     |     /// Returns `defaultValue` if the variable was not found.
  520 |     |     function envOr(string calldata name, string calldata delim, string[] calldata defaultValue)
  521 |     |         external
  522 |     |         view
  523 |     |         returns (string[] memory value);
  524 |     | 
  525 |     |     /// Gets the environment variable `name` and parses it as an array of `bytes`, delimited by `delim`.
  526 |     |     /// Reverts if the variable could not be parsed.
  527 |     |     /// Returns `defaultValue` if the variable was not found.
  528 |     |     function envOr(string calldata name, string calldata delim, bytes[] calldata defaultValue)
  529 |     |         external
  530 |     |         view
  531 |     |         returns (bytes[] memory value);
  532 |     | 
  533 |     |     /// Gets the environment variable `name` and parses it as `int256`.
  534 |     |     /// Reverts if the variable could not be parsed.
  535 |     |     /// Returns `defaultValue` if the variable was not found.
  536 |     |     function envOr(string calldata name, int256 defaultValue) external view returns (int256 value);
  537 |     | 
  538 |     |     /// Gets the environment variable `name` and parses it as `address`.
  539 |     |     /// Reverts if the variable could not be parsed.
  540 |     |     /// Returns `defaultValue` if the variable was not found.
  541 |     |     function envOr(string calldata name, address defaultValue) external view returns (address value);
  542 |     | 
  543 |     |     /// Gets the environment variable `name` and parses it as `bytes32`.
  544 |     |     /// Reverts if the variable could not be parsed.
  545 |     |     /// Returns `defaultValue` if the variable was not found.
  546 |     |     function envOr(string calldata name, bytes32 defaultValue) external view returns (bytes32 value);
  547 |     | 
  548 |     |     /// Gets the environment variable `name` and parses it as `string`.
  549 |     |     /// Reverts if the variable could not be parsed.
  550 |     |     /// Returns `defaultValue` if the variable was not found.
  551 |     |     function envOr(string calldata name, string calldata defaultValue) external view returns (string memory value);
  552 |     | 
  553 |     |     /// Gets the environment variable `name` and parses it as `bytes`.
  554 |     |     /// Reverts if the variable could not be parsed.
  555 |     |     /// Returns `defaultValue` if the variable was not found.
  556 |     |     function envOr(string calldata name, bytes calldata defaultValue) external view returns (bytes memory value);
  557 |     | 
  558 |     |     /// Gets the environment variable `name` and parses it as an array of `bool`, delimited by `delim`.
  559 |     |     /// Reverts if the variable could not be parsed.
  560 |     |     /// Returns `defaultValue` if the variable was not found.
  561 |     |     function envOr(string calldata name, string calldata delim, bool[] calldata defaultValue)
  562 |     |         external
  563 |     |         view
  564 |     |         returns (bool[] memory value);
  565 |     | 
  566 |     |     /// Gets the environment variable `name` and parses it as an array of `uint256`, delimited by `delim`.
  567 |     |     /// Reverts if the variable could not be parsed.
  568 |     |     /// Returns `defaultValue` if the variable was not found.
  569 |     |     function envOr(string calldata name, string calldata delim, uint256[] calldata defaultValue)
  570 |     |         external
  571 |     |         view
  572 |     |         returns (uint256[] memory value);
  573 |     | 
  574 |     |     /// Gets the environment variable `name` and parses it as an array of `int256`, delimited by `delim`.
  575 |     |     /// Reverts if the variable could not be parsed.
  576 |     |     /// Returns `defaultValue` if the variable was not found.
  577 |     |     function envOr(string calldata name, string calldata delim, int256[] calldata defaultValue)
  578 |     |         external
  579 |     |         view
  580 |     |         returns (int256[] memory value);
  581 |     | 
  582 |     |     /// Gets the environment variable `name` and parses it as `string`.
  583 |     |     /// Reverts if the variable was not found or could not be parsed.
  584 |     |     function envString(string calldata name) external view returns (string memory value);
  585 |     | 
  586 |     |     /// Gets the environment variable `name` and parses it as an array of `string`, delimited by `delim`.
  587 |     |     /// Reverts if the variable was not found or could not be parsed.
  588 |     |     function envString(string calldata name, string calldata delim) external view returns (string[] memory value);
  589 |     | 
  590 |     |     /// Gets the environment variable `name` and parses it as `uint256`.
  591 |     |     /// Reverts if the variable was not found or could not be parsed.
  592 |     |     function envUint(string calldata name) external view returns (uint256 value);
  593 |     | 
  594 |     |     /// Gets the environment variable `name` and parses it as an array of `uint256`, delimited by `delim`.
  595 |     |     /// Reverts if the variable was not found or could not be parsed.
  596 |     |     function envUint(string calldata name, string calldata delim) external view returns (uint256[] memory value);
  597 |     | 
  598 |     |     /// Returns true if `forge` command was executed in given context.
  599 |     |     function isContext(ForgeContext context) external view returns (bool result);
  600 |     | 
  601 |     |     /// Sets environment variables.
  602 |     |     function setEnv(string calldata name, string calldata value) external;
  603 |     | 
  604 |     |     // ======== EVM ========
  605 |     | 
  606 |     |     /// Gets all accessed reads and write slot from a `vm.record` session, for a given address.
  607 |     |     function accesses(address target) external returns (bytes32[] memory readSlots, bytes32[] memory writeSlots);
  608 |     | 
  609 |     |     /// Gets the address for a given private key.
  610 |     |     function addr(uint256 privateKey) external pure returns (address keyAddr);
  611 |     | 
  612 |     |     /// Gets all the logs according to specified filter.
  613 |     |     function eth_getLogs(uint256 fromBlock, uint256 toBlock, address target, bytes32[] calldata topics)
  614 |     |         external
  615 |     |         returns (EthGetLogs[] memory logs);
  616 |     | 
  617 |     |     /// Gets the current `block.blobbasefee`.
  618 |     |     /// You should use this instead of `block.blobbasefee` if you use `vm.blobBaseFee`, as `block.blobbasefee` is assumed to be constant across a transaction,
  619 |     |     /// and as a result will get optimized out by the compiler.
  620 |     |     /// See https://github.com/foundry-rs/foundry/issues/6180
  621 |     |     function getBlobBaseFee() external view returns (uint256 blobBaseFee);
  622 |     | 
  623 |     |     /// Gets the current `block.number`.
  624 |     |     /// You should use this instead of `block.number` if you use `vm.roll`, as `block.number` is assumed to be constant across a transaction,
  625 |     |     /// and as a result will get optimized out by the compiler.
  626 |     |     /// See https://github.com/foundry-rs/foundry/issues/6180
  627 |     |     function getBlockNumber() external view returns (uint256 height);
  628 |     | 
  629 |     |     /// Gets the current `block.timestamp`.
  630 |     |     /// You should use this instead of `block.timestamp` if you use `vm.warp`, as `block.timestamp` is assumed to be constant across a transaction,
  631 |     |     /// and as a result will get optimized out by the compiler.
  632 |     |     /// See https://github.com/foundry-rs/foundry/issues/6180
  633 |     |     function getBlockTimestamp() external view returns (uint256 timestamp);
  634 |     | 
  635 |     |     /// Gets the map key and parent of a mapping at a given slot, for a given address.
  636 |     |     function getMappingKeyAndParentOf(address target, bytes32 elementSlot)
  637 |     |         external
  638 |     |         returns (bool found, bytes32 key, bytes32 parent);
  639 |     | 
  640 |     |     /// Gets the number of elements in the mapping at the given slot, for a given address.
  641 |     |     function getMappingLength(address target, bytes32 mappingSlot) external returns (uint256 length);
  642 |     | 
  643 |     |     /// Gets the elements at index idx of the mapping at the given slot, for a given address. The
  644 |     |     /// index must be less than the length of the mapping (i.e. the number of keys in the mapping).
  645 |     |     function getMappingSlotAt(address target, bytes32 mappingSlot, uint256 idx) external returns (bytes32 value);
  646 |     | 
  647 |     |     /// Gets the nonce of an account.
  648 |     |     function getNonce(address account) external view returns (uint64 nonce);
  649 |     | 
  650 |     |     /// Get the nonce of a `Wallet`.
  651 |     |     function getNonce(Wallet calldata wallet) external returns (uint64 nonce);
  652 |     | 
  653 |     |     /// Gets all the recorded logs.
  654 |     |     function getRecordedLogs() external returns (Log[] memory logs);
  655 |     | 
  656 |     |     /// Returns state diffs from current `vm.startStateDiffRecording` session.
  657 |     |     function getStateDiff() external view returns (string memory diff);
  658 |     | 
  659 |     |     /// Returns state diffs from current `vm.startStateDiffRecording` session, in json format.
  660 |     |     function getStateDiffJson() external view returns (string memory diff);
  661 |     | 
  662 |     |     /// Gets the gas used in the last call from the callee perspective.
  663 |     |     function lastCallGas() external view returns (Gas memory gas);
  664 |     | 
  665 |     |     /// Loads a storage slot from an address.
  666 |     |     function load(address target, bytes32 slot) external view returns (bytes32 data);
  667 |     | 
  668 |     |     /// Pauses gas metering (i.e. gas usage is not counted). Noop if already paused.
  669 |     |     function pauseGasMetering() external;
  670 |     | 
  671 |     |     /// Records all storage reads and writes. Use `accesses` to get the recorded data.
  672 |     |     /// Subsequent calls to `record` will clear the previous data.
  673 |     |     function record() external;
  674 |     | 
  675 |     |     /// Record all the transaction logs.
  676 |     |     function recordLogs() external;
  677 |     | 
  678 |     |     /// Reset gas metering (i.e. gas usage is set to gas limit).
  679 |     |     function resetGasMetering() external;
  680 |     | 
  681 |     |     /// Resumes gas metering (i.e. gas usage is counted again). Noop if already on.
  682 |     |     function resumeGasMetering() external;
  683 |     | 
  684 |     |     /// Performs an Ethereum JSON-RPC request to the current fork URL.
  685 |     |     function rpc(string calldata method, string calldata params) external returns (bytes memory data);
  686 |     | 
  687 |     |     /// Performs an Ethereum JSON-RPC request to the given endpoint.
  688 |     |     function rpc(string calldata urlOrAlias, string calldata method, string calldata params)
  689 |     |         external
  690 |     |         returns (bytes memory data);
  691 |     | 
  692 |     |     /// Records the debug trace during the run.
  693 |     |     function startDebugTraceRecording() external;
  694 |     | 
  695 |     |     /// Starts recording all map SSTOREs for later retrieval.
  696 |     |     function startMappingRecording() external;
  697 |     | 
  698 |     |     /// Record all account accesses as part of CREATE, CALL or SELFDESTRUCT opcodes in order,
  699 |     |     /// along with the context of the calls
  700 |     |     function startStateDiffRecording() external;
  701 |     | 
  702 |     |     /// Stop debug trace recording and returns the recorded debug trace.
  703 |     |     function stopAndReturnDebugTraceRecording() external returns (DebugStep[] memory step);
  704 |     | 
  705 |     |     /// Returns an ordered array of all account accesses from a `vm.startStateDiffRecording` session.
  706 |     |     function stopAndReturnStateDiff() external returns (AccountAccess[] memory accountAccesses);
  707 |     | 
  708 |     |     /// Stops recording all map SSTOREs for later retrieval and clears the recorded data.
  709 |     |     function stopMappingRecording() external;
  710 |     | 
  711 |     |     /// Stops recording storage reads and writes.
  712 |     |     function stopRecord() external;
  713 |     | 
  714 |     |     // ======== Filesystem ========
  715 |     | 
  716 |     |     /// Closes file for reading, resetting the offset and allowing to read it from beginning with readLine.
  717 |     |     /// `path` is relative to the project root.
  718 |     |     function closeFile(string calldata path) external;
  719 |     | 
  720 |     |     /// Copies the contents of one file to another. This function will **overwrite** the contents of `to`.
  721 |     |     /// On success, the total number of bytes copied is returned and it is equal to the length of the `to` file as reported by `metadata`.
  722 |     |     /// Both `from` and `to` are relative to the project root.
  723 |     |     function copyFile(string calldata from, string calldata to) external returns (uint64 copied);
  724 |     | 
  725 |     |     /// Creates a new, empty directory at the provided path.
  726 |     |     /// This cheatcode will revert in the following situations, but is not limited to just these cases:
  727 |     |     /// - User lacks permissions to modify `path`.
  728 |     |     /// - A parent of the given path doesn't exist and `recursive` is false.
  729 |     |     /// - `path` already exists and `recursive` is false.
  730 |     |     /// `path` is relative to the project root.
  731 |     |     function createDir(string calldata path, bool recursive) external;
  732 |     | 
  733 |     |     /// Deploys a contract from an artifact file. Takes in the relative path to the json file or the path to the
  734 |     |     /// artifact in the form of <path>:<contract>:<version> where <contract> and <version> parts are optional.
  735 |     |     function deployCode(string calldata artifactPath) external returns (address deployedAddress);
  736 |     | 
  737 |     |     /// Deploys a contract from an artifact file. Takes in the relative path to the json file or the path to the
  738 |     |     /// artifact in the form of <path>:<contract>:<version> where <contract> and <version> parts are optional.
  739 |     |     /// Additionally accepts abi-encoded constructor arguments.
  740 |     |     function deployCode(string calldata artifactPath, bytes calldata constructorArgs)
  741 |     |         external
  742 |     |         returns (address deployedAddress);
  743 |     | 
  744 |     |     /// Deploys a contract from an artifact file. Takes in the relative path to the json file or the path to the
  745 |     |     /// artifact in the form of <path>:<contract>:<version> where <contract> and <version> parts are optional.
  746 |     |     /// Additionally accepts `msg.value`.
  747 |     |     function deployCode(string calldata artifactPath, uint256 value) external returns (address deployedAddress);
  748 |     | 
  749 |     |     /// Deploys a contract from an artifact file. Takes in the relative path to the json file or the path to the
  750 |     |     /// artifact in the form of <path>:<contract>:<version> where <contract> and <version> parts are optional.
  751 |     |     /// Additionally accepts abi-encoded constructor arguments and `msg.value`.
  752 |     |     function deployCode(string calldata artifactPath, bytes calldata constructorArgs, uint256 value)
  753 |     |         external
  754 |     |         returns (address deployedAddress);
  755 |     | 
  756 |     |     /// Deploys a contract from an artifact file, using the CREATE2 salt. Takes in the relative path to the json file or the path to the
  757 |     |     /// artifact in the form of <path>:<contract>:<version> where <contract> and <version> parts are optional.
  758 |     |     function deployCode(string calldata artifactPath, bytes32 salt) external returns (address deployedAddress);
  759 |     | 
  760 |     |     /// Deploys a contract from an artifact file, using the CREATE2 salt. Takes in the relative path to the json file or the path to the
  761 |     |     /// artifact in the form of <path>:<contract>:<version> where <contract> and <version> parts are optional.
  762 |     |     /// Additionally accepts abi-encoded constructor arguments.
  763 |     |     function deployCode(string calldata artifactPath, bytes calldata constructorArgs, bytes32 salt)
  764 |     |         external
  765 |     |         returns (address deployedAddress);
  766 |     | 
  767 |     |     /// Deploys a contract from an artifact file, using the CREATE2 salt. Takes in the relative path to the json file or the path to the
  768 |     |     /// artifact in the form of <path>:<contract>:<version> where <contract> and <version> parts are optional.
  769 |     |     /// Additionally accepts `msg.value`.
  770 |     |     function deployCode(string calldata artifactPath, uint256 value, bytes32 salt)
  771 |     |         external
  772 |     |         returns (address deployedAddress);
  773 |     | 
  774 |     |     /// Deploys a contract from an artifact file, using the CREATE2 salt. Takes in the relative path to the json file or the path to the
  775 |     |     /// artifact in the form of <path>:<contract>:<version> where <contract> and <version> parts are optional.
  776 |     |     /// Additionally accepts abi-encoded constructor arguments and `msg.value`.
  777 |     |     function deployCode(string calldata artifactPath, bytes calldata constructorArgs, uint256 value, bytes32 salt)
  778 |     |         external
  779 |     |         returns (address deployedAddress);
  780 |     | 
  781 |     |     /// Returns true if the given path points to an existing entity, else returns false.
  782 |     |     function exists(string calldata path) external view returns (bool result);
  783 |     | 
  784 |     |     /// Performs a foreign function call via the terminal.
  785 |     |     function ffi(string[] calldata commandInput) external returns (bytes memory result);
  786 |     | 
  787 |     |     /// Given a path, query the file system to get information about a file, directory, etc.
  788 |     |     function fsMetadata(string calldata path) external view returns (FsMetadata memory metadata);
  789 |     | 
  790 |     |     /// Gets the artifact path from code (aka. creation code).
  791 |     |     function getArtifactPathByCode(bytes calldata code) external view returns (string memory path);
  792 |     | 
  793 |     |     /// Gets the artifact path from deployed code (aka. runtime code).
  794 |     |     function getArtifactPathByDeployedCode(bytes calldata deployedCode) external view returns (string memory path);
  795 |     | 
  796 |     |     /// Returns the most recent broadcast for the given contract on `chainId` matching `txType`.
  797 |     |     /// For example:
  798 |     |     /// The most recent deployment can be fetched by passing `txType` as `CREATE` or `CREATE2`.
  799 |     |     /// The most recent call can be fetched by passing `txType` as `CALL`.
  800 |     |     function getBroadcast(string calldata contractName, uint64 chainId, BroadcastTxType txType)
  801 |     |         external
  802 |     |         view
  803 |     |         returns (BroadcastTxSummary memory);
  804 |     | 
  805 |     |     /// Returns all broadcasts for the given contract on `chainId` with the specified `txType`.
  806 |     |     /// Sorted such that the most recent broadcast is the first element, and the oldest is the last. i.e descending order of BroadcastTxSummary.blockNumber.
  807 |     |     function getBroadcasts(string calldata contractName, uint64 chainId, BroadcastTxType txType)
  808 |     |         external
  809 |     |         view
  810 |     |         returns (BroadcastTxSummary[] memory);
  811 |     | 
  812 |     |     /// Returns all broadcasts for the given contract on `chainId`.
  813 |     |     /// Sorted such that the most recent broadcast is the first element, and the oldest is the last. i.e descending order of BroadcastTxSummary.blockNumber.
  814 |     |     function getBroadcasts(string calldata contractName, uint64 chainId)
  815 |     |         external
  816 |     |         view
  817 |     |         returns (BroadcastTxSummary[] memory);
  818 |     | 
  819 |     |     /// Gets the creation bytecode from an artifact file. Takes in the relative path to the json file or the path to the
  820 |     |     /// artifact in the form of <path>:<contract>:<version> where <contract> and <version> parts are optional.
  821 |     |     function getCode(string calldata artifactPath) external view returns (bytes memory creationBytecode);
  822 |     | 
  823 |     |     /// Gets the deployed bytecode from an artifact file. Takes in the relative path to the json file or the path to the
  824 |     |     /// artifact in the form of <path>:<contract>:<version> where <contract> and <version> parts are optional.
  825 |     |     function getDeployedCode(string calldata artifactPath) external view returns (bytes memory runtimeBytecode);
  826 |     | 
  827 |     |     /// Returns the most recent deployment for the current `chainId`.
  828 |     |     function getDeployment(string calldata contractName) external view returns (address deployedAddress);
  829 |     | 
  830 |     |     /// Returns the most recent deployment for the given contract on `chainId`
  831 |     |     function getDeployment(string calldata contractName, uint64 chainId)
  832 |     |         external
  833 |     |         view
  834 |     |         returns (address deployedAddress);
  835 |     | 
  836 |     |     /// Returns all deployments for the given contract on `chainId`
  837 |     |     /// Sorted in descending order of deployment time i.e descending order of BroadcastTxSummary.blockNumber.
  838 |     |     /// The most recent deployment is the first element, and the oldest is the last.
  839 |     |     function getDeployments(string calldata contractName, uint64 chainId)
  840 |     |         external
  841 |     |         view
  842 |     |         returns (address[] memory deployedAddresses);
  843 |     | 
  844 |     |     /// Returns true if the path exists on disk and is pointing at a directory, else returns false.
  845 |     |     function isDir(string calldata path) external view returns (bool result);
  846 |     | 
  847 |     |     /// Returns true if the path exists on disk and is pointing at a regular file, else returns false.
  848 |     |     function isFile(string calldata path) external view returns (bool result);
  849 |     | 
  850 |     |     /// Get the path of the current project root.
  851 |     |     function projectRoot() external view returns (string memory path);
  852 |     | 
  853 |     |     /// Prompts the user for a string value in the terminal.
  854 |     |     function prompt(string calldata promptText) external returns (string memory input);
  855 |     | 
  856 |     |     /// Prompts the user for an address in the terminal.
  857 |     |     function promptAddress(string calldata promptText) external returns (address);
  858 |     | 
  859 |     |     /// Prompts the user for a hidden string value in the terminal.
  860 |     |     function promptSecret(string calldata promptText) external returns (string memory input);
  861 |     | 
  862 |     |     /// Prompts the user for hidden uint256 in the terminal (usually pk).
  863 |     |     function promptSecretUint(string calldata promptText) external returns (uint256);
  864 |     | 
  865 |     |     /// Prompts the user for uint256 in the terminal.
  866 |     |     function promptUint(string calldata promptText) external returns (uint256);
  867 |     | 
  868 |     |     /// Reads the directory at the given path recursively, up to `maxDepth`.
  869 |     |     /// `maxDepth` defaults to 1, meaning only the direct children of the given directory will be returned.
  870 |     |     /// Follows symbolic links if `followLinks` is true.
  871 |     |     function readDir(string calldata path) external view returns (DirEntry[] memory entries);
  872 |     | 
  873 |     |     /// See `readDir(string)`.
  874 |     |     function readDir(string calldata path, uint64 maxDepth) external view returns (DirEntry[] memory entries);
  875 |     | 
  876 |     |     /// See `readDir(string)`.
  877 |     |     function readDir(string calldata path, uint64 maxDepth, bool followLinks)
  878 |     |         external
  879 |     |         view
  880 |     |         returns (DirEntry[] memory entries);
  881 |     | 
  882 |     |     /// Reads the entire content of file to string. `path` is relative to the project root.
  883 |     |     function readFile(string calldata path) external view returns (string memory data);
  884 |     | 
  885 |     |     /// Reads the entire content of file as binary. `path` is relative to the project root.
  886 |     |     function readFileBinary(string calldata path) external view returns (bytes memory data);
  887 |     | 
  888 |     |     /// Reads next line of file to string.
  889 |     |     function readLine(string calldata path) external view returns (string memory line);
  890 |     | 
  891 |     |     /// Reads a symbolic link, returning the path that the link points to.
  892 |     |     /// This cheatcode will revert in the following situations, but is not limited to just these cases:
  893 |     |     /// - `path` is not a symbolic link.
  894 |     |     /// - `path` does not exist.
  895 |     |     function readLink(string calldata linkPath) external view returns (string memory targetPath);
  896 |     | 
  897 |     |     /// Removes a directory at the provided path.
  898 |     |     /// This cheatcode will revert in the following situations, but is not limited to just these cases:
  899 |     |     /// - `path` doesn't exist.
  900 |     |     /// - `path` isn't a directory.
  901 |     |     /// - User lacks permissions to modify `path`.
  902 |     |     /// - The directory is not empty and `recursive` is false.
  903 |     |     /// `path` is relative to the project root.
  904 |     |     function removeDir(string calldata path, bool recursive) external;
  905 |     | 
  906 |     |     /// Removes a file from the filesystem.
  907 |     |     /// This cheatcode will revert in the following situations, but is not limited to just these cases:
  908 |     |     /// - `path` points to a directory.
  909 |     |     /// - The file doesn't exist.
  910 |     |     /// - The user lacks permissions to remove the file.
  911 |     |     /// `path` is relative to the project root.
  912 |     |     function removeFile(string calldata path) external;
  913 |     | 
  914 |     |     /// Performs a foreign function call via terminal and returns the exit code, stdout, and stderr.
  915 |     |     function tryFfi(string[] calldata commandInput) external returns (FfiResult memory result);
  916 |     | 
  917 |     |     /// Returns the time since unix epoch in milliseconds.
  918 |     |     function unixTime() external view returns (uint256 milliseconds);
  919 |     | 
  920 |     |     /// Writes data to file, creating a file if it does not exist, and entirely replacing its contents if it does.
  921 |     |     /// `path` is relative to the project root.
  922 |     |     function writeFile(string calldata path, string calldata data) external;
  923 |     | 
  924 |     |     /// Writes binary data to a file, creating a file if it does not exist, and entirely replacing its contents if it does.
  925 |     |     /// `path` is relative to the project root.
  926 |     |     function writeFileBinary(string calldata path, bytes calldata data) external;
  927 |     | 
  928 |     |     /// Writes line to file, creating a file if it does not exist.
  929 |     |     /// `path` is relative to the project root.
  930 |     |     function writeLine(string calldata path, string calldata data) external;
  931 |     | 
  932 |     |     // ======== JSON ========
  933 |     | 
  934 |     |     /// Checks if `key` exists in a JSON object.
  935 |     |     function keyExistsJson(string calldata json, string calldata key) external view returns (bool);
  936 |     | 
  937 |     |     /// Parses a string of JSON data at `key` and coerces it to `address`.
  938 |     |     function parseJsonAddress(string calldata json, string calldata key) external pure returns (address);
  939 |     | 
  940 |     |     /// Parses a string of JSON data at `key` and coerces it to `address[]`.
  941 |     |     function parseJsonAddressArray(string calldata json, string calldata key)
  942 |     |         external
  943 |     |         pure
  944 |     |         returns (address[] memory);
  945 |     | 
  946 |     |     /// Parses a string of JSON data at `key` and coerces it to `bool`.
  947 |     |     function parseJsonBool(string calldata json, string calldata key) external pure returns (bool);
  948 |     | 
  949 |     |     /// Parses a string of JSON data at `key` and coerces it to `bool[]`.
  950 |     |     function parseJsonBoolArray(string calldata json, string calldata key) external pure returns (bool[] memory);
  951 |     | 
  952 |     |     /// Parses a string of JSON data at `key` and coerces it to `bytes`.
  953 |     |     function parseJsonBytes(string calldata json, string calldata key) external pure returns (bytes memory);
  954 |     | 
  955 |     |     /// Parses a string of JSON data at `key` and coerces it to `bytes32`.
  956 |     |     function parseJsonBytes32(string calldata json, string calldata key) external pure returns (bytes32);
  957 |     | 
  958 |     |     /// Parses a string of JSON data at `key` and coerces it to `bytes32[]`.
  959 |     |     function parseJsonBytes32Array(string calldata json, string calldata key)
  960 |     |         external
  961 |     |         pure
  962 |     |         returns (bytes32[] memory);
  963 |     | 
  964 |     |     /// Parses a string of JSON data at `key` and coerces it to `bytes[]`.
  965 |     |     function parseJsonBytesArray(string calldata json, string calldata key) external pure returns (bytes[] memory);
  966 |     | 
  967 |     |     /// Parses a string of JSON data at `key` and coerces it to `int256`.
  968 |     |     function parseJsonInt(string calldata json, string calldata key) external pure returns (int256);
  969 |     | 
  970 |     |     /// Parses a string of JSON data at `key` and coerces it to `int256[]`.
  971 |     |     function parseJsonIntArray(string calldata json, string calldata key) external pure returns (int256[] memory);
  972 |     | 
  973 |     |     /// Returns an array of all the keys in a JSON object.
  974 |     |     function parseJsonKeys(string calldata json, string calldata key) external pure returns (string[] memory keys);
  975 |     | 
  976 |     |     /// Parses a string of JSON data at `key` and coerces it to `string`.
  977 |     |     function parseJsonString(string calldata json, string calldata key) external pure returns (string memory);
  978 |     | 
  979 |     |     /// Parses a string of JSON data at `key` and coerces it to `string[]`.
  980 |     |     function parseJsonStringArray(string calldata json, string calldata key) external pure returns (string[] memory);
  981 |     | 
  982 |     |     /// Parses a string of JSON data at `key` and coerces it to type array corresponding to `typeDescription`.
  983 |     |     function parseJsonTypeArray(string calldata json, string calldata key, string calldata typeDescription)
  984 |     |         external
  985 |     |         pure
  986 |     |         returns (bytes memory);
  987 |     | 
  988 |     |     /// Parses a string of JSON data and coerces it to type corresponding to `typeDescription`.
  989 |     |     function parseJsonType(string calldata json, string calldata typeDescription)
  990 |     |         external
  991 |     |         pure
  992 |     |         returns (bytes memory);
  993 |     | 
  994 |     |     /// Parses a string of JSON data at `key` and coerces it to type corresponding to `typeDescription`.
  995 |     |     function parseJsonType(string calldata json, string calldata key, string calldata typeDescription)
  996 |     |         external
  997 |     |         pure
  998 |     |         returns (bytes memory);
  999 |     | 
 1000 |     |     /// Parses a string of JSON data at `key` and coerces it to `uint256`.
 1001 |     |     function parseJsonUint(string calldata json, string calldata key) external pure returns (uint256);
 1002 |     | 
 1003 |     |     /// Parses a string of JSON data at `key` and coerces it to `uint256[]`.
 1004 |     |     function parseJsonUintArray(string calldata json, string calldata key) external pure returns (uint256[] memory);
 1005 |     | 
 1006 |     |     /// ABI-encodes a JSON object.
 1007 |     |     function parseJson(string calldata json) external pure returns (bytes memory abiEncodedData);
 1008 |     | 
 1009 |     |     /// ABI-encodes a JSON object at `key`.
 1010 |     |     function parseJson(string calldata json, string calldata key) external pure returns (bytes memory abiEncodedData);
 1011 |     | 
 1012 |     |     /// See `serializeJson`.
 1013 |     |     function serializeAddress(string calldata objectKey, string calldata valueKey, address value)
 1014 |     |         external
 1015 |     |         returns (string memory json);
 1016 |     | 
 1017 |     |     /// See `serializeJson`.
 1018 |     |     function serializeAddress(string calldata objectKey, string calldata valueKey, address[] calldata values)
 1019 |     |         external
 1020 |     |         returns (string memory json);
 1021 |     | 
 1022 |     |     /// See `serializeJson`.
 1023 |     |     function serializeBool(string calldata objectKey, string calldata valueKey, bool value)
 1024 |     |         external
 1025 |     |         returns (string memory json);
 1026 |     | 
 1027 |     |     /// See `serializeJson`.
 1028 |     |     function serializeBool(string calldata objectKey, string calldata valueKey, bool[] calldata values)
 1029 |     |         external
 1030 |     |         returns (string memory json);
 1031 |     | 
 1032 |     |     /// See `serializeJson`.
 1033 |     |     function serializeBytes32(string calldata objectKey, string calldata valueKey, bytes32 value)
 1034 |     |         external
 1035 |     |         returns (string memory json);
 1036 |     | 
 1037 |     |     /// See `serializeJson`.
 1038 |     |     function serializeBytes32(string calldata objectKey, string calldata valueKey, bytes32[] calldata values)
 1039 |     |         external
 1040 |     |         returns (string memory json);
 1041 |     | 
 1042 |     |     /// See `serializeJson`.
 1043 |     |     function serializeBytes(string calldata objectKey, string calldata valueKey, bytes calldata value)
 1044 |     |         external
 1045 |     |         returns (string memory json);
 1046 |     | 
 1047 |     |     /// See `serializeJson`.
 1048 |     |     function serializeBytes(string calldata objectKey, string calldata valueKey, bytes[] calldata values)
 1049 |     |         external
 1050 |     |         returns (string memory json);
 1051 |     | 
 1052 |     |     /// See `serializeJson`.
 1053 |     |     function serializeInt(string calldata objectKey, string calldata valueKey, int256 value)
 1054 |     |         external
 1055 |     |         returns (string memory json);
 1056 |     | 
 1057 |     |     /// See `serializeJson`.
 1058 |     |     function serializeInt(string calldata objectKey, string calldata valueKey, int256[] calldata values)
 1059 |     |         external
 1060 |     |         returns (string memory json);
 1061 |     | 
 1062 |     |     /// Serializes a key and value to a JSON object stored in-memory that can be later written to a file.
 1063 |     |     /// Returns the stringified version of the specific JSON file up to that moment.
 1064 |     |     function serializeJson(string calldata objectKey, string calldata value) external returns (string memory json);
 1065 |     | 
 1066 |     |     /// See `serializeJson`.
 1067 |     |     function serializeJsonType(string calldata typeDescription, bytes calldata value)
 1068 |     |         external
 1069 |     |         pure
 1070 |     |         returns (string memory json);
 1071 |     | 
 1072 |     |     /// See `serializeJson`.
 1073 |     |     function serializeJsonType(
 1074 |     |         string calldata objectKey,
 1075 |     |         string calldata valueKey,
 1076 |     |         string calldata typeDescription,
 1077 |     |         bytes calldata value
 1078 |     |     ) external returns (string memory json);
 1079 |     | 
 1080 |     |     /// See `serializeJson`.
 1081 |     |     function serializeString(string calldata objectKey, string calldata valueKey, string calldata value)
 1082 |     |         external
 1083 |     |         returns (string memory json);
 1084 |     | 
 1085 |     |     /// See `serializeJson`.
 1086 |     |     function serializeString(string calldata objectKey, string calldata valueKey, string[] calldata values)
 1087 |     |         external
 1088 |     |         returns (string memory json);
 1089 |     | 
 1090 |     |     /// See `serializeJson`.
 1091 |     |     function serializeUintToHex(string calldata objectKey, string calldata valueKey, uint256 value)
 1092 |     |         external
 1093 |     |         returns (string memory json);
 1094 |     | 
 1095 |     |     /// See `serializeJson`.
 1096 |     |     function serializeUint(string calldata objectKey, string calldata valueKey, uint256 value)
 1097 |     |         external
 1098 |     |         returns (string memory json);
 1099 |     | 
 1100 |     |     /// See `serializeJson`.
 1101 |     |     function serializeUint(string calldata objectKey, string calldata valueKey, uint256[] calldata values)
 1102 |     |         external
 1103 |     |         returns (string memory json);
 1104 |     | 
 1105 |     |     /// Write a serialized JSON object to a file. If the file exists, it will be overwritten.
 1106 |     |     function writeJson(string calldata json, string calldata path) external;
 1107 |     | 
 1108 |     |     /// Write a serialized JSON object to an **existing** JSON file, replacing a value with key = <value_key.>
 1109 |     |     /// This is useful to replace a specific value of a JSON file, without having to parse the entire thing.
 1110 |     |     function writeJson(string calldata json, string calldata path, string calldata valueKey) external;
 1111 |     | 
 1112 |     |     /// Checks if `key` exists in a JSON object
 1113 |     |     /// `keyExists` is being deprecated in favor of `keyExistsJson`. It will be removed in future versions.
 1114 |     |     function keyExists(string calldata json, string calldata key) external view returns (bool);
 1115 |     | 
 1116 |     |     // ======== Scripting ========
 1117 |     | 
 1118 |     |     /// Attach an EIP-4844 blob to the next call
 1119 |     |     function attachBlob(bytes calldata blob) external;
 1120 |     | 
 1121 |     |     /// Designate the next call as an EIP-7702 transaction
 1122 |     |     function attachDelegation(SignedDelegation calldata signedDelegation) external;
 1123 |     | 
 1124 |     |     /// Designate the next call as an EIP-7702 transaction, with optional cross-chain validity.
 1125 |     |     function attachDelegation(SignedDelegation calldata signedDelegation, bool crossChain) external;
 1126 |     | 
 1127 |     |     /// Takes a signed transaction and broadcasts it to the network.
 1128 |     |     function broadcastRawTransaction(bytes calldata data) external;
 1129 |     | 
 1130 |     |     /// Has the next call (at this call depth only) create transactions that can later be signed and sent onchain.
 1131 |     |     /// Broadcasting address is determined by checking the following in order:
 1132 |     |     /// 1. If `--sender` argument was provided, that address is used.
 1133 |     |     /// 2. If exactly one signer (e.g. private key, hw wallet, keystore) is set when `forge broadcast` is invoked, that signer is used.
 1134 |     |     /// 3. Otherwise, default foundry sender (1804c8AB1F12E6bbf3894d4083f33e07309d1f38) is used.
 1135 |     |     function broadcast() external;
 1136 |     | 
 1137 |     |     /// Has the next call (at this call depth only) create a transaction with the address provided
 1138 |     |     /// as the sender that can later be signed and sent onchain.
 1139 |     |     function broadcast(address signer) external;
 1140 |     | 
 1141 |     |     /// Has the next call (at this call depth only) create a transaction with the private key
 1142 |     |     /// provided as the sender that can later be signed and sent onchain.
 1143 |     |     function broadcast(uint256 privateKey) external;
 1144 |     | 
 1145 |     |     /// Returns addresses of available unlocked wallets in the script environment.
 1146 |     |     function getWallets() external returns (address[] memory wallets);
 1147 |     | 
 1148 |     |     /// Sign an EIP-7702 authorization and designate the next call as an EIP-7702 transaction
 1149 |     |     function signAndAttachDelegation(address implementation, uint256 privateKey)
 1150 |     |         external
 1151 |     |         returns (SignedDelegation memory signedDelegation);
 1152 |     | 
 1153 |     |     /// Sign an EIP-7702 authorization and designate the next call as an EIP-7702 transaction for specific nonce
 1154 |     |     function signAndAttachDelegation(address implementation, uint256 privateKey, uint64 nonce)
 1155 |     |         external
 1156 |     |         returns (SignedDelegation memory signedDelegation);
 1157 |     | 
 1158 |     |     /// Sign an EIP-7702 authorization and designate the next call as an EIP-7702 transaction, with optional cross-chain validity.
 1159 |     |     function signAndAttachDelegation(address implementation, uint256 privateKey, bool crossChain)
 1160 |     |         external
 1161 |     |         returns (SignedDelegation memory signedDelegation);
 1162 |     | 
 1163 |     |     /// Sign an EIP-7702 authorization for delegation
 1164 |     |     function signDelegation(address implementation, uint256 privateKey)
 1165 |     |         external
 1166 |     |         returns (SignedDelegation memory signedDelegation);
 1167 |     | 
 1168 |     |     /// Sign an EIP-7702 authorization for delegation for specific nonce
 1169 |     |     function signDelegation(address implementation, uint256 privateKey, uint64 nonce)
 1170 |     |         external
 1171 |     |         returns (SignedDelegation memory signedDelegation);
 1172 |     | 
 1173 |     |     /// Sign an EIP-7702 authorization for delegation, with optional cross-chain validity.
 1174 |     |     function signDelegation(address implementation, uint256 privateKey, bool crossChain)
 1175 |     |         external
 1176 |     |         returns (SignedDelegation memory signedDelegation);
 1177 |     | 
 1178 |     |     /// Has all subsequent calls (at this call depth only) create transactions that can later be signed and sent onchain.
 1179 |     |     /// Broadcasting address is determined by checking the following in order:
 1180 |     |     /// 1. If `--sender` argument was provided, that address is used.
 1181 |     |     /// 2. If exactly one signer (e.g. private key, hw wallet, keystore) is set when `forge broadcast` is invoked, that signer is used.
 1182 |     |     /// 3. Otherwise, default foundry sender (1804c8AB1F12E6bbf3894d4083f33e07309d1f38) is used.
 1183 |     |     function startBroadcast() external;
 1184 |     | 
 1185 |     |     /// Has all subsequent calls (at this call depth only) create transactions with the address
 1186 |     |     /// provided that can later be signed and sent onchain.
 1187 |     |     function startBroadcast(address signer) external;
 1188 |     | 
 1189 |     |     /// Has all subsequent calls (at this call depth only) create transactions with the private key
 1190 |     |     /// provided that can later be signed and sent onchain.
 1191 |     |     function startBroadcast(uint256 privateKey) external;
 1192 |     | 
 1193 |     |     /// Stops collecting onchain transactions.
 1194 |     |     function stopBroadcast() external;
 1195 |     | 
 1196 |     |     // ======== String ========
 1197 |     | 
 1198 |     |     /// Returns true if `search` is found in `subject`, false otherwise.
 1199 |     |     function contains(string calldata subject, string calldata search) external returns (bool result);
 1200 |     | 
 1201 |     |     /// Returns the index of the first occurrence of a `key` in an `input` string.
 1202 |     |     /// Returns `NOT_FOUND` (i.e. `type(uint256).max`) if the `key` is not found.
 1203 |     |     /// Returns 0 in case of an empty `key`.
 1204 |     |     function indexOf(string calldata input, string calldata key) external pure returns (uint256);
 1205 |     | 
 1206 |     |     /// Parses the given `string` into an `address`.
 1207 |     |     function parseAddress(string calldata stringifiedValue) external pure returns (address parsedValue);
 1208 |     | 
 1209 |     |     /// Parses the given `string` into a `bool`.
 1210 |     |     function parseBool(string calldata stringifiedValue) external pure returns (bool parsedValue);
 1211 |     | 
 1212 |     |     /// Parses the given `string` into `bytes`.
 1213 |     |     function parseBytes(string calldata stringifiedValue) external pure returns (bytes memory parsedValue);
 1214 |     | 
 1215 |     |     /// Parses the given `string` into a `bytes32`.
 1216 |     |     function parseBytes32(string calldata stringifiedValue) external pure returns (bytes32 parsedValue);
 1217 |     | 
 1218 |     |     /// Parses the given `string` into a `int256`.
 1219 |     |     function parseInt(string calldata stringifiedValue) external pure returns (int256 parsedValue);
 1220 |     | 
 1221 |     |     /// Parses the given `string` into a `uint256`.
 1222 |     |     function parseUint(string calldata stringifiedValue) external pure returns (uint256 parsedValue);
 1223 |     | 
 1224 |     |     /// Replaces occurrences of `from` in the given `string` with `to`.
 1225 |     |     function replace(string calldata input, string calldata from, string calldata to)
 1226 |     |         external
 1227 |     |         pure
 1228 |     |         returns (string memory output);
 1229 |     | 
 1230 |     |     /// Splits the given `string` into an array of strings divided by the `delimiter`.
 1231 |     |     function split(string calldata input, string calldata delimiter) external pure returns (string[] memory outputs);
 1232 |     | 
 1233 |     |     /// Converts the given `string` value to Lowercase.
 1234 |     |     function toLowercase(string calldata input) external pure returns (string memory output);
 1235 |     | 
 1236 |     |     /// Converts the given value to a `string`.
 1237 |     |     function toString(address value) external pure returns (string memory stringifiedValue);
 1238 |     | 
 1239 |     |     /// Converts the given value to a `string`.
 1240 |     |     function toString(bytes calldata value) external pure returns (string memory stringifiedValue);
 1241 |     | 
 1242 |     |     /// Converts the given value to a `string`.
 1243 |     |     function toString(bytes32 value) external pure returns (string memory stringifiedValue);
 1244 |     | 
 1245 |     |     /// Converts the given value to a `string`.
 1246 |     |     function toString(bool value) external pure returns (string memory stringifiedValue);
 1247 |     | 
 1248 |     |     /// Converts the given value to a `string`.
 1249 |     |     function toString(uint256 value) external pure returns (string memory stringifiedValue);
 1250 |     | 
 1251 |     |     /// Converts the given value to a `string`.
 1252 |     |     function toString(int256 value) external pure returns (string memory stringifiedValue);
 1253 |     | 
 1254 |     |     /// Converts the given `string` value to Uppercase.
 1255 |     |     function toUppercase(string calldata input) external pure returns (string memory output);
 1256 |     | 
 1257 |     |     /// Trims leading and trailing whitespace from the given `string` value.
 1258 |     |     function trim(string calldata input) external pure returns (string memory output);
 1259 |     | 
 1260 |     |     // ======== Testing ========
 1261 |     | 
 1262 |     |     /// Compares two `uint256` values. Expects difference to be less than or equal to `maxDelta`.
 1263 |     |     /// Formats values with decimals in failure message.
 1264 |     |     function assertApproxEqAbsDecimal(uint256 left, uint256 right, uint256 maxDelta, uint256 decimals) external pure;
 1265 |     | 
 1266 |     |     /// Compares two `uint256` values. Expects difference to be less than or equal to `maxDelta`.
 1267 |     |     /// Formats values with decimals in failure message. Includes error message into revert string on failure.
 1268 |     |     function assertApproxEqAbsDecimal(
 1269 |     |         uint256 left,
 1270 |     |         uint256 right,
 1271 |     |         uint256 maxDelta,
 1272 |     |         uint256 decimals,
 1273 |     |         string calldata error
 1274 |     |     ) external pure;
 1275 |     | 
 1276 |     |     /// Compares two `int256` values. Expects difference to be less than or equal to `maxDelta`.
 1277 |     |     /// Formats values with decimals in failure message.
 1278 |     |     function assertApproxEqAbsDecimal(int256 left, int256 right, uint256 maxDelta, uint256 decimals) external pure;
 1279 |     | 
 1280 |     |     /// Compares two `int256` values. Expects difference to be less than or equal to `maxDelta`.
 1281 |     |     /// Formats values with decimals in failure message. Includes error message into revert string on failure.
 1282 |     |     function assertApproxEqAbsDecimal(
 1283 |     |         int256 left,
 1284 |     |         int256 right,
 1285 |     |         uint256 maxDelta,
 1286 |     |         uint256 decimals,
 1287 |     |         string calldata error
 1288 |     |     ) external pure;
 1289 |     | 
 1290 |     |     /// Compares two `uint256` values. Expects difference to be less than or equal to `maxDelta`.
 1291 |     |     function assertApproxEqAbs(uint256 left, uint256 right, uint256 maxDelta) external pure;
 1292 |     | 
 1293 |     |     /// Compares two `uint256` values. Expects difference to be less than or equal to `maxDelta`.
 1294 |     |     /// Includes error message into revert string on failure.
 1295 |     |     function assertApproxEqAbs(uint256 left, uint256 right, uint256 maxDelta, string calldata error) external pure;
 1296 |     | 
 1297 |     |     /// Compares two `int256` values. Expects difference to be less than or equal to `maxDelta`.
 1298 |     |     function assertApproxEqAbs(int256 left, int256 right, uint256 maxDelta) external pure;
 1299 |     | 
 1300 |     |     /// Compares two `int256` values. Expects difference to be less than or equal to `maxDelta`.
 1301 |     |     /// Includes error message into revert string on failure.
 1302 |     |     function assertApproxEqAbs(int256 left, int256 right, uint256 maxDelta, string calldata error) external pure;
 1303 |     | 
 1304 |     |     /// Compares two `uint256` values. Expects relative difference in percents to be less than or equal to `maxPercentDelta`.
 1305 |     |     /// `maxPercentDelta` is an 18 decimal fixed point number, where 1e18 == 100%
 1306 |     |     /// Formats values with decimals in failure message.
 1307 |     |     function assertApproxEqRelDecimal(uint256 left, uint256 right, uint256 maxPercentDelta, uint256 decimals)
 1308 |     |         external
 1309 |     |         pure;
 1310 |     | 
 1311 |     |     /// Compares two `uint256` values. Expects relative difference in percents to be less than or equal to `maxPercentDelta`.
 1312 |     |     /// `maxPercentDelta` is an 18 decimal fixed point number, where 1e18 == 100%
 1313 |     |     /// Formats values with decimals in failure message. Includes error message into revert string on failure.
 1314 |     |     function assertApproxEqRelDecimal(
 1315 |     |         uint256 left,
 1316 |     |         uint256 right,
 1317 |     |         uint256 maxPercentDelta,
 1318 |     |         uint256 decimals,
 1319 |     |         string calldata error
 1320 |     |     ) external pure;
 1321 |     | 
 1322 |     |     /// Compares two `int256` values. Expects relative difference in percents to be less than or equal to `maxPercentDelta`.
 1323 |     |     /// `maxPercentDelta` is an 18 decimal fixed point number, where 1e18 == 100%
 1324 |     |     /// Formats values with decimals in failure message.
 1325 |     |     function assertApproxEqRelDecimal(int256 left, int256 right, uint256 maxPercentDelta, uint256 decimals)
 1326 |     |         external
 1327 |     |         pure;
 1328 |     | 
 1329 |     |     /// Compares two `int256` values. Expects relative difference in percents to be less than or equal to `maxPercentDelta`.
 1330 |     |     /// `maxPercentDelta` is an 18 decimal fixed point number, where 1e18 == 100%
 1331 |     |     /// Formats values with decimals in failure message. Includes error message into revert string on failure.
 1332 |     |     function assertApproxEqRelDecimal(
 1333 |     |         int256 left,
 1334 |     |         int256 right,
 1335 |     |         uint256 maxPercentDelta,
 1336 |     |         uint256 decimals,
 1337 |     |         string calldata error
 1338 |     |     ) external pure;
 1339 |     | 
 1340 |     |     /// Compares two `uint256` values. Expects relative difference in percents to be less than or equal to `maxPercentDelta`.
 1341 |     |     /// `maxPercentDelta` is an 18 decimal fixed point number, where 1e18 == 100%
 1342 |     |     function assertApproxEqRel(uint256 left, uint256 right, uint256 maxPercentDelta) external pure;
 1343 |     | 
 1344 |     |     /// Compares two `uint256` values. Expects relative difference in percents to be less than or equal to `maxPercentDelta`.
 1345 |     |     /// `maxPercentDelta` is an 18 decimal fixed point number, where 1e18 == 100%
 1346 |     |     /// Includes error message into revert string on failure.
 1347 |     |     function assertApproxEqRel(uint256 left, uint256 right, uint256 maxPercentDelta, string calldata error)
 1348 |     |         external
 1349 |     |         pure;
 1350 |     | 
 1351 |     |     /// Compares two `int256` values. Expects relative difference in percents to be less than or equal to `maxPercentDelta`.
 1352 |     |     /// `maxPercentDelta` is an 18 decimal fixed point number, where 1e18 == 100%
 1353 |     |     function assertApproxEqRel(int256 left, int256 right, uint256 maxPercentDelta) external pure;
 1354 |     | 
 1355 |     |     /// Compares two `int256` values. Expects relative difference in percents to be less than or equal to `maxPercentDelta`.
 1356 |     |     /// `maxPercentDelta` is an 18 decimal fixed point number, where 1e18 == 100%
 1357 |     |     /// Includes error message into revert string on failure.
 1358 |     |     function assertApproxEqRel(int256 left, int256 right, uint256 maxPercentDelta, string calldata error)
 1359 |     |         external
 1360 |     |         pure;
 1361 |     | 
 1362 |     |     /// Asserts that two `uint256` values are equal, formatting them with decimals in failure message.
 1363 |     |     function assertEqDecimal(uint256 left, uint256 right, uint256 decimals) external pure;
 1364 |     | 
 1365 |     |     /// Asserts that two `uint256` values are equal, formatting them with decimals in failure message.
 1366 |     |     /// Includes error message into revert string on failure.
 1367 |     |     function assertEqDecimal(uint256 left, uint256 right, uint256 decimals, string calldata error) external pure;
 1368 |     | 
 1369 |     |     /// Asserts that two `int256` values are equal, formatting them with decimals in failure message.
 1370 |     |     function assertEqDecimal(int256 left, int256 right, uint256 decimals) external pure;
 1371 |     | 
 1372 |     |     /// Asserts that two `int256` values are equal, formatting them with decimals in failure message.
 1373 |     |     /// Includes error message into revert string on failure.
 1374 |     |     function assertEqDecimal(int256 left, int256 right, uint256 decimals, string calldata error) external pure;
 1375 |     | 
 1376 |     |     /// Asserts that two `bool` values are equal.
 1377 |     |     function assertEq(bool left, bool right) external pure;
 1378 |     | 
 1379 |     |     /// Asserts that two `bool` values are equal and includes error message into revert string on failure.
 1380 |     |     function assertEq(bool left, bool right, string calldata error) external pure;
 1381 |     | 
 1382 |     |     /// Asserts that two `string` values are equal.
 1383 |     |     function assertEq(string calldata left, string calldata right) external pure;
 1384 |     | 
 1385 |     |     /// Asserts that two `string` values are equal and includes error message into revert string on failure.
 1386 |     |     function assertEq(string calldata left, string calldata right, string calldata error) external pure;
 1387 |     | 
 1388 |     |     /// Asserts that two `bytes` values are equal.
 1389 |     |     function assertEq(bytes calldata left, bytes calldata right) external pure;
 1390 |     | 
 1391 |     |     /// Asserts that two `bytes` values are equal and includes error message into revert string on failure.
 1392 |     |     function assertEq(bytes calldata left, bytes calldata right, string calldata error) external pure;
 1393 |     | 
 1394 |     |     /// Asserts that two arrays of `bool` values are equal.
 1395 |     |     function assertEq(bool[] calldata left, bool[] calldata right) external pure;
 1396 |     | 
 1397 |     |     /// Asserts that two arrays of `bool` values are equal and includes error message into revert string on failure.
 1398 |     |     function assertEq(bool[] calldata left, bool[] calldata right, string calldata error) external pure;
 1399 |     | 
 1400 |     |     /// Asserts that two arrays of `uint256 values are equal.
 1401 |     |     function assertEq(uint256[] calldata left, uint256[] calldata right) external pure;
 1402 |     | 
 1403 |     |     /// Asserts that two arrays of `uint256` values are equal and includes error message into revert string on failure.
 1404 |     |     function assertEq(uint256[] calldata left, uint256[] calldata right, string calldata error) external pure;
 1405 |     | 
 1406 |     |     /// Asserts that two arrays of `int256` values are equal.
 1407 |     |     function assertEq(int256[] calldata left, int256[] calldata right) external pure;
 1408 |     | 
 1409 |     |     /// Asserts that two arrays of `int256` values are equal and includes error message into revert string on failure.
 1410 |     |     function assertEq(int256[] calldata left, int256[] calldata right, string calldata error) external pure;
 1411 |     | 
 1412 |     |     /// Asserts that two `uint256` values are equal.
 1413 |     |     function assertEq(uint256 left, uint256 right) external pure;
 1414 |     | 
 1415 |     |     /// Asserts that two arrays of `address` values are equal.
 1416 |     |     function assertEq(address[] calldata left, address[] calldata right) external pure;
 1417 |     | 
 1418 |     |     /// Asserts that two arrays of `address` values are equal and includes error message into revert string on failure.
 1419 |     |     function assertEq(address[] calldata left, address[] calldata right, string calldata error) external pure;
 1420 |     | 
 1421 |     |     /// Asserts that two arrays of `bytes32` values are equal.
 1422 |     |     function assertEq(bytes32[] calldata left, bytes32[] calldata right) external pure;
 1423 |     | 
 1424 |     |     /// Asserts that two arrays of `bytes32` values are equal and includes error message into revert string on failure.
 1425 |     |     function assertEq(bytes32[] calldata left, bytes32[] calldata right, string calldata error) external pure;
 1426 |     | 
 1427 |     |     /// Asserts that two arrays of `string` values are equal.
 1428 |     |     function assertEq(string[] calldata left, string[] calldata right) external pure;
 1429 |     | 
 1430 |     |     /// Asserts that two arrays of `string` values are equal and includes error message into revert string on failure.
 1431 |     |     function assertEq(string[] calldata left, string[] calldata right, string calldata error) external pure;
 1432 |     | 
 1433 |     |     /// Asserts that two arrays of `bytes` values are equal.
 1434 |     |     function assertEq(bytes[] calldata left, bytes[] calldata right) external pure;
 1435 |     | 
 1436 |     |     /// Asserts that two arrays of `bytes` values are equal and includes error message into revert string on failure.
 1437 |     |     function assertEq(bytes[] calldata left, bytes[] calldata right, string calldata error) external pure;
 1438 |     | 
 1439 |     |     /// Asserts that two `uint256` values are equal and includes error message into revert string on failure.
 1440 |     |     function assertEq(uint256 left, uint256 right, string calldata error) external pure;
 1441 |     | 
 1442 |     |     /// Asserts that two `int256` values are equal.
 1443 |     |     function assertEq(int256 left, int256 right) external pure;
 1444 |     | 
 1445 |     |     /// Asserts that two `int256` values are equal and includes error message into revert string on failure.
 1446 |     |     function assertEq(int256 left, int256 right, string calldata error) external pure;
 1447 |     | 
 1448 |     |     /// Asserts that two `address` values are equal.
 1449 |     |     function assertEq(address left, address right) external pure;
 1450 |     | 
 1451 |     |     /// Asserts that two `address` values are equal and includes error message into revert string on failure.
 1452 |     |     function assertEq(address left, address right, string calldata error) external pure;
 1453 |     | 
 1454 |     |     /// Asserts that two `bytes32` values are equal.
 1455 |     |     function assertEq(bytes32 left, bytes32 right) external pure;
 1456 |     | 
 1457 |     |     /// Asserts that two `bytes32` values are equal and includes error message into revert string on failure.
 1458 |     |     function assertEq(bytes32 left, bytes32 right, string calldata error) external pure;
 1459 |     | 
 1460 |     |     /// Asserts that the given condition is false.
 1461 |     |     function assertFalse(bool condition) external pure;
 1462 |     | 
 1463 |     |     /// Asserts that the given condition is false and includes error message into revert string on failure.
 1464 |     |     function assertFalse(bool condition, string calldata error) external pure;
 1465 |     | 
 1466 |     |     /// Compares two `uint256` values. Expects first value to be greater than or equal to second.
 1467 |     |     /// Formats values with decimals in failure message.
 1468 |     |     function assertGeDecimal(uint256 left, uint256 right, uint256 decimals) external pure;
 1469 |     | 
 1470 |     |     /// Compares two `uint256` values. Expects first value to be greater than or equal to second.
 1471 |     |     /// Formats values with decimals in failure message. Includes error message into revert string on failure.
 1472 |     |     function assertGeDecimal(uint256 left, uint256 right, uint256 decimals, string calldata error) external pure;
 1473 |     | 
 1474 |     |     /// Compares two `int256` values. Expects first value to be greater than or equal to second.
 1475 |     |     /// Formats values with decimals in failure message.
 1476 |     |     function assertGeDecimal(int256 left, int256 right, uint256 decimals) external pure;
 1477 |     | 
 1478 |     |     /// Compares two `int256` values. Expects first value to be greater than or equal to second.
 1479 |     |     /// Formats values with decimals in failure message. Includes error message into revert string on failure.
 1480 |     |     function assertGeDecimal(int256 left, int256 right, uint256 decimals, string calldata error) external pure;
 1481 |     | 
 1482 |     |     /// Compares two `uint256` values. Expects first value to be greater than or equal to second.
 1483 |     |     function assertGe(uint256 left, uint256 right) external pure;
 1484 |     | 
 1485 |     |     /// Compares two `uint256` values. Expects first value to be greater than or equal to second.
 1486 |     |     /// Includes error message into revert string on failure.
 1487 |     |     function assertGe(uint256 left, uint256 right, string calldata error) external pure;
 1488 |     | 
 1489 |     |     /// Compares two `int256` values. Expects first value to be greater than or equal to second.
 1490 |     |     function assertGe(int256 left, int256 right) external pure;
 1491 |     | 
 1492 |     |     /// Compares two `int256` values. Expects first value to be greater than or equal to second.
 1493 |     |     /// Includes error message into revert string on failure.
 1494 |     |     function assertGe(int256 left, int256 right, string calldata error) external pure;
 1495 |     | 
 1496 |     |     /// Compares two `uint256` values. Expects first value to be greater than second.
 1497 |     |     /// Formats values with decimals in failure message.
 1498 |     |     function assertGtDecimal(uint256 left, uint256 right, uint256 decimals) external pure;
 1499 |     | 
 1500 |     |     /// Compares two `uint256` values. Expects first value to be greater than second.
 1501 |     |     /// Formats values with decimals in failure message. Includes error message into revert string on failure.
 1502 |     |     function assertGtDecimal(uint256 left, uint256 right, uint256 decimals, string calldata error) external pure;
 1503 |     | 
 1504 |     |     /// Compares two `int256` values. Expects first value to be greater than second.
 1505 |     |     /// Formats values with decimals in failure message.
 1506 |     |     function assertGtDecimal(int256 left, int256 right, uint256 decimals) external pure;
 1507 |     | 
 1508 |     |     /// Compares two `int256` values. Expects first value to be greater than second.
 1509 |     |     /// Formats values with decimals in failure message. Includes error message into revert string on failure.
 1510 |     |     function assertGtDecimal(int256 left, int256 right, uint256 decimals, string calldata error) external pure;
 1511 |     | 
 1512 |     |     /// Compares two `uint256` values. Expects first value to be greater than second.
 1513 |     |     function assertGt(uint256 left, uint256 right) external pure;
 1514 |     | 
 1515 |     |     /// Compares two `uint256` values. Expects first value to be greater than second.
 1516 |     |     /// Includes error message into revert string on failure.
 1517 |     |     function assertGt(uint256 left, uint256 right, string calldata error) external pure;
 1518 |     | 
 1519 |     |     /// Compares two `int256` values. Expects first value to be greater than second.
 1520 |     |     function assertGt(int256 left, int256 right) external pure;
 1521 |     | 
 1522 |     |     /// Compares two `int256` values. Expects first value to be greater than second.
 1523 |     |     /// Includes error message into revert string on failure.
 1524 |     |     function assertGt(int256 left, int256 right, string calldata error) external pure;
 1525 |     | 
 1526 |     |     /// Compares two `uint256` values. Expects first value to be less than or equal to second.
 1527 |     |     /// Formats values with decimals in failure message.
 1528 |     |     function assertLeDecimal(uint256 left, uint256 right, uint256 decimals) external pure;
 1529 |     | 
 1530 |     |     /// Compares two `uint256` values. Expects first value to be less than or equal to second.
 1531 |     |     /// Formats values with decimals in failure message. Includes error message into revert string on failure.
 1532 |     |     function assertLeDecimal(uint256 left, uint256 right, uint256 decimals, string calldata error) external pure;
 1533 |     | 
 1534 |     |     /// Compares two `int256` values. Expects first value to be less than or equal to second.
 1535 |     |     /// Formats values with decimals in failure message.
 1536 |     |     function assertLeDecimal(int256 left, int256 right, uint256 decimals) external pure;
 1537 |     | 
 1538 |     |     /// Compares two `int256` values. Expects first value to be less than or equal to second.
 1539 |     |     /// Formats values with decimals in failure message. Includes error message into revert string on failure.
 1540 |     |     function assertLeDecimal(int256 left, int256 right, uint256 decimals, string calldata error) external pure;
 1541 |     | 
 1542 |     |     /// Compares two `uint256` values. Expects first value to be less than or equal to second.
 1543 |     |     function assertLe(uint256 left, uint256 right) external pure;
 1544 |     | 
 1545 |     |     /// Compares two `uint256` values. Expects first value to be less than or equal to second.
 1546 |     |     /// Includes error message into revert string on failure.
 1547 |     |     function assertLe(uint256 left, uint256 right, string calldata error) external pure;
 1548 |     | 
 1549 |     |     /// Compares two `int256` values. Expects first value to be less than or equal to second.
 1550 |     |     function assertLe(int256 left, int256 right) external pure;
 1551 |     | 
 1552 |     |     /// Compares two `int256` values. Expects first value to be less than or equal to second.
 1553 |     |     /// Includes error message into revert string on failure.
 1554 |     |     function assertLe(int256 left, int256 right, string calldata error) external pure;
 1555 |     | 
 1556 |     |     /// Compares two `uint256` values. Expects first value to be less than second.
 1557 |     |     /// Formats values with decimals in failure message.
 1558 |     |     function assertLtDecimal(uint256 left, uint256 right, uint256 decimals) external pure;
 1559 |     | 
 1560 |     |     /// Compares two `uint256` values. Expects first value to be less than second.
 1561 |     |     /// Formats values with decimals in failure message. Includes error message into revert string on failure.
 1562 |     |     function assertLtDecimal(uint256 left, uint256 right, uint256 decimals, string calldata error) external pure;
 1563 |     | 
 1564 |     |     /// Compares two `int256` values. Expects first value to be less than second.
 1565 |     |     /// Formats values with decimals in failure message.
 1566 |     |     function assertLtDecimal(int256 left, int256 right, uint256 decimals) external pure;
 1567 |     | 
 1568 |     |     /// Compares two `int256` values. Expects first value to be less than second.
 1569 |     |     /// Formats values with decimals in failure message. Includes error message into revert string on failure.
 1570 |     |     function assertLtDecimal(int256 left, int256 right, uint256 decimals, string calldata error) external pure;
 1571 |     | 
 1572 |     |     /// Compares two `uint256` values. Expects first value to be less than second.
 1573 |     |     function assertLt(uint256 left, uint256 right) external pure;
 1574 |     | 
 1575 |     |     /// Compares two `uint256` values. Expects first value to be less than second.
 1576 |     |     /// Includes error message into revert string on failure.
 1577 |     |     function assertLt(uint256 left, uint256 right, string calldata error) external pure;
 1578 |     | 
 1579 |     |     /// Compares two `int256` values. Expects first value to be less than second.
 1580 |     |     function assertLt(int256 left, int256 right) external pure;
 1581 |     | 
 1582 |     |     /// Compares two `int256` values. Expects first value to be less than second.
 1583 |     |     /// Includes error message into revert string on failure.
 1584 |     |     function assertLt(int256 left, int256 right, string calldata error) external pure;
 1585 |     | 
 1586 |     |     /// Asserts that two `uint256` values are not equal, formatting them with decimals in failure message.
 1587 |     |     function assertNotEqDecimal(uint256 left, uint256 right, uint256 decimals) external pure;
 1588 |     | 
 1589 |     |     /// Asserts that two `uint256` values are not equal, formatting them with decimals in failure message.
 1590 |     |     /// Includes error message into revert string on failure.
 1591 |     |     function assertNotEqDecimal(uint256 left, uint256 right, uint256 decimals, string calldata error) external pure;
 1592 |     | 
 1593 |     |     /// Asserts that two `int256` values are not equal, formatting them with decimals in failure message.
 1594 |     |     function assertNotEqDecimal(int256 left, int256 right, uint256 decimals) external pure;
 1595 |     | 
 1596 |     |     /// Asserts that two `int256` values are not equal, formatting them with decimals in failure message.
 1597 |     |     /// Includes error message into revert string on failure.
 1598 |     |     function assertNotEqDecimal(int256 left, int256 right, uint256 decimals, string calldata error) external pure;
 1599 |     | 
 1600 |     |     /// Asserts that two `bool` values are not equal.
 1601 |     |     function assertNotEq(bool left, bool right) external pure;
 1602 |     | 
 1603 |     |     /// Asserts that two `bool` values are not equal and includes error message into revert string on failure.
 1604 |     |     function assertNotEq(bool left, bool right, string calldata error) external pure;
 1605 |     | 
 1606 |     |     /// Asserts that two `string` values are not equal.
 1607 |     |     function assertNotEq(string calldata left, string calldata right) external pure;
 1608 |     | 
 1609 |     |     /// Asserts that two `string` values are not equal and includes error message into revert string on failure.
 1610 |     |     function assertNotEq(string calldata left, string calldata right, string calldata error) external pure;
 1611 |     | 
 1612 |     |     /// Asserts that two `bytes` values are not equal.
 1613 |     |     function assertNotEq(bytes calldata left, bytes calldata right) external pure;
 1614 |     | 
 1615 |     |     /// Asserts that two `bytes` values are not equal and includes error message into revert string on failure.
 1616 |     |     function assertNotEq(bytes calldata left, bytes calldata right, string calldata error) external pure;
 1617 |     | 
 1618 |     |     /// Asserts that two arrays of `bool` values are not equal.
 1619 |     |     function assertNotEq(bool[] calldata left, bool[] calldata right) external pure;
 1620 |     | 
 1621 |     |     /// Asserts that two arrays of `bool` values are not equal and includes error message into revert string on failure.
 1622 |     |     function assertNotEq(bool[] calldata left, bool[] calldata right, string calldata error) external pure;
 1623 |     | 
 1624 |     |     /// Asserts that two arrays of `uint256` values are not equal.
 1625 |     |     function assertNotEq(uint256[] calldata left, uint256[] calldata right) external pure;
 1626 |     | 
 1627 |     |     /// Asserts that two arrays of `uint256` values are not equal and includes error message into revert string on failure.
 1628 |     |     function assertNotEq(uint256[] calldata left, uint256[] calldata right, string calldata error) external pure;
 1629 |     | 
 1630 |     |     /// Asserts that two arrays of `int256` values are not equal.
 1631 |     |     function assertNotEq(int256[] calldata left, int256[] calldata right) external pure;
 1632 |     | 
 1633 |     |     /// Asserts that two arrays of `int256` values are not equal and includes error message into revert string on failure.
 1634 |     |     function assertNotEq(int256[] calldata left, int256[] calldata right, string calldata error) external pure;
 1635 |     | 
 1636 |     |     /// Asserts that two `uint256` values are not equal.
 1637 |     |     function assertNotEq(uint256 left, uint256 right) external pure;
 1638 |     | 
 1639 |     |     /// Asserts that two arrays of `address` values are not equal.
 1640 |     |     function assertNotEq(address[] calldata left, address[] calldata right) external pure;
 1641 |     | 
 1642 |     |     /// Asserts that two arrays of `address` values are not equal and includes error message into revert string on failure.
 1643 |     |     function assertNotEq(address[] calldata left, address[] calldata right, string calldata error) external pure;
 1644 |     | 
 1645 |     |     /// Asserts that two arrays of `bytes32` values are not equal.
 1646 |     |     function assertNotEq(bytes32[] calldata left, bytes32[] calldata right) external pure;
 1647 |     | 
 1648 |     |     /// Asserts that two arrays of `bytes32` values are not equal and includes error message into revert string on failure.
 1649 |     |     function assertNotEq(bytes32[] calldata left, bytes32[] calldata right, string calldata error) external pure;
 1650 |     | 
 1651 |     |     /// Asserts that two arrays of `string` values are not equal.
 1652 |     |     function assertNotEq(string[] calldata left, string[] calldata right) external pure;
 1653 |     | 
 1654 |     |     /// Asserts that two arrays of `string` values are not equal and includes error message into revert string on failure.
 1655 |     |     function assertNotEq(string[] calldata left, string[] calldata right, string calldata error) external pure;
 1656 |     | 
 1657 |     |     /// Asserts that two arrays of `bytes` values are not equal.
 1658 |     |     function assertNotEq(bytes[] calldata left, bytes[] calldata right) external pure;
 1659 |     | 
 1660 |     |     /// Asserts that two arrays of `bytes` values are not equal and includes error message into revert string on failure.
 1661 |     |     function assertNotEq(bytes[] calldata left, bytes[] calldata right, string calldata error) external pure;
 1662 |     | 
 1663 |     |     /// Asserts that two `uint256` values are not equal and includes error message into revert string on failure.
 1664 |     |     function assertNotEq(uint256 left, uint256 right, string calldata error) external pure;
 1665 |     | 
 1666 |     |     /// Asserts that two `int256` values are not equal.
 1667 |     |     function assertNotEq(int256 left, int256 right) external pure;
 1668 |     | 
 1669 |     |     /// Asserts that two `int256` values are not equal and includes error message into revert string on failure.
 1670 |     |     function assertNotEq(int256 left, int256 right, string calldata error) external pure;
 1671 |     | 
 1672 |     |     /// Asserts that two `address` values are not equal.
 1673 |     |     function assertNotEq(address left, address right) external pure;
 1674 |     | 
 1675 |     |     /// Asserts that two `address` values are not equal and includes error message into revert string on failure.
 1676 |     |     function assertNotEq(address left, address right, string calldata error) external pure;
 1677 |     | 
 1678 |     |     /// Asserts that two `bytes32` values are not equal.
 1679 |     |     function assertNotEq(bytes32 left, bytes32 right) external pure;
 1680 |     | 
 1681 |     |     /// Asserts that two `bytes32` values are not equal and includes error message into revert string on failure.
 1682 |     |     function assertNotEq(bytes32 left, bytes32 right, string calldata error) external pure;
 1683 |     | 
 1684 |     |     /// Asserts that the given condition is true.
 1685 |     |     function assertTrue(bool condition) external pure;
 1686 |     | 
 1687 |     |     /// Asserts that the given condition is true and includes error message into revert string on failure.
 1688 |     |     function assertTrue(bool condition, string calldata error) external pure;
 1689 |     | 
 1690 |     |     /// If the condition is false, discard this run's fuzz inputs and generate new ones.
 1691 |     |     function assume(bool condition) external pure;
 1692 |     | 
 1693 |     |     /// Discard this run's fuzz inputs and generate new ones if next call reverted.
 1694 |     |     function assumeNoRevert() external pure;
 1695 |     | 
 1696 |     |     /// Discard this run's fuzz inputs and generate new ones if next call reverts with the potential revert parameters.
 1697 |     |     function assumeNoRevert(PotentialRevert calldata potentialRevert) external pure;
 1698 |     | 
 1699 |     |     /// Discard this run's fuzz inputs and generate new ones if next call reverts with the any of the potential revert parameters.
 1700 |     |     function assumeNoRevert(PotentialRevert[] calldata potentialReverts) external pure;
 1701 |     | 
 1702 |     |     /// Writes a breakpoint to jump to in the debugger.
 1703 |     |     function breakpoint(string calldata char) external pure;
 1704 |     | 
 1705 |     |     /// Writes a conditional breakpoint to jump to in the debugger.
 1706 |     |     function breakpoint(string calldata char, bool value) external pure;
 1707 |     | 
 1708 |     |     /// Returns true if the current Foundry version is greater than or equal to the given version.
 1709 |     |     /// The given version string must be in the format `major.minor.patch`.
 1710 |     |     /// This is equivalent to `foundryVersionCmp(version) >= 0`.
 1711 |     |     function foundryVersionAtLeast(string calldata version) external view returns (bool);
 1712 |     | 
 1713 |     |     /// Compares the current Foundry version with the given version string.
 1714 |     |     /// The given version string must be in the format `major.minor.patch`.
 1715 |     |     /// Returns:
 1716 |     |     /// -1 if current Foundry version is less than the given version
 1717 |     |     /// 0 if current Foundry version equals the given version
 1718 |     |     /// 1 if current Foundry version is greater than the given version
 1719 |     |     /// This result can then be used with a comparison operator against `0`.
 1720 |     |     /// For example, to check if the current Foundry version is greater than or equal to `1.0.0`:
 1721 |     |     /// `if (foundryVersionCmp("1.0.0") >= 0) { ... }`
 1722 |     |     function foundryVersionCmp(string calldata version) external view returns (int256);
 1723 |     | 
 1724 |     |     /// Returns a Chain struct for specific alias
 1725 |     |     function getChain(string calldata chainAlias) external view returns (Chain memory chain);
 1726 |     | 
 1727 |     |     /// Returns a Chain struct for specific chainId
 1728 |     |     function getChain(uint256 chainId) external view returns (Chain memory chain);
 1729 |     | 
 1730 |     |     /// Returns the Foundry version.
 1731 |     |     /// Format: <cargo_version>-<tag>+<git_sha_short>.<unix_build_timestamp>.<profile>
 1732 |     |     /// Sample output: 0.3.0-nightly+3cb96bde9b.1737036656.debug
 1733 |     |     /// Note: Build timestamps may vary slightly across platforms due to separate CI jobs.
 1734 |     |     /// For reliable version comparisons, use UNIX format (e.g., >= 1700000000)
 1735 |     |     /// to compare timestamps while ignoring minor time differences.
 1736 |     |     function getFoundryVersion() external view returns (string memory version);
 1737 |     | 
 1738 |     |     /// Returns the RPC url for the given alias.
 1739 |     |     function rpcUrl(string calldata rpcAlias) external view returns (string memory json);
 1740 |     | 
 1741 |     |     /// Returns all rpc urls and their aliases as structs.
 1742 |     |     function rpcUrlStructs() external view returns (Rpc[] memory urls);
 1743 |     | 
 1744 |     |     /// Returns all rpc urls and their aliases `[alias, url][]`.
 1745 |     |     function rpcUrls() external view returns (string[2][] memory urls);
 1746 |     | 
 1747 |     |     /// Suspends execution of the main thread for `duration` milliseconds.
 1748 |     |     function sleep(uint256 duration) external;
 1749 |     | 
 1750 |     |     // ======== Toml ========
 1751 |     | 
 1752 |     |     /// Checks if `key` exists in a TOML table.
 1753 |     |     function keyExistsToml(string calldata toml, string calldata key) external view returns (bool);
 1754 |     | 
 1755 |     |     /// Parses a string of TOML data at `key` and coerces it to `address`.
 1756 |     |     function parseTomlAddress(string calldata toml, string calldata key) external pure returns (address);
 1757 |     | 
 1758 |     |     /// Parses a string of TOML data at `key` and coerces it to `address[]`.
 1759 |     |     function parseTomlAddressArray(string calldata toml, string calldata key)
 1760 |     |         external
 1761 |     |         pure
 1762 |     |         returns (address[] memory);
 1763 |     | 
 1764 |     |     /// Parses a string of TOML data at `key` and coerces it to `bool`.
 1765 |     |     function parseTomlBool(string calldata toml, string calldata key) external pure returns (bool);
 1766 |     | 
 1767 |     |     /// Parses a string of TOML data at `key` and coerces it to `bool[]`.
 1768 |     |     function parseTomlBoolArray(string calldata toml, string calldata key) external pure returns (bool[] memory);
 1769 |     | 
 1770 |     |     /// Parses a string of TOML data at `key` and coerces it to `bytes`.
 1771 |     |     function parseTomlBytes(string calldata toml, string calldata key) external pure returns (bytes memory);
 1772 |     | 
 1773 |     |     /// Parses a string of TOML data at `key` and coerces it to `bytes32`.
 1774 |     |     function parseTomlBytes32(string calldata toml, string calldata key) external pure returns (bytes32);
 1775 |     | 
 1776 |     |     /// Parses a string of TOML data at `key` and coerces it to `bytes32[]`.
 1777 |     |     function parseTomlBytes32Array(string calldata toml, string calldata key)
 1778 |     |         external
 1779 |     |         pure
 1780 |     |         returns (bytes32[] memory);
 1781 |     | 
 1782 |     |     /// Parses a string of TOML data at `key` and coerces it to `bytes[]`.
 1783 |     |     function parseTomlBytesArray(string calldata toml, string calldata key) external pure returns (bytes[] memory);
 1784 |     | 
 1785 |     |     /// Parses a string of TOML data at `key` and coerces it to `int256`.
 1786 |     |     function parseTomlInt(string calldata toml, string calldata key) external pure returns (int256);
 1787 |     | 
 1788 |     |     /// Parses a string of TOML data at `key` and coerces it to `int256[]`.
 1789 |     |     function parseTomlIntArray(string calldata toml, string calldata key) external pure returns (int256[] memory);
 1790 |     | 
 1791 |     |     /// Returns an array of all the keys in a TOML table.
 1792 |     |     function parseTomlKeys(string calldata toml, string calldata key) external pure returns (string[] memory keys);
 1793 |     | 
 1794 |     |     /// Parses a string of TOML data at `key` and coerces it to `string`.
 1795 |     |     function parseTomlString(string calldata toml, string calldata key) external pure returns (string memory);
 1796 |     | 
 1797 |     |     /// Parses a string of TOML data at `key` and coerces it to `string[]`.
 1798 |     |     function parseTomlStringArray(string calldata toml, string calldata key) external pure returns (string[] memory);
 1799 |     | 
 1800 |     |     /// Parses a string of TOML data at `key` and coerces it to type array corresponding to `typeDescription`.
 1801 |     |     function parseTomlTypeArray(string calldata toml, string calldata key, string calldata typeDescription)
 1802 |     |         external
 1803 |     |         pure
 1804 |     |         returns (bytes memory);
 1805 |     | 
 1806 |     |     /// Parses a string of TOML data and coerces it to type corresponding to `typeDescription`.
 1807 |     |     function parseTomlType(string calldata toml, string calldata typeDescription)
 1808 |     |         external
 1809 |     |         pure
 1810 |     |         returns (bytes memory);
 1811 |     | 
 1812 |     |     /// Parses a string of TOML data at `key` and coerces it to type corresponding to `typeDescription`.
 1813 |     |     function parseTomlType(string calldata toml, string calldata key, string calldata typeDescription)
 1814 |     |         external
 1815 |     |         pure
 1816 |     |         returns (bytes memory);
 1817 |     | 
 1818 |     |     /// Parses a string of TOML data at `key` and coerces it to `uint256`.
 1819 |     |     function parseTomlUint(string calldata toml, string calldata key) external pure returns (uint256);
 1820 |     | 
 1821 |     |     /// Parses a string of TOML data at `key` and coerces it to `uint256[]`.
 1822 |     |     function parseTomlUintArray(string calldata toml, string calldata key) external pure returns (uint256[] memory);
 1823 |     | 
 1824 |     |     /// ABI-encodes a TOML table.
 1825 |     |     function parseToml(string calldata toml) external pure returns (bytes memory abiEncodedData);
 1826 |     | 
 1827 |     |     /// ABI-encodes a TOML table at `key`.
 1828 |     |     function parseToml(string calldata toml, string calldata key) external pure returns (bytes memory abiEncodedData);
 1829 |     | 
 1830 |     |     /// Takes serialized JSON, converts to TOML and write a serialized TOML to a file.
 1831 |     |     function writeToml(string calldata json, string calldata path) external;
 1832 |     | 
 1833 |     |     /// Takes serialized JSON, converts to TOML and write a serialized TOML table to an **existing** TOML file, replacing a value with key = <value_key.>
 1834 |     |     /// This is useful to replace a specific value of a TOML file, without having to parse the entire thing.
 1835 |     |     function writeToml(string calldata json, string calldata path, string calldata valueKey) external;
 1836 |     | 
 1837 |     |     // ======== Utilities ========
 1838 |     | 
 1839 |     |     /// Compute the address of a contract created with CREATE2 using the given CREATE2 deployer.
 1840 |     |     function computeCreate2Address(bytes32 salt, bytes32 initCodeHash, address deployer)
 1841 |     |         external
 1842 |     |         pure
 1843 |     |         returns (address);
 1844 |     | 
 1845 |     |     /// Compute the address of a contract created with CREATE2 using the default CREATE2 deployer.
 1846 |     |     function computeCreate2Address(bytes32 salt, bytes32 initCodeHash) external pure returns (address);
 1847 |     | 
 1848 |     |     /// Compute the address a contract will be deployed at for a given deployer address and nonce.
 1849 |     |     function computeCreateAddress(address deployer, uint256 nonce) external pure returns (address);
 1850 |     | 
 1851 |     |     /// Utility cheatcode to copy storage of `from` contract to another `to` contract.
 1852 |     |     function copyStorage(address from, address to) external;
 1853 |     | 
 1854 |     |     /// Returns ENS namehash for provided string.
 1855 |     |     function ensNamehash(string calldata name) external pure returns (bytes32);
 1856 |     | 
 1857 |     |     /// Gets the label for the specified address.
 1858 |     |     function getLabel(address account) external view returns (string memory currentLabel);
 1859 |     | 
 1860 |     |     /// Labels an address in call traces.
 1861 |     |     function label(address account, string calldata newLabel) external;
 1862 |     | 
 1863 |     |     /// Pauses collection of call traces. Useful in cases when you want to skip tracing of
 1864 |     |     /// complex calls which are not useful for debugging.
 1865 |     |     function pauseTracing() external view;
 1866 |     | 
 1867 |     |     /// Returns a random `address`.
 1868 |     |     function randomAddress() external returns (address);
 1869 |     | 
 1870 |     |     /// Returns a random `bool`.
 1871 |     |     function randomBool() external view returns (bool);
 1872 |     | 
 1873 |     |     /// Returns a random byte array value of the given length.
 1874 |     |     function randomBytes(uint256 len) external view returns (bytes memory);
 1875 |     | 
 1876 |     |     /// Returns a random fixed-size byte array of length 4.
 1877 |     |     function randomBytes4() external view returns (bytes4);
 1878 |     | 
 1879 |     |     /// Returns a random fixed-size byte array of length 8.
 1880 |     |     function randomBytes8() external view returns (bytes8);
 1881 |     | 
 1882 |     |     /// Returns a random `int256` value.
 1883 |     |     function randomInt() external view returns (int256);
 1884 |     | 
 1885 |     |     /// Returns a random `int256` value of given bits.
 1886 |     |     function randomInt(uint256 bits) external view returns (int256);
 1887 |     | 
 1888 |     |     /// Returns a random uint256 value.
 1889 |     |     function randomUint() external returns (uint256);
 1890 |     | 
 1891 |     |     /// Returns random uint256 value between the provided range (=min..=max).
 1892 |     |     function randomUint(uint256 min, uint256 max) external returns (uint256);
 1893 |     | 
 1894 |     |     /// Returns a random `uint256` value of given bits.
 1895 |     |     function randomUint(uint256 bits) external view returns (uint256);
 1896 |     | 
 1897 |     |     /// Unpauses collection of call traces.
 1898 |     |     function resumeTracing() external view;
 1899 |     | 
 1900 |     |     /// Utility cheatcode to set arbitrary storage for given target address.
 1901 |     |     function setArbitraryStorage(address target) external;
 1902 |     | 
 1903 |     |     /// Utility cheatcode to set arbitrary storage for given target address and overwrite
 1904 |     |     /// any storage slots that have been previously set.
 1905 |     |     function setArbitraryStorage(address target, bool overwrite) external;
 1906 |     | 
 1907 |     |     /// Randomly shuffles an array.
 1908 |     |     function shuffle(uint256[] calldata array) external returns (uint256[] memory);
 1909 |     | 
 1910 |     |     /// Sorts an array in ascending order.
 1911 |     |     function sort(uint256[] calldata array) external returns (uint256[] memory);
 1912 |     | 
 1913 |     |     /// Encodes a `bytes` value to a base64url string.
 1914 |     |     function toBase64URL(bytes calldata data) external pure returns (string memory);
 1915 |     | 
 1916 |     |     /// Encodes a `string` value to a base64url string.
 1917 |     |     function toBase64URL(string calldata data) external pure returns (string memory);
 1918 |     | 
 1919 |     |     /// Encodes a `bytes` value to a base64 string.
 1920 |     |     function toBase64(bytes calldata data) external pure returns (string memory);
 1921 |     | 
 1922 |     |     /// Encodes a `string` value to a base64 string.
 1923 |     |     function toBase64(string calldata data) external pure returns (string memory);
 1924 |     | 
 1925 |     |     // Generates the hash of the canonical EIP-712 type representation.
 1926 |     |     //
 1927 |     |     // Supports 2 different inputs:
 1928 |     |     //  1. Name of the type (i.e. "Transaction"):
 1929 |     |     //     * requires previous binding generation with `forge bind-json`.
 1930 |     |     //     * bindings will be retrieved from the path configured in `foundry.toml`.
 1931 |     |     //
 1932 |     |     //  2. String representation of the type (i.e. "Foo(Bar bar) Bar(uint256 baz)").
 1933 |     |     //     * Note: the cheatcode will output the canonical type even if the input is malformated
 1934 |     |     //             with the wrong order of elements or with extra whitespaces.
 1935 |     |     function eip712HashType(string calldata typeNameOrDefinition) external pure returns (bytes32 typeHash);
 1936 |     | 
 1937 |     |     // Generates the hash of the canonical EIP-712 type representation.
 1938 |     |     // Requires previous binding generation with `forge bind-json`.
 1939 |     |     //
 1940 |     |     // Params:
 1941 |     |     //  * `bindingsPath`: path where the output of `forge bind-json` is stored.
 1942 |     |     //  * `typeName`: Name of the type (i.e. "Transaction").
 1943 |     |     function eip712HashType(string calldata bindingsPath, string calldata typeName)
 1944 |     |         external
 1945 |     |         pure
 1946 |     |         returns (bytes32 typeHash);
 1947 |     | 
 1948 |     |     // Generates the struct hash of the canonical EIP-712 type representation and its abi-encoded data.
 1949 |     |     //
 1950 |     |     // Supports 2 different inputs:
 1951 |     |     //  1. Name of the type (i.e. "PermitSingle"):
 1952 |     |     //     * requires previous binding generation with `forge bind-json`.
 1953 |     |     //     * bindings will be retrieved from the path configured in `foundry.toml`.
 1954 |     |     //
 1955 |     |     //  2. String representation of the type (i.e. "Foo(Bar bar) Bar(uint256 baz)").
 1956 |     |     //     * Note: the cheatcode will use the canonical type even if the input is malformated
 1957 |     |     //             with the wrong order of elements or with extra whitespaces.
 1958 |     |     function eip712HashStruct(string calldata typeNameOrDefinition, bytes calldata abiEncodedData)
 1959 |     |         external
 1960 |     |         pure
 1961 |     |         returns (bytes32 typeHash);
 1962 |     | 
 1963 |     |     // Generates the struct hash of the canonical EIP-712 type representation and its abi-encoded data.
 1964 |     |     // Requires previous binding generation with `forge bind-json`.
 1965 |     |     //
 1966 |     |     // Params:
 1967 |     |     //  * `bindingsPath`: path where the output of `forge bind-json` is stored.
 1968 |     |     //  * `typeName`: Name of the type (i.e. "PermitSingle").
 1969 |     |     //  * `abiEncodedData`: ABI-encoded data for the struct that is being hashed.
 1970 |     |     function eip712HashStruct(string calldata bindingsPath, string calldata typeName, bytes calldata abiEncodedData)
 1971 |     |         external
 1972 |     |         pure
 1973 |     |         returns (bytes32 typeHash);
 1974 |     | 
 1975 |     |     // Generates a ready-to-sign digest of human-readable typed data following the EIP-712 standard.
 1976 |     |     function eip712HashTypedData(string calldata jsonData) external pure returns (bytes32 digest);
 1977 |     | }
 1978 |     | 
 1979 |     | /// The `Vm` interface does allow manipulation of the EVM state. These are all intended to be used
 1980 |     | /// in tests, but it is not recommended to use these cheats in scripts.
 1981 |     | interface Vm is VmSafe {
 1982 |     |     // ======== EVM ========
 1983 |     | 
 1984 |     |     /// Utility cheatcode to set an EIP-2930 access list for all subsequent transactions.
 1985 |     |     function accessList(AccessListItem[] calldata access) external;
 1986 |     | 
 1987 |     |     /// Returns the identifier of the currently active fork. Reverts if no fork is currently active.
 1988 |     |     function activeFork() external view returns (uint256 forkId);
 1989 |     | 
 1990 |     |     /// In forking mode, explicitly grant the given address cheatcode access.
 1991 |     |     function allowCheatcodes(address account) external;
 1992 |     | 
 1993 |     |     /// Sets `block.blobbasefee`
 1994 |     |     function blobBaseFee(uint256 newBlobBaseFee) external;
 1995 |     | 
 1996 |     |     /// Sets the blobhashes in the transaction.
 1997 |     |     /// Not available on EVM versions before Cancun.
 1998 |     |     /// If used on unsupported EVM versions it will revert.
 1999 |     |     function blobhashes(bytes32[] calldata hashes) external;
 2000 |     | 
 2001 |     |     /// Sets `block.chainid`.
 2002 |     |     function chainId(uint256 newChainId) external;
 2003 |     | 
 2004 |     |     /// Clears all mocked calls.
 2005 |     |     function clearMockedCalls() external;
 2006 |     | 
 2007 |     |     /// Clones a source account code, state, balance and nonce to a target account and updates in-memory EVM state.
 2008 |     |     function cloneAccount(address source, address target) external;
 2009 |     | 
 2010 |     |     /// Sets `block.coinbase`.
 2011 |     |     function coinbase(address newCoinbase) external;
 2012 |     | 
 2013 |     |     /// Marks the slots of an account and the account address as cold.
 2014 |     |     function cool(address target) external;
 2015 |     | 
 2016 |     |     /// Utility cheatcode to mark specific storage slot as cold, simulating no prior read.
 2017 |     |     function coolSlot(address target, bytes32 slot) external;
 2018 |     | 
 2019 |     |     /// Creates a new fork with the given endpoint and the _latest_ block and returns the identifier of the fork.
 2020 |     |     function createFork(string calldata urlOrAlias) external returns (uint256 forkId);
 2021 |     | 
 2022 |     |     /// Creates a new fork with the given endpoint and block and returns the identifier of the fork.
 2023 |     |     function createFork(string calldata urlOrAlias, uint256 blockNumber) external returns (uint256 forkId);
 2024 |     | 
 2025 |     |     /// Creates a new fork with the given endpoint and at the block the given transaction was mined in,
 2026 |     |     /// replays all transaction mined in the block before the transaction, and returns the identifier of the fork.
 2027 |     |     function createFork(string calldata urlOrAlias, bytes32 txHash) external returns (uint256 forkId);
 2028 |     | 
 2029 |     |     /// Creates and also selects a new fork with the given endpoint and the latest block and returns the identifier of the fork.
 2030 |     |     function createSelectFork(string calldata urlOrAlias) external returns (uint256 forkId);
 2031 |     | 
 2032 |     |     /// Creates and also selects a new fork with the given endpoint and block and returns the identifier of the fork.
 2033 |     |     function createSelectFork(string calldata urlOrAlias, uint256 blockNumber) external returns (uint256 forkId);
 2034 |     | 
 2035 |     |     /// Creates and also selects new fork with the given endpoint and at the block the given transaction was mined in,
 2036 |     |     /// replays all transaction mined in the block before the transaction, returns the identifier of the fork.
 2037 |     |     function createSelectFork(string calldata urlOrAlias, bytes32 txHash) external returns (uint256 forkId);
 2038 |     | 
 2039 |     |     /// Sets an address' balance.
 2040 |     |     function deal(address account, uint256 newBalance) external;
 2041 |     | 
 2042 |     |     /// Removes the snapshot with the given ID created by `snapshot`.
 2043 |     |     /// Takes the snapshot ID to delete.
 2044 |     |     /// Returns `true` if the snapshot was successfully deleted.
 2045 |     |     /// Returns `false` if the snapshot does not exist.
 2046 |     |     function deleteStateSnapshot(uint256 snapshotId) external returns (bool success);
 2047 |     | 
 2048 |     |     /// Removes _all_ snapshots previously created by `snapshot`.
 2049 |     |     function deleteStateSnapshots() external;
 2050 |     | 
 2051 |     |     /// Sets `block.difficulty`.
 2052 |     |     /// Not available on EVM versions from Paris onwards. Use `prevrandao` instead.
 2053 |     |     /// Reverts if used on unsupported EVM versions.
 2054 |     |     function difficulty(uint256 newDifficulty) external;
 2055 |     | 
 2056 |     |     /// Dump a genesis JSON file's `allocs` to disk.
 2057 |     |     function dumpState(string calldata pathToStateJson) external;
 2058 |     | 
 2059 |     |     /// Sets an address' code.
 2060 |     |     function etch(address target, bytes calldata newRuntimeBytecode) external;
 2061 |     | 
 2062 |     |     /// Sets `block.basefee`.
 2063 |     |     function fee(uint256 newBasefee) external;
 2064 |     | 
 2065 |     |     /// Gets the blockhashes from the current transaction.
 2066 |     |     /// Not available on EVM versions before Cancun.
 2067 |     |     /// If used on unsupported EVM versions it will revert.
 2068 |     |     function getBlobhashes() external view returns (bytes32[] memory hashes);
 2069 |     | 
 2070 |     |     /// Returns true if the account is marked as persistent.
 2071 |     |     function isPersistent(address account) external view returns (bool persistent);
 2072 |     | 
 2073 |     |     /// Load a genesis JSON file's `allocs` into the in-memory EVM state.
 2074 |     |     function loadAllocs(string calldata pathToAllocsJson) external;
 2075 |     | 
 2076 |     |     /// Marks that the account(s) should use persistent storage across fork swaps in a multifork setup
 2077 |     |     /// Meaning, changes made to the state of this account will be kept when switching forks.
 2078 |     |     function makePersistent(address account) external;
 2079 |     | 
 2080 |     |     /// See `makePersistent(address)`.
 2081 |     |     function makePersistent(address account0, address account1) external;
 2082 |     | 
 2083 |     |     /// See `makePersistent(address)`.
 2084 |     |     function makePersistent(address account0, address account1, address account2) external;
 2085 |     | 
 2086 |     |     /// See `makePersistent(address)`.
 2087 |     |     function makePersistent(address[] calldata accounts) external;
 2088 |     | 
 2089 |     |     /// Reverts a call to an address with specified revert data.
 2090 |     |     function mockCallRevert(address callee, bytes calldata data, bytes calldata revertData) external;
 2091 |     | 
 2092 |     |     /// Reverts a call to an address with a specific `msg.value`, with specified revert data.
 2093 |     |     function mockCallRevert(address callee, uint256 msgValue, bytes calldata data, bytes calldata revertData)
 2094 |     |         external;
 2095 |     | 
 2096 |     |     /// Reverts a call to an address with specified revert data.
 2097 |     |     /// Overload to pass the function selector directly `token.approve.selector` instead of `abi.encodeWithSelector(token.approve.selector)`.
 2098 |     |     function mockCallRevert(address callee, bytes4 data, bytes calldata revertData) external;
 2099 |     | 
 2100 |     |     /// Reverts a call to an address with a specific `msg.value`, with specified revert data.
 2101 |     |     /// Overload to pass the function selector directly `token.approve.selector` instead of `abi.encodeWithSelector(token.approve.selector)`.
 2102 |     |     function mockCallRevert(address callee, uint256 msgValue, bytes4 data, bytes calldata revertData) external;
 2103 |     | 
 2104 |     |     /// Mocks a call to an address, returning specified data.
 2105 |     |     /// Calldata can either be strict or a partial match, e.g. if you only
 2106 |     |     /// pass a Solidity selector to the expected calldata, then the entire Solidity
 2107 |     |     /// function will be mocked.
 2108 |     |     function mockCall(address callee, bytes calldata data, bytes calldata returnData) external;
 2109 |     | 
 2110 |     |     /// Mocks a call to an address with a specific `msg.value`, returning specified data.
 2111 |     |     /// Calldata match takes precedence over `msg.value` in case of ambiguity.
 2112 |     |     function mockCall(address callee, uint256 msgValue, bytes calldata data, bytes calldata returnData) external;
 2113 |     | 
 2114 |     |     /// Mocks a call to an address, returning specified data.
 2115 |     |     /// Calldata can either be strict or a partial match, e.g. if you only
 2116 |     |     /// pass a Solidity selector to the expected calldata, then the entire Solidity
 2117 |     |     /// function will be mocked.
 2118 |     |     /// Overload to pass the function selector directly `token.approve.selector` instead of `abi.encodeWithSelector(token.approve.selector)`.
 2119 |     |     function mockCall(address callee, bytes4 data, bytes calldata returnData) external;
 2120 |     | 
 2121 |     |     /// Mocks a call to an address with a specific `msg.value`, returning specified data.
 2122 |     |     /// Calldata match takes precedence over `msg.value` in case of ambiguity.
 2123 |     |     /// Overload to pass the function selector directly `token.approve.selector` instead of `abi.encodeWithSelector(token.approve.selector)`.
 2124 |     |     function mockCall(address callee, uint256 msgValue, bytes4 data, bytes calldata returnData) external;
 2125 |     | 
 2126 |     |     /// Mocks multiple calls to an address, returning specified data for each call.
 2127 |     |     function mockCalls(address callee, bytes calldata data, bytes[] calldata returnData) external;
 2128 |     | 
 2129 |     |     /// Mocks multiple calls to an address with a specific `msg.value`, returning specified data for each call.
 2130 |     |     function mockCalls(address callee, uint256 msgValue, bytes calldata data, bytes[] calldata returnData) external;
 2131 |     | 
 2132 |     |     /// Whenever a call is made to `callee` with calldata `data`, this cheatcode instead calls
 2133 |     |     /// `target` with the same calldata. This functionality is similar to a delegate call made to
 2134 |     |     /// `target` contract from `callee`.
 2135 |     |     /// Can be used to substitute a call to a function with another implementation that captures
 2136 |     |     /// the primary logic of the original function but is easier to reason about.
 2137 |     |     /// If calldata is not a strict match then partial match by selector is attempted.
 2138 |     |     function mockFunction(address callee, address target, bytes calldata data) external;
 2139 |     | 
 2140 |     |     /// Utility cheatcode to remove any EIP-2930 access list set by `accessList` cheatcode.
 2141 |     |     function noAccessList() external;
 2142 |     | 
 2143 |     |     /// Sets the *next* call's `msg.sender` to be the input address.
 2144 |     |     function prank(address msgSender) external;
 2145 |     | 
 2146 |     |     /// Sets the *next* call's `msg.sender` to be the input address, and the `tx.origin` to be the second input.
 2147 |     |     function prank(address msgSender, address txOrigin) external;
 2148 |     | 
 2149 |     |     /// Sets the *next* delegate call's `msg.sender` to be the input address.
 2150 |     |     function prank(address msgSender, bool delegateCall) external;
 2151 |     | 
 2152 |     |     /// Sets the *next* delegate call's `msg.sender` to be the input address, and the `tx.origin` to be the second input.
 2153 |     |     function prank(address msgSender, address txOrigin, bool delegateCall) external;
 2154 |     | 
 2155 |     |     /// Sets `block.prevrandao`.
 2156 |     |     /// Not available on EVM versions before Paris. Use `difficulty` instead.
 2157 |     |     /// If used on unsupported EVM versions it will revert.
 2158 |     |     function prevrandao(bytes32 newPrevrandao) external;
 2159 |     | 
 2160 |     |     /// Sets `block.prevrandao`.
 2161 |     |     /// Not available on EVM versions before Paris. Use `difficulty` instead.
 2162 |     |     /// If used on unsupported EVM versions it will revert.
 2163 |     |     function prevrandao(uint256 newPrevrandao) external;
 2164 |     | 
 2165 |     |     /// Reads the current `msg.sender` and `tx.origin` from state and reports if there is any active caller modification.
 2166 |     |     function readCallers() external returns (CallerMode callerMode, address msgSender, address txOrigin);
 2167 |     | 
 2168 |     |     /// Resets the nonce of an account to 0 for EOAs and 1 for contract accounts.
 2169 |     |     function resetNonce(address account) external;
 2170 |     | 
 2171 |     |     /// Revert the state of the EVM to a previous snapshot
 2172 |     |     /// Takes the snapshot ID to revert to.
 2173 |     |     /// Returns `true` if the snapshot was successfully reverted.
 2174 |     |     /// Returns `false` if the snapshot does not exist.
 2175 |     |     /// **Note:** This does not automatically delete the snapshot. To delete the snapshot use `deleteStateSnapshot`.
 2176 |     |     function revertToState(uint256 snapshotId) external returns (bool success);
 2177 |     | 
 2178 |     |     /// Revert the state of the EVM to a previous snapshot and automatically deletes the snapshots
 2179 |     |     /// Takes the snapshot ID to revert to.
 2180 |     |     /// Returns `true` if the snapshot was successfully reverted and deleted.
 2181 |     |     /// Returns `false` if the snapshot does not exist.
 2182 |     |     function revertToStateAndDelete(uint256 snapshotId) external returns (bool success);
 2183 |     | 
 2184 |     |     /// Revokes persistent status from the address, previously added via `makePersistent`.
 2185 |     |     function revokePersistent(address account) external;
 2186 |     | 
 2187 |     |     /// See `revokePersistent(address)`.
 2188 |     |     function revokePersistent(address[] calldata accounts) external;
 2189 |     | 
 2190 |     |     /// Sets `block.height`.
 2191 |     |     function roll(uint256 newHeight) external;
 2192 |     | 
 2193 |     |     /// Updates the currently active fork to given block number
 2194 |     |     /// This is similar to `roll` but for the currently active fork.
 2195 |     |     function rollFork(uint256 blockNumber) external;
 2196 |     | 
 2197 |     |     /// Updates the currently active fork to given transaction. This will `rollFork` with the number
 2198 |     |     /// of the block the transaction was mined in and replays all transaction mined before it in the block.
 2199 |     |     function rollFork(bytes32 txHash) external;
 2200 |     | 
 2201 |     |     /// Updates the given fork to given block number.
 2202 |     |     function rollFork(uint256 forkId, uint256 blockNumber) external;
 2203 |     | 
 2204 |     |     /// Updates the given fork to block number of the given transaction and replays all transaction mined before it in the block.
 2205 |     |     function rollFork(uint256 forkId, bytes32 txHash) external;
 2206 |     | 
 2207 |     |     /// Takes a fork identifier created by `createFork` and sets the corresponding forked state as active.
 2208 |     |     function selectFork(uint256 forkId) external;
 2209 |     | 
 2210 |     |     /// Set blockhash for the current block.
 2211 |     |     /// It only sets the blockhash for blocks where `block.number - 256 <= number < block.number`.
 2212 |     |     function setBlockhash(uint256 blockNumber, bytes32 blockHash) external;
 2213 |     | 
 2214 |     |     /// Sets the nonce of an account. Must be higher than the current nonce of the account.
 2215 |     |     function setNonce(address account, uint64 newNonce) external;
 2216 |     | 
 2217 |     |     /// Sets the nonce of an account to an arbitrary value.
 2218 |     |     function setNonceUnsafe(address account, uint64 newNonce) external;
 2219 |     | 
 2220 |     |     /// Snapshot capture the gas usage of the last call by name from the callee perspective.
 2221 |     |     function snapshotGasLastCall(string calldata name) external returns (uint256 gasUsed);
 2222 |     | 
 2223 |     |     /// Snapshot capture the gas usage of the last call by name in a group from the callee perspective.
 2224 |     |     function snapshotGasLastCall(string calldata group, string calldata name) external returns (uint256 gasUsed);
 2225 |     | 
 2226 |     |     /// Snapshot the current state of the evm.
 2227 |     |     /// Returns the ID of the snapshot that was created.
 2228 |     |     /// To revert a snapshot use `revertToState`.
 2229 |     |     function snapshotState() external returns (uint256 snapshotId);
 2230 |     | 
 2231 |     |     /// Snapshot capture an arbitrary numerical value by name.
 2232 |     |     /// The group name is derived from the contract name.
 2233 |     |     function snapshotValue(string calldata name, uint256 value) external;
 2234 |     | 
 2235 |     |     /// Snapshot capture an arbitrary numerical value by name in a group.
 2236 |     |     function snapshotValue(string calldata group, string calldata name, uint256 value) external;
 2237 |     | 
 2238 |     |     /// Sets all subsequent calls' `msg.sender` to be the input address until `stopPrank` is called.
 2239 |     |     function startPrank(address msgSender) external;
 2240 |     | 
 2241 |     |     /// Sets all subsequent calls' `msg.sender` to be the input address until `stopPrank` is called, and the `tx.origin` to be the second input.
 2242 |     |     function startPrank(address msgSender, address txOrigin) external;
 2243 |     | 
 2244 |     |     /// Sets all subsequent delegate calls' `msg.sender` to be the input address until `stopPrank` is called.
 2245 |     |     function startPrank(address msgSender, bool delegateCall) external;
 2246 |     | 
 2247 |     |     /// Sets all subsequent delegate calls' `msg.sender` to be the input address until `stopPrank` is called, and the `tx.origin` to be the second input.
 2248 |     |     function startPrank(address msgSender, address txOrigin, bool delegateCall) external;
 2249 |     | 
 2250 |     |     /// Start a snapshot capture of the current gas usage by name.
 2251 |     |     /// The group name is derived from the contract name.
 2252 |     |     function startSnapshotGas(string calldata name) external;
 2253 |     | 
 2254 |     |     /// Start a snapshot capture of the current gas usage by name in a group.
 2255 |     |     function startSnapshotGas(string calldata group, string calldata name) external;
 2256 |     | 
 2257 |     |     /// Resets subsequent calls' `msg.sender` to be `address(this)`.
 2258 |     |     function stopPrank() external;
 2259 |     | 
 2260 |     |     /// Stop the snapshot capture of the current gas by latest snapshot name, capturing the gas used since the start.
 2261 |     |     function stopSnapshotGas() external returns (uint256 gasUsed);
 2262 |     | 
 2263 |     |     /// Stop the snapshot capture of the current gas usage by name, capturing the gas used since the start.
 2264 |     |     /// The group name is derived from the contract name.
 2265 |     |     function stopSnapshotGas(string calldata name) external returns (uint256 gasUsed);
 2266 |     | 
 2267 |     |     /// Stop the snapshot capture of the current gas usage by name in a group, capturing the gas used since the start.
 2268 |     |     function stopSnapshotGas(string calldata group, string calldata name) external returns (uint256 gasUsed);
 2269 |     | 
 2270 |     |     /// Stores a value to an address' storage slot.
 2271 |     |     function store(address target, bytes32 slot, bytes32 value) external;
 2272 |     | 
 2273 |     |     /// Fetches the given transaction from the active fork and executes it on the current state.
 2274 |     |     function transact(bytes32 txHash) external;
 2275 |     | 
 2276 |     |     /// Fetches the given transaction from the given fork and executes it on the current state.
 2277 |     |     function transact(uint256 forkId, bytes32 txHash) external;
 2278 |     | 
 2279 |     |     /// Sets `tx.gasprice`.
 2280 |     |     function txGasPrice(uint256 newGasPrice) external;
 2281 |     | 
 2282 |     |     /// Utility cheatcode to mark specific storage slot as warm, simulating a prior read.
 2283 |     |     function warmSlot(address target, bytes32 slot) external;
 2284 |     | 
 2285 |     |     /// Sets `block.timestamp`.
 2286 |     |     function warp(uint256 newTimestamp) external;
 2287 |     | 
 2288 |     |     /// `deleteSnapshot` is being deprecated in favor of `deleteStateSnapshot`. It will be removed in future versions.
 2289 |     |     function deleteSnapshot(uint256 snapshotId) external returns (bool success);
 2290 |     | 
 2291 |     |     /// `deleteSnapshots` is being deprecated in favor of `deleteStateSnapshots`. It will be removed in future versions.
 2292 |     |     function deleteSnapshots() external;
 2293 |     | 
 2294 |     |     /// `revertToAndDelete` is being deprecated in favor of `revertToStateAndDelete`. It will be removed in future versions.
 2295 |     |     function revertToAndDelete(uint256 snapshotId) external returns (bool success);
 2296 |     | 
 2297 |     |     /// `revertTo` is being deprecated in favor of `revertToState`. It will be removed in future versions.
 2298 |     |     function revertTo(uint256 snapshotId) external returns (bool success);
 2299 |     | 
 2300 |     |     /// `snapshot` is being deprecated in favor of `snapshotState`. It will be removed in future versions.
 2301 |     |     function snapshot() external returns (uint256 snapshotId);
 2302 |     | 
 2303 |     |     // ======== Testing ========
 2304 |     | 
 2305 |     |     /// Expect a call to an address with the specified `msg.value` and calldata, and a *minimum* amount of gas.
 2306 |     |     function expectCallMinGas(address callee, uint256 msgValue, uint64 minGas, bytes calldata data) external;
 2307 |     | 
 2308 |     |     /// Expect given number of calls to an address with the specified `msg.value` and calldata, and a *minimum* amount of gas.
 2309 |     |     function expectCallMinGas(address callee, uint256 msgValue, uint64 minGas, bytes calldata data, uint64 count)
 2310 |     |         external;
 2311 |     | 
 2312 |     |     /// Expects a call to an address with the specified calldata.
 2313 |     |     /// Calldata can either be a strict or a partial match.
 2314 |     |     function expectCall(address callee, bytes calldata data) external;
 2315 |     | 
 2316 |     |     /// Expects given number of calls to an address with the specified calldata.
 2317 |     |     function expectCall(address callee, bytes calldata data, uint64 count) external;
 2318 |     | 
 2319 |     |     /// Expects a call to an address with the specified `msg.value` and calldata.
 2320 |     |     function expectCall(address callee, uint256 msgValue, bytes calldata data) external;
 2321 |     | 
 2322 |     |     /// Expects given number of calls to an address with the specified `msg.value` and calldata.
 2323 |     |     function expectCall(address callee, uint256 msgValue, bytes calldata data, uint64 count) external;
 2324 |     | 
 2325 |     |     /// Expect a call to an address with the specified `msg.value`, gas, and calldata.
 2326 |     |     function expectCall(address callee, uint256 msgValue, uint64 gas, bytes calldata data) external;
 2327 |     | 
 2328 |     |     /// Expects given number of calls to an address with the specified `msg.value`, gas, and calldata.
 2329 |     |     function expectCall(address callee, uint256 msgValue, uint64 gas, bytes calldata data, uint64 count) external;
 2330 |     | 
 2331 |     |     /// Expects the deployment of the specified bytecode by the specified address using the CREATE opcode
 2332 |     |     function expectCreate(bytes calldata bytecode, address deployer) external;
 2333 |     | 
 2334 |     |     /// Expects the deployment of the specified bytecode by the specified address using the CREATE2 opcode
 2335 |     |     function expectCreate2(bytes calldata bytecode, address deployer) external;
 2336 |     | 
 2337 |     |     /// Prepare an expected anonymous log with (bool checkTopic1, bool checkTopic2, bool checkTopic3, bool checkData.).
 2338 |     |     /// Call this function, then emit an anonymous event, then call a function. Internally after the call, we check if
 2339 |     |     /// logs were emitted in the expected order with the expected topics and data (as specified by the booleans).
 2340 |     |     function expectEmitAnonymous(bool checkTopic0, bool checkTopic1, bool checkTopic2, bool checkTopic3, bool checkData)
 2341 |     |         external;
 2342 |     | 
 2343 |     |     /// Same as the previous method, but also checks supplied address against emitting contract.
 2344 |     |     function expectEmitAnonymous(
 2345 |     |         bool checkTopic0,
 2346 |     |         bool checkTopic1,
 2347 |     |         bool checkTopic2,
 2348 |     |         bool checkTopic3,
 2349 |     |         bool checkData,
 2350 |     |         address emitter
 2351 |     |     ) external;
 2352 |     | 
 2353 |     |     /// Prepare an expected anonymous log with all topic and data checks enabled.
 2354 |     |     /// Call this function, then emit an anonymous event, then call a function. Internally after the call, we check if
 2355 |     |     /// logs were emitted in the expected order with the expected topics and data.
 2356 |     |     function expectEmitAnonymous() external;
 2357 |     | 
 2358 |     |     /// Same as the previous method, but also checks supplied address against emitting contract.
 2359 |     |     function expectEmitAnonymous(address emitter) external;
 2360 |     | 
 2361 |     |     /// Prepare an expected log with (bool checkTopic1, bool checkTopic2, bool checkTopic3, bool checkData.).
 2362 |     |     /// Call this function, then emit an event, then call a function. Internally after the call, we check if
 2363 |     |     /// logs were emitted in the expected order with the expected topics and data (as specified by the booleans).
 2364 |     |     function expectEmit(bool checkTopic1, bool checkTopic2, bool checkTopic3, bool checkData) external;
 2365 |     | 
 2366 |     |     /// Same as the previous method, but also checks supplied address against emitting contract.
 2367 |     |     function expectEmit(bool checkTopic1, bool checkTopic2, bool checkTopic3, bool checkData, address emitter)
 2368 |     |         external;
 2369 |     | 
 2370 |     |     /// Prepare an expected log with all topic and data checks enabled.
 2371 |     |     /// Call this function, then emit an event, then call a function. Internally after the call, we check if
 2372 |     |     /// logs were emitted in the expected order with the expected topics and data.
 2373 |     |     function expectEmit() external;
 2374 |     | 
 2375 |     |     /// Same as the previous method, but also checks supplied address against emitting contract.
 2376 |     |     function expectEmit(address emitter) external;
 2377 |     | 
 2378 |     |     /// Expect a given number of logs with the provided topics.
 2379 |     |     function expectEmit(bool checkTopic1, bool checkTopic2, bool checkTopic3, bool checkData, uint64 count) external;
 2380 |     | 
 2381 |     |     /// Expect a given number of logs from a specific emitter with the provided topics.
 2382 |     |     function expectEmit(
 2383 |     |         bool checkTopic1,
 2384 |     |         bool checkTopic2,
 2385 |     |         bool checkTopic3,
 2386 |     |         bool checkData,
 2387 |     |         address emitter,
 2388 |     |         uint64 count
 2389 |     |     ) external;
 2390 |     | 
 2391 |     |     /// Expect a given number of logs with all topic and data checks enabled.
 2392 |     |     function expectEmit(uint64 count) external;
 2393 |     | 
 2394 |     |     /// Expect a given number of logs from a specific emitter with all topic and data checks enabled.
 2395 |     |     function expectEmit(address emitter, uint64 count) external;
 2396 |     | 
 2397 |     |     /// Expects an error on next call that starts with the revert data.
 2398 |     |     function expectPartialRevert(bytes4 revertData) external;
 2399 |     | 
 2400 |     |     /// Expects an error on next call to reverter address, that starts with the revert data.
 2401 |     |     function expectPartialRevert(bytes4 revertData, address reverter) external;
 2402 |     | 
 2403 |     |     /// Expects an error on next call with any revert data.
 2404 |     |     function expectRevert() external;
 2405 |     | 
 2406 |     |     /// Expects an error on next call that exactly matches the revert data.
 2407 |     |     function expectRevert(bytes4 revertData) external;
 2408 |     | 
 2409 |     |     /// Expects a `count` number of reverts from the upcoming calls from the reverter address that match the revert data.
 2410 |     |     function expectRevert(bytes4 revertData, address reverter, uint64 count) external;
 2411 |     | 
 2412 |     |     /// Expects a `count` number of reverts from the upcoming calls from the reverter address that exactly match the revert data.
 2413 |     |     function expectRevert(bytes calldata revertData, address reverter, uint64 count) external;
 2414 |     | 
 2415 |     |     /// Expects an error on next call that exactly matches the revert data.
 2416 |     |     function expectRevert(bytes calldata revertData) external;
 2417 |     | 
 2418 |     |     /// Expects an error with any revert data on next call to reverter address.
 2419 |     |     function expectRevert(address reverter) external;
 2420 |     | 
 2421 |     |     /// Expects an error from reverter address on next call, with any revert data.
 2422 |     |     function expectRevert(bytes4 revertData, address reverter) external;
 2423 |     | 
 2424 |     |     /// Expects an error from reverter address on next call, that exactly matches the revert data.
 2425 |     |     function expectRevert(bytes calldata revertData, address reverter) external;
 2426 |     | 
 2427 |     |     /// Expects a `count` number of reverts from the upcoming calls with any revert data or reverter.
 2428 |     |     function expectRevert(uint64 count) external;
 2429 |     | 
 2430 |     |     /// Expects a `count` number of reverts from the upcoming calls that match the revert data.
 2431 |     |     function expectRevert(bytes4 revertData, uint64 count) external;
 2432 |     | 
 2433 |     |     /// Expects a `count` number of reverts from the upcoming calls that exactly match the revert data.
 2434 |     |     function expectRevert(bytes calldata revertData, uint64 count) external;
 2435 |     | 
 2436 |     |     /// Expects a `count` number of reverts from the upcoming calls from the reverter address.
 2437 |     |     function expectRevert(address reverter, uint64 count) external;
 2438 |     | 
 2439 |     |     /// Only allows memory writes to offsets [0x00, 0x60)  [min, max) in the current subcontext. If any other
 2440 |     |     /// memory is written to, the test will fail. Can be called multiple times to add more ranges to the set.
 2441 |     |     function expectSafeMemory(uint64 min, uint64 max) external;
 2442 |     | 
 2443 |     |     /// Only allows memory writes to offsets [0x00, 0x60)  [min, max) in the next created subcontext.
 2444 |     |     /// If any other memory is written to, the test will fail. Can be called multiple times to add more ranges
 2445 |     |     /// to the set.
 2446 |     |     function expectSafeMemoryCall(uint64 min, uint64 max) external;
 2447 |     | 
 2448 |     |     /// Marks a test as skipped. Must be called at the top level of a test.
 2449 |     |     function skip(bool skipTest) external;
 2450 |     | 
 2451 |     |     /// Marks a test as skipped with a reason. Must be called at the top level of a test.
 2452 |     |     function skip(bool skipTest, string calldata reason) external;
 2453 |     | 
 2454 |     |     /// Stops all safe memory expectation in the current subcontext.
 2455 |     |     function stopExpectSafeMemory() external;
 2456 |     | 
 2457 |     |     // ======== Utilities ========
 2458 |     | 
 2459 |     |     /// Causes the next contract creation (via new) to fail and return its initcode in the returndata buffer.
 2460 |     |     /// This allows type-safe access to the initcode payload that would be used for contract creation.
 2461 |     |     /// Example usage:
 2462 |     |     /// vm.interceptInitcode();
 2463 |     |     /// bytes memory initcode;
 2464 |     |     /// try new MyContract(param1, param2) { assert(false); }
 2465 |     |     /// catch (bytes memory interceptedInitcode) { initcode = interceptedInitcode; }
 2466 |     |     function interceptInitcode() external;
 2467 |     | }
 2468 |     | 

/home/phantom/Documents/azemora/azemora-contracts/lib/forge-std/src/console.sol
    1 |     | // SPDX-License-Identifier: MIT
    2 |     | pragma solidity >=0.4.22 <0.9.0;
    3 |     | 
    4 |     | library console {
    5 |     |     address constant CONSOLE_ADDRESS =
    6 |     |         0x000000000000000000636F6e736F6c652e6c6f67;
    7 |     | 
    8 |     |     function _sendLogPayloadImplementation(bytes memory payload) internal view {
    9 |     |         address consoleAddress = CONSOLE_ADDRESS;
   10 |     |         /// @solidity memory-safe-assembly
   11 |     |         assembly {
   12 |     |             pop(
   13 |     |                 staticcall(
   14 |     |                     gas(),
   15 |     |                     consoleAddress,
   16 |     |                     add(payload, 32),
   17 |     |                     mload(payload),
   18 |     |                     0,
   19 |     |                     0
   20 |     |                 )
   21 |     |             )
   22 |     |         }
   23 |     |     }
   24 |     | 
   25 |     |     function _castToPure(
   26 |     |       function(bytes memory) internal view fnIn
   27 |     |     ) internal pure returns (function(bytes memory) pure fnOut) {
   28 |     |         assembly {
   29 |     |             fnOut := fnIn
   30 |     |         }
   31 |     |     }
   32 |     | 
   33 |     |     function _sendLogPayload(bytes memory payload) internal pure {
   34 |     |         _castToPure(_sendLogPayloadImplementation)(payload);
   35 |     |     }
   36 |     | 
   37 |     |     function log() internal pure {
   38 |     |         _sendLogPayload(abi.encodeWithSignature("log()"));
   39 |     |     }
   40 |     | 
   41 |     |     function logInt(int256 p0) internal pure {
   42 |     |         _sendLogPayload(abi.encodeWithSignature("log(int256)", p0));
   43 |     |     }
   44 |     | 
   45 |     |     function logUint(uint256 p0) internal pure {
   46 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256)", p0));
   47 |     |     }
   48 |     | 
   49 |     |     function logString(string memory p0) internal pure {
   50 |     |         _sendLogPayload(abi.encodeWithSignature("log(string)", p0));
   51 |     |     }
   52 |     | 
   53 |     |     function logBool(bool p0) internal pure {
   54 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool)", p0));
   55 |     |     }
   56 |     | 
   57 |     |     function logAddress(address p0) internal pure {
   58 |     |         _sendLogPayload(abi.encodeWithSignature("log(address)", p0));
   59 |     |     }
   60 |     | 
   61 |     |     function logBytes(bytes memory p0) internal pure {
   62 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes)", p0));
   63 |     |     }
   64 |     | 
   65 |     |     function logBytes1(bytes1 p0) internal pure {
   66 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes1)", p0));
   67 |     |     }
   68 |     | 
   69 |     |     function logBytes2(bytes2 p0) internal pure {
   70 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes2)", p0));
   71 |     |     }
   72 |     | 
   73 |     |     function logBytes3(bytes3 p0) internal pure {
   74 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes3)", p0));
   75 |     |     }
   76 |     | 
   77 |     |     function logBytes4(bytes4 p0) internal pure {
   78 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes4)", p0));
   79 |     |     }
   80 |     | 
   81 |     |     function logBytes5(bytes5 p0) internal pure {
   82 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes5)", p0));
   83 |     |     }
   84 |     | 
   85 |     |     function logBytes6(bytes6 p0) internal pure {
   86 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes6)", p0));
   87 |     |     }
   88 |     | 
   89 |     |     function logBytes7(bytes7 p0) internal pure {
   90 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes7)", p0));
   91 |     |     }
   92 |     | 
   93 |     |     function logBytes8(bytes8 p0) internal pure {
   94 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes8)", p0));
   95 |     |     }
   96 |     | 
   97 |     |     function logBytes9(bytes9 p0) internal pure {
   98 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes9)", p0));
   99 |     |     }
  100 |     | 
  101 |     |     function logBytes10(bytes10 p0) internal pure {
  102 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes10)", p0));
  103 |     |     }
  104 |     | 
  105 |     |     function logBytes11(bytes11 p0) internal pure {
  106 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes11)", p0));
  107 |     |     }
  108 |     | 
  109 |     |     function logBytes12(bytes12 p0) internal pure {
  110 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes12)", p0));
  111 |     |     }
  112 |     | 
  113 |     |     function logBytes13(bytes13 p0) internal pure {
  114 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes13)", p0));
  115 |     |     }
  116 |     | 
  117 |     |     function logBytes14(bytes14 p0) internal pure {
  118 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes14)", p0));
  119 |     |     }
  120 |     | 
  121 |     |     function logBytes15(bytes15 p0) internal pure {
  122 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes15)", p0));
  123 |     |     }
  124 |     | 
  125 |     |     function logBytes16(bytes16 p0) internal pure {
  126 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes16)", p0));
  127 |     |     }
  128 |     | 
  129 |     |     function logBytes17(bytes17 p0) internal pure {
  130 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes17)", p0));
  131 |     |     }
  132 |     | 
  133 |     |     function logBytes18(bytes18 p0) internal pure {
  134 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes18)", p0));
  135 |     |     }
  136 |     | 
  137 |     |     function logBytes19(bytes19 p0) internal pure {
  138 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes19)", p0));
  139 |     |     }
  140 |     | 
  141 |     |     function logBytes20(bytes20 p0) internal pure {
  142 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes20)", p0));
  143 |     |     }
  144 |     | 
  145 |     |     function logBytes21(bytes21 p0) internal pure {
  146 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes21)", p0));
  147 |     |     }
  148 |     | 
  149 |     |     function logBytes22(bytes22 p0) internal pure {
  150 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes22)", p0));
  151 |     |     }
  152 |     | 
  153 |     |     function logBytes23(bytes23 p0) internal pure {
  154 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes23)", p0));
  155 |     |     }
  156 |     | 
  157 |     |     function logBytes24(bytes24 p0) internal pure {
  158 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes24)", p0));
  159 |     |     }
  160 |     | 
  161 |     |     function logBytes25(bytes25 p0) internal pure {
  162 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes25)", p0));
  163 |     |     }
  164 |     | 
  165 |     |     function logBytes26(bytes26 p0) internal pure {
  166 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes26)", p0));
  167 |     |     }
  168 |     | 
  169 |     |     function logBytes27(bytes27 p0) internal pure {
  170 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes27)", p0));
  171 |     |     }
  172 |     | 
  173 |     |     function logBytes28(bytes28 p0) internal pure {
  174 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes28)", p0));
  175 |     |     }
  176 |     | 
  177 |     |     function logBytes29(bytes29 p0) internal pure {
  178 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes29)", p0));
  179 |     |     }
  180 |     | 
  181 |     |     function logBytes30(bytes30 p0) internal pure {
  182 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes30)", p0));
  183 |     |     }
  184 |     | 
  185 |     |     function logBytes31(bytes31 p0) internal pure {
  186 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes31)", p0));
  187 |     |     }
  188 |     | 
  189 |     |     function logBytes32(bytes32 p0) internal pure {
  190 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes32)", p0));
  191 |     |     }
  192 |     | 
  193 |     |     function log(uint256 p0) internal pure {
  194 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256)", p0));
  195 |     |     }
  196 |     | 
  197 |     |     function log(int256 p0) internal pure {
  198 |     |         _sendLogPayload(abi.encodeWithSignature("log(int256)", p0));
  199 |     |     }
  200 |     | 
  201 |     |     function log(string memory p0) internal pure {
  202 |     |         _sendLogPayload(abi.encodeWithSignature("log(string)", p0));
  203 |     |     }
  204 |     | 
  205 |     |     function log(bool p0) internal pure {
  206 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool)", p0));
  207 |     |     }
  208 |     | 
  209 |     |     function log(address p0) internal pure {
  210 |     |         _sendLogPayload(abi.encodeWithSignature("log(address)", p0));
  211 |     |     }
  212 |     | 
  213 |     |     function log(uint256 p0, uint256 p1) internal pure {
  214 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,uint256)", p0, p1));
  215 |     |     }
  216 |     | 
  217 |     |     function log(uint256 p0, string memory p1) internal pure {
  218 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,string)", p0, p1));
  219 |     |     }
  220 |     | 
  221 |     |     function log(uint256 p0, bool p1) internal pure {
  222 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,bool)", p0, p1));
  223 |     |     }
  224 |     | 
  225 |     |     function log(uint256 p0, address p1) internal pure {
  226 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,address)", p0, p1));
  227 |     |     }
  228 |     | 
  229 |     |     function log(string memory p0, uint256 p1) internal pure {
  230 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,uint256)", p0, p1));
  231 |     |     }
  232 |     | 
  233 |     |     function log(string memory p0, int256 p1) internal pure {
  234 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,int256)", p0, p1));
  235 |     |     }
  236 |     | 
  237 |     |     function log(string memory p0, string memory p1) internal pure {
  238 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,string)", p0, p1));
  239 |     |     }
  240 |     | 
  241 |     |     function log(string memory p0, bool p1) internal pure {
  242 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,bool)", p0, p1));
  243 |     |     }
  244 |     | 
  245 |     |     function log(string memory p0, address p1) internal pure {
  246 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,address)", p0, p1));
  247 |     |     }
  248 |     | 
  249 |     |     function log(bool p0, uint256 p1) internal pure {
  250 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,uint256)", p0, p1));
  251 |     |     }
  252 |     | 
  253 |     |     function log(bool p0, string memory p1) internal pure {
  254 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,string)", p0, p1));
  255 |     |     }
  256 |     | 
  257 |     |     function log(bool p0, bool p1) internal pure {
  258 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,bool)", p0, p1));
  259 |     |     }
  260 |     | 
  261 |     |     function log(bool p0, address p1) internal pure {
  262 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,address)", p0, p1));
  263 |     |     }
  264 |     | 
  265 |     |     function log(address p0, uint256 p1) internal pure {
  266 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,uint256)", p0, p1));
  267 |     |     }
  268 |     | 
  269 |     |     function log(address p0, string memory p1) internal pure {
  270 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,string)", p0, p1));
  271 |     |     }
  272 |     | 
  273 |     |     function log(address p0, bool p1) internal pure {
  274 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,bool)", p0, p1));
  275 |     |     }
  276 |     | 
  277 |     |     function log(address p0, address p1) internal pure {
  278 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,address)", p0, p1));
  279 |     |     }
  280 |     | 
  281 |     |     function log(uint256 p0, uint256 p1, uint256 p2) internal pure {
  282 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,uint256,uint256)", p0, p1, p2));
  283 |     |     }
  284 |     | 
  285 |     |     function log(uint256 p0, uint256 p1, string memory p2) internal pure {
  286 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,uint256,string)", p0, p1, p2));
  287 |     |     }
  288 |     | 
  289 |     |     function log(uint256 p0, uint256 p1, bool p2) internal pure {
  290 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,uint256,bool)", p0, p1, p2));
  291 |     |     }
  292 |     | 
  293 |     |     function log(uint256 p0, uint256 p1, address p2) internal pure {
  294 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,uint256,address)", p0, p1, p2));
  295 |     |     }
  296 |     | 
  297 |     |     function log(uint256 p0, string memory p1, uint256 p2) internal pure {
  298 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,string,uint256)", p0, p1, p2));
  299 |     |     }
  300 |     | 
  301 |     |     function log(uint256 p0, string memory p1, string memory p2) internal pure {
  302 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,string,string)", p0, p1, p2));
  303 |     |     }
  304 |     | 
  305 |     |     function log(uint256 p0, string memory p1, bool p2) internal pure {
  306 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,string,bool)", p0, p1, p2));
  307 |     |     }
  308 |     | 
  309 |     |     function log(uint256 p0, string memory p1, address p2) internal pure {
  310 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,string,address)", p0, p1, p2));
  311 |     |     }
  312 |     | 
  313 |     |     function log(uint256 p0, bool p1, uint256 p2) internal pure {
  314 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,bool,uint256)", p0, p1, p2));
  315 |     |     }
  316 |     | 
  317 |     |     function log(uint256 p0, bool p1, string memory p2) internal pure {
  318 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,bool,string)", p0, p1, p2));
  319 |     |     }
  320 |     | 
  321 |     |     function log(uint256 p0, bool p1, bool p2) internal pure {
  322 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,bool,bool)", p0, p1, p2));
  323 |     |     }
  324 |     | 
  325 |     |     function log(uint256 p0, bool p1, address p2) internal pure {
  326 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,bool,address)", p0, p1, p2));
  327 |     |     }
  328 |     | 
  329 |     |     function log(uint256 p0, address p1, uint256 p2) internal pure {
  330 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,address,uint256)", p0, p1, p2));
  331 |     |     }
  332 |     | 
  333 |     |     function log(uint256 p0, address p1, string memory p2) internal pure {
  334 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,address,string)", p0, p1, p2));
  335 |     |     }
  336 |     | 
  337 |     |     function log(uint256 p0, address p1, bool p2) internal pure {
  338 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,address,bool)", p0, p1, p2));
  339 |     |     }
  340 |     | 
  341 |     |     function log(uint256 p0, address p1, address p2) internal pure {
  342 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,address,address)", p0, p1, p2));
  343 |     |     }
  344 |     | 
  345 |     |     function log(string memory p0, uint256 p1, uint256 p2) internal pure {
  346 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,uint256,uint256)", p0, p1, p2));
  347 |     |     }
  348 |     | 
  349 |     |     function log(string memory p0, uint256 p1, string memory p2) internal pure {
  350 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,uint256,string)", p0, p1, p2));
  351 |     |     }
  352 |     | 
  353 |     |     function log(string memory p0, uint256 p1, bool p2) internal pure {
  354 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,uint256,bool)", p0, p1, p2));
  355 |     |     }
  356 |     | 
  357 |     |     function log(string memory p0, uint256 p1, address p2) internal pure {
  358 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,uint256,address)", p0, p1, p2));
  359 |     |     }
  360 |     | 
  361 |     |     function log(string memory p0, string memory p1, uint256 p2) internal pure {
  362 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,string,uint256)", p0, p1, p2));
  363 |     |     }
  364 |     | 
  365 |     |     function log(string memory p0, string memory p1, string memory p2) internal pure {
  366 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,string,string)", p0, p1, p2));
  367 |     |     }
  368 |     | 
  369 |     |     function log(string memory p0, string memory p1, bool p2) internal pure {
  370 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,string,bool)", p0, p1, p2));
  371 |     |     }
  372 |     | 
  373 |     |     function log(string memory p0, string memory p1, address p2) internal pure {
  374 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,string,address)", p0, p1, p2));
  375 |     |     }
  376 |     | 
  377 |     |     function log(string memory p0, bool p1, uint256 p2) internal pure {
  378 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,bool,uint256)", p0, p1, p2));
  379 |     |     }
  380 |     | 
  381 |     |     function log(string memory p0, bool p1, string memory p2) internal pure {
  382 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,bool,string)", p0, p1, p2));
  383 |     |     }
  384 |     | 
  385 |     |     function log(string memory p0, bool p1, bool p2) internal pure {
  386 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,bool,bool)", p0, p1, p2));
  387 |     |     }
  388 |     | 
  389 |     |     function log(string memory p0, bool p1, address p2) internal pure {
  390 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,bool,address)", p0, p1, p2));
  391 |     |     }
  392 |     | 
  393 |     |     function log(string memory p0, address p1, uint256 p2) internal pure {
  394 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,address,uint256)", p0, p1, p2));
  395 |     |     }
  396 |     | 
  397 |     |     function log(string memory p0, address p1, string memory p2) internal pure {
  398 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,address,string)", p0, p1, p2));
  399 |     |     }
  400 |     | 
  401 |     |     function log(string memory p0, address p1, bool p2) internal pure {
  402 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,address,bool)", p0, p1, p2));
  403 |     |     }
  404 |     | 
  405 |     |     function log(string memory p0, address p1, address p2) internal pure {
  406 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,address,address)", p0, p1, p2));
  407 |     |     }
  408 |     | 
  409 |     |     function log(bool p0, uint256 p1, uint256 p2) internal pure {
  410 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,uint256,uint256)", p0, p1, p2));
  411 |     |     }
  412 |     | 
  413 |     |     function log(bool p0, uint256 p1, string memory p2) internal pure {
  414 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,uint256,string)", p0, p1, p2));
  415 |     |     }
  416 |     | 
  417 |     |     function log(bool p0, uint256 p1, bool p2) internal pure {
  418 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,uint256,bool)", p0, p1, p2));
  419 |     |     }
  420 |     | 
  421 |     |     function log(bool p0, uint256 p1, address p2) internal pure {
  422 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,uint256,address)", p0, p1, p2));
  423 |     |     }
  424 |     | 
  425 |     |     function log(bool p0, string memory p1, uint256 p2) internal pure {
  426 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,string,uint256)", p0, p1, p2));
  427 |     |     }
  428 |     | 
  429 |     |     function log(bool p0, string memory p1, string memory p2) internal pure {
  430 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,string,string)", p0, p1, p2));
  431 |     |     }
  432 |     | 
  433 |     |     function log(bool p0, string memory p1, bool p2) internal pure {
  434 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,string,bool)", p0, p1, p2));
  435 |     |     }
  436 |     | 
  437 |     |     function log(bool p0, string memory p1, address p2) internal pure {
  438 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,string,address)", p0, p1, p2));
  439 |     |     }
  440 |     | 
  441 |     |     function log(bool p0, bool p1, uint256 p2) internal pure {
  442 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,bool,uint256)", p0, p1, p2));
  443 |     |     }
  444 |     | 
  445 |     |     function log(bool p0, bool p1, string memory p2) internal pure {
  446 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,bool,string)", p0, p1, p2));
  447 |     |     }
  448 |     | 
  449 |     |     function log(bool p0, bool p1, bool p2) internal pure {
  450 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,bool,bool)", p0, p1, p2));
  451 |     |     }
  452 |     | 
  453 |     |     function log(bool p0, bool p1, address p2) internal pure {
  454 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,bool,address)", p0, p1, p2));
  455 |     |     }
  456 |     | 
  457 |     |     function log(bool p0, address p1, uint256 p2) internal pure {
  458 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,address,uint256)", p0, p1, p2));
  459 |     |     }
  460 |     | 
  461 |     |     function log(bool p0, address p1, string memory p2) internal pure {
  462 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,address,string)", p0, p1, p2));
  463 |     |     }
  464 |     | 
  465 |     |     function log(bool p0, address p1, bool p2) internal pure {
  466 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,address,bool)", p0, p1, p2));
  467 |     |     }
  468 |     | 
  469 |     |     function log(bool p0, address p1, address p2) internal pure {
  470 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,address,address)", p0, p1, p2));
  471 |     |     }
  472 |     | 
  473 |     |     function log(address p0, uint256 p1, uint256 p2) internal pure {
  474 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,uint256,uint256)", p0, p1, p2));
  475 |     |     }
  476 |     | 
  477 |     |     function log(address p0, uint256 p1, string memory p2) internal pure {
  478 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,uint256,string)", p0, p1, p2));
  479 |     |     }
  480 |     | 
  481 |     |     function log(address p0, uint256 p1, bool p2) internal pure {
  482 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,uint256,bool)", p0, p1, p2));
  483 |     |     }
  484 |     | 
  485 |     |     function log(address p0, uint256 p1, address p2) internal pure {
  486 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,uint256,address)", p0, p1, p2));
  487 |     |     }
  488 |     | 
  489 |     |     function log(address p0, string memory p1, uint256 p2) internal pure {
  490 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,string,uint256)", p0, p1, p2));
  491 |     |     }
  492 |     | 
  493 |     |     function log(address p0, string memory p1, string memory p2) internal pure {
  494 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,string,string)", p0, p1, p2));
  495 |     |     }
  496 |     | 
  497 |     |     function log(address p0, string memory p1, bool p2) internal pure {
  498 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,string,bool)", p0, p1, p2));
  499 |     |     }
  500 |     | 
  501 |     |     function log(address p0, string memory p1, address p2) internal pure {
  502 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,string,address)", p0, p1, p2));
  503 |     |     }
  504 |     | 
  505 |     |     function log(address p0, bool p1, uint256 p2) internal pure {
  506 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,bool,uint256)", p0, p1, p2));
  507 |     |     }
  508 |     | 
  509 |     |     function log(address p0, bool p1, string memory p2) internal pure {
  510 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,bool,string)", p0, p1, p2));
  511 |     |     }
  512 |     | 
  513 |     |     function log(address p0, bool p1, bool p2) internal pure {
  514 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,bool,bool)", p0, p1, p2));
  515 |     |     }
  516 |     | 
  517 |     |     function log(address p0, bool p1, address p2) internal pure {
  518 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,bool,address)", p0, p1, p2));
  519 |     |     }
  520 |     | 
  521 |     |     function log(address p0, address p1, uint256 p2) internal pure {
  522 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,address,uint256)", p0, p1, p2));
  523 |     |     }
  524 |     | 
  525 |     |     function log(address p0, address p1, string memory p2) internal pure {
  526 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,address,string)", p0, p1, p2));
  527 |     |     }
  528 |     | 
  529 |     |     function log(address p0, address p1, bool p2) internal pure {
  530 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,address,bool)", p0, p1, p2));
  531 |     |     }
  532 |     | 
  533 |     |     function log(address p0, address p1, address p2) internal pure {
  534 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,address,address)", p0, p1, p2));
  535 |     |     }
  536 |     | 
  537 |     |     function log(uint256 p0, uint256 p1, uint256 p2, uint256 p3) internal pure {
  538 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,uint256,uint256,uint256)", p0, p1, p2, p3));
  539 |     |     }
  540 |     | 
  541 |     |     function log(uint256 p0, uint256 p1, uint256 p2, string memory p3) internal pure {
  542 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,uint256,uint256,string)", p0, p1, p2, p3));
  543 |     |     }
  544 |     | 
  545 |     |     function log(uint256 p0, uint256 p1, uint256 p2, bool p3) internal pure {
  546 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,uint256,uint256,bool)", p0, p1, p2, p3));
  547 |     |     }
  548 |     | 
  549 |     |     function log(uint256 p0, uint256 p1, uint256 p2, address p3) internal pure {
  550 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,uint256,uint256,address)", p0, p1, p2, p3));
  551 |     |     }
  552 |     | 
  553 |     |     function log(uint256 p0, uint256 p1, string memory p2, uint256 p3) internal pure {
  554 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,uint256,string,uint256)", p0, p1, p2, p3));
  555 |     |     }
  556 |     | 
  557 |     |     function log(uint256 p0, uint256 p1, string memory p2, string memory p3) internal pure {
  558 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,uint256,string,string)", p0, p1, p2, p3));
  559 |     |     }
  560 |     | 
  561 |     |     function log(uint256 p0, uint256 p1, string memory p2, bool p3) internal pure {
  562 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,uint256,string,bool)", p0, p1, p2, p3));
  563 |     |     }
  564 |     | 
  565 |     |     function log(uint256 p0, uint256 p1, string memory p2, address p3) internal pure {
  566 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,uint256,string,address)", p0, p1, p2, p3));
  567 |     |     }
  568 |     | 
  569 |     |     function log(uint256 p0, uint256 p1, bool p2, uint256 p3) internal pure {
  570 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,uint256,bool,uint256)", p0, p1, p2, p3));
  571 |     |     }
  572 |     | 
  573 |     |     function log(uint256 p0, uint256 p1, bool p2, string memory p3) internal pure {
  574 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,uint256,bool,string)", p0, p1, p2, p3));
  575 |     |     }
  576 |     | 
  577 |     |     function log(uint256 p0, uint256 p1, bool p2, bool p3) internal pure {
  578 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,uint256,bool,bool)", p0, p1, p2, p3));
  579 |     |     }
  580 |     | 
  581 |     |     function log(uint256 p0, uint256 p1, bool p2, address p3) internal pure {
  582 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,uint256,bool,address)", p0, p1, p2, p3));
  583 |     |     }
  584 |     | 
  585 |     |     function log(uint256 p0, uint256 p1, address p2, uint256 p3) internal pure {
  586 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,uint256,address,uint256)", p0, p1, p2, p3));
  587 |     |     }
  588 |     | 
  589 |     |     function log(uint256 p0, uint256 p1, address p2, string memory p3) internal pure {
  590 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,uint256,address,string)", p0, p1, p2, p3));
  591 |     |     }
  592 |     | 
  593 |     |     function log(uint256 p0, uint256 p1, address p2, bool p3) internal pure {
  594 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,uint256,address,bool)", p0, p1, p2, p3));
  595 |     |     }
  596 |     | 
  597 |     |     function log(uint256 p0, uint256 p1, address p2, address p3) internal pure {
  598 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,uint256,address,address)", p0, p1, p2, p3));
  599 |     |     }
  600 |     | 
  601 |     |     function log(uint256 p0, string memory p1, uint256 p2, uint256 p3) internal pure {
  602 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,string,uint256,uint256)", p0, p1, p2, p3));
  603 |     |     }
  604 |     | 
  605 |     |     function log(uint256 p0, string memory p1, uint256 p2, string memory p3) internal pure {
  606 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,string,uint256,string)", p0, p1, p2, p3));
  607 |     |     }
  608 |     | 
  609 |     |     function log(uint256 p0, string memory p1, uint256 p2, bool p3) internal pure {
  610 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,string,uint256,bool)", p0, p1, p2, p3));
  611 |     |     }
  612 |     | 
  613 |     |     function log(uint256 p0, string memory p1, uint256 p2, address p3) internal pure {
  614 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,string,uint256,address)", p0, p1, p2, p3));
  615 |     |     }
  616 |     | 
  617 |     |     function log(uint256 p0, string memory p1, string memory p2, uint256 p3) internal pure {
  618 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,string,string,uint256)", p0, p1, p2, p3));
  619 |     |     }
  620 |     | 
  621 |     |     function log(uint256 p0, string memory p1, string memory p2, string memory p3) internal pure {
  622 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,string,string,string)", p0, p1, p2, p3));
  623 |     |     }
  624 |     | 
  625 |     |     function log(uint256 p0, string memory p1, string memory p2, bool p3) internal pure {
  626 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,string,string,bool)", p0, p1, p2, p3));
  627 |     |     }
  628 |     | 
  629 |     |     function log(uint256 p0, string memory p1, string memory p2, address p3) internal pure {
  630 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,string,string,address)", p0, p1, p2, p3));
  631 |     |     }
  632 |     | 
  633 |     |     function log(uint256 p0, string memory p1, bool p2, uint256 p3) internal pure {
  634 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,string,bool,uint256)", p0, p1, p2, p3));
  635 |     |     }
  636 |     | 
  637 |     |     function log(uint256 p0, string memory p1, bool p2, string memory p3) internal pure {
  638 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,string,bool,string)", p0, p1, p2, p3));
  639 |     |     }
  640 |     | 
  641 |     |     function log(uint256 p0, string memory p1, bool p2, bool p3) internal pure {
  642 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,string,bool,bool)", p0, p1, p2, p3));
  643 |     |     }
  644 |     | 
  645 |     |     function log(uint256 p0, string memory p1, bool p2, address p3) internal pure {
  646 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,string,bool,address)", p0, p1, p2, p3));
  647 |     |     }
  648 |     | 
  649 |     |     function log(uint256 p0, string memory p1, address p2, uint256 p3) internal pure {
  650 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,string,address,uint256)", p0, p1, p2, p3));
  651 |     |     }
  652 |     | 
  653 |     |     function log(uint256 p0, string memory p1, address p2, string memory p3) internal pure {
  654 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,string,address,string)", p0, p1, p2, p3));
  655 |     |     }
  656 |     | 
  657 |     |     function log(uint256 p0, string memory p1, address p2, bool p3) internal pure {
  658 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,string,address,bool)", p0, p1, p2, p3));
  659 |     |     }
  660 |     | 
  661 |     |     function log(uint256 p0, string memory p1, address p2, address p3) internal pure {
  662 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,string,address,address)", p0, p1, p2, p3));
  663 |     |     }
  664 |     | 
  665 |     |     function log(uint256 p0, bool p1, uint256 p2, uint256 p3) internal pure {
  666 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,bool,uint256,uint256)", p0, p1, p2, p3));
  667 |     |     }
  668 |     | 
  669 |     |     function log(uint256 p0, bool p1, uint256 p2, string memory p3) internal pure {
  670 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,bool,uint256,string)", p0, p1, p2, p3));
  671 |     |     }
  672 |     | 
  673 |     |     function log(uint256 p0, bool p1, uint256 p2, bool p3) internal pure {
  674 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,bool,uint256,bool)", p0, p1, p2, p3));
  675 |     |     }
  676 |     | 
  677 |     |     function log(uint256 p0, bool p1, uint256 p2, address p3) internal pure {
  678 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,bool,uint256,address)", p0, p1, p2, p3));
  679 |     |     }
  680 |     | 
  681 |     |     function log(uint256 p0, bool p1, string memory p2, uint256 p3) internal pure {
  682 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,bool,string,uint256)", p0, p1, p2, p3));
  683 |     |     }
  684 |     | 
  685 |     |     function log(uint256 p0, bool p1, string memory p2, string memory p3) internal pure {
  686 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,bool,string,string)", p0, p1, p2, p3));
  687 |     |     }
  688 |     | 
  689 |     |     function log(uint256 p0, bool p1, string memory p2, bool p3) internal pure {
  690 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,bool,string,bool)", p0, p1, p2, p3));
  691 |     |     }
  692 |     | 
  693 |     |     function log(uint256 p0, bool p1, string memory p2, address p3) internal pure {
  694 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,bool,string,address)", p0, p1, p2, p3));
  695 |     |     }
  696 |     | 
  697 |     |     function log(uint256 p0, bool p1, bool p2, uint256 p3) internal pure {
  698 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,bool,bool,uint256)", p0, p1, p2, p3));
  699 |     |     }
  700 |     | 
  701 |     |     function log(uint256 p0, bool p1, bool p2, string memory p3) internal pure {
  702 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,bool,bool,string)", p0, p1, p2, p3));
  703 |     |     }
  704 |     | 
  705 |     |     function log(uint256 p0, bool p1, bool p2, bool p3) internal pure {
  706 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,bool,bool,bool)", p0, p1, p2, p3));
  707 |     |     }
  708 |     | 
  709 |     |     function log(uint256 p0, bool p1, bool p2, address p3) internal pure {
  710 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,bool,bool,address)", p0, p1, p2, p3));
  711 |     |     }
  712 |     | 
  713 |     |     function log(uint256 p0, bool p1, address p2, uint256 p3) internal pure {
  714 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,bool,address,uint256)", p0, p1, p2, p3));
  715 |     |     }
  716 |     | 
  717 |     |     function log(uint256 p0, bool p1, address p2, string memory p3) internal pure {
  718 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,bool,address,string)", p0, p1, p2, p3));
  719 |     |     }
  720 |     | 
  721 |     |     function log(uint256 p0, bool p1, address p2, bool p3) internal pure {
  722 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,bool,address,bool)", p0, p1, p2, p3));
  723 |     |     }
  724 |     | 
  725 |     |     function log(uint256 p0, bool p1, address p2, address p3) internal pure {
  726 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,bool,address,address)", p0, p1, p2, p3));
  727 |     |     }
  728 |     | 
  729 |     |     function log(uint256 p0, address p1, uint256 p2, uint256 p3) internal pure {
  730 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,address,uint256,uint256)", p0, p1, p2, p3));
  731 |     |     }
  732 |     | 
  733 |     |     function log(uint256 p0, address p1, uint256 p2, string memory p3) internal pure {
  734 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,address,uint256,string)", p0, p1, p2, p3));
  735 |     |     }
  736 |     | 
  737 |     |     function log(uint256 p0, address p1, uint256 p2, bool p3) internal pure {
  738 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,address,uint256,bool)", p0, p1, p2, p3));
  739 |     |     }
  740 |     | 
  741 |     |     function log(uint256 p0, address p1, uint256 p2, address p3) internal pure {
  742 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,address,uint256,address)", p0, p1, p2, p3));
  743 |     |     }
  744 |     | 
  745 |     |     function log(uint256 p0, address p1, string memory p2, uint256 p3) internal pure {
  746 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,address,string,uint256)", p0, p1, p2, p3));
  747 |     |     }
  748 |     | 
  749 |     |     function log(uint256 p0, address p1, string memory p2, string memory p3) internal pure {
  750 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,address,string,string)", p0, p1, p2, p3));
  751 |     |     }
  752 |     | 
  753 |     |     function log(uint256 p0, address p1, string memory p2, bool p3) internal pure {
  754 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,address,string,bool)", p0, p1, p2, p3));
  755 |     |     }
  756 |     | 
  757 |     |     function log(uint256 p0, address p1, string memory p2, address p3) internal pure {
  758 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,address,string,address)", p0, p1, p2, p3));
  759 |     |     }
  760 |     | 
  761 |     |     function log(uint256 p0, address p1, bool p2, uint256 p3) internal pure {
  762 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,address,bool,uint256)", p0, p1, p2, p3));
  763 |     |     }
  764 |     | 
  765 |     |     function log(uint256 p0, address p1, bool p2, string memory p3) internal pure {
  766 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,address,bool,string)", p0, p1, p2, p3));
  767 |     |     }
  768 |     | 
  769 |     |     function log(uint256 p0, address p1, bool p2, bool p3) internal pure {
  770 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,address,bool,bool)", p0, p1, p2, p3));
  771 |     |     }
  772 |     | 
  773 |     |     function log(uint256 p0, address p1, bool p2, address p3) internal pure {
  774 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,address,bool,address)", p0, p1, p2, p3));
  775 |     |     }
  776 |     | 
  777 |     |     function log(uint256 p0, address p1, address p2, uint256 p3) internal pure {
  778 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,address,address,uint256)", p0, p1, p2, p3));
  779 |     |     }
  780 |     | 
  781 |     |     function log(uint256 p0, address p1, address p2, string memory p3) internal pure {
  782 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,address,address,string)", p0, p1, p2, p3));
  783 |     |     }
  784 |     | 
  785 |     |     function log(uint256 p0, address p1, address p2, bool p3) internal pure {
  786 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,address,address,bool)", p0, p1, p2, p3));
  787 |     |     }
  788 |     | 
  789 |     |     function log(uint256 p0, address p1, address p2, address p3) internal pure {
  790 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,address,address,address)", p0, p1, p2, p3));
  791 |     |     }
  792 |     | 
  793 |     |     function log(string memory p0, uint256 p1, uint256 p2, uint256 p3) internal pure {
  794 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,uint256,uint256,uint256)", p0, p1, p2, p3));
  795 |     |     }
  796 |     | 
  797 |     |     function log(string memory p0, uint256 p1, uint256 p2, string memory p3) internal pure {
  798 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,uint256,uint256,string)", p0, p1, p2, p3));
  799 |     |     }
  800 |     | 
  801 |     |     function log(string memory p0, uint256 p1, uint256 p2, bool p3) internal pure {
  802 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,uint256,uint256,bool)", p0, p1, p2, p3));
  803 |     |     }
  804 |     | 
  805 |     |     function log(string memory p0, uint256 p1, uint256 p2, address p3) internal pure {
  806 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,uint256,uint256,address)", p0, p1, p2, p3));
  807 |     |     }
  808 |     | 
  809 |     |     function log(string memory p0, uint256 p1, string memory p2, uint256 p3) internal pure {
  810 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,uint256,string,uint256)", p0, p1, p2, p3));
  811 |     |     }
  812 |     | 
  813 |     |     function log(string memory p0, uint256 p1, string memory p2, string memory p3) internal pure {
  814 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,uint256,string,string)", p0, p1, p2, p3));
  815 |     |     }
  816 |     | 
  817 |     |     function log(string memory p0, uint256 p1, string memory p2, bool p3) internal pure {
  818 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,uint256,string,bool)", p0, p1, p2, p3));
  819 |     |     }
  820 |     | 
  821 |     |     function log(string memory p0, uint256 p1, string memory p2, address p3) internal pure {
  822 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,uint256,string,address)", p0, p1, p2, p3));
  823 |     |     }
  824 |     | 
  825 |     |     function log(string memory p0, uint256 p1, bool p2, uint256 p3) internal pure {
  826 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,uint256,bool,uint256)", p0, p1, p2, p3));
  827 |     |     }
  828 |     | 
  829 |     |     function log(string memory p0, uint256 p1, bool p2, string memory p3) internal pure {
  830 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,uint256,bool,string)", p0, p1, p2, p3));
  831 |     |     }
  832 |     | 
  833 |     |     function log(string memory p0, uint256 p1, bool p2, bool p3) internal pure {
  834 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,uint256,bool,bool)", p0, p1, p2, p3));
  835 |     |     }
  836 |     | 
  837 |     |     function log(string memory p0, uint256 p1, bool p2, address p3) internal pure {
  838 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,uint256,bool,address)", p0, p1, p2, p3));
  839 |     |     }
  840 |     | 
  841 |     |     function log(string memory p0, uint256 p1, address p2, uint256 p3) internal pure {
  842 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,uint256,address,uint256)", p0, p1, p2, p3));
  843 |     |     }
  844 |     | 
  845 |     |     function log(string memory p0, uint256 p1, address p2, string memory p3) internal pure {
  846 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,uint256,address,string)", p0, p1, p2, p3));
  847 |     |     }
  848 |     | 
  849 |     |     function log(string memory p0, uint256 p1, address p2, bool p3) internal pure {
  850 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,uint256,address,bool)", p0, p1, p2, p3));
  851 |     |     }
  852 |     | 
  853 |     |     function log(string memory p0, uint256 p1, address p2, address p3) internal pure {
  854 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,uint256,address,address)", p0, p1, p2, p3));
  855 |     |     }
  856 |     | 
  857 |     |     function log(string memory p0, string memory p1, uint256 p2, uint256 p3) internal pure {
  858 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,string,uint256,uint256)", p0, p1, p2, p3));
  859 |     |     }
  860 |     | 
  861 |     |     function log(string memory p0, string memory p1, uint256 p2, string memory p3) internal pure {
  862 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,string,uint256,string)", p0, p1, p2, p3));
  863 |     |     }
  864 |     | 
  865 |     |     function log(string memory p0, string memory p1, uint256 p2, bool p3) internal pure {
  866 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,string,uint256,bool)", p0, p1, p2, p3));
  867 |     |     }
  868 |     | 
  869 |     |     function log(string memory p0, string memory p1, uint256 p2, address p3) internal pure {
  870 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,string,uint256,address)", p0, p1, p2, p3));
  871 |     |     }
  872 |     | 
  873 |     |     function log(string memory p0, string memory p1, string memory p2, uint256 p3) internal pure {
  874 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,string,string,uint256)", p0, p1, p2, p3));
  875 |     |     }
  876 |     | 
  877 |     |     function log(string memory p0, string memory p1, string memory p2, string memory p3) internal pure {
  878 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,string,string,string)", p0, p1, p2, p3));
  879 |     |     }
  880 |     | 
  881 |     |     function log(string memory p0, string memory p1, string memory p2, bool p3) internal pure {
  882 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,string,string,bool)", p0, p1, p2, p3));
  883 |     |     }
  884 |     | 
  885 |     |     function log(string memory p0, string memory p1, string memory p2, address p3) internal pure {
  886 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,string,string,address)", p0, p1, p2, p3));
  887 |     |     }
  888 |     | 
  889 |     |     function log(string memory p0, string memory p1, bool p2, uint256 p3) internal pure {
  890 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,string,bool,uint256)", p0, p1, p2, p3));
  891 |     |     }
  892 |     | 
  893 |     |     function log(string memory p0, string memory p1, bool p2, string memory p3) internal pure {
  894 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,string,bool,string)", p0, p1, p2, p3));
  895 |     |     }
  896 |     | 
  897 |     |     function log(string memory p0, string memory p1, bool p2, bool p3) internal pure {
  898 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,string,bool,bool)", p0, p1, p2, p3));
  899 |     |     }
  900 |     | 
  901 |     |     function log(string memory p0, string memory p1, bool p2, address p3) internal pure {
  902 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,string,bool,address)", p0, p1, p2, p3));
  903 |     |     }
  904 |     | 
  905 |     |     function log(string memory p0, string memory p1, address p2, uint256 p3) internal pure {
  906 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,string,address,uint256)", p0, p1, p2, p3));
  907 |     |     }
  908 |     | 
  909 |     |     function log(string memory p0, string memory p1, address p2, string memory p3) internal pure {
  910 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,string,address,string)", p0, p1, p2, p3));
  911 |     |     }
  912 |     | 
  913 |     |     function log(string memory p0, string memory p1, address p2, bool p3) internal pure {
  914 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,string,address,bool)", p0, p1, p2, p3));
  915 |     |     }
  916 |     | 
  917 |     |     function log(string memory p0, string memory p1, address p2, address p3) internal pure {
  918 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,string,address,address)", p0, p1, p2, p3));
  919 |     |     }
  920 |     | 
  921 |     |     function log(string memory p0, bool p1, uint256 p2, uint256 p3) internal pure {
  922 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,bool,uint256,uint256)", p0, p1, p2, p3));
  923 |     |     }
  924 |     | 
  925 |     |     function log(string memory p0, bool p1, uint256 p2, string memory p3) internal pure {
  926 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,bool,uint256,string)", p0, p1, p2, p3));
  927 |     |     }
  928 |     | 
  929 |     |     function log(string memory p0, bool p1, uint256 p2, bool p3) internal pure {
  930 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,bool,uint256,bool)", p0, p1, p2, p3));
  931 |     |     }
  932 |     | 
  933 |     |     function log(string memory p0, bool p1, uint256 p2, address p3) internal pure {
  934 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,bool,uint256,address)", p0, p1, p2, p3));
  935 |     |     }
  936 |     | 
  937 |     |     function log(string memory p0, bool p1, string memory p2, uint256 p3) internal pure {
  938 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,bool,string,uint256)", p0, p1, p2, p3));
  939 |     |     }
  940 |     | 
  941 |     |     function log(string memory p0, bool p1, string memory p2, string memory p3) internal pure {
  942 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,bool,string,string)", p0, p1, p2, p3));
  943 |     |     }
  944 |     | 
  945 |     |     function log(string memory p0, bool p1, string memory p2, bool p3) internal pure {
  946 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,bool,string,bool)", p0, p1, p2, p3));
  947 |     |     }
  948 |     | 
  949 |     |     function log(string memory p0, bool p1, string memory p2, address p3) internal pure {
  950 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,bool,string,address)", p0, p1, p2, p3));
  951 |     |     }
  952 |     | 
  953 |     |     function log(string memory p0, bool p1, bool p2, uint256 p3) internal pure {
  954 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,bool,bool,uint256)", p0, p1, p2, p3));
  955 |     |     }
  956 |     | 
  957 |     |     function log(string memory p0, bool p1, bool p2, string memory p3) internal pure {
  958 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,bool,bool,string)", p0, p1, p2, p3));
  959 |     |     }
  960 |     | 
  961 |     |     function log(string memory p0, bool p1, bool p2, bool p3) internal pure {
  962 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,bool,bool,bool)", p0, p1, p2, p3));
  963 |     |     }
  964 |     | 
  965 |     |     function log(string memory p0, bool p1, bool p2, address p3) internal pure {
  966 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,bool,bool,address)", p0, p1, p2, p3));
  967 |     |     }
  968 |     | 
  969 |     |     function log(string memory p0, bool p1, address p2, uint256 p3) internal pure {
  970 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,bool,address,uint256)", p0, p1, p2, p3));
  971 |     |     }
  972 |     | 
  973 |     |     function log(string memory p0, bool p1, address p2, string memory p3) internal pure {
  974 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,bool,address,string)", p0, p1, p2, p3));
  975 |     |     }
  976 |     | 
  977 |     |     function log(string memory p0, bool p1, address p2, bool p3) internal pure {
  978 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,bool,address,bool)", p0, p1, p2, p3));
  979 |     |     }
  980 |     | 
  981 |     |     function log(string memory p0, bool p1, address p2, address p3) internal pure {
  982 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,bool,address,address)", p0, p1, p2, p3));
  983 |     |     }
  984 |     | 
  985 |     |     function log(string memory p0, address p1, uint256 p2, uint256 p3) internal pure {
  986 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,address,uint256,uint256)", p0, p1, p2, p3));
  987 |     |     }
  988 |     | 
  989 |     |     function log(string memory p0, address p1, uint256 p2, string memory p3) internal pure {
  990 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,address,uint256,string)", p0, p1, p2, p3));
  991 |     |     }
  992 |     | 
  993 |     |     function log(string memory p0, address p1, uint256 p2, bool p3) internal pure {
  994 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,address,uint256,bool)", p0, p1, p2, p3));
  995 |     |     }
  996 |     | 
  997 |     |     function log(string memory p0, address p1, uint256 p2, address p3) internal pure {
  998 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,address,uint256,address)", p0, p1, p2, p3));
  999 |     |     }
 1000 |     | 
 1001 |     |     function log(string memory p0, address p1, string memory p2, uint256 p3) internal pure {
 1002 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,address,string,uint256)", p0, p1, p2, p3));
 1003 |     |     }
 1004 |     | 
 1005 |     |     function log(string memory p0, address p1, string memory p2, string memory p3) internal pure {
 1006 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,address,string,string)", p0, p1, p2, p3));
 1007 |     |     }
 1008 |     | 
 1009 |     |     function log(string memory p0, address p1, string memory p2, bool p3) internal pure {
 1010 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,address,string,bool)", p0, p1, p2, p3));
 1011 |     |     }
 1012 |     | 
 1013 |     |     function log(string memory p0, address p1, string memory p2, address p3) internal pure {
 1014 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,address,string,address)", p0, p1, p2, p3));
 1015 |     |     }
 1016 |     | 
 1017 |     |     function log(string memory p0, address p1, bool p2, uint256 p3) internal pure {
 1018 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,address,bool,uint256)", p0, p1, p2, p3));
 1019 |     |     }
 1020 |     | 
 1021 |     |     function log(string memory p0, address p1, bool p2, string memory p3) internal pure {
 1022 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,address,bool,string)", p0, p1, p2, p3));
 1023 |     |     }
 1024 |     | 
 1025 |     |     function log(string memory p0, address p1, bool p2, bool p3) internal pure {
 1026 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,address,bool,bool)", p0, p1, p2, p3));
 1027 |     |     }
 1028 |     | 
 1029 |     |     function log(string memory p0, address p1, bool p2, address p3) internal pure {
 1030 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,address,bool,address)", p0, p1, p2, p3));
 1031 |     |     }
 1032 |     | 
 1033 |     |     function log(string memory p0, address p1, address p2, uint256 p3) internal pure {
 1034 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,address,address,uint256)", p0, p1, p2, p3));
 1035 |     |     }
 1036 |     | 
 1037 |     |     function log(string memory p0, address p1, address p2, string memory p3) internal pure {
 1038 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,address,address,string)", p0, p1, p2, p3));
 1039 |     |     }
 1040 |     | 
 1041 |     |     function log(string memory p0, address p1, address p2, bool p3) internal pure {
 1042 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,address,address,bool)", p0, p1, p2, p3));
 1043 |     |     }
 1044 |     | 
 1045 |     |     function log(string memory p0, address p1, address p2, address p3) internal pure {
 1046 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,address,address,address)", p0, p1, p2, p3));
 1047 |     |     }
 1048 |     | 
 1049 |     |     function log(bool p0, uint256 p1, uint256 p2, uint256 p3) internal pure {
 1050 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,uint256,uint256,uint256)", p0, p1, p2, p3));
 1051 |     |     }
 1052 |     | 
 1053 |     |     function log(bool p0, uint256 p1, uint256 p2, string memory p3) internal pure {
 1054 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,uint256,uint256,string)", p0, p1, p2, p3));
 1055 |     |     }
 1056 |     | 
 1057 |     |     function log(bool p0, uint256 p1, uint256 p2, bool p3) internal pure {
 1058 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,uint256,uint256,bool)", p0, p1, p2, p3));
 1059 |     |     }
 1060 |     | 
 1061 |     |     function log(bool p0, uint256 p1, uint256 p2, address p3) internal pure {
 1062 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,uint256,uint256,address)", p0, p1, p2, p3));
 1063 |     |     }
 1064 |     | 
 1065 |     |     function log(bool p0, uint256 p1, string memory p2, uint256 p3) internal pure {
 1066 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,uint256,string,uint256)", p0, p1, p2, p3));
 1067 |     |     }
 1068 |     | 
 1069 |     |     function log(bool p0, uint256 p1, string memory p2, string memory p3) internal pure {
 1070 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,uint256,string,string)", p0, p1, p2, p3));
 1071 |     |     }
 1072 |     | 
 1073 |     |     function log(bool p0, uint256 p1, string memory p2, bool p3) internal pure {
 1074 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,uint256,string,bool)", p0, p1, p2, p3));
 1075 |     |     }
 1076 |     | 
 1077 |     |     function log(bool p0, uint256 p1, string memory p2, address p3) internal pure {
 1078 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,uint256,string,address)", p0, p1, p2, p3));
 1079 |     |     }
 1080 |     | 
 1081 |     |     function log(bool p0, uint256 p1, bool p2, uint256 p3) internal pure {
 1082 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,uint256,bool,uint256)", p0, p1, p2, p3));
 1083 |     |     }
 1084 |     | 
 1085 |     |     function log(bool p0, uint256 p1, bool p2, string memory p3) internal pure {
 1086 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,uint256,bool,string)", p0, p1, p2, p3));
 1087 |     |     }
 1088 |     | 
 1089 |     |     function log(bool p0, uint256 p1, bool p2, bool p3) internal pure {
 1090 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,uint256,bool,bool)", p0, p1, p2, p3));
 1091 |     |     }
 1092 |     | 
 1093 |     |     function log(bool p0, uint256 p1, bool p2, address p3) internal pure {
 1094 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,uint256,bool,address)", p0, p1, p2, p3));
 1095 |     |     }
 1096 |     | 
 1097 |     |     function log(bool p0, uint256 p1, address p2, uint256 p3) internal pure {
 1098 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,uint256,address,uint256)", p0, p1, p2, p3));
 1099 |     |     }
 1100 |     | 
 1101 |     |     function log(bool p0, uint256 p1, address p2, string memory p3) internal pure {
 1102 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,uint256,address,string)", p0, p1, p2, p3));
 1103 |     |     }
 1104 |     | 
 1105 |     |     function log(bool p0, uint256 p1, address p2, bool p3) internal pure {
 1106 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,uint256,address,bool)", p0, p1, p2, p3));
 1107 |     |     }
 1108 |     | 
 1109 |     |     function log(bool p0, uint256 p1, address p2, address p3) internal pure {
 1110 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,uint256,address,address)", p0, p1, p2, p3));
 1111 |     |     }
 1112 |     | 
 1113 |     |     function log(bool p0, string memory p1, uint256 p2, uint256 p3) internal pure {
 1114 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,string,uint256,uint256)", p0, p1, p2, p3));
 1115 |     |     }
 1116 |     | 
 1117 |     |     function log(bool p0, string memory p1, uint256 p2, string memory p3) internal pure {
 1118 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,string,uint256,string)", p0, p1, p2, p3));
 1119 |     |     }
 1120 |     | 
 1121 |     |     function log(bool p0, string memory p1, uint256 p2, bool p3) internal pure {
 1122 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,string,uint256,bool)", p0, p1, p2, p3));
 1123 |     |     }
 1124 |     | 
 1125 |     |     function log(bool p0, string memory p1, uint256 p2, address p3) internal pure {
 1126 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,string,uint256,address)", p0, p1, p2, p3));
 1127 |     |     }
 1128 |     | 
 1129 |     |     function log(bool p0, string memory p1, string memory p2, uint256 p3) internal pure {
 1130 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,string,string,uint256)", p0, p1, p2, p3));
 1131 |     |     }
 1132 |     | 
 1133 |     |     function log(bool p0, string memory p1, string memory p2, string memory p3) internal pure {
 1134 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,string,string,string)", p0, p1, p2, p3));
 1135 |     |     }
 1136 |     | 
 1137 |     |     function log(bool p0, string memory p1, string memory p2, bool p3) internal pure {
 1138 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,string,string,bool)", p0, p1, p2, p3));
 1139 |     |     }
 1140 |     | 
 1141 |     |     function log(bool p0, string memory p1, string memory p2, address p3) internal pure {
 1142 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,string,string,address)", p0, p1, p2, p3));
 1143 |     |     }
 1144 |     | 
 1145 |     |     function log(bool p0, string memory p1, bool p2, uint256 p3) internal pure {
 1146 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,string,bool,uint256)", p0, p1, p2, p3));
 1147 |     |     }
 1148 |     | 
 1149 |     |     function log(bool p0, string memory p1, bool p2, string memory p3) internal pure {
 1150 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,string,bool,string)", p0, p1, p2, p3));
 1151 |     |     }
 1152 |     | 
 1153 |     |     function log(bool p0, string memory p1, bool p2, bool p3) internal pure {
 1154 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,string,bool,bool)", p0, p1, p2, p3));
 1155 |     |     }
 1156 |     | 
 1157 |     |     function log(bool p0, string memory p1, bool p2, address p3) internal pure {
 1158 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,string,bool,address)", p0, p1, p2, p3));
 1159 |     |     }
 1160 |     | 
 1161 |     |     function log(bool p0, string memory p1, address p2, uint256 p3) internal pure {
 1162 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,string,address,uint256)", p0, p1, p2, p3));
 1163 |     |     }
 1164 |     | 
 1165 |     |     function log(bool p0, string memory p1, address p2, string memory p3) internal pure {
 1166 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,string,address,string)", p0, p1, p2, p3));
 1167 |     |     }
 1168 |     | 
 1169 |     |     function log(bool p0, string memory p1, address p2, bool p3) internal pure {
 1170 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,string,address,bool)", p0, p1, p2, p3));
 1171 |     |     }
 1172 |     | 
 1173 |     |     function log(bool p0, string memory p1, address p2, address p3) internal pure {
 1174 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,string,address,address)", p0, p1, p2, p3));
 1175 |     |     }
 1176 |     | 
 1177 |     |     function log(bool p0, bool p1, uint256 p2, uint256 p3) internal pure {
 1178 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,bool,uint256,uint256)", p0, p1, p2, p3));
 1179 |     |     }
 1180 |     | 
 1181 |     |     function log(bool p0, bool p1, uint256 p2, string memory p3) internal pure {
 1182 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,bool,uint256,string)", p0, p1, p2, p3));
 1183 |     |     }
 1184 |     | 
 1185 |     |     function log(bool p0, bool p1, uint256 p2, bool p3) internal pure {
 1186 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,bool,uint256,bool)", p0, p1, p2, p3));
 1187 |     |     }
 1188 |     | 
 1189 |     |     function log(bool p0, bool p1, uint256 p2, address p3) internal pure {
 1190 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,bool,uint256,address)", p0, p1, p2, p3));
 1191 |     |     }
 1192 |     | 
 1193 |     |     function log(bool p0, bool p1, string memory p2, uint256 p3) internal pure {
 1194 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,bool,string,uint256)", p0, p1, p2, p3));
 1195 |     |     }
 1196 |     | 
 1197 |     |     function log(bool p0, bool p1, string memory p2, string memory p3) internal pure {
 1198 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,bool,string,string)", p0, p1, p2, p3));
 1199 |     |     }
 1200 |     | 
 1201 |     |     function log(bool p0, bool p1, string memory p2, bool p3) internal pure {
 1202 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,bool,string,bool)", p0, p1, p2, p3));
 1203 |     |     }
 1204 |     | 
 1205 |     |     function log(bool p0, bool p1, string memory p2, address p3) internal pure {
 1206 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,bool,string,address)", p0, p1, p2, p3));
 1207 |     |     }
 1208 |     | 
 1209 |     |     function log(bool p0, bool p1, bool p2, uint256 p3) internal pure {
 1210 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,bool,bool,uint256)", p0, p1, p2, p3));
 1211 |     |     }
 1212 |     | 
 1213 |     |     function log(bool p0, bool p1, bool p2, string memory p3) internal pure {
 1214 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,bool,bool,string)", p0, p1, p2, p3));
 1215 |     |     }
 1216 |     | 
 1217 |     |     function log(bool p0, bool p1, bool p2, bool p3) internal pure {
 1218 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,bool,bool,bool)", p0, p1, p2, p3));
 1219 |     |     }
 1220 |     | 
 1221 |     |     function log(bool p0, bool p1, bool p2, address p3) internal pure {
 1222 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,bool,bool,address)", p0, p1, p2, p3));
 1223 |     |     }
 1224 |     | 
 1225 |     |     function log(bool p0, bool p1, address p2, uint256 p3) internal pure {
 1226 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,bool,address,uint256)", p0, p1, p2, p3));
 1227 |     |     }
 1228 |     | 
 1229 |     |     function log(bool p0, bool p1, address p2, string memory p3) internal pure {
 1230 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,bool,address,string)", p0, p1, p2, p3));
 1231 |     |     }
 1232 |     | 
 1233 |     |     function log(bool p0, bool p1, address p2, bool p3) internal pure {
 1234 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,bool,address,bool)", p0, p1, p2, p3));
 1235 |     |     }
 1236 |     | 
 1237 |     |     function log(bool p0, bool p1, address p2, address p3) internal pure {
 1238 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,bool,address,address)", p0, p1, p2, p3));
 1239 |     |     }
 1240 |     | 
 1241 |     |     function log(bool p0, address p1, uint256 p2, uint256 p3) internal pure {
 1242 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,address,uint256,uint256)", p0, p1, p2, p3));
 1243 |     |     }
 1244 |     | 
 1245 |     |     function log(bool p0, address p1, uint256 p2, string memory p3) internal pure {
 1246 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,address,uint256,string)", p0, p1, p2, p3));
 1247 |     |     }
 1248 |     | 
 1249 |     |     function log(bool p0, address p1, uint256 p2, bool p3) internal pure {
 1250 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,address,uint256,bool)", p0, p1, p2, p3));
 1251 |     |     }
 1252 |     | 
 1253 |     |     function log(bool p0, address p1, uint256 p2, address p3) internal pure {
 1254 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,address,uint256,address)", p0, p1, p2, p3));
 1255 |     |     }
 1256 |     | 
 1257 |     |     function log(bool p0, address p1, string memory p2, uint256 p3) internal pure {
 1258 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,address,string,uint256)", p0, p1, p2, p3));
 1259 |     |     }
 1260 |     | 
 1261 |     |     function log(bool p0, address p1, string memory p2, string memory p3) internal pure {
 1262 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,address,string,string)", p0, p1, p2, p3));
 1263 |     |     }
 1264 |     | 
 1265 |     |     function log(bool p0, address p1, string memory p2, bool p3) internal pure {
 1266 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,address,string,bool)", p0, p1, p2, p3));
 1267 |     |     }
 1268 |     | 
 1269 |     |     function log(bool p0, address p1, string memory p2, address p3) internal pure {
 1270 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,address,string,address)", p0, p1, p2, p3));
 1271 |     |     }
 1272 |     | 
 1273 |     |     function log(bool p0, address p1, bool p2, uint256 p3) internal pure {
 1274 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,address,bool,uint256)", p0, p1, p2, p3));
 1275 |     |     }
 1276 |     | 
 1277 |     |     function log(bool p0, address p1, bool p2, string memory p3) internal pure {
 1278 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,address,bool,string)", p0, p1, p2, p3));
 1279 |     |     }
 1280 |     | 
 1281 |     |     function log(bool p0, address p1, bool p2, bool p3) internal pure {
 1282 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,address,bool,bool)", p0, p1, p2, p3));
 1283 |     |     }
 1284 |     | 
 1285 |     |     function log(bool p0, address p1, bool p2, address p3) internal pure {
 1286 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,address,bool,address)", p0, p1, p2, p3));
 1287 |     |     }
 1288 |     | 
 1289 |     |     function log(bool p0, address p1, address p2, uint256 p3) internal pure {
 1290 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,address,address,uint256)", p0, p1, p2, p3));
 1291 |     |     }
 1292 |     | 
 1293 |     |     function log(bool p0, address p1, address p2, string memory p3) internal pure {
 1294 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,address,address,string)", p0, p1, p2, p3));
 1295 |     |     }
 1296 |     | 
 1297 |     |     function log(bool p0, address p1, address p2, bool p3) internal pure {
 1298 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,address,address,bool)", p0, p1, p2, p3));
 1299 |     |     }
 1300 |     | 
 1301 |     |     function log(bool p0, address p1, address p2, address p3) internal pure {
 1302 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,address,address,address)", p0, p1, p2, p3));
 1303 |     |     }
 1304 |     | 
 1305 |     |     function log(address p0, uint256 p1, uint256 p2, uint256 p3) internal pure {
 1306 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,uint256,uint256,uint256)", p0, p1, p2, p3));
 1307 |     |     }
 1308 |     | 
 1309 |     |     function log(address p0, uint256 p1, uint256 p2, string memory p3) internal pure {
 1310 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,uint256,uint256,string)", p0, p1, p2, p3));
 1311 |     |     }
 1312 |     | 
 1313 |     |     function log(address p0, uint256 p1, uint256 p2, bool p3) internal pure {
 1314 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,uint256,uint256,bool)", p0, p1, p2, p3));
 1315 |     |     }
 1316 |     | 
 1317 |     |     function log(address p0, uint256 p1, uint256 p2, address p3) internal pure {
 1318 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,uint256,uint256,address)", p0, p1, p2, p3));
 1319 |     |     }
 1320 |     | 
 1321 |     |     function log(address p0, uint256 p1, string memory p2, uint256 p3) internal pure {
 1322 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,uint256,string,uint256)", p0, p1, p2, p3));
 1323 |     |     }
 1324 |     | 
 1325 |     |     function log(address p0, uint256 p1, string memory p2, string memory p3) internal pure {
 1326 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,uint256,string,string)", p0, p1, p2, p3));
 1327 |     |     }
 1328 |     | 
 1329 |     |     function log(address p0, uint256 p1, string memory p2, bool p3) internal pure {
 1330 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,uint256,string,bool)", p0, p1, p2, p3));
 1331 |     |     }
 1332 |     | 
 1333 |     |     function log(address p0, uint256 p1, string memory p2, address p3) internal pure {
 1334 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,uint256,string,address)", p0, p1, p2, p3));
 1335 |     |     }
 1336 |     | 
 1337 |     |     function log(address p0, uint256 p1, bool p2, uint256 p3) internal pure {
 1338 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,uint256,bool,uint256)", p0, p1, p2, p3));
 1339 |     |     }
 1340 |     | 
 1341 |     |     function log(address p0, uint256 p1, bool p2, string memory p3) internal pure {
 1342 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,uint256,bool,string)", p0, p1, p2, p3));
 1343 |     |     }
 1344 |     | 
 1345 |     |     function log(address p0, uint256 p1, bool p2, bool p3) internal pure {
 1346 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,uint256,bool,bool)", p0, p1, p2, p3));
 1347 |     |     }
 1348 |     | 
 1349 |     |     function log(address p0, uint256 p1, bool p2, address p3) internal pure {
 1350 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,uint256,bool,address)", p0, p1, p2, p3));
 1351 |     |     }
 1352 |     | 
 1353 |     |     function log(address p0, uint256 p1, address p2, uint256 p3) internal pure {
 1354 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,uint256,address,uint256)", p0, p1, p2, p3));
 1355 |     |     }
 1356 |     | 
 1357 |     |     function log(address p0, uint256 p1, address p2, string memory p3) internal pure {
 1358 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,uint256,address,string)", p0, p1, p2, p3));
 1359 |     |     }
 1360 |     | 
 1361 |     |     function log(address p0, uint256 p1, address p2, bool p3) internal pure {
 1362 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,uint256,address,bool)", p0, p1, p2, p3));
 1363 |     |     }
 1364 |     | 
 1365 |     |     function log(address p0, uint256 p1, address p2, address p3) internal pure {
 1366 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,uint256,address,address)", p0, p1, p2, p3));
 1367 |     |     }
 1368 |     | 
 1369 |     |     function log(address p0, string memory p1, uint256 p2, uint256 p3) internal pure {
 1370 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,string,uint256,uint256)", p0, p1, p2, p3));
 1371 |     |     }
 1372 |     | 
 1373 |     |     function log(address p0, string memory p1, uint256 p2, string memory p3) internal pure {
 1374 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,string,uint256,string)", p0, p1, p2, p3));
 1375 |     |     }
 1376 |     | 
 1377 |     |     function log(address p0, string memory p1, uint256 p2, bool p3) internal pure {
 1378 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,string,uint256,bool)", p0, p1, p2, p3));
 1379 |     |     }
 1380 |     | 
 1381 |     |     function log(address p0, string memory p1, uint256 p2, address p3) internal pure {
 1382 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,string,uint256,address)", p0, p1, p2, p3));
 1383 |     |     }
 1384 |     | 
 1385 |     |     function log(address p0, string memory p1, string memory p2, uint256 p3) internal pure {
 1386 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,string,string,uint256)", p0, p1, p2, p3));
 1387 |     |     }
 1388 |     | 
 1389 |     |     function log(address p0, string memory p1, string memory p2, string memory p3) internal pure {
 1390 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,string,string,string)", p0, p1, p2, p3));
 1391 |     |     }
 1392 |     | 
 1393 |     |     function log(address p0, string memory p1, string memory p2, bool p3) internal pure {
 1394 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,string,string,bool)", p0, p1, p2, p3));
 1395 |     |     }
 1396 |     | 
 1397 |     |     function log(address p0, string memory p1, string memory p2, address p3) internal pure {
 1398 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,string,string,address)", p0, p1, p2, p3));
 1399 |     |     }
 1400 |     | 
 1401 |     |     function log(address p0, string memory p1, bool p2, uint256 p3) internal pure {
 1402 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,string,bool,uint256)", p0, p1, p2, p3));
 1403 |     |     }
 1404 |     | 
 1405 |     |     function log(address p0, string memory p1, bool p2, string memory p3) internal pure {
 1406 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,string,bool,string)", p0, p1, p2, p3));
 1407 |     |     }
 1408 |     | 
 1409 |     |     function log(address p0, string memory p1, bool p2, bool p3) internal pure {
 1410 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,string,bool,bool)", p0, p1, p2, p3));
 1411 |     |     }
 1412 |     | 
 1413 |     |     function log(address p0, string memory p1, bool p2, address p3) internal pure {
 1414 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,string,bool,address)", p0, p1, p2, p3));
 1415 |     |     }
 1416 |     | 
 1417 |     |     function log(address p0, string memory p1, address p2, uint256 p3) internal pure {
 1418 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,string,address,uint256)", p0, p1, p2, p3));
 1419 |     |     }
 1420 |     | 
 1421 |     |     function log(address p0, string memory p1, address p2, string memory p3) internal pure {
 1422 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,string,address,string)", p0, p1, p2, p3));
 1423 |     |     }
 1424 |     | 
 1425 |     |     function log(address p0, string memory p1, address p2, bool p3) internal pure {
 1426 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,string,address,bool)", p0, p1, p2, p3));
 1427 |     |     }
 1428 |     | 
 1429 |     |     function log(address p0, string memory p1, address p2, address p3) internal pure {
 1430 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,string,address,address)", p0, p1, p2, p3));
 1431 |     |     }
 1432 |     | 
 1433 |     |     function log(address p0, bool p1, uint256 p2, uint256 p3) internal pure {
 1434 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,bool,uint256,uint256)", p0, p1, p2, p3));
 1435 |     |     }
 1436 |     | 
 1437 |     |     function log(address p0, bool p1, uint256 p2, string memory p3) internal pure {
 1438 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,bool,uint256,string)", p0, p1, p2, p3));
 1439 |     |     }
 1440 |     | 
 1441 |     |     function log(address p0, bool p1, uint256 p2, bool p3) internal pure {
 1442 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,bool,uint256,bool)", p0, p1, p2, p3));
 1443 |     |     }
 1444 |     | 
 1445 |     |     function log(address p0, bool p1, uint256 p2, address p3) internal pure {
 1446 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,bool,uint256,address)", p0, p1, p2, p3));
 1447 |     |     }
 1448 |     | 
 1449 |     |     function log(address p0, bool p1, string memory p2, uint256 p3) internal pure {
 1450 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,bool,string,uint256)", p0, p1, p2, p3));
 1451 |     |     }
 1452 |     | 
 1453 |     |     function log(address p0, bool p1, string memory p2, string memory p3) internal pure {
 1454 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,bool,string,string)", p0, p1, p2, p3));
 1455 |     |     }
 1456 |     | 
 1457 |     |     function log(address p0, bool p1, string memory p2, bool p3) internal pure {
 1458 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,bool,string,bool)", p0, p1, p2, p3));
 1459 |     |     }
 1460 |     | 
 1461 |     |     function log(address p0, bool p1, string memory p2, address p3) internal pure {
 1462 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,bool,string,address)", p0, p1, p2, p3));
 1463 |     |     }
 1464 |     | 
 1465 |     |     function log(address p0, bool p1, bool p2, uint256 p3) internal pure {
 1466 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,bool,bool,uint256)", p0, p1, p2, p3));
 1467 |     |     }
 1468 |     | 
 1469 |     |     function log(address p0, bool p1, bool p2, string memory p3) internal pure {
 1470 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,bool,bool,string)", p0, p1, p2, p3));
 1471 |     |     }
 1472 |     | 
 1473 |     |     function log(address p0, bool p1, bool p2, bool p3) internal pure {
 1474 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,bool,bool,bool)", p0, p1, p2, p3));
 1475 |     |     }
 1476 |     | 
 1477 |     |     function log(address p0, bool p1, bool p2, address p3) internal pure {
 1478 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,bool,bool,address)", p0, p1, p2, p3));
 1479 |     |     }
 1480 |     | 
 1481 |     |     function log(address p0, bool p1, address p2, uint256 p3) internal pure {
 1482 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,bool,address,uint256)", p0, p1, p2, p3));
 1483 |     |     }
 1484 |     | 
 1485 |     |     function log(address p0, bool p1, address p2, string memory p3) internal pure {
 1486 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,bool,address,string)", p0, p1, p2, p3));
 1487 |     |     }
 1488 |     | 
 1489 |     |     function log(address p0, bool p1, address p2, bool p3) internal pure {
 1490 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,bool,address,bool)", p0, p1, p2, p3));
 1491 |     |     }
 1492 |     | 
 1493 |     |     function log(address p0, bool p1, address p2, address p3) internal pure {
 1494 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,bool,address,address)", p0, p1, p2, p3));
 1495 |     |     }
 1496 |     | 
 1497 |     |     function log(address p0, address p1, uint256 p2, uint256 p3) internal pure {
 1498 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,address,uint256,uint256)", p0, p1, p2, p3));
 1499 |     |     }
 1500 |     | 
 1501 |     |     function log(address p0, address p1, uint256 p2, string memory p3) internal pure {
 1502 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,address,uint256,string)", p0, p1, p2, p3));
 1503 |     |     }
 1504 |     | 
 1505 |     |     function log(address p0, address p1, uint256 p2, bool p3) internal pure {
 1506 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,address,uint256,bool)", p0, p1, p2, p3));
 1507 |     |     }
 1508 |     | 
 1509 |     |     function log(address p0, address p1, uint256 p2, address p3) internal pure {
 1510 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,address,uint256,address)", p0, p1, p2, p3));
 1511 |     |     }
 1512 |     | 
 1513 |     |     function log(address p0, address p1, string memory p2, uint256 p3) internal pure {
 1514 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,address,string,uint256)", p0, p1, p2, p3));
 1515 |     |     }
 1516 |     | 
 1517 |     |     function log(address p0, address p1, string memory p2, string memory p3) internal pure {
 1518 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,address,string,string)", p0, p1, p2, p3));
 1519 |     |     }
 1520 |     | 
 1521 |     |     function log(address p0, address p1, string memory p2, bool p3) internal pure {
 1522 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,address,string,bool)", p0, p1, p2, p3));
 1523 |     |     }
 1524 |     | 
 1525 |     |     function log(address p0, address p1, string memory p2, address p3) internal pure {
 1526 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,address,string,address)", p0, p1, p2, p3));
 1527 |     |     }
 1528 |     | 
 1529 |     |     function log(address p0, address p1, bool p2, uint256 p3) internal pure {
 1530 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,address,bool,uint256)", p0, p1, p2, p3));
 1531 |     |     }
 1532 |     | 
 1533 |     |     function log(address p0, address p1, bool p2, string memory p3) internal pure {
 1534 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,address,bool,string)", p0, p1, p2, p3));
 1535 |     |     }
 1536 |     | 
 1537 |     |     function log(address p0, address p1, bool p2, bool p3) internal pure {
 1538 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,address,bool,bool)", p0, p1, p2, p3));
 1539 |     |     }
 1540 |     | 
 1541 |     |     function log(address p0, address p1, bool p2, address p3) internal pure {
 1542 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,address,bool,address)", p0, p1, p2, p3));
 1543 |     |     }
 1544 |     | 
 1545 |     |     function log(address p0, address p1, address p2, uint256 p3) internal pure {
 1546 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,address,address,uint256)", p0, p1, p2, p3));
 1547 |     |     }
 1548 |     | 
 1549 |     |     function log(address p0, address p1, address p2, string memory p3) internal pure {
 1550 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,address,address,string)", p0, p1, p2, p3));
 1551 |     |     }
 1552 |     | 
 1553 |     |     function log(address p0, address p1, address p2, bool p3) internal pure {
 1554 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,address,address,bool)", p0, p1, p2, p3));
 1555 |     |     }
 1556 |     | 
 1557 |     |     function log(address p0, address p1, address p2, address p3) internal pure {
 1558 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,address,address,address)", p0, p1, p2, p3));
 1559 |     |     }
 1560 |     | }
 1561 |     | 

/home/phantom/Documents/azemora/azemora-contracts/lib/forge-std/src/console2.sol
 1 |     | // SPDX-License-Identifier: MIT
 2 |     | pragma solidity >=0.4.22 <0.9.0;
 3 |     | 
 4 |     | import {console as console2} from "./console.sol";
 5 |     | 

/home/phantom/Documents/azemora/azemora-contracts/lib/forge-std/src/interfaces/IMulticall3.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | pragma solidity >=0.6.2 <0.9.0;
  3 |     | 
  4 |     | pragma experimental ABIEncoderV2;
  5 |     | 
  6 |     | interface IMulticall3 {
  7 |     |     struct Call {
  8 |     |         address target;
  9 |     |         bytes callData;
 10 |     |     }
 11 |     | 
 12 |     |     struct Call3 {
 13 |     |         address target;
 14 |     |         bool allowFailure;
 15 |     |         bytes callData;
 16 |     |     }
 17 |     | 
 18 |     |     struct Call3Value {
 19 |     |         address target;
 20 |     |         bool allowFailure;
 21 |     |         uint256 value;
 22 |     |         bytes callData;
 23 |     |     }
 24 |     | 
 25 |     |     struct Result {
 26 |     |         bool success;
 27 |     |         bytes returnData;
 28 |     |     }
 29 |     | 
 30 |     |     function aggregate(Call[] calldata calls)
 31 |     |         external
 32 |     |         payable
 33 |     |         returns (uint256 blockNumber, bytes[] memory returnData);
 34 |     | 
 35 |     |     function aggregate3(Call3[] calldata calls) external payable returns (Result[] memory returnData);
 36 |     | 
 37 |     |     function aggregate3Value(Call3Value[] calldata calls) external payable returns (Result[] memory returnData);
 38 |     | 
 39 |     |     function blockAndAggregate(Call[] calldata calls)
 40 |     |         external
 41 |     |         payable
 42 |     |         returns (uint256 blockNumber, bytes32 blockHash, Result[] memory returnData);
 43 |     | 
 44 |     |     function getBasefee() external view returns (uint256 basefee);
 45 |     | 
 46 |     |     function getBlockHash(uint256 blockNumber) external view returns (bytes32 blockHash);
 47 |     | 
 48 |     |     function getBlockNumber() external view returns (uint256 blockNumber);
 49 |     | 
 50 |     |     function getChainId() external view returns (uint256 chainid);
 51 |     | 
 52 |     |     function getCurrentBlockCoinbase() external view returns (address coinbase);
 53 |     | 
 54 |     |     function getCurrentBlockDifficulty() external view returns (uint256 difficulty);
 55 |     | 
 56 |     |     function getCurrentBlockGasLimit() external view returns (uint256 gaslimit);
 57 |     | 
 58 |     |     function getCurrentBlockTimestamp() external view returns (uint256 timestamp);
 59 |     | 
 60 |     |     function getEthBalance(address addr) external view returns (uint256 balance);
 61 |     | 
 62 |     |     function getLastBlockHash() external view returns (bytes32 blockHash);
 63 |     | 
 64 |     |     function tryAggregate(bool requireSuccess, Call[] calldata calls)
 65 |     |         external
 66 |     |         payable
 67 |     |         returns (Result[] memory returnData);
 68 |     | 
 69 |     |     function tryBlockAndAggregate(bool requireSuccess, Call[] calldata calls)
 70 |     |         external
 71 |     |         payable
 72 |     |         returns (uint256 blockNumber, bytes32 blockHash, Result[] memory returnData);
 73 |     | }
 74 |     | 

/home/phantom/Documents/azemora/azemora-contracts/lib/forge-std/src/safeconsole.sol
     1 |     | // SPDX-License-Identifier: MIT
     2 |     | pragma solidity >=0.6.2 <0.9.0;
     3 |     | 
     4 |     | /// @author philogy <https://github.com/philogy>
     5 |     | /// @dev Code generated automatically by script.
     6 |     | library safeconsole {
     7 |     |     uint256 constant CONSOLE_ADDR = 0x000000000000000000000000000000000000000000636F6e736F6c652e6c6f67;
     8 |     | 
     9 |     |     // Credit to [0age](https://twitter.com/z0age/status/1654922202930888704) and [0xdapper](https://github.com/foundry-rs/forge-std/pull/374)
    10 |     |     // for the view-to-pure log trick.
    11 |     |     function _sendLogPayload(uint256 offset, uint256 size) private pure {
    12 |     |         function(uint256, uint256) internal view fnIn = _sendLogPayloadView;
    13 |     |         function(uint256, uint256) internal pure pureSendLogPayload;
    14 |     |         /// @solidity memory-safe-assembly
    15 |     |         assembly {
    16 |     |             pureSendLogPayload := fnIn
    17 |     |         }
    18 |     |         pureSendLogPayload(offset, size);
    19 |     |     }
    20 |     | 
    21 |     |     function _sendLogPayloadView(uint256 offset, uint256 size) private view {
    22 |     |         /// @solidity memory-safe-assembly
    23 |     |         assembly {
    24 |     |             pop(staticcall(gas(), CONSOLE_ADDR, offset, size, 0x0, 0x0))
    25 |     |         }
    26 |     |     }
    27 |     | 
    28 |     |     function _memcopy(uint256 fromOffset, uint256 toOffset, uint256 length) private pure {
    29 |     |         function(uint256, uint256, uint256) internal view fnIn = _memcopyView;
    30 |     |         function(uint256, uint256, uint256) internal pure pureMemcopy;
    31 |     |         /// @solidity memory-safe-assembly
    32 |     |         assembly {
    33 |     |             pureMemcopy := fnIn
    34 |     |         }
    35 |     |         pureMemcopy(fromOffset, toOffset, length);
    36 |     |     }
    37 |     | 
    38 |     |     function _memcopyView(uint256 fromOffset, uint256 toOffset, uint256 length) private view {
    39 |     |         /// @solidity memory-safe-assembly
    40 |     |         assembly {
    41 |     |             pop(staticcall(gas(), 0x4, fromOffset, length, toOffset, length))
    42 |     |         }
    43 |     |     }
    44 |     | 
    45 |     |     function logMemory(uint256 offset, uint256 length) internal pure {
    46 |     |         if (offset >= 0x60) {
    47 |     |             // Sufficient memory before slice to prepare call header.
    48 |     |             bytes32 m0;
    49 |     |             bytes32 m1;
    50 |     |             bytes32 m2;
    51 |     |             /// @solidity memory-safe-assembly
    52 |     |             assembly {
    53 |     |                 m0 := mload(sub(offset, 0x60))
    54 |     |                 m1 := mload(sub(offset, 0x40))
    55 |     |                 m2 := mload(sub(offset, 0x20))
    56 |     |                 // Selector of `log(bytes)`.
    57 |     |                 mstore(sub(offset, 0x60), 0x0be77f56)
    58 |     |                 mstore(sub(offset, 0x40), 0x20)
    59 |     |                 mstore(sub(offset, 0x20), length)
    60 |     |             }
    61 |     |             _sendLogPayload(offset - 0x44, length + 0x44);
    62 |     |             /// @solidity memory-safe-assembly
    63 |     |             assembly {
    64 |     |                 mstore(sub(offset, 0x60), m0)
    65 |     |                 mstore(sub(offset, 0x40), m1)
    66 |     |                 mstore(sub(offset, 0x20), m2)
    67 |     |             }
    68 |     |         } else {
    69 |     |             // Insufficient space, so copy slice forward, add header and reverse.
    70 |     |             bytes32 m0;
    71 |     |             bytes32 m1;
    72 |     |             bytes32 m2;
    73 |     |             uint256 endOffset = offset + length;
    74 |     |             /// @solidity memory-safe-assembly
    75 |     |             assembly {
    76 |     |                 m0 := mload(add(endOffset, 0x00))
    77 |     |                 m1 := mload(add(endOffset, 0x20))
    78 |     |                 m2 := mload(add(endOffset, 0x40))
    79 |     |             }
    80 |     |             _memcopy(offset, offset + 0x60, length);
    81 |     |             /// @solidity memory-safe-assembly
    82 |     |             assembly {
    83 |     |                 // Selector of `log(bytes)`.
    84 |     |                 mstore(add(offset, 0x00), 0x0be77f56)
    85 |     |                 mstore(add(offset, 0x20), 0x20)
    86 |     |                 mstore(add(offset, 0x40), length)
    87 |     |             }
    88 |     |             _sendLogPayload(offset + 0x1c, length + 0x44);
    89 |     |             _memcopy(offset + 0x60, offset, length);
    90 |     |             /// @solidity memory-safe-assembly
    91 |     |             assembly {
    92 |     |                 mstore(add(endOffset, 0x00), m0)
    93 |     |                 mstore(add(endOffset, 0x20), m1)
    94 |     |                 mstore(add(endOffset, 0x40), m2)
    95 |     |             }
    96 |     |         }
    97 |     |     }
    98 |     | 
    99 |     |     function log(address p0) internal pure {
   100 |     |         bytes32 m0;
   101 |     |         bytes32 m1;
   102 |     |         /// @solidity memory-safe-assembly
   103 |     |         assembly {
   104 |     |             m0 := mload(0x00)
   105 |     |             m1 := mload(0x20)
   106 |     |             // Selector of `log(address)`.
   107 |     |             mstore(0x00, 0x2c2ecbc2)
   108 |     |             mstore(0x20, p0)
   109 |     |         }
   110 |     |         _sendLogPayload(0x1c, 0x24);
   111 |     |         /// @solidity memory-safe-assembly
   112 |     |         assembly {
   113 |     |             mstore(0x00, m0)
   114 |     |             mstore(0x20, m1)
   115 |     |         }
   116 |     |     }
   117 |     | 
   118 |     |     function log(bool p0) internal pure {
   119 |     |         bytes32 m0;
   120 |     |         bytes32 m1;
   121 |     |         /// @solidity memory-safe-assembly
   122 |     |         assembly {
   123 |     |             m0 := mload(0x00)
   124 |     |             m1 := mload(0x20)
   125 |     |             // Selector of `log(bool)`.
   126 |     |             mstore(0x00, 0x32458eed)
   127 |     |             mstore(0x20, p0)
   128 |     |         }
   129 |     |         _sendLogPayload(0x1c, 0x24);
   130 |     |         /// @solidity memory-safe-assembly
   131 |     |         assembly {
   132 |     |             mstore(0x00, m0)
   133 |     |             mstore(0x20, m1)
   134 |     |         }
   135 |     |     }
   136 |     | 
   137 |     |     function log(uint256 p0) internal pure {
   138 |     |         bytes32 m0;
   139 |     |         bytes32 m1;
   140 |     |         /// @solidity memory-safe-assembly
   141 |     |         assembly {
   142 |     |             m0 := mload(0x00)
   143 |     |             m1 := mload(0x20)
   144 |     |             // Selector of `log(uint256)`.
   145 |     |             mstore(0x00, 0xf82c50f1)
   146 |     |             mstore(0x20, p0)
   147 |     |         }
   148 |     |         _sendLogPayload(0x1c, 0x24);
   149 |     |         /// @solidity memory-safe-assembly
   150 |     |         assembly {
   151 |     |             mstore(0x00, m0)
   152 |     |             mstore(0x20, m1)
   153 |     |         }
   154 |     |     }
   155 |     | 
   156 |     |     function log(bytes32 p0) internal pure {
   157 |     |         bytes32 m0;
   158 |     |         bytes32 m1;
   159 |     |         bytes32 m2;
   160 |     |         bytes32 m3;
   161 |     |         /// @solidity memory-safe-assembly
   162 |     |         assembly {
   163 |     |             function writeString(pos, w) {
   164 |     |                 let length := 0
   165 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
   166 |     |                 mstore(pos, length)
   167 |     |                 let shift := sub(256, shl(3, length))
   168 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
   169 |     |             }
   170 |     |             m0 := mload(0x00)
   171 |     |             m1 := mload(0x20)
   172 |     |             m2 := mload(0x40)
   173 |     |             m3 := mload(0x60)
   174 |     |             // Selector of `log(string)`.
   175 |     |             mstore(0x00, 0x41304fac)
   176 |     |             mstore(0x20, 0x20)
   177 |     |             writeString(0x40, p0)
   178 |     |         }
   179 |     |         _sendLogPayload(0x1c, 0x64);
   180 |     |         /// @solidity memory-safe-assembly
   181 |     |         assembly {
   182 |     |             mstore(0x00, m0)
   183 |     |             mstore(0x20, m1)
   184 |     |             mstore(0x40, m2)
   185 |     |             mstore(0x60, m3)
   186 |     |         }
   187 |     |     }
   188 |     | 
   189 |     |     function log(address p0, address p1) internal pure {
   190 |     |         bytes32 m0;
   191 |     |         bytes32 m1;
   192 |     |         bytes32 m2;
   193 |     |         /// @solidity memory-safe-assembly
   194 |     |         assembly {
   195 |     |             m0 := mload(0x00)
   196 |     |             m1 := mload(0x20)
   197 |     |             m2 := mload(0x40)
   198 |     |             // Selector of `log(address,address)`.
   199 |     |             mstore(0x00, 0xdaf0d4aa)
   200 |     |             mstore(0x20, p0)
   201 |     |             mstore(0x40, p1)
   202 |     |         }
   203 |     |         _sendLogPayload(0x1c, 0x44);
   204 |     |         /// @solidity memory-safe-assembly
   205 |     |         assembly {
   206 |     |             mstore(0x00, m0)
   207 |     |             mstore(0x20, m1)
   208 |     |             mstore(0x40, m2)
   209 |     |         }
   210 |     |     }
   211 |     | 
   212 |     |     function log(address p0, bool p1) internal pure {
   213 |     |         bytes32 m0;
   214 |     |         bytes32 m1;
   215 |     |         bytes32 m2;
   216 |     |         /// @solidity memory-safe-assembly
   217 |     |         assembly {
   218 |     |             m0 := mload(0x00)
   219 |     |             m1 := mload(0x20)
   220 |     |             m2 := mload(0x40)
   221 |     |             // Selector of `log(address,bool)`.
   222 |     |             mstore(0x00, 0x75b605d3)
   223 |     |             mstore(0x20, p0)
   224 |     |             mstore(0x40, p1)
   225 |     |         }
   226 |     |         _sendLogPayload(0x1c, 0x44);
   227 |     |         /// @solidity memory-safe-assembly
   228 |     |         assembly {
   229 |     |             mstore(0x00, m0)
   230 |     |             mstore(0x20, m1)
   231 |     |             mstore(0x40, m2)
   232 |     |         }
   233 |     |     }
   234 |     | 
   235 |     |     function log(address p0, uint256 p1) internal pure {
   236 |     |         bytes32 m0;
   237 |     |         bytes32 m1;
   238 |     |         bytes32 m2;
   239 |     |         /// @solidity memory-safe-assembly
   240 |     |         assembly {
   241 |     |             m0 := mload(0x00)
   242 |     |             m1 := mload(0x20)
   243 |     |             m2 := mload(0x40)
   244 |     |             // Selector of `log(address,uint256)`.
   245 |     |             mstore(0x00, 0x8309e8a8)
   246 |     |             mstore(0x20, p0)
   247 |     |             mstore(0x40, p1)
   248 |     |         }
   249 |     |         _sendLogPayload(0x1c, 0x44);
   250 |     |         /// @solidity memory-safe-assembly
   251 |     |         assembly {
   252 |     |             mstore(0x00, m0)
   253 |     |             mstore(0x20, m1)
   254 |     |             mstore(0x40, m2)
   255 |     |         }
   256 |     |     }
   257 |     | 
   258 |     |     function log(address p0, bytes32 p1) internal pure {
   259 |     |         bytes32 m0;
   260 |     |         bytes32 m1;
   261 |     |         bytes32 m2;
   262 |     |         bytes32 m3;
   263 |     |         bytes32 m4;
   264 |     |         /// @solidity memory-safe-assembly
   265 |     |         assembly {
   266 |     |             function writeString(pos, w) {
   267 |     |                 let length := 0
   268 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
   269 |     |                 mstore(pos, length)
   270 |     |                 let shift := sub(256, shl(3, length))
   271 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
   272 |     |             }
   273 |     |             m0 := mload(0x00)
   274 |     |             m1 := mload(0x20)
   275 |     |             m2 := mload(0x40)
   276 |     |             m3 := mload(0x60)
   277 |     |             m4 := mload(0x80)
   278 |     |             // Selector of `log(address,string)`.
   279 |     |             mstore(0x00, 0x759f86bb)
   280 |     |             mstore(0x20, p0)
   281 |     |             mstore(0x40, 0x40)
   282 |     |             writeString(0x60, p1)
   283 |     |         }
   284 |     |         _sendLogPayload(0x1c, 0x84);
   285 |     |         /// @solidity memory-safe-assembly
   286 |     |         assembly {
   287 |     |             mstore(0x00, m0)
   288 |     |             mstore(0x20, m1)
   289 |     |             mstore(0x40, m2)
   290 |     |             mstore(0x60, m3)
   291 |     |             mstore(0x80, m4)
   292 |     |         }
   293 |     |     }
   294 |     | 
   295 |     |     function log(bool p0, address p1) internal pure {
   296 |     |         bytes32 m0;
   297 |     |         bytes32 m1;
   298 |     |         bytes32 m2;
   299 |     |         /// @solidity memory-safe-assembly
   300 |     |         assembly {
   301 |     |             m0 := mload(0x00)
   302 |     |             m1 := mload(0x20)
   303 |     |             m2 := mload(0x40)
   304 |     |             // Selector of `log(bool,address)`.
   305 |     |             mstore(0x00, 0x853c4849)
   306 |     |             mstore(0x20, p0)
   307 |     |             mstore(0x40, p1)
   308 |     |         }
   309 |     |         _sendLogPayload(0x1c, 0x44);
   310 |     |         /// @solidity memory-safe-assembly
   311 |     |         assembly {
   312 |     |             mstore(0x00, m0)
   313 |     |             mstore(0x20, m1)
   314 |     |             mstore(0x40, m2)
   315 |     |         }
   316 |     |     }
   317 |     | 
   318 |     |     function log(bool p0, bool p1) internal pure {
   319 |     |         bytes32 m0;
   320 |     |         bytes32 m1;
   321 |     |         bytes32 m2;
   322 |     |         /// @solidity memory-safe-assembly
   323 |     |         assembly {
   324 |     |             m0 := mload(0x00)
   325 |     |             m1 := mload(0x20)
   326 |     |             m2 := mload(0x40)
   327 |     |             // Selector of `log(bool,bool)`.
   328 |     |             mstore(0x00, 0x2a110e83)
   329 |     |             mstore(0x20, p0)
   330 |     |             mstore(0x40, p1)
   331 |     |         }
   332 |     |         _sendLogPayload(0x1c, 0x44);
   333 |     |         /// @solidity memory-safe-assembly
   334 |     |         assembly {
   335 |     |             mstore(0x00, m0)
   336 |     |             mstore(0x20, m1)
   337 |     |             mstore(0x40, m2)
   338 |     |         }
   339 |     |     }
   340 |     | 
   341 |     |     function log(bool p0, uint256 p1) internal pure {
   342 |     |         bytes32 m0;
   343 |     |         bytes32 m1;
   344 |     |         bytes32 m2;
   345 |     |         /// @solidity memory-safe-assembly
   346 |     |         assembly {
   347 |     |             m0 := mload(0x00)
   348 |     |             m1 := mload(0x20)
   349 |     |             m2 := mload(0x40)
   350 |     |             // Selector of `log(bool,uint256)`.
   351 |     |             mstore(0x00, 0x399174d3)
   352 |     |             mstore(0x20, p0)
   353 |     |             mstore(0x40, p1)
   354 |     |         }
   355 |     |         _sendLogPayload(0x1c, 0x44);
   356 |     |         /// @solidity memory-safe-assembly
   357 |     |         assembly {
   358 |     |             mstore(0x00, m0)
   359 |     |             mstore(0x20, m1)
   360 |     |             mstore(0x40, m2)
   361 |     |         }
   362 |     |     }
   363 |     | 
   364 |     |     function log(bool p0, bytes32 p1) internal pure {
   365 |     |         bytes32 m0;
   366 |     |         bytes32 m1;
   367 |     |         bytes32 m2;
   368 |     |         bytes32 m3;
   369 |     |         bytes32 m4;
   370 |     |         /// @solidity memory-safe-assembly
   371 |     |         assembly {
   372 |     |             function writeString(pos, w) {
   373 |     |                 let length := 0
   374 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
   375 |     |                 mstore(pos, length)
   376 |     |                 let shift := sub(256, shl(3, length))
   377 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
   378 |     |             }
   379 |     |             m0 := mload(0x00)
   380 |     |             m1 := mload(0x20)
   381 |     |             m2 := mload(0x40)
   382 |     |             m3 := mload(0x60)
   383 |     |             m4 := mload(0x80)
   384 |     |             // Selector of `log(bool,string)`.
   385 |     |             mstore(0x00, 0x8feac525)
   386 |     |             mstore(0x20, p0)
   387 |     |             mstore(0x40, 0x40)
   388 |     |             writeString(0x60, p1)
   389 |     |         }
   390 |     |         _sendLogPayload(0x1c, 0x84);
   391 |     |         /// @solidity memory-safe-assembly
   392 |     |         assembly {
   393 |     |             mstore(0x00, m0)
   394 |     |             mstore(0x20, m1)
   395 |     |             mstore(0x40, m2)
   396 |     |             mstore(0x60, m3)
   397 |     |             mstore(0x80, m4)
   398 |     |         }
   399 |     |     }
   400 |     | 
   401 |     |     function log(uint256 p0, address p1) internal pure {
   402 |     |         bytes32 m0;
   403 |     |         bytes32 m1;
   404 |     |         bytes32 m2;
   405 |     |         /// @solidity memory-safe-assembly
   406 |     |         assembly {
   407 |     |             m0 := mload(0x00)
   408 |     |             m1 := mload(0x20)
   409 |     |             m2 := mload(0x40)
   410 |     |             // Selector of `log(uint256,address)`.
   411 |     |             mstore(0x00, 0x69276c86)
   412 |     |             mstore(0x20, p0)
   413 |     |             mstore(0x40, p1)
   414 |     |         }
   415 |     |         _sendLogPayload(0x1c, 0x44);
   416 |     |         /// @solidity memory-safe-assembly
   417 |     |         assembly {
   418 |     |             mstore(0x00, m0)
   419 |     |             mstore(0x20, m1)
   420 |     |             mstore(0x40, m2)
   421 |     |         }
   422 |     |     }
   423 |     | 
   424 |     |     function log(uint256 p0, bool p1) internal pure {
   425 |     |         bytes32 m0;
   426 |     |         bytes32 m1;
   427 |     |         bytes32 m2;
   428 |     |         /// @solidity memory-safe-assembly
   429 |     |         assembly {
   430 |     |             m0 := mload(0x00)
   431 |     |             m1 := mload(0x20)
   432 |     |             m2 := mload(0x40)
   433 |     |             // Selector of `log(uint256,bool)`.
   434 |     |             mstore(0x00, 0x1c9d7eb3)
   435 |     |             mstore(0x20, p0)
   436 |     |             mstore(0x40, p1)
   437 |     |         }
   438 |     |         _sendLogPayload(0x1c, 0x44);
   439 |     |         /// @solidity memory-safe-assembly
   440 |     |         assembly {
   441 |     |             mstore(0x00, m0)
   442 |     |             mstore(0x20, m1)
   443 |     |             mstore(0x40, m2)
   444 |     |         }
   445 |     |     }
   446 |     | 
   447 |     |     function log(uint256 p0, uint256 p1) internal pure {
   448 |     |         bytes32 m0;
   449 |     |         bytes32 m1;
   450 |     |         bytes32 m2;
   451 |     |         /// @solidity memory-safe-assembly
   452 |     |         assembly {
   453 |     |             m0 := mload(0x00)
   454 |     |             m1 := mload(0x20)
   455 |     |             m2 := mload(0x40)
   456 |     |             // Selector of `log(uint256,uint256)`.
   457 |     |             mstore(0x00, 0xf666715a)
   458 |     |             mstore(0x20, p0)
   459 |     |             mstore(0x40, p1)
   460 |     |         }
   461 |     |         _sendLogPayload(0x1c, 0x44);
   462 |     |         /// @solidity memory-safe-assembly
   463 |     |         assembly {
   464 |     |             mstore(0x00, m0)
   465 |     |             mstore(0x20, m1)
   466 |     |             mstore(0x40, m2)
   467 |     |         }
   468 |     |     }
   469 |     | 
   470 |     |     function log(uint256 p0, bytes32 p1) internal pure {
   471 |     |         bytes32 m0;
   472 |     |         bytes32 m1;
   473 |     |         bytes32 m2;
   474 |     |         bytes32 m3;
   475 |     |         bytes32 m4;
   476 |     |         /// @solidity memory-safe-assembly
   477 |     |         assembly {
   478 |     |             function writeString(pos, w) {
   479 |     |                 let length := 0
   480 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
   481 |     |                 mstore(pos, length)
   482 |     |                 let shift := sub(256, shl(3, length))
   483 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
   484 |     |             }
   485 |     |             m0 := mload(0x00)
   486 |     |             m1 := mload(0x20)
   487 |     |             m2 := mload(0x40)
   488 |     |             m3 := mload(0x60)
   489 |     |             m4 := mload(0x80)
   490 |     |             // Selector of `log(uint256,string)`.
   491 |     |             mstore(0x00, 0x643fd0df)
   492 |     |             mstore(0x20, p0)
   493 |     |             mstore(0x40, 0x40)
   494 |     |             writeString(0x60, p1)
   495 |     |         }
   496 |     |         _sendLogPayload(0x1c, 0x84);
   497 |     |         /// @solidity memory-safe-assembly
   498 |     |         assembly {
   499 |     |             mstore(0x00, m0)
   500 |     |             mstore(0x20, m1)
   501 |     |             mstore(0x40, m2)
   502 |     |             mstore(0x60, m3)
   503 |     |             mstore(0x80, m4)
   504 |     |         }
   505 |     |     }
   506 |     | 
   507 |     |     function log(bytes32 p0, address p1) internal pure {
   508 |     |         bytes32 m0;
   509 |     |         bytes32 m1;
   510 |     |         bytes32 m2;
   511 |     |         bytes32 m3;
   512 |     |         bytes32 m4;
   513 |     |         /// @solidity memory-safe-assembly
   514 |     |         assembly {
   515 |     |             function writeString(pos, w) {
   516 |     |                 let length := 0
   517 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
   518 |     |                 mstore(pos, length)
   519 |     |                 let shift := sub(256, shl(3, length))
   520 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
   521 |     |             }
   522 |     |             m0 := mload(0x00)
   523 |     |             m1 := mload(0x20)
   524 |     |             m2 := mload(0x40)
   525 |     |             m3 := mload(0x60)
   526 |     |             m4 := mload(0x80)
   527 |     |             // Selector of `log(string,address)`.
   528 |     |             mstore(0x00, 0x319af333)
   529 |     |             mstore(0x20, 0x40)
   530 |     |             mstore(0x40, p1)
   531 |     |             writeString(0x60, p0)
   532 |     |         }
   533 |     |         _sendLogPayload(0x1c, 0x84);
   534 |     |         /// @solidity memory-safe-assembly
   535 |     |         assembly {
   536 |     |             mstore(0x00, m0)
   537 |     |             mstore(0x20, m1)
   538 |     |             mstore(0x40, m2)
   539 |     |             mstore(0x60, m3)
   540 |     |             mstore(0x80, m4)
   541 |     |         }
   542 |     |     }
   543 |     | 
   544 |     |     function log(bytes32 p0, bool p1) internal pure {
   545 |     |         bytes32 m0;
   546 |     |         bytes32 m1;
   547 |     |         bytes32 m2;
   548 |     |         bytes32 m3;
   549 |     |         bytes32 m4;
   550 |     |         /// @solidity memory-safe-assembly
   551 |     |         assembly {
   552 |     |             function writeString(pos, w) {
   553 |     |                 let length := 0
   554 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
   555 |     |                 mstore(pos, length)
   556 |     |                 let shift := sub(256, shl(3, length))
   557 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
   558 |     |             }
   559 |     |             m0 := mload(0x00)
   560 |     |             m1 := mload(0x20)
   561 |     |             m2 := mload(0x40)
   562 |     |             m3 := mload(0x60)
   563 |     |             m4 := mload(0x80)
   564 |     |             // Selector of `log(string,bool)`.
   565 |     |             mstore(0x00, 0xc3b55635)
   566 |     |             mstore(0x20, 0x40)
   567 |     |             mstore(0x40, p1)
   568 |     |             writeString(0x60, p0)
   569 |     |         }
   570 |     |         _sendLogPayload(0x1c, 0x84);
   571 |     |         /// @solidity memory-safe-assembly
   572 |     |         assembly {
   573 |     |             mstore(0x00, m0)
   574 |     |             mstore(0x20, m1)
   575 |     |             mstore(0x40, m2)
   576 |     |             mstore(0x60, m3)
   577 |     |             mstore(0x80, m4)
   578 |     |         }
   579 |     |     }
   580 |     | 
   581 |     |     function log(bytes32 p0, uint256 p1) internal pure {
   582 |     |         bytes32 m0;
   583 |     |         bytes32 m1;
   584 |     |         bytes32 m2;
   585 |     |         bytes32 m3;
   586 |     |         bytes32 m4;
   587 |     |         /// @solidity memory-safe-assembly
   588 |     |         assembly {
   589 |     |             function writeString(pos, w) {
   590 |     |                 let length := 0
   591 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
   592 |     |                 mstore(pos, length)
   593 |     |                 let shift := sub(256, shl(3, length))
   594 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
   595 |     |             }
   596 |     |             m0 := mload(0x00)
   597 |     |             m1 := mload(0x20)
   598 |     |             m2 := mload(0x40)
   599 |     |             m3 := mload(0x60)
   600 |     |             m4 := mload(0x80)
   601 |     |             // Selector of `log(string,uint256)`.
   602 |     |             mstore(0x00, 0xb60e72cc)
   603 |     |             mstore(0x20, 0x40)
   604 |     |             mstore(0x40, p1)
   605 |     |             writeString(0x60, p0)
   606 |     |         }
   607 |     |         _sendLogPayload(0x1c, 0x84);
   608 |     |         /// @solidity memory-safe-assembly
   609 |     |         assembly {
   610 |     |             mstore(0x00, m0)
   611 |     |             mstore(0x20, m1)
   612 |     |             mstore(0x40, m2)
   613 |     |             mstore(0x60, m3)
   614 |     |             mstore(0x80, m4)
   615 |     |         }
   616 |     |     }
   617 |     | 
   618 |     |     function log(bytes32 p0, bytes32 p1) internal pure {
   619 |     |         bytes32 m0;
   620 |     |         bytes32 m1;
   621 |     |         bytes32 m2;
   622 |     |         bytes32 m3;
   623 |     |         bytes32 m4;
   624 |     |         bytes32 m5;
   625 |     |         bytes32 m6;
   626 |     |         /// @solidity memory-safe-assembly
   627 |     |         assembly {
   628 |     |             function writeString(pos, w) {
   629 |     |                 let length := 0
   630 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
   631 |     |                 mstore(pos, length)
   632 |     |                 let shift := sub(256, shl(3, length))
   633 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
   634 |     |             }
   635 |     |             m0 := mload(0x00)
   636 |     |             m1 := mload(0x20)
   637 |     |             m2 := mload(0x40)
   638 |     |             m3 := mload(0x60)
   639 |     |             m4 := mload(0x80)
   640 |     |             m5 := mload(0xa0)
   641 |     |             m6 := mload(0xc0)
   642 |     |             // Selector of `log(string,string)`.
   643 |     |             mstore(0x00, 0x4b5c4277)
   644 |     |             mstore(0x20, 0x40)
   645 |     |             mstore(0x40, 0x80)
   646 |     |             writeString(0x60, p0)
   647 |     |             writeString(0xa0, p1)
   648 |     |         }
   649 |     |         _sendLogPayload(0x1c, 0xc4);
   650 |     |         /// @solidity memory-safe-assembly
   651 |     |         assembly {
   652 |     |             mstore(0x00, m0)
   653 |     |             mstore(0x20, m1)
   654 |     |             mstore(0x40, m2)
   655 |     |             mstore(0x60, m3)
   656 |     |             mstore(0x80, m4)
   657 |     |             mstore(0xa0, m5)
   658 |     |             mstore(0xc0, m6)
   659 |     |         }
   660 |     |     }
   661 |     | 
   662 |     |     function log(address p0, address p1, address p2) internal pure {
   663 |     |         bytes32 m0;
   664 |     |         bytes32 m1;
   665 |     |         bytes32 m2;
   666 |     |         bytes32 m3;
   667 |     |         /// @solidity memory-safe-assembly
   668 |     |         assembly {
   669 |     |             m0 := mload(0x00)
   670 |     |             m1 := mload(0x20)
   671 |     |             m2 := mload(0x40)
   672 |     |             m3 := mload(0x60)
   673 |     |             // Selector of `log(address,address,address)`.
   674 |     |             mstore(0x00, 0x018c84c2)
   675 |     |             mstore(0x20, p0)
   676 |     |             mstore(0x40, p1)
   677 |     |             mstore(0x60, p2)
   678 |     |         }
   679 |     |         _sendLogPayload(0x1c, 0x64);
   680 |     |         /// @solidity memory-safe-assembly
   681 |     |         assembly {
   682 |     |             mstore(0x00, m0)
   683 |     |             mstore(0x20, m1)
   684 |     |             mstore(0x40, m2)
   685 |     |             mstore(0x60, m3)
   686 |     |         }
   687 |     |     }
   688 |     | 
   689 |     |     function log(address p0, address p1, bool p2) internal pure {
   690 |     |         bytes32 m0;
   691 |     |         bytes32 m1;
   692 |     |         bytes32 m2;
   693 |     |         bytes32 m3;
   694 |     |         /// @solidity memory-safe-assembly
   695 |     |         assembly {
   696 |     |             m0 := mload(0x00)
   697 |     |             m1 := mload(0x20)
   698 |     |             m2 := mload(0x40)
   699 |     |             m3 := mload(0x60)
   700 |     |             // Selector of `log(address,address,bool)`.
   701 |     |             mstore(0x00, 0xf2a66286)
   702 |     |             mstore(0x20, p0)
   703 |     |             mstore(0x40, p1)
   704 |     |             mstore(0x60, p2)
   705 |     |         }
   706 |     |         _sendLogPayload(0x1c, 0x64);
   707 |     |         /// @solidity memory-safe-assembly
   708 |     |         assembly {
   709 |     |             mstore(0x00, m0)
   710 |     |             mstore(0x20, m1)
   711 |     |             mstore(0x40, m2)
   712 |     |             mstore(0x60, m3)
   713 |     |         }
   714 |     |     }
   715 |     | 
   716 |     |     function log(address p0, address p1, uint256 p2) internal pure {
   717 |     |         bytes32 m0;
   718 |     |         bytes32 m1;
   719 |     |         bytes32 m2;
   720 |     |         bytes32 m3;
   721 |     |         /// @solidity memory-safe-assembly
   722 |     |         assembly {
   723 |     |             m0 := mload(0x00)
   724 |     |             m1 := mload(0x20)
   725 |     |             m2 := mload(0x40)
   726 |     |             m3 := mload(0x60)
   727 |     |             // Selector of `log(address,address,uint256)`.
   728 |     |             mstore(0x00, 0x17fe6185)
   729 |     |             mstore(0x20, p0)
   730 |     |             mstore(0x40, p1)
   731 |     |             mstore(0x60, p2)
   732 |     |         }
   733 |     |         _sendLogPayload(0x1c, 0x64);
   734 |     |         /// @solidity memory-safe-assembly
   735 |     |         assembly {
   736 |     |             mstore(0x00, m0)
   737 |     |             mstore(0x20, m1)
   738 |     |             mstore(0x40, m2)
   739 |     |             mstore(0x60, m3)
   740 |     |         }
   741 |     |     }
   742 |     | 
   743 |     |     function log(address p0, address p1, bytes32 p2) internal pure {
   744 |     |         bytes32 m0;
   745 |     |         bytes32 m1;
   746 |     |         bytes32 m2;
   747 |     |         bytes32 m3;
   748 |     |         bytes32 m4;
   749 |     |         bytes32 m5;
   750 |     |         /// @solidity memory-safe-assembly
   751 |     |         assembly {
   752 |     |             function writeString(pos, w) {
   753 |     |                 let length := 0
   754 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
   755 |     |                 mstore(pos, length)
   756 |     |                 let shift := sub(256, shl(3, length))
   757 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
   758 |     |             }
   759 |     |             m0 := mload(0x00)
   760 |     |             m1 := mload(0x20)
   761 |     |             m2 := mload(0x40)
   762 |     |             m3 := mload(0x60)
   763 |     |             m4 := mload(0x80)
   764 |     |             m5 := mload(0xa0)
   765 |     |             // Selector of `log(address,address,string)`.
   766 |     |             mstore(0x00, 0x007150be)
   767 |     |             mstore(0x20, p0)
   768 |     |             mstore(0x40, p1)
   769 |     |             mstore(0x60, 0x60)
   770 |     |             writeString(0x80, p2)
   771 |     |         }
   772 |     |         _sendLogPayload(0x1c, 0xa4);
   773 |     |         /// @solidity memory-safe-assembly
   774 |     |         assembly {
   775 |     |             mstore(0x00, m0)
   776 |     |             mstore(0x20, m1)
   777 |     |             mstore(0x40, m2)
   778 |     |             mstore(0x60, m3)
   779 |     |             mstore(0x80, m4)
   780 |     |             mstore(0xa0, m5)
   781 |     |         }
   782 |     |     }
   783 |     | 
   784 |     |     function log(address p0, bool p1, address p2) internal pure {
   785 |     |         bytes32 m0;
   786 |     |         bytes32 m1;
   787 |     |         bytes32 m2;
   788 |     |         bytes32 m3;
   789 |     |         /// @solidity memory-safe-assembly
   790 |     |         assembly {
   791 |     |             m0 := mload(0x00)
   792 |     |             m1 := mload(0x20)
   793 |     |             m2 := mload(0x40)
   794 |     |             m3 := mload(0x60)
   795 |     |             // Selector of `log(address,bool,address)`.
   796 |     |             mstore(0x00, 0xf11699ed)
   797 |     |             mstore(0x20, p0)
   798 |     |             mstore(0x40, p1)
   799 |     |             mstore(0x60, p2)
   800 |     |         }
   801 |     |         _sendLogPayload(0x1c, 0x64);
   802 |     |         /// @solidity memory-safe-assembly
   803 |     |         assembly {
   804 |     |             mstore(0x00, m0)
   805 |     |             mstore(0x20, m1)
   806 |     |             mstore(0x40, m2)
   807 |     |             mstore(0x60, m3)
   808 |     |         }
   809 |     |     }
   810 |     | 
   811 |     |     function log(address p0, bool p1, bool p2) internal pure {
   812 |     |         bytes32 m0;
   813 |     |         bytes32 m1;
   814 |     |         bytes32 m2;
   815 |     |         bytes32 m3;
   816 |     |         /// @solidity memory-safe-assembly
   817 |     |         assembly {
   818 |     |             m0 := mload(0x00)
   819 |     |             m1 := mload(0x20)
   820 |     |             m2 := mload(0x40)
   821 |     |             m3 := mload(0x60)
   822 |     |             // Selector of `log(address,bool,bool)`.
   823 |     |             mstore(0x00, 0xeb830c92)
   824 |     |             mstore(0x20, p0)
   825 |     |             mstore(0x40, p1)
   826 |     |             mstore(0x60, p2)
   827 |     |         }
   828 |     |         _sendLogPayload(0x1c, 0x64);
   829 |     |         /// @solidity memory-safe-assembly
   830 |     |         assembly {
   831 |     |             mstore(0x00, m0)
   832 |     |             mstore(0x20, m1)
   833 |     |             mstore(0x40, m2)
   834 |     |             mstore(0x60, m3)
   835 |     |         }
   836 |     |     }
   837 |     | 
   838 |     |     function log(address p0, bool p1, uint256 p2) internal pure {
   839 |     |         bytes32 m0;
   840 |     |         bytes32 m1;
   841 |     |         bytes32 m2;
   842 |     |         bytes32 m3;
   843 |     |         /// @solidity memory-safe-assembly
   844 |     |         assembly {
   845 |     |             m0 := mload(0x00)
   846 |     |             m1 := mload(0x20)
   847 |     |             m2 := mload(0x40)
   848 |     |             m3 := mload(0x60)
   849 |     |             // Selector of `log(address,bool,uint256)`.
   850 |     |             mstore(0x00, 0x9c4f99fb)
   851 |     |             mstore(0x20, p0)
   852 |     |             mstore(0x40, p1)
   853 |     |             mstore(0x60, p2)
   854 |     |         }
   855 |     |         _sendLogPayload(0x1c, 0x64);
   856 |     |         /// @solidity memory-safe-assembly
   857 |     |         assembly {
   858 |     |             mstore(0x00, m0)
   859 |     |             mstore(0x20, m1)
   860 |     |             mstore(0x40, m2)
   861 |     |             mstore(0x60, m3)
   862 |     |         }
   863 |     |     }
   864 |     | 
   865 |     |     function log(address p0, bool p1, bytes32 p2) internal pure {
   866 |     |         bytes32 m0;
   867 |     |         bytes32 m1;
   868 |     |         bytes32 m2;
   869 |     |         bytes32 m3;
   870 |     |         bytes32 m4;
   871 |     |         bytes32 m5;
   872 |     |         /// @solidity memory-safe-assembly
   873 |     |         assembly {
   874 |     |             function writeString(pos, w) {
   875 |     |                 let length := 0
   876 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
   877 |     |                 mstore(pos, length)
   878 |     |                 let shift := sub(256, shl(3, length))
   879 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
   880 |     |             }
   881 |     |             m0 := mload(0x00)
   882 |     |             m1 := mload(0x20)
   883 |     |             m2 := mload(0x40)
   884 |     |             m3 := mload(0x60)
   885 |     |             m4 := mload(0x80)
   886 |     |             m5 := mload(0xa0)
   887 |     |             // Selector of `log(address,bool,string)`.
   888 |     |             mstore(0x00, 0x212255cc)
   889 |     |             mstore(0x20, p0)
   890 |     |             mstore(0x40, p1)
   891 |     |             mstore(0x60, 0x60)
   892 |     |             writeString(0x80, p2)
   893 |     |         }
   894 |     |         _sendLogPayload(0x1c, 0xa4);
   895 |     |         /// @solidity memory-safe-assembly
   896 |     |         assembly {
   897 |     |             mstore(0x00, m0)
   898 |     |             mstore(0x20, m1)
   899 |     |             mstore(0x40, m2)
   900 |     |             mstore(0x60, m3)
   901 |     |             mstore(0x80, m4)
   902 |     |             mstore(0xa0, m5)
   903 |     |         }
   904 |     |     }
   905 |     | 
   906 |     |     function log(address p0, uint256 p1, address p2) internal pure {
   907 |     |         bytes32 m0;
   908 |     |         bytes32 m1;
   909 |     |         bytes32 m2;
   910 |     |         bytes32 m3;
   911 |     |         /// @solidity memory-safe-assembly
   912 |     |         assembly {
   913 |     |             m0 := mload(0x00)
   914 |     |             m1 := mload(0x20)
   915 |     |             m2 := mload(0x40)
   916 |     |             m3 := mload(0x60)
   917 |     |             // Selector of `log(address,uint256,address)`.
   918 |     |             mstore(0x00, 0x7bc0d848)
   919 |     |             mstore(0x20, p0)
   920 |     |             mstore(0x40, p1)
   921 |     |             mstore(0x60, p2)
   922 |     |         }
   923 |     |         _sendLogPayload(0x1c, 0x64);
   924 |     |         /// @solidity memory-safe-assembly
   925 |     |         assembly {
   926 |     |             mstore(0x00, m0)
   927 |     |             mstore(0x20, m1)
   928 |     |             mstore(0x40, m2)
   929 |     |             mstore(0x60, m3)
   930 |     |         }
   931 |     |     }
   932 |     | 
   933 |     |     function log(address p0, uint256 p1, bool p2) internal pure {
   934 |     |         bytes32 m0;
   935 |     |         bytes32 m1;
   936 |     |         bytes32 m2;
   937 |     |         bytes32 m3;
   938 |     |         /// @solidity memory-safe-assembly
   939 |     |         assembly {
   940 |     |             m0 := mload(0x00)
   941 |     |             m1 := mload(0x20)
   942 |     |             m2 := mload(0x40)
   943 |     |             m3 := mload(0x60)
   944 |     |             // Selector of `log(address,uint256,bool)`.
   945 |     |             mstore(0x00, 0x678209a8)
   946 |     |             mstore(0x20, p0)
   947 |     |             mstore(0x40, p1)
   948 |     |             mstore(0x60, p2)
   949 |     |         }
   950 |     |         _sendLogPayload(0x1c, 0x64);
   951 |     |         /// @solidity memory-safe-assembly
   952 |     |         assembly {
   953 |     |             mstore(0x00, m0)
   954 |     |             mstore(0x20, m1)
   955 |     |             mstore(0x40, m2)
   956 |     |             mstore(0x60, m3)
   957 |     |         }
   958 |     |     }
   959 |     | 
   960 |     |     function log(address p0, uint256 p1, uint256 p2) internal pure {
   961 |     |         bytes32 m0;
   962 |     |         bytes32 m1;
   963 |     |         bytes32 m2;
   964 |     |         bytes32 m3;
   965 |     |         /// @solidity memory-safe-assembly
   966 |     |         assembly {
   967 |     |             m0 := mload(0x00)
   968 |     |             m1 := mload(0x20)
   969 |     |             m2 := mload(0x40)
   970 |     |             m3 := mload(0x60)
   971 |     |             // Selector of `log(address,uint256,uint256)`.
   972 |     |             mstore(0x00, 0xb69bcaf6)
   973 |     |             mstore(0x20, p0)
   974 |     |             mstore(0x40, p1)
   975 |     |             mstore(0x60, p2)
   976 |     |         }
   977 |     |         _sendLogPayload(0x1c, 0x64);
   978 |     |         /// @solidity memory-safe-assembly
   979 |     |         assembly {
   980 |     |             mstore(0x00, m0)
   981 |     |             mstore(0x20, m1)
   982 |     |             mstore(0x40, m2)
   983 |     |             mstore(0x60, m3)
   984 |     |         }
   985 |     |     }
   986 |     | 
   987 |     |     function log(address p0, uint256 p1, bytes32 p2) internal pure {
   988 |     |         bytes32 m0;
   989 |     |         bytes32 m1;
   990 |     |         bytes32 m2;
   991 |     |         bytes32 m3;
   992 |     |         bytes32 m4;
   993 |     |         bytes32 m5;
   994 |     |         /// @solidity memory-safe-assembly
   995 |     |         assembly {
   996 |     |             function writeString(pos, w) {
   997 |     |                 let length := 0
   998 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
   999 |     |                 mstore(pos, length)
  1000 |     |                 let shift := sub(256, shl(3, length))
  1001 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  1002 |     |             }
  1003 |     |             m0 := mload(0x00)
  1004 |     |             m1 := mload(0x20)
  1005 |     |             m2 := mload(0x40)
  1006 |     |             m3 := mload(0x60)
  1007 |     |             m4 := mload(0x80)
  1008 |     |             m5 := mload(0xa0)
  1009 |     |             // Selector of `log(address,uint256,string)`.
  1010 |     |             mstore(0x00, 0xa1f2e8aa)
  1011 |     |             mstore(0x20, p0)
  1012 |     |             mstore(0x40, p1)
  1013 |     |             mstore(0x60, 0x60)
  1014 |     |             writeString(0x80, p2)
  1015 |     |         }
  1016 |     |         _sendLogPayload(0x1c, 0xa4);
  1017 |     |         /// @solidity memory-safe-assembly
  1018 |     |         assembly {
  1019 |     |             mstore(0x00, m0)
  1020 |     |             mstore(0x20, m1)
  1021 |     |             mstore(0x40, m2)
  1022 |     |             mstore(0x60, m3)
  1023 |     |             mstore(0x80, m4)
  1024 |     |             mstore(0xa0, m5)
  1025 |     |         }
  1026 |     |     }
  1027 |     | 
  1028 |     |     function log(address p0, bytes32 p1, address p2) internal pure {
  1029 |     |         bytes32 m0;
  1030 |     |         bytes32 m1;
  1031 |     |         bytes32 m2;
  1032 |     |         bytes32 m3;
  1033 |     |         bytes32 m4;
  1034 |     |         bytes32 m5;
  1035 |     |         /// @solidity memory-safe-assembly
  1036 |     |         assembly {
  1037 |     |             function writeString(pos, w) {
  1038 |     |                 let length := 0
  1039 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  1040 |     |                 mstore(pos, length)
  1041 |     |                 let shift := sub(256, shl(3, length))
  1042 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  1043 |     |             }
  1044 |     |             m0 := mload(0x00)
  1045 |     |             m1 := mload(0x20)
  1046 |     |             m2 := mload(0x40)
  1047 |     |             m3 := mload(0x60)
  1048 |     |             m4 := mload(0x80)
  1049 |     |             m5 := mload(0xa0)
  1050 |     |             // Selector of `log(address,string,address)`.
  1051 |     |             mstore(0x00, 0xf08744e8)
  1052 |     |             mstore(0x20, p0)
  1053 |     |             mstore(0x40, 0x60)
  1054 |     |             mstore(0x60, p2)
  1055 |     |             writeString(0x80, p1)
  1056 |     |         }
  1057 |     |         _sendLogPayload(0x1c, 0xa4);
  1058 |     |         /// @solidity memory-safe-assembly
  1059 |     |         assembly {
  1060 |     |             mstore(0x00, m0)
  1061 |     |             mstore(0x20, m1)
  1062 |     |             mstore(0x40, m2)
  1063 |     |             mstore(0x60, m3)
  1064 |     |             mstore(0x80, m4)
  1065 |     |             mstore(0xa0, m5)
  1066 |     |         }
  1067 |     |     }
  1068 |     | 
  1069 |     |     function log(address p0, bytes32 p1, bool p2) internal pure {
  1070 |     |         bytes32 m0;
  1071 |     |         bytes32 m1;
  1072 |     |         bytes32 m2;
  1073 |     |         bytes32 m3;
  1074 |     |         bytes32 m4;
  1075 |     |         bytes32 m5;
  1076 |     |         /// @solidity memory-safe-assembly
  1077 |     |         assembly {
  1078 |     |             function writeString(pos, w) {
  1079 |     |                 let length := 0
  1080 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  1081 |     |                 mstore(pos, length)
  1082 |     |                 let shift := sub(256, shl(3, length))
  1083 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  1084 |     |             }
  1085 |     |             m0 := mload(0x00)
  1086 |     |             m1 := mload(0x20)
  1087 |     |             m2 := mload(0x40)
  1088 |     |             m3 := mload(0x60)
  1089 |     |             m4 := mload(0x80)
  1090 |     |             m5 := mload(0xa0)
  1091 |     |             // Selector of `log(address,string,bool)`.
  1092 |     |             mstore(0x00, 0xcf020fb1)
  1093 |     |             mstore(0x20, p0)
  1094 |     |             mstore(0x40, 0x60)
  1095 |     |             mstore(0x60, p2)
  1096 |     |             writeString(0x80, p1)
  1097 |     |         }
  1098 |     |         _sendLogPayload(0x1c, 0xa4);
  1099 |     |         /// @solidity memory-safe-assembly
  1100 |     |         assembly {
  1101 |     |             mstore(0x00, m0)
  1102 |     |             mstore(0x20, m1)
  1103 |     |             mstore(0x40, m2)
  1104 |     |             mstore(0x60, m3)
  1105 |     |             mstore(0x80, m4)
  1106 |     |             mstore(0xa0, m5)
  1107 |     |         }
  1108 |     |     }
  1109 |     | 
  1110 |     |     function log(address p0, bytes32 p1, uint256 p2) internal pure {
  1111 |     |         bytes32 m0;
  1112 |     |         bytes32 m1;
  1113 |     |         bytes32 m2;
  1114 |     |         bytes32 m3;
  1115 |     |         bytes32 m4;
  1116 |     |         bytes32 m5;
  1117 |     |         /// @solidity memory-safe-assembly
  1118 |     |         assembly {
  1119 |     |             function writeString(pos, w) {
  1120 |     |                 let length := 0
  1121 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  1122 |     |                 mstore(pos, length)
  1123 |     |                 let shift := sub(256, shl(3, length))
  1124 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  1125 |     |             }
  1126 |     |             m0 := mload(0x00)
  1127 |     |             m1 := mload(0x20)
  1128 |     |             m2 := mload(0x40)
  1129 |     |             m3 := mload(0x60)
  1130 |     |             m4 := mload(0x80)
  1131 |     |             m5 := mload(0xa0)
  1132 |     |             // Selector of `log(address,string,uint256)`.
  1133 |     |             mstore(0x00, 0x67dd6ff1)
  1134 |     |             mstore(0x20, p0)
  1135 |     |             mstore(0x40, 0x60)
  1136 |     |             mstore(0x60, p2)
  1137 |     |             writeString(0x80, p1)
  1138 |     |         }
  1139 |     |         _sendLogPayload(0x1c, 0xa4);
  1140 |     |         /// @solidity memory-safe-assembly
  1141 |     |         assembly {
  1142 |     |             mstore(0x00, m0)
  1143 |     |             mstore(0x20, m1)
  1144 |     |             mstore(0x40, m2)
  1145 |     |             mstore(0x60, m3)
  1146 |     |             mstore(0x80, m4)
  1147 |     |             mstore(0xa0, m5)
  1148 |     |         }
  1149 |     |     }
  1150 |     | 
  1151 |     |     function log(address p0, bytes32 p1, bytes32 p2) internal pure {
  1152 |     |         bytes32 m0;
  1153 |     |         bytes32 m1;
  1154 |     |         bytes32 m2;
  1155 |     |         bytes32 m3;
  1156 |     |         bytes32 m4;
  1157 |     |         bytes32 m5;
  1158 |     |         bytes32 m6;
  1159 |     |         bytes32 m7;
  1160 |     |         /// @solidity memory-safe-assembly
  1161 |     |         assembly {
  1162 |     |             function writeString(pos, w) {
  1163 |     |                 let length := 0
  1164 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  1165 |     |                 mstore(pos, length)
  1166 |     |                 let shift := sub(256, shl(3, length))
  1167 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  1168 |     |             }
  1169 |     |             m0 := mload(0x00)
  1170 |     |             m1 := mload(0x20)
  1171 |     |             m2 := mload(0x40)
  1172 |     |             m3 := mload(0x60)
  1173 |     |             m4 := mload(0x80)
  1174 |     |             m5 := mload(0xa0)
  1175 |     |             m6 := mload(0xc0)
  1176 |     |             m7 := mload(0xe0)
  1177 |     |             // Selector of `log(address,string,string)`.
  1178 |     |             mstore(0x00, 0xfb772265)
  1179 |     |             mstore(0x20, p0)
  1180 |     |             mstore(0x40, 0x60)
  1181 |     |             mstore(0x60, 0xa0)
  1182 |     |             writeString(0x80, p1)
  1183 |     |             writeString(0xc0, p2)
  1184 |     |         }
  1185 |     |         _sendLogPayload(0x1c, 0xe4);
  1186 |     |         /// @solidity memory-safe-assembly
  1187 |     |         assembly {
  1188 |     |             mstore(0x00, m0)
  1189 |     |             mstore(0x20, m1)
  1190 |     |             mstore(0x40, m2)
  1191 |     |             mstore(0x60, m3)
  1192 |     |             mstore(0x80, m4)
  1193 |     |             mstore(0xa0, m5)
  1194 |     |             mstore(0xc0, m6)
  1195 |     |             mstore(0xe0, m7)
  1196 |     |         }
  1197 |     |     }
  1198 |     | 
  1199 |     |     function log(bool p0, address p1, address p2) internal pure {
  1200 |     |         bytes32 m0;
  1201 |     |         bytes32 m1;
  1202 |     |         bytes32 m2;
  1203 |     |         bytes32 m3;
  1204 |     |         /// @solidity memory-safe-assembly
  1205 |     |         assembly {
  1206 |     |             m0 := mload(0x00)
  1207 |     |             m1 := mload(0x20)
  1208 |     |             m2 := mload(0x40)
  1209 |     |             m3 := mload(0x60)
  1210 |     |             // Selector of `log(bool,address,address)`.
  1211 |     |             mstore(0x00, 0xd2763667)
  1212 |     |             mstore(0x20, p0)
  1213 |     |             mstore(0x40, p1)
  1214 |     |             mstore(0x60, p2)
  1215 |     |         }
  1216 |     |         _sendLogPayload(0x1c, 0x64);
  1217 |     |         /// @solidity memory-safe-assembly
  1218 |     |         assembly {
  1219 |     |             mstore(0x00, m0)
  1220 |     |             mstore(0x20, m1)
  1221 |     |             mstore(0x40, m2)
  1222 |     |             mstore(0x60, m3)
  1223 |     |         }
  1224 |     |     }
  1225 |     | 
  1226 |     |     function log(bool p0, address p1, bool p2) internal pure {
  1227 |     |         bytes32 m0;
  1228 |     |         bytes32 m1;
  1229 |     |         bytes32 m2;
  1230 |     |         bytes32 m3;
  1231 |     |         /// @solidity memory-safe-assembly
  1232 |     |         assembly {
  1233 |     |             m0 := mload(0x00)
  1234 |     |             m1 := mload(0x20)
  1235 |     |             m2 := mload(0x40)
  1236 |     |             m3 := mload(0x60)
  1237 |     |             // Selector of `log(bool,address,bool)`.
  1238 |     |             mstore(0x00, 0x18c9c746)
  1239 |     |             mstore(0x20, p0)
  1240 |     |             mstore(0x40, p1)
  1241 |     |             mstore(0x60, p2)
  1242 |     |         }
  1243 |     |         _sendLogPayload(0x1c, 0x64);
  1244 |     |         /// @solidity memory-safe-assembly
  1245 |     |         assembly {
  1246 |     |             mstore(0x00, m0)
  1247 |     |             mstore(0x20, m1)
  1248 |     |             mstore(0x40, m2)
  1249 |     |             mstore(0x60, m3)
  1250 |     |         }
  1251 |     |     }
  1252 |     | 
  1253 |     |     function log(bool p0, address p1, uint256 p2) internal pure {
  1254 |     |         bytes32 m0;
  1255 |     |         bytes32 m1;
  1256 |     |         bytes32 m2;
  1257 |     |         bytes32 m3;
  1258 |     |         /// @solidity memory-safe-assembly
  1259 |     |         assembly {
  1260 |     |             m0 := mload(0x00)
  1261 |     |             m1 := mload(0x20)
  1262 |     |             m2 := mload(0x40)
  1263 |     |             m3 := mload(0x60)
  1264 |     |             // Selector of `log(bool,address,uint256)`.
  1265 |     |             mstore(0x00, 0x5f7b9afb)
  1266 |     |             mstore(0x20, p0)
  1267 |     |             mstore(0x40, p1)
  1268 |     |             mstore(0x60, p2)
  1269 |     |         }
  1270 |     |         _sendLogPayload(0x1c, 0x64);
  1271 |     |         /// @solidity memory-safe-assembly
  1272 |     |         assembly {
  1273 |     |             mstore(0x00, m0)
  1274 |     |             mstore(0x20, m1)
  1275 |     |             mstore(0x40, m2)
  1276 |     |             mstore(0x60, m3)
  1277 |     |         }
  1278 |     |     }
  1279 |     | 
  1280 |     |     function log(bool p0, address p1, bytes32 p2) internal pure {
  1281 |     |         bytes32 m0;
  1282 |     |         bytes32 m1;
  1283 |     |         bytes32 m2;
  1284 |     |         bytes32 m3;
  1285 |     |         bytes32 m4;
  1286 |     |         bytes32 m5;
  1287 |     |         /// @solidity memory-safe-assembly
  1288 |     |         assembly {
  1289 |     |             function writeString(pos, w) {
  1290 |     |                 let length := 0
  1291 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  1292 |     |                 mstore(pos, length)
  1293 |     |                 let shift := sub(256, shl(3, length))
  1294 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  1295 |     |             }
  1296 |     |             m0 := mload(0x00)
  1297 |     |             m1 := mload(0x20)
  1298 |     |             m2 := mload(0x40)
  1299 |     |             m3 := mload(0x60)
  1300 |     |             m4 := mload(0x80)
  1301 |     |             m5 := mload(0xa0)
  1302 |     |             // Selector of `log(bool,address,string)`.
  1303 |     |             mstore(0x00, 0xde9a9270)
  1304 |     |             mstore(0x20, p0)
  1305 |     |             mstore(0x40, p1)
  1306 |     |             mstore(0x60, 0x60)
  1307 |     |             writeString(0x80, p2)
  1308 |     |         }
  1309 |     |         _sendLogPayload(0x1c, 0xa4);
  1310 |     |         /// @solidity memory-safe-assembly
  1311 |     |         assembly {
  1312 |     |             mstore(0x00, m0)
  1313 |     |             mstore(0x20, m1)
  1314 |     |             mstore(0x40, m2)
  1315 |     |             mstore(0x60, m3)
  1316 |     |             mstore(0x80, m4)
  1317 |     |             mstore(0xa0, m5)
  1318 |     |         }
  1319 |     |     }
  1320 |     | 
  1321 |     |     function log(bool p0, bool p1, address p2) internal pure {
  1322 |     |         bytes32 m0;
  1323 |     |         bytes32 m1;
  1324 |     |         bytes32 m2;
  1325 |     |         bytes32 m3;
  1326 |     |         /// @solidity memory-safe-assembly
  1327 |     |         assembly {
  1328 |     |             m0 := mload(0x00)
  1329 |     |             m1 := mload(0x20)
  1330 |     |             m2 := mload(0x40)
  1331 |     |             m3 := mload(0x60)
  1332 |     |             // Selector of `log(bool,bool,address)`.
  1333 |     |             mstore(0x00, 0x1078f68d)
  1334 |     |             mstore(0x20, p0)
  1335 |     |             mstore(0x40, p1)
  1336 |     |             mstore(0x60, p2)
  1337 |     |         }
  1338 |     |         _sendLogPayload(0x1c, 0x64);
  1339 |     |         /// @solidity memory-safe-assembly
  1340 |     |         assembly {
  1341 |     |             mstore(0x00, m0)
  1342 |     |             mstore(0x20, m1)
  1343 |     |             mstore(0x40, m2)
  1344 |     |             mstore(0x60, m3)
  1345 |     |         }
  1346 |     |     }
  1347 |     | 
  1348 |     |     function log(bool p0, bool p1, bool p2) internal pure {
  1349 |     |         bytes32 m0;
  1350 |     |         bytes32 m1;
  1351 |     |         bytes32 m2;
  1352 |     |         bytes32 m3;
  1353 |     |         /// @solidity memory-safe-assembly
  1354 |     |         assembly {
  1355 |     |             m0 := mload(0x00)
  1356 |     |             m1 := mload(0x20)
  1357 |     |             m2 := mload(0x40)
  1358 |     |             m3 := mload(0x60)
  1359 |     |             // Selector of `log(bool,bool,bool)`.
  1360 |     |             mstore(0x00, 0x50709698)
  1361 |     |             mstore(0x20, p0)
  1362 |     |             mstore(0x40, p1)
  1363 |     |             mstore(0x60, p2)
  1364 |     |         }
  1365 |     |         _sendLogPayload(0x1c, 0x64);
  1366 |     |         /// @solidity memory-safe-assembly
  1367 |     |         assembly {
  1368 |     |             mstore(0x00, m0)
  1369 |     |             mstore(0x20, m1)
  1370 |     |             mstore(0x40, m2)
  1371 |     |             mstore(0x60, m3)
  1372 |     |         }
  1373 |     |     }
  1374 |     | 
  1375 |     |     function log(bool p0, bool p1, uint256 p2) internal pure {
  1376 |     |         bytes32 m0;
  1377 |     |         bytes32 m1;
  1378 |     |         bytes32 m2;
  1379 |     |         bytes32 m3;
  1380 |     |         /// @solidity memory-safe-assembly
  1381 |     |         assembly {
  1382 |     |             m0 := mload(0x00)
  1383 |     |             m1 := mload(0x20)
  1384 |     |             m2 := mload(0x40)
  1385 |     |             m3 := mload(0x60)
  1386 |     |             // Selector of `log(bool,bool,uint256)`.
  1387 |     |             mstore(0x00, 0x12f21602)
  1388 |     |             mstore(0x20, p0)
  1389 |     |             mstore(0x40, p1)
  1390 |     |             mstore(0x60, p2)
  1391 |     |         }
  1392 |     |         _sendLogPayload(0x1c, 0x64);
  1393 |     |         /// @solidity memory-safe-assembly
  1394 |     |         assembly {
  1395 |     |             mstore(0x00, m0)
  1396 |     |             mstore(0x20, m1)
  1397 |     |             mstore(0x40, m2)
  1398 |     |             mstore(0x60, m3)
  1399 |     |         }
  1400 |     |     }
  1401 |     | 
  1402 |     |     function log(bool p0, bool p1, bytes32 p2) internal pure {
  1403 |     |         bytes32 m0;
  1404 |     |         bytes32 m1;
  1405 |     |         bytes32 m2;
  1406 |     |         bytes32 m3;
  1407 |     |         bytes32 m4;
  1408 |     |         bytes32 m5;
  1409 |     |         /// @solidity memory-safe-assembly
  1410 |     |         assembly {
  1411 |     |             function writeString(pos, w) {
  1412 |     |                 let length := 0
  1413 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  1414 |     |                 mstore(pos, length)
  1415 |     |                 let shift := sub(256, shl(3, length))
  1416 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  1417 |     |             }
  1418 |     |             m0 := mload(0x00)
  1419 |     |             m1 := mload(0x20)
  1420 |     |             m2 := mload(0x40)
  1421 |     |             m3 := mload(0x60)
  1422 |     |             m4 := mload(0x80)
  1423 |     |             m5 := mload(0xa0)
  1424 |     |             // Selector of `log(bool,bool,string)`.
  1425 |     |             mstore(0x00, 0x2555fa46)
  1426 |     |             mstore(0x20, p0)
  1427 |     |             mstore(0x40, p1)
  1428 |     |             mstore(0x60, 0x60)
  1429 |     |             writeString(0x80, p2)
  1430 |     |         }
  1431 |     |         _sendLogPayload(0x1c, 0xa4);
  1432 |     |         /// @solidity memory-safe-assembly
  1433 |     |         assembly {
  1434 |     |             mstore(0x00, m0)
  1435 |     |             mstore(0x20, m1)
  1436 |     |             mstore(0x40, m2)
  1437 |     |             mstore(0x60, m3)
  1438 |     |             mstore(0x80, m4)
  1439 |     |             mstore(0xa0, m5)
  1440 |     |         }
  1441 |     |     }
  1442 |     | 
  1443 |     |     function log(bool p0, uint256 p1, address p2) internal pure {
  1444 |     |         bytes32 m0;
  1445 |     |         bytes32 m1;
  1446 |     |         bytes32 m2;
  1447 |     |         bytes32 m3;
  1448 |     |         /// @solidity memory-safe-assembly
  1449 |     |         assembly {
  1450 |     |             m0 := mload(0x00)
  1451 |     |             m1 := mload(0x20)
  1452 |     |             m2 := mload(0x40)
  1453 |     |             m3 := mload(0x60)
  1454 |     |             // Selector of `log(bool,uint256,address)`.
  1455 |     |             mstore(0x00, 0x088ef9d2)
  1456 |     |             mstore(0x20, p0)
  1457 |     |             mstore(0x40, p1)
  1458 |     |             mstore(0x60, p2)
  1459 |     |         }
  1460 |     |         _sendLogPayload(0x1c, 0x64);
  1461 |     |         /// @solidity memory-safe-assembly
  1462 |     |         assembly {
  1463 |     |             mstore(0x00, m0)
  1464 |     |             mstore(0x20, m1)
  1465 |     |             mstore(0x40, m2)
  1466 |     |             mstore(0x60, m3)
  1467 |     |         }
  1468 |     |     }
  1469 |     | 
  1470 |     |     function log(bool p0, uint256 p1, bool p2) internal pure {
  1471 |     |         bytes32 m0;
  1472 |     |         bytes32 m1;
  1473 |     |         bytes32 m2;
  1474 |     |         bytes32 m3;
  1475 |     |         /// @solidity memory-safe-assembly
  1476 |     |         assembly {
  1477 |     |             m0 := mload(0x00)
  1478 |     |             m1 := mload(0x20)
  1479 |     |             m2 := mload(0x40)
  1480 |     |             m3 := mload(0x60)
  1481 |     |             // Selector of `log(bool,uint256,bool)`.
  1482 |     |             mstore(0x00, 0xe8defba9)
  1483 |     |             mstore(0x20, p0)
  1484 |     |             mstore(0x40, p1)
  1485 |     |             mstore(0x60, p2)
  1486 |     |         }
  1487 |     |         _sendLogPayload(0x1c, 0x64);
  1488 |     |         /// @solidity memory-safe-assembly
  1489 |     |         assembly {
  1490 |     |             mstore(0x00, m0)
  1491 |     |             mstore(0x20, m1)
  1492 |     |             mstore(0x40, m2)
  1493 |     |             mstore(0x60, m3)
  1494 |     |         }
  1495 |     |     }
  1496 |     | 
  1497 |     |     function log(bool p0, uint256 p1, uint256 p2) internal pure {
  1498 |     |         bytes32 m0;
  1499 |     |         bytes32 m1;
  1500 |     |         bytes32 m2;
  1501 |     |         bytes32 m3;
  1502 |     |         /// @solidity memory-safe-assembly
  1503 |     |         assembly {
  1504 |     |             m0 := mload(0x00)
  1505 |     |             m1 := mload(0x20)
  1506 |     |             m2 := mload(0x40)
  1507 |     |             m3 := mload(0x60)
  1508 |     |             // Selector of `log(bool,uint256,uint256)`.
  1509 |     |             mstore(0x00, 0x37103367)
  1510 |     |             mstore(0x20, p0)
  1511 |     |             mstore(0x40, p1)
  1512 |     |             mstore(0x60, p2)
  1513 |     |         }
  1514 |     |         _sendLogPayload(0x1c, 0x64);
  1515 |     |         /// @solidity memory-safe-assembly
  1516 |     |         assembly {
  1517 |     |             mstore(0x00, m0)
  1518 |     |             mstore(0x20, m1)
  1519 |     |             mstore(0x40, m2)
  1520 |     |             mstore(0x60, m3)
  1521 |     |         }
  1522 |     |     }
  1523 |     | 
  1524 |     |     function log(bool p0, uint256 p1, bytes32 p2) internal pure {
  1525 |     |         bytes32 m0;
  1526 |     |         bytes32 m1;
  1527 |     |         bytes32 m2;
  1528 |     |         bytes32 m3;
  1529 |     |         bytes32 m4;
  1530 |     |         bytes32 m5;
  1531 |     |         /// @solidity memory-safe-assembly
  1532 |     |         assembly {
  1533 |     |             function writeString(pos, w) {
  1534 |     |                 let length := 0
  1535 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  1536 |     |                 mstore(pos, length)
  1537 |     |                 let shift := sub(256, shl(3, length))
  1538 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  1539 |     |             }
  1540 |     |             m0 := mload(0x00)
  1541 |     |             m1 := mload(0x20)
  1542 |     |             m2 := mload(0x40)
  1543 |     |             m3 := mload(0x60)
  1544 |     |             m4 := mload(0x80)
  1545 |     |             m5 := mload(0xa0)
  1546 |     |             // Selector of `log(bool,uint256,string)`.
  1547 |     |             mstore(0x00, 0xc3fc3970)
  1548 |     |             mstore(0x20, p0)
  1549 |     |             mstore(0x40, p1)
  1550 |     |             mstore(0x60, 0x60)
  1551 |     |             writeString(0x80, p2)
  1552 |     |         }
  1553 |     |         _sendLogPayload(0x1c, 0xa4);
  1554 |     |         /// @solidity memory-safe-assembly
  1555 |     |         assembly {
  1556 |     |             mstore(0x00, m0)
  1557 |     |             mstore(0x20, m1)
  1558 |     |             mstore(0x40, m2)
  1559 |     |             mstore(0x60, m3)
  1560 |     |             mstore(0x80, m4)
  1561 |     |             mstore(0xa0, m5)
  1562 |     |         }
  1563 |     |     }
  1564 |     | 
  1565 |     |     function log(bool p0, bytes32 p1, address p2) internal pure {
  1566 |     |         bytes32 m0;
  1567 |     |         bytes32 m1;
  1568 |     |         bytes32 m2;
  1569 |     |         bytes32 m3;
  1570 |     |         bytes32 m4;
  1571 |     |         bytes32 m5;
  1572 |     |         /// @solidity memory-safe-assembly
  1573 |     |         assembly {
  1574 |     |             function writeString(pos, w) {
  1575 |     |                 let length := 0
  1576 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  1577 |     |                 mstore(pos, length)
  1578 |     |                 let shift := sub(256, shl(3, length))
  1579 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  1580 |     |             }
  1581 |     |             m0 := mload(0x00)
  1582 |     |             m1 := mload(0x20)
  1583 |     |             m2 := mload(0x40)
  1584 |     |             m3 := mload(0x60)
  1585 |     |             m4 := mload(0x80)
  1586 |     |             m5 := mload(0xa0)
  1587 |     |             // Selector of `log(bool,string,address)`.
  1588 |     |             mstore(0x00, 0x9591b953)
  1589 |     |             mstore(0x20, p0)
  1590 |     |             mstore(0x40, 0x60)
  1591 |     |             mstore(0x60, p2)
  1592 |     |             writeString(0x80, p1)
  1593 |     |         }
  1594 |     |         _sendLogPayload(0x1c, 0xa4);
  1595 |     |         /// @solidity memory-safe-assembly
  1596 |     |         assembly {
  1597 |     |             mstore(0x00, m0)
  1598 |     |             mstore(0x20, m1)
  1599 |     |             mstore(0x40, m2)
  1600 |     |             mstore(0x60, m3)
  1601 |     |             mstore(0x80, m4)
  1602 |     |             mstore(0xa0, m5)
  1603 |     |         }
  1604 |     |     }
  1605 |     | 
  1606 |     |     function log(bool p0, bytes32 p1, bool p2) internal pure {
  1607 |     |         bytes32 m0;
  1608 |     |         bytes32 m1;
  1609 |     |         bytes32 m2;
  1610 |     |         bytes32 m3;
  1611 |     |         bytes32 m4;
  1612 |     |         bytes32 m5;
  1613 |     |         /// @solidity memory-safe-assembly
  1614 |     |         assembly {
  1615 |     |             function writeString(pos, w) {
  1616 |     |                 let length := 0
  1617 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  1618 |     |                 mstore(pos, length)
  1619 |     |                 let shift := sub(256, shl(3, length))
  1620 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  1621 |     |             }
  1622 |     |             m0 := mload(0x00)
  1623 |     |             m1 := mload(0x20)
  1624 |     |             m2 := mload(0x40)
  1625 |     |             m3 := mload(0x60)
  1626 |     |             m4 := mload(0x80)
  1627 |     |             m5 := mload(0xa0)
  1628 |     |             // Selector of `log(bool,string,bool)`.
  1629 |     |             mstore(0x00, 0xdbb4c247)
  1630 |     |             mstore(0x20, p0)
  1631 |     |             mstore(0x40, 0x60)
  1632 |     |             mstore(0x60, p2)
  1633 |     |             writeString(0x80, p1)
  1634 |     |         }
  1635 |     |         _sendLogPayload(0x1c, 0xa4);
  1636 |     |         /// @solidity memory-safe-assembly
  1637 |     |         assembly {
  1638 |     |             mstore(0x00, m0)
  1639 |     |             mstore(0x20, m1)
  1640 |     |             mstore(0x40, m2)
  1641 |     |             mstore(0x60, m3)
  1642 |     |             mstore(0x80, m4)
  1643 |     |             mstore(0xa0, m5)
  1644 |     |         }
  1645 |     |     }
  1646 |     | 
  1647 |     |     function log(bool p0, bytes32 p1, uint256 p2) internal pure {
  1648 |     |         bytes32 m0;
  1649 |     |         bytes32 m1;
  1650 |     |         bytes32 m2;
  1651 |     |         bytes32 m3;
  1652 |     |         bytes32 m4;
  1653 |     |         bytes32 m5;
  1654 |     |         /// @solidity memory-safe-assembly
  1655 |     |         assembly {
  1656 |     |             function writeString(pos, w) {
  1657 |     |                 let length := 0
  1658 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  1659 |     |                 mstore(pos, length)
  1660 |     |                 let shift := sub(256, shl(3, length))
  1661 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  1662 |     |             }
  1663 |     |             m0 := mload(0x00)
  1664 |     |             m1 := mload(0x20)
  1665 |     |             m2 := mload(0x40)
  1666 |     |             m3 := mload(0x60)
  1667 |     |             m4 := mload(0x80)
  1668 |     |             m5 := mload(0xa0)
  1669 |     |             // Selector of `log(bool,string,uint256)`.
  1670 |     |             mstore(0x00, 0x1093ee11)
  1671 |     |             mstore(0x20, p0)
  1672 |     |             mstore(0x40, 0x60)
  1673 |     |             mstore(0x60, p2)
  1674 |     |             writeString(0x80, p1)
  1675 |     |         }
  1676 |     |         _sendLogPayload(0x1c, 0xa4);
  1677 |     |         /// @solidity memory-safe-assembly
  1678 |     |         assembly {
  1679 |     |             mstore(0x00, m0)
  1680 |     |             mstore(0x20, m1)
  1681 |     |             mstore(0x40, m2)
  1682 |     |             mstore(0x60, m3)
  1683 |     |             mstore(0x80, m4)
  1684 |     |             mstore(0xa0, m5)
  1685 |     |         }
  1686 |     |     }
  1687 |     | 
  1688 |     |     function log(bool p0, bytes32 p1, bytes32 p2) internal pure {
  1689 |     |         bytes32 m0;
  1690 |     |         bytes32 m1;
  1691 |     |         bytes32 m2;
  1692 |     |         bytes32 m3;
  1693 |     |         bytes32 m4;
  1694 |     |         bytes32 m5;
  1695 |     |         bytes32 m6;
  1696 |     |         bytes32 m7;
  1697 |     |         /// @solidity memory-safe-assembly
  1698 |     |         assembly {
  1699 |     |             function writeString(pos, w) {
  1700 |     |                 let length := 0
  1701 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  1702 |     |                 mstore(pos, length)
  1703 |     |                 let shift := sub(256, shl(3, length))
  1704 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  1705 |     |             }
  1706 |     |             m0 := mload(0x00)
  1707 |     |             m1 := mload(0x20)
  1708 |     |             m2 := mload(0x40)
  1709 |     |             m3 := mload(0x60)
  1710 |     |             m4 := mload(0x80)
  1711 |     |             m5 := mload(0xa0)
  1712 |     |             m6 := mload(0xc0)
  1713 |     |             m7 := mload(0xe0)
  1714 |     |             // Selector of `log(bool,string,string)`.
  1715 |     |             mstore(0x00, 0xb076847f)
  1716 |     |             mstore(0x20, p0)
  1717 |     |             mstore(0x40, 0x60)
  1718 |     |             mstore(0x60, 0xa0)
  1719 |     |             writeString(0x80, p1)
  1720 |     |             writeString(0xc0, p2)
  1721 |     |         }
  1722 |     |         _sendLogPayload(0x1c, 0xe4);
  1723 |     |         /// @solidity memory-safe-assembly
  1724 |     |         assembly {
  1725 |     |             mstore(0x00, m0)
  1726 |     |             mstore(0x20, m1)
  1727 |     |             mstore(0x40, m2)
  1728 |     |             mstore(0x60, m3)
  1729 |     |             mstore(0x80, m4)
  1730 |     |             mstore(0xa0, m5)
  1731 |     |             mstore(0xc0, m6)
  1732 |     |             mstore(0xe0, m7)
  1733 |     |         }
  1734 |     |     }
  1735 |     | 
  1736 |     |     function log(uint256 p0, address p1, address p2) internal pure {
  1737 |     |         bytes32 m0;
  1738 |     |         bytes32 m1;
  1739 |     |         bytes32 m2;
  1740 |     |         bytes32 m3;
  1741 |     |         /// @solidity memory-safe-assembly
  1742 |     |         assembly {
  1743 |     |             m0 := mload(0x00)
  1744 |     |             m1 := mload(0x20)
  1745 |     |             m2 := mload(0x40)
  1746 |     |             m3 := mload(0x60)
  1747 |     |             // Selector of `log(uint256,address,address)`.
  1748 |     |             mstore(0x00, 0xbcfd9be0)
  1749 |     |             mstore(0x20, p0)
  1750 |     |             mstore(0x40, p1)
  1751 |     |             mstore(0x60, p2)
  1752 |     |         }
  1753 |     |         _sendLogPayload(0x1c, 0x64);
  1754 |     |         /// @solidity memory-safe-assembly
  1755 |     |         assembly {
  1756 |     |             mstore(0x00, m0)
  1757 |     |             mstore(0x20, m1)
  1758 |     |             mstore(0x40, m2)
  1759 |     |             mstore(0x60, m3)
  1760 |     |         }
  1761 |     |     }
  1762 |     | 
  1763 |     |     function log(uint256 p0, address p1, bool p2) internal pure {
  1764 |     |         bytes32 m0;
  1765 |     |         bytes32 m1;
  1766 |     |         bytes32 m2;
  1767 |     |         bytes32 m3;
  1768 |     |         /// @solidity memory-safe-assembly
  1769 |     |         assembly {
  1770 |     |             m0 := mload(0x00)
  1771 |     |             m1 := mload(0x20)
  1772 |     |             m2 := mload(0x40)
  1773 |     |             m3 := mload(0x60)
  1774 |     |             // Selector of `log(uint256,address,bool)`.
  1775 |     |             mstore(0x00, 0x9b6ec042)
  1776 |     |             mstore(0x20, p0)
  1777 |     |             mstore(0x40, p1)
  1778 |     |             mstore(0x60, p2)
  1779 |     |         }
  1780 |     |         _sendLogPayload(0x1c, 0x64);
  1781 |     |         /// @solidity memory-safe-assembly
  1782 |     |         assembly {
  1783 |     |             mstore(0x00, m0)
  1784 |     |             mstore(0x20, m1)
  1785 |     |             mstore(0x40, m2)
  1786 |     |             mstore(0x60, m3)
  1787 |     |         }
  1788 |     |     }
  1789 |     | 
  1790 |     |     function log(uint256 p0, address p1, uint256 p2) internal pure {
  1791 |     |         bytes32 m0;
  1792 |     |         bytes32 m1;
  1793 |     |         bytes32 m2;
  1794 |     |         bytes32 m3;
  1795 |     |         /// @solidity memory-safe-assembly
  1796 |     |         assembly {
  1797 |     |             m0 := mload(0x00)
  1798 |     |             m1 := mload(0x20)
  1799 |     |             m2 := mload(0x40)
  1800 |     |             m3 := mload(0x60)
  1801 |     |             // Selector of `log(uint256,address,uint256)`.
  1802 |     |             mstore(0x00, 0x5a9b5ed5)
  1803 |     |             mstore(0x20, p0)
  1804 |     |             mstore(0x40, p1)
  1805 |     |             mstore(0x60, p2)
  1806 |     |         }
  1807 |     |         _sendLogPayload(0x1c, 0x64);
  1808 |     |         /// @solidity memory-safe-assembly
  1809 |     |         assembly {
  1810 |     |             mstore(0x00, m0)
  1811 |     |             mstore(0x20, m1)
  1812 |     |             mstore(0x40, m2)
  1813 |     |             mstore(0x60, m3)
  1814 |     |         }
  1815 |     |     }
  1816 |     | 
  1817 |     |     function log(uint256 p0, address p1, bytes32 p2) internal pure {
  1818 |     |         bytes32 m0;
  1819 |     |         bytes32 m1;
  1820 |     |         bytes32 m2;
  1821 |     |         bytes32 m3;
  1822 |     |         bytes32 m4;
  1823 |     |         bytes32 m5;
  1824 |     |         /// @solidity memory-safe-assembly
  1825 |     |         assembly {
  1826 |     |             function writeString(pos, w) {
  1827 |     |                 let length := 0
  1828 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  1829 |     |                 mstore(pos, length)
  1830 |     |                 let shift := sub(256, shl(3, length))
  1831 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  1832 |     |             }
  1833 |     |             m0 := mload(0x00)
  1834 |     |             m1 := mload(0x20)
  1835 |     |             m2 := mload(0x40)
  1836 |     |             m3 := mload(0x60)
  1837 |     |             m4 := mload(0x80)
  1838 |     |             m5 := mload(0xa0)
  1839 |     |             // Selector of `log(uint256,address,string)`.
  1840 |     |             mstore(0x00, 0x63cb41f9)
  1841 |     |             mstore(0x20, p0)
  1842 |     |             mstore(0x40, p1)
  1843 |     |             mstore(0x60, 0x60)
  1844 |     |             writeString(0x80, p2)
  1845 |     |         }
  1846 |     |         _sendLogPayload(0x1c, 0xa4);
  1847 |     |         /// @solidity memory-safe-assembly
  1848 |     |         assembly {
  1849 |     |             mstore(0x00, m0)
  1850 |     |             mstore(0x20, m1)
  1851 |     |             mstore(0x40, m2)
  1852 |     |             mstore(0x60, m3)
  1853 |     |             mstore(0x80, m4)
  1854 |     |             mstore(0xa0, m5)
  1855 |     |         }
  1856 |     |     }
  1857 |     | 
  1858 |     |     function log(uint256 p0, bool p1, address p2) internal pure {
  1859 |     |         bytes32 m0;
  1860 |     |         bytes32 m1;
  1861 |     |         bytes32 m2;
  1862 |     |         bytes32 m3;
  1863 |     |         /// @solidity memory-safe-assembly
  1864 |     |         assembly {
  1865 |     |             m0 := mload(0x00)
  1866 |     |             m1 := mload(0x20)
  1867 |     |             m2 := mload(0x40)
  1868 |     |             m3 := mload(0x60)
  1869 |     |             // Selector of `log(uint256,bool,address)`.
  1870 |     |             mstore(0x00, 0x35085f7b)
  1871 |     |             mstore(0x20, p0)
  1872 |     |             mstore(0x40, p1)
  1873 |     |             mstore(0x60, p2)
  1874 |     |         }
  1875 |     |         _sendLogPayload(0x1c, 0x64);
  1876 |     |         /// @solidity memory-safe-assembly
  1877 |     |         assembly {
  1878 |     |             mstore(0x00, m0)
  1879 |     |             mstore(0x20, m1)
  1880 |     |             mstore(0x40, m2)
  1881 |     |             mstore(0x60, m3)
  1882 |     |         }
  1883 |     |     }
  1884 |     | 
  1885 |     |     function log(uint256 p0, bool p1, bool p2) internal pure {
  1886 |     |         bytes32 m0;
  1887 |     |         bytes32 m1;
  1888 |     |         bytes32 m2;
  1889 |     |         bytes32 m3;
  1890 |     |         /// @solidity memory-safe-assembly
  1891 |     |         assembly {
  1892 |     |             m0 := mload(0x00)
  1893 |     |             m1 := mload(0x20)
  1894 |     |             m2 := mload(0x40)
  1895 |     |             m3 := mload(0x60)
  1896 |     |             // Selector of `log(uint256,bool,bool)`.
  1897 |     |             mstore(0x00, 0x20718650)
  1898 |     |             mstore(0x20, p0)
  1899 |     |             mstore(0x40, p1)
  1900 |     |             mstore(0x60, p2)
  1901 |     |         }
  1902 |     |         _sendLogPayload(0x1c, 0x64);
  1903 |     |         /// @solidity memory-safe-assembly
  1904 |     |         assembly {
  1905 |     |             mstore(0x00, m0)
  1906 |     |             mstore(0x20, m1)
  1907 |     |             mstore(0x40, m2)
  1908 |     |             mstore(0x60, m3)
  1909 |     |         }
  1910 |     |     }
  1911 |     | 
  1912 |     |     function log(uint256 p0, bool p1, uint256 p2) internal pure {
  1913 |     |         bytes32 m0;
  1914 |     |         bytes32 m1;
  1915 |     |         bytes32 m2;
  1916 |     |         bytes32 m3;
  1917 |     |         /// @solidity memory-safe-assembly
  1918 |     |         assembly {
  1919 |     |             m0 := mload(0x00)
  1920 |     |             m1 := mload(0x20)
  1921 |     |             m2 := mload(0x40)
  1922 |     |             m3 := mload(0x60)
  1923 |     |             // Selector of `log(uint256,bool,uint256)`.
  1924 |     |             mstore(0x00, 0x20098014)
  1925 |     |             mstore(0x20, p0)
  1926 |     |             mstore(0x40, p1)
  1927 |     |             mstore(0x60, p2)
  1928 |     |         }
  1929 |     |         _sendLogPayload(0x1c, 0x64);
  1930 |     |         /// @solidity memory-safe-assembly
  1931 |     |         assembly {
  1932 |     |             mstore(0x00, m0)
  1933 |     |             mstore(0x20, m1)
  1934 |     |             mstore(0x40, m2)
  1935 |     |             mstore(0x60, m3)
  1936 |     |         }
  1937 |     |     }
  1938 |     | 
  1939 |     |     function log(uint256 p0, bool p1, bytes32 p2) internal pure {
  1940 |     |         bytes32 m0;
  1941 |     |         bytes32 m1;
  1942 |     |         bytes32 m2;
  1943 |     |         bytes32 m3;
  1944 |     |         bytes32 m4;
  1945 |     |         bytes32 m5;
  1946 |     |         /// @solidity memory-safe-assembly
  1947 |     |         assembly {
  1948 |     |             function writeString(pos, w) {
  1949 |     |                 let length := 0
  1950 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  1951 |     |                 mstore(pos, length)
  1952 |     |                 let shift := sub(256, shl(3, length))
  1953 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  1954 |     |             }
  1955 |     |             m0 := mload(0x00)
  1956 |     |             m1 := mload(0x20)
  1957 |     |             m2 := mload(0x40)
  1958 |     |             m3 := mload(0x60)
  1959 |     |             m4 := mload(0x80)
  1960 |     |             m5 := mload(0xa0)
  1961 |     |             // Selector of `log(uint256,bool,string)`.
  1962 |     |             mstore(0x00, 0x85775021)
  1963 |     |             mstore(0x20, p0)
  1964 |     |             mstore(0x40, p1)
  1965 |     |             mstore(0x60, 0x60)
  1966 |     |             writeString(0x80, p2)
  1967 |     |         }
  1968 |     |         _sendLogPayload(0x1c, 0xa4);
  1969 |     |         /// @solidity memory-safe-assembly
  1970 |     |         assembly {
  1971 |     |             mstore(0x00, m0)
  1972 |     |             mstore(0x20, m1)
  1973 |     |             mstore(0x40, m2)
  1974 |     |             mstore(0x60, m3)
  1975 |     |             mstore(0x80, m4)
  1976 |     |             mstore(0xa0, m5)
  1977 |     |         }
  1978 |     |     }
  1979 |     | 
  1980 |     |     function log(uint256 p0, uint256 p1, address p2) internal pure {
  1981 |     |         bytes32 m0;
  1982 |     |         bytes32 m1;
  1983 |     |         bytes32 m2;
  1984 |     |         bytes32 m3;
  1985 |     |         /// @solidity memory-safe-assembly
  1986 |     |         assembly {
  1987 |     |             m0 := mload(0x00)
  1988 |     |             m1 := mload(0x20)
  1989 |     |             m2 := mload(0x40)
  1990 |     |             m3 := mload(0x60)
  1991 |     |             // Selector of `log(uint256,uint256,address)`.
  1992 |     |             mstore(0x00, 0x5c96b331)
  1993 |     |             mstore(0x20, p0)
  1994 |     |             mstore(0x40, p1)
  1995 |     |             mstore(0x60, p2)
  1996 |     |         }
  1997 |     |         _sendLogPayload(0x1c, 0x64);
  1998 |     |         /// @solidity memory-safe-assembly
  1999 |     |         assembly {
  2000 |     |             mstore(0x00, m0)
  2001 |     |             mstore(0x20, m1)
  2002 |     |             mstore(0x40, m2)
  2003 |     |             mstore(0x60, m3)
  2004 |     |         }
  2005 |     |     }
  2006 |     | 
  2007 |     |     function log(uint256 p0, uint256 p1, bool p2) internal pure {
  2008 |     |         bytes32 m0;
  2009 |     |         bytes32 m1;
  2010 |     |         bytes32 m2;
  2011 |     |         bytes32 m3;
  2012 |     |         /// @solidity memory-safe-assembly
  2013 |     |         assembly {
  2014 |     |             m0 := mload(0x00)
  2015 |     |             m1 := mload(0x20)
  2016 |     |             m2 := mload(0x40)
  2017 |     |             m3 := mload(0x60)
  2018 |     |             // Selector of `log(uint256,uint256,bool)`.
  2019 |     |             mstore(0x00, 0x4766da72)
  2020 |     |             mstore(0x20, p0)
  2021 |     |             mstore(0x40, p1)
  2022 |     |             mstore(0x60, p2)
  2023 |     |         }
  2024 |     |         _sendLogPayload(0x1c, 0x64);
  2025 |     |         /// @solidity memory-safe-assembly
  2026 |     |         assembly {
  2027 |     |             mstore(0x00, m0)
  2028 |     |             mstore(0x20, m1)
  2029 |     |             mstore(0x40, m2)
  2030 |     |             mstore(0x60, m3)
  2031 |     |         }
  2032 |     |     }
  2033 |     | 
  2034 |     |     function log(uint256 p0, uint256 p1, uint256 p2) internal pure {
  2035 |     |         bytes32 m0;
  2036 |     |         bytes32 m1;
  2037 |     |         bytes32 m2;
  2038 |     |         bytes32 m3;
  2039 |     |         /// @solidity memory-safe-assembly
  2040 |     |         assembly {
  2041 |     |             m0 := mload(0x00)
  2042 |     |             m1 := mload(0x20)
  2043 |     |             m2 := mload(0x40)
  2044 |     |             m3 := mload(0x60)
  2045 |     |             // Selector of `log(uint256,uint256,uint256)`.
  2046 |     |             mstore(0x00, 0xd1ed7a3c)
  2047 |     |             mstore(0x20, p0)
  2048 |     |             mstore(0x40, p1)
  2049 |     |             mstore(0x60, p2)
  2050 |     |         }
  2051 |     |         _sendLogPayload(0x1c, 0x64);
  2052 |     |         /// @solidity memory-safe-assembly
  2053 |     |         assembly {
  2054 |     |             mstore(0x00, m0)
  2055 |     |             mstore(0x20, m1)
  2056 |     |             mstore(0x40, m2)
  2057 |     |             mstore(0x60, m3)
  2058 |     |         }
  2059 |     |     }
  2060 |     | 
  2061 |     |     function log(uint256 p0, uint256 p1, bytes32 p2) internal pure {
  2062 |     |         bytes32 m0;
  2063 |     |         bytes32 m1;
  2064 |     |         bytes32 m2;
  2065 |     |         bytes32 m3;
  2066 |     |         bytes32 m4;
  2067 |     |         bytes32 m5;
  2068 |     |         /// @solidity memory-safe-assembly
  2069 |     |         assembly {
  2070 |     |             function writeString(pos, w) {
  2071 |     |                 let length := 0
  2072 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  2073 |     |                 mstore(pos, length)
  2074 |     |                 let shift := sub(256, shl(3, length))
  2075 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  2076 |     |             }
  2077 |     |             m0 := mload(0x00)
  2078 |     |             m1 := mload(0x20)
  2079 |     |             m2 := mload(0x40)
  2080 |     |             m3 := mload(0x60)
  2081 |     |             m4 := mload(0x80)
  2082 |     |             m5 := mload(0xa0)
  2083 |     |             // Selector of `log(uint256,uint256,string)`.
  2084 |     |             mstore(0x00, 0x71d04af2)
  2085 |     |             mstore(0x20, p0)
  2086 |     |             mstore(0x40, p1)
  2087 |     |             mstore(0x60, 0x60)
  2088 |     |             writeString(0x80, p2)
  2089 |     |         }
  2090 |     |         _sendLogPayload(0x1c, 0xa4);
  2091 |     |         /// @solidity memory-safe-assembly
  2092 |     |         assembly {
  2093 |     |             mstore(0x00, m0)
  2094 |     |             mstore(0x20, m1)
  2095 |     |             mstore(0x40, m2)
  2096 |     |             mstore(0x60, m3)
  2097 |     |             mstore(0x80, m4)
  2098 |     |             mstore(0xa0, m5)
  2099 |     |         }
  2100 |     |     }
  2101 |     | 
  2102 |     |     function log(uint256 p0, bytes32 p1, address p2) internal pure {
  2103 |     |         bytes32 m0;
  2104 |     |         bytes32 m1;
  2105 |     |         bytes32 m2;
  2106 |     |         bytes32 m3;
  2107 |     |         bytes32 m4;
  2108 |     |         bytes32 m5;
  2109 |     |         /// @solidity memory-safe-assembly
  2110 |     |         assembly {
  2111 |     |             function writeString(pos, w) {
  2112 |     |                 let length := 0
  2113 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  2114 |     |                 mstore(pos, length)
  2115 |     |                 let shift := sub(256, shl(3, length))
  2116 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  2117 |     |             }
  2118 |     |             m0 := mload(0x00)
  2119 |     |             m1 := mload(0x20)
  2120 |     |             m2 := mload(0x40)
  2121 |     |             m3 := mload(0x60)
  2122 |     |             m4 := mload(0x80)
  2123 |     |             m5 := mload(0xa0)
  2124 |     |             // Selector of `log(uint256,string,address)`.
  2125 |     |             mstore(0x00, 0x7afac959)
  2126 |     |             mstore(0x20, p0)
  2127 |     |             mstore(0x40, 0x60)
  2128 |     |             mstore(0x60, p2)
  2129 |     |             writeString(0x80, p1)
  2130 |     |         }
  2131 |     |         _sendLogPayload(0x1c, 0xa4);
  2132 |     |         /// @solidity memory-safe-assembly
  2133 |     |         assembly {
  2134 |     |             mstore(0x00, m0)
  2135 |     |             mstore(0x20, m1)
  2136 |     |             mstore(0x40, m2)
  2137 |     |             mstore(0x60, m3)
  2138 |     |             mstore(0x80, m4)
  2139 |     |             mstore(0xa0, m5)
  2140 |     |         }
  2141 |     |     }
  2142 |     | 
  2143 |     |     function log(uint256 p0, bytes32 p1, bool p2) internal pure {
  2144 |     |         bytes32 m0;
  2145 |     |         bytes32 m1;
  2146 |     |         bytes32 m2;
  2147 |     |         bytes32 m3;
  2148 |     |         bytes32 m4;
  2149 |     |         bytes32 m5;
  2150 |     |         /// @solidity memory-safe-assembly
  2151 |     |         assembly {
  2152 |     |             function writeString(pos, w) {
  2153 |     |                 let length := 0
  2154 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  2155 |     |                 mstore(pos, length)
  2156 |     |                 let shift := sub(256, shl(3, length))
  2157 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  2158 |     |             }
  2159 |     |             m0 := mload(0x00)
  2160 |     |             m1 := mload(0x20)
  2161 |     |             m2 := mload(0x40)
  2162 |     |             m3 := mload(0x60)
  2163 |     |             m4 := mload(0x80)
  2164 |     |             m5 := mload(0xa0)
  2165 |     |             // Selector of `log(uint256,string,bool)`.
  2166 |     |             mstore(0x00, 0x4ceda75a)
  2167 |     |             mstore(0x20, p0)
  2168 |     |             mstore(0x40, 0x60)
  2169 |     |             mstore(0x60, p2)
  2170 |     |             writeString(0x80, p1)
  2171 |     |         }
  2172 |     |         _sendLogPayload(0x1c, 0xa4);
  2173 |     |         /// @solidity memory-safe-assembly
  2174 |     |         assembly {
  2175 |     |             mstore(0x00, m0)
  2176 |     |             mstore(0x20, m1)
  2177 |     |             mstore(0x40, m2)
  2178 |     |             mstore(0x60, m3)
  2179 |     |             mstore(0x80, m4)
  2180 |     |             mstore(0xa0, m5)
  2181 |     |         }
  2182 |     |     }
  2183 |     | 
  2184 |     |     function log(uint256 p0, bytes32 p1, uint256 p2) internal pure {
  2185 |     |         bytes32 m0;
  2186 |     |         bytes32 m1;
  2187 |     |         bytes32 m2;
  2188 |     |         bytes32 m3;
  2189 |     |         bytes32 m4;
  2190 |     |         bytes32 m5;
  2191 |     |         /// @solidity memory-safe-assembly
  2192 |     |         assembly {
  2193 |     |             function writeString(pos, w) {
  2194 |     |                 let length := 0
  2195 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  2196 |     |                 mstore(pos, length)
  2197 |     |                 let shift := sub(256, shl(3, length))
  2198 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  2199 |     |             }
  2200 |     |             m0 := mload(0x00)
  2201 |     |             m1 := mload(0x20)
  2202 |     |             m2 := mload(0x40)
  2203 |     |             m3 := mload(0x60)
  2204 |     |             m4 := mload(0x80)
  2205 |     |             m5 := mload(0xa0)
  2206 |     |             // Selector of `log(uint256,string,uint256)`.
  2207 |     |             mstore(0x00, 0x37aa7d4c)
  2208 |     |             mstore(0x20, p0)
  2209 |     |             mstore(0x40, 0x60)
  2210 |     |             mstore(0x60, p2)
  2211 |     |             writeString(0x80, p1)
  2212 |     |         }
  2213 |     |         _sendLogPayload(0x1c, 0xa4);
  2214 |     |         /// @solidity memory-safe-assembly
  2215 |     |         assembly {
  2216 |     |             mstore(0x00, m0)
  2217 |     |             mstore(0x20, m1)
  2218 |     |             mstore(0x40, m2)
  2219 |     |             mstore(0x60, m3)
  2220 |     |             mstore(0x80, m4)
  2221 |     |             mstore(0xa0, m5)
  2222 |     |         }
  2223 |     |     }
  2224 |     | 
  2225 |     |     function log(uint256 p0, bytes32 p1, bytes32 p2) internal pure {
  2226 |     |         bytes32 m0;
  2227 |     |         bytes32 m1;
  2228 |     |         bytes32 m2;
  2229 |     |         bytes32 m3;
  2230 |     |         bytes32 m4;
  2231 |     |         bytes32 m5;
  2232 |     |         bytes32 m6;
  2233 |     |         bytes32 m7;
  2234 |     |         /// @solidity memory-safe-assembly
  2235 |     |         assembly {
  2236 |     |             function writeString(pos, w) {
  2237 |     |                 let length := 0
  2238 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  2239 |     |                 mstore(pos, length)
  2240 |     |                 let shift := sub(256, shl(3, length))
  2241 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  2242 |     |             }
  2243 |     |             m0 := mload(0x00)
  2244 |     |             m1 := mload(0x20)
  2245 |     |             m2 := mload(0x40)
  2246 |     |             m3 := mload(0x60)
  2247 |     |             m4 := mload(0x80)
  2248 |     |             m5 := mload(0xa0)
  2249 |     |             m6 := mload(0xc0)
  2250 |     |             m7 := mload(0xe0)
  2251 |     |             // Selector of `log(uint256,string,string)`.
  2252 |     |             mstore(0x00, 0xb115611f)
  2253 |     |             mstore(0x20, p0)
  2254 |     |             mstore(0x40, 0x60)
  2255 |     |             mstore(0x60, 0xa0)
  2256 |     |             writeString(0x80, p1)
  2257 |     |             writeString(0xc0, p2)
  2258 |     |         }
  2259 |     |         _sendLogPayload(0x1c, 0xe4);
  2260 |     |         /// @solidity memory-safe-assembly
  2261 |     |         assembly {
  2262 |     |             mstore(0x00, m0)
  2263 |     |             mstore(0x20, m1)
  2264 |     |             mstore(0x40, m2)
  2265 |     |             mstore(0x60, m3)
  2266 |     |             mstore(0x80, m4)
  2267 |     |             mstore(0xa0, m5)
  2268 |     |             mstore(0xc0, m6)
  2269 |     |             mstore(0xe0, m7)
  2270 |     |         }
  2271 |     |     }
  2272 |     | 
  2273 |     |     function log(bytes32 p0, address p1, address p2) internal pure {
  2274 |     |         bytes32 m0;
  2275 |     |         bytes32 m1;
  2276 |     |         bytes32 m2;
  2277 |     |         bytes32 m3;
  2278 |     |         bytes32 m4;
  2279 |     |         bytes32 m5;
  2280 |     |         /// @solidity memory-safe-assembly
  2281 |     |         assembly {
  2282 |     |             function writeString(pos, w) {
  2283 |     |                 let length := 0
  2284 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  2285 |     |                 mstore(pos, length)
  2286 |     |                 let shift := sub(256, shl(3, length))
  2287 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  2288 |     |             }
  2289 |     |             m0 := mload(0x00)
  2290 |     |             m1 := mload(0x20)
  2291 |     |             m2 := mload(0x40)
  2292 |     |             m3 := mload(0x60)
  2293 |     |             m4 := mload(0x80)
  2294 |     |             m5 := mload(0xa0)
  2295 |     |             // Selector of `log(string,address,address)`.
  2296 |     |             mstore(0x00, 0xfcec75e0)
  2297 |     |             mstore(0x20, 0x60)
  2298 |     |             mstore(0x40, p1)
  2299 |     |             mstore(0x60, p2)
  2300 |     |             writeString(0x80, p0)
  2301 |     |         }
  2302 |     |         _sendLogPayload(0x1c, 0xa4);
  2303 |     |         /// @solidity memory-safe-assembly
  2304 |     |         assembly {
  2305 |     |             mstore(0x00, m0)
  2306 |     |             mstore(0x20, m1)
  2307 |     |             mstore(0x40, m2)
  2308 |     |             mstore(0x60, m3)
  2309 |     |             mstore(0x80, m4)
  2310 |     |             mstore(0xa0, m5)
  2311 |     |         }
  2312 |     |     }
  2313 |     | 
  2314 |     |     function log(bytes32 p0, address p1, bool p2) internal pure {
  2315 |     |         bytes32 m0;
  2316 |     |         bytes32 m1;
  2317 |     |         bytes32 m2;
  2318 |     |         bytes32 m3;
  2319 |     |         bytes32 m4;
  2320 |     |         bytes32 m5;
  2321 |     |         /// @solidity memory-safe-assembly
  2322 |     |         assembly {
  2323 |     |             function writeString(pos, w) {
  2324 |     |                 let length := 0
  2325 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  2326 |     |                 mstore(pos, length)
  2327 |     |                 let shift := sub(256, shl(3, length))
  2328 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  2329 |     |             }
  2330 |     |             m0 := mload(0x00)
  2331 |     |             m1 := mload(0x20)
  2332 |     |             m2 := mload(0x40)
  2333 |     |             m3 := mload(0x60)
  2334 |     |             m4 := mload(0x80)
  2335 |     |             m5 := mload(0xa0)
  2336 |     |             // Selector of `log(string,address,bool)`.
  2337 |     |             mstore(0x00, 0xc91d5ed4)
  2338 |     |             mstore(0x20, 0x60)
  2339 |     |             mstore(0x40, p1)
  2340 |     |             mstore(0x60, p2)
  2341 |     |             writeString(0x80, p0)
  2342 |     |         }
  2343 |     |         _sendLogPayload(0x1c, 0xa4);
  2344 |     |         /// @solidity memory-safe-assembly
  2345 |     |         assembly {
  2346 |     |             mstore(0x00, m0)
  2347 |     |             mstore(0x20, m1)
  2348 |     |             mstore(0x40, m2)
  2349 |     |             mstore(0x60, m3)
  2350 |     |             mstore(0x80, m4)
  2351 |     |             mstore(0xa0, m5)
  2352 |     |         }
  2353 |     |     }
  2354 |     | 
  2355 |     |     function log(bytes32 p0, address p1, uint256 p2) internal pure {
  2356 |     |         bytes32 m0;
  2357 |     |         bytes32 m1;
  2358 |     |         bytes32 m2;
  2359 |     |         bytes32 m3;
  2360 |     |         bytes32 m4;
  2361 |     |         bytes32 m5;
  2362 |     |         /// @solidity memory-safe-assembly
  2363 |     |         assembly {
  2364 |     |             function writeString(pos, w) {
  2365 |     |                 let length := 0
  2366 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  2367 |     |                 mstore(pos, length)
  2368 |     |                 let shift := sub(256, shl(3, length))
  2369 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  2370 |     |             }
  2371 |     |             m0 := mload(0x00)
  2372 |     |             m1 := mload(0x20)
  2373 |     |             m2 := mload(0x40)
  2374 |     |             m3 := mload(0x60)
  2375 |     |             m4 := mload(0x80)
  2376 |     |             m5 := mload(0xa0)
  2377 |     |             // Selector of `log(string,address,uint256)`.
  2378 |     |             mstore(0x00, 0x0d26b925)
  2379 |     |             mstore(0x20, 0x60)
  2380 |     |             mstore(0x40, p1)
  2381 |     |             mstore(0x60, p2)
  2382 |     |             writeString(0x80, p0)
  2383 |     |         }
  2384 |     |         _sendLogPayload(0x1c, 0xa4);
  2385 |     |         /// @solidity memory-safe-assembly
  2386 |     |         assembly {
  2387 |     |             mstore(0x00, m0)
  2388 |     |             mstore(0x20, m1)
  2389 |     |             mstore(0x40, m2)
  2390 |     |             mstore(0x60, m3)
  2391 |     |             mstore(0x80, m4)
  2392 |     |             mstore(0xa0, m5)
  2393 |     |         }
  2394 |     |     }
  2395 |     | 
  2396 |     |     function log(bytes32 p0, address p1, bytes32 p2) internal pure {
  2397 |     |         bytes32 m0;
  2398 |     |         bytes32 m1;
  2399 |     |         bytes32 m2;
  2400 |     |         bytes32 m3;
  2401 |     |         bytes32 m4;
  2402 |     |         bytes32 m5;
  2403 |     |         bytes32 m6;
  2404 |     |         bytes32 m7;
  2405 |     |         /// @solidity memory-safe-assembly
  2406 |     |         assembly {
  2407 |     |             function writeString(pos, w) {
  2408 |     |                 let length := 0
  2409 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  2410 |     |                 mstore(pos, length)
  2411 |     |                 let shift := sub(256, shl(3, length))
  2412 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  2413 |     |             }
  2414 |     |             m0 := mload(0x00)
  2415 |     |             m1 := mload(0x20)
  2416 |     |             m2 := mload(0x40)
  2417 |     |             m3 := mload(0x60)
  2418 |     |             m4 := mload(0x80)
  2419 |     |             m5 := mload(0xa0)
  2420 |     |             m6 := mload(0xc0)
  2421 |     |             m7 := mload(0xe0)
  2422 |     |             // Selector of `log(string,address,string)`.
  2423 |     |             mstore(0x00, 0xe0e9ad4f)
  2424 |     |             mstore(0x20, 0x60)
  2425 |     |             mstore(0x40, p1)
  2426 |     |             mstore(0x60, 0xa0)
  2427 |     |             writeString(0x80, p0)
  2428 |     |             writeString(0xc0, p2)
  2429 |     |         }
  2430 |     |         _sendLogPayload(0x1c, 0xe4);
  2431 |     |         /// @solidity memory-safe-assembly
  2432 |     |         assembly {
  2433 |     |             mstore(0x00, m0)
  2434 |     |             mstore(0x20, m1)
  2435 |     |             mstore(0x40, m2)
  2436 |     |             mstore(0x60, m3)
  2437 |     |             mstore(0x80, m4)
  2438 |     |             mstore(0xa0, m5)
  2439 |     |             mstore(0xc0, m6)
  2440 |     |             mstore(0xe0, m7)
  2441 |     |         }
  2442 |     |     }
  2443 |     | 
  2444 |     |     function log(bytes32 p0, bool p1, address p2) internal pure {
  2445 |     |         bytes32 m0;
  2446 |     |         bytes32 m1;
  2447 |     |         bytes32 m2;
  2448 |     |         bytes32 m3;
  2449 |     |         bytes32 m4;
  2450 |     |         bytes32 m5;
  2451 |     |         /// @solidity memory-safe-assembly
  2452 |     |         assembly {
  2453 |     |             function writeString(pos, w) {
  2454 |     |                 let length := 0
  2455 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  2456 |     |                 mstore(pos, length)
  2457 |     |                 let shift := sub(256, shl(3, length))
  2458 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  2459 |     |             }
  2460 |     |             m0 := mload(0x00)
  2461 |     |             m1 := mload(0x20)
  2462 |     |             m2 := mload(0x40)
  2463 |     |             m3 := mload(0x60)
  2464 |     |             m4 := mload(0x80)
  2465 |     |             m5 := mload(0xa0)
  2466 |     |             // Selector of `log(string,bool,address)`.
  2467 |     |             mstore(0x00, 0x932bbb38)
  2468 |     |             mstore(0x20, 0x60)
  2469 |     |             mstore(0x40, p1)
  2470 |     |             mstore(0x60, p2)
  2471 |     |             writeString(0x80, p0)
  2472 |     |         }
  2473 |     |         _sendLogPayload(0x1c, 0xa4);
  2474 |     |         /// @solidity memory-safe-assembly
  2475 |     |         assembly {
  2476 |     |             mstore(0x00, m0)
  2477 |     |             mstore(0x20, m1)
  2478 |     |             mstore(0x40, m2)
  2479 |     |             mstore(0x60, m3)
  2480 |     |             mstore(0x80, m4)
  2481 |     |             mstore(0xa0, m5)
  2482 |     |         }
  2483 |     |     }
  2484 |     | 
  2485 |     |     function log(bytes32 p0, bool p1, bool p2) internal pure {
  2486 |     |         bytes32 m0;
  2487 |     |         bytes32 m1;
  2488 |     |         bytes32 m2;
  2489 |     |         bytes32 m3;
  2490 |     |         bytes32 m4;
  2491 |     |         bytes32 m5;
  2492 |     |         /// @solidity memory-safe-assembly
  2493 |     |         assembly {
  2494 |     |             function writeString(pos, w) {
  2495 |     |                 let length := 0
  2496 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  2497 |     |                 mstore(pos, length)
  2498 |     |                 let shift := sub(256, shl(3, length))
  2499 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  2500 |     |             }
  2501 |     |             m0 := mload(0x00)
  2502 |     |             m1 := mload(0x20)
  2503 |     |             m2 := mload(0x40)
  2504 |     |             m3 := mload(0x60)
  2505 |     |             m4 := mload(0x80)
  2506 |     |             m5 := mload(0xa0)
  2507 |     |             // Selector of `log(string,bool,bool)`.
  2508 |     |             mstore(0x00, 0x850b7ad6)
  2509 |     |             mstore(0x20, 0x60)
  2510 |     |             mstore(0x40, p1)
  2511 |     |             mstore(0x60, p2)
  2512 |     |             writeString(0x80, p0)
  2513 |     |         }
  2514 |     |         _sendLogPayload(0x1c, 0xa4);
  2515 |     |         /// @solidity memory-safe-assembly
  2516 |     |         assembly {
  2517 |     |             mstore(0x00, m0)
  2518 |     |             mstore(0x20, m1)
  2519 |     |             mstore(0x40, m2)
  2520 |     |             mstore(0x60, m3)
  2521 |     |             mstore(0x80, m4)
  2522 |     |             mstore(0xa0, m5)
  2523 |     |         }
  2524 |     |     }
  2525 |     | 
  2526 |     |     function log(bytes32 p0, bool p1, uint256 p2) internal pure {
  2527 |     |         bytes32 m0;
  2528 |     |         bytes32 m1;
  2529 |     |         bytes32 m2;
  2530 |     |         bytes32 m3;
  2531 |     |         bytes32 m4;
  2532 |     |         bytes32 m5;
  2533 |     |         /// @solidity memory-safe-assembly
  2534 |     |         assembly {
  2535 |     |             function writeString(pos, w) {
  2536 |     |                 let length := 0
  2537 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  2538 |     |                 mstore(pos, length)
  2539 |     |                 let shift := sub(256, shl(3, length))
  2540 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  2541 |     |             }
  2542 |     |             m0 := mload(0x00)
  2543 |     |             m1 := mload(0x20)
  2544 |     |             m2 := mload(0x40)
  2545 |     |             m3 := mload(0x60)
  2546 |     |             m4 := mload(0x80)
  2547 |     |             m5 := mload(0xa0)
  2548 |     |             // Selector of `log(string,bool,uint256)`.
  2549 |     |             mstore(0x00, 0xc95958d6)
  2550 |     |             mstore(0x20, 0x60)
  2551 |     |             mstore(0x40, p1)
  2552 |     |             mstore(0x60, p2)
  2553 |     |             writeString(0x80, p0)
  2554 |     |         }
  2555 |     |         _sendLogPayload(0x1c, 0xa4);
  2556 |     |         /// @solidity memory-safe-assembly
  2557 |     |         assembly {
  2558 |     |             mstore(0x00, m0)
  2559 |     |             mstore(0x20, m1)
  2560 |     |             mstore(0x40, m2)
  2561 |     |             mstore(0x60, m3)
  2562 |     |             mstore(0x80, m4)
  2563 |     |             mstore(0xa0, m5)
  2564 |     |         }
  2565 |     |     }
  2566 |     | 
  2567 |     |     function log(bytes32 p0, bool p1, bytes32 p2) internal pure {
  2568 |     |         bytes32 m0;
  2569 |     |         bytes32 m1;
  2570 |     |         bytes32 m2;
  2571 |     |         bytes32 m3;
  2572 |     |         bytes32 m4;
  2573 |     |         bytes32 m5;
  2574 |     |         bytes32 m6;
  2575 |     |         bytes32 m7;
  2576 |     |         /// @solidity memory-safe-assembly
  2577 |     |         assembly {
  2578 |     |             function writeString(pos, w) {
  2579 |     |                 let length := 0
  2580 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  2581 |     |                 mstore(pos, length)
  2582 |     |                 let shift := sub(256, shl(3, length))
  2583 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  2584 |     |             }
  2585 |     |             m0 := mload(0x00)
  2586 |     |             m1 := mload(0x20)
  2587 |     |             m2 := mload(0x40)
  2588 |     |             m3 := mload(0x60)
  2589 |     |             m4 := mload(0x80)
  2590 |     |             m5 := mload(0xa0)
  2591 |     |             m6 := mload(0xc0)
  2592 |     |             m7 := mload(0xe0)
  2593 |     |             // Selector of `log(string,bool,string)`.
  2594 |     |             mstore(0x00, 0xe298f47d)
  2595 |     |             mstore(0x20, 0x60)
  2596 |     |             mstore(0x40, p1)
  2597 |     |             mstore(0x60, 0xa0)
  2598 |     |             writeString(0x80, p0)
  2599 |     |             writeString(0xc0, p2)
  2600 |     |         }
  2601 |     |         _sendLogPayload(0x1c, 0xe4);
  2602 |     |         /// @solidity memory-safe-assembly
  2603 |     |         assembly {
  2604 |     |             mstore(0x00, m0)
  2605 |     |             mstore(0x20, m1)
  2606 |     |             mstore(0x40, m2)
  2607 |     |             mstore(0x60, m3)
  2608 |     |             mstore(0x80, m4)
  2609 |     |             mstore(0xa0, m5)
  2610 |     |             mstore(0xc0, m6)
  2611 |     |             mstore(0xe0, m7)
  2612 |     |         }
  2613 |     |     }
  2614 |     | 
  2615 |     |     function log(bytes32 p0, uint256 p1, address p2) internal pure {
  2616 |     |         bytes32 m0;
  2617 |     |         bytes32 m1;
  2618 |     |         bytes32 m2;
  2619 |     |         bytes32 m3;
  2620 |     |         bytes32 m4;
  2621 |     |         bytes32 m5;
  2622 |     |         /// @solidity memory-safe-assembly
  2623 |     |         assembly {
  2624 |     |             function writeString(pos, w) {
  2625 |     |                 let length := 0
  2626 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  2627 |     |                 mstore(pos, length)
  2628 |     |                 let shift := sub(256, shl(3, length))
  2629 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  2630 |     |             }
  2631 |     |             m0 := mload(0x00)
  2632 |     |             m1 := mload(0x20)
  2633 |     |             m2 := mload(0x40)
  2634 |     |             m3 := mload(0x60)
  2635 |     |             m4 := mload(0x80)
  2636 |     |             m5 := mload(0xa0)
  2637 |     |             // Selector of `log(string,uint256,address)`.
  2638 |     |             mstore(0x00, 0x1c7ec448)
  2639 |     |             mstore(0x20, 0x60)
  2640 |     |             mstore(0x40, p1)
  2641 |     |             mstore(0x60, p2)
  2642 |     |             writeString(0x80, p0)
  2643 |     |         }
  2644 |     |         _sendLogPayload(0x1c, 0xa4);
  2645 |     |         /// @solidity memory-safe-assembly
  2646 |     |         assembly {
  2647 |     |             mstore(0x00, m0)
  2648 |     |             mstore(0x20, m1)
  2649 |     |             mstore(0x40, m2)
  2650 |     |             mstore(0x60, m3)
  2651 |     |             mstore(0x80, m4)
  2652 |     |             mstore(0xa0, m5)
  2653 |     |         }
  2654 |     |     }
  2655 |     | 
  2656 |     |     function log(bytes32 p0, uint256 p1, bool p2) internal pure {
  2657 |     |         bytes32 m0;
  2658 |     |         bytes32 m1;
  2659 |     |         bytes32 m2;
  2660 |     |         bytes32 m3;
  2661 |     |         bytes32 m4;
  2662 |     |         bytes32 m5;
  2663 |     |         /// @solidity memory-safe-assembly
  2664 |     |         assembly {
  2665 |     |             function writeString(pos, w) {
  2666 |     |                 let length := 0
  2667 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  2668 |     |                 mstore(pos, length)
  2669 |     |                 let shift := sub(256, shl(3, length))
  2670 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  2671 |     |             }
  2672 |     |             m0 := mload(0x00)
  2673 |     |             m1 := mload(0x20)
  2674 |     |             m2 := mload(0x40)
  2675 |     |             m3 := mload(0x60)
  2676 |     |             m4 := mload(0x80)
  2677 |     |             m5 := mload(0xa0)
  2678 |     |             // Selector of `log(string,uint256,bool)`.
  2679 |     |             mstore(0x00, 0xca7733b1)
  2680 |     |             mstore(0x20, 0x60)
  2681 |     |             mstore(0x40, p1)
  2682 |     |             mstore(0x60, p2)
  2683 |     |             writeString(0x80, p0)
  2684 |     |         }
  2685 |     |         _sendLogPayload(0x1c, 0xa4);
  2686 |     |         /// @solidity memory-safe-assembly
  2687 |     |         assembly {
  2688 |     |             mstore(0x00, m0)
  2689 |     |             mstore(0x20, m1)
  2690 |     |             mstore(0x40, m2)
  2691 |     |             mstore(0x60, m3)
  2692 |     |             mstore(0x80, m4)
  2693 |     |             mstore(0xa0, m5)
  2694 |     |         }
  2695 |     |     }
  2696 |     | 
  2697 |     |     function log(bytes32 p0, uint256 p1, uint256 p2) internal pure {
  2698 |     |         bytes32 m0;
  2699 |     |         bytes32 m1;
  2700 |     |         bytes32 m2;
  2701 |     |         bytes32 m3;
  2702 |     |         bytes32 m4;
  2703 |     |         bytes32 m5;
  2704 |     |         /// @solidity memory-safe-assembly
  2705 |     |         assembly {
  2706 |     |             function writeString(pos, w) {
  2707 |     |                 let length := 0
  2708 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  2709 |     |                 mstore(pos, length)
  2710 |     |                 let shift := sub(256, shl(3, length))
  2711 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  2712 |     |             }
  2713 |     |             m0 := mload(0x00)
  2714 |     |             m1 := mload(0x20)
  2715 |     |             m2 := mload(0x40)
  2716 |     |             m3 := mload(0x60)
  2717 |     |             m4 := mload(0x80)
  2718 |     |             m5 := mload(0xa0)
  2719 |     |             // Selector of `log(string,uint256,uint256)`.
  2720 |     |             mstore(0x00, 0xca47c4eb)
  2721 |     |             mstore(0x20, 0x60)
  2722 |     |             mstore(0x40, p1)
  2723 |     |             mstore(0x60, p2)
  2724 |     |             writeString(0x80, p0)
  2725 |     |         }
  2726 |     |         _sendLogPayload(0x1c, 0xa4);
  2727 |     |         /// @solidity memory-safe-assembly
  2728 |     |         assembly {
  2729 |     |             mstore(0x00, m0)
  2730 |     |             mstore(0x20, m1)
  2731 |     |             mstore(0x40, m2)
  2732 |     |             mstore(0x60, m3)
  2733 |     |             mstore(0x80, m4)
  2734 |     |             mstore(0xa0, m5)
  2735 |     |         }
  2736 |     |     }
  2737 |     | 
  2738 |     |     function log(bytes32 p0, uint256 p1, bytes32 p2) internal pure {
  2739 |     |         bytes32 m0;
  2740 |     |         bytes32 m1;
  2741 |     |         bytes32 m2;
  2742 |     |         bytes32 m3;
  2743 |     |         bytes32 m4;
  2744 |     |         bytes32 m5;
  2745 |     |         bytes32 m6;
  2746 |     |         bytes32 m7;
  2747 |     |         /// @solidity memory-safe-assembly
  2748 |     |         assembly {
  2749 |     |             function writeString(pos, w) {
  2750 |     |                 let length := 0
  2751 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  2752 |     |                 mstore(pos, length)
  2753 |     |                 let shift := sub(256, shl(3, length))
  2754 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  2755 |     |             }
  2756 |     |             m0 := mload(0x00)
  2757 |     |             m1 := mload(0x20)
  2758 |     |             m2 := mload(0x40)
  2759 |     |             m3 := mload(0x60)
  2760 |     |             m4 := mload(0x80)
  2761 |     |             m5 := mload(0xa0)
  2762 |     |             m6 := mload(0xc0)
  2763 |     |             m7 := mload(0xe0)
  2764 |     |             // Selector of `log(string,uint256,string)`.
  2765 |     |             mstore(0x00, 0x5970e089)
  2766 |     |             mstore(0x20, 0x60)
  2767 |     |             mstore(0x40, p1)
  2768 |     |             mstore(0x60, 0xa0)
  2769 |     |             writeString(0x80, p0)
  2770 |     |             writeString(0xc0, p2)
  2771 |     |         }
  2772 |     |         _sendLogPayload(0x1c, 0xe4);
  2773 |     |         /// @solidity memory-safe-assembly
  2774 |     |         assembly {
  2775 |     |             mstore(0x00, m0)
  2776 |     |             mstore(0x20, m1)
  2777 |     |             mstore(0x40, m2)
  2778 |     |             mstore(0x60, m3)
  2779 |     |             mstore(0x80, m4)
  2780 |     |             mstore(0xa0, m5)
  2781 |     |             mstore(0xc0, m6)
  2782 |     |             mstore(0xe0, m7)
  2783 |     |         }
  2784 |     |     }
  2785 |     | 
  2786 |     |     function log(bytes32 p0, bytes32 p1, address p2) internal pure {
  2787 |     |         bytes32 m0;
  2788 |     |         bytes32 m1;
  2789 |     |         bytes32 m2;
  2790 |     |         bytes32 m3;
  2791 |     |         bytes32 m4;
  2792 |     |         bytes32 m5;
  2793 |     |         bytes32 m6;
  2794 |     |         bytes32 m7;
  2795 |     |         /// @solidity memory-safe-assembly
  2796 |     |         assembly {
  2797 |     |             function writeString(pos, w) {
  2798 |     |                 let length := 0
  2799 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  2800 |     |                 mstore(pos, length)
  2801 |     |                 let shift := sub(256, shl(3, length))
  2802 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  2803 |     |             }
  2804 |     |             m0 := mload(0x00)
  2805 |     |             m1 := mload(0x20)
  2806 |     |             m2 := mload(0x40)
  2807 |     |             m3 := mload(0x60)
  2808 |     |             m4 := mload(0x80)
  2809 |     |             m5 := mload(0xa0)
  2810 |     |             m6 := mload(0xc0)
  2811 |     |             m7 := mload(0xe0)
  2812 |     |             // Selector of `log(string,string,address)`.
  2813 |     |             mstore(0x00, 0x95ed0195)
  2814 |     |             mstore(0x20, 0x60)
  2815 |     |             mstore(0x40, 0xa0)
  2816 |     |             mstore(0x60, p2)
  2817 |     |             writeString(0x80, p0)
  2818 |     |             writeString(0xc0, p1)
  2819 |     |         }
  2820 |     |         _sendLogPayload(0x1c, 0xe4);
  2821 |     |         /// @solidity memory-safe-assembly
  2822 |     |         assembly {
  2823 |     |             mstore(0x00, m0)
  2824 |     |             mstore(0x20, m1)
  2825 |     |             mstore(0x40, m2)
  2826 |     |             mstore(0x60, m3)
  2827 |     |             mstore(0x80, m4)
  2828 |     |             mstore(0xa0, m5)
  2829 |     |             mstore(0xc0, m6)
  2830 |     |             mstore(0xe0, m7)
  2831 |     |         }
  2832 |     |     }
  2833 |     | 
  2834 |     |     function log(bytes32 p0, bytes32 p1, bool p2) internal pure {
  2835 |     |         bytes32 m0;
  2836 |     |         bytes32 m1;
  2837 |     |         bytes32 m2;
  2838 |     |         bytes32 m3;
  2839 |     |         bytes32 m4;
  2840 |     |         bytes32 m5;
  2841 |     |         bytes32 m6;
  2842 |     |         bytes32 m7;
  2843 |     |         /// @solidity memory-safe-assembly
  2844 |     |         assembly {
  2845 |     |             function writeString(pos, w) {
  2846 |     |                 let length := 0
  2847 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  2848 |     |                 mstore(pos, length)
  2849 |     |                 let shift := sub(256, shl(3, length))
  2850 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  2851 |     |             }
  2852 |     |             m0 := mload(0x00)
  2853 |     |             m1 := mload(0x20)
  2854 |     |             m2 := mload(0x40)
  2855 |     |             m3 := mload(0x60)
  2856 |     |             m4 := mload(0x80)
  2857 |     |             m5 := mload(0xa0)
  2858 |     |             m6 := mload(0xc0)
  2859 |     |             m7 := mload(0xe0)
  2860 |     |             // Selector of `log(string,string,bool)`.
  2861 |     |             mstore(0x00, 0xb0e0f9b5)
  2862 |     |             mstore(0x20, 0x60)
  2863 |     |             mstore(0x40, 0xa0)
  2864 |     |             mstore(0x60, p2)
  2865 |     |             writeString(0x80, p0)
  2866 |     |             writeString(0xc0, p1)
  2867 |     |         }
  2868 |     |         _sendLogPayload(0x1c, 0xe4);
  2869 |     |         /// @solidity memory-safe-assembly
  2870 |     |         assembly {
  2871 |     |             mstore(0x00, m0)
  2872 |     |             mstore(0x20, m1)
  2873 |     |             mstore(0x40, m2)
  2874 |     |             mstore(0x60, m3)
  2875 |     |             mstore(0x80, m4)
  2876 |     |             mstore(0xa0, m5)
  2877 |     |             mstore(0xc0, m6)
  2878 |     |             mstore(0xe0, m7)
  2879 |     |         }
  2880 |     |     }
  2881 |     | 
  2882 |     |     function log(bytes32 p0, bytes32 p1, uint256 p2) internal pure {
  2883 |     |         bytes32 m0;
  2884 |     |         bytes32 m1;
  2885 |     |         bytes32 m2;
  2886 |     |         bytes32 m3;
  2887 |     |         bytes32 m4;
  2888 |     |         bytes32 m5;
  2889 |     |         bytes32 m6;
  2890 |     |         bytes32 m7;
  2891 |     |         /// @solidity memory-safe-assembly
  2892 |     |         assembly {
  2893 |     |             function writeString(pos, w) {
  2894 |     |                 let length := 0
  2895 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  2896 |     |                 mstore(pos, length)
  2897 |     |                 let shift := sub(256, shl(3, length))
  2898 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  2899 |     |             }
  2900 |     |             m0 := mload(0x00)
  2901 |     |             m1 := mload(0x20)
  2902 |     |             m2 := mload(0x40)
  2903 |     |             m3 := mload(0x60)
  2904 |     |             m4 := mload(0x80)
  2905 |     |             m5 := mload(0xa0)
  2906 |     |             m6 := mload(0xc0)
  2907 |     |             m7 := mload(0xe0)
  2908 |     |             // Selector of `log(string,string,uint256)`.
  2909 |     |             mstore(0x00, 0x5821efa1)
  2910 |     |             mstore(0x20, 0x60)
  2911 |     |             mstore(0x40, 0xa0)
  2912 |     |             mstore(0x60, p2)
  2913 |     |             writeString(0x80, p0)
  2914 |     |             writeString(0xc0, p1)
  2915 |     |         }
  2916 |     |         _sendLogPayload(0x1c, 0xe4);
  2917 |     |         /// @solidity memory-safe-assembly
  2918 |     |         assembly {
  2919 |     |             mstore(0x00, m0)
  2920 |     |             mstore(0x20, m1)
  2921 |     |             mstore(0x40, m2)
  2922 |     |             mstore(0x60, m3)
  2923 |     |             mstore(0x80, m4)
  2924 |     |             mstore(0xa0, m5)
  2925 |     |             mstore(0xc0, m6)
  2926 |     |             mstore(0xe0, m7)
  2927 |     |         }
  2928 |     |     }
  2929 |     | 
  2930 |     |     function log(bytes32 p0, bytes32 p1, bytes32 p2) internal pure {
  2931 |     |         bytes32 m0;
  2932 |     |         bytes32 m1;
  2933 |     |         bytes32 m2;
  2934 |     |         bytes32 m3;
  2935 |     |         bytes32 m4;
  2936 |     |         bytes32 m5;
  2937 |     |         bytes32 m6;
  2938 |     |         bytes32 m7;
  2939 |     |         bytes32 m8;
  2940 |     |         bytes32 m9;
  2941 |     |         /// @solidity memory-safe-assembly
  2942 |     |         assembly {
  2943 |     |             function writeString(pos, w) {
  2944 |     |                 let length := 0
  2945 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  2946 |     |                 mstore(pos, length)
  2947 |     |                 let shift := sub(256, shl(3, length))
  2948 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  2949 |     |             }
  2950 |     |             m0 := mload(0x00)
  2951 |     |             m1 := mload(0x20)
  2952 |     |             m2 := mload(0x40)
  2953 |     |             m3 := mload(0x60)
  2954 |     |             m4 := mload(0x80)
  2955 |     |             m5 := mload(0xa0)
  2956 |     |             m6 := mload(0xc0)
  2957 |     |             m7 := mload(0xe0)
  2958 |     |             m8 := mload(0x100)
  2959 |     |             m9 := mload(0x120)
  2960 |     |             // Selector of `log(string,string,string)`.
  2961 |     |             mstore(0x00, 0x2ced7cef)
  2962 |     |             mstore(0x20, 0x60)
  2963 |     |             mstore(0x40, 0xa0)
  2964 |     |             mstore(0x60, 0xe0)
  2965 |     |             writeString(0x80, p0)
  2966 |     |             writeString(0xc0, p1)
  2967 |     |             writeString(0x100, p2)
  2968 |     |         }
  2969 |     |         _sendLogPayload(0x1c, 0x124);
  2970 |     |         /// @solidity memory-safe-assembly
  2971 |     |         assembly {
  2972 |     |             mstore(0x00, m0)
  2973 |     |             mstore(0x20, m1)
  2974 |     |             mstore(0x40, m2)
  2975 |     |             mstore(0x60, m3)
  2976 |     |             mstore(0x80, m4)
  2977 |     |             mstore(0xa0, m5)
  2978 |     |             mstore(0xc0, m6)
  2979 |     |             mstore(0xe0, m7)
  2980 |     |             mstore(0x100, m8)
  2981 |     |             mstore(0x120, m9)
  2982 |     |         }
  2983 |     |     }
  2984 |     | 
  2985 |     |     function log(address p0, address p1, address p2, address p3) internal pure {
  2986 |     |         bytes32 m0;
  2987 |     |         bytes32 m1;
  2988 |     |         bytes32 m2;
  2989 |     |         bytes32 m3;
  2990 |     |         bytes32 m4;
  2991 |     |         /// @solidity memory-safe-assembly
  2992 |     |         assembly {
  2993 |     |             m0 := mload(0x00)
  2994 |     |             m1 := mload(0x20)
  2995 |     |             m2 := mload(0x40)
  2996 |     |             m3 := mload(0x60)
  2997 |     |             m4 := mload(0x80)
  2998 |     |             // Selector of `log(address,address,address,address)`.
  2999 |     |             mstore(0x00, 0x665bf134)
  3000 |     |             mstore(0x20, p0)
  3001 |     |             mstore(0x40, p1)
  3002 |     |             mstore(0x60, p2)
  3003 |     |             mstore(0x80, p3)
  3004 |     |         }
  3005 |     |         _sendLogPayload(0x1c, 0x84);
  3006 |     |         /// @solidity memory-safe-assembly
  3007 |     |         assembly {
  3008 |     |             mstore(0x00, m0)
  3009 |     |             mstore(0x20, m1)
  3010 |     |             mstore(0x40, m2)
  3011 |     |             mstore(0x60, m3)
  3012 |     |             mstore(0x80, m4)
  3013 |     |         }
  3014 |     |     }
  3015 |     | 
  3016 |     |     function log(address p0, address p1, address p2, bool p3) internal pure {
  3017 |     |         bytes32 m0;
  3018 |     |         bytes32 m1;
  3019 |     |         bytes32 m2;
  3020 |     |         bytes32 m3;
  3021 |     |         bytes32 m4;
  3022 |     |         /// @solidity memory-safe-assembly
  3023 |     |         assembly {
  3024 |     |             m0 := mload(0x00)
  3025 |     |             m1 := mload(0x20)
  3026 |     |             m2 := mload(0x40)
  3027 |     |             m3 := mload(0x60)
  3028 |     |             m4 := mload(0x80)
  3029 |     |             // Selector of `log(address,address,address,bool)`.
  3030 |     |             mstore(0x00, 0x0e378994)
  3031 |     |             mstore(0x20, p0)
  3032 |     |             mstore(0x40, p1)
  3033 |     |             mstore(0x60, p2)
  3034 |     |             mstore(0x80, p3)
  3035 |     |         }
  3036 |     |         _sendLogPayload(0x1c, 0x84);
  3037 |     |         /// @solidity memory-safe-assembly
  3038 |     |         assembly {
  3039 |     |             mstore(0x00, m0)
  3040 |     |             mstore(0x20, m1)
  3041 |     |             mstore(0x40, m2)
  3042 |     |             mstore(0x60, m3)
  3043 |     |             mstore(0x80, m4)
  3044 |     |         }
  3045 |     |     }
  3046 |     | 
  3047 |     |     function log(address p0, address p1, address p2, uint256 p3) internal pure {
  3048 |     |         bytes32 m0;
  3049 |     |         bytes32 m1;
  3050 |     |         bytes32 m2;
  3051 |     |         bytes32 m3;
  3052 |     |         bytes32 m4;
  3053 |     |         /// @solidity memory-safe-assembly
  3054 |     |         assembly {
  3055 |     |             m0 := mload(0x00)
  3056 |     |             m1 := mload(0x20)
  3057 |     |             m2 := mload(0x40)
  3058 |     |             m3 := mload(0x60)
  3059 |     |             m4 := mload(0x80)
  3060 |     |             // Selector of `log(address,address,address,uint256)`.
  3061 |     |             mstore(0x00, 0x94250d77)
  3062 |     |             mstore(0x20, p0)
  3063 |     |             mstore(0x40, p1)
  3064 |     |             mstore(0x60, p2)
  3065 |     |             mstore(0x80, p3)
  3066 |     |         }
  3067 |     |         _sendLogPayload(0x1c, 0x84);
  3068 |     |         /// @solidity memory-safe-assembly
  3069 |     |         assembly {
  3070 |     |             mstore(0x00, m0)
  3071 |     |             mstore(0x20, m1)
  3072 |     |             mstore(0x40, m2)
  3073 |     |             mstore(0x60, m3)
  3074 |     |             mstore(0x80, m4)
  3075 |     |         }
  3076 |     |     }
  3077 |     | 
  3078 |     |     function log(address p0, address p1, address p2, bytes32 p3) internal pure {
  3079 |     |         bytes32 m0;
  3080 |     |         bytes32 m1;
  3081 |     |         bytes32 m2;
  3082 |     |         bytes32 m3;
  3083 |     |         bytes32 m4;
  3084 |     |         bytes32 m5;
  3085 |     |         bytes32 m6;
  3086 |     |         /// @solidity memory-safe-assembly
  3087 |     |         assembly {
  3088 |     |             function writeString(pos, w) {
  3089 |     |                 let length := 0
  3090 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  3091 |     |                 mstore(pos, length)
  3092 |     |                 let shift := sub(256, shl(3, length))
  3093 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  3094 |     |             }
  3095 |     |             m0 := mload(0x00)
  3096 |     |             m1 := mload(0x20)
  3097 |     |             m2 := mload(0x40)
  3098 |     |             m3 := mload(0x60)
  3099 |     |             m4 := mload(0x80)
  3100 |     |             m5 := mload(0xa0)
  3101 |     |             m6 := mload(0xc0)
  3102 |     |             // Selector of `log(address,address,address,string)`.
  3103 |     |             mstore(0x00, 0xf808da20)
  3104 |     |             mstore(0x20, p0)
  3105 |     |             mstore(0x40, p1)
  3106 |     |             mstore(0x60, p2)
  3107 |     |             mstore(0x80, 0x80)
  3108 |     |             writeString(0xa0, p3)
  3109 |     |         }
  3110 |     |         _sendLogPayload(0x1c, 0xc4);
  3111 |     |         /// @solidity memory-safe-assembly
  3112 |     |         assembly {
  3113 |     |             mstore(0x00, m0)
  3114 |     |             mstore(0x20, m1)
  3115 |     |             mstore(0x40, m2)
  3116 |     |             mstore(0x60, m3)
  3117 |     |             mstore(0x80, m4)
  3118 |     |             mstore(0xa0, m5)
  3119 |     |             mstore(0xc0, m6)
  3120 |     |         }
  3121 |     |     }
  3122 |     | 
  3123 |     |     function log(address p0, address p1, bool p2, address p3) internal pure {
  3124 |     |         bytes32 m0;
  3125 |     |         bytes32 m1;
  3126 |     |         bytes32 m2;
  3127 |     |         bytes32 m3;
  3128 |     |         bytes32 m4;
  3129 |     |         /// @solidity memory-safe-assembly
  3130 |     |         assembly {
  3131 |     |             m0 := mload(0x00)
  3132 |     |             m1 := mload(0x20)
  3133 |     |             m2 := mload(0x40)
  3134 |     |             m3 := mload(0x60)
  3135 |     |             m4 := mload(0x80)
  3136 |     |             // Selector of `log(address,address,bool,address)`.
  3137 |     |             mstore(0x00, 0x9f1bc36e)
  3138 |     |             mstore(0x20, p0)
  3139 |     |             mstore(0x40, p1)
  3140 |     |             mstore(0x60, p2)
  3141 |     |             mstore(0x80, p3)
  3142 |     |         }
  3143 |     |         _sendLogPayload(0x1c, 0x84);
  3144 |     |         /// @solidity memory-safe-assembly
  3145 |     |         assembly {
  3146 |     |             mstore(0x00, m0)
  3147 |     |             mstore(0x20, m1)
  3148 |     |             mstore(0x40, m2)
  3149 |     |             mstore(0x60, m3)
  3150 |     |             mstore(0x80, m4)
  3151 |     |         }
  3152 |     |     }
  3153 |     | 
  3154 |     |     function log(address p0, address p1, bool p2, bool p3) internal pure {
  3155 |     |         bytes32 m0;
  3156 |     |         bytes32 m1;
  3157 |     |         bytes32 m2;
  3158 |     |         bytes32 m3;
  3159 |     |         bytes32 m4;
  3160 |     |         /// @solidity memory-safe-assembly
  3161 |     |         assembly {
  3162 |     |             m0 := mload(0x00)
  3163 |     |             m1 := mload(0x20)
  3164 |     |             m2 := mload(0x40)
  3165 |     |             m3 := mload(0x60)
  3166 |     |             m4 := mload(0x80)
  3167 |     |             // Selector of `log(address,address,bool,bool)`.
  3168 |     |             mstore(0x00, 0x2cd4134a)
  3169 |     |             mstore(0x20, p0)
  3170 |     |             mstore(0x40, p1)
  3171 |     |             mstore(0x60, p2)
  3172 |     |             mstore(0x80, p3)
  3173 |     |         }
  3174 |     |         _sendLogPayload(0x1c, 0x84);
  3175 |     |         /// @solidity memory-safe-assembly
  3176 |     |         assembly {
  3177 |     |             mstore(0x00, m0)
  3178 |     |             mstore(0x20, m1)
  3179 |     |             mstore(0x40, m2)
  3180 |     |             mstore(0x60, m3)
  3181 |     |             mstore(0x80, m4)
  3182 |     |         }
  3183 |     |     }
  3184 |     | 
  3185 |     |     function log(address p0, address p1, bool p2, uint256 p3) internal pure {
  3186 |     |         bytes32 m0;
  3187 |     |         bytes32 m1;
  3188 |     |         bytes32 m2;
  3189 |     |         bytes32 m3;
  3190 |     |         bytes32 m4;
  3191 |     |         /// @solidity memory-safe-assembly
  3192 |     |         assembly {
  3193 |     |             m0 := mload(0x00)
  3194 |     |             m1 := mload(0x20)
  3195 |     |             m2 := mload(0x40)
  3196 |     |             m3 := mload(0x60)
  3197 |     |             m4 := mload(0x80)
  3198 |     |             // Selector of `log(address,address,bool,uint256)`.
  3199 |     |             mstore(0x00, 0x3971e78c)
  3200 |     |             mstore(0x20, p0)
  3201 |     |             mstore(0x40, p1)
  3202 |     |             mstore(0x60, p2)
  3203 |     |             mstore(0x80, p3)
  3204 |     |         }
  3205 |     |         _sendLogPayload(0x1c, 0x84);
  3206 |     |         /// @solidity memory-safe-assembly
  3207 |     |         assembly {
  3208 |     |             mstore(0x00, m0)
  3209 |     |             mstore(0x20, m1)
  3210 |     |             mstore(0x40, m2)
  3211 |     |             mstore(0x60, m3)
  3212 |     |             mstore(0x80, m4)
  3213 |     |         }
  3214 |     |     }
  3215 |     | 
  3216 |     |     function log(address p0, address p1, bool p2, bytes32 p3) internal pure {
  3217 |     |         bytes32 m0;
  3218 |     |         bytes32 m1;
  3219 |     |         bytes32 m2;
  3220 |     |         bytes32 m3;
  3221 |     |         bytes32 m4;
  3222 |     |         bytes32 m5;
  3223 |     |         bytes32 m6;
  3224 |     |         /// @solidity memory-safe-assembly
  3225 |     |         assembly {
  3226 |     |             function writeString(pos, w) {
  3227 |     |                 let length := 0
  3228 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  3229 |     |                 mstore(pos, length)
  3230 |     |                 let shift := sub(256, shl(3, length))
  3231 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  3232 |     |             }
  3233 |     |             m0 := mload(0x00)
  3234 |     |             m1 := mload(0x20)
  3235 |     |             m2 := mload(0x40)
  3236 |     |             m3 := mload(0x60)
  3237 |     |             m4 := mload(0x80)
  3238 |     |             m5 := mload(0xa0)
  3239 |     |             m6 := mload(0xc0)
  3240 |     |             // Selector of `log(address,address,bool,string)`.
  3241 |     |             mstore(0x00, 0xaa6540c8)
  3242 |     |             mstore(0x20, p0)
  3243 |     |             mstore(0x40, p1)
  3244 |     |             mstore(0x60, p2)
  3245 |     |             mstore(0x80, 0x80)
  3246 |     |             writeString(0xa0, p3)
  3247 |     |         }
  3248 |     |         _sendLogPayload(0x1c, 0xc4);
  3249 |     |         /// @solidity memory-safe-assembly
  3250 |     |         assembly {
  3251 |     |             mstore(0x00, m0)
  3252 |     |             mstore(0x20, m1)
  3253 |     |             mstore(0x40, m2)
  3254 |     |             mstore(0x60, m3)
  3255 |     |             mstore(0x80, m4)
  3256 |     |             mstore(0xa0, m5)
  3257 |     |             mstore(0xc0, m6)
  3258 |     |         }
  3259 |     |     }
  3260 |     | 
  3261 |     |     function log(address p0, address p1, uint256 p2, address p3) internal pure {
  3262 |     |         bytes32 m0;
  3263 |     |         bytes32 m1;
  3264 |     |         bytes32 m2;
  3265 |     |         bytes32 m3;
  3266 |     |         bytes32 m4;
  3267 |     |         /// @solidity memory-safe-assembly
  3268 |     |         assembly {
  3269 |     |             m0 := mload(0x00)
  3270 |     |             m1 := mload(0x20)
  3271 |     |             m2 := mload(0x40)
  3272 |     |             m3 := mload(0x60)
  3273 |     |             m4 := mload(0x80)
  3274 |     |             // Selector of `log(address,address,uint256,address)`.
  3275 |     |             mstore(0x00, 0x8da6def5)
  3276 |     |             mstore(0x20, p0)
  3277 |     |             mstore(0x40, p1)
  3278 |     |             mstore(0x60, p2)
  3279 |     |             mstore(0x80, p3)
  3280 |     |         }
  3281 |     |         _sendLogPayload(0x1c, 0x84);
  3282 |     |         /// @solidity memory-safe-assembly
  3283 |     |         assembly {
  3284 |     |             mstore(0x00, m0)
  3285 |     |             mstore(0x20, m1)
  3286 |     |             mstore(0x40, m2)
  3287 |     |             mstore(0x60, m3)
  3288 |     |             mstore(0x80, m4)
  3289 |     |         }
  3290 |     |     }
  3291 |     | 
  3292 |     |     function log(address p0, address p1, uint256 p2, bool p3) internal pure {
  3293 |     |         bytes32 m0;
  3294 |     |         bytes32 m1;
  3295 |     |         bytes32 m2;
  3296 |     |         bytes32 m3;
  3297 |     |         bytes32 m4;
  3298 |     |         /// @solidity memory-safe-assembly
  3299 |     |         assembly {
  3300 |     |             m0 := mload(0x00)
  3301 |     |             m1 := mload(0x20)
  3302 |     |             m2 := mload(0x40)
  3303 |     |             m3 := mload(0x60)
  3304 |     |             m4 := mload(0x80)
  3305 |     |             // Selector of `log(address,address,uint256,bool)`.
  3306 |     |             mstore(0x00, 0x9b4254e2)
  3307 |     |             mstore(0x20, p0)
  3308 |     |             mstore(0x40, p1)
  3309 |     |             mstore(0x60, p2)
  3310 |     |             mstore(0x80, p3)
  3311 |     |         }
  3312 |     |         _sendLogPayload(0x1c, 0x84);
  3313 |     |         /// @solidity memory-safe-assembly
  3314 |     |         assembly {
  3315 |     |             mstore(0x00, m0)
  3316 |     |             mstore(0x20, m1)
  3317 |     |             mstore(0x40, m2)
  3318 |     |             mstore(0x60, m3)
  3319 |     |             mstore(0x80, m4)
  3320 |     |         }
  3321 |     |     }
  3322 |     | 
  3323 |     |     function log(address p0, address p1, uint256 p2, uint256 p3) internal pure {
  3324 |     |         bytes32 m0;
  3325 |     |         bytes32 m1;
  3326 |     |         bytes32 m2;
  3327 |     |         bytes32 m3;
  3328 |     |         bytes32 m4;
  3329 |     |         /// @solidity memory-safe-assembly
  3330 |     |         assembly {
  3331 |     |             m0 := mload(0x00)
  3332 |     |             m1 := mload(0x20)
  3333 |     |             m2 := mload(0x40)
  3334 |     |             m3 := mload(0x60)
  3335 |     |             m4 := mload(0x80)
  3336 |     |             // Selector of `log(address,address,uint256,uint256)`.
  3337 |     |             mstore(0x00, 0xbe553481)
  3338 |     |             mstore(0x20, p0)
  3339 |     |             mstore(0x40, p1)
  3340 |     |             mstore(0x60, p2)
  3341 |     |             mstore(0x80, p3)
  3342 |     |         }
  3343 |     |         _sendLogPayload(0x1c, 0x84);
  3344 |     |         /// @solidity memory-safe-assembly
  3345 |     |         assembly {
  3346 |     |             mstore(0x00, m0)
  3347 |     |             mstore(0x20, m1)
  3348 |     |             mstore(0x40, m2)
  3349 |     |             mstore(0x60, m3)
  3350 |     |             mstore(0x80, m4)
  3351 |     |         }
  3352 |     |     }
  3353 |     | 
  3354 |     |     function log(address p0, address p1, uint256 p2, bytes32 p3) internal pure {
  3355 |     |         bytes32 m0;
  3356 |     |         bytes32 m1;
  3357 |     |         bytes32 m2;
  3358 |     |         bytes32 m3;
  3359 |     |         bytes32 m4;
  3360 |     |         bytes32 m5;
  3361 |     |         bytes32 m6;
  3362 |     |         /// @solidity memory-safe-assembly
  3363 |     |         assembly {
  3364 |     |             function writeString(pos, w) {
  3365 |     |                 let length := 0
  3366 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  3367 |     |                 mstore(pos, length)
  3368 |     |                 let shift := sub(256, shl(3, length))
  3369 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  3370 |     |             }
  3371 |     |             m0 := mload(0x00)
  3372 |     |             m1 := mload(0x20)
  3373 |     |             m2 := mload(0x40)
  3374 |     |             m3 := mload(0x60)
  3375 |     |             m4 := mload(0x80)
  3376 |     |             m5 := mload(0xa0)
  3377 |     |             m6 := mload(0xc0)
  3378 |     |             // Selector of `log(address,address,uint256,string)`.
  3379 |     |             mstore(0x00, 0xfdb4f990)
  3380 |     |             mstore(0x20, p0)
  3381 |     |             mstore(0x40, p1)
  3382 |     |             mstore(0x60, p2)
  3383 |     |             mstore(0x80, 0x80)
  3384 |     |             writeString(0xa0, p3)
  3385 |     |         }
  3386 |     |         _sendLogPayload(0x1c, 0xc4);
  3387 |     |         /// @solidity memory-safe-assembly
  3388 |     |         assembly {
  3389 |     |             mstore(0x00, m0)
  3390 |     |             mstore(0x20, m1)
  3391 |     |             mstore(0x40, m2)
  3392 |     |             mstore(0x60, m3)
  3393 |     |             mstore(0x80, m4)
  3394 |     |             mstore(0xa0, m5)
  3395 |     |             mstore(0xc0, m6)
  3396 |     |         }
  3397 |     |     }
  3398 |     | 
  3399 |     |     function log(address p0, address p1, bytes32 p2, address p3) internal pure {
  3400 |     |         bytes32 m0;
  3401 |     |         bytes32 m1;
  3402 |     |         bytes32 m2;
  3403 |     |         bytes32 m3;
  3404 |     |         bytes32 m4;
  3405 |     |         bytes32 m5;
  3406 |     |         bytes32 m6;
  3407 |     |         /// @solidity memory-safe-assembly
  3408 |     |         assembly {
  3409 |     |             function writeString(pos, w) {
  3410 |     |                 let length := 0
  3411 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  3412 |     |                 mstore(pos, length)
  3413 |     |                 let shift := sub(256, shl(3, length))
  3414 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  3415 |     |             }
  3416 |     |             m0 := mload(0x00)
  3417 |     |             m1 := mload(0x20)
  3418 |     |             m2 := mload(0x40)
  3419 |     |             m3 := mload(0x60)
  3420 |     |             m4 := mload(0x80)
  3421 |     |             m5 := mload(0xa0)
  3422 |     |             m6 := mload(0xc0)
  3423 |     |             // Selector of `log(address,address,string,address)`.
  3424 |     |             mstore(0x00, 0x8f736d16)
  3425 |     |             mstore(0x20, p0)
  3426 |     |             mstore(0x40, p1)
  3427 |     |             mstore(0x60, 0x80)
  3428 |     |             mstore(0x80, p3)
  3429 |     |             writeString(0xa0, p2)
  3430 |     |         }
  3431 |     |         _sendLogPayload(0x1c, 0xc4);
  3432 |     |         /// @solidity memory-safe-assembly
  3433 |     |         assembly {
  3434 |     |             mstore(0x00, m0)
  3435 |     |             mstore(0x20, m1)
  3436 |     |             mstore(0x40, m2)
  3437 |     |             mstore(0x60, m3)
  3438 |     |             mstore(0x80, m4)
  3439 |     |             mstore(0xa0, m5)
  3440 |     |             mstore(0xc0, m6)
  3441 |     |         }
  3442 |     |     }
  3443 |     | 
  3444 |     |     function log(address p0, address p1, bytes32 p2, bool p3) internal pure {
  3445 |     |         bytes32 m0;
  3446 |     |         bytes32 m1;
  3447 |     |         bytes32 m2;
  3448 |     |         bytes32 m3;
  3449 |     |         bytes32 m4;
  3450 |     |         bytes32 m5;
  3451 |     |         bytes32 m6;
  3452 |     |         /// @solidity memory-safe-assembly
  3453 |     |         assembly {
  3454 |     |             function writeString(pos, w) {
  3455 |     |                 let length := 0
  3456 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  3457 |     |                 mstore(pos, length)
  3458 |     |                 let shift := sub(256, shl(3, length))
  3459 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  3460 |     |             }
  3461 |     |             m0 := mload(0x00)
  3462 |     |             m1 := mload(0x20)
  3463 |     |             m2 := mload(0x40)
  3464 |     |             m3 := mload(0x60)
  3465 |     |             m4 := mload(0x80)
  3466 |     |             m5 := mload(0xa0)
  3467 |     |             m6 := mload(0xc0)
  3468 |     |             // Selector of `log(address,address,string,bool)`.
  3469 |     |             mstore(0x00, 0x6f1a594e)
  3470 |     |             mstore(0x20, p0)
  3471 |     |             mstore(0x40, p1)
  3472 |     |             mstore(0x60, 0x80)
  3473 |     |             mstore(0x80, p3)
  3474 |     |             writeString(0xa0, p2)
  3475 |     |         }
  3476 |     |         _sendLogPayload(0x1c, 0xc4);
  3477 |     |         /// @solidity memory-safe-assembly
  3478 |     |         assembly {
  3479 |     |             mstore(0x00, m0)
  3480 |     |             mstore(0x20, m1)
  3481 |     |             mstore(0x40, m2)
  3482 |     |             mstore(0x60, m3)
  3483 |     |             mstore(0x80, m4)
  3484 |     |             mstore(0xa0, m5)
  3485 |     |             mstore(0xc0, m6)
  3486 |     |         }
  3487 |     |     }
  3488 |     | 
  3489 |     |     function log(address p0, address p1, bytes32 p2, uint256 p3) internal pure {
  3490 |     |         bytes32 m0;
  3491 |     |         bytes32 m1;
  3492 |     |         bytes32 m2;
  3493 |     |         bytes32 m3;
  3494 |     |         bytes32 m4;
  3495 |     |         bytes32 m5;
  3496 |     |         bytes32 m6;
  3497 |     |         /// @solidity memory-safe-assembly
  3498 |     |         assembly {
  3499 |     |             function writeString(pos, w) {
  3500 |     |                 let length := 0
  3501 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  3502 |     |                 mstore(pos, length)
  3503 |     |                 let shift := sub(256, shl(3, length))
  3504 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  3505 |     |             }
  3506 |     |             m0 := mload(0x00)
  3507 |     |             m1 := mload(0x20)
  3508 |     |             m2 := mload(0x40)
  3509 |     |             m3 := mload(0x60)
  3510 |     |             m4 := mload(0x80)
  3511 |     |             m5 := mload(0xa0)
  3512 |     |             m6 := mload(0xc0)
  3513 |     |             // Selector of `log(address,address,string,uint256)`.
  3514 |     |             mstore(0x00, 0xef1cefe7)
  3515 |     |             mstore(0x20, p0)
  3516 |     |             mstore(0x40, p1)
  3517 |     |             mstore(0x60, 0x80)
  3518 |     |             mstore(0x80, p3)
  3519 |     |             writeString(0xa0, p2)
  3520 |     |         }
  3521 |     |         _sendLogPayload(0x1c, 0xc4);
  3522 |     |         /// @solidity memory-safe-assembly
  3523 |     |         assembly {
  3524 |     |             mstore(0x00, m0)
  3525 |     |             mstore(0x20, m1)
  3526 |     |             mstore(0x40, m2)
  3527 |     |             mstore(0x60, m3)
  3528 |     |             mstore(0x80, m4)
  3529 |     |             mstore(0xa0, m5)
  3530 |     |             mstore(0xc0, m6)
  3531 |     |         }
  3532 |     |     }
  3533 |     | 
  3534 |     |     function log(address p0, address p1, bytes32 p2, bytes32 p3) internal pure {
  3535 |     |         bytes32 m0;
  3536 |     |         bytes32 m1;
  3537 |     |         bytes32 m2;
  3538 |     |         bytes32 m3;
  3539 |     |         bytes32 m4;
  3540 |     |         bytes32 m5;
  3541 |     |         bytes32 m6;
  3542 |     |         bytes32 m7;
  3543 |     |         bytes32 m8;
  3544 |     |         /// @solidity memory-safe-assembly
  3545 |     |         assembly {
  3546 |     |             function writeString(pos, w) {
  3547 |     |                 let length := 0
  3548 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  3549 |     |                 mstore(pos, length)
  3550 |     |                 let shift := sub(256, shl(3, length))
  3551 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  3552 |     |             }
  3553 |     |             m0 := mload(0x00)
  3554 |     |             m1 := mload(0x20)
  3555 |     |             m2 := mload(0x40)
  3556 |     |             m3 := mload(0x60)
  3557 |     |             m4 := mload(0x80)
  3558 |     |             m5 := mload(0xa0)
  3559 |     |             m6 := mload(0xc0)
  3560 |     |             m7 := mload(0xe0)
  3561 |     |             m8 := mload(0x100)
  3562 |     |             // Selector of `log(address,address,string,string)`.
  3563 |     |             mstore(0x00, 0x21bdaf25)
  3564 |     |             mstore(0x20, p0)
  3565 |     |             mstore(0x40, p1)
  3566 |     |             mstore(0x60, 0x80)
  3567 |     |             mstore(0x80, 0xc0)
  3568 |     |             writeString(0xa0, p2)
  3569 |     |             writeString(0xe0, p3)
  3570 |     |         }
  3571 |     |         _sendLogPayload(0x1c, 0x104);
  3572 |     |         /// @solidity memory-safe-assembly
  3573 |     |         assembly {
  3574 |     |             mstore(0x00, m0)
  3575 |     |             mstore(0x20, m1)
  3576 |     |             mstore(0x40, m2)
  3577 |     |             mstore(0x60, m3)
  3578 |     |             mstore(0x80, m4)
  3579 |     |             mstore(0xa0, m5)
  3580 |     |             mstore(0xc0, m6)
  3581 |     |             mstore(0xe0, m7)
  3582 |     |             mstore(0x100, m8)
  3583 |     |         }
  3584 |     |     }
  3585 |     | 
  3586 |     |     function log(address p0, bool p1, address p2, address p3) internal pure {
  3587 |     |         bytes32 m0;
  3588 |     |         bytes32 m1;
  3589 |     |         bytes32 m2;
  3590 |     |         bytes32 m3;
  3591 |     |         bytes32 m4;
  3592 |     |         /// @solidity memory-safe-assembly
  3593 |     |         assembly {
  3594 |     |             m0 := mload(0x00)
  3595 |     |             m1 := mload(0x20)
  3596 |     |             m2 := mload(0x40)
  3597 |     |             m3 := mload(0x60)
  3598 |     |             m4 := mload(0x80)
  3599 |     |             // Selector of `log(address,bool,address,address)`.
  3600 |     |             mstore(0x00, 0x660375dd)
  3601 |     |             mstore(0x20, p0)
  3602 |     |             mstore(0x40, p1)
  3603 |     |             mstore(0x60, p2)
  3604 |     |             mstore(0x80, p3)
  3605 |     |         }
  3606 |     |         _sendLogPayload(0x1c, 0x84);
  3607 |     |         /// @solidity memory-safe-assembly
  3608 |     |         assembly {
  3609 |     |             mstore(0x00, m0)
  3610 |     |             mstore(0x20, m1)
  3611 |     |             mstore(0x40, m2)
  3612 |     |             mstore(0x60, m3)
  3613 |     |             mstore(0x80, m4)
  3614 |     |         }
  3615 |     |     }
  3616 |     | 
  3617 |     |     function log(address p0, bool p1, address p2, bool p3) internal pure {
  3618 |     |         bytes32 m0;
  3619 |     |         bytes32 m1;
  3620 |     |         bytes32 m2;
  3621 |     |         bytes32 m3;
  3622 |     |         bytes32 m4;
  3623 |     |         /// @solidity memory-safe-assembly
  3624 |     |         assembly {
  3625 |     |             m0 := mload(0x00)
  3626 |     |             m1 := mload(0x20)
  3627 |     |             m2 := mload(0x40)
  3628 |     |             m3 := mload(0x60)
  3629 |     |             m4 := mload(0x80)
  3630 |     |             // Selector of `log(address,bool,address,bool)`.
  3631 |     |             mstore(0x00, 0xa6f50b0f)
  3632 |     |             mstore(0x20, p0)
  3633 |     |             mstore(0x40, p1)
  3634 |     |             mstore(0x60, p2)
  3635 |     |             mstore(0x80, p3)
  3636 |     |         }
  3637 |     |         _sendLogPayload(0x1c, 0x84);
  3638 |     |         /// @solidity memory-safe-assembly
  3639 |     |         assembly {
  3640 |     |             mstore(0x00, m0)
  3641 |     |             mstore(0x20, m1)
  3642 |     |             mstore(0x40, m2)
  3643 |     |             mstore(0x60, m3)
  3644 |     |             mstore(0x80, m4)
  3645 |     |         }
  3646 |     |     }
  3647 |     | 
  3648 |     |     function log(address p0, bool p1, address p2, uint256 p3) internal pure {
  3649 |     |         bytes32 m0;
  3650 |     |         bytes32 m1;
  3651 |     |         bytes32 m2;
  3652 |     |         bytes32 m3;
  3653 |     |         bytes32 m4;
  3654 |     |         /// @solidity memory-safe-assembly
  3655 |     |         assembly {
  3656 |     |             m0 := mload(0x00)
  3657 |     |             m1 := mload(0x20)
  3658 |     |             m2 := mload(0x40)
  3659 |     |             m3 := mload(0x60)
  3660 |     |             m4 := mload(0x80)
  3661 |     |             // Selector of `log(address,bool,address,uint256)`.
  3662 |     |             mstore(0x00, 0xa75c59de)
  3663 |     |             mstore(0x20, p0)
  3664 |     |             mstore(0x40, p1)
  3665 |     |             mstore(0x60, p2)
  3666 |     |             mstore(0x80, p3)
  3667 |     |         }
  3668 |     |         _sendLogPayload(0x1c, 0x84);
  3669 |     |         /// @solidity memory-safe-assembly
  3670 |     |         assembly {
  3671 |     |             mstore(0x00, m0)
  3672 |     |             mstore(0x20, m1)
  3673 |     |             mstore(0x40, m2)
  3674 |     |             mstore(0x60, m3)
  3675 |     |             mstore(0x80, m4)
  3676 |     |         }
  3677 |     |     }
  3678 |     | 
  3679 |     |     function log(address p0, bool p1, address p2, bytes32 p3) internal pure {
  3680 |     |         bytes32 m0;
  3681 |     |         bytes32 m1;
  3682 |     |         bytes32 m2;
  3683 |     |         bytes32 m3;
  3684 |     |         bytes32 m4;
  3685 |     |         bytes32 m5;
  3686 |     |         bytes32 m6;
  3687 |     |         /// @solidity memory-safe-assembly
  3688 |     |         assembly {
  3689 |     |             function writeString(pos, w) {
  3690 |     |                 let length := 0
  3691 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  3692 |     |                 mstore(pos, length)
  3693 |     |                 let shift := sub(256, shl(3, length))
  3694 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  3695 |     |             }
  3696 |     |             m0 := mload(0x00)
  3697 |     |             m1 := mload(0x20)
  3698 |     |             m2 := mload(0x40)
  3699 |     |             m3 := mload(0x60)
  3700 |     |             m4 := mload(0x80)
  3701 |     |             m5 := mload(0xa0)
  3702 |     |             m6 := mload(0xc0)
  3703 |     |             // Selector of `log(address,bool,address,string)`.
  3704 |     |             mstore(0x00, 0x2dd778e6)
  3705 |     |             mstore(0x20, p0)
  3706 |     |             mstore(0x40, p1)
  3707 |     |             mstore(0x60, p2)
  3708 |     |             mstore(0x80, 0x80)
  3709 |     |             writeString(0xa0, p3)
  3710 |     |         }
  3711 |     |         _sendLogPayload(0x1c, 0xc4);
  3712 |     |         /// @solidity memory-safe-assembly
  3713 |     |         assembly {
  3714 |     |             mstore(0x00, m0)
  3715 |     |             mstore(0x20, m1)
  3716 |     |             mstore(0x40, m2)
  3717 |     |             mstore(0x60, m3)
  3718 |     |             mstore(0x80, m4)
  3719 |     |             mstore(0xa0, m5)
  3720 |     |             mstore(0xc0, m6)
  3721 |     |         }
  3722 |     |     }
  3723 |     | 
  3724 |     |     function log(address p0, bool p1, bool p2, address p3) internal pure {
  3725 |     |         bytes32 m0;
  3726 |     |         bytes32 m1;
  3727 |     |         bytes32 m2;
  3728 |     |         bytes32 m3;
  3729 |     |         bytes32 m4;
  3730 |     |         /// @solidity memory-safe-assembly
  3731 |     |         assembly {
  3732 |     |             m0 := mload(0x00)
  3733 |     |             m1 := mload(0x20)
  3734 |     |             m2 := mload(0x40)
  3735 |     |             m3 := mload(0x60)
  3736 |     |             m4 := mload(0x80)
  3737 |     |             // Selector of `log(address,bool,bool,address)`.
  3738 |     |             mstore(0x00, 0xcf394485)
  3739 |     |             mstore(0x20, p0)
  3740 |     |             mstore(0x40, p1)
  3741 |     |             mstore(0x60, p2)
  3742 |     |             mstore(0x80, p3)
  3743 |     |         }
  3744 |     |         _sendLogPayload(0x1c, 0x84);
  3745 |     |         /// @solidity memory-safe-assembly
  3746 |     |         assembly {
  3747 |     |             mstore(0x00, m0)
  3748 |     |             mstore(0x20, m1)
  3749 |     |             mstore(0x40, m2)
  3750 |     |             mstore(0x60, m3)
  3751 |     |             mstore(0x80, m4)
  3752 |     |         }
  3753 |     |     }
  3754 |     | 
  3755 |     |     function log(address p0, bool p1, bool p2, bool p3) internal pure {
  3756 |     |         bytes32 m0;
  3757 |     |         bytes32 m1;
  3758 |     |         bytes32 m2;
  3759 |     |         bytes32 m3;
  3760 |     |         bytes32 m4;
  3761 |     |         /// @solidity memory-safe-assembly
  3762 |     |         assembly {
  3763 |     |             m0 := mload(0x00)
  3764 |     |             m1 := mload(0x20)
  3765 |     |             m2 := mload(0x40)
  3766 |     |             m3 := mload(0x60)
  3767 |     |             m4 := mload(0x80)
  3768 |     |             // Selector of `log(address,bool,bool,bool)`.
  3769 |     |             mstore(0x00, 0xcac43479)
  3770 |     |             mstore(0x20, p0)
  3771 |     |             mstore(0x40, p1)
  3772 |     |             mstore(0x60, p2)
  3773 |     |             mstore(0x80, p3)
  3774 |     |         }
  3775 |     |         _sendLogPayload(0x1c, 0x84);
  3776 |     |         /// @solidity memory-safe-assembly
  3777 |     |         assembly {
  3778 |     |             mstore(0x00, m0)
  3779 |     |             mstore(0x20, m1)
  3780 |     |             mstore(0x40, m2)
  3781 |     |             mstore(0x60, m3)
  3782 |     |             mstore(0x80, m4)
  3783 |     |         }
  3784 |     |     }
  3785 |     | 
  3786 |     |     function log(address p0, bool p1, bool p2, uint256 p3) internal pure {
  3787 |     |         bytes32 m0;
  3788 |     |         bytes32 m1;
  3789 |     |         bytes32 m2;
  3790 |     |         bytes32 m3;
  3791 |     |         bytes32 m4;
  3792 |     |         /// @solidity memory-safe-assembly
  3793 |     |         assembly {
  3794 |     |             m0 := mload(0x00)
  3795 |     |             m1 := mload(0x20)
  3796 |     |             m2 := mload(0x40)
  3797 |     |             m3 := mload(0x60)
  3798 |     |             m4 := mload(0x80)
  3799 |     |             // Selector of `log(address,bool,bool,uint256)`.
  3800 |     |             mstore(0x00, 0x8c4e5de6)
  3801 |     |             mstore(0x20, p0)
  3802 |     |             mstore(0x40, p1)
  3803 |     |             mstore(0x60, p2)
  3804 |     |             mstore(0x80, p3)
  3805 |     |         }
  3806 |     |         _sendLogPayload(0x1c, 0x84);
  3807 |     |         /// @solidity memory-safe-assembly
  3808 |     |         assembly {
  3809 |     |             mstore(0x00, m0)
  3810 |     |             mstore(0x20, m1)
  3811 |     |             mstore(0x40, m2)
  3812 |     |             mstore(0x60, m3)
  3813 |     |             mstore(0x80, m4)
  3814 |     |         }
  3815 |     |     }
  3816 |     | 
  3817 |     |     function log(address p0, bool p1, bool p2, bytes32 p3) internal pure {
  3818 |     |         bytes32 m0;
  3819 |     |         bytes32 m1;
  3820 |     |         bytes32 m2;
  3821 |     |         bytes32 m3;
  3822 |     |         bytes32 m4;
  3823 |     |         bytes32 m5;
  3824 |     |         bytes32 m6;
  3825 |     |         /// @solidity memory-safe-assembly
  3826 |     |         assembly {
  3827 |     |             function writeString(pos, w) {
  3828 |     |                 let length := 0
  3829 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  3830 |     |                 mstore(pos, length)
  3831 |     |                 let shift := sub(256, shl(3, length))
  3832 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  3833 |     |             }
  3834 |     |             m0 := mload(0x00)
  3835 |     |             m1 := mload(0x20)
  3836 |     |             m2 := mload(0x40)
  3837 |     |             m3 := mload(0x60)
  3838 |     |             m4 := mload(0x80)
  3839 |     |             m5 := mload(0xa0)
  3840 |     |             m6 := mload(0xc0)
  3841 |     |             // Selector of `log(address,bool,bool,string)`.
  3842 |     |             mstore(0x00, 0xdfc4a2e8)
  3843 |     |             mstore(0x20, p0)
  3844 |     |             mstore(0x40, p1)
  3845 |     |             mstore(0x60, p2)
  3846 |     |             mstore(0x80, 0x80)
  3847 |     |             writeString(0xa0, p3)
  3848 |     |         }
  3849 |     |         _sendLogPayload(0x1c, 0xc4);
  3850 |     |         /// @solidity memory-safe-assembly
  3851 |     |         assembly {
  3852 |     |             mstore(0x00, m0)
  3853 |     |             mstore(0x20, m1)
  3854 |     |             mstore(0x40, m2)
  3855 |     |             mstore(0x60, m3)
  3856 |     |             mstore(0x80, m4)
  3857 |     |             mstore(0xa0, m5)
  3858 |     |             mstore(0xc0, m6)
  3859 |     |         }
  3860 |     |     }
  3861 |     | 
  3862 |     |     function log(address p0, bool p1, uint256 p2, address p3) internal pure {
  3863 |     |         bytes32 m0;
  3864 |     |         bytes32 m1;
  3865 |     |         bytes32 m2;
  3866 |     |         bytes32 m3;
  3867 |     |         bytes32 m4;
  3868 |     |         /// @solidity memory-safe-assembly
  3869 |     |         assembly {
  3870 |     |             m0 := mload(0x00)
  3871 |     |             m1 := mload(0x20)
  3872 |     |             m2 := mload(0x40)
  3873 |     |             m3 := mload(0x60)
  3874 |     |             m4 := mload(0x80)
  3875 |     |             // Selector of `log(address,bool,uint256,address)`.
  3876 |     |             mstore(0x00, 0xccf790a1)
  3877 |     |             mstore(0x20, p0)
  3878 |     |             mstore(0x40, p1)
  3879 |     |             mstore(0x60, p2)
  3880 |     |             mstore(0x80, p3)
  3881 |     |         }
  3882 |     |         _sendLogPayload(0x1c, 0x84);
  3883 |     |         /// @solidity memory-safe-assembly
  3884 |     |         assembly {
  3885 |     |             mstore(0x00, m0)
  3886 |     |             mstore(0x20, m1)
  3887 |     |             mstore(0x40, m2)
  3888 |     |             mstore(0x60, m3)
  3889 |     |             mstore(0x80, m4)
  3890 |     |         }
  3891 |     |     }
  3892 |     | 
  3893 |     |     function log(address p0, bool p1, uint256 p2, bool p3) internal pure {
  3894 |     |         bytes32 m0;
  3895 |     |         bytes32 m1;
  3896 |     |         bytes32 m2;
  3897 |     |         bytes32 m3;
  3898 |     |         bytes32 m4;
  3899 |     |         /// @solidity memory-safe-assembly
  3900 |     |         assembly {
  3901 |     |             m0 := mload(0x00)
  3902 |     |             m1 := mload(0x20)
  3903 |     |             m2 := mload(0x40)
  3904 |     |             m3 := mload(0x60)
  3905 |     |             m4 := mload(0x80)
  3906 |     |             // Selector of `log(address,bool,uint256,bool)`.
  3907 |     |             mstore(0x00, 0xc4643e20)
  3908 |     |             mstore(0x20, p0)
  3909 |     |             mstore(0x40, p1)
  3910 |     |             mstore(0x60, p2)
  3911 |     |             mstore(0x80, p3)
  3912 |     |         }
  3913 |     |         _sendLogPayload(0x1c, 0x84);
  3914 |     |         /// @solidity memory-safe-assembly
  3915 |     |         assembly {
  3916 |     |             mstore(0x00, m0)
  3917 |     |             mstore(0x20, m1)
  3918 |     |             mstore(0x40, m2)
  3919 |     |             mstore(0x60, m3)
  3920 |     |             mstore(0x80, m4)
  3921 |     |         }
  3922 |     |     }
  3923 |     | 
  3924 |     |     function log(address p0, bool p1, uint256 p2, uint256 p3) internal pure {
  3925 |     |         bytes32 m0;
  3926 |     |         bytes32 m1;
  3927 |     |         bytes32 m2;
  3928 |     |         bytes32 m3;
  3929 |     |         bytes32 m4;
  3930 |     |         /// @solidity memory-safe-assembly
  3931 |     |         assembly {
  3932 |     |             m0 := mload(0x00)
  3933 |     |             m1 := mload(0x20)
  3934 |     |             m2 := mload(0x40)
  3935 |     |             m3 := mload(0x60)
  3936 |     |             m4 := mload(0x80)
  3937 |     |             // Selector of `log(address,bool,uint256,uint256)`.
  3938 |     |             mstore(0x00, 0x386ff5f4)
  3939 |     |             mstore(0x20, p0)
  3940 |     |             mstore(0x40, p1)
  3941 |     |             mstore(0x60, p2)
  3942 |     |             mstore(0x80, p3)
  3943 |     |         }
  3944 |     |         _sendLogPayload(0x1c, 0x84);
  3945 |     |         /// @solidity memory-safe-assembly
  3946 |     |         assembly {
  3947 |     |             mstore(0x00, m0)
  3948 |     |             mstore(0x20, m1)
  3949 |     |             mstore(0x40, m2)
  3950 |     |             mstore(0x60, m3)
  3951 |     |             mstore(0x80, m4)
  3952 |     |         }
  3953 |     |     }
  3954 |     | 
  3955 |     |     function log(address p0, bool p1, uint256 p2, bytes32 p3) internal pure {
  3956 |     |         bytes32 m0;
  3957 |     |         bytes32 m1;
  3958 |     |         bytes32 m2;
  3959 |     |         bytes32 m3;
  3960 |     |         bytes32 m4;
  3961 |     |         bytes32 m5;
  3962 |     |         bytes32 m6;
  3963 |     |         /// @solidity memory-safe-assembly
  3964 |     |         assembly {
  3965 |     |             function writeString(pos, w) {
  3966 |     |                 let length := 0
  3967 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  3968 |     |                 mstore(pos, length)
  3969 |     |                 let shift := sub(256, shl(3, length))
  3970 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  3971 |     |             }
  3972 |     |             m0 := mload(0x00)
  3973 |     |             m1 := mload(0x20)
  3974 |     |             m2 := mload(0x40)
  3975 |     |             m3 := mload(0x60)
  3976 |     |             m4 := mload(0x80)
  3977 |     |             m5 := mload(0xa0)
  3978 |     |             m6 := mload(0xc0)
  3979 |     |             // Selector of `log(address,bool,uint256,string)`.
  3980 |     |             mstore(0x00, 0x0aa6cfad)
  3981 |     |             mstore(0x20, p0)
  3982 |     |             mstore(0x40, p1)
  3983 |     |             mstore(0x60, p2)
  3984 |     |             mstore(0x80, 0x80)
  3985 |     |             writeString(0xa0, p3)
  3986 |     |         }
  3987 |     |         _sendLogPayload(0x1c, 0xc4);
  3988 |     |         /// @solidity memory-safe-assembly
  3989 |     |         assembly {
  3990 |     |             mstore(0x00, m0)
  3991 |     |             mstore(0x20, m1)
  3992 |     |             mstore(0x40, m2)
  3993 |     |             mstore(0x60, m3)
  3994 |     |             mstore(0x80, m4)
  3995 |     |             mstore(0xa0, m5)
  3996 |     |             mstore(0xc0, m6)
  3997 |     |         }
  3998 |     |     }
  3999 |     | 
  4000 |     |     function log(address p0, bool p1, bytes32 p2, address p3) internal pure {
  4001 |     |         bytes32 m0;
  4002 |     |         bytes32 m1;
  4003 |     |         bytes32 m2;
  4004 |     |         bytes32 m3;
  4005 |     |         bytes32 m4;
  4006 |     |         bytes32 m5;
  4007 |     |         bytes32 m6;
  4008 |     |         /// @solidity memory-safe-assembly
  4009 |     |         assembly {
  4010 |     |             function writeString(pos, w) {
  4011 |     |                 let length := 0
  4012 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  4013 |     |                 mstore(pos, length)
  4014 |     |                 let shift := sub(256, shl(3, length))
  4015 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  4016 |     |             }
  4017 |     |             m0 := mload(0x00)
  4018 |     |             m1 := mload(0x20)
  4019 |     |             m2 := mload(0x40)
  4020 |     |             m3 := mload(0x60)
  4021 |     |             m4 := mload(0x80)
  4022 |     |             m5 := mload(0xa0)
  4023 |     |             m6 := mload(0xc0)
  4024 |     |             // Selector of `log(address,bool,string,address)`.
  4025 |     |             mstore(0x00, 0x19fd4956)
  4026 |     |             mstore(0x20, p0)
  4027 |     |             mstore(0x40, p1)
  4028 |     |             mstore(0x60, 0x80)
  4029 |     |             mstore(0x80, p3)
  4030 |     |             writeString(0xa0, p2)
  4031 |     |         }
  4032 |     |         _sendLogPayload(0x1c, 0xc4);
  4033 |     |         /// @solidity memory-safe-assembly
  4034 |     |         assembly {
  4035 |     |             mstore(0x00, m0)
  4036 |     |             mstore(0x20, m1)
  4037 |     |             mstore(0x40, m2)
  4038 |     |             mstore(0x60, m3)
  4039 |     |             mstore(0x80, m4)
  4040 |     |             mstore(0xa0, m5)
  4041 |     |             mstore(0xc0, m6)
  4042 |     |         }
  4043 |     |     }
  4044 |     | 
  4045 |     |     function log(address p0, bool p1, bytes32 p2, bool p3) internal pure {
  4046 |     |         bytes32 m0;
  4047 |     |         bytes32 m1;
  4048 |     |         bytes32 m2;
  4049 |     |         bytes32 m3;
  4050 |     |         bytes32 m4;
  4051 |     |         bytes32 m5;
  4052 |     |         bytes32 m6;
  4053 |     |         /// @solidity memory-safe-assembly
  4054 |     |         assembly {
  4055 |     |             function writeString(pos, w) {
  4056 |     |                 let length := 0
  4057 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  4058 |     |                 mstore(pos, length)
  4059 |     |                 let shift := sub(256, shl(3, length))
  4060 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  4061 |     |             }
  4062 |     |             m0 := mload(0x00)
  4063 |     |             m1 := mload(0x20)
  4064 |     |             m2 := mload(0x40)
  4065 |     |             m3 := mload(0x60)
  4066 |     |             m4 := mload(0x80)
  4067 |     |             m5 := mload(0xa0)
  4068 |     |             m6 := mload(0xc0)
  4069 |     |             // Selector of `log(address,bool,string,bool)`.
  4070 |     |             mstore(0x00, 0x50ad461d)
  4071 |     |             mstore(0x20, p0)
  4072 |     |             mstore(0x40, p1)
  4073 |     |             mstore(0x60, 0x80)
  4074 |     |             mstore(0x80, p3)
  4075 |     |             writeString(0xa0, p2)
  4076 |     |         }
  4077 |     |         _sendLogPayload(0x1c, 0xc4);
  4078 |     |         /// @solidity memory-safe-assembly
  4079 |     |         assembly {
  4080 |     |             mstore(0x00, m0)
  4081 |     |             mstore(0x20, m1)
  4082 |     |             mstore(0x40, m2)
  4083 |     |             mstore(0x60, m3)
  4084 |     |             mstore(0x80, m4)
  4085 |     |             mstore(0xa0, m5)
  4086 |     |             mstore(0xc0, m6)
  4087 |     |         }
  4088 |     |     }
  4089 |     | 
  4090 |     |     function log(address p0, bool p1, bytes32 p2, uint256 p3) internal pure {
  4091 |     |         bytes32 m0;
  4092 |     |         bytes32 m1;
  4093 |     |         bytes32 m2;
  4094 |     |         bytes32 m3;
  4095 |     |         bytes32 m4;
  4096 |     |         bytes32 m5;
  4097 |     |         bytes32 m6;
  4098 |     |         /// @solidity memory-safe-assembly
  4099 |     |         assembly {
  4100 |     |             function writeString(pos, w) {
  4101 |     |                 let length := 0
  4102 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  4103 |     |                 mstore(pos, length)
  4104 |     |                 let shift := sub(256, shl(3, length))
  4105 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  4106 |     |             }
  4107 |     |             m0 := mload(0x00)
  4108 |     |             m1 := mload(0x20)
  4109 |     |             m2 := mload(0x40)
  4110 |     |             m3 := mload(0x60)
  4111 |     |             m4 := mload(0x80)
  4112 |     |             m5 := mload(0xa0)
  4113 |     |             m6 := mload(0xc0)
  4114 |     |             // Selector of `log(address,bool,string,uint256)`.
  4115 |     |             mstore(0x00, 0x80e6a20b)
  4116 |     |             mstore(0x20, p0)
  4117 |     |             mstore(0x40, p1)
  4118 |     |             mstore(0x60, 0x80)
  4119 |     |             mstore(0x80, p3)
  4120 |     |             writeString(0xa0, p2)
  4121 |     |         }
  4122 |     |         _sendLogPayload(0x1c, 0xc4);
  4123 |     |         /// @solidity memory-safe-assembly
  4124 |     |         assembly {
  4125 |     |             mstore(0x00, m0)
  4126 |     |             mstore(0x20, m1)
  4127 |     |             mstore(0x40, m2)
  4128 |     |             mstore(0x60, m3)
  4129 |     |             mstore(0x80, m4)
  4130 |     |             mstore(0xa0, m5)
  4131 |     |             mstore(0xc0, m6)
  4132 |     |         }
  4133 |     |     }
  4134 |     | 
  4135 |     |     function log(address p0, bool p1, bytes32 p2, bytes32 p3) internal pure {
  4136 |     |         bytes32 m0;
  4137 |     |         bytes32 m1;
  4138 |     |         bytes32 m2;
  4139 |     |         bytes32 m3;
  4140 |     |         bytes32 m4;
  4141 |     |         bytes32 m5;
  4142 |     |         bytes32 m6;
  4143 |     |         bytes32 m7;
  4144 |     |         bytes32 m8;
  4145 |     |         /// @solidity memory-safe-assembly
  4146 |     |         assembly {
  4147 |     |             function writeString(pos, w) {
  4148 |     |                 let length := 0
  4149 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  4150 |     |                 mstore(pos, length)
  4151 |     |                 let shift := sub(256, shl(3, length))
  4152 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  4153 |     |             }
  4154 |     |             m0 := mload(0x00)
  4155 |     |             m1 := mload(0x20)
  4156 |     |             m2 := mload(0x40)
  4157 |     |             m3 := mload(0x60)
  4158 |     |             m4 := mload(0x80)
  4159 |     |             m5 := mload(0xa0)
  4160 |     |             m6 := mload(0xc0)
  4161 |     |             m7 := mload(0xe0)
  4162 |     |             m8 := mload(0x100)
  4163 |     |             // Selector of `log(address,bool,string,string)`.
  4164 |     |             mstore(0x00, 0x475c5c33)
  4165 |     |             mstore(0x20, p0)
  4166 |     |             mstore(0x40, p1)
  4167 |     |             mstore(0x60, 0x80)
  4168 |     |             mstore(0x80, 0xc0)
  4169 |     |             writeString(0xa0, p2)
  4170 |     |             writeString(0xe0, p3)
  4171 |     |         }
  4172 |     |         _sendLogPayload(0x1c, 0x104);
  4173 |     |         /// @solidity memory-safe-assembly
  4174 |     |         assembly {
  4175 |     |             mstore(0x00, m0)
  4176 |     |             mstore(0x20, m1)
  4177 |     |             mstore(0x40, m2)
  4178 |     |             mstore(0x60, m3)
  4179 |     |             mstore(0x80, m4)
  4180 |     |             mstore(0xa0, m5)
  4181 |     |             mstore(0xc0, m6)
  4182 |     |             mstore(0xe0, m7)
  4183 |     |             mstore(0x100, m8)
  4184 |     |         }
  4185 |     |     }
  4186 |     | 
  4187 |     |     function log(address p0, uint256 p1, address p2, address p3) internal pure {
  4188 |     |         bytes32 m0;
  4189 |     |         bytes32 m1;
  4190 |     |         bytes32 m2;
  4191 |     |         bytes32 m3;
  4192 |     |         bytes32 m4;
  4193 |     |         /// @solidity memory-safe-assembly
  4194 |     |         assembly {
  4195 |     |             m0 := mload(0x00)
  4196 |     |             m1 := mload(0x20)
  4197 |     |             m2 := mload(0x40)
  4198 |     |             m3 := mload(0x60)
  4199 |     |             m4 := mload(0x80)
  4200 |     |             // Selector of `log(address,uint256,address,address)`.
  4201 |     |             mstore(0x00, 0x478d1c62)
  4202 |     |             mstore(0x20, p0)
  4203 |     |             mstore(0x40, p1)
  4204 |     |             mstore(0x60, p2)
  4205 |     |             mstore(0x80, p3)
  4206 |     |         }
  4207 |     |         _sendLogPayload(0x1c, 0x84);
  4208 |     |         /// @solidity memory-safe-assembly
  4209 |     |         assembly {
  4210 |     |             mstore(0x00, m0)
  4211 |     |             mstore(0x20, m1)
  4212 |     |             mstore(0x40, m2)
  4213 |     |             mstore(0x60, m3)
  4214 |     |             mstore(0x80, m4)
  4215 |     |         }
  4216 |     |     }
  4217 |     | 
  4218 |     |     function log(address p0, uint256 p1, address p2, bool p3) internal pure {
  4219 |     |         bytes32 m0;
  4220 |     |         bytes32 m1;
  4221 |     |         bytes32 m2;
  4222 |     |         bytes32 m3;
  4223 |     |         bytes32 m4;
  4224 |     |         /// @solidity memory-safe-assembly
  4225 |     |         assembly {
  4226 |     |             m0 := mload(0x00)
  4227 |     |             m1 := mload(0x20)
  4228 |     |             m2 := mload(0x40)
  4229 |     |             m3 := mload(0x60)
  4230 |     |             m4 := mload(0x80)
  4231 |     |             // Selector of `log(address,uint256,address,bool)`.
  4232 |     |             mstore(0x00, 0xa1bcc9b3)
  4233 |     |             mstore(0x20, p0)
  4234 |     |             mstore(0x40, p1)
  4235 |     |             mstore(0x60, p2)
  4236 |     |             mstore(0x80, p3)
  4237 |     |         }
  4238 |     |         _sendLogPayload(0x1c, 0x84);
  4239 |     |         /// @solidity memory-safe-assembly
  4240 |     |         assembly {
  4241 |     |             mstore(0x00, m0)
  4242 |     |             mstore(0x20, m1)
  4243 |     |             mstore(0x40, m2)
  4244 |     |             mstore(0x60, m3)
  4245 |     |             mstore(0x80, m4)
  4246 |     |         }
  4247 |     |     }
  4248 |     | 
  4249 |     |     function log(address p0, uint256 p1, address p2, uint256 p3) internal pure {
  4250 |     |         bytes32 m0;
  4251 |     |         bytes32 m1;
  4252 |     |         bytes32 m2;
  4253 |     |         bytes32 m3;
  4254 |     |         bytes32 m4;
  4255 |     |         /// @solidity memory-safe-assembly
  4256 |     |         assembly {
  4257 |     |             m0 := mload(0x00)
  4258 |     |             m1 := mload(0x20)
  4259 |     |             m2 := mload(0x40)
  4260 |     |             m3 := mload(0x60)
  4261 |     |             m4 := mload(0x80)
  4262 |     |             // Selector of `log(address,uint256,address,uint256)`.
  4263 |     |             mstore(0x00, 0x100f650e)
  4264 |     |             mstore(0x20, p0)
  4265 |     |             mstore(0x40, p1)
  4266 |     |             mstore(0x60, p2)
  4267 |     |             mstore(0x80, p3)
  4268 |     |         }
  4269 |     |         _sendLogPayload(0x1c, 0x84);
  4270 |     |         /// @solidity memory-safe-assembly
  4271 |     |         assembly {
  4272 |     |             mstore(0x00, m0)
  4273 |     |             mstore(0x20, m1)
  4274 |     |             mstore(0x40, m2)
  4275 |     |             mstore(0x60, m3)
  4276 |     |             mstore(0x80, m4)
  4277 |     |         }
  4278 |     |     }
  4279 |     | 
  4280 |     |     function log(address p0, uint256 p1, address p2, bytes32 p3) internal pure {
  4281 |     |         bytes32 m0;
  4282 |     |         bytes32 m1;
  4283 |     |         bytes32 m2;
  4284 |     |         bytes32 m3;
  4285 |     |         bytes32 m4;
  4286 |     |         bytes32 m5;
  4287 |     |         bytes32 m6;
  4288 |     |         /// @solidity memory-safe-assembly
  4289 |     |         assembly {
  4290 |     |             function writeString(pos, w) {
  4291 |     |                 let length := 0
  4292 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  4293 |     |                 mstore(pos, length)
  4294 |     |                 let shift := sub(256, shl(3, length))
  4295 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  4296 |     |             }
  4297 |     |             m0 := mload(0x00)
  4298 |     |             m1 := mload(0x20)
  4299 |     |             m2 := mload(0x40)
  4300 |     |             m3 := mload(0x60)
  4301 |     |             m4 := mload(0x80)
  4302 |     |             m5 := mload(0xa0)
  4303 |     |             m6 := mload(0xc0)
  4304 |     |             // Selector of `log(address,uint256,address,string)`.
  4305 |     |             mstore(0x00, 0x1da986ea)
  4306 |     |             mstore(0x20, p0)
  4307 |     |             mstore(0x40, p1)
  4308 |     |             mstore(0x60, p2)
  4309 |     |             mstore(0x80, 0x80)
  4310 |     |             writeString(0xa0, p3)
  4311 |     |         }
  4312 |     |         _sendLogPayload(0x1c, 0xc4);
  4313 |     |         /// @solidity memory-safe-assembly
  4314 |     |         assembly {
  4315 |     |             mstore(0x00, m0)
  4316 |     |             mstore(0x20, m1)
  4317 |     |             mstore(0x40, m2)
  4318 |     |             mstore(0x60, m3)
  4319 |     |             mstore(0x80, m4)
  4320 |     |             mstore(0xa0, m5)
  4321 |     |             mstore(0xc0, m6)
  4322 |     |         }
  4323 |     |     }
  4324 |     | 
  4325 |     |     function log(address p0, uint256 p1, bool p2, address p3) internal pure {
  4326 |     |         bytes32 m0;
  4327 |     |         bytes32 m1;
  4328 |     |         bytes32 m2;
  4329 |     |         bytes32 m3;
  4330 |     |         bytes32 m4;
  4331 |     |         /// @solidity memory-safe-assembly
  4332 |     |         assembly {
  4333 |     |             m0 := mload(0x00)
  4334 |     |             m1 := mload(0x20)
  4335 |     |             m2 := mload(0x40)
  4336 |     |             m3 := mload(0x60)
  4337 |     |             m4 := mload(0x80)
  4338 |     |             // Selector of `log(address,uint256,bool,address)`.
  4339 |     |             mstore(0x00, 0xa31bfdcc)
  4340 |     |             mstore(0x20, p0)
  4341 |     |             mstore(0x40, p1)
  4342 |     |             mstore(0x60, p2)
  4343 |     |             mstore(0x80, p3)
  4344 |     |         }
  4345 |     |         _sendLogPayload(0x1c, 0x84);
  4346 |     |         /// @solidity memory-safe-assembly
  4347 |     |         assembly {
  4348 |     |             mstore(0x00, m0)
  4349 |     |             mstore(0x20, m1)
  4350 |     |             mstore(0x40, m2)
  4351 |     |             mstore(0x60, m3)
  4352 |     |             mstore(0x80, m4)
  4353 |     |         }
  4354 |     |     }
  4355 |     | 
  4356 |     |     function log(address p0, uint256 p1, bool p2, bool p3) internal pure {
  4357 |     |         bytes32 m0;
  4358 |     |         bytes32 m1;
  4359 |     |         bytes32 m2;
  4360 |     |         bytes32 m3;
  4361 |     |         bytes32 m4;
  4362 |     |         /// @solidity memory-safe-assembly
  4363 |     |         assembly {
  4364 |     |             m0 := mload(0x00)
  4365 |     |             m1 := mload(0x20)
  4366 |     |             m2 := mload(0x40)
  4367 |     |             m3 := mload(0x60)
  4368 |     |             m4 := mload(0x80)
  4369 |     |             // Selector of `log(address,uint256,bool,bool)`.
  4370 |     |             mstore(0x00, 0x3bf5e537)
  4371 |     |             mstore(0x20, p0)
  4372 |     |             mstore(0x40, p1)
  4373 |     |             mstore(0x60, p2)
  4374 |     |             mstore(0x80, p3)
  4375 |     |         }
  4376 |     |         _sendLogPayload(0x1c, 0x84);
  4377 |     |         /// @solidity memory-safe-assembly
  4378 |     |         assembly {
  4379 |     |             mstore(0x00, m0)
  4380 |     |             mstore(0x20, m1)
  4381 |     |             mstore(0x40, m2)
  4382 |     |             mstore(0x60, m3)
  4383 |     |             mstore(0x80, m4)
  4384 |     |         }
  4385 |     |     }
  4386 |     | 
  4387 |     |     function log(address p0, uint256 p1, bool p2, uint256 p3) internal pure {
  4388 |     |         bytes32 m0;
  4389 |     |         bytes32 m1;
  4390 |     |         bytes32 m2;
  4391 |     |         bytes32 m3;
  4392 |     |         bytes32 m4;
  4393 |     |         /// @solidity memory-safe-assembly
  4394 |     |         assembly {
  4395 |     |             m0 := mload(0x00)
  4396 |     |             m1 := mload(0x20)
  4397 |     |             m2 := mload(0x40)
  4398 |     |             m3 := mload(0x60)
  4399 |     |             m4 := mload(0x80)
  4400 |     |             // Selector of `log(address,uint256,bool,uint256)`.
  4401 |     |             mstore(0x00, 0x22f6b999)
  4402 |     |             mstore(0x20, p0)
  4403 |     |             mstore(0x40, p1)
  4404 |     |             mstore(0x60, p2)
  4405 |     |             mstore(0x80, p3)
  4406 |     |         }
  4407 |     |         _sendLogPayload(0x1c, 0x84);
  4408 |     |         /// @solidity memory-safe-assembly
  4409 |     |         assembly {
  4410 |     |             mstore(0x00, m0)
  4411 |     |             mstore(0x20, m1)
  4412 |     |             mstore(0x40, m2)
  4413 |     |             mstore(0x60, m3)
  4414 |     |             mstore(0x80, m4)
  4415 |     |         }
  4416 |     |     }
  4417 |     | 
  4418 |     |     function log(address p0, uint256 p1, bool p2, bytes32 p3) internal pure {
  4419 |     |         bytes32 m0;
  4420 |     |         bytes32 m1;
  4421 |     |         bytes32 m2;
  4422 |     |         bytes32 m3;
  4423 |     |         bytes32 m4;
  4424 |     |         bytes32 m5;
  4425 |     |         bytes32 m6;
  4426 |     |         /// @solidity memory-safe-assembly
  4427 |     |         assembly {
  4428 |     |             function writeString(pos, w) {
  4429 |     |                 let length := 0
  4430 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  4431 |     |                 mstore(pos, length)
  4432 |     |                 let shift := sub(256, shl(3, length))
  4433 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  4434 |     |             }
  4435 |     |             m0 := mload(0x00)
  4436 |     |             m1 := mload(0x20)
  4437 |     |             m2 := mload(0x40)
  4438 |     |             m3 := mload(0x60)
  4439 |     |             m4 := mload(0x80)
  4440 |     |             m5 := mload(0xa0)
  4441 |     |             m6 := mload(0xc0)
  4442 |     |             // Selector of `log(address,uint256,bool,string)`.
  4443 |     |             mstore(0x00, 0xc5ad85f9)
  4444 |     |             mstore(0x20, p0)
  4445 |     |             mstore(0x40, p1)
  4446 |     |             mstore(0x60, p2)
  4447 |     |             mstore(0x80, 0x80)
  4448 |     |             writeString(0xa0, p3)
  4449 |     |         }
  4450 |     |         _sendLogPayload(0x1c, 0xc4);
  4451 |     |         /// @solidity memory-safe-assembly
  4452 |     |         assembly {
  4453 |     |             mstore(0x00, m0)
  4454 |     |             mstore(0x20, m1)
  4455 |     |             mstore(0x40, m2)
  4456 |     |             mstore(0x60, m3)
  4457 |     |             mstore(0x80, m4)
  4458 |     |             mstore(0xa0, m5)
  4459 |     |             mstore(0xc0, m6)
  4460 |     |         }
  4461 |     |     }
  4462 |     | 
  4463 |     |     function log(address p0, uint256 p1, uint256 p2, address p3) internal pure {
  4464 |     |         bytes32 m0;
  4465 |     |         bytes32 m1;
  4466 |     |         bytes32 m2;
  4467 |     |         bytes32 m3;
  4468 |     |         bytes32 m4;
  4469 |     |         /// @solidity memory-safe-assembly
  4470 |     |         assembly {
  4471 |     |             m0 := mload(0x00)
  4472 |     |             m1 := mload(0x20)
  4473 |     |             m2 := mload(0x40)
  4474 |     |             m3 := mload(0x60)
  4475 |     |             m4 := mload(0x80)
  4476 |     |             // Selector of `log(address,uint256,uint256,address)`.
  4477 |     |             mstore(0x00, 0x20e3984d)
  4478 |     |             mstore(0x20, p0)
  4479 |     |             mstore(0x40, p1)
  4480 |     |             mstore(0x60, p2)
  4481 |     |             mstore(0x80, p3)
  4482 |     |         }
  4483 |     |         _sendLogPayload(0x1c, 0x84);
  4484 |     |         /// @solidity memory-safe-assembly
  4485 |     |         assembly {
  4486 |     |             mstore(0x00, m0)
  4487 |     |             mstore(0x20, m1)
  4488 |     |             mstore(0x40, m2)
  4489 |     |             mstore(0x60, m3)
  4490 |     |             mstore(0x80, m4)
  4491 |     |         }
  4492 |     |     }
  4493 |     | 
  4494 |     |     function log(address p0, uint256 p1, uint256 p2, bool p3) internal pure {
  4495 |     |         bytes32 m0;
  4496 |     |         bytes32 m1;
  4497 |     |         bytes32 m2;
  4498 |     |         bytes32 m3;
  4499 |     |         bytes32 m4;
  4500 |     |         /// @solidity memory-safe-assembly
  4501 |     |         assembly {
  4502 |     |             m0 := mload(0x00)
  4503 |     |             m1 := mload(0x20)
  4504 |     |             m2 := mload(0x40)
  4505 |     |             m3 := mload(0x60)
  4506 |     |             m4 := mload(0x80)
  4507 |     |             // Selector of `log(address,uint256,uint256,bool)`.
  4508 |     |             mstore(0x00, 0x66f1bc67)
  4509 |     |             mstore(0x20, p0)
  4510 |     |             mstore(0x40, p1)
  4511 |     |             mstore(0x60, p2)
  4512 |     |             mstore(0x80, p3)
  4513 |     |         }
  4514 |     |         _sendLogPayload(0x1c, 0x84);
  4515 |     |         /// @solidity memory-safe-assembly
  4516 |     |         assembly {
  4517 |     |             mstore(0x00, m0)
  4518 |     |             mstore(0x20, m1)
  4519 |     |             mstore(0x40, m2)
  4520 |     |             mstore(0x60, m3)
  4521 |     |             mstore(0x80, m4)
  4522 |     |         }
  4523 |     |     }
  4524 |     | 
  4525 |     |     function log(address p0, uint256 p1, uint256 p2, uint256 p3) internal pure {
  4526 |     |         bytes32 m0;
  4527 |     |         bytes32 m1;
  4528 |     |         bytes32 m2;
  4529 |     |         bytes32 m3;
  4530 |     |         bytes32 m4;
  4531 |     |         /// @solidity memory-safe-assembly
  4532 |     |         assembly {
  4533 |     |             m0 := mload(0x00)
  4534 |     |             m1 := mload(0x20)
  4535 |     |             m2 := mload(0x40)
  4536 |     |             m3 := mload(0x60)
  4537 |     |             m4 := mload(0x80)
  4538 |     |             // Selector of `log(address,uint256,uint256,uint256)`.
  4539 |     |             mstore(0x00, 0x34f0e636)
  4540 |     |             mstore(0x20, p0)
  4541 |     |             mstore(0x40, p1)
  4542 |     |             mstore(0x60, p2)
  4543 |     |             mstore(0x80, p3)
  4544 |     |         }
  4545 |     |         _sendLogPayload(0x1c, 0x84);
  4546 |     |         /// @solidity memory-safe-assembly
  4547 |     |         assembly {
  4548 |     |             mstore(0x00, m0)
  4549 |     |             mstore(0x20, m1)
  4550 |     |             mstore(0x40, m2)
  4551 |     |             mstore(0x60, m3)
  4552 |     |             mstore(0x80, m4)
  4553 |     |         }
  4554 |     |     }
  4555 |     | 
  4556 |     |     function log(address p0, uint256 p1, uint256 p2, bytes32 p3) internal pure {
  4557 |     |         bytes32 m0;
  4558 |     |         bytes32 m1;
  4559 |     |         bytes32 m2;
  4560 |     |         bytes32 m3;
  4561 |     |         bytes32 m4;
  4562 |     |         bytes32 m5;
  4563 |     |         bytes32 m6;
  4564 |     |         /// @solidity memory-safe-assembly
  4565 |     |         assembly {
  4566 |     |             function writeString(pos, w) {
  4567 |     |                 let length := 0
  4568 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  4569 |     |                 mstore(pos, length)
  4570 |     |                 let shift := sub(256, shl(3, length))
  4571 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  4572 |     |             }
  4573 |     |             m0 := mload(0x00)
  4574 |     |             m1 := mload(0x20)
  4575 |     |             m2 := mload(0x40)
  4576 |     |             m3 := mload(0x60)
  4577 |     |             m4 := mload(0x80)
  4578 |     |             m5 := mload(0xa0)
  4579 |     |             m6 := mload(0xc0)
  4580 |     |             // Selector of `log(address,uint256,uint256,string)`.
  4581 |     |             mstore(0x00, 0x4a28c017)
  4582 |     |             mstore(0x20, p0)
  4583 |     |             mstore(0x40, p1)
  4584 |     |             mstore(0x60, p2)
  4585 |     |             mstore(0x80, 0x80)
  4586 |     |             writeString(0xa0, p3)
  4587 |     |         }
  4588 |     |         _sendLogPayload(0x1c, 0xc4);
  4589 |     |         /// @solidity memory-safe-assembly
  4590 |     |         assembly {
  4591 |     |             mstore(0x00, m0)
  4592 |     |             mstore(0x20, m1)
  4593 |     |             mstore(0x40, m2)
  4594 |     |             mstore(0x60, m3)
  4595 |     |             mstore(0x80, m4)
  4596 |     |             mstore(0xa0, m5)
  4597 |     |             mstore(0xc0, m6)
  4598 |     |         }
  4599 |     |     }
  4600 |     | 
  4601 |     |     function log(address p0, uint256 p1, bytes32 p2, address p3) internal pure {
  4602 |     |         bytes32 m0;
  4603 |     |         bytes32 m1;
  4604 |     |         bytes32 m2;
  4605 |     |         bytes32 m3;
  4606 |     |         bytes32 m4;
  4607 |     |         bytes32 m5;
  4608 |     |         bytes32 m6;
  4609 |     |         /// @solidity memory-safe-assembly
  4610 |     |         assembly {
  4611 |     |             function writeString(pos, w) {
  4612 |     |                 let length := 0
  4613 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  4614 |     |                 mstore(pos, length)
  4615 |     |                 let shift := sub(256, shl(3, length))
  4616 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  4617 |     |             }
  4618 |     |             m0 := mload(0x00)
  4619 |     |             m1 := mload(0x20)
  4620 |     |             m2 := mload(0x40)
  4621 |     |             m3 := mload(0x60)
  4622 |     |             m4 := mload(0x80)
  4623 |     |             m5 := mload(0xa0)
  4624 |     |             m6 := mload(0xc0)
  4625 |     |             // Selector of `log(address,uint256,string,address)`.
  4626 |     |             mstore(0x00, 0x5c430d47)
  4627 |     |             mstore(0x20, p0)
  4628 |     |             mstore(0x40, p1)
  4629 |     |             mstore(0x60, 0x80)
  4630 |     |             mstore(0x80, p3)
  4631 |     |             writeString(0xa0, p2)
  4632 |     |         }
  4633 |     |         _sendLogPayload(0x1c, 0xc4);
  4634 |     |         /// @solidity memory-safe-assembly
  4635 |     |         assembly {
  4636 |     |             mstore(0x00, m0)
  4637 |     |             mstore(0x20, m1)
  4638 |     |             mstore(0x40, m2)
  4639 |     |             mstore(0x60, m3)
  4640 |     |             mstore(0x80, m4)
  4641 |     |             mstore(0xa0, m5)
  4642 |     |             mstore(0xc0, m6)
  4643 |     |         }
  4644 |     |     }
  4645 |     | 
  4646 |     |     function log(address p0, uint256 p1, bytes32 p2, bool p3) internal pure {
  4647 |     |         bytes32 m0;
  4648 |     |         bytes32 m1;
  4649 |     |         bytes32 m2;
  4650 |     |         bytes32 m3;
  4651 |     |         bytes32 m4;
  4652 |     |         bytes32 m5;
  4653 |     |         bytes32 m6;
  4654 |     |         /// @solidity memory-safe-assembly
  4655 |     |         assembly {
  4656 |     |             function writeString(pos, w) {
  4657 |     |                 let length := 0
  4658 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  4659 |     |                 mstore(pos, length)
  4660 |     |                 let shift := sub(256, shl(3, length))
  4661 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  4662 |     |             }
  4663 |     |             m0 := mload(0x00)
  4664 |     |             m1 := mload(0x20)
  4665 |     |             m2 := mload(0x40)
  4666 |     |             m3 := mload(0x60)
  4667 |     |             m4 := mload(0x80)
  4668 |     |             m5 := mload(0xa0)
  4669 |     |             m6 := mload(0xc0)
  4670 |     |             // Selector of `log(address,uint256,string,bool)`.
  4671 |     |             mstore(0x00, 0xcf18105c)
  4672 |     |             mstore(0x20, p0)
  4673 |     |             mstore(0x40, p1)
  4674 |     |             mstore(0x60, 0x80)
  4675 |     |             mstore(0x80, p3)
  4676 |     |             writeString(0xa0, p2)
  4677 |     |         }
  4678 |     |         _sendLogPayload(0x1c, 0xc4);
  4679 |     |         /// @solidity memory-safe-assembly
  4680 |     |         assembly {
  4681 |     |             mstore(0x00, m0)
  4682 |     |             mstore(0x20, m1)
  4683 |     |             mstore(0x40, m2)
  4684 |     |             mstore(0x60, m3)
  4685 |     |             mstore(0x80, m4)
  4686 |     |             mstore(0xa0, m5)
  4687 |     |             mstore(0xc0, m6)
  4688 |     |         }
  4689 |     |     }
  4690 |     | 
  4691 |     |     function log(address p0, uint256 p1, bytes32 p2, uint256 p3) internal pure {
  4692 |     |         bytes32 m0;
  4693 |     |         bytes32 m1;
  4694 |     |         bytes32 m2;
  4695 |     |         bytes32 m3;
  4696 |     |         bytes32 m4;
  4697 |     |         bytes32 m5;
  4698 |     |         bytes32 m6;
  4699 |     |         /// @solidity memory-safe-assembly
  4700 |     |         assembly {
  4701 |     |             function writeString(pos, w) {
  4702 |     |                 let length := 0
  4703 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  4704 |     |                 mstore(pos, length)
  4705 |     |                 let shift := sub(256, shl(3, length))
  4706 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  4707 |     |             }
  4708 |     |             m0 := mload(0x00)
  4709 |     |             m1 := mload(0x20)
  4710 |     |             m2 := mload(0x40)
  4711 |     |             m3 := mload(0x60)
  4712 |     |             m4 := mload(0x80)
  4713 |     |             m5 := mload(0xa0)
  4714 |     |             m6 := mload(0xc0)
  4715 |     |             // Selector of `log(address,uint256,string,uint256)`.
  4716 |     |             mstore(0x00, 0xbf01f891)
  4717 |     |             mstore(0x20, p0)
  4718 |     |             mstore(0x40, p1)
  4719 |     |             mstore(0x60, 0x80)
  4720 |     |             mstore(0x80, p3)
  4721 |     |             writeString(0xa0, p2)
  4722 |     |         }
  4723 |     |         _sendLogPayload(0x1c, 0xc4);
  4724 |     |         /// @solidity memory-safe-assembly
  4725 |     |         assembly {
  4726 |     |             mstore(0x00, m0)
  4727 |     |             mstore(0x20, m1)
  4728 |     |             mstore(0x40, m2)
  4729 |     |             mstore(0x60, m3)
  4730 |     |             mstore(0x80, m4)
  4731 |     |             mstore(0xa0, m5)
  4732 |     |             mstore(0xc0, m6)
  4733 |     |         }
  4734 |     |     }
  4735 |     | 
  4736 |     |     function log(address p0, uint256 p1, bytes32 p2, bytes32 p3) internal pure {
  4737 |     |         bytes32 m0;
  4738 |     |         bytes32 m1;
  4739 |     |         bytes32 m2;
  4740 |     |         bytes32 m3;
  4741 |     |         bytes32 m4;
  4742 |     |         bytes32 m5;
  4743 |     |         bytes32 m6;
  4744 |     |         bytes32 m7;
  4745 |     |         bytes32 m8;
  4746 |     |         /// @solidity memory-safe-assembly
  4747 |     |         assembly {
  4748 |     |             function writeString(pos, w) {
  4749 |     |                 let length := 0
  4750 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  4751 |     |                 mstore(pos, length)
  4752 |     |                 let shift := sub(256, shl(3, length))
  4753 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  4754 |     |             }
  4755 |     |             m0 := mload(0x00)
  4756 |     |             m1 := mload(0x20)
  4757 |     |             m2 := mload(0x40)
  4758 |     |             m3 := mload(0x60)
  4759 |     |             m4 := mload(0x80)
  4760 |     |             m5 := mload(0xa0)
  4761 |     |             m6 := mload(0xc0)
  4762 |     |             m7 := mload(0xe0)
  4763 |     |             m8 := mload(0x100)
  4764 |     |             // Selector of `log(address,uint256,string,string)`.
  4765 |     |             mstore(0x00, 0x88a8c406)
  4766 |     |             mstore(0x20, p0)
  4767 |     |             mstore(0x40, p1)
  4768 |     |             mstore(0x60, 0x80)
  4769 |     |             mstore(0x80, 0xc0)
  4770 |     |             writeString(0xa0, p2)
  4771 |     |             writeString(0xe0, p3)
  4772 |     |         }
  4773 |     |         _sendLogPayload(0x1c, 0x104);
  4774 |     |         /// @solidity memory-safe-assembly
  4775 |     |         assembly {
  4776 |     |             mstore(0x00, m0)
  4777 |     |             mstore(0x20, m1)
  4778 |     |             mstore(0x40, m2)
  4779 |     |             mstore(0x60, m3)
  4780 |     |             mstore(0x80, m4)
  4781 |     |             mstore(0xa0, m5)
  4782 |     |             mstore(0xc0, m6)
  4783 |     |             mstore(0xe0, m7)
  4784 |     |             mstore(0x100, m8)
  4785 |     |         }
  4786 |     |     }
  4787 |     | 
  4788 |     |     function log(address p0, bytes32 p1, address p2, address p3) internal pure {
  4789 |     |         bytes32 m0;
  4790 |     |         bytes32 m1;
  4791 |     |         bytes32 m2;
  4792 |     |         bytes32 m3;
  4793 |     |         bytes32 m4;
  4794 |     |         bytes32 m5;
  4795 |     |         bytes32 m6;
  4796 |     |         /// @solidity memory-safe-assembly
  4797 |     |         assembly {
  4798 |     |             function writeString(pos, w) {
  4799 |     |                 let length := 0
  4800 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  4801 |     |                 mstore(pos, length)
  4802 |     |                 let shift := sub(256, shl(3, length))
  4803 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  4804 |     |             }
  4805 |     |             m0 := mload(0x00)
  4806 |     |             m1 := mload(0x20)
  4807 |     |             m2 := mload(0x40)
  4808 |     |             m3 := mload(0x60)
  4809 |     |             m4 := mload(0x80)
  4810 |     |             m5 := mload(0xa0)
  4811 |     |             m6 := mload(0xc0)
  4812 |     |             // Selector of `log(address,string,address,address)`.
  4813 |     |             mstore(0x00, 0x0d36fa20)
  4814 |     |             mstore(0x20, p0)
  4815 |     |             mstore(0x40, 0x80)
  4816 |     |             mstore(0x60, p2)
  4817 |     |             mstore(0x80, p3)
  4818 |     |             writeString(0xa0, p1)
  4819 |     |         }
  4820 |     |         _sendLogPayload(0x1c, 0xc4);
  4821 |     |         /// @solidity memory-safe-assembly
  4822 |     |         assembly {
  4823 |     |             mstore(0x00, m0)
  4824 |     |             mstore(0x20, m1)
  4825 |     |             mstore(0x40, m2)
  4826 |     |             mstore(0x60, m3)
  4827 |     |             mstore(0x80, m4)
  4828 |     |             mstore(0xa0, m5)
  4829 |     |             mstore(0xc0, m6)
  4830 |     |         }
  4831 |     |     }
  4832 |     | 
  4833 |     |     function log(address p0, bytes32 p1, address p2, bool p3) internal pure {
  4834 |     |         bytes32 m0;
  4835 |     |         bytes32 m1;
  4836 |     |         bytes32 m2;
  4837 |     |         bytes32 m3;
  4838 |     |         bytes32 m4;
  4839 |     |         bytes32 m5;
  4840 |     |         bytes32 m6;
  4841 |     |         /// @solidity memory-safe-assembly
  4842 |     |         assembly {
  4843 |     |             function writeString(pos, w) {
  4844 |     |                 let length := 0
  4845 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  4846 |     |                 mstore(pos, length)
  4847 |     |                 let shift := sub(256, shl(3, length))
  4848 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  4849 |     |             }
  4850 |     |             m0 := mload(0x00)
  4851 |     |             m1 := mload(0x20)
  4852 |     |             m2 := mload(0x40)
  4853 |     |             m3 := mload(0x60)
  4854 |     |             m4 := mload(0x80)
  4855 |     |             m5 := mload(0xa0)
  4856 |     |             m6 := mload(0xc0)
  4857 |     |             // Selector of `log(address,string,address,bool)`.
  4858 |     |             mstore(0x00, 0x0df12b76)
  4859 |     |             mstore(0x20, p0)
  4860 |     |             mstore(0x40, 0x80)
  4861 |     |             mstore(0x60, p2)
  4862 |     |             mstore(0x80, p3)
  4863 |     |             writeString(0xa0, p1)
  4864 |     |         }
  4865 |     |         _sendLogPayload(0x1c, 0xc4);
  4866 |     |         /// @solidity memory-safe-assembly
  4867 |     |         assembly {
  4868 |     |             mstore(0x00, m0)
  4869 |     |             mstore(0x20, m1)
  4870 |     |             mstore(0x40, m2)
  4871 |     |             mstore(0x60, m3)
  4872 |     |             mstore(0x80, m4)
  4873 |     |             mstore(0xa0, m5)
  4874 |     |             mstore(0xc0, m6)
  4875 |     |         }
  4876 |     |     }
  4877 |     | 
  4878 |     |     function log(address p0, bytes32 p1, address p2, uint256 p3) internal pure {
  4879 |     |         bytes32 m0;
  4880 |     |         bytes32 m1;
  4881 |     |         bytes32 m2;
  4882 |     |         bytes32 m3;
  4883 |     |         bytes32 m4;
  4884 |     |         bytes32 m5;
  4885 |     |         bytes32 m6;
  4886 |     |         /// @solidity memory-safe-assembly
  4887 |     |         assembly {
  4888 |     |             function writeString(pos, w) {
  4889 |     |                 let length := 0
  4890 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  4891 |     |                 mstore(pos, length)
  4892 |     |                 let shift := sub(256, shl(3, length))
  4893 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  4894 |     |             }
  4895 |     |             m0 := mload(0x00)
  4896 |     |             m1 := mload(0x20)
  4897 |     |             m2 := mload(0x40)
  4898 |     |             m3 := mload(0x60)
  4899 |     |             m4 := mload(0x80)
  4900 |     |             m5 := mload(0xa0)
  4901 |     |             m6 := mload(0xc0)
  4902 |     |             // Selector of `log(address,string,address,uint256)`.
  4903 |     |             mstore(0x00, 0x457fe3cf)
  4904 |     |             mstore(0x20, p0)
  4905 |     |             mstore(0x40, 0x80)
  4906 |     |             mstore(0x60, p2)
  4907 |     |             mstore(0x80, p3)
  4908 |     |             writeString(0xa0, p1)
  4909 |     |         }
  4910 |     |         _sendLogPayload(0x1c, 0xc4);
  4911 |     |         /// @solidity memory-safe-assembly
  4912 |     |         assembly {
  4913 |     |             mstore(0x00, m0)
  4914 |     |             mstore(0x20, m1)
  4915 |     |             mstore(0x40, m2)
  4916 |     |             mstore(0x60, m3)
  4917 |     |             mstore(0x80, m4)
  4918 |     |             mstore(0xa0, m5)
  4919 |     |             mstore(0xc0, m6)
  4920 |     |         }
  4921 |     |     }
  4922 |     | 
  4923 |     |     function log(address p0, bytes32 p1, address p2, bytes32 p3) internal pure {
  4924 |     |         bytes32 m0;
  4925 |     |         bytes32 m1;
  4926 |     |         bytes32 m2;
  4927 |     |         bytes32 m3;
  4928 |     |         bytes32 m4;
  4929 |     |         bytes32 m5;
  4930 |     |         bytes32 m6;
  4931 |     |         bytes32 m7;
  4932 |     |         bytes32 m8;
  4933 |     |         /// @solidity memory-safe-assembly
  4934 |     |         assembly {
  4935 |     |             function writeString(pos, w) {
  4936 |     |                 let length := 0
  4937 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  4938 |     |                 mstore(pos, length)
  4939 |     |                 let shift := sub(256, shl(3, length))
  4940 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  4941 |     |             }
  4942 |     |             m0 := mload(0x00)
  4943 |     |             m1 := mload(0x20)
  4944 |     |             m2 := mload(0x40)
  4945 |     |             m3 := mload(0x60)
  4946 |     |             m4 := mload(0x80)
  4947 |     |             m5 := mload(0xa0)
  4948 |     |             m6 := mload(0xc0)
  4949 |     |             m7 := mload(0xe0)
  4950 |     |             m8 := mload(0x100)
  4951 |     |             // Selector of `log(address,string,address,string)`.
  4952 |     |             mstore(0x00, 0xf7e36245)
  4953 |     |             mstore(0x20, p0)
  4954 |     |             mstore(0x40, 0x80)
  4955 |     |             mstore(0x60, p2)
  4956 |     |             mstore(0x80, 0xc0)
  4957 |     |             writeString(0xa0, p1)
  4958 |     |             writeString(0xe0, p3)
  4959 |     |         }
  4960 |     |         _sendLogPayload(0x1c, 0x104);
  4961 |     |         /// @solidity memory-safe-assembly
  4962 |     |         assembly {
  4963 |     |             mstore(0x00, m0)
  4964 |     |             mstore(0x20, m1)
  4965 |     |             mstore(0x40, m2)
  4966 |     |             mstore(0x60, m3)
  4967 |     |             mstore(0x80, m4)
  4968 |     |             mstore(0xa0, m5)
  4969 |     |             mstore(0xc0, m6)
  4970 |     |             mstore(0xe0, m7)
  4971 |     |             mstore(0x100, m8)
  4972 |     |         }
  4973 |     |     }
  4974 |     | 
  4975 |     |     function log(address p0, bytes32 p1, bool p2, address p3) internal pure {
  4976 |     |         bytes32 m0;
  4977 |     |         bytes32 m1;
  4978 |     |         bytes32 m2;
  4979 |     |         bytes32 m3;
  4980 |     |         bytes32 m4;
  4981 |     |         bytes32 m5;
  4982 |     |         bytes32 m6;
  4983 |     |         /// @solidity memory-safe-assembly
  4984 |     |         assembly {
  4985 |     |             function writeString(pos, w) {
  4986 |     |                 let length := 0
  4987 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  4988 |     |                 mstore(pos, length)
  4989 |     |                 let shift := sub(256, shl(3, length))
  4990 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  4991 |     |             }
  4992 |     |             m0 := mload(0x00)
  4993 |     |             m1 := mload(0x20)
  4994 |     |             m2 := mload(0x40)
  4995 |     |             m3 := mload(0x60)
  4996 |     |             m4 := mload(0x80)
  4997 |     |             m5 := mload(0xa0)
  4998 |     |             m6 := mload(0xc0)
  4999 |     |             // Selector of `log(address,string,bool,address)`.
  5000 |     |             mstore(0x00, 0x205871c2)
  5001 |     |             mstore(0x20, p0)
  5002 |     |             mstore(0x40, 0x80)
  5003 |     |             mstore(0x60, p2)
  5004 |     |             mstore(0x80, p3)
  5005 |     |             writeString(0xa0, p1)
  5006 |     |         }
  5007 |     |         _sendLogPayload(0x1c, 0xc4);
  5008 |     |         /// @solidity memory-safe-assembly
  5009 |     |         assembly {
  5010 |     |             mstore(0x00, m0)
  5011 |     |             mstore(0x20, m1)
  5012 |     |             mstore(0x40, m2)
  5013 |     |             mstore(0x60, m3)
  5014 |     |             mstore(0x80, m4)
  5015 |     |             mstore(0xa0, m5)
  5016 |     |             mstore(0xc0, m6)
  5017 |     |         }
  5018 |     |     }
  5019 |     | 
  5020 |     |     function log(address p0, bytes32 p1, bool p2, bool p3) internal pure {
  5021 |     |         bytes32 m0;
  5022 |     |         bytes32 m1;
  5023 |     |         bytes32 m2;
  5024 |     |         bytes32 m3;
  5025 |     |         bytes32 m4;
  5026 |     |         bytes32 m5;
  5027 |     |         bytes32 m6;
  5028 |     |         /// @solidity memory-safe-assembly
  5029 |     |         assembly {
  5030 |     |             function writeString(pos, w) {
  5031 |     |                 let length := 0
  5032 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  5033 |     |                 mstore(pos, length)
  5034 |     |                 let shift := sub(256, shl(3, length))
  5035 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  5036 |     |             }
  5037 |     |             m0 := mload(0x00)
  5038 |     |             m1 := mload(0x20)
  5039 |     |             m2 := mload(0x40)
  5040 |     |             m3 := mload(0x60)
  5041 |     |             m4 := mload(0x80)
  5042 |     |             m5 := mload(0xa0)
  5043 |     |             m6 := mload(0xc0)
  5044 |     |             // Selector of `log(address,string,bool,bool)`.
  5045 |     |             mstore(0x00, 0x5f1d5c9f)
  5046 |     |             mstore(0x20, p0)
  5047 |     |             mstore(0x40, 0x80)
  5048 |     |             mstore(0x60, p2)
  5049 |     |             mstore(0x80, p3)
  5050 |     |             writeString(0xa0, p1)
  5051 |     |         }
  5052 |     |         _sendLogPayload(0x1c, 0xc4);
  5053 |     |         /// @solidity memory-safe-assembly
  5054 |     |         assembly {
  5055 |     |             mstore(0x00, m0)
  5056 |     |             mstore(0x20, m1)
  5057 |     |             mstore(0x40, m2)
  5058 |     |             mstore(0x60, m3)
  5059 |     |             mstore(0x80, m4)
  5060 |     |             mstore(0xa0, m5)
  5061 |     |             mstore(0xc0, m6)
  5062 |     |         }
  5063 |     |     }
  5064 |     | 
  5065 |     |     function log(address p0, bytes32 p1, bool p2, uint256 p3) internal pure {
  5066 |     |         bytes32 m0;
  5067 |     |         bytes32 m1;
  5068 |     |         bytes32 m2;
  5069 |     |         bytes32 m3;
  5070 |     |         bytes32 m4;
  5071 |     |         bytes32 m5;
  5072 |     |         bytes32 m6;
  5073 |     |         /// @solidity memory-safe-assembly
  5074 |     |         assembly {
  5075 |     |             function writeString(pos, w) {
  5076 |     |                 let length := 0
  5077 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  5078 |     |                 mstore(pos, length)
  5079 |     |                 let shift := sub(256, shl(3, length))
  5080 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  5081 |     |             }
  5082 |     |             m0 := mload(0x00)
  5083 |     |             m1 := mload(0x20)
  5084 |     |             m2 := mload(0x40)
  5085 |     |             m3 := mload(0x60)
  5086 |     |             m4 := mload(0x80)
  5087 |     |             m5 := mload(0xa0)
  5088 |     |             m6 := mload(0xc0)
  5089 |     |             // Selector of `log(address,string,bool,uint256)`.
  5090 |     |             mstore(0x00, 0x515e38b6)
  5091 |     |             mstore(0x20, p0)
  5092 |     |             mstore(0x40, 0x80)
  5093 |     |             mstore(0x60, p2)
  5094 |     |             mstore(0x80, p3)
  5095 |     |             writeString(0xa0, p1)
  5096 |     |         }
  5097 |     |         _sendLogPayload(0x1c, 0xc4);
  5098 |     |         /// @solidity memory-safe-assembly
  5099 |     |         assembly {
  5100 |     |             mstore(0x00, m0)
  5101 |     |             mstore(0x20, m1)
  5102 |     |             mstore(0x40, m2)
  5103 |     |             mstore(0x60, m3)
  5104 |     |             mstore(0x80, m4)
  5105 |     |             mstore(0xa0, m5)
  5106 |     |             mstore(0xc0, m6)
  5107 |     |         }
  5108 |     |     }
  5109 |     | 
  5110 |     |     function log(address p0, bytes32 p1, bool p2, bytes32 p3) internal pure {
  5111 |     |         bytes32 m0;
  5112 |     |         bytes32 m1;
  5113 |     |         bytes32 m2;
  5114 |     |         bytes32 m3;
  5115 |     |         bytes32 m4;
  5116 |     |         bytes32 m5;
  5117 |     |         bytes32 m6;
  5118 |     |         bytes32 m7;
  5119 |     |         bytes32 m8;
  5120 |     |         /// @solidity memory-safe-assembly
  5121 |     |         assembly {
  5122 |     |             function writeString(pos, w) {
  5123 |     |                 let length := 0
  5124 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  5125 |     |                 mstore(pos, length)
  5126 |     |                 let shift := sub(256, shl(3, length))
  5127 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  5128 |     |             }
  5129 |     |             m0 := mload(0x00)
  5130 |     |             m1 := mload(0x20)
  5131 |     |             m2 := mload(0x40)
  5132 |     |             m3 := mload(0x60)
  5133 |     |             m4 := mload(0x80)
  5134 |     |             m5 := mload(0xa0)
  5135 |     |             m6 := mload(0xc0)
  5136 |     |             m7 := mload(0xe0)
  5137 |     |             m8 := mload(0x100)
  5138 |     |             // Selector of `log(address,string,bool,string)`.
  5139 |     |             mstore(0x00, 0xbc0b61fe)
  5140 |     |             mstore(0x20, p0)
  5141 |     |             mstore(0x40, 0x80)
  5142 |     |             mstore(0x60, p2)
  5143 |     |             mstore(0x80, 0xc0)
  5144 |     |             writeString(0xa0, p1)
  5145 |     |             writeString(0xe0, p3)
  5146 |     |         }
  5147 |     |         _sendLogPayload(0x1c, 0x104);
  5148 |     |         /// @solidity memory-safe-assembly
  5149 |     |         assembly {
  5150 |     |             mstore(0x00, m0)
  5151 |     |             mstore(0x20, m1)
  5152 |     |             mstore(0x40, m2)
  5153 |     |             mstore(0x60, m3)
  5154 |     |             mstore(0x80, m4)
  5155 |     |             mstore(0xa0, m5)
  5156 |     |             mstore(0xc0, m6)
  5157 |     |             mstore(0xe0, m7)
  5158 |     |             mstore(0x100, m8)
  5159 |     |         }
  5160 |     |     }
  5161 |     | 
  5162 |     |     function log(address p0, bytes32 p1, uint256 p2, address p3) internal pure {
  5163 |     |         bytes32 m0;
  5164 |     |         bytes32 m1;
  5165 |     |         bytes32 m2;
  5166 |     |         bytes32 m3;
  5167 |     |         bytes32 m4;
  5168 |     |         bytes32 m5;
  5169 |     |         bytes32 m6;
  5170 |     |         /// @solidity memory-safe-assembly
  5171 |     |         assembly {
  5172 |     |             function writeString(pos, w) {
  5173 |     |                 let length := 0
  5174 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  5175 |     |                 mstore(pos, length)
  5176 |     |                 let shift := sub(256, shl(3, length))
  5177 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  5178 |     |             }
  5179 |     |             m0 := mload(0x00)
  5180 |     |             m1 := mload(0x20)
  5181 |     |             m2 := mload(0x40)
  5182 |     |             m3 := mload(0x60)
  5183 |     |             m4 := mload(0x80)
  5184 |     |             m5 := mload(0xa0)
  5185 |     |             m6 := mload(0xc0)
  5186 |     |             // Selector of `log(address,string,uint256,address)`.
  5187 |     |             mstore(0x00, 0x63183678)
  5188 |     |             mstore(0x20, p0)
  5189 |     |             mstore(0x40, 0x80)
  5190 |     |             mstore(0x60, p2)
  5191 |     |             mstore(0x80, p3)
  5192 |     |             writeString(0xa0, p1)
  5193 |     |         }
  5194 |     |         _sendLogPayload(0x1c, 0xc4);
  5195 |     |         /// @solidity memory-safe-assembly
  5196 |     |         assembly {
  5197 |     |             mstore(0x00, m0)
  5198 |     |             mstore(0x20, m1)
  5199 |     |             mstore(0x40, m2)
  5200 |     |             mstore(0x60, m3)
  5201 |     |             mstore(0x80, m4)
  5202 |     |             mstore(0xa0, m5)
  5203 |     |             mstore(0xc0, m6)
  5204 |     |         }
  5205 |     |     }
  5206 |     | 
  5207 |     |     function log(address p0, bytes32 p1, uint256 p2, bool p3) internal pure {
  5208 |     |         bytes32 m0;
  5209 |     |         bytes32 m1;
  5210 |     |         bytes32 m2;
  5211 |     |         bytes32 m3;
  5212 |     |         bytes32 m4;
  5213 |     |         bytes32 m5;
  5214 |     |         bytes32 m6;
  5215 |     |         /// @solidity memory-safe-assembly
  5216 |     |         assembly {
  5217 |     |             function writeString(pos, w) {
  5218 |     |                 let length := 0
  5219 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  5220 |     |                 mstore(pos, length)
  5221 |     |                 let shift := sub(256, shl(3, length))
  5222 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  5223 |     |             }
  5224 |     |             m0 := mload(0x00)
  5225 |     |             m1 := mload(0x20)
  5226 |     |             m2 := mload(0x40)
  5227 |     |             m3 := mload(0x60)
  5228 |     |             m4 := mload(0x80)
  5229 |     |             m5 := mload(0xa0)
  5230 |     |             m6 := mload(0xc0)
  5231 |     |             // Selector of `log(address,string,uint256,bool)`.
  5232 |     |             mstore(0x00, 0x0ef7e050)
  5233 |     |             mstore(0x20, p0)
  5234 |     |             mstore(0x40, 0x80)
  5235 |     |             mstore(0x60, p2)
  5236 |     |             mstore(0x80, p3)
  5237 |     |             writeString(0xa0, p1)
  5238 |     |         }
  5239 |     |         _sendLogPayload(0x1c, 0xc4);
  5240 |     |         /// @solidity memory-safe-assembly
  5241 |     |         assembly {
  5242 |     |             mstore(0x00, m0)
  5243 |     |             mstore(0x20, m1)
  5244 |     |             mstore(0x40, m2)
  5245 |     |             mstore(0x60, m3)
  5246 |     |             mstore(0x80, m4)
  5247 |     |             mstore(0xa0, m5)
  5248 |     |             mstore(0xc0, m6)
  5249 |     |         }
  5250 |     |     }
  5251 |     | 
  5252 |     |     function log(address p0, bytes32 p1, uint256 p2, uint256 p3) internal pure {
  5253 |     |         bytes32 m0;
  5254 |     |         bytes32 m1;
  5255 |     |         bytes32 m2;
  5256 |     |         bytes32 m3;
  5257 |     |         bytes32 m4;
  5258 |     |         bytes32 m5;
  5259 |     |         bytes32 m6;
  5260 |     |         /// @solidity memory-safe-assembly
  5261 |     |         assembly {
  5262 |     |             function writeString(pos, w) {
  5263 |     |                 let length := 0
  5264 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  5265 |     |                 mstore(pos, length)
  5266 |     |                 let shift := sub(256, shl(3, length))
  5267 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  5268 |     |             }
  5269 |     |             m0 := mload(0x00)
  5270 |     |             m1 := mload(0x20)
  5271 |     |             m2 := mload(0x40)
  5272 |     |             m3 := mload(0x60)
  5273 |     |             m4 := mload(0x80)
  5274 |     |             m5 := mload(0xa0)
  5275 |     |             m6 := mload(0xc0)
  5276 |     |             // Selector of `log(address,string,uint256,uint256)`.
  5277 |     |             mstore(0x00, 0x1dc8e1b8)
  5278 |     |             mstore(0x20, p0)
  5279 |     |             mstore(0x40, 0x80)
  5280 |     |             mstore(0x60, p2)
  5281 |     |             mstore(0x80, p3)
  5282 |     |             writeString(0xa0, p1)
  5283 |     |         }
  5284 |     |         _sendLogPayload(0x1c, 0xc4);
  5285 |     |         /// @solidity memory-safe-assembly
  5286 |     |         assembly {
  5287 |     |             mstore(0x00, m0)
  5288 |     |             mstore(0x20, m1)
  5289 |     |             mstore(0x40, m2)
  5290 |     |             mstore(0x60, m3)
  5291 |     |             mstore(0x80, m4)
  5292 |     |             mstore(0xa0, m5)
  5293 |     |             mstore(0xc0, m6)
  5294 |     |         }
  5295 |     |     }
  5296 |     | 
  5297 |     |     function log(address p0, bytes32 p1, uint256 p2, bytes32 p3) internal pure {
  5298 |     |         bytes32 m0;
  5299 |     |         bytes32 m1;
  5300 |     |         bytes32 m2;
  5301 |     |         bytes32 m3;
  5302 |     |         bytes32 m4;
  5303 |     |         bytes32 m5;
  5304 |     |         bytes32 m6;
  5305 |     |         bytes32 m7;
  5306 |     |         bytes32 m8;
  5307 |     |         /// @solidity memory-safe-assembly
  5308 |     |         assembly {
  5309 |     |             function writeString(pos, w) {
  5310 |     |                 let length := 0
  5311 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  5312 |     |                 mstore(pos, length)
  5313 |     |                 let shift := sub(256, shl(3, length))
  5314 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  5315 |     |             }
  5316 |     |             m0 := mload(0x00)
  5317 |     |             m1 := mload(0x20)
  5318 |     |             m2 := mload(0x40)
  5319 |     |             m3 := mload(0x60)
  5320 |     |             m4 := mload(0x80)
  5321 |     |             m5 := mload(0xa0)
  5322 |     |             m6 := mload(0xc0)
  5323 |     |             m7 := mload(0xe0)
  5324 |     |             m8 := mload(0x100)
  5325 |     |             // Selector of `log(address,string,uint256,string)`.
  5326 |     |             mstore(0x00, 0x448830a8)
  5327 |     |             mstore(0x20, p0)
  5328 |     |             mstore(0x40, 0x80)
  5329 |     |             mstore(0x60, p2)
  5330 |     |             mstore(0x80, 0xc0)
  5331 |     |             writeString(0xa0, p1)
  5332 |     |             writeString(0xe0, p3)
  5333 |     |         }
  5334 |     |         _sendLogPayload(0x1c, 0x104);
  5335 |     |         /// @solidity memory-safe-assembly
  5336 |     |         assembly {
  5337 |     |             mstore(0x00, m0)
  5338 |     |             mstore(0x20, m1)
  5339 |     |             mstore(0x40, m2)
  5340 |     |             mstore(0x60, m3)
  5341 |     |             mstore(0x80, m4)
  5342 |     |             mstore(0xa0, m5)
  5343 |     |             mstore(0xc0, m6)
  5344 |     |             mstore(0xe0, m7)
  5345 |     |             mstore(0x100, m8)
  5346 |     |         }
  5347 |     |     }
  5348 |     | 
  5349 |     |     function log(address p0, bytes32 p1, bytes32 p2, address p3) internal pure {
  5350 |     |         bytes32 m0;
  5351 |     |         bytes32 m1;
  5352 |     |         bytes32 m2;
  5353 |     |         bytes32 m3;
  5354 |     |         bytes32 m4;
  5355 |     |         bytes32 m5;
  5356 |     |         bytes32 m6;
  5357 |     |         bytes32 m7;
  5358 |     |         bytes32 m8;
  5359 |     |         /// @solidity memory-safe-assembly
  5360 |     |         assembly {
  5361 |     |             function writeString(pos, w) {
  5362 |     |                 let length := 0
  5363 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  5364 |     |                 mstore(pos, length)
  5365 |     |                 let shift := sub(256, shl(3, length))
  5366 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  5367 |     |             }
  5368 |     |             m0 := mload(0x00)
  5369 |     |             m1 := mload(0x20)
  5370 |     |             m2 := mload(0x40)
  5371 |     |             m3 := mload(0x60)
  5372 |     |             m4 := mload(0x80)
  5373 |     |             m5 := mload(0xa0)
  5374 |     |             m6 := mload(0xc0)
  5375 |     |             m7 := mload(0xe0)
  5376 |     |             m8 := mload(0x100)
  5377 |     |             // Selector of `log(address,string,string,address)`.
  5378 |     |             mstore(0x00, 0xa04e2f87)
  5379 |     |             mstore(0x20, p0)
  5380 |     |             mstore(0x40, 0x80)
  5381 |     |             mstore(0x60, 0xc0)
  5382 |     |             mstore(0x80, p3)
  5383 |     |             writeString(0xa0, p1)
  5384 |     |             writeString(0xe0, p2)
  5385 |     |         }
  5386 |     |         _sendLogPayload(0x1c, 0x104);
  5387 |     |         /// @solidity memory-safe-assembly
  5388 |     |         assembly {
  5389 |     |             mstore(0x00, m0)
  5390 |     |             mstore(0x20, m1)
  5391 |     |             mstore(0x40, m2)
  5392 |     |             mstore(0x60, m3)
  5393 |     |             mstore(0x80, m4)
  5394 |     |             mstore(0xa0, m5)
  5395 |     |             mstore(0xc0, m6)
  5396 |     |             mstore(0xe0, m7)
  5397 |     |             mstore(0x100, m8)
  5398 |     |         }
  5399 |     |     }
  5400 |     | 
  5401 |     |     function log(address p0, bytes32 p1, bytes32 p2, bool p3) internal pure {
  5402 |     |         bytes32 m0;
  5403 |     |         bytes32 m1;
  5404 |     |         bytes32 m2;
  5405 |     |         bytes32 m3;
  5406 |     |         bytes32 m4;
  5407 |     |         bytes32 m5;
  5408 |     |         bytes32 m6;
  5409 |     |         bytes32 m7;
  5410 |     |         bytes32 m8;
  5411 |     |         /// @solidity memory-safe-assembly
  5412 |     |         assembly {
  5413 |     |             function writeString(pos, w) {
  5414 |     |                 let length := 0
  5415 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  5416 |     |                 mstore(pos, length)
  5417 |     |                 let shift := sub(256, shl(3, length))
  5418 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  5419 |     |             }
  5420 |     |             m0 := mload(0x00)
  5421 |     |             m1 := mload(0x20)
  5422 |     |             m2 := mload(0x40)
  5423 |     |             m3 := mload(0x60)
  5424 |     |             m4 := mload(0x80)
  5425 |     |             m5 := mload(0xa0)
  5426 |     |             m6 := mload(0xc0)
  5427 |     |             m7 := mload(0xe0)
  5428 |     |             m8 := mload(0x100)
  5429 |     |             // Selector of `log(address,string,string,bool)`.
  5430 |     |             mstore(0x00, 0x35a5071f)
  5431 |     |             mstore(0x20, p0)
  5432 |     |             mstore(0x40, 0x80)
  5433 |     |             mstore(0x60, 0xc0)
  5434 |     |             mstore(0x80, p3)
  5435 |     |             writeString(0xa0, p1)
  5436 |     |             writeString(0xe0, p2)
  5437 |     |         }
  5438 |     |         _sendLogPayload(0x1c, 0x104);
  5439 |     |         /// @solidity memory-safe-assembly
  5440 |     |         assembly {
  5441 |     |             mstore(0x00, m0)
  5442 |     |             mstore(0x20, m1)
  5443 |     |             mstore(0x40, m2)
  5444 |     |             mstore(0x60, m3)
  5445 |     |             mstore(0x80, m4)
  5446 |     |             mstore(0xa0, m5)
  5447 |     |             mstore(0xc0, m6)
  5448 |     |             mstore(0xe0, m7)
  5449 |     |             mstore(0x100, m8)
  5450 |     |         }
  5451 |     |     }
  5452 |     | 
  5453 |     |     function log(address p0, bytes32 p1, bytes32 p2, uint256 p3) internal pure {
  5454 |     |         bytes32 m0;
  5455 |     |         bytes32 m1;
  5456 |     |         bytes32 m2;
  5457 |     |         bytes32 m3;
  5458 |     |         bytes32 m4;
  5459 |     |         bytes32 m5;
  5460 |     |         bytes32 m6;
  5461 |     |         bytes32 m7;
  5462 |     |         bytes32 m8;
  5463 |     |         /// @solidity memory-safe-assembly
  5464 |     |         assembly {
  5465 |     |             function writeString(pos, w) {
  5466 |     |                 let length := 0
  5467 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  5468 |     |                 mstore(pos, length)
  5469 |     |                 let shift := sub(256, shl(3, length))
  5470 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  5471 |     |             }
  5472 |     |             m0 := mload(0x00)
  5473 |     |             m1 := mload(0x20)
  5474 |     |             m2 := mload(0x40)
  5475 |     |             m3 := mload(0x60)
  5476 |     |             m4 := mload(0x80)
  5477 |     |             m5 := mload(0xa0)
  5478 |     |             m6 := mload(0xc0)
  5479 |     |             m7 := mload(0xe0)
  5480 |     |             m8 := mload(0x100)
  5481 |     |             // Selector of `log(address,string,string,uint256)`.
  5482 |     |             mstore(0x00, 0x159f8927)
  5483 |     |             mstore(0x20, p0)
  5484 |     |             mstore(0x40, 0x80)
  5485 |     |             mstore(0x60, 0xc0)
  5486 |     |             mstore(0x80, p3)
  5487 |     |             writeString(0xa0, p1)
  5488 |     |             writeString(0xe0, p2)
  5489 |     |         }
  5490 |     |         _sendLogPayload(0x1c, 0x104);
  5491 |     |         /// @solidity memory-safe-assembly
  5492 |     |         assembly {
  5493 |     |             mstore(0x00, m0)
  5494 |     |             mstore(0x20, m1)
  5495 |     |             mstore(0x40, m2)
  5496 |     |             mstore(0x60, m3)
  5497 |     |             mstore(0x80, m4)
  5498 |     |             mstore(0xa0, m5)
  5499 |     |             mstore(0xc0, m6)
  5500 |     |             mstore(0xe0, m7)
  5501 |     |             mstore(0x100, m8)
  5502 |     |         }
  5503 |     |     }
  5504 |     | 
  5505 |     |     function log(address p0, bytes32 p1, bytes32 p2, bytes32 p3) internal pure {
  5506 |     |         bytes32 m0;
  5507 |     |         bytes32 m1;
  5508 |     |         bytes32 m2;
  5509 |     |         bytes32 m3;
  5510 |     |         bytes32 m4;
  5511 |     |         bytes32 m5;
  5512 |     |         bytes32 m6;
  5513 |     |         bytes32 m7;
  5514 |     |         bytes32 m8;
  5515 |     |         bytes32 m9;
  5516 |     |         bytes32 m10;
  5517 |     |         /// @solidity memory-safe-assembly
  5518 |     |         assembly {
  5519 |     |             function writeString(pos, w) {
  5520 |     |                 let length := 0
  5521 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  5522 |     |                 mstore(pos, length)
  5523 |     |                 let shift := sub(256, shl(3, length))
  5524 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  5525 |     |             }
  5526 |     |             m0 := mload(0x00)
  5527 |     |             m1 := mload(0x20)
  5528 |     |             m2 := mload(0x40)
  5529 |     |             m3 := mload(0x60)
  5530 |     |             m4 := mload(0x80)
  5531 |     |             m5 := mload(0xa0)
  5532 |     |             m6 := mload(0xc0)
  5533 |     |             m7 := mload(0xe0)
  5534 |     |             m8 := mload(0x100)
  5535 |     |             m9 := mload(0x120)
  5536 |     |             m10 := mload(0x140)
  5537 |     |             // Selector of `log(address,string,string,string)`.
  5538 |     |             mstore(0x00, 0x5d02c50b)
  5539 |     |             mstore(0x20, p0)
  5540 |     |             mstore(0x40, 0x80)
  5541 |     |             mstore(0x60, 0xc0)
  5542 |     |             mstore(0x80, 0x100)
  5543 |     |             writeString(0xa0, p1)
  5544 |     |             writeString(0xe0, p2)
  5545 |     |             writeString(0x120, p3)
  5546 |     |         }
  5547 |     |         _sendLogPayload(0x1c, 0x144);
  5548 |     |         /// @solidity memory-safe-assembly
  5549 |     |         assembly {
  5550 |     |             mstore(0x00, m0)
  5551 |     |             mstore(0x20, m1)
  5552 |     |             mstore(0x40, m2)
  5553 |     |             mstore(0x60, m3)
  5554 |     |             mstore(0x80, m4)
  5555 |     |             mstore(0xa0, m5)
  5556 |     |             mstore(0xc0, m6)
  5557 |     |             mstore(0xe0, m7)
  5558 |     |             mstore(0x100, m8)
  5559 |     |             mstore(0x120, m9)
  5560 |     |             mstore(0x140, m10)
  5561 |     |         }
  5562 |     |     }
  5563 |     | 
  5564 |     |     function log(bool p0, address p1, address p2, address p3) internal pure {
  5565 |     |         bytes32 m0;
  5566 |     |         bytes32 m1;
  5567 |     |         bytes32 m2;
  5568 |     |         bytes32 m3;
  5569 |     |         bytes32 m4;
  5570 |     |         /// @solidity memory-safe-assembly
  5571 |     |         assembly {
  5572 |     |             m0 := mload(0x00)
  5573 |     |             m1 := mload(0x20)
  5574 |     |             m2 := mload(0x40)
  5575 |     |             m3 := mload(0x60)
  5576 |     |             m4 := mload(0x80)
  5577 |     |             // Selector of `log(bool,address,address,address)`.
  5578 |     |             mstore(0x00, 0x1d14d001)
  5579 |     |             mstore(0x20, p0)
  5580 |     |             mstore(0x40, p1)
  5581 |     |             mstore(0x60, p2)
  5582 |     |             mstore(0x80, p3)
  5583 |     |         }
  5584 |     |         _sendLogPayload(0x1c, 0x84);
  5585 |     |         /// @solidity memory-safe-assembly
  5586 |     |         assembly {
  5587 |     |             mstore(0x00, m0)
  5588 |     |             mstore(0x20, m1)
  5589 |     |             mstore(0x40, m2)
  5590 |     |             mstore(0x60, m3)
  5591 |     |             mstore(0x80, m4)
  5592 |     |         }
  5593 |     |     }
  5594 |     | 
  5595 |     |     function log(bool p0, address p1, address p2, bool p3) internal pure {
  5596 |     |         bytes32 m0;
  5597 |     |         bytes32 m1;
  5598 |     |         bytes32 m2;
  5599 |     |         bytes32 m3;
  5600 |     |         bytes32 m4;
  5601 |     |         /// @solidity memory-safe-assembly
  5602 |     |         assembly {
  5603 |     |             m0 := mload(0x00)
  5604 |     |             m1 := mload(0x20)
  5605 |     |             m2 := mload(0x40)
  5606 |     |             m3 := mload(0x60)
  5607 |     |             m4 := mload(0x80)
  5608 |     |             // Selector of `log(bool,address,address,bool)`.
  5609 |     |             mstore(0x00, 0x46600be0)
  5610 |     |             mstore(0x20, p0)
  5611 |     |             mstore(0x40, p1)
  5612 |     |             mstore(0x60, p2)
  5613 |     |             mstore(0x80, p3)
  5614 |     |         }
  5615 |     |         _sendLogPayload(0x1c, 0x84);
  5616 |     |         /// @solidity memory-safe-assembly
  5617 |     |         assembly {
  5618 |     |             mstore(0x00, m0)
  5619 |     |             mstore(0x20, m1)
  5620 |     |             mstore(0x40, m2)
  5621 |     |             mstore(0x60, m3)
  5622 |     |             mstore(0x80, m4)
  5623 |     |         }
  5624 |     |     }
  5625 |     | 
  5626 |     |     function log(bool p0, address p1, address p2, uint256 p3) internal pure {
  5627 |     |         bytes32 m0;
  5628 |     |         bytes32 m1;
  5629 |     |         bytes32 m2;
  5630 |     |         bytes32 m3;
  5631 |     |         bytes32 m4;
  5632 |     |         /// @solidity memory-safe-assembly
  5633 |     |         assembly {
  5634 |     |             m0 := mload(0x00)
  5635 |     |             m1 := mload(0x20)
  5636 |     |             m2 := mload(0x40)
  5637 |     |             m3 := mload(0x60)
  5638 |     |             m4 := mload(0x80)
  5639 |     |             // Selector of `log(bool,address,address,uint256)`.
  5640 |     |             mstore(0x00, 0x0c66d1be)
  5641 |     |             mstore(0x20, p0)
  5642 |     |             mstore(0x40, p1)
  5643 |     |             mstore(0x60, p2)
  5644 |     |             mstore(0x80, p3)
  5645 |     |         }
  5646 |     |         _sendLogPayload(0x1c, 0x84);
  5647 |     |         /// @solidity memory-safe-assembly
  5648 |     |         assembly {
  5649 |     |             mstore(0x00, m0)
  5650 |     |             mstore(0x20, m1)
  5651 |     |             mstore(0x40, m2)
  5652 |     |             mstore(0x60, m3)
  5653 |     |             mstore(0x80, m4)
  5654 |     |         }
  5655 |     |     }
  5656 |     | 
  5657 |     |     function log(bool p0, address p1, address p2, bytes32 p3) internal pure {
  5658 |     |         bytes32 m0;
  5659 |     |         bytes32 m1;
  5660 |     |         bytes32 m2;
  5661 |     |         bytes32 m3;
  5662 |     |         bytes32 m4;
  5663 |     |         bytes32 m5;
  5664 |     |         bytes32 m6;
  5665 |     |         /// @solidity memory-safe-assembly
  5666 |     |         assembly {
  5667 |     |             function writeString(pos, w) {
  5668 |     |                 let length := 0
  5669 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  5670 |     |                 mstore(pos, length)
  5671 |     |                 let shift := sub(256, shl(3, length))
  5672 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  5673 |     |             }
  5674 |     |             m0 := mload(0x00)
  5675 |     |             m1 := mload(0x20)
  5676 |     |             m2 := mload(0x40)
  5677 |     |             m3 := mload(0x60)
  5678 |     |             m4 := mload(0x80)
  5679 |     |             m5 := mload(0xa0)
  5680 |     |             m6 := mload(0xc0)
  5681 |     |             // Selector of `log(bool,address,address,string)`.
  5682 |     |             mstore(0x00, 0xd812a167)
  5683 |     |             mstore(0x20, p0)
  5684 |     |             mstore(0x40, p1)
  5685 |     |             mstore(0x60, p2)
  5686 |     |             mstore(0x80, 0x80)
  5687 |     |             writeString(0xa0, p3)
  5688 |     |         }
  5689 |     |         _sendLogPayload(0x1c, 0xc4);
  5690 |     |         /// @solidity memory-safe-assembly
  5691 |     |         assembly {
  5692 |     |             mstore(0x00, m0)
  5693 |     |             mstore(0x20, m1)
  5694 |     |             mstore(0x40, m2)
  5695 |     |             mstore(0x60, m3)
  5696 |     |             mstore(0x80, m4)
  5697 |     |             mstore(0xa0, m5)
  5698 |     |             mstore(0xc0, m6)
  5699 |     |         }
  5700 |     |     }
  5701 |     | 
  5702 |     |     function log(bool p0, address p1, bool p2, address p3) internal pure {
  5703 |     |         bytes32 m0;
  5704 |     |         bytes32 m1;
  5705 |     |         bytes32 m2;
  5706 |     |         bytes32 m3;
  5707 |     |         bytes32 m4;
  5708 |     |         /// @solidity memory-safe-assembly
  5709 |     |         assembly {
  5710 |     |             m0 := mload(0x00)
  5711 |     |             m1 := mload(0x20)
  5712 |     |             m2 := mload(0x40)
  5713 |     |             m3 := mload(0x60)
  5714 |     |             m4 := mload(0x80)
  5715 |     |             // Selector of `log(bool,address,bool,address)`.
  5716 |     |             mstore(0x00, 0x1c41a336)
  5717 |     |             mstore(0x20, p0)
  5718 |     |             mstore(0x40, p1)
  5719 |     |             mstore(0x60, p2)
  5720 |     |             mstore(0x80, p3)
  5721 |     |         }
  5722 |     |         _sendLogPayload(0x1c, 0x84);
  5723 |     |         /// @solidity memory-safe-assembly
  5724 |     |         assembly {
  5725 |     |             mstore(0x00, m0)
  5726 |     |             mstore(0x20, m1)
  5727 |     |             mstore(0x40, m2)
  5728 |     |             mstore(0x60, m3)
  5729 |     |             mstore(0x80, m4)
  5730 |     |         }
  5731 |     |     }
  5732 |     | 
  5733 |     |     function log(bool p0, address p1, bool p2, bool p3) internal pure {
  5734 |     |         bytes32 m0;
  5735 |     |         bytes32 m1;
  5736 |     |         bytes32 m2;
  5737 |     |         bytes32 m3;
  5738 |     |         bytes32 m4;
  5739 |     |         /// @solidity memory-safe-assembly
  5740 |     |         assembly {
  5741 |     |             m0 := mload(0x00)
  5742 |     |             m1 := mload(0x20)
  5743 |     |             m2 := mload(0x40)
  5744 |     |             m3 := mload(0x60)
  5745 |     |             m4 := mload(0x80)
  5746 |     |             // Selector of `log(bool,address,bool,bool)`.
  5747 |     |             mstore(0x00, 0x6a9c478b)
  5748 |     |             mstore(0x20, p0)
  5749 |     |             mstore(0x40, p1)
  5750 |     |             mstore(0x60, p2)
  5751 |     |             mstore(0x80, p3)
  5752 |     |         }
  5753 |     |         _sendLogPayload(0x1c, 0x84);
  5754 |     |         /// @solidity memory-safe-assembly
  5755 |     |         assembly {
  5756 |     |             mstore(0x00, m0)
  5757 |     |             mstore(0x20, m1)
  5758 |     |             mstore(0x40, m2)
  5759 |     |             mstore(0x60, m3)
  5760 |     |             mstore(0x80, m4)
  5761 |     |         }
  5762 |     |     }
  5763 |     | 
  5764 |     |     function log(bool p0, address p1, bool p2, uint256 p3) internal pure {
  5765 |     |         bytes32 m0;
  5766 |     |         bytes32 m1;
  5767 |     |         bytes32 m2;
  5768 |     |         bytes32 m3;
  5769 |     |         bytes32 m4;
  5770 |     |         /// @solidity memory-safe-assembly
  5771 |     |         assembly {
  5772 |     |             m0 := mload(0x00)
  5773 |     |             m1 := mload(0x20)
  5774 |     |             m2 := mload(0x40)
  5775 |     |             m3 := mload(0x60)
  5776 |     |             m4 := mload(0x80)
  5777 |     |             // Selector of `log(bool,address,bool,uint256)`.
  5778 |     |             mstore(0x00, 0x07831502)
  5779 |     |             mstore(0x20, p0)
  5780 |     |             mstore(0x40, p1)
  5781 |     |             mstore(0x60, p2)
  5782 |     |             mstore(0x80, p3)
  5783 |     |         }
  5784 |     |         _sendLogPayload(0x1c, 0x84);
  5785 |     |         /// @solidity memory-safe-assembly
  5786 |     |         assembly {
  5787 |     |             mstore(0x00, m0)
  5788 |     |             mstore(0x20, m1)
  5789 |     |             mstore(0x40, m2)
  5790 |     |             mstore(0x60, m3)
  5791 |     |             mstore(0x80, m4)
  5792 |     |         }
  5793 |     |     }
  5794 |     | 
  5795 |     |     function log(bool p0, address p1, bool p2, bytes32 p3) internal pure {
  5796 |     |         bytes32 m0;
  5797 |     |         bytes32 m1;
  5798 |     |         bytes32 m2;
  5799 |     |         bytes32 m3;
  5800 |     |         bytes32 m4;
  5801 |     |         bytes32 m5;
  5802 |     |         bytes32 m6;
  5803 |     |         /// @solidity memory-safe-assembly
  5804 |     |         assembly {
  5805 |     |             function writeString(pos, w) {
  5806 |     |                 let length := 0
  5807 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  5808 |     |                 mstore(pos, length)
  5809 |     |                 let shift := sub(256, shl(3, length))
  5810 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  5811 |     |             }
  5812 |     |             m0 := mload(0x00)
  5813 |     |             m1 := mload(0x20)
  5814 |     |             m2 := mload(0x40)
  5815 |     |             m3 := mload(0x60)
  5816 |     |             m4 := mload(0x80)
  5817 |     |             m5 := mload(0xa0)
  5818 |     |             m6 := mload(0xc0)
  5819 |     |             // Selector of `log(bool,address,bool,string)`.
  5820 |     |             mstore(0x00, 0x4a66cb34)
  5821 |     |             mstore(0x20, p0)
  5822 |     |             mstore(0x40, p1)
  5823 |     |             mstore(0x60, p2)
  5824 |     |             mstore(0x80, 0x80)
  5825 |     |             writeString(0xa0, p3)
  5826 |     |         }
  5827 |     |         _sendLogPayload(0x1c, 0xc4);
  5828 |     |         /// @solidity memory-safe-assembly
  5829 |     |         assembly {
  5830 |     |             mstore(0x00, m0)
  5831 |     |             mstore(0x20, m1)
  5832 |     |             mstore(0x40, m2)
  5833 |     |             mstore(0x60, m3)
  5834 |     |             mstore(0x80, m4)
  5835 |     |             mstore(0xa0, m5)
  5836 |     |             mstore(0xc0, m6)
  5837 |     |         }
  5838 |     |     }
  5839 |     | 
  5840 |     |     function log(bool p0, address p1, uint256 p2, address p3) internal pure {
  5841 |     |         bytes32 m0;
  5842 |     |         bytes32 m1;
  5843 |     |         bytes32 m2;
  5844 |     |         bytes32 m3;
  5845 |     |         bytes32 m4;
  5846 |     |         /// @solidity memory-safe-assembly
  5847 |     |         assembly {
  5848 |     |             m0 := mload(0x00)
  5849 |     |             m1 := mload(0x20)
  5850 |     |             m2 := mload(0x40)
  5851 |     |             m3 := mload(0x60)
  5852 |     |             m4 := mload(0x80)
  5853 |     |             // Selector of `log(bool,address,uint256,address)`.
  5854 |     |             mstore(0x00, 0x136b05dd)
  5855 |     |             mstore(0x20, p0)
  5856 |     |             mstore(0x40, p1)
  5857 |     |             mstore(0x60, p2)
  5858 |     |             mstore(0x80, p3)
  5859 |     |         }
  5860 |     |         _sendLogPayload(0x1c, 0x84);
  5861 |     |         /// @solidity memory-safe-assembly
  5862 |     |         assembly {
  5863 |     |             mstore(0x00, m0)
  5864 |     |             mstore(0x20, m1)
  5865 |     |             mstore(0x40, m2)
  5866 |     |             mstore(0x60, m3)
  5867 |     |             mstore(0x80, m4)
  5868 |     |         }
  5869 |     |     }
  5870 |     | 
  5871 |     |     function log(bool p0, address p1, uint256 p2, bool p3) internal pure {
  5872 |     |         bytes32 m0;
  5873 |     |         bytes32 m1;
  5874 |     |         bytes32 m2;
  5875 |     |         bytes32 m3;
  5876 |     |         bytes32 m4;
  5877 |     |         /// @solidity memory-safe-assembly
  5878 |     |         assembly {
  5879 |     |             m0 := mload(0x00)
  5880 |     |             m1 := mload(0x20)
  5881 |     |             m2 := mload(0x40)
  5882 |     |             m3 := mload(0x60)
  5883 |     |             m4 := mload(0x80)
  5884 |     |             // Selector of `log(bool,address,uint256,bool)`.
  5885 |     |             mstore(0x00, 0xd6019f1c)
  5886 |     |             mstore(0x20, p0)
  5887 |     |             mstore(0x40, p1)
  5888 |     |             mstore(0x60, p2)
  5889 |     |             mstore(0x80, p3)
  5890 |     |         }
  5891 |     |         _sendLogPayload(0x1c, 0x84);
  5892 |     |         /// @solidity memory-safe-assembly
  5893 |     |         assembly {
  5894 |     |             mstore(0x00, m0)
  5895 |     |             mstore(0x20, m1)
  5896 |     |             mstore(0x40, m2)
  5897 |     |             mstore(0x60, m3)
  5898 |     |             mstore(0x80, m4)
  5899 |     |         }
  5900 |     |     }
  5901 |     | 
  5902 |     |     function log(bool p0, address p1, uint256 p2, uint256 p3) internal pure {
  5903 |     |         bytes32 m0;
  5904 |     |         bytes32 m1;
  5905 |     |         bytes32 m2;
  5906 |     |         bytes32 m3;
  5907 |     |         bytes32 m4;
  5908 |     |         /// @solidity memory-safe-assembly
  5909 |     |         assembly {
  5910 |     |             m0 := mload(0x00)
  5911 |     |             m1 := mload(0x20)
  5912 |     |             m2 := mload(0x40)
  5913 |     |             m3 := mload(0x60)
  5914 |     |             m4 := mload(0x80)
  5915 |     |             // Selector of `log(bool,address,uint256,uint256)`.
  5916 |     |             mstore(0x00, 0x7bf181a1)
  5917 |     |             mstore(0x20, p0)
  5918 |     |             mstore(0x40, p1)
  5919 |     |             mstore(0x60, p2)
  5920 |     |             mstore(0x80, p3)
  5921 |     |         }
  5922 |     |         _sendLogPayload(0x1c, 0x84);
  5923 |     |         /// @solidity memory-safe-assembly
  5924 |     |         assembly {
  5925 |     |             mstore(0x00, m0)
  5926 |     |             mstore(0x20, m1)
  5927 |     |             mstore(0x40, m2)
  5928 |     |             mstore(0x60, m3)
  5929 |     |             mstore(0x80, m4)
  5930 |     |         }
  5931 |     |     }
  5932 |     | 
  5933 |     |     function log(bool p0, address p1, uint256 p2, bytes32 p3) internal pure {
  5934 |     |         bytes32 m0;
  5935 |     |         bytes32 m1;
  5936 |     |         bytes32 m2;
  5937 |     |         bytes32 m3;
  5938 |     |         bytes32 m4;
  5939 |     |         bytes32 m5;
  5940 |     |         bytes32 m6;
  5941 |     |         /// @solidity memory-safe-assembly
  5942 |     |         assembly {
  5943 |     |             function writeString(pos, w) {
  5944 |     |                 let length := 0
  5945 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  5946 |     |                 mstore(pos, length)
  5947 |     |                 let shift := sub(256, shl(3, length))
  5948 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  5949 |     |             }
  5950 |     |             m0 := mload(0x00)
  5951 |     |             m1 := mload(0x20)
  5952 |     |             m2 := mload(0x40)
  5953 |     |             m3 := mload(0x60)
  5954 |     |             m4 := mload(0x80)
  5955 |     |             m5 := mload(0xa0)
  5956 |     |             m6 := mload(0xc0)
  5957 |     |             // Selector of `log(bool,address,uint256,string)`.
  5958 |     |             mstore(0x00, 0x51f09ff8)
  5959 |     |             mstore(0x20, p0)
  5960 |     |             mstore(0x40, p1)
  5961 |     |             mstore(0x60, p2)
  5962 |     |             mstore(0x80, 0x80)
  5963 |     |             writeString(0xa0, p3)
  5964 |     |         }
  5965 |     |         _sendLogPayload(0x1c, 0xc4);
  5966 |     |         /// @solidity memory-safe-assembly
  5967 |     |         assembly {
  5968 |     |             mstore(0x00, m0)
  5969 |     |             mstore(0x20, m1)
  5970 |     |             mstore(0x40, m2)
  5971 |     |             mstore(0x60, m3)
  5972 |     |             mstore(0x80, m4)
  5973 |     |             mstore(0xa0, m5)
  5974 |     |             mstore(0xc0, m6)
  5975 |     |         }
  5976 |     |     }
  5977 |     | 
  5978 |     |     function log(bool p0, address p1, bytes32 p2, address p3) internal pure {
  5979 |     |         bytes32 m0;
  5980 |     |         bytes32 m1;
  5981 |     |         bytes32 m2;
  5982 |     |         bytes32 m3;
  5983 |     |         bytes32 m4;
  5984 |     |         bytes32 m5;
  5985 |     |         bytes32 m6;
  5986 |     |         /// @solidity memory-safe-assembly
  5987 |     |         assembly {
  5988 |     |             function writeString(pos, w) {
  5989 |     |                 let length := 0
  5990 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  5991 |     |                 mstore(pos, length)
  5992 |     |                 let shift := sub(256, shl(3, length))
  5993 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  5994 |     |             }
  5995 |     |             m0 := mload(0x00)
  5996 |     |             m1 := mload(0x20)
  5997 |     |             m2 := mload(0x40)
  5998 |     |             m3 := mload(0x60)
  5999 |     |             m4 := mload(0x80)
  6000 |     |             m5 := mload(0xa0)
  6001 |     |             m6 := mload(0xc0)
  6002 |     |             // Selector of `log(bool,address,string,address)`.
  6003 |     |             mstore(0x00, 0x6f7c603e)
  6004 |     |             mstore(0x20, p0)
  6005 |     |             mstore(0x40, p1)
  6006 |     |             mstore(0x60, 0x80)
  6007 |     |             mstore(0x80, p3)
  6008 |     |             writeString(0xa0, p2)
  6009 |     |         }
  6010 |     |         _sendLogPayload(0x1c, 0xc4);
  6011 |     |         /// @solidity memory-safe-assembly
  6012 |     |         assembly {
  6013 |     |             mstore(0x00, m0)
  6014 |     |             mstore(0x20, m1)
  6015 |     |             mstore(0x40, m2)
  6016 |     |             mstore(0x60, m3)
  6017 |     |             mstore(0x80, m4)
  6018 |     |             mstore(0xa0, m5)
  6019 |     |             mstore(0xc0, m6)
  6020 |     |         }
  6021 |     |     }
  6022 |     | 
  6023 |     |     function log(bool p0, address p1, bytes32 p2, bool p3) internal pure {
  6024 |     |         bytes32 m0;
  6025 |     |         bytes32 m1;
  6026 |     |         bytes32 m2;
  6027 |     |         bytes32 m3;
  6028 |     |         bytes32 m4;
  6029 |     |         bytes32 m5;
  6030 |     |         bytes32 m6;
  6031 |     |         /// @solidity memory-safe-assembly
  6032 |     |         assembly {
  6033 |     |             function writeString(pos, w) {
  6034 |     |                 let length := 0
  6035 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  6036 |     |                 mstore(pos, length)
  6037 |     |                 let shift := sub(256, shl(3, length))
  6038 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  6039 |     |             }
  6040 |     |             m0 := mload(0x00)
  6041 |     |             m1 := mload(0x20)
  6042 |     |             m2 := mload(0x40)
  6043 |     |             m3 := mload(0x60)
  6044 |     |             m4 := mload(0x80)
  6045 |     |             m5 := mload(0xa0)
  6046 |     |             m6 := mload(0xc0)
  6047 |     |             // Selector of `log(bool,address,string,bool)`.
  6048 |     |             mstore(0x00, 0xe2bfd60b)
  6049 |     |             mstore(0x20, p0)
  6050 |     |             mstore(0x40, p1)
  6051 |     |             mstore(0x60, 0x80)
  6052 |     |             mstore(0x80, p3)
  6053 |     |             writeString(0xa0, p2)
  6054 |     |         }
  6055 |     |         _sendLogPayload(0x1c, 0xc4);
  6056 |     |         /// @solidity memory-safe-assembly
  6057 |     |         assembly {
  6058 |     |             mstore(0x00, m0)
  6059 |     |             mstore(0x20, m1)
  6060 |     |             mstore(0x40, m2)
  6061 |     |             mstore(0x60, m3)
  6062 |     |             mstore(0x80, m4)
  6063 |     |             mstore(0xa0, m5)
  6064 |     |             mstore(0xc0, m6)
  6065 |     |         }
  6066 |     |     }
  6067 |     | 
  6068 |     |     function log(bool p0, address p1, bytes32 p2, uint256 p3) internal pure {
  6069 |     |         bytes32 m0;
  6070 |     |         bytes32 m1;
  6071 |     |         bytes32 m2;
  6072 |     |         bytes32 m3;
  6073 |     |         bytes32 m4;
  6074 |     |         bytes32 m5;
  6075 |     |         bytes32 m6;
  6076 |     |         /// @solidity memory-safe-assembly
  6077 |     |         assembly {
  6078 |     |             function writeString(pos, w) {
  6079 |     |                 let length := 0
  6080 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  6081 |     |                 mstore(pos, length)
  6082 |     |                 let shift := sub(256, shl(3, length))
  6083 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  6084 |     |             }
  6085 |     |             m0 := mload(0x00)
  6086 |     |             m1 := mload(0x20)
  6087 |     |             m2 := mload(0x40)
  6088 |     |             m3 := mload(0x60)
  6089 |     |             m4 := mload(0x80)
  6090 |     |             m5 := mload(0xa0)
  6091 |     |             m6 := mload(0xc0)
  6092 |     |             // Selector of `log(bool,address,string,uint256)`.
  6093 |     |             mstore(0x00, 0xc21f64c7)
  6094 |     |             mstore(0x20, p0)
  6095 |     |             mstore(0x40, p1)
  6096 |     |             mstore(0x60, 0x80)
  6097 |     |             mstore(0x80, p3)
  6098 |     |             writeString(0xa0, p2)
  6099 |     |         }
  6100 |     |         _sendLogPayload(0x1c, 0xc4);
  6101 |     |         /// @solidity memory-safe-assembly
  6102 |     |         assembly {
  6103 |     |             mstore(0x00, m0)
  6104 |     |             mstore(0x20, m1)
  6105 |     |             mstore(0x40, m2)
  6106 |     |             mstore(0x60, m3)
  6107 |     |             mstore(0x80, m4)
  6108 |     |             mstore(0xa0, m5)
  6109 |     |             mstore(0xc0, m6)
  6110 |     |         }
  6111 |     |     }
  6112 |     | 
  6113 |     |     function log(bool p0, address p1, bytes32 p2, bytes32 p3) internal pure {
  6114 |     |         bytes32 m0;
  6115 |     |         bytes32 m1;
  6116 |     |         bytes32 m2;
  6117 |     |         bytes32 m3;
  6118 |     |         bytes32 m4;
  6119 |     |         bytes32 m5;
  6120 |     |         bytes32 m6;
  6121 |     |         bytes32 m7;
  6122 |     |         bytes32 m8;
  6123 |     |         /// @solidity memory-safe-assembly
  6124 |     |         assembly {
  6125 |     |             function writeString(pos, w) {
  6126 |     |                 let length := 0
  6127 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  6128 |     |                 mstore(pos, length)
  6129 |     |                 let shift := sub(256, shl(3, length))
  6130 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  6131 |     |             }
  6132 |     |             m0 := mload(0x00)
  6133 |     |             m1 := mload(0x20)
  6134 |     |             m2 := mload(0x40)
  6135 |     |             m3 := mload(0x60)
  6136 |     |             m4 := mload(0x80)
  6137 |     |             m5 := mload(0xa0)
  6138 |     |             m6 := mload(0xc0)
  6139 |     |             m7 := mload(0xe0)
  6140 |     |             m8 := mload(0x100)
  6141 |     |             // Selector of `log(bool,address,string,string)`.
  6142 |     |             mstore(0x00, 0xa73c1db6)
  6143 |     |             mstore(0x20, p0)
  6144 |     |             mstore(0x40, p1)
  6145 |     |             mstore(0x60, 0x80)
  6146 |     |             mstore(0x80, 0xc0)
  6147 |     |             writeString(0xa0, p2)
  6148 |     |             writeString(0xe0, p3)
  6149 |     |         }
  6150 |     |         _sendLogPayload(0x1c, 0x104);
  6151 |     |         /// @solidity memory-safe-assembly
  6152 |     |         assembly {
  6153 |     |             mstore(0x00, m0)
  6154 |     |             mstore(0x20, m1)
  6155 |     |             mstore(0x40, m2)
  6156 |     |             mstore(0x60, m3)
  6157 |     |             mstore(0x80, m4)
  6158 |     |             mstore(0xa0, m5)
  6159 |     |             mstore(0xc0, m6)
  6160 |     |             mstore(0xe0, m7)
  6161 |     |             mstore(0x100, m8)
  6162 |     |         }
  6163 |     |     }
  6164 |     | 
  6165 |     |     function log(bool p0, bool p1, address p2, address p3) internal pure {
  6166 |     |         bytes32 m0;
  6167 |     |         bytes32 m1;
  6168 |     |         bytes32 m2;
  6169 |     |         bytes32 m3;
  6170 |     |         bytes32 m4;
  6171 |     |         /// @solidity memory-safe-assembly
  6172 |     |         assembly {
  6173 |     |             m0 := mload(0x00)
  6174 |     |             m1 := mload(0x20)
  6175 |     |             m2 := mload(0x40)
  6176 |     |             m3 := mload(0x60)
  6177 |     |             m4 := mload(0x80)
  6178 |     |             // Selector of `log(bool,bool,address,address)`.
  6179 |     |             mstore(0x00, 0xf4880ea4)
  6180 |     |             mstore(0x20, p0)
  6181 |     |             mstore(0x40, p1)
  6182 |     |             mstore(0x60, p2)
  6183 |     |             mstore(0x80, p3)
  6184 |     |         }
  6185 |     |         _sendLogPayload(0x1c, 0x84);
  6186 |     |         /// @solidity memory-safe-assembly
  6187 |     |         assembly {
  6188 |     |             mstore(0x00, m0)
  6189 |     |             mstore(0x20, m1)
  6190 |     |             mstore(0x40, m2)
  6191 |     |             mstore(0x60, m3)
  6192 |     |             mstore(0x80, m4)
  6193 |     |         }
  6194 |     |     }
  6195 |     | 
  6196 |     |     function log(bool p0, bool p1, address p2, bool p3) internal pure {
  6197 |     |         bytes32 m0;
  6198 |     |         bytes32 m1;
  6199 |     |         bytes32 m2;
  6200 |     |         bytes32 m3;
  6201 |     |         bytes32 m4;
  6202 |     |         /// @solidity memory-safe-assembly
  6203 |     |         assembly {
  6204 |     |             m0 := mload(0x00)
  6205 |     |             m1 := mload(0x20)
  6206 |     |             m2 := mload(0x40)
  6207 |     |             m3 := mload(0x60)
  6208 |     |             m4 := mload(0x80)
  6209 |     |             // Selector of `log(bool,bool,address,bool)`.
  6210 |     |             mstore(0x00, 0xc0a302d8)
  6211 |     |             mstore(0x20, p0)
  6212 |     |             mstore(0x40, p1)
  6213 |     |             mstore(0x60, p2)
  6214 |     |             mstore(0x80, p3)
  6215 |     |         }
  6216 |     |         _sendLogPayload(0x1c, 0x84);
  6217 |     |         /// @solidity memory-safe-assembly
  6218 |     |         assembly {
  6219 |     |             mstore(0x00, m0)
  6220 |     |             mstore(0x20, m1)
  6221 |     |             mstore(0x40, m2)
  6222 |     |             mstore(0x60, m3)
  6223 |     |             mstore(0x80, m4)
  6224 |     |         }
  6225 |     |     }
  6226 |     | 
  6227 |     |     function log(bool p0, bool p1, address p2, uint256 p3) internal pure {
  6228 |     |         bytes32 m0;
  6229 |     |         bytes32 m1;
  6230 |     |         bytes32 m2;
  6231 |     |         bytes32 m3;
  6232 |     |         bytes32 m4;
  6233 |     |         /// @solidity memory-safe-assembly
  6234 |     |         assembly {
  6235 |     |             m0 := mload(0x00)
  6236 |     |             m1 := mload(0x20)
  6237 |     |             m2 := mload(0x40)
  6238 |     |             m3 := mload(0x60)
  6239 |     |             m4 := mload(0x80)
  6240 |     |             // Selector of `log(bool,bool,address,uint256)`.
  6241 |     |             mstore(0x00, 0x4c123d57)
  6242 |     |             mstore(0x20, p0)
  6243 |     |             mstore(0x40, p1)
  6244 |     |             mstore(0x60, p2)
  6245 |     |             mstore(0x80, p3)
  6246 |     |         }
  6247 |     |         _sendLogPayload(0x1c, 0x84);
  6248 |     |         /// @solidity memory-safe-assembly
  6249 |     |         assembly {
  6250 |     |             mstore(0x00, m0)
  6251 |     |             mstore(0x20, m1)
  6252 |     |             mstore(0x40, m2)
  6253 |     |             mstore(0x60, m3)
  6254 |     |             mstore(0x80, m4)
  6255 |     |         }
  6256 |     |     }
  6257 |     | 
  6258 |     |     function log(bool p0, bool p1, address p2, bytes32 p3) internal pure {
  6259 |     |         bytes32 m0;
  6260 |     |         bytes32 m1;
  6261 |     |         bytes32 m2;
  6262 |     |         bytes32 m3;
  6263 |     |         bytes32 m4;
  6264 |     |         bytes32 m5;
  6265 |     |         bytes32 m6;
  6266 |     |         /// @solidity memory-safe-assembly
  6267 |     |         assembly {
  6268 |     |             function writeString(pos, w) {
  6269 |     |                 let length := 0
  6270 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  6271 |     |                 mstore(pos, length)
  6272 |     |                 let shift := sub(256, shl(3, length))
  6273 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  6274 |     |             }
  6275 |     |             m0 := mload(0x00)
  6276 |     |             m1 := mload(0x20)
  6277 |     |             m2 := mload(0x40)
  6278 |     |             m3 := mload(0x60)
  6279 |     |             m4 := mload(0x80)
  6280 |     |             m5 := mload(0xa0)
  6281 |     |             m6 := mload(0xc0)
  6282 |     |             // Selector of `log(bool,bool,address,string)`.
  6283 |     |             mstore(0x00, 0xa0a47963)
  6284 |     |             mstore(0x20, p0)
  6285 |     |             mstore(0x40, p1)
  6286 |     |             mstore(0x60, p2)
  6287 |     |             mstore(0x80, 0x80)
  6288 |     |             writeString(0xa0, p3)
  6289 |     |         }
  6290 |     |         _sendLogPayload(0x1c, 0xc4);
  6291 |     |         /// @solidity memory-safe-assembly
  6292 |     |         assembly {
  6293 |     |             mstore(0x00, m0)
  6294 |     |             mstore(0x20, m1)
  6295 |     |             mstore(0x40, m2)
  6296 |     |             mstore(0x60, m3)
  6297 |     |             mstore(0x80, m4)
  6298 |     |             mstore(0xa0, m5)
  6299 |     |             mstore(0xc0, m6)
  6300 |     |         }
  6301 |     |     }
  6302 |     | 
  6303 |     |     function log(bool p0, bool p1, bool p2, address p3) internal pure {
  6304 |     |         bytes32 m0;
  6305 |     |         bytes32 m1;
  6306 |     |         bytes32 m2;
  6307 |     |         bytes32 m3;
  6308 |     |         bytes32 m4;
  6309 |     |         /// @solidity memory-safe-assembly
  6310 |     |         assembly {
  6311 |     |             m0 := mload(0x00)
  6312 |     |             m1 := mload(0x20)
  6313 |     |             m2 := mload(0x40)
  6314 |     |             m3 := mload(0x60)
  6315 |     |             m4 := mload(0x80)
  6316 |     |             // Selector of `log(bool,bool,bool,address)`.
  6317 |     |             mstore(0x00, 0x8c329b1a)
  6318 |     |             mstore(0x20, p0)
  6319 |     |             mstore(0x40, p1)
  6320 |     |             mstore(0x60, p2)
  6321 |     |             mstore(0x80, p3)
  6322 |     |         }
  6323 |     |         _sendLogPayload(0x1c, 0x84);
  6324 |     |         /// @solidity memory-safe-assembly
  6325 |     |         assembly {
  6326 |     |             mstore(0x00, m0)
  6327 |     |             mstore(0x20, m1)
  6328 |     |             mstore(0x40, m2)
  6329 |     |             mstore(0x60, m3)
  6330 |     |             mstore(0x80, m4)
  6331 |     |         }
  6332 |     |     }
  6333 |     | 
  6334 |     |     function log(bool p0, bool p1, bool p2, bool p3) internal pure {
  6335 |     |         bytes32 m0;
  6336 |     |         bytes32 m1;
  6337 |     |         bytes32 m2;
  6338 |     |         bytes32 m3;
  6339 |     |         bytes32 m4;
  6340 |     |         /// @solidity memory-safe-assembly
  6341 |     |         assembly {
  6342 |     |             m0 := mload(0x00)
  6343 |     |             m1 := mload(0x20)
  6344 |     |             m2 := mload(0x40)
  6345 |     |             m3 := mload(0x60)
  6346 |     |             m4 := mload(0x80)
  6347 |     |             // Selector of `log(bool,bool,bool,bool)`.
  6348 |     |             mstore(0x00, 0x3b2a5ce0)
  6349 |     |             mstore(0x20, p0)
  6350 |     |             mstore(0x40, p1)
  6351 |     |             mstore(0x60, p2)
  6352 |     |             mstore(0x80, p3)
  6353 |     |         }
  6354 |     |         _sendLogPayload(0x1c, 0x84);
  6355 |     |         /// @solidity memory-safe-assembly
  6356 |     |         assembly {
  6357 |     |             mstore(0x00, m0)
  6358 |     |             mstore(0x20, m1)
  6359 |     |             mstore(0x40, m2)
  6360 |     |             mstore(0x60, m3)
  6361 |     |             mstore(0x80, m4)
  6362 |     |         }
  6363 |     |     }
  6364 |     | 
  6365 |     |     function log(bool p0, bool p1, bool p2, uint256 p3) internal pure {
  6366 |     |         bytes32 m0;
  6367 |     |         bytes32 m1;
  6368 |     |         bytes32 m2;
  6369 |     |         bytes32 m3;
  6370 |     |         bytes32 m4;
  6371 |     |         /// @solidity memory-safe-assembly
  6372 |     |         assembly {
  6373 |     |             m0 := mload(0x00)
  6374 |     |             m1 := mload(0x20)
  6375 |     |             m2 := mload(0x40)
  6376 |     |             m3 := mload(0x60)
  6377 |     |             m4 := mload(0x80)
  6378 |     |             // Selector of `log(bool,bool,bool,uint256)`.
  6379 |     |             mstore(0x00, 0x6d7045c1)
  6380 |     |             mstore(0x20, p0)
  6381 |     |             mstore(0x40, p1)
  6382 |     |             mstore(0x60, p2)
  6383 |     |             mstore(0x80, p3)
  6384 |     |         }
  6385 |     |         _sendLogPayload(0x1c, 0x84);
  6386 |     |         /// @solidity memory-safe-assembly
  6387 |     |         assembly {
  6388 |     |             mstore(0x00, m0)
  6389 |     |             mstore(0x20, m1)
  6390 |     |             mstore(0x40, m2)
  6391 |     |             mstore(0x60, m3)
  6392 |     |             mstore(0x80, m4)
  6393 |     |         }
  6394 |     |     }
  6395 |     | 
  6396 |     |     function log(bool p0, bool p1, bool p2, bytes32 p3) internal pure {
  6397 |     |         bytes32 m0;
  6398 |     |         bytes32 m1;
  6399 |     |         bytes32 m2;
  6400 |     |         bytes32 m3;
  6401 |     |         bytes32 m4;
  6402 |     |         bytes32 m5;
  6403 |     |         bytes32 m6;
  6404 |     |         /// @solidity memory-safe-assembly
  6405 |     |         assembly {
  6406 |     |             function writeString(pos, w) {
  6407 |     |                 let length := 0
  6408 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  6409 |     |                 mstore(pos, length)
  6410 |     |                 let shift := sub(256, shl(3, length))
  6411 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  6412 |     |             }
  6413 |     |             m0 := mload(0x00)
  6414 |     |             m1 := mload(0x20)
  6415 |     |             m2 := mload(0x40)
  6416 |     |             m3 := mload(0x60)
  6417 |     |             m4 := mload(0x80)
  6418 |     |             m5 := mload(0xa0)
  6419 |     |             m6 := mload(0xc0)
  6420 |     |             // Selector of `log(bool,bool,bool,string)`.
  6421 |     |             mstore(0x00, 0x2ae408d4)
  6422 |     |             mstore(0x20, p0)
  6423 |     |             mstore(0x40, p1)
  6424 |     |             mstore(0x60, p2)
  6425 |     |             mstore(0x80, 0x80)
  6426 |     |             writeString(0xa0, p3)
  6427 |     |         }
  6428 |     |         _sendLogPayload(0x1c, 0xc4);
  6429 |     |         /// @solidity memory-safe-assembly
  6430 |     |         assembly {
  6431 |     |             mstore(0x00, m0)
  6432 |     |             mstore(0x20, m1)
  6433 |     |             mstore(0x40, m2)
  6434 |     |             mstore(0x60, m3)
  6435 |     |             mstore(0x80, m4)
  6436 |     |             mstore(0xa0, m5)
  6437 |     |             mstore(0xc0, m6)
  6438 |     |         }
  6439 |     |     }
  6440 |     | 
  6441 |     |     function log(bool p0, bool p1, uint256 p2, address p3) internal pure {
  6442 |     |         bytes32 m0;
  6443 |     |         bytes32 m1;
  6444 |     |         bytes32 m2;
  6445 |     |         bytes32 m3;
  6446 |     |         bytes32 m4;
  6447 |     |         /// @solidity memory-safe-assembly
  6448 |     |         assembly {
  6449 |     |             m0 := mload(0x00)
  6450 |     |             m1 := mload(0x20)
  6451 |     |             m2 := mload(0x40)
  6452 |     |             m3 := mload(0x60)
  6453 |     |             m4 := mload(0x80)
  6454 |     |             // Selector of `log(bool,bool,uint256,address)`.
  6455 |     |             mstore(0x00, 0x54a7a9a0)
  6456 |     |             mstore(0x20, p0)
  6457 |     |             mstore(0x40, p1)
  6458 |     |             mstore(0x60, p2)
  6459 |     |             mstore(0x80, p3)
  6460 |     |         }
  6461 |     |         _sendLogPayload(0x1c, 0x84);
  6462 |     |         /// @solidity memory-safe-assembly
  6463 |     |         assembly {
  6464 |     |             mstore(0x00, m0)
  6465 |     |             mstore(0x20, m1)
  6466 |     |             mstore(0x40, m2)
  6467 |     |             mstore(0x60, m3)
  6468 |     |             mstore(0x80, m4)
  6469 |     |         }
  6470 |     |     }
  6471 |     | 
  6472 |     |     function log(bool p0, bool p1, uint256 p2, bool p3) internal pure {
  6473 |     |         bytes32 m0;
  6474 |     |         bytes32 m1;
  6475 |     |         bytes32 m2;
  6476 |     |         bytes32 m3;
  6477 |     |         bytes32 m4;
  6478 |     |         /// @solidity memory-safe-assembly
  6479 |     |         assembly {
  6480 |     |             m0 := mload(0x00)
  6481 |     |             m1 := mload(0x20)
  6482 |     |             m2 := mload(0x40)
  6483 |     |             m3 := mload(0x60)
  6484 |     |             m4 := mload(0x80)
  6485 |     |             // Selector of `log(bool,bool,uint256,bool)`.
  6486 |     |             mstore(0x00, 0x619e4d0e)
  6487 |     |             mstore(0x20, p0)
  6488 |     |             mstore(0x40, p1)
  6489 |     |             mstore(0x60, p2)
  6490 |     |             mstore(0x80, p3)
  6491 |     |         }
  6492 |     |         _sendLogPayload(0x1c, 0x84);
  6493 |     |         /// @solidity memory-safe-assembly
  6494 |     |         assembly {
  6495 |     |             mstore(0x00, m0)
  6496 |     |             mstore(0x20, m1)
  6497 |     |             mstore(0x40, m2)
  6498 |     |             mstore(0x60, m3)
  6499 |     |             mstore(0x80, m4)
  6500 |     |         }
  6501 |     |     }
  6502 |     | 
  6503 |     |     function log(bool p0, bool p1, uint256 p2, uint256 p3) internal pure {
  6504 |     |         bytes32 m0;
  6505 |     |         bytes32 m1;
  6506 |     |         bytes32 m2;
  6507 |     |         bytes32 m3;
  6508 |     |         bytes32 m4;
  6509 |     |         /// @solidity memory-safe-assembly
  6510 |     |         assembly {
  6511 |     |             m0 := mload(0x00)
  6512 |     |             m1 := mload(0x20)
  6513 |     |             m2 := mload(0x40)
  6514 |     |             m3 := mload(0x60)
  6515 |     |             m4 := mload(0x80)
  6516 |     |             // Selector of `log(bool,bool,uint256,uint256)`.
  6517 |     |             mstore(0x00, 0x0bb00eab)
  6518 |     |             mstore(0x20, p0)
  6519 |     |             mstore(0x40, p1)
  6520 |     |             mstore(0x60, p2)
  6521 |     |             mstore(0x80, p3)
  6522 |     |         }
  6523 |     |         _sendLogPayload(0x1c, 0x84);
  6524 |     |         /// @solidity memory-safe-assembly
  6525 |     |         assembly {
  6526 |     |             mstore(0x00, m0)
  6527 |     |             mstore(0x20, m1)
  6528 |     |             mstore(0x40, m2)
  6529 |     |             mstore(0x60, m3)
  6530 |     |             mstore(0x80, m4)
  6531 |     |         }
  6532 |     |     }
  6533 |     | 
  6534 |     |     function log(bool p0, bool p1, uint256 p2, bytes32 p3) internal pure {
  6535 |     |         bytes32 m0;
  6536 |     |         bytes32 m1;
  6537 |     |         bytes32 m2;
  6538 |     |         bytes32 m3;
  6539 |     |         bytes32 m4;
  6540 |     |         bytes32 m5;
  6541 |     |         bytes32 m6;
  6542 |     |         /// @solidity memory-safe-assembly
  6543 |     |         assembly {
  6544 |     |             function writeString(pos, w) {
  6545 |     |                 let length := 0
  6546 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  6547 |     |                 mstore(pos, length)
  6548 |     |                 let shift := sub(256, shl(3, length))
  6549 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  6550 |     |             }
  6551 |     |             m0 := mload(0x00)
  6552 |     |             m1 := mload(0x20)
  6553 |     |             m2 := mload(0x40)
  6554 |     |             m3 := mload(0x60)
  6555 |     |             m4 := mload(0x80)
  6556 |     |             m5 := mload(0xa0)
  6557 |     |             m6 := mload(0xc0)
  6558 |     |             // Selector of `log(bool,bool,uint256,string)`.
  6559 |     |             mstore(0x00, 0x7dd4d0e0)
  6560 |     |             mstore(0x20, p0)
  6561 |     |             mstore(0x40, p1)
  6562 |     |             mstore(0x60, p2)
  6563 |     |             mstore(0x80, 0x80)
  6564 |     |             writeString(0xa0, p3)
  6565 |     |         }
  6566 |     |         _sendLogPayload(0x1c, 0xc4);
  6567 |     |         /// @solidity memory-safe-assembly
  6568 |     |         assembly {
  6569 |     |             mstore(0x00, m0)
  6570 |     |             mstore(0x20, m1)
  6571 |     |             mstore(0x40, m2)
  6572 |     |             mstore(0x60, m3)
  6573 |     |             mstore(0x80, m4)
  6574 |     |             mstore(0xa0, m5)
  6575 |     |             mstore(0xc0, m6)
  6576 |     |         }
  6577 |     |     }
  6578 |     | 
  6579 |     |     function log(bool p0, bool p1, bytes32 p2, address p3) internal pure {
  6580 |     |         bytes32 m0;
  6581 |     |         bytes32 m1;
  6582 |     |         bytes32 m2;
  6583 |     |         bytes32 m3;
  6584 |     |         bytes32 m4;
  6585 |     |         bytes32 m5;
  6586 |     |         bytes32 m6;
  6587 |     |         /// @solidity memory-safe-assembly
  6588 |     |         assembly {
  6589 |     |             function writeString(pos, w) {
  6590 |     |                 let length := 0
  6591 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  6592 |     |                 mstore(pos, length)
  6593 |     |                 let shift := sub(256, shl(3, length))
  6594 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  6595 |     |             }
  6596 |     |             m0 := mload(0x00)
  6597 |     |             m1 := mload(0x20)
  6598 |     |             m2 := mload(0x40)
  6599 |     |             m3 := mload(0x60)
  6600 |     |             m4 := mload(0x80)
  6601 |     |             m5 := mload(0xa0)
  6602 |     |             m6 := mload(0xc0)
  6603 |     |             // Selector of `log(bool,bool,string,address)`.
  6604 |     |             mstore(0x00, 0xf9ad2b89)
  6605 |     |             mstore(0x20, p0)
  6606 |     |             mstore(0x40, p1)
  6607 |     |             mstore(0x60, 0x80)
  6608 |     |             mstore(0x80, p3)
  6609 |     |             writeString(0xa0, p2)
  6610 |     |         }
  6611 |     |         _sendLogPayload(0x1c, 0xc4);
  6612 |     |         /// @solidity memory-safe-assembly
  6613 |     |         assembly {
  6614 |     |             mstore(0x00, m0)
  6615 |     |             mstore(0x20, m1)
  6616 |     |             mstore(0x40, m2)
  6617 |     |             mstore(0x60, m3)
  6618 |     |             mstore(0x80, m4)
  6619 |     |             mstore(0xa0, m5)
  6620 |     |             mstore(0xc0, m6)
  6621 |     |         }
  6622 |     |     }
  6623 |     | 
  6624 |     |     function log(bool p0, bool p1, bytes32 p2, bool p3) internal pure {
  6625 |     |         bytes32 m0;
  6626 |     |         bytes32 m1;
  6627 |     |         bytes32 m2;
  6628 |     |         bytes32 m3;
  6629 |     |         bytes32 m4;
  6630 |     |         bytes32 m5;
  6631 |     |         bytes32 m6;
  6632 |     |         /// @solidity memory-safe-assembly
  6633 |     |         assembly {
  6634 |     |             function writeString(pos, w) {
  6635 |     |                 let length := 0
  6636 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  6637 |     |                 mstore(pos, length)
  6638 |     |                 let shift := sub(256, shl(3, length))
  6639 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  6640 |     |             }
  6641 |     |             m0 := mload(0x00)
  6642 |     |             m1 := mload(0x20)
  6643 |     |             m2 := mload(0x40)
  6644 |     |             m3 := mload(0x60)
  6645 |     |             m4 := mload(0x80)
  6646 |     |             m5 := mload(0xa0)
  6647 |     |             m6 := mload(0xc0)
  6648 |     |             // Selector of `log(bool,bool,string,bool)`.
  6649 |     |             mstore(0x00, 0xb857163a)
  6650 |     |             mstore(0x20, p0)
  6651 |     |             mstore(0x40, p1)
  6652 |     |             mstore(0x60, 0x80)
  6653 |     |             mstore(0x80, p3)
  6654 |     |             writeString(0xa0, p2)
  6655 |     |         }
  6656 |     |         _sendLogPayload(0x1c, 0xc4);
  6657 |     |         /// @solidity memory-safe-assembly
  6658 |     |         assembly {
  6659 |     |             mstore(0x00, m0)
  6660 |     |             mstore(0x20, m1)
  6661 |     |             mstore(0x40, m2)
  6662 |     |             mstore(0x60, m3)
  6663 |     |             mstore(0x80, m4)
  6664 |     |             mstore(0xa0, m5)
  6665 |     |             mstore(0xc0, m6)
  6666 |     |         }
  6667 |     |     }
  6668 |     | 
  6669 |     |     function log(bool p0, bool p1, bytes32 p2, uint256 p3) internal pure {
  6670 |     |         bytes32 m0;
  6671 |     |         bytes32 m1;
  6672 |     |         bytes32 m2;
  6673 |     |         bytes32 m3;
  6674 |     |         bytes32 m4;
  6675 |     |         bytes32 m5;
  6676 |     |         bytes32 m6;
  6677 |     |         /// @solidity memory-safe-assembly
  6678 |     |         assembly {
  6679 |     |             function writeString(pos, w) {
  6680 |     |                 let length := 0
  6681 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  6682 |     |                 mstore(pos, length)
  6683 |     |                 let shift := sub(256, shl(3, length))
  6684 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  6685 |     |             }
  6686 |     |             m0 := mload(0x00)
  6687 |     |             m1 := mload(0x20)
  6688 |     |             m2 := mload(0x40)
  6689 |     |             m3 := mload(0x60)
  6690 |     |             m4 := mload(0x80)
  6691 |     |             m5 := mload(0xa0)
  6692 |     |             m6 := mload(0xc0)
  6693 |     |             // Selector of `log(bool,bool,string,uint256)`.
  6694 |     |             mstore(0x00, 0xe3a9ca2f)
  6695 |     |             mstore(0x20, p0)
  6696 |     |             mstore(0x40, p1)
  6697 |     |             mstore(0x60, 0x80)
  6698 |     |             mstore(0x80, p3)
  6699 |     |             writeString(0xa0, p2)
  6700 |     |         }
  6701 |     |         _sendLogPayload(0x1c, 0xc4);
  6702 |     |         /// @solidity memory-safe-assembly
  6703 |     |         assembly {
  6704 |     |             mstore(0x00, m0)
  6705 |     |             mstore(0x20, m1)
  6706 |     |             mstore(0x40, m2)
  6707 |     |             mstore(0x60, m3)
  6708 |     |             mstore(0x80, m4)
  6709 |     |             mstore(0xa0, m5)
  6710 |     |             mstore(0xc0, m6)
  6711 |     |         }
  6712 |     |     }
  6713 |     | 
  6714 |     |     function log(bool p0, bool p1, bytes32 p2, bytes32 p3) internal pure {
  6715 |     |         bytes32 m0;
  6716 |     |         bytes32 m1;
  6717 |     |         bytes32 m2;
  6718 |     |         bytes32 m3;
  6719 |     |         bytes32 m4;
  6720 |     |         bytes32 m5;
  6721 |     |         bytes32 m6;
  6722 |     |         bytes32 m7;
  6723 |     |         bytes32 m8;
  6724 |     |         /// @solidity memory-safe-assembly
  6725 |     |         assembly {
  6726 |     |             function writeString(pos, w) {
  6727 |     |                 let length := 0
  6728 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  6729 |     |                 mstore(pos, length)
  6730 |     |                 let shift := sub(256, shl(3, length))
  6731 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  6732 |     |             }
  6733 |     |             m0 := mload(0x00)
  6734 |     |             m1 := mload(0x20)
  6735 |     |             m2 := mload(0x40)
  6736 |     |             m3 := mload(0x60)
  6737 |     |             m4 := mload(0x80)
  6738 |     |             m5 := mload(0xa0)
  6739 |     |             m6 := mload(0xc0)
  6740 |     |             m7 := mload(0xe0)
  6741 |     |             m8 := mload(0x100)
  6742 |     |             // Selector of `log(bool,bool,string,string)`.
  6743 |     |             mstore(0x00, 0x6d1e8751)
  6744 |     |             mstore(0x20, p0)
  6745 |     |             mstore(0x40, p1)
  6746 |     |             mstore(0x60, 0x80)
  6747 |     |             mstore(0x80, 0xc0)
  6748 |     |             writeString(0xa0, p2)
  6749 |     |             writeString(0xe0, p3)
  6750 |     |         }
  6751 |     |         _sendLogPayload(0x1c, 0x104);
  6752 |     |         /// @solidity memory-safe-assembly
  6753 |     |         assembly {
  6754 |     |             mstore(0x00, m0)
  6755 |     |             mstore(0x20, m1)
  6756 |     |             mstore(0x40, m2)
  6757 |     |             mstore(0x60, m3)
  6758 |     |             mstore(0x80, m4)
  6759 |     |             mstore(0xa0, m5)
  6760 |     |             mstore(0xc0, m6)
  6761 |     |             mstore(0xe0, m7)
  6762 |     |             mstore(0x100, m8)
  6763 |     |         }
  6764 |     |     }
  6765 |     | 
  6766 |     |     function log(bool p0, uint256 p1, address p2, address p3) internal pure {
  6767 |     |         bytes32 m0;
  6768 |     |         bytes32 m1;
  6769 |     |         bytes32 m2;
  6770 |     |         bytes32 m3;
  6771 |     |         bytes32 m4;
  6772 |     |         /// @solidity memory-safe-assembly
  6773 |     |         assembly {
  6774 |     |             m0 := mload(0x00)
  6775 |     |             m1 := mload(0x20)
  6776 |     |             m2 := mload(0x40)
  6777 |     |             m3 := mload(0x60)
  6778 |     |             m4 := mload(0x80)
  6779 |     |             // Selector of `log(bool,uint256,address,address)`.
  6780 |     |             mstore(0x00, 0x26f560a8)
  6781 |     |             mstore(0x20, p0)
  6782 |     |             mstore(0x40, p1)
  6783 |     |             mstore(0x60, p2)
  6784 |     |             mstore(0x80, p3)
  6785 |     |         }
  6786 |     |         _sendLogPayload(0x1c, 0x84);
  6787 |     |         /// @solidity memory-safe-assembly
  6788 |     |         assembly {
  6789 |     |             mstore(0x00, m0)
  6790 |     |             mstore(0x20, m1)
  6791 |     |             mstore(0x40, m2)
  6792 |     |             mstore(0x60, m3)
  6793 |     |             mstore(0x80, m4)
  6794 |     |         }
  6795 |     |     }
  6796 |     | 
  6797 |     |     function log(bool p0, uint256 p1, address p2, bool p3) internal pure {
  6798 |     |         bytes32 m0;
  6799 |     |         bytes32 m1;
  6800 |     |         bytes32 m2;
  6801 |     |         bytes32 m3;
  6802 |     |         bytes32 m4;
  6803 |     |         /// @solidity memory-safe-assembly
  6804 |     |         assembly {
  6805 |     |             m0 := mload(0x00)
  6806 |     |             m1 := mload(0x20)
  6807 |     |             m2 := mload(0x40)
  6808 |     |             m3 := mload(0x60)
  6809 |     |             m4 := mload(0x80)
  6810 |     |             // Selector of `log(bool,uint256,address,bool)`.
  6811 |     |             mstore(0x00, 0xb4c314ff)
  6812 |     |             mstore(0x20, p0)
  6813 |     |             mstore(0x40, p1)
  6814 |     |             mstore(0x60, p2)
  6815 |     |             mstore(0x80, p3)
  6816 |     |         }
  6817 |     |         _sendLogPayload(0x1c, 0x84);
  6818 |     |         /// @solidity memory-safe-assembly
  6819 |     |         assembly {
  6820 |     |             mstore(0x00, m0)
  6821 |     |             mstore(0x20, m1)
  6822 |     |             mstore(0x40, m2)
  6823 |     |             mstore(0x60, m3)
  6824 |     |             mstore(0x80, m4)
  6825 |     |         }
  6826 |     |     }
  6827 |     | 
  6828 |     |     function log(bool p0, uint256 p1, address p2, uint256 p3) internal pure {
  6829 |     |         bytes32 m0;
  6830 |     |         bytes32 m1;
  6831 |     |         bytes32 m2;
  6832 |     |         bytes32 m3;
  6833 |     |         bytes32 m4;
  6834 |     |         /// @solidity memory-safe-assembly
  6835 |     |         assembly {
  6836 |     |             m0 := mload(0x00)
  6837 |     |             m1 := mload(0x20)
  6838 |     |             m2 := mload(0x40)
  6839 |     |             m3 := mload(0x60)
  6840 |     |             m4 := mload(0x80)
  6841 |     |             // Selector of `log(bool,uint256,address,uint256)`.
  6842 |     |             mstore(0x00, 0x1537dc87)
  6843 |     |             mstore(0x20, p0)
  6844 |     |             mstore(0x40, p1)
  6845 |     |             mstore(0x60, p2)
  6846 |     |             mstore(0x80, p3)
  6847 |     |         }
  6848 |     |         _sendLogPayload(0x1c, 0x84);
  6849 |     |         /// @solidity memory-safe-assembly
  6850 |     |         assembly {
  6851 |     |             mstore(0x00, m0)
  6852 |     |             mstore(0x20, m1)
  6853 |     |             mstore(0x40, m2)
  6854 |     |             mstore(0x60, m3)
  6855 |     |             mstore(0x80, m4)
  6856 |     |         }
  6857 |     |     }
  6858 |     | 
  6859 |     |     function log(bool p0, uint256 p1, address p2, bytes32 p3) internal pure {
  6860 |     |         bytes32 m0;
  6861 |     |         bytes32 m1;
  6862 |     |         bytes32 m2;
  6863 |     |         bytes32 m3;
  6864 |     |         bytes32 m4;
  6865 |     |         bytes32 m5;
  6866 |     |         bytes32 m6;
  6867 |     |         /// @solidity memory-safe-assembly
  6868 |     |         assembly {
  6869 |     |             function writeString(pos, w) {
  6870 |     |                 let length := 0
  6871 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  6872 |     |                 mstore(pos, length)
  6873 |     |                 let shift := sub(256, shl(3, length))
  6874 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  6875 |     |             }
  6876 |     |             m0 := mload(0x00)
  6877 |     |             m1 := mload(0x20)
  6878 |     |             m2 := mload(0x40)
  6879 |     |             m3 := mload(0x60)
  6880 |     |             m4 := mload(0x80)
  6881 |     |             m5 := mload(0xa0)
  6882 |     |             m6 := mload(0xc0)
  6883 |     |             // Selector of `log(bool,uint256,address,string)`.
  6884 |     |             mstore(0x00, 0x1bb3b09a)
  6885 |     |             mstore(0x20, p0)
  6886 |     |             mstore(0x40, p1)
  6887 |     |             mstore(0x60, p2)
  6888 |     |             mstore(0x80, 0x80)
  6889 |     |             writeString(0xa0, p3)
  6890 |     |         }
  6891 |     |         _sendLogPayload(0x1c, 0xc4);
  6892 |     |         /// @solidity memory-safe-assembly
  6893 |     |         assembly {
  6894 |     |             mstore(0x00, m0)
  6895 |     |             mstore(0x20, m1)
  6896 |     |             mstore(0x40, m2)
  6897 |     |             mstore(0x60, m3)
  6898 |     |             mstore(0x80, m4)
  6899 |     |             mstore(0xa0, m5)
  6900 |     |             mstore(0xc0, m6)
  6901 |     |         }
  6902 |     |     }
  6903 |     | 
  6904 |     |     function log(bool p0, uint256 p1, bool p2, address p3) internal pure {
  6905 |     |         bytes32 m0;
  6906 |     |         bytes32 m1;
  6907 |     |         bytes32 m2;
  6908 |     |         bytes32 m3;
  6909 |     |         bytes32 m4;
  6910 |     |         /// @solidity memory-safe-assembly
  6911 |     |         assembly {
  6912 |     |             m0 := mload(0x00)
  6913 |     |             m1 := mload(0x20)
  6914 |     |             m2 := mload(0x40)
  6915 |     |             m3 := mload(0x60)
  6916 |     |             m4 := mload(0x80)
  6917 |     |             // Selector of `log(bool,uint256,bool,address)`.
  6918 |     |             mstore(0x00, 0x9acd3616)
  6919 |     |             mstore(0x20, p0)
  6920 |     |             mstore(0x40, p1)
  6921 |     |             mstore(0x60, p2)
  6922 |     |             mstore(0x80, p3)
  6923 |     |         }
  6924 |     |         _sendLogPayload(0x1c, 0x84);
  6925 |     |         /// @solidity memory-safe-assembly
  6926 |     |         assembly {
  6927 |     |             mstore(0x00, m0)
  6928 |     |             mstore(0x20, m1)
  6929 |     |             mstore(0x40, m2)
  6930 |     |             mstore(0x60, m3)
  6931 |     |             mstore(0x80, m4)
  6932 |     |         }
  6933 |     |     }
  6934 |     | 
  6935 |     |     function log(bool p0, uint256 p1, bool p2, bool p3) internal pure {
  6936 |     |         bytes32 m0;
  6937 |     |         bytes32 m1;
  6938 |     |         bytes32 m2;
  6939 |     |         bytes32 m3;
  6940 |     |         bytes32 m4;
  6941 |     |         /// @solidity memory-safe-assembly
  6942 |     |         assembly {
  6943 |     |             m0 := mload(0x00)
  6944 |     |             m1 := mload(0x20)
  6945 |     |             m2 := mload(0x40)
  6946 |     |             m3 := mload(0x60)
  6947 |     |             m4 := mload(0x80)
  6948 |     |             // Selector of `log(bool,uint256,bool,bool)`.
  6949 |     |             mstore(0x00, 0xceb5f4d7)
  6950 |     |             mstore(0x20, p0)
  6951 |     |             mstore(0x40, p1)
  6952 |     |             mstore(0x60, p2)
  6953 |     |             mstore(0x80, p3)
  6954 |     |         }
  6955 |     |         _sendLogPayload(0x1c, 0x84);
  6956 |     |         /// @solidity memory-safe-assembly
  6957 |     |         assembly {
  6958 |     |             mstore(0x00, m0)
  6959 |     |             mstore(0x20, m1)
  6960 |     |             mstore(0x40, m2)
  6961 |     |             mstore(0x60, m3)
  6962 |     |             mstore(0x80, m4)
  6963 |     |         }
  6964 |     |     }
  6965 |     | 
  6966 |     |     function log(bool p0, uint256 p1, bool p2, uint256 p3) internal pure {
  6967 |     |         bytes32 m0;
  6968 |     |         bytes32 m1;
  6969 |     |         bytes32 m2;
  6970 |     |         bytes32 m3;
  6971 |     |         bytes32 m4;
  6972 |     |         /// @solidity memory-safe-assembly
  6973 |     |         assembly {
  6974 |     |             m0 := mload(0x00)
  6975 |     |             m1 := mload(0x20)
  6976 |     |             m2 := mload(0x40)
  6977 |     |             m3 := mload(0x60)
  6978 |     |             m4 := mload(0x80)
  6979 |     |             // Selector of `log(bool,uint256,bool,uint256)`.
  6980 |     |             mstore(0x00, 0x7f9bbca2)
  6981 |     |             mstore(0x20, p0)
  6982 |     |             mstore(0x40, p1)
  6983 |     |             mstore(0x60, p2)
  6984 |     |             mstore(0x80, p3)
  6985 |     |         }
  6986 |     |         _sendLogPayload(0x1c, 0x84);
  6987 |     |         /// @solidity memory-safe-assembly
  6988 |     |         assembly {
  6989 |     |             mstore(0x00, m0)
  6990 |     |             mstore(0x20, m1)
  6991 |     |             mstore(0x40, m2)
  6992 |     |             mstore(0x60, m3)
  6993 |     |             mstore(0x80, m4)
  6994 |     |         }
  6995 |     |     }
  6996 |     | 
  6997 |     |     function log(bool p0, uint256 p1, bool p2, bytes32 p3) internal pure {
  6998 |     |         bytes32 m0;
  6999 |     |         bytes32 m1;
  7000 |     |         bytes32 m2;
  7001 |     |         bytes32 m3;
  7002 |     |         bytes32 m4;
  7003 |     |         bytes32 m5;
  7004 |     |         bytes32 m6;
  7005 |     |         /// @solidity memory-safe-assembly
  7006 |     |         assembly {
  7007 |     |             function writeString(pos, w) {
  7008 |     |                 let length := 0
  7009 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  7010 |     |                 mstore(pos, length)
  7011 |     |                 let shift := sub(256, shl(3, length))
  7012 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  7013 |     |             }
  7014 |     |             m0 := mload(0x00)
  7015 |     |             m1 := mload(0x20)
  7016 |     |             m2 := mload(0x40)
  7017 |     |             m3 := mload(0x60)
  7018 |     |             m4 := mload(0x80)
  7019 |     |             m5 := mload(0xa0)
  7020 |     |             m6 := mload(0xc0)
  7021 |     |             // Selector of `log(bool,uint256,bool,string)`.
  7022 |     |             mstore(0x00, 0x9143dbb1)
  7023 |     |             mstore(0x20, p0)
  7024 |     |             mstore(0x40, p1)
  7025 |     |             mstore(0x60, p2)
  7026 |     |             mstore(0x80, 0x80)
  7027 |     |             writeString(0xa0, p3)
  7028 |     |         }
  7029 |     |         _sendLogPayload(0x1c, 0xc4);
  7030 |     |         /// @solidity memory-safe-assembly
  7031 |     |         assembly {
  7032 |     |             mstore(0x00, m0)
  7033 |     |             mstore(0x20, m1)
  7034 |     |             mstore(0x40, m2)
  7035 |     |             mstore(0x60, m3)
  7036 |     |             mstore(0x80, m4)
  7037 |     |             mstore(0xa0, m5)
  7038 |     |             mstore(0xc0, m6)
  7039 |     |         }
  7040 |     |     }
  7041 |     | 
  7042 |     |     function log(bool p0, uint256 p1, uint256 p2, address p3) internal pure {
  7043 |     |         bytes32 m0;
  7044 |     |         bytes32 m1;
  7045 |     |         bytes32 m2;
  7046 |     |         bytes32 m3;
  7047 |     |         bytes32 m4;
  7048 |     |         /// @solidity memory-safe-assembly
  7049 |     |         assembly {
  7050 |     |             m0 := mload(0x00)
  7051 |     |             m1 := mload(0x20)
  7052 |     |             m2 := mload(0x40)
  7053 |     |             m3 := mload(0x60)
  7054 |     |             m4 := mload(0x80)
  7055 |     |             // Selector of `log(bool,uint256,uint256,address)`.
  7056 |     |             mstore(0x00, 0x00dd87b9)
  7057 |     |             mstore(0x20, p0)
  7058 |     |             mstore(0x40, p1)
  7059 |     |             mstore(0x60, p2)
  7060 |     |             mstore(0x80, p3)
  7061 |     |         }
  7062 |     |         _sendLogPayload(0x1c, 0x84);
  7063 |     |         /// @solidity memory-safe-assembly
  7064 |     |         assembly {
  7065 |     |             mstore(0x00, m0)
  7066 |     |             mstore(0x20, m1)
  7067 |     |             mstore(0x40, m2)
  7068 |     |             mstore(0x60, m3)
  7069 |     |             mstore(0x80, m4)
  7070 |     |         }
  7071 |     |     }
  7072 |     | 
  7073 |     |     function log(bool p0, uint256 p1, uint256 p2, bool p3) internal pure {
  7074 |     |         bytes32 m0;
  7075 |     |         bytes32 m1;
  7076 |     |         bytes32 m2;
  7077 |     |         bytes32 m3;
  7078 |     |         bytes32 m4;
  7079 |     |         /// @solidity memory-safe-assembly
  7080 |     |         assembly {
  7081 |     |             m0 := mload(0x00)
  7082 |     |             m1 := mload(0x20)
  7083 |     |             m2 := mload(0x40)
  7084 |     |             m3 := mload(0x60)
  7085 |     |             m4 := mload(0x80)
  7086 |     |             // Selector of `log(bool,uint256,uint256,bool)`.
  7087 |     |             mstore(0x00, 0xbe984353)
  7088 |     |             mstore(0x20, p0)
  7089 |     |             mstore(0x40, p1)
  7090 |     |             mstore(0x60, p2)
  7091 |     |             mstore(0x80, p3)
  7092 |     |         }
  7093 |     |         _sendLogPayload(0x1c, 0x84);
  7094 |     |         /// @solidity memory-safe-assembly
  7095 |     |         assembly {
  7096 |     |             mstore(0x00, m0)
  7097 |     |             mstore(0x20, m1)
  7098 |     |             mstore(0x40, m2)
  7099 |     |             mstore(0x60, m3)
  7100 |     |             mstore(0x80, m4)
  7101 |     |         }
  7102 |     |     }
  7103 |     | 
  7104 |     |     function log(bool p0, uint256 p1, uint256 p2, uint256 p3) internal pure {
  7105 |     |         bytes32 m0;
  7106 |     |         bytes32 m1;
  7107 |     |         bytes32 m2;
  7108 |     |         bytes32 m3;
  7109 |     |         bytes32 m4;
  7110 |     |         /// @solidity memory-safe-assembly
  7111 |     |         assembly {
  7112 |     |             m0 := mload(0x00)
  7113 |     |             m1 := mload(0x20)
  7114 |     |             m2 := mload(0x40)
  7115 |     |             m3 := mload(0x60)
  7116 |     |             m4 := mload(0x80)
  7117 |     |             // Selector of `log(bool,uint256,uint256,uint256)`.
  7118 |     |             mstore(0x00, 0x374bb4b2)
  7119 |     |             mstore(0x20, p0)
  7120 |     |             mstore(0x40, p1)
  7121 |     |             mstore(0x60, p2)
  7122 |     |             mstore(0x80, p3)
  7123 |     |         }
  7124 |     |         _sendLogPayload(0x1c, 0x84);
  7125 |     |         /// @solidity memory-safe-assembly
  7126 |     |         assembly {
  7127 |     |             mstore(0x00, m0)
  7128 |     |             mstore(0x20, m1)
  7129 |     |             mstore(0x40, m2)
  7130 |     |             mstore(0x60, m3)
  7131 |     |             mstore(0x80, m4)
  7132 |     |         }
  7133 |     |     }
  7134 |     | 
  7135 |     |     function log(bool p0, uint256 p1, uint256 p2, bytes32 p3) internal pure {
  7136 |     |         bytes32 m0;
  7137 |     |         bytes32 m1;
  7138 |     |         bytes32 m2;
  7139 |     |         bytes32 m3;
  7140 |     |         bytes32 m4;
  7141 |     |         bytes32 m5;
  7142 |     |         bytes32 m6;
  7143 |     |         /// @solidity memory-safe-assembly
  7144 |     |         assembly {
  7145 |     |             function writeString(pos, w) {
  7146 |     |                 let length := 0
  7147 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  7148 |     |                 mstore(pos, length)
  7149 |     |                 let shift := sub(256, shl(3, length))
  7150 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  7151 |     |             }
  7152 |     |             m0 := mload(0x00)
  7153 |     |             m1 := mload(0x20)
  7154 |     |             m2 := mload(0x40)
  7155 |     |             m3 := mload(0x60)
  7156 |     |             m4 := mload(0x80)
  7157 |     |             m5 := mload(0xa0)
  7158 |     |             m6 := mload(0xc0)
  7159 |     |             // Selector of `log(bool,uint256,uint256,string)`.
  7160 |     |             mstore(0x00, 0x8e69fb5d)
  7161 |     |             mstore(0x20, p0)
  7162 |     |             mstore(0x40, p1)
  7163 |     |             mstore(0x60, p2)
  7164 |     |             mstore(0x80, 0x80)
  7165 |     |             writeString(0xa0, p3)
  7166 |     |         }
  7167 |     |         _sendLogPayload(0x1c, 0xc4);
  7168 |     |         /// @solidity memory-safe-assembly
  7169 |     |         assembly {
  7170 |     |             mstore(0x00, m0)
  7171 |     |             mstore(0x20, m1)
  7172 |     |             mstore(0x40, m2)
  7173 |     |             mstore(0x60, m3)
  7174 |     |             mstore(0x80, m4)
  7175 |     |             mstore(0xa0, m5)
  7176 |     |             mstore(0xc0, m6)
  7177 |     |         }
  7178 |     |     }
  7179 |     | 
  7180 |     |     function log(bool p0, uint256 p1, bytes32 p2, address p3) internal pure {
  7181 |     |         bytes32 m0;
  7182 |     |         bytes32 m1;
  7183 |     |         bytes32 m2;
  7184 |     |         bytes32 m3;
  7185 |     |         bytes32 m4;
  7186 |     |         bytes32 m5;
  7187 |     |         bytes32 m6;
  7188 |     |         /// @solidity memory-safe-assembly
  7189 |     |         assembly {
  7190 |     |             function writeString(pos, w) {
  7191 |     |                 let length := 0
  7192 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  7193 |     |                 mstore(pos, length)
  7194 |     |                 let shift := sub(256, shl(3, length))
  7195 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  7196 |     |             }
  7197 |     |             m0 := mload(0x00)
  7198 |     |             m1 := mload(0x20)
  7199 |     |             m2 := mload(0x40)
  7200 |     |             m3 := mload(0x60)
  7201 |     |             m4 := mload(0x80)
  7202 |     |             m5 := mload(0xa0)
  7203 |     |             m6 := mload(0xc0)
  7204 |     |             // Selector of `log(bool,uint256,string,address)`.
  7205 |     |             mstore(0x00, 0xfedd1fff)
  7206 |     |             mstore(0x20, p0)
  7207 |     |             mstore(0x40, p1)
  7208 |     |             mstore(0x60, 0x80)
  7209 |     |             mstore(0x80, p3)
  7210 |     |             writeString(0xa0, p2)
  7211 |     |         }
  7212 |     |         _sendLogPayload(0x1c, 0xc4);
  7213 |     |         /// @solidity memory-safe-assembly
  7214 |     |         assembly {
  7215 |     |             mstore(0x00, m0)
  7216 |     |             mstore(0x20, m1)
  7217 |     |             mstore(0x40, m2)
  7218 |     |             mstore(0x60, m3)
  7219 |     |             mstore(0x80, m4)
  7220 |     |             mstore(0xa0, m5)
  7221 |     |             mstore(0xc0, m6)
  7222 |     |         }
  7223 |     |     }
  7224 |     | 
  7225 |     |     function log(bool p0, uint256 p1, bytes32 p2, bool p3) internal pure {
  7226 |     |         bytes32 m0;
  7227 |     |         bytes32 m1;
  7228 |     |         bytes32 m2;
  7229 |     |         bytes32 m3;
  7230 |     |         bytes32 m4;
  7231 |     |         bytes32 m5;
  7232 |     |         bytes32 m6;
  7233 |     |         /// @solidity memory-safe-assembly
  7234 |     |         assembly {
  7235 |     |             function writeString(pos, w) {
  7236 |     |                 let length := 0
  7237 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  7238 |     |                 mstore(pos, length)
  7239 |     |                 let shift := sub(256, shl(3, length))
  7240 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  7241 |     |             }
  7242 |     |             m0 := mload(0x00)
  7243 |     |             m1 := mload(0x20)
  7244 |     |             m2 := mload(0x40)
  7245 |     |             m3 := mload(0x60)
  7246 |     |             m4 := mload(0x80)
  7247 |     |             m5 := mload(0xa0)
  7248 |     |             m6 := mload(0xc0)
  7249 |     |             // Selector of `log(bool,uint256,string,bool)`.
  7250 |     |             mstore(0x00, 0xe5e70b2b)
  7251 |     |             mstore(0x20, p0)
  7252 |     |             mstore(0x40, p1)
  7253 |     |             mstore(0x60, 0x80)
  7254 |     |             mstore(0x80, p3)
  7255 |     |             writeString(0xa0, p2)
  7256 |     |         }
  7257 |     |         _sendLogPayload(0x1c, 0xc4);
  7258 |     |         /// @solidity memory-safe-assembly
  7259 |     |         assembly {
  7260 |     |             mstore(0x00, m0)
  7261 |     |             mstore(0x20, m1)
  7262 |     |             mstore(0x40, m2)
  7263 |     |             mstore(0x60, m3)
  7264 |     |             mstore(0x80, m4)
  7265 |     |             mstore(0xa0, m5)
  7266 |     |             mstore(0xc0, m6)
  7267 |     |         }
  7268 |     |     }
  7269 |     | 
  7270 |     |     function log(bool p0, uint256 p1, bytes32 p2, uint256 p3) internal pure {
  7271 |     |         bytes32 m0;
  7272 |     |         bytes32 m1;
  7273 |     |         bytes32 m2;
  7274 |     |         bytes32 m3;
  7275 |     |         bytes32 m4;
  7276 |     |         bytes32 m5;
  7277 |     |         bytes32 m6;
  7278 |     |         /// @solidity memory-safe-assembly
  7279 |     |         assembly {
  7280 |     |             function writeString(pos, w) {
  7281 |     |                 let length := 0
  7282 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  7283 |     |                 mstore(pos, length)
  7284 |     |                 let shift := sub(256, shl(3, length))
  7285 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  7286 |     |             }
  7287 |     |             m0 := mload(0x00)
  7288 |     |             m1 := mload(0x20)
  7289 |     |             m2 := mload(0x40)
  7290 |     |             m3 := mload(0x60)
  7291 |     |             m4 := mload(0x80)
  7292 |     |             m5 := mload(0xa0)
  7293 |     |             m6 := mload(0xc0)
  7294 |     |             // Selector of `log(bool,uint256,string,uint256)`.
  7295 |     |             mstore(0x00, 0x6a1199e2)
  7296 |     |             mstore(0x20, p0)
  7297 |     |             mstore(0x40, p1)
  7298 |     |             mstore(0x60, 0x80)
  7299 |     |             mstore(0x80, p3)
  7300 |     |             writeString(0xa0, p2)
  7301 |     |         }
  7302 |     |         _sendLogPayload(0x1c, 0xc4);
  7303 |     |         /// @solidity memory-safe-assembly
  7304 |     |         assembly {
  7305 |     |             mstore(0x00, m0)
  7306 |     |             mstore(0x20, m1)
  7307 |     |             mstore(0x40, m2)
  7308 |     |             mstore(0x60, m3)
  7309 |     |             mstore(0x80, m4)
  7310 |     |             mstore(0xa0, m5)
  7311 |     |             mstore(0xc0, m6)
  7312 |     |         }
  7313 |     |     }
  7314 |     | 
  7315 |     |     function log(bool p0, uint256 p1, bytes32 p2, bytes32 p3) internal pure {
  7316 |     |         bytes32 m0;
  7317 |     |         bytes32 m1;
  7318 |     |         bytes32 m2;
  7319 |     |         bytes32 m3;
  7320 |     |         bytes32 m4;
  7321 |     |         bytes32 m5;
  7322 |     |         bytes32 m6;
  7323 |     |         bytes32 m7;
  7324 |     |         bytes32 m8;
  7325 |     |         /// @solidity memory-safe-assembly
  7326 |     |         assembly {
  7327 |     |             function writeString(pos, w) {
  7328 |     |                 let length := 0
  7329 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  7330 |     |                 mstore(pos, length)
  7331 |     |                 let shift := sub(256, shl(3, length))
  7332 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  7333 |     |             }
  7334 |     |             m0 := mload(0x00)
  7335 |     |             m1 := mload(0x20)
  7336 |     |             m2 := mload(0x40)
  7337 |     |             m3 := mload(0x60)
  7338 |     |             m4 := mload(0x80)
  7339 |     |             m5 := mload(0xa0)
  7340 |     |             m6 := mload(0xc0)
  7341 |     |             m7 := mload(0xe0)
  7342 |     |             m8 := mload(0x100)
  7343 |     |             // Selector of `log(bool,uint256,string,string)`.
  7344 |     |             mstore(0x00, 0xf5bc2249)
  7345 |     |             mstore(0x20, p0)
  7346 |     |             mstore(0x40, p1)
  7347 |     |             mstore(0x60, 0x80)
  7348 |     |             mstore(0x80, 0xc0)
  7349 |     |             writeString(0xa0, p2)
  7350 |     |             writeString(0xe0, p3)
  7351 |     |         }
  7352 |     |         _sendLogPayload(0x1c, 0x104);
  7353 |     |         /// @solidity memory-safe-assembly
  7354 |     |         assembly {
  7355 |     |             mstore(0x00, m0)
  7356 |     |             mstore(0x20, m1)
  7357 |     |             mstore(0x40, m2)
  7358 |     |             mstore(0x60, m3)
  7359 |     |             mstore(0x80, m4)
  7360 |     |             mstore(0xa0, m5)
  7361 |     |             mstore(0xc0, m6)
  7362 |     |             mstore(0xe0, m7)
  7363 |     |             mstore(0x100, m8)
  7364 |     |         }
  7365 |     |     }
  7366 |     | 
  7367 |     |     function log(bool p0, bytes32 p1, address p2, address p3) internal pure {
  7368 |     |         bytes32 m0;
  7369 |     |         bytes32 m1;
  7370 |     |         bytes32 m2;
  7371 |     |         bytes32 m3;
  7372 |     |         bytes32 m4;
  7373 |     |         bytes32 m5;
  7374 |     |         bytes32 m6;
  7375 |     |         /// @solidity memory-safe-assembly
  7376 |     |         assembly {
  7377 |     |             function writeString(pos, w) {
  7378 |     |                 let length := 0
  7379 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  7380 |     |                 mstore(pos, length)
  7381 |     |                 let shift := sub(256, shl(3, length))
  7382 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  7383 |     |             }
  7384 |     |             m0 := mload(0x00)
  7385 |     |             m1 := mload(0x20)
  7386 |     |             m2 := mload(0x40)
  7387 |     |             m3 := mload(0x60)
  7388 |     |             m4 := mload(0x80)
  7389 |     |             m5 := mload(0xa0)
  7390 |     |             m6 := mload(0xc0)
  7391 |     |             // Selector of `log(bool,string,address,address)`.
  7392 |     |             mstore(0x00, 0x2b2b18dc)
  7393 |     |             mstore(0x20, p0)
  7394 |     |             mstore(0x40, 0x80)
  7395 |     |             mstore(0x60, p2)
  7396 |     |             mstore(0x80, p3)
  7397 |     |             writeString(0xa0, p1)
  7398 |     |         }
  7399 |     |         _sendLogPayload(0x1c, 0xc4);
  7400 |     |         /// @solidity memory-safe-assembly
  7401 |     |         assembly {
  7402 |     |             mstore(0x00, m0)
  7403 |     |             mstore(0x20, m1)
  7404 |     |             mstore(0x40, m2)
  7405 |     |             mstore(0x60, m3)
  7406 |     |             mstore(0x80, m4)
  7407 |     |             mstore(0xa0, m5)
  7408 |     |             mstore(0xc0, m6)
  7409 |     |         }
  7410 |     |     }
  7411 |     | 
  7412 |     |     function log(bool p0, bytes32 p1, address p2, bool p3) internal pure {
  7413 |     |         bytes32 m0;
  7414 |     |         bytes32 m1;
  7415 |     |         bytes32 m2;
  7416 |     |         bytes32 m3;
  7417 |     |         bytes32 m4;
  7418 |     |         bytes32 m5;
  7419 |     |         bytes32 m6;
  7420 |     |         /// @solidity memory-safe-assembly
  7421 |     |         assembly {
  7422 |     |             function writeString(pos, w) {
  7423 |     |                 let length := 0
  7424 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  7425 |     |                 mstore(pos, length)
  7426 |     |                 let shift := sub(256, shl(3, length))
  7427 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  7428 |     |             }
  7429 |     |             m0 := mload(0x00)
  7430 |     |             m1 := mload(0x20)
  7431 |     |             m2 := mload(0x40)
  7432 |     |             m3 := mload(0x60)
  7433 |     |             m4 := mload(0x80)
  7434 |     |             m5 := mload(0xa0)
  7435 |     |             m6 := mload(0xc0)
  7436 |     |             // Selector of `log(bool,string,address,bool)`.
  7437 |     |             mstore(0x00, 0x6dd434ca)
  7438 |     |             mstore(0x20, p0)
  7439 |     |             mstore(0x40, 0x80)
  7440 |     |             mstore(0x60, p2)
  7441 |     |             mstore(0x80, p3)
  7442 |     |             writeString(0xa0, p1)
  7443 |     |         }
  7444 |     |         _sendLogPayload(0x1c, 0xc4);
  7445 |     |         /// @solidity memory-safe-assembly
  7446 |     |         assembly {
  7447 |     |             mstore(0x00, m0)
  7448 |     |             mstore(0x20, m1)
  7449 |     |             mstore(0x40, m2)
  7450 |     |             mstore(0x60, m3)
  7451 |     |             mstore(0x80, m4)
  7452 |     |             mstore(0xa0, m5)
  7453 |     |             mstore(0xc0, m6)
  7454 |     |         }
  7455 |     |     }
  7456 |     | 
  7457 |     |     function log(bool p0, bytes32 p1, address p2, uint256 p3) internal pure {
  7458 |     |         bytes32 m0;
  7459 |     |         bytes32 m1;
  7460 |     |         bytes32 m2;
  7461 |     |         bytes32 m3;
  7462 |     |         bytes32 m4;
  7463 |     |         bytes32 m5;
  7464 |     |         bytes32 m6;
  7465 |     |         /// @solidity memory-safe-assembly
  7466 |     |         assembly {
  7467 |     |             function writeString(pos, w) {
  7468 |     |                 let length := 0
  7469 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  7470 |     |                 mstore(pos, length)
  7471 |     |                 let shift := sub(256, shl(3, length))
  7472 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  7473 |     |             }
  7474 |     |             m0 := mload(0x00)
  7475 |     |             m1 := mload(0x20)
  7476 |     |             m2 := mload(0x40)
  7477 |     |             m3 := mload(0x60)
  7478 |     |             m4 := mload(0x80)
  7479 |     |             m5 := mload(0xa0)
  7480 |     |             m6 := mload(0xc0)
  7481 |     |             // Selector of `log(bool,string,address,uint256)`.
  7482 |     |             mstore(0x00, 0xa5cada94)
  7483 |     |             mstore(0x20, p0)
  7484 |     |             mstore(0x40, 0x80)
  7485 |     |             mstore(0x60, p2)
  7486 |     |             mstore(0x80, p3)
  7487 |     |             writeString(0xa0, p1)
  7488 |     |         }
  7489 |     |         _sendLogPayload(0x1c, 0xc4);
  7490 |     |         /// @solidity memory-safe-assembly
  7491 |     |         assembly {
  7492 |     |             mstore(0x00, m0)
  7493 |     |             mstore(0x20, m1)
  7494 |     |             mstore(0x40, m2)
  7495 |     |             mstore(0x60, m3)
  7496 |     |             mstore(0x80, m4)
  7497 |     |             mstore(0xa0, m5)
  7498 |     |             mstore(0xc0, m6)
  7499 |     |         }
  7500 |     |     }
  7501 |     | 
  7502 |     |     function log(bool p0, bytes32 p1, address p2, bytes32 p3) internal pure {
  7503 |     |         bytes32 m0;
  7504 |     |         bytes32 m1;
  7505 |     |         bytes32 m2;
  7506 |     |         bytes32 m3;
  7507 |     |         bytes32 m4;
  7508 |     |         bytes32 m5;
  7509 |     |         bytes32 m6;
  7510 |     |         bytes32 m7;
  7511 |     |         bytes32 m8;
  7512 |     |         /// @solidity memory-safe-assembly
  7513 |     |         assembly {
  7514 |     |             function writeString(pos, w) {
  7515 |     |                 let length := 0
  7516 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  7517 |     |                 mstore(pos, length)
  7518 |     |                 let shift := sub(256, shl(3, length))
  7519 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  7520 |     |             }
  7521 |     |             m0 := mload(0x00)
  7522 |     |             m1 := mload(0x20)
  7523 |     |             m2 := mload(0x40)
  7524 |     |             m3 := mload(0x60)
  7525 |     |             m4 := mload(0x80)
  7526 |     |             m5 := mload(0xa0)
  7527 |     |             m6 := mload(0xc0)
  7528 |     |             m7 := mload(0xe0)
  7529 |     |             m8 := mload(0x100)
  7530 |     |             // Selector of `log(bool,string,address,string)`.
  7531 |     |             mstore(0x00, 0x12d6c788)
  7532 |     |             mstore(0x20, p0)
  7533 |     |             mstore(0x40, 0x80)
  7534 |     |             mstore(0x60, p2)
  7535 |     |             mstore(0x80, 0xc0)
  7536 |     |             writeString(0xa0, p1)
  7537 |     |             writeString(0xe0, p3)
  7538 |     |         }
  7539 |     |         _sendLogPayload(0x1c, 0x104);
  7540 |     |         /// @solidity memory-safe-assembly
  7541 |     |         assembly {
  7542 |     |             mstore(0x00, m0)
  7543 |     |             mstore(0x20, m1)
  7544 |     |             mstore(0x40, m2)
  7545 |     |             mstore(0x60, m3)
  7546 |     |             mstore(0x80, m4)
  7547 |     |             mstore(0xa0, m5)
  7548 |     |             mstore(0xc0, m6)
  7549 |     |             mstore(0xe0, m7)
  7550 |     |             mstore(0x100, m8)
  7551 |     |         }
  7552 |     |     }
  7553 |     | 
  7554 |     |     function log(bool p0, bytes32 p1, bool p2, address p3) internal pure {
  7555 |     |         bytes32 m0;
  7556 |     |         bytes32 m1;
  7557 |     |         bytes32 m2;
  7558 |     |         bytes32 m3;
  7559 |     |         bytes32 m4;
  7560 |     |         bytes32 m5;
  7561 |     |         bytes32 m6;
  7562 |     |         /// @solidity memory-safe-assembly
  7563 |     |         assembly {
  7564 |     |             function writeString(pos, w) {
  7565 |     |                 let length := 0
  7566 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  7567 |     |                 mstore(pos, length)
  7568 |     |                 let shift := sub(256, shl(3, length))
  7569 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  7570 |     |             }
  7571 |     |             m0 := mload(0x00)
  7572 |     |             m1 := mload(0x20)
  7573 |     |             m2 := mload(0x40)
  7574 |     |             m3 := mload(0x60)
  7575 |     |             m4 := mload(0x80)
  7576 |     |             m5 := mload(0xa0)
  7577 |     |             m6 := mload(0xc0)
  7578 |     |             // Selector of `log(bool,string,bool,address)`.
  7579 |     |             mstore(0x00, 0x538e06ab)
  7580 |     |             mstore(0x20, p0)
  7581 |     |             mstore(0x40, 0x80)
  7582 |     |             mstore(0x60, p2)
  7583 |     |             mstore(0x80, p3)
  7584 |     |             writeString(0xa0, p1)
  7585 |     |         }
  7586 |     |         _sendLogPayload(0x1c, 0xc4);
  7587 |     |         /// @solidity memory-safe-assembly
  7588 |     |         assembly {
  7589 |     |             mstore(0x00, m0)
  7590 |     |             mstore(0x20, m1)
  7591 |     |             mstore(0x40, m2)
  7592 |     |             mstore(0x60, m3)
  7593 |     |             mstore(0x80, m4)
  7594 |     |             mstore(0xa0, m5)
  7595 |     |             mstore(0xc0, m6)
  7596 |     |         }
  7597 |     |     }
  7598 |     | 
  7599 |     |     function log(bool p0, bytes32 p1, bool p2, bool p3) internal pure {
  7600 |     |         bytes32 m0;
  7601 |     |         bytes32 m1;
  7602 |     |         bytes32 m2;
  7603 |     |         bytes32 m3;
  7604 |     |         bytes32 m4;
  7605 |     |         bytes32 m5;
  7606 |     |         bytes32 m6;
  7607 |     |         /// @solidity memory-safe-assembly
  7608 |     |         assembly {
  7609 |     |             function writeString(pos, w) {
  7610 |     |                 let length := 0
  7611 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  7612 |     |                 mstore(pos, length)
  7613 |     |                 let shift := sub(256, shl(3, length))
  7614 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  7615 |     |             }
  7616 |     |             m0 := mload(0x00)
  7617 |     |             m1 := mload(0x20)
  7618 |     |             m2 := mload(0x40)
  7619 |     |             m3 := mload(0x60)
  7620 |     |             m4 := mload(0x80)
  7621 |     |             m5 := mload(0xa0)
  7622 |     |             m6 := mload(0xc0)
  7623 |     |             // Selector of `log(bool,string,bool,bool)`.
  7624 |     |             mstore(0x00, 0xdc5e935b)
  7625 |     |             mstore(0x20, p0)
  7626 |     |             mstore(0x40, 0x80)
  7627 |     |             mstore(0x60, p2)
  7628 |     |             mstore(0x80, p3)
  7629 |     |             writeString(0xa0, p1)
  7630 |     |         }
  7631 |     |         _sendLogPayload(0x1c, 0xc4);
  7632 |     |         /// @solidity memory-safe-assembly
  7633 |     |         assembly {
  7634 |     |             mstore(0x00, m0)
  7635 |     |             mstore(0x20, m1)
  7636 |     |             mstore(0x40, m2)
  7637 |     |             mstore(0x60, m3)
  7638 |     |             mstore(0x80, m4)
  7639 |     |             mstore(0xa0, m5)
  7640 |     |             mstore(0xc0, m6)
  7641 |     |         }
  7642 |     |     }
  7643 |     | 
  7644 |     |     function log(bool p0, bytes32 p1, bool p2, uint256 p3) internal pure {
  7645 |     |         bytes32 m0;
  7646 |     |         bytes32 m1;
  7647 |     |         bytes32 m2;
  7648 |     |         bytes32 m3;
  7649 |     |         bytes32 m4;
  7650 |     |         bytes32 m5;
  7651 |     |         bytes32 m6;
  7652 |     |         /// @solidity memory-safe-assembly
  7653 |     |         assembly {
  7654 |     |             function writeString(pos, w) {
  7655 |     |                 let length := 0
  7656 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  7657 |     |                 mstore(pos, length)
  7658 |     |                 let shift := sub(256, shl(3, length))
  7659 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  7660 |     |             }
  7661 |     |             m0 := mload(0x00)
  7662 |     |             m1 := mload(0x20)
  7663 |     |             m2 := mload(0x40)
  7664 |     |             m3 := mload(0x60)
  7665 |     |             m4 := mload(0x80)
  7666 |     |             m5 := mload(0xa0)
  7667 |     |             m6 := mload(0xc0)
  7668 |     |             // Selector of `log(bool,string,bool,uint256)`.
  7669 |     |             mstore(0x00, 0x1606a393)
  7670 |     |             mstore(0x20, p0)
  7671 |     |             mstore(0x40, 0x80)
  7672 |     |             mstore(0x60, p2)
  7673 |     |             mstore(0x80, p3)
  7674 |     |             writeString(0xa0, p1)
  7675 |     |         }
  7676 |     |         _sendLogPayload(0x1c, 0xc4);
  7677 |     |         /// @solidity memory-safe-assembly
  7678 |     |         assembly {
  7679 |     |             mstore(0x00, m0)
  7680 |     |             mstore(0x20, m1)
  7681 |     |             mstore(0x40, m2)
  7682 |     |             mstore(0x60, m3)
  7683 |     |             mstore(0x80, m4)
  7684 |     |             mstore(0xa0, m5)
  7685 |     |             mstore(0xc0, m6)
  7686 |     |         }
  7687 |     |     }
  7688 |     | 
  7689 |     |     function log(bool p0, bytes32 p1, bool p2, bytes32 p3) internal pure {
  7690 |     |         bytes32 m0;
  7691 |     |         bytes32 m1;
  7692 |     |         bytes32 m2;
  7693 |     |         bytes32 m3;
  7694 |     |         bytes32 m4;
  7695 |     |         bytes32 m5;
  7696 |     |         bytes32 m6;
  7697 |     |         bytes32 m7;
  7698 |     |         bytes32 m8;
  7699 |     |         /// @solidity memory-safe-assembly
  7700 |     |         assembly {
  7701 |     |             function writeString(pos, w) {
  7702 |     |                 let length := 0
  7703 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  7704 |     |                 mstore(pos, length)
  7705 |     |                 let shift := sub(256, shl(3, length))
  7706 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  7707 |     |             }
  7708 |     |             m0 := mload(0x00)
  7709 |     |             m1 := mload(0x20)
  7710 |     |             m2 := mload(0x40)
  7711 |     |             m3 := mload(0x60)
  7712 |     |             m4 := mload(0x80)
  7713 |     |             m5 := mload(0xa0)
  7714 |     |             m6 := mload(0xc0)
  7715 |     |             m7 := mload(0xe0)
  7716 |     |             m8 := mload(0x100)
  7717 |     |             // Selector of `log(bool,string,bool,string)`.
  7718 |     |             mstore(0x00, 0x483d0416)
  7719 |     |             mstore(0x20, p0)
  7720 |     |             mstore(0x40, 0x80)
  7721 |     |             mstore(0x60, p2)
  7722 |     |             mstore(0x80, 0xc0)
  7723 |     |             writeString(0xa0, p1)
  7724 |     |             writeString(0xe0, p3)
  7725 |     |         }
  7726 |     |         _sendLogPayload(0x1c, 0x104);
  7727 |     |         /// @solidity memory-safe-assembly
  7728 |     |         assembly {
  7729 |     |             mstore(0x00, m0)
  7730 |     |             mstore(0x20, m1)
  7731 |     |             mstore(0x40, m2)
  7732 |     |             mstore(0x60, m3)
  7733 |     |             mstore(0x80, m4)
  7734 |     |             mstore(0xa0, m5)
  7735 |     |             mstore(0xc0, m6)
  7736 |     |             mstore(0xe0, m7)
  7737 |     |             mstore(0x100, m8)
  7738 |     |         }
  7739 |     |     }
  7740 |     | 
  7741 |     |     function log(bool p0, bytes32 p1, uint256 p2, address p3) internal pure {
  7742 |     |         bytes32 m0;
  7743 |     |         bytes32 m1;
  7744 |     |         bytes32 m2;
  7745 |     |         bytes32 m3;
  7746 |     |         bytes32 m4;
  7747 |     |         bytes32 m5;
  7748 |     |         bytes32 m6;
  7749 |     |         /// @solidity memory-safe-assembly
  7750 |     |         assembly {
  7751 |     |             function writeString(pos, w) {
  7752 |     |                 let length := 0
  7753 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  7754 |     |                 mstore(pos, length)
  7755 |     |                 let shift := sub(256, shl(3, length))
  7756 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  7757 |     |             }
  7758 |     |             m0 := mload(0x00)
  7759 |     |             m1 := mload(0x20)
  7760 |     |             m2 := mload(0x40)
  7761 |     |             m3 := mload(0x60)
  7762 |     |             m4 := mload(0x80)
  7763 |     |             m5 := mload(0xa0)
  7764 |     |             m6 := mload(0xc0)
  7765 |     |             // Selector of `log(bool,string,uint256,address)`.
  7766 |     |             mstore(0x00, 0x1596a1ce)
  7767 |     |             mstore(0x20, p0)
  7768 |     |             mstore(0x40, 0x80)
  7769 |     |             mstore(0x60, p2)
  7770 |     |             mstore(0x80, p3)
  7771 |     |             writeString(0xa0, p1)
  7772 |     |         }
  7773 |     |         _sendLogPayload(0x1c, 0xc4);
  7774 |     |         /// @solidity memory-safe-assembly
  7775 |     |         assembly {
  7776 |     |             mstore(0x00, m0)
  7777 |     |             mstore(0x20, m1)
  7778 |     |             mstore(0x40, m2)
  7779 |     |             mstore(0x60, m3)
  7780 |     |             mstore(0x80, m4)
  7781 |     |             mstore(0xa0, m5)
  7782 |     |             mstore(0xc0, m6)
  7783 |     |         }
  7784 |     |     }
  7785 |     | 
  7786 |     |     function log(bool p0, bytes32 p1, uint256 p2, bool p3) internal pure {
  7787 |     |         bytes32 m0;
  7788 |     |         bytes32 m1;
  7789 |     |         bytes32 m2;
  7790 |     |         bytes32 m3;
  7791 |     |         bytes32 m4;
  7792 |     |         bytes32 m5;
  7793 |     |         bytes32 m6;
  7794 |     |         /// @solidity memory-safe-assembly
  7795 |     |         assembly {
  7796 |     |             function writeString(pos, w) {
  7797 |     |                 let length := 0
  7798 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  7799 |     |                 mstore(pos, length)
  7800 |     |                 let shift := sub(256, shl(3, length))
  7801 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  7802 |     |             }
  7803 |     |             m0 := mload(0x00)
  7804 |     |             m1 := mload(0x20)
  7805 |     |             m2 := mload(0x40)
  7806 |     |             m3 := mload(0x60)
  7807 |     |             m4 := mload(0x80)
  7808 |     |             m5 := mload(0xa0)
  7809 |     |             m6 := mload(0xc0)
  7810 |     |             // Selector of `log(bool,string,uint256,bool)`.
  7811 |     |             mstore(0x00, 0x6b0e5d53)
  7812 |     |             mstore(0x20, p0)
  7813 |     |             mstore(0x40, 0x80)
  7814 |     |             mstore(0x60, p2)
  7815 |     |             mstore(0x80, p3)
  7816 |     |             writeString(0xa0, p1)
  7817 |     |         }
  7818 |     |         _sendLogPayload(0x1c, 0xc4);
  7819 |     |         /// @solidity memory-safe-assembly
  7820 |     |         assembly {
  7821 |     |             mstore(0x00, m0)
  7822 |     |             mstore(0x20, m1)
  7823 |     |             mstore(0x40, m2)
  7824 |     |             mstore(0x60, m3)
  7825 |     |             mstore(0x80, m4)
  7826 |     |             mstore(0xa0, m5)
  7827 |     |             mstore(0xc0, m6)
  7828 |     |         }
  7829 |     |     }
  7830 |     | 
  7831 |     |     function log(bool p0, bytes32 p1, uint256 p2, uint256 p3) internal pure {
  7832 |     |         bytes32 m0;
  7833 |     |         bytes32 m1;
  7834 |     |         bytes32 m2;
  7835 |     |         bytes32 m3;
  7836 |     |         bytes32 m4;
  7837 |     |         bytes32 m5;
  7838 |     |         bytes32 m6;
  7839 |     |         /// @solidity memory-safe-assembly
  7840 |     |         assembly {
  7841 |     |             function writeString(pos, w) {
  7842 |     |                 let length := 0
  7843 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  7844 |     |                 mstore(pos, length)
  7845 |     |                 let shift := sub(256, shl(3, length))
  7846 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  7847 |     |             }
  7848 |     |             m0 := mload(0x00)
  7849 |     |             m1 := mload(0x20)
  7850 |     |             m2 := mload(0x40)
  7851 |     |             m3 := mload(0x60)
  7852 |     |             m4 := mload(0x80)
  7853 |     |             m5 := mload(0xa0)
  7854 |     |             m6 := mload(0xc0)
  7855 |     |             // Selector of `log(bool,string,uint256,uint256)`.
  7856 |     |             mstore(0x00, 0x28863fcb)
  7857 |     |             mstore(0x20, p0)
  7858 |     |             mstore(0x40, 0x80)
  7859 |     |             mstore(0x60, p2)
  7860 |     |             mstore(0x80, p3)
  7861 |     |             writeString(0xa0, p1)
  7862 |     |         }
  7863 |     |         _sendLogPayload(0x1c, 0xc4);
  7864 |     |         /// @solidity memory-safe-assembly
  7865 |     |         assembly {
  7866 |     |             mstore(0x00, m0)
  7867 |     |             mstore(0x20, m1)
  7868 |     |             mstore(0x40, m2)
  7869 |     |             mstore(0x60, m3)
  7870 |     |             mstore(0x80, m4)
  7871 |     |             mstore(0xa0, m5)
  7872 |     |             mstore(0xc0, m6)
  7873 |     |         }
  7874 |     |     }
  7875 |     | 
  7876 |     |     function log(bool p0, bytes32 p1, uint256 p2, bytes32 p3) internal pure {
  7877 |     |         bytes32 m0;
  7878 |     |         bytes32 m1;
  7879 |     |         bytes32 m2;
  7880 |     |         bytes32 m3;
  7881 |     |         bytes32 m4;
  7882 |     |         bytes32 m5;
  7883 |     |         bytes32 m6;
  7884 |     |         bytes32 m7;
  7885 |     |         bytes32 m8;
  7886 |     |         /// @solidity memory-safe-assembly
  7887 |     |         assembly {
  7888 |     |             function writeString(pos, w) {
  7889 |     |                 let length := 0
  7890 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  7891 |     |                 mstore(pos, length)
  7892 |     |                 let shift := sub(256, shl(3, length))
  7893 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  7894 |     |             }
  7895 |     |             m0 := mload(0x00)
  7896 |     |             m1 := mload(0x20)
  7897 |     |             m2 := mload(0x40)
  7898 |     |             m3 := mload(0x60)
  7899 |     |             m4 := mload(0x80)
  7900 |     |             m5 := mload(0xa0)
  7901 |     |             m6 := mload(0xc0)
  7902 |     |             m7 := mload(0xe0)
  7903 |     |             m8 := mload(0x100)
  7904 |     |             // Selector of `log(bool,string,uint256,string)`.
  7905 |     |             mstore(0x00, 0x1ad96de6)
  7906 |     |             mstore(0x20, p0)
  7907 |     |             mstore(0x40, 0x80)
  7908 |     |             mstore(0x60, p2)
  7909 |     |             mstore(0x80, 0xc0)
  7910 |     |             writeString(0xa0, p1)
  7911 |     |             writeString(0xe0, p3)
  7912 |     |         }
  7913 |     |         _sendLogPayload(0x1c, 0x104);
  7914 |     |         /// @solidity memory-safe-assembly
  7915 |     |         assembly {
  7916 |     |             mstore(0x00, m0)
  7917 |     |             mstore(0x20, m1)
  7918 |     |             mstore(0x40, m2)
  7919 |     |             mstore(0x60, m3)
  7920 |     |             mstore(0x80, m4)
  7921 |     |             mstore(0xa0, m5)
  7922 |     |             mstore(0xc0, m6)
  7923 |     |             mstore(0xe0, m7)
  7924 |     |             mstore(0x100, m8)
  7925 |     |         }
  7926 |     |     }
  7927 |     | 
  7928 |     |     function log(bool p0, bytes32 p1, bytes32 p2, address p3) internal pure {
  7929 |     |         bytes32 m0;
  7930 |     |         bytes32 m1;
  7931 |     |         bytes32 m2;
  7932 |     |         bytes32 m3;
  7933 |     |         bytes32 m4;
  7934 |     |         bytes32 m5;
  7935 |     |         bytes32 m6;
  7936 |     |         bytes32 m7;
  7937 |     |         bytes32 m8;
  7938 |     |         /// @solidity memory-safe-assembly
  7939 |     |         assembly {
  7940 |     |             function writeString(pos, w) {
  7941 |     |                 let length := 0
  7942 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  7943 |     |                 mstore(pos, length)
  7944 |     |                 let shift := sub(256, shl(3, length))
  7945 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  7946 |     |             }
  7947 |     |             m0 := mload(0x00)
  7948 |     |             m1 := mload(0x20)
  7949 |     |             m2 := mload(0x40)
  7950 |     |             m3 := mload(0x60)
  7951 |     |             m4 := mload(0x80)
  7952 |     |             m5 := mload(0xa0)
  7953 |     |             m6 := mload(0xc0)
  7954 |     |             m7 := mload(0xe0)
  7955 |     |             m8 := mload(0x100)
  7956 |     |             // Selector of `log(bool,string,string,address)`.
  7957 |     |             mstore(0x00, 0x97d394d8)
  7958 |     |             mstore(0x20, p0)
  7959 |     |             mstore(0x40, 0x80)
  7960 |     |             mstore(0x60, 0xc0)
  7961 |     |             mstore(0x80, p3)
  7962 |     |             writeString(0xa0, p1)
  7963 |     |             writeString(0xe0, p2)
  7964 |     |         }
  7965 |     |         _sendLogPayload(0x1c, 0x104);
  7966 |     |         /// @solidity memory-safe-assembly
  7967 |     |         assembly {
  7968 |     |             mstore(0x00, m0)
  7969 |     |             mstore(0x20, m1)
  7970 |     |             mstore(0x40, m2)
  7971 |     |             mstore(0x60, m3)
  7972 |     |             mstore(0x80, m4)
  7973 |     |             mstore(0xa0, m5)
  7974 |     |             mstore(0xc0, m6)
  7975 |     |             mstore(0xe0, m7)
  7976 |     |             mstore(0x100, m8)
  7977 |     |         }
  7978 |     |     }
  7979 |     | 
  7980 |     |     function log(bool p0, bytes32 p1, bytes32 p2, bool p3) internal pure {
  7981 |     |         bytes32 m0;
  7982 |     |         bytes32 m1;
  7983 |     |         bytes32 m2;
  7984 |     |         bytes32 m3;
  7985 |     |         bytes32 m4;
  7986 |     |         bytes32 m5;
  7987 |     |         bytes32 m6;
  7988 |     |         bytes32 m7;
  7989 |     |         bytes32 m8;
  7990 |     |         /// @solidity memory-safe-assembly
  7991 |     |         assembly {
  7992 |     |             function writeString(pos, w) {
  7993 |     |                 let length := 0
  7994 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  7995 |     |                 mstore(pos, length)
  7996 |     |                 let shift := sub(256, shl(3, length))
  7997 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  7998 |     |             }
  7999 |     |             m0 := mload(0x00)
  8000 |     |             m1 := mload(0x20)
  8001 |     |             m2 := mload(0x40)
  8002 |     |             m3 := mload(0x60)
  8003 |     |             m4 := mload(0x80)
  8004 |     |             m5 := mload(0xa0)
  8005 |     |             m6 := mload(0xc0)
  8006 |     |             m7 := mload(0xe0)
  8007 |     |             m8 := mload(0x100)
  8008 |     |             // Selector of `log(bool,string,string,bool)`.
  8009 |     |             mstore(0x00, 0x1e4b87e5)
  8010 |     |             mstore(0x20, p0)
  8011 |     |             mstore(0x40, 0x80)
  8012 |     |             mstore(0x60, 0xc0)
  8013 |     |             mstore(0x80, p3)
  8014 |     |             writeString(0xa0, p1)
  8015 |     |             writeString(0xe0, p2)
  8016 |     |         }
  8017 |     |         _sendLogPayload(0x1c, 0x104);
  8018 |     |         /// @solidity memory-safe-assembly
  8019 |     |         assembly {
  8020 |     |             mstore(0x00, m0)
  8021 |     |             mstore(0x20, m1)
  8022 |     |             mstore(0x40, m2)
  8023 |     |             mstore(0x60, m3)
  8024 |     |             mstore(0x80, m4)
  8025 |     |             mstore(0xa0, m5)
  8026 |     |             mstore(0xc0, m6)
  8027 |     |             mstore(0xe0, m7)
  8028 |     |             mstore(0x100, m8)
  8029 |     |         }
  8030 |     |     }
  8031 |     | 
  8032 |     |     function log(bool p0, bytes32 p1, bytes32 p2, uint256 p3) internal pure {
  8033 |     |         bytes32 m0;
  8034 |     |         bytes32 m1;
  8035 |     |         bytes32 m2;
  8036 |     |         bytes32 m3;
  8037 |     |         bytes32 m4;
  8038 |     |         bytes32 m5;
  8039 |     |         bytes32 m6;
  8040 |     |         bytes32 m7;
  8041 |     |         bytes32 m8;
  8042 |     |         /// @solidity memory-safe-assembly
  8043 |     |         assembly {
  8044 |     |             function writeString(pos, w) {
  8045 |     |                 let length := 0
  8046 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  8047 |     |                 mstore(pos, length)
  8048 |     |                 let shift := sub(256, shl(3, length))
  8049 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  8050 |     |             }
  8051 |     |             m0 := mload(0x00)
  8052 |     |             m1 := mload(0x20)
  8053 |     |             m2 := mload(0x40)
  8054 |     |             m3 := mload(0x60)
  8055 |     |             m4 := mload(0x80)
  8056 |     |             m5 := mload(0xa0)
  8057 |     |             m6 := mload(0xc0)
  8058 |     |             m7 := mload(0xe0)
  8059 |     |             m8 := mload(0x100)
  8060 |     |             // Selector of `log(bool,string,string,uint256)`.
  8061 |     |             mstore(0x00, 0x7be0c3eb)
  8062 |     |             mstore(0x20, p0)
  8063 |     |             mstore(0x40, 0x80)
  8064 |     |             mstore(0x60, 0xc0)
  8065 |     |             mstore(0x80, p3)
  8066 |     |             writeString(0xa0, p1)
  8067 |     |             writeString(0xe0, p2)
  8068 |     |         }
  8069 |     |         _sendLogPayload(0x1c, 0x104);
  8070 |     |         /// @solidity memory-safe-assembly
  8071 |     |         assembly {
  8072 |     |             mstore(0x00, m0)
  8073 |     |             mstore(0x20, m1)
  8074 |     |             mstore(0x40, m2)
  8075 |     |             mstore(0x60, m3)
  8076 |     |             mstore(0x80, m4)
  8077 |     |             mstore(0xa0, m5)
  8078 |     |             mstore(0xc0, m6)
  8079 |     |             mstore(0xe0, m7)
  8080 |     |             mstore(0x100, m8)
  8081 |     |         }
  8082 |     |     }
  8083 |     | 
  8084 |     |     function log(bool p0, bytes32 p1, bytes32 p2, bytes32 p3) internal pure {
  8085 |     |         bytes32 m0;
  8086 |     |         bytes32 m1;
  8087 |     |         bytes32 m2;
  8088 |     |         bytes32 m3;
  8089 |     |         bytes32 m4;
  8090 |     |         bytes32 m5;
  8091 |     |         bytes32 m6;
  8092 |     |         bytes32 m7;
  8093 |     |         bytes32 m8;
  8094 |     |         bytes32 m9;
  8095 |     |         bytes32 m10;
  8096 |     |         /// @solidity memory-safe-assembly
  8097 |     |         assembly {
  8098 |     |             function writeString(pos, w) {
  8099 |     |                 let length := 0
  8100 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  8101 |     |                 mstore(pos, length)
  8102 |     |                 let shift := sub(256, shl(3, length))
  8103 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  8104 |     |             }
  8105 |     |             m0 := mload(0x00)
  8106 |     |             m1 := mload(0x20)
  8107 |     |             m2 := mload(0x40)
  8108 |     |             m3 := mload(0x60)
  8109 |     |             m4 := mload(0x80)
  8110 |     |             m5 := mload(0xa0)
  8111 |     |             m6 := mload(0xc0)
  8112 |     |             m7 := mload(0xe0)
  8113 |     |             m8 := mload(0x100)
  8114 |     |             m9 := mload(0x120)
  8115 |     |             m10 := mload(0x140)
  8116 |     |             // Selector of `log(bool,string,string,string)`.
  8117 |     |             mstore(0x00, 0x1762e32a)
  8118 |     |             mstore(0x20, p0)
  8119 |     |             mstore(0x40, 0x80)
  8120 |     |             mstore(0x60, 0xc0)
  8121 |     |             mstore(0x80, 0x100)
  8122 |     |             writeString(0xa0, p1)
  8123 |     |             writeString(0xe0, p2)
  8124 |     |             writeString(0x120, p3)
  8125 |     |         }
  8126 |     |         _sendLogPayload(0x1c, 0x144);
  8127 |     |         /// @solidity memory-safe-assembly
  8128 |     |         assembly {
  8129 |     |             mstore(0x00, m0)
  8130 |     |             mstore(0x20, m1)
  8131 |     |             mstore(0x40, m2)
  8132 |     |             mstore(0x60, m3)
  8133 |     |             mstore(0x80, m4)
  8134 |     |             mstore(0xa0, m5)
  8135 |     |             mstore(0xc0, m6)
  8136 |     |             mstore(0xe0, m7)
  8137 |     |             mstore(0x100, m8)
  8138 |     |             mstore(0x120, m9)
  8139 |     |             mstore(0x140, m10)
  8140 |     |         }
  8141 |     |     }
  8142 |     | 
  8143 |     |     function log(uint256 p0, address p1, address p2, address p3) internal pure {
  8144 |     |         bytes32 m0;
  8145 |     |         bytes32 m1;
  8146 |     |         bytes32 m2;
  8147 |     |         bytes32 m3;
  8148 |     |         bytes32 m4;
  8149 |     |         /// @solidity memory-safe-assembly
  8150 |     |         assembly {
  8151 |     |             m0 := mload(0x00)
  8152 |     |             m1 := mload(0x20)
  8153 |     |             m2 := mload(0x40)
  8154 |     |             m3 := mload(0x60)
  8155 |     |             m4 := mload(0x80)
  8156 |     |             // Selector of `log(uint256,address,address,address)`.
  8157 |     |             mstore(0x00, 0x2488b414)
  8158 |     |             mstore(0x20, p0)
  8159 |     |             mstore(0x40, p1)
  8160 |     |             mstore(0x60, p2)
  8161 |     |             mstore(0x80, p3)
  8162 |     |         }
  8163 |     |         _sendLogPayload(0x1c, 0x84);
  8164 |     |         /// @solidity memory-safe-assembly
  8165 |     |         assembly {
  8166 |     |             mstore(0x00, m0)
  8167 |     |             mstore(0x20, m1)
  8168 |     |             mstore(0x40, m2)
  8169 |     |             mstore(0x60, m3)
  8170 |     |             mstore(0x80, m4)
  8171 |     |         }
  8172 |     |     }
  8173 |     | 
  8174 |     |     function log(uint256 p0, address p1, address p2, bool p3) internal pure {
  8175 |     |         bytes32 m0;
  8176 |     |         bytes32 m1;
  8177 |     |         bytes32 m2;
  8178 |     |         bytes32 m3;
  8179 |     |         bytes32 m4;
  8180 |     |         /// @solidity memory-safe-assembly
  8181 |     |         assembly {
  8182 |     |             m0 := mload(0x00)
  8183 |     |             m1 := mload(0x20)
  8184 |     |             m2 := mload(0x40)
  8185 |     |             m3 := mload(0x60)
  8186 |     |             m4 := mload(0x80)
  8187 |     |             // Selector of `log(uint256,address,address,bool)`.
  8188 |     |             mstore(0x00, 0x091ffaf5)
  8189 |     |             mstore(0x20, p0)
  8190 |     |             mstore(0x40, p1)
  8191 |     |             mstore(0x60, p2)
  8192 |     |             mstore(0x80, p3)
  8193 |     |         }
  8194 |     |         _sendLogPayload(0x1c, 0x84);
  8195 |     |         /// @solidity memory-safe-assembly
  8196 |     |         assembly {
  8197 |     |             mstore(0x00, m0)
  8198 |     |             mstore(0x20, m1)
  8199 |     |             mstore(0x40, m2)
  8200 |     |             mstore(0x60, m3)
  8201 |     |             mstore(0x80, m4)
  8202 |     |         }
  8203 |     |     }
  8204 |     | 
  8205 |     |     function log(uint256 p0, address p1, address p2, uint256 p3) internal pure {
  8206 |     |         bytes32 m0;
  8207 |     |         bytes32 m1;
  8208 |     |         bytes32 m2;
  8209 |     |         bytes32 m3;
  8210 |     |         bytes32 m4;
  8211 |     |         /// @solidity memory-safe-assembly
  8212 |     |         assembly {
  8213 |     |             m0 := mload(0x00)
  8214 |     |             m1 := mload(0x20)
  8215 |     |             m2 := mload(0x40)
  8216 |     |             m3 := mload(0x60)
  8217 |     |             m4 := mload(0x80)
  8218 |     |             // Selector of `log(uint256,address,address,uint256)`.
  8219 |     |             mstore(0x00, 0x736efbb6)
  8220 |     |             mstore(0x20, p0)
  8221 |     |             mstore(0x40, p1)
  8222 |     |             mstore(0x60, p2)
  8223 |     |             mstore(0x80, p3)
  8224 |     |         }
  8225 |     |         _sendLogPayload(0x1c, 0x84);
  8226 |     |         /// @solidity memory-safe-assembly
  8227 |     |         assembly {
  8228 |     |             mstore(0x00, m0)
  8229 |     |             mstore(0x20, m1)
  8230 |     |             mstore(0x40, m2)
  8231 |     |             mstore(0x60, m3)
  8232 |     |             mstore(0x80, m4)
  8233 |     |         }
  8234 |     |     }
  8235 |     | 
  8236 |     |     function log(uint256 p0, address p1, address p2, bytes32 p3) internal pure {
  8237 |     |         bytes32 m0;
  8238 |     |         bytes32 m1;
  8239 |     |         bytes32 m2;
  8240 |     |         bytes32 m3;
  8241 |     |         bytes32 m4;
  8242 |     |         bytes32 m5;
  8243 |     |         bytes32 m6;
  8244 |     |         /// @solidity memory-safe-assembly
  8245 |     |         assembly {
  8246 |     |             function writeString(pos, w) {
  8247 |     |                 let length := 0
  8248 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  8249 |     |                 mstore(pos, length)
  8250 |     |                 let shift := sub(256, shl(3, length))
  8251 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  8252 |     |             }
  8253 |     |             m0 := mload(0x00)
  8254 |     |             m1 := mload(0x20)
  8255 |     |             m2 := mload(0x40)
  8256 |     |             m3 := mload(0x60)
  8257 |     |             m4 := mload(0x80)
  8258 |     |             m5 := mload(0xa0)
  8259 |     |             m6 := mload(0xc0)
  8260 |     |             // Selector of `log(uint256,address,address,string)`.
  8261 |     |             mstore(0x00, 0x031c6f73)
  8262 |     |             mstore(0x20, p0)
  8263 |     |             mstore(0x40, p1)
  8264 |     |             mstore(0x60, p2)
  8265 |     |             mstore(0x80, 0x80)
  8266 |     |             writeString(0xa0, p3)
  8267 |     |         }
  8268 |     |         _sendLogPayload(0x1c, 0xc4);
  8269 |     |         /// @solidity memory-safe-assembly
  8270 |     |         assembly {
  8271 |     |             mstore(0x00, m0)
  8272 |     |             mstore(0x20, m1)
  8273 |     |             mstore(0x40, m2)
  8274 |     |             mstore(0x60, m3)
  8275 |     |             mstore(0x80, m4)
  8276 |     |             mstore(0xa0, m5)
  8277 |     |             mstore(0xc0, m6)
  8278 |     |         }
  8279 |     |     }
  8280 |     | 
  8281 |     |     function log(uint256 p0, address p1, bool p2, address p3) internal pure {
  8282 |     |         bytes32 m0;
  8283 |     |         bytes32 m1;
  8284 |     |         bytes32 m2;
  8285 |     |         bytes32 m3;
  8286 |     |         bytes32 m4;
  8287 |     |         /// @solidity memory-safe-assembly
  8288 |     |         assembly {
  8289 |     |             m0 := mload(0x00)
  8290 |     |             m1 := mload(0x20)
  8291 |     |             m2 := mload(0x40)
  8292 |     |             m3 := mload(0x60)
  8293 |     |             m4 := mload(0x80)
  8294 |     |             // Selector of `log(uint256,address,bool,address)`.
  8295 |     |             mstore(0x00, 0xef72c513)
  8296 |     |             mstore(0x20, p0)
  8297 |     |             mstore(0x40, p1)
  8298 |     |             mstore(0x60, p2)
  8299 |     |             mstore(0x80, p3)
  8300 |     |         }
  8301 |     |         _sendLogPayload(0x1c, 0x84);
  8302 |     |         /// @solidity memory-safe-assembly
  8303 |     |         assembly {
  8304 |     |             mstore(0x00, m0)
  8305 |     |             mstore(0x20, m1)
  8306 |     |             mstore(0x40, m2)
  8307 |     |             mstore(0x60, m3)
  8308 |     |             mstore(0x80, m4)
  8309 |     |         }
  8310 |     |     }
  8311 |     | 
  8312 |     |     function log(uint256 p0, address p1, bool p2, bool p3) internal pure {
  8313 |     |         bytes32 m0;
  8314 |     |         bytes32 m1;
  8315 |     |         bytes32 m2;
  8316 |     |         bytes32 m3;
  8317 |     |         bytes32 m4;
  8318 |     |         /// @solidity memory-safe-assembly
  8319 |     |         assembly {
  8320 |     |             m0 := mload(0x00)
  8321 |     |             m1 := mload(0x20)
  8322 |     |             m2 := mload(0x40)
  8323 |     |             m3 := mload(0x60)
  8324 |     |             m4 := mload(0x80)
  8325 |     |             // Selector of `log(uint256,address,bool,bool)`.
  8326 |     |             mstore(0x00, 0xe351140f)
  8327 |     |             mstore(0x20, p0)
  8328 |     |             mstore(0x40, p1)
  8329 |     |             mstore(0x60, p2)
  8330 |     |             mstore(0x80, p3)
  8331 |     |         }
  8332 |     |         _sendLogPayload(0x1c, 0x84);
  8333 |     |         /// @solidity memory-safe-assembly
  8334 |     |         assembly {
  8335 |     |             mstore(0x00, m0)
  8336 |     |             mstore(0x20, m1)
  8337 |     |             mstore(0x40, m2)
  8338 |     |             mstore(0x60, m3)
  8339 |     |             mstore(0x80, m4)
  8340 |     |         }
  8341 |     |     }
  8342 |     | 
  8343 |     |     function log(uint256 p0, address p1, bool p2, uint256 p3) internal pure {
  8344 |     |         bytes32 m0;
  8345 |     |         bytes32 m1;
  8346 |     |         bytes32 m2;
  8347 |     |         bytes32 m3;
  8348 |     |         bytes32 m4;
  8349 |     |         /// @solidity memory-safe-assembly
  8350 |     |         assembly {
  8351 |     |             m0 := mload(0x00)
  8352 |     |             m1 := mload(0x20)
  8353 |     |             m2 := mload(0x40)
  8354 |     |             m3 := mload(0x60)
  8355 |     |             m4 := mload(0x80)
  8356 |     |             // Selector of `log(uint256,address,bool,uint256)`.
  8357 |     |             mstore(0x00, 0x5abd992a)
  8358 |     |             mstore(0x20, p0)
  8359 |     |             mstore(0x40, p1)
  8360 |     |             mstore(0x60, p2)
  8361 |     |             mstore(0x80, p3)
  8362 |     |         }
  8363 |     |         _sendLogPayload(0x1c, 0x84);
  8364 |     |         /// @solidity memory-safe-assembly
  8365 |     |         assembly {
  8366 |     |             mstore(0x00, m0)
  8367 |     |             mstore(0x20, m1)
  8368 |     |             mstore(0x40, m2)
  8369 |     |             mstore(0x60, m3)
  8370 |     |             mstore(0x80, m4)
  8371 |     |         }
  8372 |     |     }
  8373 |     | 
  8374 |     |     function log(uint256 p0, address p1, bool p2, bytes32 p3) internal pure {
  8375 |     |         bytes32 m0;
  8376 |     |         bytes32 m1;
  8377 |     |         bytes32 m2;
  8378 |     |         bytes32 m3;
  8379 |     |         bytes32 m4;
  8380 |     |         bytes32 m5;
  8381 |     |         bytes32 m6;
  8382 |     |         /// @solidity memory-safe-assembly
  8383 |     |         assembly {
  8384 |     |             function writeString(pos, w) {
  8385 |     |                 let length := 0
  8386 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  8387 |     |                 mstore(pos, length)
  8388 |     |                 let shift := sub(256, shl(3, length))
  8389 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  8390 |     |             }
  8391 |     |             m0 := mload(0x00)
  8392 |     |             m1 := mload(0x20)
  8393 |     |             m2 := mload(0x40)
  8394 |     |             m3 := mload(0x60)
  8395 |     |             m4 := mload(0x80)
  8396 |     |             m5 := mload(0xa0)
  8397 |     |             m6 := mload(0xc0)
  8398 |     |             // Selector of `log(uint256,address,bool,string)`.
  8399 |     |             mstore(0x00, 0x90fb06aa)
  8400 |     |             mstore(0x20, p0)
  8401 |     |             mstore(0x40, p1)
  8402 |     |             mstore(0x60, p2)
  8403 |     |             mstore(0x80, 0x80)
  8404 |     |             writeString(0xa0, p3)
  8405 |     |         }
  8406 |     |         _sendLogPayload(0x1c, 0xc4);
  8407 |     |         /// @solidity memory-safe-assembly
  8408 |     |         assembly {
  8409 |     |             mstore(0x00, m0)
  8410 |     |             mstore(0x20, m1)
  8411 |     |             mstore(0x40, m2)
  8412 |     |             mstore(0x60, m3)
  8413 |     |             mstore(0x80, m4)
  8414 |     |             mstore(0xa0, m5)
  8415 |     |             mstore(0xc0, m6)
  8416 |     |         }
  8417 |     |     }
  8418 |     | 
  8419 |     |     function log(uint256 p0, address p1, uint256 p2, address p3) internal pure {
  8420 |     |         bytes32 m0;
  8421 |     |         bytes32 m1;
  8422 |     |         bytes32 m2;
  8423 |     |         bytes32 m3;
  8424 |     |         bytes32 m4;
  8425 |     |         /// @solidity memory-safe-assembly
  8426 |     |         assembly {
  8427 |     |             m0 := mload(0x00)
  8428 |     |             m1 := mload(0x20)
  8429 |     |             m2 := mload(0x40)
  8430 |     |             m3 := mload(0x60)
  8431 |     |             m4 := mload(0x80)
  8432 |     |             // Selector of `log(uint256,address,uint256,address)`.
  8433 |     |             mstore(0x00, 0x15c127b5)
  8434 |     |             mstore(0x20, p0)
  8435 |     |             mstore(0x40, p1)
  8436 |     |             mstore(0x60, p2)
  8437 |     |             mstore(0x80, p3)
  8438 |     |         }
  8439 |     |         _sendLogPayload(0x1c, 0x84);
  8440 |     |         /// @solidity memory-safe-assembly
  8441 |     |         assembly {
  8442 |     |             mstore(0x00, m0)
  8443 |     |             mstore(0x20, m1)
  8444 |     |             mstore(0x40, m2)
  8445 |     |             mstore(0x60, m3)
  8446 |     |             mstore(0x80, m4)
  8447 |     |         }
  8448 |     |     }
  8449 |     | 
  8450 |     |     function log(uint256 p0, address p1, uint256 p2, bool p3) internal pure {
  8451 |     |         bytes32 m0;
  8452 |     |         bytes32 m1;
  8453 |     |         bytes32 m2;
  8454 |     |         bytes32 m3;
  8455 |     |         bytes32 m4;
  8456 |     |         /// @solidity memory-safe-assembly
  8457 |     |         assembly {
  8458 |     |             m0 := mload(0x00)
  8459 |     |             m1 := mload(0x20)
  8460 |     |             m2 := mload(0x40)
  8461 |     |             m3 := mload(0x60)
  8462 |     |             m4 := mload(0x80)
  8463 |     |             // Selector of `log(uint256,address,uint256,bool)`.
  8464 |     |             mstore(0x00, 0x5f743a7c)
  8465 |     |             mstore(0x20, p0)
  8466 |     |             mstore(0x40, p1)
  8467 |     |             mstore(0x60, p2)
  8468 |     |             mstore(0x80, p3)
  8469 |     |         }
  8470 |     |         _sendLogPayload(0x1c, 0x84);
  8471 |     |         /// @solidity memory-safe-assembly
  8472 |     |         assembly {
  8473 |     |             mstore(0x00, m0)
  8474 |     |             mstore(0x20, m1)
  8475 |     |             mstore(0x40, m2)
  8476 |     |             mstore(0x60, m3)
  8477 |     |             mstore(0x80, m4)
  8478 |     |         }
  8479 |     |     }
  8480 |     | 
  8481 |     |     function log(uint256 p0, address p1, uint256 p2, uint256 p3) internal pure {
  8482 |     |         bytes32 m0;
  8483 |     |         bytes32 m1;
  8484 |     |         bytes32 m2;
  8485 |     |         bytes32 m3;
  8486 |     |         bytes32 m4;
  8487 |     |         /// @solidity memory-safe-assembly
  8488 |     |         assembly {
  8489 |     |             m0 := mload(0x00)
  8490 |     |             m1 := mload(0x20)
  8491 |     |             m2 := mload(0x40)
  8492 |     |             m3 := mload(0x60)
  8493 |     |             m4 := mload(0x80)
  8494 |     |             // Selector of `log(uint256,address,uint256,uint256)`.
  8495 |     |             mstore(0x00, 0x0c9cd9c1)
  8496 |     |             mstore(0x20, p0)
  8497 |     |             mstore(0x40, p1)
  8498 |     |             mstore(0x60, p2)
  8499 |     |             mstore(0x80, p3)
  8500 |     |         }
  8501 |     |         _sendLogPayload(0x1c, 0x84);
  8502 |     |         /// @solidity memory-safe-assembly
  8503 |     |         assembly {
  8504 |     |             mstore(0x00, m0)
  8505 |     |             mstore(0x20, m1)
  8506 |     |             mstore(0x40, m2)
  8507 |     |             mstore(0x60, m3)
  8508 |     |             mstore(0x80, m4)
  8509 |     |         }
  8510 |     |     }
  8511 |     | 
  8512 |     |     function log(uint256 p0, address p1, uint256 p2, bytes32 p3) internal pure {
  8513 |     |         bytes32 m0;
  8514 |     |         bytes32 m1;
  8515 |     |         bytes32 m2;
  8516 |     |         bytes32 m3;
  8517 |     |         bytes32 m4;
  8518 |     |         bytes32 m5;
  8519 |     |         bytes32 m6;
  8520 |     |         /// @solidity memory-safe-assembly
  8521 |     |         assembly {
  8522 |     |             function writeString(pos, w) {
  8523 |     |                 let length := 0
  8524 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  8525 |     |                 mstore(pos, length)
  8526 |     |                 let shift := sub(256, shl(3, length))
  8527 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  8528 |     |             }
  8529 |     |             m0 := mload(0x00)
  8530 |     |             m1 := mload(0x20)
  8531 |     |             m2 := mload(0x40)
  8532 |     |             m3 := mload(0x60)
  8533 |     |             m4 := mload(0x80)
  8534 |     |             m5 := mload(0xa0)
  8535 |     |             m6 := mload(0xc0)
  8536 |     |             // Selector of `log(uint256,address,uint256,string)`.
  8537 |     |             mstore(0x00, 0xddb06521)
  8538 |     |             mstore(0x20, p0)
  8539 |     |             mstore(0x40, p1)
  8540 |     |             mstore(0x60, p2)
  8541 |     |             mstore(0x80, 0x80)
  8542 |     |             writeString(0xa0, p3)
  8543 |     |         }
  8544 |     |         _sendLogPayload(0x1c, 0xc4);
  8545 |     |         /// @solidity memory-safe-assembly
  8546 |     |         assembly {
  8547 |     |             mstore(0x00, m0)
  8548 |     |             mstore(0x20, m1)
  8549 |     |             mstore(0x40, m2)
  8550 |     |             mstore(0x60, m3)
  8551 |     |             mstore(0x80, m4)
  8552 |     |             mstore(0xa0, m5)
  8553 |     |             mstore(0xc0, m6)
  8554 |     |         }
  8555 |     |     }
  8556 |     | 
  8557 |     |     function log(uint256 p0, address p1, bytes32 p2, address p3) internal pure {
  8558 |     |         bytes32 m0;
  8559 |     |         bytes32 m1;
  8560 |     |         bytes32 m2;
  8561 |     |         bytes32 m3;
  8562 |     |         bytes32 m4;
  8563 |     |         bytes32 m5;
  8564 |     |         bytes32 m6;
  8565 |     |         /// @solidity memory-safe-assembly
  8566 |     |         assembly {
  8567 |     |             function writeString(pos, w) {
  8568 |     |                 let length := 0
  8569 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  8570 |     |                 mstore(pos, length)
  8571 |     |                 let shift := sub(256, shl(3, length))
  8572 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  8573 |     |             }
  8574 |     |             m0 := mload(0x00)
  8575 |     |             m1 := mload(0x20)
  8576 |     |             m2 := mload(0x40)
  8577 |     |             m3 := mload(0x60)
  8578 |     |             m4 := mload(0x80)
  8579 |     |             m5 := mload(0xa0)
  8580 |     |             m6 := mload(0xc0)
  8581 |     |             // Selector of `log(uint256,address,string,address)`.
  8582 |     |             mstore(0x00, 0x9cba8fff)
  8583 |     |             mstore(0x20, p0)
  8584 |     |             mstore(0x40, p1)
  8585 |     |             mstore(0x60, 0x80)
  8586 |     |             mstore(0x80, p3)
  8587 |     |             writeString(0xa0, p2)
  8588 |     |         }
  8589 |     |         _sendLogPayload(0x1c, 0xc4);
  8590 |     |         /// @solidity memory-safe-assembly
  8591 |     |         assembly {
  8592 |     |             mstore(0x00, m0)
  8593 |     |             mstore(0x20, m1)
  8594 |     |             mstore(0x40, m2)
  8595 |     |             mstore(0x60, m3)
  8596 |     |             mstore(0x80, m4)
  8597 |     |             mstore(0xa0, m5)
  8598 |     |             mstore(0xc0, m6)
  8599 |     |         }
  8600 |     |     }
  8601 |     | 
  8602 |     |     function log(uint256 p0, address p1, bytes32 p2, bool p3) internal pure {
  8603 |     |         bytes32 m0;
  8604 |     |         bytes32 m1;
  8605 |     |         bytes32 m2;
  8606 |     |         bytes32 m3;
  8607 |     |         bytes32 m4;
  8608 |     |         bytes32 m5;
  8609 |     |         bytes32 m6;
  8610 |     |         /// @solidity memory-safe-assembly
  8611 |     |         assembly {
  8612 |     |             function writeString(pos, w) {
  8613 |     |                 let length := 0
  8614 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  8615 |     |                 mstore(pos, length)
  8616 |     |                 let shift := sub(256, shl(3, length))
  8617 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  8618 |     |             }
  8619 |     |             m0 := mload(0x00)
  8620 |     |             m1 := mload(0x20)
  8621 |     |             m2 := mload(0x40)
  8622 |     |             m3 := mload(0x60)
  8623 |     |             m4 := mload(0x80)
  8624 |     |             m5 := mload(0xa0)
  8625 |     |             m6 := mload(0xc0)
  8626 |     |             // Selector of `log(uint256,address,string,bool)`.
  8627 |     |             mstore(0x00, 0xcc32ab07)
  8628 |     |             mstore(0x20, p0)
  8629 |     |             mstore(0x40, p1)
  8630 |     |             mstore(0x60, 0x80)
  8631 |     |             mstore(0x80, p3)
  8632 |     |             writeString(0xa0, p2)
  8633 |     |         }
  8634 |     |         _sendLogPayload(0x1c, 0xc4);
  8635 |     |         /// @solidity memory-safe-assembly
  8636 |     |         assembly {
  8637 |     |             mstore(0x00, m0)
  8638 |     |             mstore(0x20, m1)
  8639 |     |             mstore(0x40, m2)
  8640 |     |             mstore(0x60, m3)
  8641 |     |             mstore(0x80, m4)
  8642 |     |             mstore(0xa0, m5)
  8643 |     |             mstore(0xc0, m6)
  8644 |     |         }
  8645 |     |     }
  8646 |     | 
  8647 |     |     function log(uint256 p0, address p1, bytes32 p2, uint256 p3) internal pure {
  8648 |     |         bytes32 m0;
  8649 |     |         bytes32 m1;
  8650 |     |         bytes32 m2;
  8651 |     |         bytes32 m3;
  8652 |     |         bytes32 m4;
  8653 |     |         bytes32 m5;
  8654 |     |         bytes32 m6;
  8655 |     |         /// @solidity memory-safe-assembly
  8656 |     |         assembly {
  8657 |     |             function writeString(pos, w) {
  8658 |     |                 let length := 0
  8659 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  8660 |     |                 mstore(pos, length)
  8661 |     |                 let shift := sub(256, shl(3, length))
  8662 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  8663 |     |             }
  8664 |     |             m0 := mload(0x00)
  8665 |     |             m1 := mload(0x20)
  8666 |     |             m2 := mload(0x40)
  8667 |     |             m3 := mload(0x60)
  8668 |     |             m4 := mload(0x80)
  8669 |     |             m5 := mload(0xa0)
  8670 |     |             m6 := mload(0xc0)
  8671 |     |             // Selector of `log(uint256,address,string,uint256)`.
  8672 |     |             mstore(0x00, 0x46826b5d)
  8673 |     |             mstore(0x20, p0)
  8674 |     |             mstore(0x40, p1)
  8675 |     |             mstore(0x60, 0x80)
  8676 |     |             mstore(0x80, p3)
  8677 |     |             writeString(0xa0, p2)
  8678 |     |         }
  8679 |     |         _sendLogPayload(0x1c, 0xc4);
  8680 |     |         /// @solidity memory-safe-assembly
  8681 |     |         assembly {
  8682 |     |             mstore(0x00, m0)
  8683 |     |             mstore(0x20, m1)
  8684 |     |             mstore(0x40, m2)
  8685 |     |             mstore(0x60, m3)
  8686 |     |             mstore(0x80, m4)
  8687 |     |             mstore(0xa0, m5)
  8688 |     |             mstore(0xc0, m6)
  8689 |     |         }
  8690 |     |     }
  8691 |     | 
  8692 |     |     function log(uint256 p0, address p1, bytes32 p2, bytes32 p3) internal pure {
  8693 |     |         bytes32 m0;
  8694 |     |         bytes32 m1;
  8695 |     |         bytes32 m2;
  8696 |     |         bytes32 m3;
  8697 |     |         bytes32 m4;
  8698 |     |         bytes32 m5;
  8699 |     |         bytes32 m6;
  8700 |     |         bytes32 m7;
  8701 |     |         bytes32 m8;
  8702 |     |         /// @solidity memory-safe-assembly
  8703 |     |         assembly {
  8704 |     |             function writeString(pos, w) {
  8705 |     |                 let length := 0
  8706 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  8707 |     |                 mstore(pos, length)
  8708 |     |                 let shift := sub(256, shl(3, length))
  8709 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  8710 |     |             }
  8711 |     |             m0 := mload(0x00)
  8712 |     |             m1 := mload(0x20)
  8713 |     |             m2 := mload(0x40)
  8714 |     |             m3 := mload(0x60)
  8715 |     |             m4 := mload(0x80)
  8716 |     |             m5 := mload(0xa0)
  8717 |     |             m6 := mload(0xc0)
  8718 |     |             m7 := mload(0xe0)
  8719 |     |             m8 := mload(0x100)
  8720 |     |             // Selector of `log(uint256,address,string,string)`.
  8721 |     |             mstore(0x00, 0x3e128ca3)
  8722 |     |             mstore(0x20, p0)
  8723 |     |             mstore(0x40, p1)
  8724 |     |             mstore(0x60, 0x80)
  8725 |     |             mstore(0x80, 0xc0)
  8726 |     |             writeString(0xa0, p2)
  8727 |     |             writeString(0xe0, p3)
  8728 |     |         }
  8729 |     |         _sendLogPayload(0x1c, 0x104);
  8730 |     |         /// @solidity memory-safe-assembly
  8731 |     |         assembly {
  8732 |     |             mstore(0x00, m0)
  8733 |     |             mstore(0x20, m1)
  8734 |     |             mstore(0x40, m2)
  8735 |     |             mstore(0x60, m3)
  8736 |     |             mstore(0x80, m4)
  8737 |     |             mstore(0xa0, m5)
  8738 |     |             mstore(0xc0, m6)
  8739 |     |             mstore(0xe0, m7)
  8740 |     |             mstore(0x100, m8)
  8741 |     |         }
  8742 |     |     }
  8743 |     | 
  8744 |     |     function log(uint256 p0, bool p1, address p2, address p3) internal pure {
  8745 |     |         bytes32 m0;
  8746 |     |         bytes32 m1;
  8747 |     |         bytes32 m2;
  8748 |     |         bytes32 m3;
  8749 |     |         bytes32 m4;
  8750 |     |         /// @solidity memory-safe-assembly
  8751 |     |         assembly {
  8752 |     |             m0 := mload(0x00)
  8753 |     |             m1 := mload(0x20)
  8754 |     |             m2 := mload(0x40)
  8755 |     |             m3 := mload(0x60)
  8756 |     |             m4 := mload(0x80)
  8757 |     |             // Selector of `log(uint256,bool,address,address)`.
  8758 |     |             mstore(0x00, 0xa1ef4cbb)
  8759 |     |             mstore(0x20, p0)
  8760 |     |             mstore(0x40, p1)
  8761 |     |             mstore(0x60, p2)
  8762 |     |             mstore(0x80, p3)
  8763 |     |         }
  8764 |     |         _sendLogPayload(0x1c, 0x84);
  8765 |     |         /// @solidity memory-safe-assembly
  8766 |     |         assembly {
  8767 |     |             mstore(0x00, m0)
  8768 |     |             mstore(0x20, m1)
  8769 |     |             mstore(0x40, m2)
  8770 |     |             mstore(0x60, m3)
  8771 |     |             mstore(0x80, m4)
  8772 |     |         }
  8773 |     |     }
  8774 |     | 
  8775 |     |     function log(uint256 p0, bool p1, address p2, bool p3) internal pure {
  8776 |     |         bytes32 m0;
  8777 |     |         bytes32 m1;
  8778 |     |         bytes32 m2;
  8779 |     |         bytes32 m3;
  8780 |     |         bytes32 m4;
  8781 |     |         /// @solidity memory-safe-assembly
  8782 |     |         assembly {
  8783 |     |             m0 := mload(0x00)
  8784 |     |             m1 := mload(0x20)
  8785 |     |             m2 := mload(0x40)
  8786 |     |             m3 := mload(0x60)
  8787 |     |             m4 := mload(0x80)
  8788 |     |             // Selector of `log(uint256,bool,address,bool)`.
  8789 |     |             mstore(0x00, 0x454d54a5)
  8790 |     |             mstore(0x20, p0)
  8791 |     |             mstore(0x40, p1)
  8792 |     |             mstore(0x60, p2)
  8793 |     |             mstore(0x80, p3)
  8794 |     |         }
  8795 |     |         _sendLogPayload(0x1c, 0x84);
  8796 |     |         /// @solidity memory-safe-assembly
  8797 |     |         assembly {
  8798 |     |             mstore(0x00, m0)
  8799 |     |             mstore(0x20, m1)
  8800 |     |             mstore(0x40, m2)
  8801 |     |             mstore(0x60, m3)
  8802 |     |             mstore(0x80, m4)
  8803 |     |         }
  8804 |     |     }
  8805 |     | 
  8806 |     |     function log(uint256 p0, bool p1, address p2, uint256 p3) internal pure {
  8807 |     |         bytes32 m0;
  8808 |     |         bytes32 m1;
  8809 |     |         bytes32 m2;
  8810 |     |         bytes32 m3;
  8811 |     |         bytes32 m4;
  8812 |     |         /// @solidity memory-safe-assembly
  8813 |     |         assembly {
  8814 |     |             m0 := mload(0x00)
  8815 |     |             m1 := mload(0x20)
  8816 |     |             m2 := mload(0x40)
  8817 |     |             m3 := mload(0x60)
  8818 |     |             m4 := mload(0x80)
  8819 |     |             // Selector of `log(uint256,bool,address,uint256)`.
  8820 |     |             mstore(0x00, 0x078287f5)
  8821 |     |             mstore(0x20, p0)
  8822 |     |             mstore(0x40, p1)
  8823 |     |             mstore(0x60, p2)
  8824 |     |             mstore(0x80, p3)
  8825 |     |         }
  8826 |     |         _sendLogPayload(0x1c, 0x84);
  8827 |     |         /// @solidity memory-safe-assembly
  8828 |     |         assembly {
  8829 |     |             mstore(0x00, m0)
  8830 |     |             mstore(0x20, m1)
  8831 |     |             mstore(0x40, m2)
  8832 |     |             mstore(0x60, m3)
  8833 |     |             mstore(0x80, m4)
  8834 |     |         }
  8835 |     |     }
  8836 |     | 
  8837 |     |     function log(uint256 p0, bool p1, address p2, bytes32 p3) internal pure {
  8838 |     |         bytes32 m0;
  8839 |     |         bytes32 m1;
  8840 |     |         bytes32 m2;
  8841 |     |         bytes32 m3;
  8842 |     |         bytes32 m4;
  8843 |     |         bytes32 m5;
  8844 |     |         bytes32 m6;
  8845 |     |         /// @solidity memory-safe-assembly
  8846 |     |         assembly {
  8847 |     |             function writeString(pos, w) {
  8848 |     |                 let length := 0
  8849 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  8850 |     |                 mstore(pos, length)
  8851 |     |                 let shift := sub(256, shl(3, length))
  8852 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  8853 |     |             }
  8854 |     |             m0 := mload(0x00)
  8855 |     |             m1 := mload(0x20)
  8856 |     |             m2 := mload(0x40)
  8857 |     |             m3 := mload(0x60)
  8858 |     |             m4 := mload(0x80)
  8859 |     |             m5 := mload(0xa0)
  8860 |     |             m6 := mload(0xc0)
  8861 |     |             // Selector of `log(uint256,bool,address,string)`.
  8862 |     |             mstore(0x00, 0xade052c7)
  8863 |     |             mstore(0x20, p0)
  8864 |     |             mstore(0x40, p1)
  8865 |     |             mstore(0x60, p2)
  8866 |     |             mstore(0x80, 0x80)
  8867 |     |             writeString(0xa0, p3)
  8868 |     |         }
  8869 |     |         _sendLogPayload(0x1c, 0xc4);
  8870 |     |         /// @solidity memory-safe-assembly
  8871 |     |         assembly {
  8872 |     |             mstore(0x00, m0)
  8873 |     |             mstore(0x20, m1)
  8874 |     |             mstore(0x40, m2)
  8875 |     |             mstore(0x60, m3)
  8876 |     |             mstore(0x80, m4)
  8877 |     |             mstore(0xa0, m5)
  8878 |     |             mstore(0xc0, m6)
  8879 |     |         }
  8880 |     |     }
  8881 |     | 
  8882 |     |     function log(uint256 p0, bool p1, bool p2, address p3) internal pure {
  8883 |     |         bytes32 m0;
  8884 |     |         bytes32 m1;
  8885 |     |         bytes32 m2;
  8886 |     |         bytes32 m3;
  8887 |     |         bytes32 m4;
  8888 |     |         /// @solidity memory-safe-assembly
  8889 |     |         assembly {
  8890 |     |             m0 := mload(0x00)
  8891 |     |             m1 := mload(0x20)
  8892 |     |             m2 := mload(0x40)
  8893 |     |             m3 := mload(0x60)
  8894 |     |             m4 := mload(0x80)
  8895 |     |             // Selector of `log(uint256,bool,bool,address)`.
  8896 |     |             mstore(0x00, 0x69640b59)
  8897 |     |             mstore(0x20, p0)
  8898 |     |             mstore(0x40, p1)
  8899 |     |             mstore(0x60, p2)
  8900 |     |             mstore(0x80, p3)
  8901 |     |         }
  8902 |     |         _sendLogPayload(0x1c, 0x84);
  8903 |     |         /// @solidity memory-safe-assembly
  8904 |     |         assembly {
  8905 |     |             mstore(0x00, m0)
  8906 |     |             mstore(0x20, m1)
  8907 |     |             mstore(0x40, m2)
  8908 |     |             mstore(0x60, m3)
  8909 |     |             mstore(0x80, m4)
  8910 |     |         }
  8911 |     |     }
  8912 |     | 
  8913 |     |     function log(uint256 p0, bool p1, bool p2, bool p3) internal pure {
  8914 |     |         bytes32 m0;
  8915 |     |         bytes32 m1;
  8916 |     |         bytes32 m2;
  8917 |     |         bytes32 m3;
  8918 |     |         bytes32 m4;
  8919 |     |         /// @solidity memory-safe-assembly
  8920 |     |         assembly {
  8921 |     |             m0 := mload(0x00)
  8922 |     |             m1 := mload(0x20)
  8923 |     |             m2 := mload(0x40)
  8924 |     |             m3 := mload(0x60)
  8925 |     |             m4 := mload(0x80)
  8926 |     |             // Selector of `log(uint256,bool,bool,bool)`.
  8927 |     |             mstore(0x00, 0xb6f577a1)
  8928 |     |             mstore(0x20, p0)
  8929 |     |             mstore(0x40, p1)
  8930 |     |             mstore(0x60, p2)
  8931 |     |             mstore(0x80, p3)
  8932 |     |         }
  8933 |     |         _sendLogPayload(0x1c, 0x84);
  8934 |     |         /// @solidity memory-safe-assembly
  8935 |     |         assembly {
  8936 |     |             mstore(0x00, m0)
  8937 |     |             mstore(0x20, m1)
  8938 |     |             mstore(0x40, m2)
  8939 |     |             mstore(0x60, m3)
  8940 |     |             mstore(0x80, m4)
  8941 |     |         }
  8942 |     |     }
  8943 |     | 
  8944 |     |     function log(uint256 p0, bool p1, bool p2, uint256 p3) internal pure {
  8945 |     |         bytes32 m0;
  8946 |     |         bytes32 m1;
  8947 |     |         bytes32 m2;
  8948 |     |         bytes32 m3;
  8949 |     |         bytes32 m4;
  8950 |     |         /// @solidity memory-safe-assembly
  8951 |     |         assembly {
  8952 |     |             m0 := mload(0x00)
  8953 |     |             m1 := mload(0x20)
  8954 |     |             m2 := mload(0x40)
  8955 |     |             m3 := mload(0x60)
  8956 |     |             m4 := mload(0x80)
  8957 |     |             // Selector of `log(uint256,bool,bool,uint256)`.
  8958 |     |             mstore(0x00, 0x7464ce23)
  8959 |     |             mstore(0x20, p0)
  8960 |     |             mstore(0x40, p1)
  8961 |     |             mstore(0x60, p2)
  8962 |     |             mstore(0x80, p3)
  8963 |     |         }
  8964 |     |         _sendLogPayload(0x1c, 0x84);
  8965 |     |         /// @solidity memory-safe-assembly
  8966 |     |         assembly {
  8967 |     |             mstore(0x00, m0)
  8968 |     |             mstore(0x20, m1)
  8969 |     |             mstore(0x40, m2)
  8970 |     |             mstore(0x60, m3)
  8971 |     |             mstore(0x80, m4)
  8972 |     |         }
  8973 |     |     }
  8974 |     | 
  8975 |     |     function log(uint256 p0, bool p1, bool p2, bytes32 p3) internal pure {
  8976 |     |         bytes32 m0;
  8977 |     |         bytes32 m1;
  8978 |     |         bytes32 m2;
  8979 |     |         bytes32 m3;
  8980 |     |         bytes32 m4;
  8981 |     |         bytes32 m5;
  8982 |     |         bytes32 m6;
  8983 |     |         /// @solidity memory-safe-assembly
  8984 |     |         assembly {
  8985 |     |             function writeString(pos, w) {
  8986 |     |                 let length := 0
  8987 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  8988 |     |                 mstore(pos, length)
  8989 |     |                 let shift := sub(256, shl(3, length))
  8990 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  8991 |     |             }
  8992 |     |             m0 := mload(0x00)
  8993 |     |             m1 := mload(0x20)
  8994 |     |             m2 := mload(0x40)
  8995 |     |             m3 := mload(0x60)
  8996 |     |             m4 := mload(0x80)
  8997 |     |             m5 := mload(0xa0)
  8998 |     |             m6 := mload(0xc0)
  8999 |     |             // Selector of `log(uint256,bool,bool,string)`.
  9000 |     |             mstore(0x00, 0xdddb9561)
  9001 |     |             mstore(0x20, p0)
  9002 |     |             mstore(0x40, p1)
  9003 |     |             mstore(0x60, p2)
  9004 |     |             mstore(0x80, 0x80)
  9005 |     |             writeString(0xa0, p3)
  9006 |     |         }
  9007 |     |         _sendLogPayload(0x1c, 0xc4);
  9008 |     |         /// @solidity memory-safe-assembly
  9009 |     |         assembly {
  9010 |     |             mstore(0x00, m0)
  9011 |     |             mstore(0x20, m1)
  9012 |     |             mstore(0x40, m2)
  9013 |     |             mstore(0x60, m3)
  9014 |     |             mstore(0x80, m4)
  9015 |     |             mstore(0xa0, m5)
  9016 |     |             mstore(0xc0, m6)
  9017 |     |         }
  9018 |     |     }
  9019 |     | 
  9020 |     |     function log(uint256 p0, bool p1, uint256 p2, address p3) internal pure {
  9021 |     |         bytes32 m0;
  9022 |     |         bytes32 m1;
  9023 |     |         bytes32 m2;
  9024 |     |         bytes32 m3;
  9025 |     |         bytes32 m4;
  9026 |     |         /// @solidity memory-safe-assembly
  9027 |     |         assembly {
  9028 |     |             m0 := mload(0x00)
  9029 |     |             m1 := mload(0x20)
  9030 |     |             m2 := mload(0x40)
  9031 |     |             m3 := mload(0x60)
  9032 |     |             m4 := mload(0x80)
  9033 |     |             // Selector of `log(uint256,bool,uint256,address)`.
  9034 |     |             mstore(0x00, 0x88cb6041)
  9035 |     |             mstore(0x20, p0)
  9036 |     |             mstore(0x40, p1)
  9037 |     |             mstore(0x60, p2)
  9038 |     |             mstore(0x80, p3)
  9039 |     |         }
  9040 |     |         _sendLogPayload(0x1c, 0x84);
  9041 |     |         /// @solidity memory-safe-assembly
  9042 |     |         assembly {
  9043 |     |             mstore(0x00, m0)
  9044 |     |             mstore(0x20, m1)
  9045 |     |             mstore(0x40, m2)
  9046 |     |             mstore(0x60, m3)
  9047 |     |             mstore(0x80, m4)
  9048 |     |         }
  9049 |     |     }
  9050 |     | 
  9051 |     |     function log(uint256 p0, bool p1, uint256 p2, bool p3) internal pure {
  9052 |     |         bytes32 m0;
  9053 |     |         bytes32 m1;
  9054 |     |         bytes32 m2;
  9055 |     |         bytes32 m3;
  9056 |     |         bytes32 m4;
  9057 |     |         /// @solidity memory-safe-assembly
  9058 |     |         assembly {
  9059 |     |             m0 := mload(0x00)
  9060 |     |             m1 := mload(0x20)
  9061 |     |             m2 := mload(0x40)
  9062 |     |             m3 := mload(0x60)
  9063 |     |             m4 := mload(0x80)
  9064 |     |             // Selector of `log(uint256,bool,uint256,bool)`.
  9065 |     |             mstore(0x00, 0x91a02e2a)
  9066 |     |             mstore(0x20, p0)
  9067 |     |             mstore(0x40, p1)
  9068 |     |             mstore(0x60, p2)
  9069 |     |             mstore(0x80, p3)
  9070 |     |         }
  9071 |     |         _sendLogPayload(0x1c, 0x84);
  9072 |     |         /// @solidity memory-safe-assembly
  9073 |     |         assembly {
  9074 |     |             mstore(0x00, m0)
  9075 |     |             mstore(0x20, m1)
  9076 |     |             mstore(0x40, m2)
  9077 |     |             mstore(0x60, m3)
  9078 |     |             mstore(0x80, m4)
  9079 |     |         }
  9080 |     |     }
  9081 |     | 
  9082 |     |     function log(uint256 p0, bool p1, uint256 p2, uint256 p3) internal pure {
  9083 |     |         bytes32 m0;
  9084 |     |         bytes32 m1;
  9085 |     |         bytes32 m2;
  9086 |     |         bytes32 m3;
  9087 |     |         bytes32 m4;
  9088 |     |         /// @solidity memory-safe-assembly
  9089 |     |         assembly {
  9090 |     |             m0 := mload(0x00)
  9091 |     |             m1 := mload(0x20)
  9092 |     |             m2 := mload(0x40)
  9093 |     |             m3 := mload(0x60)
  9094 |     |             m4 := mload(0x80)
  9095 |     |             // Selector of `log(uint256,bool,uint256,uint256)`.
  9096 |     |             mstore(0x00, 0xc6acc7a8)
  9097 |     |             mstore(0x20, p0)
  9098 |     |             mstore(0x40, p1)
  9099 |     |             mstore(0x60, p2)
  9100 |     |             mstore(0x80, p3)
  9101 |     |         }
  9102 |     |         _sendLogPayload(0x1c, 0x84);
  9103 |     |         /// @solidity memory-safe-assembly
  9104 |     |         assembly {
  9105 |     |             mstore(0x00, m0)
  9106 |     |             mstore(0x20, m1)
  9107 |     |             mstore(0x40, m2)
  9108 |     |             mstore(0x60, m3)
  9109 |     |             mstore(0x80, m4)
  9110 |     |         }
  9111 |     |     }
  9112 |     | 
  9113 |     |     function log(uint256 p0, bool p1, uint256 p2, bytes32 p3) internal pure {
  9114 |     |         bytes32 m0;
  9115 |     |         bytes32 m1;
  9116 |     |         bytes32 m2;
  9117 |     |         bytes32 m3;
  9118 |     |         bytes32 m4;
  9119 |     |         bytes32 m5;
  9120 |     |         bytes32 m6;
  9121 |     |         /// @solidity memory-safe-assembly
  9122 |     |         assembly {
  9123 |     |             function writeString(pos, w) {
  9124 |     |                 let length := 0
  9125 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  9126 |     |                 mstore(pos, length)
  9127 |     |                 let shift := sub(256, shl(3, length))
  9128 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  9129 |     |             }
  9130 |     |             m0 := mload(0x00)
  9131 |     |             m1 := mload(0x20)
  9132 |     |             m2 := mload(0x40)
  9133 |     |             m3 := mload(0x60)
  9134 |     |             m4 := mload(0x80)
  9135 |     |             m5 := mload(0xa0)
  9136 |     |             m6 := mload(0xc0)
  9137 |     |             // Selector of `log(uint256,bool,uint256,string)`.
  9138 |     |             mstore(0x00, 0xde03e774)
  9139 |     |             mstore(0x20, p0)
  9140 |     |             mstore(0x40, p1)
  9141 |     |             mstore(0x60, p2)
  9142 |     |             mstore(0x80, 0x80)
  9143 |     |             writeString(0xa0, p3)
  9144 |     |         }
  9145 |     |         _sendLogPayload(0x1c, 0xc4);
  9146 |     |         /// @solidity memory-safe-assembly
  9147 |     |         assembly {
  9148 |     |             mstore(0x00, m0)
  9149 |     |             mstore(0x20, m1)
  9150 |     |             mstore(0x40, m2)
  9151 |     |             mstore(0x60, m3)
  9152 |     |             mstore(0x80, m4)
  9153 |     |             mstore(0xa0, m5)
  9154 |     |             mstore(0xc0, m6)
  9155 |     |         }
  9156 |     |     }
  9157 |     | 
  9158 |     |     function log(uint256 p0, bool p1, bytes32 p2, address p3) internal pure {
  9159 |     |         bytes32 m0;
  9160 |     |         bytes32 m1;
  9161 |     |         bytes32 m2;
  9162 |     |         bytes32 m3;
  9163 |     |         bytes32 m4;
  9164 |     |         bytes32 m5;
  9165 |     |         bytes32 m6;
  9166 |     |         /// @solidity memory-safe-assembly
  9167 |     |         assembly {
  9168 |     |             function writeString(pos, w) {
  9169 |     |                 let length := 0
  9170 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  9171 |     |                 mstore(pos, length)
  9172 |     |                 let shift := sub(256, shl(3, length))
  9173 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  9174 |     |             }
  9175 |     |             m0 := mload(0x00)
  9176 |     |             m1 := mload(0x20)
  9177 |     |             m2 := mload(0x40)
  9178 |     |             m3 := mload(0x60)
  9179 |     |             m4 := mload(0x80)
  9180 |     |             m5 := mload(0xa0)
  9181 |     |             m6 := mload(0xc0)
  9182 |     |             // Selector of `log(uint256,bool,string,address)`.
  9183 |     |             mstore(0x00, 0xef529018)
  9184 |     |             mstore(0x20, p0)
  9185 |     |             mstore(0x40, p1)
  9186 |     |             mstore(0x60, 0x80)
  9187 |     |             mstore(0x80, p3)
  9188 |     |             writeString(0xa0, p2)
  9189 |     |         }
  9190 |     |         _sendLogPayload(0x1c, 0xc4);
  9191 |     |         /// @solidity memory-safe-assembly
  9192 |     |         assembly {
  9193 |     |             mstore(0x00, m0)
  9194 |     |             mstore(0x20, m1)
  9195 |     |             mstore(0x40, m2)
  9196 |     |             mstore(0x60, m3)
  9197 |     |             mstore(0x80, m4)
  9198 |     |             mstore(0xa0, m5)
  9199 |     |             mstore(0xc0, m6)
  9200 |     |         }
  9201 |     |     }
  9202 |     | 
  9203 |     |     function log(uint256 p0, bool p1, bytes32 p2, bool p3) internal pure {
  9204 |     |         bytes32 m0;
  9205 |     |         bytes32 m1;
  9206 |     |         bytes32 m2;
  9207 |     |         bytes32 m3;
  9208 |     |         bytes32 m4;
  9209 |     |         bytes32 m5;
  9210 |     |         bytes32 m6;
  9211 |     |         /// @solidity memory-safe-assembly
  9212 |     |         assembly {
  9213 |     |             function writeString(pos, w) {
  9214 |     |                 let length := 0
  9215 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  9216 |     |                 mstore(pos, length)
  9217 |     |                 let shift := sub(256, shl(3, length))
  9218 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  9219 |     |             }
  9220 |     |             m0 := mload(0x00)
  9221 |     |             m1 := mload(0x20)
  9222 |     |             m2 := mload(0x40)
  9223 |     |             m3 := mload(0x60)
  9224 |     |             m4 := mload(0x80)
  9225 |     |             m5 := mload(0xa0)
  9226 |     |             m6 := mload(0xc0)
  9227 |     |             // Selector of `log(uint256,bool,string,bool)`.
  9228 |     |             mstore(0x00, 0xeb928d7f)
  9229 |     |             mstore(0x20, p0)
  9230 |     |             mstore(0x40, p1)
  9231 |     |             mstore(0x60, 0x80)
  9232 |     |             mstore(0x80, p3)
  9233 |     |             writeString(0xa0, p2)
  9234 |     |         }
  9235 |     |         _sendLogPayload(0x1c, 0xc4);
  9236 |     |         /// @solidity memory-safe-assembly
  9237 |     |         assembly {
  9238 |     |             mstore(0x00, m0)
  9239 |     |             mstore(0x20, m1)
  9240 |     |             mstore(0x40, m2)
  9241 |     |             mstore(0x60, m3)
  9242 |     |             mstore(0x80, m4)
  9243 |     |             mstore(0xa0, m5)
  9244 |     |             mstore(0xc0, m6)
  9245 |     |         }
  9246 |     |     }
  9247 |     | 
  9248 |     |     function log(uint256 p0, bool p1, bytes32 p2, uint256 p3) internal pure {
  9249 |     |         bytes32 m0;
  9250 |     |         bytes32 m1;
  9251 |     |         bytes32 m2;
  9252 |     |         bytes32 m3;
  9253 |     |         bytes32 m4;
  9254 |     |         bytes32 m5;
  9255 |     |         bytes32 m6;
  9256 |     |         /// @solidity memory-safe-assembly
  9257 |     |         assembly {
  9258 |     |             function writeString(pos, w) {
  9259 |     |                 let length := 0
  9260 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  9261 |     |                 mstore(pos, length)
  9262 |     |                 let shift := sub(256, shl(3, length))
  9263 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  9264 |     |             }
  9265 |     |             m0 := mload(0x00)
  9266 |     |             m1 := mload(0x20)
  9267 |     |             m2 := mload(0x40)
  9268 |     |             m3 := mload(0x60)
  9269 |     |             m4 := mload(0x80)
  9270 |     |             m5 := mload(0xa0)
  9271 |     |             m6 := mload(0xc0)
  9272 |     |             // Selector of `log(uint256,bool,string,uint256)`.
  9273 |     |             mstore(0x00, 0x2c1d0746)
  9274 |     |             mstore(0x20, p0)
  9275 |     |             mstore(0x40, p1)
  9276 |     |             mstore(0x60, 0x80)
  9277 |     |             mstore(0x80, p3)
  9278 |     |             writeString(0xa0, p2)
  9279 |     |         }
  9280 |     |         _sendLogPayload(0x1c, 0xc4);
  9281 |     |         /// @solidity memory-safe-assembly
  9282 |     |         assembly {
  9283 |     |             mstore(0x00, m0)
  9284 |     |             mstore(0x20, m1)
  9285 |     |             mstore(0x40, m2)
  9286 |     |             mstore(0x60, m3)
  9287 |     |             mstore(0x80, m4)
  9288 |     |             mstore(0xa0, m5)
  9289 |     |             mstore(0xc0, m6)
  9290 |     |         }
  9291 |     |     }
  9292 |     | 
  9293 |     |     function log(uint256 p0, bool p1, bytes32 p2, bytes32 p3) internal pure {
  9294 |     |         bytes32 m0;
  9295 |     |         bytes32 m1;
  9296 |     |         bytes32 m2;
  9297 |     |         bytes32 m3;
  9298 |     |         bytes32 m4;
  9299 |     |         bytes32 m5;
  9300 |     |         bytes32 m6;
  9301 |     |         bytes32 m7;
  9302 |     |         bytes32 m8;
  9303 |     |         /// @solidity memory-safe-assembly
  9304 |     |         assembly {
  9305 |     |             function writeString(pos, w) {
  9306 |     |                 let length := 0
  9307 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  9308 |     |                 mstore(pos, length)
  9309 |     |                 let shift := sub(256, shl(3, length))
  9310 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  9311 |     |             }
  9312 |     |             m0 := mload(0x00)
  9313 |     |             m1 := mload(0x20)
  9314 |     |             m2 := mload(0x40)
  9315 |     |             m3 := mload(0x60)
  9316 |     |             m4 := mload(0x80)
  9317 |     |             m5 := mload(0xa0)
  9318 |     |             m6 := mload(0xc0)
  9319 |     |             m7 := mload(0xe0)
  9320 |     |             m8 := mload(0x100)
  9321 |     |             // Selector of `log(uint256,bool,string,string)`.
  9322 |     |             mstore(0x00, 0x68c8b8bd)
  9323 |     |             mstore(0x20, p0)
  9324 |     |             mstore(0x40, p1)
  9325 |     |             mstore(0x60, 0x80)
  9326 |     |             mstore(0x80, 0xc0)
  9327 |     |             writeString(0xa0, p2)
  9328 |     |             writeString(0xe0, p3)
  9329 |     |         }
  9330 |     |         _sendLogPayload(0x1c, 0x104);
  9331 |     |         /// @solidity memory-safe-assembly
  9332 |     |         assembly {
  9333 |     |             mstore(0x00, m0)
  9334 |     |             mstore(0x20, m1)
  9335 |     |             mstore(0x40, m2)
  9336 |     |             mstore(0x60, m3)
  9337 |     |             mstore(0x80, m4)
  9338 |     |             mstore(0xa0, m5)
  9339 |     |             mstore(0xc0, m6)
  9340 |     |             mstore(0xe0, m7)
  9341 |     |             mstore(0x100, m8)
  9342 |     |         }
  9343 |     |     }
  9344 |     | 
  9345 |     |     function log(uint256 p0, uint256 p1, address p2, address p3) internal pure {
  9346 |     |         bytes32 m0;
  9347 |     |         bytes32 m1;
  9348 |     |         bytes32 m2;
  9349 |     |         bytes32 m3;
  9350 |     |         bytes32 m4;
  9351 |     |         /// @solidity memory-safe-assembly
  9352 |     |         assembly {
  9353 |     |             m0 := mload(0x00)
  9354 |     |             m1 := mload(0x20)
  9355 |     |             m2 := mload(0x40)
  9356 |     |             m3 := mload(0x60)
  9357 |     |             m4 := mload(0x80)
  9358 |     |             // Selector of `log(uint256,uint256,address,address)`.
  9359 |     |             mstore(0x00, 0x56a5d1b1)
  9360 |     |             mstore(0x20, p0)
  9361 |     |             mstore(0x40, p1)
  9362 |     |             mstore(0x60, p2)
  9363 |     |             mstore(0x80, p3)
  9364 |     |         }
  9365 |     |         _sendLogPayload(0x1c, 0x84);
  9366 |     |         /// @solidity memory-safe-assembly
  9367 |     |         assembly {
  9368 |     |             mstore(0x00, m0)
  9369 |     |             mstore(0x20, m1)
  9370 |     |             mstore(0x40, m2)
  9371 |     |             mstore(0x60, m3)
  9372 |     |             mstore(0x80, m4)
  9373 |     |         }
  9374 |     |     }
  9375 |     | 
  9376 |     |     function log(uint256 p0, uint256 p1, address p2, bool p3) internal pure {
  9377 |     |         bytes32 m0;
  9378 |     |         bytes32 m1;
  9379 |     |         bytes32 m2;
  9380 |     |         bytes32 m3;
  9381 |     |         bytes32 m4;
  9382 |     |         /// @solidity memory-safe-assembly
  9383 |     |         assembly {
  9384 |     |             m0 := mload(0x00)
  9385 |     |             m1 := mload(0x20)
  9386 |     |             m2 := mload(0x40)
  9387 |     |             m3 := mload(0x60)
  9388 |     |             m4 := mload(0x80)
  9389 |     |             // Selector of `log(uint256,uint256,address,bool)`.
  9390 |     |             mstore(0x00, 0x15cac476)
  9391 |     |             mstore(0x20, p0)
  9392 |     |             mstore(0x40, p1)
  9393 |     |             mstore(0x60, p2)
  9394 |     |             mstore(0x80, p3)
  9395 |     |         }
  9396 |     |         _sendLogPayload(0x1c, 0x84);
  9397 |     |         /// @solidity memory-safe-assembly
  9398 |     |         assembly {
  9399 |     |             mstore(0x00, m0)
  9400 |     |             mstore(0x20, m1)
  9401 |     |             mstore(0x40, m2)
  9402 |     |             mstore(0x60, m3)
  9403 |     |             mstore(0x80, m4)
  9404 |     |         }
  9405 |     |     }
  9406 |     | 
  9407 |     |     function log(uint256 p0, uint256 p1, address p2, uint256 p3) internal pure {
  9408 |     |         bytes32 m0;
  9409 |     |         bytes32 m1;
  9410 |     |         bytes32 m2;
  9411 |     |         bytes32 m3;
  9412 |     |         bytes32 m4;
  9413 |     |         /// @solidity memory-safe-assembly
  9414 |     |         assembly {
  9415 |     |             m0 := mload(0x00)
  9416 |     |             m1 := mload(0x20)
  9417 |     |             m2 := mload(0x40)
  9418 |     |             m3 := mload(0x60)
  9419 |     |             m4 := mload(0x80)
  9420 |     |             // Selector of `log(uint256,uint256,address,uint256)`.
  9421 |     |             mstore(0x00, 0x88f6e4b2)
  9422 |     |             mstore(0x20, p0)
  9423 |     |             mstore(0x40, p1)
  9424 |     |             mstore(0x60, p2)
  9425 |     |             mstore(0x80, p3)
  9426 |     |         }
  9427 |     |         _sendLogPayload(0x1c, 0x84);
  9428 |     |         /// @solidity memory-safe-assembly
  9429 |     |         assembly {
  9430 |     |             mstore(0x00, m0)
  9431 |     |             mstore(0x20, m1)
  9432 |     |             mstore(0x40, m2)
  9433 |     |             mstore(0x60, m3)
  9434 |     |             mstore(0x80, m4)
  9435 |     |         }
  9436 |     |     }
  9437 |     | 
  9438 |     |     function log(uint256 p0, uint256 p1, address p2, bytes32 p3) internal pure {
  9439 |     |         bytes32 m0;
  9440 |     |         bytes32 m1;
  9441 |     |         bytes32 m2;
  9442 |     |         bytes32 m3;
  9443 |     |         bytes32 m4;
  9444 |     |         bytes32 m5;
  9445 |     |         bytes32 m6;
  9446 |     |         /// @solidity memory-safe-assembly
  9447 |     |         assembly {
  9448 |     |             function writeString(pos, w) {
  9449 |     |                 let length := 0
  9450 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  9451 |     |                 mstore(pos, length)
  9452 |     |                 let shift := sub(256, shl(3, length))
  9453 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  9454 |     |             }
  9455 |     |             m0 := mload(0x00)
  9456 |     |             m1 := mload(0x20)
  9457 |     |             m2 := mload(0x40)
  9458 |     |             m3 := mload(0x60)
  9459 |     |             m4 := mload(0x80)
  9460 |     |             m5 := mload(0xa0)
  9461 |     |             m6 := mload(0xc0)
  9462 |     |             // Selector of `log(uint256,uint256,address,string)`.
  9463 |     |             mstore(0x00, 0x6cde40b8)
  9464 |     |             mstore(0x20, p0)
  9465 |     |             mstore(0x40, p1)
  9466 |     |             mstore(0x60, p2)
  9467 |     |             mstore(0x80, 0x80)
  9468 |     |             writeString(0xa0, p3)
  9469 |     |         }
  9470 |     |         _sendLogPayload(0x1c, 0xc4);
  9471 |     |         /// @solidity memory-safe-assembly
  9472 |     |         assembly {
  9473 |     |             mstore(0x00, m0)
  9474 |     |             mstore(0x20, m1)
  9475 |     |             mstore(0x40, m2)
  9476 |     |             mstore(0x60, m3)
  9477 |     |             mstore(0x80, m4)
  9478 |     |             mstore(0xa0, m5)
  9479 |     |             mstore(0xc0, m6)
  9480 |     |         }
  9481 |     |     }
  9482 |     | 
  9483 |     |     function log(uint256 p0, uint256 p1, bool p2, address p3) internal pure {
  9484 |     |         bytes32 m0;
  9485 |     |         bytes32 m1;
  9486 |     |         bytes32 m2;
  9487 |     |         bytes32 m3;
  9488 |     |         bytes32 m4;
  9489 |     |         /// @solidity memory-safe-assembly
  9490 |     |         assembly {
  9491 |     |             m0 := mload(0x00)
  9492 |     |             m1 := mload(0x20)
  9493 |     |             m2 := mload(0x40)
  9494 |     |             m3 := mload(0x60)
  9495 |     |             m4 := mload(0x80)
  9496 |     |             // Selector of `log(uint256,uint256,bool,address)`.
  9497 |     |             mstore(0x00, 0x9a816a83)
  9498 |     |             mstore(0x20, p0)
  9499 |     |             mstore(0x40, p1)
  9500 |     |             mstore(0x60, p2)
  9501 |     |             mstore(0x80, p3)
  9502 |     |         }
  9503 |     |         _sendLogPayload(0x1c, 0x84);
  9504 |     |         /// @solidity memory-safe-assembly
  9505 |     |         assembly {
  9506 |     |             mstore(0x00, m0)
  9507 |     |             mstore(0x20, m1)
  9508 |     |             mstore(0x40, m2)
  9509 |     |             mstore(0x60, m3)
  9510 |     |             mstore(0x80, m4)
  9511 |     |         }
  9512 |     |     }
  9513 |     | 
  9514 |     |     function log(uint256 p0, uint256 p1, bool p2, bool p3) internal pure {
  9515 |     |         bytes32 m0;
  9516 |     |         bytes32 m1;
  9517 |     |         bytes32 m2;
  9518 |     |         bytes32 m3;
  9519 |     |         bytes32 m4;
  9520 |     |         /// @solidity memory-safe-assembly
  9521 |     |         assembly {
  9522 |     |             m0 := mload(0x00)
  9523 |     |             m1 := mload(0x20)
  9524 |     |             m2 := mload(0x40)
  9525 |     |             m3 := mload(0x60)
  9526 |     |             m4 := mload(0x80)
  9527 |     |             // Selector of `log(uint256,uint256,bool,bool)`.
  9528 |     |             mstore(0x00, 0xab085ae6)
  9529 |     |             mstore(0x20, p0)
  9530 |     |             mstore(0x40, p1)
  9531 |     |             mstore(0x60, p2)
  9532 |     |             mstore(0x80, p3)
  9533 |     |         }
  9534 |     |         _sendLogPayload(0x1c, 0x84);
  9535 |     |         /// @solidity memory-safe-assembly
  9536 |     |         assembly {
  9537 |     |             mstore(0x00, m0)
  9538 |     |             mstore(0x20, m1)
  9539 |     |             mstore(0x40, m2)
  9540 |     |             mstore(0x60, m3)
  9541 |     |             mstore(0x80, m4)
  9542 |     |         }
  9543 |     |     }
  9544 |     | 
  9545 |     |     function log(uint256 p0, uint256 p1, bool p2, uint256 p3) internal pure {
  9546 |     |         bytes32 m0;
  9547 |     |         bytes32 m1;
  9548 |     |         bytes32 m2;
  9549 |     |         bytes32 m3;
  9550 |     |         bytes32 m4;
  9551 |     |         /// @solidity memory-safe-assembly
  9552 |     |         assembly {
  9553 |     |             m0 := mload(0x00)
  9554 |     |             m1 := mload(0x20)
  9555 |     |             m2 := mload(0x40)
  9556 |     |             m3 := mload(0x60)
  9557 |     |             m4 := mload(0x80)
  9558 |     |             // Selector of `log(uint256,uint256,bool,uint256)`.
  9559 |     |             mstore(0x00, 0xeb7f6fd2)
  9560 |     |             mstore(0x20, p0)
  9561 |     |             mstore(0x40, p1)
  9562 |     |             mstore(0x60, p2)
  9563 |     |             mstore(0x80, p3)
  9564 |     |         }
  9565 |     |         _sendLogPayload(0x1c, 0x84);
  9566 |     |         /// @solidity memory-safe-assembly
  9567 |     |         assembly {
  9568 |     |             mstore(0x00, m0)
  9569 |     |             mstore(0x20, m1)
  9570 |     |             mstore(0x40, m2)
  9571 |     |             mstore(0x60, m3)
  9572 |     |             mstore(0x80, m4)
  9573 |     |         }
  9574 |     |     }
  9575 |     | 
  9576 |     |     function log(uint256 p0, uint256 p1, bool p2, bytes32 p3) internal pure {
  9577 |     |         bytes32 m0;
  9578 |     |         bytes32 m1;
  9579 |     |         bytes32 m2;
  9580 |     |         bytes32 m3;
  9581 |     |         bytes32 m4;
  9582 |     |         bytes32 m5;
  9583 |     |         bytes32 m6;
  9584 |     |         /// @solidity memory-safe-assembly
  9585 |     |         assembly {
  9586 |     |             function writeString(pos, w) {
  9587 |     |                 let length := 0
  9588 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  9589 |     |                 mstore(pos, length)
  9590 |     |                 let shift := sub(256, shl(3, length))
  9591 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  9592 |     |             }
  9593 |     |             m0 := mload(0x00)
  9594 |     |             m1 := mload(0x20)
  9595 |     |             m2 := mload(0x40)
  9596 |     |             m3 := mload(0x60)
  9597 |     |             m4 := mload(0x80)
  9598 |     |             m5 := mload(0xa0)
  9599 |     |             m6 := mload(0xc0)
  9600 |     |             // Selector of `log(uint256,uint256,bool,string)`.
  9601 |     |             mstore(0x00, 0xa5b4fc99)
  9602 |     |             mstore(0x20, p0)
  9603 |     |             mstore(0x40, p1)
  9604 |     |             mstore(0x60, p2)
  9605 |     |             mstore(0x80, 0x80)
  9606 |     |             writeString(0xa0, p3)
  9607 |     |         }
  9608 |     |         _sendLogPayload(0x1c, 0xc4);
  9609 |     |         /// @solidity memory-safe-assembly
  9610 |     |         assembly {
  9611 |     |             mstore(0x00, m0)
  9612 |     |             mstore(0x20, m1)
  9613 |     |             mstore(0x40, m2)
  9614 |     |             mstore(0x60, m3)
  9615 |     |             mstore(0x80, m4)
  9616 |     |             mstore(0xa0, m5)
  9617 |     |             mstore(0xc0, m6)
  9618 |     |         }
  9619 |     |     }
  9620 |     | 
  9621 |     |     function log(uint256 p0, uint256 p1, uint256 p2, address p3) internal pure {
  9622 |     |         bytes32 m0;
  9623 |     |         bytes32 m1;
  9624 |     |         bytes32 m2;
  9625 |     |         bytes32 m3;
  9626 |     |         bytes32 m4;
  9627 |     |         /// @solidity memory-safe-assembly
  9628 |     |         assembly {
  9629 |     |             m0 := mload(0x00)
  9630 |     |             m1 := mload(0x20)
  9631 |     |             m2 := mload(0x40)
  9632 |     |             m3 := mload(0x60)
  9633 |     |             m4 := mload(0x80)
  9634 |     |             // Selector of `log(uint256,uint256,uint256,address)`.
  9635 |     |             mstore(0x00, 0xfa8185af)
  9636 |     |             mstore(0x20, p0)
  9637 |     |             mstore(0x40, p1)
  9638 |     |             mstore(0x60, p2)
  9639 |     |             mstore(0x80, p3)
  9640 |     |         }
  9641 |     |         _sendLogPayload(0x1c, 0x84);
  9642 |     |         /// @solidity memory-safe-assembly
  9643 |     |         assembly {
  9644 |     |             mstore(0x00, m0)
  9645 |     |             mstore(0x20, m1)
  9646 |     |             mstore(0x40, m2)
  9647 |     |             mstore(0x60, m3)
  9648 |     |             mstore(0x80, m4)
  9649 |     |         }
  9650 |     |     }
  9651 |     | 
  9652 |     |     function log(uint256 p0, uint256 p1, uint256 p2, bool p3) internal pure {
  9653 |     |         bytes32 m0;
  9654 |     |         bytes32 m1;
  9655 |     |         bytes32 m2;
  9656 |     |         bytes32 m3;
  9657 |     |         bytes32 m4;
  9658 |     |         /// @solidity memory-safe-assembly
  9659 |     |         assembly {
  9660 |     |             m0 := mload(0x00)
  9661 |     |             m1 := mload(0x20)
  9662 |     |             m2 := mload(0x40)
  9663 |     |             m3 := mload(0x60)
  9664 |     |             m4 := mload(0x80)
  9665 |     |             // Selector of `log(uint256,uint256,uint256,bool)`.
  9666 |     |             mstore(0x00, 0xc598d185)
  9667 |     |             mstore(0x20, p0)
  9668 |     |             mstore(0x40, p1)
  9669 |     |             mstore(0x60, p2)
  9670 |     |             mstore(0x80, p3)
  9671 |     |         }
  9672 |     |         _sendLogPayload(0x1c, 0x84);
  9673 |     |         /// @solidity memory-safe-assembly
  9674 |     |         assembly {
  9675 |     |             mstore(0x00, m0)
  9676 |     |             mstore(0x20, m1)
  9677 |     |             mstore(0x40, m2)
  9678 |     |             mstore(0x60, m3)
  9679 |     |             mstore(0x80, m4)
  9680 |     |         }
  9681 |     |     }
  9682 |     | 
  9683 |     |     function log(uint256 p0, uint256 p1, uint256 p2, uint256 p3) internal pure {
  9684 |     |         bytes32 m0;
  9685 |     |         bytes32 m1;
  9686 |     |         bytes32 m2;
  9687 |     |         bytes32 m3;
  9688 |     |         bytes32 m4;
  9689 |     |         /// @solidity memory-safe-assembly
  9690 |     |         assembly {
  9691 |     |             m0 := mload(0x00)
  9692 |     |             m1 := mload(0x20)
  9693 |     |             m2 := mload(0x40)
  9694 |     |             m3 := mload(0x60)
  9695 |     |             m4 := mload(0x80)
  9696 |     |             // Selector of `log(uint256,uint256,uint256,uint256)`.
  9697 |     |             mstore(0x00, 0x193fb800)
  9698 |     |             mstore(0x20, p0)
  9699 |     |             mstore(0x40, p1)
  9700 |     |             mstore(0x60, p2)
  9701 |     |             mstore(0x80, p3)
  9702 |     |         }
  9703 |     |         _sendLogPayload(0x1c, 0x84);
  9704 |     |         /// @solidity memory-safe-assembly
  9705 |     |         assembly {
  9706 |     |             mstore(0x00, m0)
  9707 |     |             mstore(0x20, m1)
  9708 |     |             mstore(0x40, m2)
  9709 |     |             mstore(0x60, m3)
  9710 |     |             mstore(0x80, m4)
  9711 |     |         }
  9712 |     |     }
  9713 |     | 
  9714 |     |     function log(uint256 p0, uint256 p1, uint256 p2, bytes32 p3) internal pure {
  9715 |     |         bytes32 m0;
  9716 |     |         bytes32 m1;
  9717 |     |         bytes32 m2;
  9718 |     |         bytes32 m3;
  9719 |     |         bytes32 m4;
  9720 |     |         bytes32 m5;
  9721 |     |         bytes32 m6;
  9722 |     |         /// @solidity memory-safe-assembly
  9723 |     |         assembly {
  9724 |     |             function writeString(pos, w) {
  9725 |     |                 let length := 0
  9726 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  9727 |     |                 mstore(pos, length)
  9728 |     |                 let shift := sub(256, shl(3, length))
  9729 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  9730 |     |             }
  9731 |     |             m0 := mload(0x00)
  9732 |     |             m1 := mload(0x20)
  9733 |     |             m2 := mload(0x40)
  9734 |     |             m3 := mload(0x60)
  9735 |     |             m4 := mload(0x80)
  9736 |     |             m5 := mload(0xa0)
  9737 |     |             m6 := mload(0xc0)
  9738 |     |             // Selector of `log(uint256,uint256,uint256,string)`.
  9739 |     |             mstore(0x00, 0x59cfcbe3)
  9740 |     |             mstore(0x20, p0)
  9741 |     |             mstore(0x40, p1)
  9742 |     |             mstore(0x60, p2)
  9743 |     |             mstore(0x80, 0x80)
  9744 |     |             writeString(0xa0, p3)
  9745 |     |         }
  9746 |     |         _sendLogPayload(0x1c, 0xc4);
  9747 |     |         /// @solidity memory-safe-assembly
  9748 |     |         assembly {
  9749 |     |             mstore(0x00, m0)
  9750 |     |             mstore(0x20, m1)
  9751 |     |             mstore(0x40, m2)
  9752 |     |             mstore(0x60, m3)
  9753 |     |             mstore(0x80, m4)
  9754 |     |             mstore(0xa0, m5)
  9755 |     |             mstore(0xc0, m6)
  9756 |     |         }
  9757 |     |     }
  9758 |     | 
  9759 |     |     function log(uint256 p0, uint256 p1, bytes32 p2, address p3) internal pure {
  9760 |     |         bytes32 m0;
  9761 |     |         bytes32 m1;
  9762 |     |         bytes32 m2;
  9763 |     |         bytes32 m3;
  9764 |     |         bytes32 m4;
  9765 |     |         bytes32 m5;
  9766 |     |         bytes32 m6;
  9767 |     |         /// @solidity memory-safe-assembly
  9768 |     |         assembly {
  9769 |     |             function writeString(pos, w) {
  9770 |     |                 let length := 0
  9771 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  9772 |     |                 mstore(pos, length)
  9773 |     |                 let shift := sub(256, shl(3, length))
  9774 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  9775 |     |             }
  9776 |     |             m0 := mload(0x00)
  9777 |     |             m1 := mload(0x20)
  9778 |     |             m2 := mload(0x40)
  9779 |     |             m3 := mload(0x60)
  9780 |     |             m4 := mload(0x80)
  9781 |     |             m5 := mload(0xa0)
  9782 |     |             m6 := mload(0xc0)
  9783 |     |             // Selector of `log(uint256,uint256,string,address)`.
  9784 |     |             mstore(0x00, 0x42d21db7)
  9785 |     |             mstore(0x20, p0)
  9786 |     |             mstore(0x40, p1)
  9787 |     |             mstore(0x60, 0x80)
  9788 |     |             mstore(0x80, p3)
  9789 |     |             writeString(0xa0, p2)
  9790 |     |         }
  9791 |     |         _sendLogPayload(0x1c, 0xc4);
  9792 |     |         /// @solidity memory-safe-assembly
  9793 |     |         assembly {
  9794 |     |             mstore(0x00, m0)
  9795 |     |             mstore(0x20, m1)
  9796 |     |             mstore(0x40, m2)
  9797 |     |             mstore(0x60, m3)
  9798 |     |             mstore(0x80, m4)
  9799 |     |             mstore(0xa0, m5)
  9800 |     |             mstore(0xc0, m6)
  9801 |     |         }
  9802 |     |     }
  9803 |     | 
  9804 |     |     function log(uint256 p0, uint256 p1, bytes32 p2, bool p3) internal pure {
  9805 |     |         bytes32 m0;
  9806 |     |         bytes32 m1;
  9807 |     |         bytes32 m2;
  9808 |     |         bytes32 m3;
  9809 |     |         bytes32 m4;
  9810 |     |         bytes32 m5;
  9811 |     |         bytes32 m6;
  9812 |     |         /// @solidity memory-safe-assembly
  9813 |     |         assembly {
  9814 |     |             function writeString(pos, w) {
  9815 |     |                 let length := 0
  9816 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  9817 |     |                 mstore(pos, length)
  9818 |     |                 let shift := sub(256, shl(3, length))
  9819 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  9820 |     |             }
  9821 |     |             m0 := mload(0x00)
  9822 |     |             m1 := mload(0x20)
  9823 |     |             m2 := mload(0x40)
  9824 |     |             m3 := mload(0x60)
  9825 |     |             m4 := mload(0x80)
  9826 |     |             m5 := mload(0xa0)
  9827 |     |             m6 := mload(0xc0)
  9828 |     |             // Selector of `log(uint256,uint256,string,bool)`.
  9829 |     |             mstore(0x00, 0x7af6ab25)
  9830 |     |             mstore(0x20, p0)
  9831 |     |             mstore(0x40, p1)
  9832 |     |             mstore(0x60, 0x80)
  9833 |     |             mstore(0x80, p3)
  9834 |     |             writeString(0xa0, p2)
  9835 |     |         }
  9836 |     |         _sendLogPayload(0x1c, 0xc4);
  9837 |     |         /// @solidity memory-safe-assembly
  9838 |     |         assembly {
  9839 |     |             mstore(0x00, m0)
  9840 |     |             mstore(0x20, m1)
  9841 |     |             mstore(0x40, m2)
  9842 |     |             mstore(0x60, m3)
  9843 |     |             mstore(0x80, m4)
  9844 |     |             mstore(0xa0, m5)
  9845 |     |             mstore(0xc0, m6)
  9846 |     |         }
  9847 |     |     }
  9848 |     | 
  9849 |     |     function log(uint256 p0, uint256 p1, bytes32 p2, uint256 p3) internal pure {
  9850 |     |         bytes32 m0;
  9851 |     |         bytes32 m1;
  9852 |     |         bytes32 m2;
  9853 |     |         bytes32 m3;
  9854 |     |         bytes32 m4;
  9855 |     |         bytes32 m5;
  9856 |     |         bytes32 m6;
  9857 |     |         /// @solidity memory-safe-assembly
  9858 |     |         assembly {
  9859 |     |             function writeString(pos, w) {
  9860 |     |                 let length := 0
  9861 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  9862 |     |                 mstore(pos, length)
  9863 |     |                 let shift := sub(256, shl(3, length))
  9864 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  9865 |     |             }
  9866 |     |             m0 := mload(0x00)
  9867 |     |             m1 := mload(0x20)
  9868 |     |             m2 := mload(0x40)
  9869 |     |             m3 := mload(0x60)
  9870 |     |             m4 := mload(0x80)
  9871 |     |             m5 := mload(0xa0)
  9872 |     |             m6 := mload(0xc0)
  9873 |     |             // Selector of `log(uint256,uint256,string,uint256)`.
  9874 |     |             mstore(0x00, 0x5da297eb)
  9875 |     |             mstore(0x20, p0)
  9876 |     |             mstore(0x40, p1)
  9877 |     |             mstore(0x60, 0x80)
  9878 |     |             mstore(0x80, p3)
  9879 |     |             writeString(0xa0, p2)
  9880 |     |         }
  9881 |     |         _sendLogPayload(0x1c, 0xc4);
  9882 |     |         /// @solidity memory-safe-assembly
  9883 |     |         assembly {
  9884 |     |             mstore(0x00, m0)
  9885 |     |             mstore(0x20, m1)
  9886 |     |             mstore(0x40, m2)
  9887 |     |             mstore(0x60, m3)
  9888 |     |             mstore(0x80, m4)
  9889 |     |             mstore(0xa0, m5)
  9890 |     |             mstore(0xc0, m6)
  9891 |     |         }
  9892 |     |     }
  9893 |     | 
  9894 |     |     function log(uint256 p0, uint256 p1, bytes32 p2, bytes32 p3) internal pure {
  9895 |     |         bytes32 m0;
  9896 |     |         bytes32 m1;
  9897 |     |         bytes32 m2;
  9898 |     |         bytes32 m3;
  9899 |     |         bytes32 m4;
  9900 |     |         bytes32 m5;
  9901 |     |         bytes32 m6;
  9902 |     |         bytes32 m7;
  9903 |     |         bytes32 m8;
  9904 |     |         /// @solidity memory-safe-assembly
  9905 |     |         assembly {
  9906 |     |             function writeString(pos, w) {
  9907 |     |                 let length := 0
  9908 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  9909 |     |                 mstore(pos, length)
  9910 |     |                 let shift := sub(256, shl(3, length))
  9911 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  9912 |     |             }
  9913 |     |             m0 := mload(0x00)
  9914 |     |             m1 := mload(0x20)
  9915 |     |             m2 := mload(0x40)
  9916 |     |             m3 := mload(0x60)
  9917 |     |             m4 := mload(0x80)
  9918 |     |             m5 := mload(0xa0)
  9919 |     |             m6 := mload(0xc0)
  9920 |     |             m7 := mload(0xe0)
  9921 |     |             m8 := mload(0x100)
  9922 |     |             // Selector of `log(uint256,uint256,string,string)`.
  9923 |     |             mstore(0x00, 0x27d8afd2)
  9924 |     |             mstore(0x20, p0)
  9925 |     |             mstore(0x40, p1)
  9926 |     |             mstore(0x60, 0x80)
  9927 |     |             mstore(0x80, 0xc0)
  9928 |     |             writeString(0xa0, p2)
  9929 |     |             writeString(0xe0, p3)
  9930 |     |         }
  9931 |     |         _sendLogPayload(0x1c, 0x104);
  9932 |     |         /// @solidity memory-safe-assembly
  9933 |     |         assembly {
  9934 |     |             mstore(0x00, m0)
  9935 |     |             mstore(0x20, m1)
  9936 |     |             mstore(0x40, m2)
  9937 |     |             mstore(0x60, m3)
  9938 |     |             mstore(0x80, m4)
  9939 |     |             mstore(0xa0, m5)
  9940 |     |             mstore(0xc0, m6)
  9941 |     |             mstore(0xe0, m7)
  9942 |     |             mstore(0x100, m8)
  9943 |     |         }
  9944 |     |     }
  9945 |     | 
  9946 |     |     function log(uint256 p0, bytes32 p1, address p2, address p3) internal pure {
  9947 |     |         bytes32 m0;
  9948 |     |         bytes32 m1;
  9949 |     |         bytes32 m2;
  9950 |     |         bytes32 m3;
  9951 |     |         bytes32 m4;
  9952 |     |         bytes32 m5;
  9953 |     |         bytes32 m6;
  9954 |     |         /// @solidity memory-safe-assembly
  9955 |     |         assembly {
  9956 |     |             function writeString(pos, w) {
  9957 |     |                 let length := 0
  9958 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  9959 |     |                 mstore(pos, length)
  9960 |     |                 let shift := sub(256, shl(3, length))
  9961 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  9962 |     |             }
  9963 |     |             m0 := mload(0x00)
  9964 |     |             m1 := mload(0x20)
  9965 |     |             m2 := mload(0x40)
  9966 |     |             m3 := mload(0x60)
  9967 |     |             m4 := mload(0x80)
  9968 |     |             m5 := mload(0xa0)
  9969 |     |             m6 := mload(0xc0)
  9970 |     |             // Selector of `log(uint256,string,address,address)`.
  9971 |     |             mstore(0x00, 0x6168ed61)
  9972 |     |             mstore(0x20, p0)
  9973 |     |             mstore(0x40, 0x80)
  9974 |     |             mstore(0x60, p2)
  9975 |     |             mstore(0x80, p3)
  9976 |     |             writeString(0xa0, p1)
  9977 |     |         }
  9978 |     |         _sendLogPayload(0x1c, 0xc4);
  9979 |     |         /// @solidity memory-safe-assembly
  9980 |     |         assembly {
  9981 |     |             mstore(0x00, m0)
  9982 |     |             mstore(0x20, m1)
  9983 |     |             mstore(0x40, m2)
  9984 |     |             mstore(0x60, m3)
  9985 |     |             mstore(0x80, m4)
  9986 |     |             mstore(0xa0, m5)
  9987 |     |             mstore(0xc0, m6)
  9988 |     |         }
  9989 |     |     }
  9990 |     | 
  9991 |     |     function log(uint256 p0, bytes32 p1, address p2, bool p3) internal pure {
  9992 |     |         bytes32 m0;
  9993 |     |         bytes32 m1;
  9994 |     |         bytes32 m2;
  9995 |     |         bytes32 m3;
  9996 |     |         bytes32 m4;
  9997 |     |         bytes32 m5;
  9998 |     |         bytes32 m6;
  9999 |     |         /// @solidity memory-safe-assembly
 10000 |     |         assembly {
 10001 |     |             function writeString(pos, w) {
 10002 |     |                 let length := 0
 10003 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
 10004 |     |                 mstore(pos, length)
 10005 |     |                 let shift := sub(256, shl(3, length))
 10006 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
 10007 |     |             }
 10008 |     |             m0 := mload(0x00)
 10009 |     |             m1 := mload(0x20)
 10010 |     |             m2 := mload(0x40)
 10011 |     |             m3 := mload(0x60)
 10012 |     |             m4 := mload(0x80)
 10013 |     |             m5 := mload(0xa0)
 10014 |     |             m6 := mload(0xc0)
 10015 |     |             // Selector of `log(uint256,string,address,bool)`.
 10016 |     |             mstore(0x00, 0x90c30a56)
 10017 |     |             mstore(0x20, p0)
 10018 |     |             mstore(0x40, 0x80)
 10019 |     |             mstore(0x60, p2)
 10020 |     |             mstore(0x80, p3)
 10021 |     |             writeString(0xa0, p1)
 10022 |     |         }
 10023 |     |         _sendLogPayload(0x1c, 0xc4);
 10024 |     |         /// @solidity memory-safe-assembly
 10025 |     |         assembly {
 10026 |     |             mstore(0x00, m0)
 10027 |     |             mstore(0x20, m1)
 10028 |     |             mstore(0x40, m2)
 10029 |     |             mstore(0x60, m3)
 10030 |     |             mstore(0x80, m4)
 10031 |     |             mstore(0xa0, m5)
 10032 |     |             mstore(0xc0, m6)
 10033 |     |         }
 10034 |     |     }
 10035 |     | 
 10036 |     |     function log(uint256 p0, bytes32 p1, address p2, uint256 p3) internal pure {
 10037 |     |         bytes32 m0;
 10038 |     |         bytes32 m1;
 10039 |     |         bytes32 m2;
 10040 |     |         bytes32 m3;
 10041 |     |         bytes32 m4;
 10042 |     |         bytes32 m5;
 10043 |     |         bytes32 m6;
 10044 |     |         /// @solidity memory-safe-assembly
 10045 |     |         assembly {
 10046 |     |             function writeString(pos, w) {
 10047 |     |                 let length := 0
 10048 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
 10049 |     |                 mstore(pos, length)
 10050 |     |                 let shift := sub(256, shl(3, length))
 10051 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
 10052 |     |             }
 10053 |     |             m0 := mload(0x00)
 10054 |     |             m1 := mload(0x20)
 10055 |     |             m2 := mload(0x40)
 10056 |     |             m3 := mload(0x60)
 10057 |     |             m4 := mload(0x80)
 10058 |     |             m5 := mload(0xa0)
 10059 |     |             m6 := mload(0xc0)
 10060 |     |             // Selector of `log(uint256,string,address,uint256)`.
 10061 |     |             mstore(0x00, 0xe8d3018d)
 10062 |     |             mstore(0x20, p0)
 10063 |     |             mstore(0x40, 0x80)
 10064 |     |             mstore(0x60, p2)
 10065 |     |             mstore(0x80, p3)
 10066 |     |             writeString(0xa0, p1)
 10067 |     |         }
 10068 |     |         _sendLogPayload(0x1c, 0xc4);
 10069 |     |         /// @solidity memory-safe-assembly
 10070 |     |         assembly {
 10071 |     |             mstore(0x00, m0)
 10072 |     |             mstore(0x20, m1)
 10073 |     |             mstore(0x40, m2)
 10074 |     |             mstore(0x60, m3)
 10075 |     |             mstore(0x80, m4)
 10076 |     |             mstore(0xa0, m5)
 10077 |     |             mstore(0xc0, m6)
 10078 |     |         }
 10079 |     |     }
 10080 |     | 
 10081 |     |     function log(uint256 p0, bytes32 p1, address p2, bytes32 p3) internal pure {
 10082 |     |         bytes32 m0;
 10083 |     |         bytes32 m1;
 10084 |     |         bytes32 m2;
 10085 |     |         bytes32 m3;
 10086 |     |         bytes32 m4;
 10087 |     |         bytes32 m5;
 10088 |     |         bytes32 m6;
 10089 |     |         bytes32 m7;
 10090 |     |         bytes32 m8;
 10091 |     |         /// @solidity memory-safe-assembly
 10092 |     |         assembly {
 10093 |     |             function writeString(pos, w) {
 10094 |     |                 let length := 0
 10095 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
 10096 |     |                 mstore(pos, length)
 10097 |     |                 let shift := sub(256, shl(3, length))
 10098 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
 10099 |     |             }
 10100 |     |             m0 := mload(0x00)
 10101 |     |             m1 := mload(0x20)
 10102 |     |             m2 := mload(0x40)
 10103 |     |             m3 := mload(0x60)
 10104 |     |             m4 := mload(0x80)
 10105 |     |             m5 := mload(0xa0)
 10106 |     |             m6 := mload(0xc0)
 10107 |     |             m7 := mload(0xe0)
 10108 |     |             m8 := mload(0x100)
 10109 |     |             // Selector of `log(uint256,string,address,string)`.
 10110 |     |             mstore(0x00, 0x9c3adfa1)
 10111 |     |             mstore(0x20, p0)
 10112 |     |             mstore(0x40, 0x80)
 10113 |     |             mstore(0x60, p2)
 10114 |     |             mstore(0x80, 0xc0)
 10115 |     |             writeString(0xa0, p1)
 10116 |     |             writeString(0xe0, p3)
 10117 |     |         }
 10118 |     |         _sendLogPayload(0x1c, 0x104);
 10119 |     |         /// @solidity memory-safe-assembly
 10120 |     |         assembly {
 10121 |     |             mstore(0x00, m0)
 10122 |     |             mstore(0x20, m1)
 10123 |     |             mstore(0x40, m2)
 10124 |     |             mstore(0x60, m3)
 10125 |     |             mstore(0x80, m4)
 10126 |     |             mstore(0xa0, m5)
 10127 |     |             mstore(0xc0, m6)
 10128 |     |             mstore(0xe0, m7)
 10129 |     |             mstore(0x100, m8)
 10130 |     |         }
 10131 |     |     }
 10132 |     | 
 10133 |     |     function log(uint256 p0, bytes32 p1, bool p2, address p3) internal pure {
 10134 |     |         bytes32 m0;
 10135 |     |         bytes32 m1;
 10136 |     |         bytes32 m2;
 10137 |     |         bytes32 m3;
 10138 |     |         bytes32 m4;
 10139 |     |         bytes32 m5;
 10140 |     |         bytes32 m6;
 10141 |     |         /// @solidity memory-safe-assembly
 10142 |     |         assembly {
 10143 |     |             function writeString(pos, w) {
 10144 |     |                 let length := 0
 10145 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
 10146 |     |                 mstore(pos, length)
 10147 |     |                 let shift := sub(256, shl(3, length))
 10148 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
 10149 |     |             }
 10150 |     |             m0 := mload(0x00)
 10151 |     |             m1 := mload(0x20)
 10152 |     |             m2 := mload(0x40)
 10153 |     |             m3 := mload(0x60)
 10154 |     |             m4 := mload(0x80)
 10155 |     |             m5 := mload(0xa0)
 10156 |     |             m6 := mload(0xc0)
 10157 |     |             // Selector of `log(uint256,string,bool,address)`.
 10158 |     |             mstore(0x00, 0xae2ec581)
 10159 |     |             mstore(0x20, p0)
 10160 |     |             mstore(0x40, 0x80)
 10161 |     |             mstore(0x60, p2)
 10162 |     |             mstore(0x80, p3)
 10163 |     |             writeString(0xa0, p1)
 10164 |     |         }
 10165 |     |         _sendLogPayload(0x1c, 0xc4);
 10166 |     |         /// @solidity memory-safe-assembly
 10167 |     |         assembly {
 10168 |     |             mstore(0x00, m0)
 10169 |     |             mstore(0x20, m1)
 10170 |     |             mstore(0x40, m2)
 10171 |     |             mstore(0x60, m3)
 10172 |     |             mstore(0x80, m4)
 10173 |     |             mstore(0xa0, m5)
 10174 |     |             mstore(0xc0, m6)
 10175 |     |         }
 10176 |     |     }
 10177 |     | 
 10178 |     |     function log(uint256 p0, bytes32 p1, bool p2, bool p3) internal pure {
 10179 |     |         bytes32 m0;
 10180 |     |         bytes32 m1;
 10181 |     |         bytes32 m2;
 10182 |     |         bytes32 m3;
 10183 |     |         bytes32 m4;
 10184 |     |         bytes32 m5;
 10185 |     |         bytes32 m6;
 10186 |     |         /// @solidity memory-safe-assembly
 10187 |     |         assembly {
 10188 |     |             function writeString(pos, w) {
 10189 |     |                 let length := 0
 10190 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
 10191 |     |                 mstore(pos, length)
 10192 |     |                 let shift := sub(256, shl(3, length))
 10193 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
 10194 |     |             }
 10195 |     |             m0 := mload(0x00)
 10196 |     |             m1 := mload(0x20)
 10197 |     |             m2 := mload(0x40)
 10198 |     |             m3 := mload(0x60)
 10199 |     |             m4 := mload(0x80)
 10200 |     |             m5 := mload(0xa0)
 10201 |     |             m6 := mload(0xc0)
 10202 |     |             // Selector of `log(uint256,string,bool,bool)`.
 10203 |     |             mstore(0x00, 0xba535d9c)
 10204 |     |             mstore(0x20, p0)
 10205 |     |             mstore(0x40, 0x80)
 10206 |     |             mstore(0x60, p2)
 10207 |     |             mstore(0x80, p3)
 10208 |     |             writeString(0xa0, p1)
 10209 |     |         }
 10210 |     |         _sendLogPayload(0x1c, 0xc4);
 10211 |     |         /// @solidity memory-safe-assembly
 10212 |     |         assembly {
 10213 |     |             mstore(0x00, m0)
 10214 |     |             mstore(0x20, m1)
 10215 |     |             mstore(0x40, m2)
 10216 |     |             mstore(0x60, m3)
 10217 |     |             mstore(0x80, m4)
 10218 |     |             mstore(0xa0, m5)
 10219 |     |             mstore(0xc0, m6)
 10220 |     |         }
 10221 |     |     }
 10222 |     | 
 10223 |     |     function log(uint256 p0, bytes32 p1, bool p2, uint256 p3) internal pure {
 10224 |     |         bytes32 m0;
 10225 |     |         bytes32 m1;
 10226 |     |         bytes32 m2;
 10227 |     |         bytes32 m3;
 10228 |     |         bytes32 m4;
 10229 |     |         bytes32 m5;
 10230 |     |         bytes32 m6;
 10231 |     |         /// @solidity memory-safe-assembly
 10232 |     |         assembly {
 10233 |     |             function writeString(pos, w) {
 10234 |     |                 let length := 0
 10235 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
 10236 |     |                 mstore(pos, length)
 10237 |     |                 let shift := sub(256, shl(3, length))
 10238 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
 10239 |     |             }
 10240 |     |             m0 := mload(0x00)
 10241 |     |             m1 := mload(0x20)
 10242 |     |             m2 := mload(0x40)
 10243 |     |             m3 := mload(0x60)
 10244 |     |             m4 := mload(0x80)
 10245 |     |             m5 := mload(0xa0)
 10246 |     |             m6 := mload(0xc0)
 10247 |     |             // Selector of `log(uint256,string,bool,uint256)`.
 10248 |     |             mstore(0x00, 0xcf009880)
 10249 |     |             mstore(0x20, p0)
 10250 |     |             mstore(0x40, 0x80)
 10251 |     |             mstore(0x60, p2)
 10252 |     |             mstore(0x80, p3)
 10253 |     |             writeString(0xa0, p1)
 10254 |     |         }
 10255 |     |         _sendLogPayload(0x1c, 0xc4);
 10256 |     |         /// @solidity memory-safe-assembly
 10257 |     |         assembly {
 10258 |     |             mstore(0x00, m0)
 10259 |     |             mstore(0x20, m1)
 10260 |     |             mstore(0x40, m2)
 10261 |     |             mstore(0x60, m3)
 10262 |     |             mstore(0x80, m4)
 10263 |     |             mstore(0xa0, m5)
 10264 |     |             mstore(0xc0, m6)
 10265 |     |         }
 10266 |     |     }
 10267 |     | 
 10268 |     |     function log(uint256 p0, bytes32 p1, bool p2, bytes32 p3) internal pure {
 10269 |     |         bytes32 m0;
 10270 |     |         bytes32 m1;
 10271 |     |         bytes32 m2;
 10272 |     |         bytes32 m3;
 10273 |     |         bytes32 m4;
 10274 |     |         bytes32 m5;
 10275 |     |         bytes32 m6;
 10276 |     |         bytes32 m7;
 10277 |     |         bytes32 m8;
 10278 |     |         /// @solidity memory-safe-assembly
 10279 |     |         assembly {
 10280 |     |             function writeString(pos, w) {
 10281 |     |                 let length := 0
 10282 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
 10283 |     |                 mstore(pos, length)
 10284 |     |                 let shift := sub(256, shl(3, length))
 10285 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
 10286 |     |             }
 10287 |     |             m0 := mload(0x00)
 10288 |     |             m1 := mload(0x20)
 10289 |     |             m2 := mload(0x40)
 10290 |     |             m3 := mload(0x60)
 10291 |     |             m4 := mload(0x80)
 10292 |     |             m5 := mload(0xa0)
 10293 |     |             m6 := mload(0xc0)
 10294 |     |             m7 := mload(0xe0)
 10295 |     |             m8 := mload(0x100)
 10296 |     |             // Selector of `log(uint256,string,bool,string)`.
 10297 |     |             mstore(0x00, 0xd2d423cd)
 10298 |     |             mstore(0x20, p0)
 10299 |     |             mstore(0x40, 0x80)
 10300 |     |             mstore(0x60, p2)
 10301 |     |             mstore(0x80, 0xc0)
 10302 |     |             writeString(0xa0, p1)
 10303 |     |             writeString(0xe0, p3)
 10304 |     |         }
 10305 |     |         _sendLogPayload(0x1c, 0x104);
 10306 |     |         /// @solidity memory-safe-assembly
 10307 |     |         assembly {
 10308 |     |             mstore(0x00, m0)
 10309 |     |             mstore(0x20, m1)
 10310 |     |             mstore(0x40, m2)
 10311 |     |             mstore(0x60, m3)
 10312 |     |             mstore(0x80, m4)
 10313 |     |             mstore(0xa0, m5)
 10314 |     |             mstore(0xc0, m6)
 10315 |     |             mstore(0xe0, m7)
 10316 |     |             mstore(0x100, m8)
 10317 |     |         }
 10318 |     |     }
 10319 |     | 
 10320 |     |     function log(uint256 p0, bytes32 p1, uint256 p2, address p3) internal pure {
 10321 |     |         bytes32 m0;
 10322 |     |         bytes32 m1;
 10323 |     |         bytes32 m2;
 10324 |     |         bytes32 m3;
 10325 |     |         bytes32 m4;
 10326 |     |         bytes32 m5;
 10327 |     |         bytes32 m6;
 10328 |     |         /// @solidity memory-safe-assembly
 10329 |     |         assembly {
 10330 |     |             function writeString(pos, w) {
 10331 |     |                 let length := 0
 10332 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
 10333 |     |                 mstore(pos, length)
 10334 |     |                 let shift := sub(256, shl(3, length))
 10335 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
 10336 |     |             }
 10337 |     |             m0 := mload(0x00)
 10338 |     |             m1 := mload(0x20)
 10339 |     |             m2 := mload(0x40)
 10340 |     |             m3 := mload(0x60)
 10341 |     |             m4 := mload(0x80)
 10342 |     |             m5 := mload(0xa0)
 10343 |     |             m6 := mload(0xc0)
 10344 |     |             // Selector of `log(uint256,string,uint256,address)`.
 10345 |     |             mstore(0x00, 0x3b2279b4)
 10346 |     |             mstore(0x20, p0)
 10347 |     |             mstore(0x40, 0x80)
 10348 |     |             mstore(0x60, p2)
 10349 |     |             mstore(0x80, p3)
 10350 |     |             writeString(0xa0, p1)
 10351 |     |         }
 10352 |     |         _sendLogPayload(0x1c, 0xc4);
 10353 |     |         /// @solidity memory-safe-assembly
 10354 |     |         assembly {
 10355 |     |             mstore(0x00, m0)
 10356 |     |             mstore(0x20, m1)
 10357 |     |             mstore(0x40, m2)
 10358 |     |             mstore(0x60, m3)
 10359 |     |             mstore(0x80, m4)
 10360 |     |             mstore(0xa0, m5)
 10361 |     |             mstore(0xc0, m6)
 10362 |     |         }
 10363 |     |     }
 10364 |     | 
 10365 |     |     function log(uint256 p0, bytes32 p1, uint256 p2, bool p3) internal pure {
 10366 |     |         bytes32 m0;
 10367 |     |         bytes32 m1;
 10368 |     |         bytes32 m2;
 10369 |     |         bytes32 m3;
 10370 |     |         bytes32 m4;
 10371 |     |         bytes32 m5;
 10372 |     |         bytes32 m6;
 10373 |     |         /// @solidity memory-safe-assembly
 10374 |     |         assembly {
 10375 |     |             function writeString(pos, w) {
 10376 |     |                 let length := 0
 10377 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
 10378 |     |                 mstore(pos, length)
 10379 |     |                 let shift := sub(256, shl(3, length))
 10380 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
 10381 |     |             }
 10382 |     |             m0 := mload(0x00)
 10383 |     |             m1 := mload(0x20)
 10384 |     |             m2 := mload(0x40)
 10385 |     |             m3 := mload(0x60)
 10386 |     |             m4 := mload(0x80)
 10387 |     |             m5 := mload(0xa0)
 10388 |     |             m6 := mload(0xc0)
 10389 |     |             // Selector of `log(uint256,string,uint256,bool)`.
 10390 |     |             mstore(0x00, 0x691a8f74)
 10391 |     |             mstore(0x20, p0)
 10392 |     |             mstore(0x40, 0x80)
 10393 |     |             mstore(0x60, p2)
 10394 |     |             mstore(0x80, p3)
 10395 |     |             writeString(0xa0, p1)
 10396 |     |         }
 10397 |     |         _sendLogPayload(0x1c, 0xc4);
 10398 |     |         /// @solidity memory-safe-assembly
 10399 |     |         assembly {
 10400 |     |             mstore(0x00, m0)
 10401 |     |             mstore(0x20, m1)
 10402 |     |             mstore(0x40, m2)
 10403 |     |             mstore(0x60, m3)
 10404 |     |             mstore(0x80, m4)
 10405 |     |             mstore(0xa0, m5)
 10406 |     |             mstore(0xc0, m6)
 10407 |     |         }
 10408 |     |     }
 10409 |     | 
 10410 |     |     function log(uint256 p0, bytes32 p1, uint256 p2, uint256 p3) internal pure {
 10411 |     |         bytes32 m0;
 10412 |     |         bytes32 m1;
 10413 |     |         bytes32 m2;
 10414 |     |         bytes32 m3;
 10415 |     |         bytes32 m4;
 10416 |     |         bytes32 m5;
 10417 |     |         bytes32 m6;
 10418 |     |         /// @solidity memory-safe-assembly
 10419 |     |         assembly {
 10420 |     |             function writeString(pos, w) {
 10421 |     |                 let length := 0
 10422 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
 10423 |     |                 mstore(pos, length)
 10424 |     |                 let shift := sub(256, shl(3, length))
 10425 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
 10426 |     |             }
 10427 |     |             m0 := mload(0x00)
 10428 |     |             m1 := mload(0x20)
 10429 |     |             m2 := mload(0x40)
 10430 |     |             m3 := mload(0x60)
 10431 |     |             m4 := mload(0x80)
 10432 |     |             m5 := mload(0xa0)
 10433 |     |             m6 := mload(0xc0)
 10434 |     |             // Selector of `log(uint256,string,uint256,uint256)`.
 10435 |     |             mstore(0x00, 0x82c25b74)
 10436 |     |             mstore(0x20, p0)
 10437 |     |             mstore(0x40, 0x80)
 10438 |     |             mstore(0x60, p2)
 10439 |     |             mstore(0x80, p3)
 10440 |     |             writeString(0xa0, p1)
 10441 |     |         }
 10442 |     |         _sendLogPayload(0x1c, 0xc4);
 10443 |     |         /// @solidity memory-safe-assembly
 10444 |     |         assembly {
 10445 |     |             mstore(0x00, m0)
 10446 |     |             mstore(0x20, m1)
 10447 |     |             mstore(0x40, m2)
 10448 |     |             mstore(0x60, m3)
 10449 |     |             mstore(0x80, m4)
 10450 |     |             mstore(0xa0, m5)
 10451 |     |             mstore(0xc0, m6)
 10452 |     |         }
 10453 |     |     }
 10454 |     | 
 10455 |     |     function log(uint256 p0, bytes32 p1, uint256 p2, bytes32 p3) internal pure {
 10456 |     |         bytes32 m0;
 10457 |     |         bytes32 m1;
 10458 |     |         bytes32 m2;
 10459 |     |         bytes32 m3;
 10460 |     |         bytes32 m4;
 10461 |     |         bytes32 m5;
 10462 |     |         bytes32 m6;
 10463 |     |         bytes32 m7;
 10464 |     |         bytes32 m8;
 10465 |     |         /// @solidity memory-safe-assembly
 10466 |     |         assembly {
 10467 |     |             function writeString(pos, w) {
 10468 |     |                 let length := 0
 10469 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
 10470 |     |                 mstore(pos, length)
 10471 |     |                 let shift := sub(256, shl(3, length))
 10472 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
 10473 |     |             }
 10474 |     |             m0 := mload(0x00)
 10475 |     |             m1 := mload(0x20)
 10476 |     |             m2 := mload(0x40)
 10477 |     |             m3 := mload(0x60)
 10478 |     |             m4 := mload(0x80)
 10479 |     |             m5 := mload(0xa0)
 10480 |     |             m6 := mload(0xc0)
 10481 |     |             m7 := mload(0xe0)
 10482 |     |             m8 := mload(0x100)
 10483 |     |             // Selector of `log(uint256,string,uint256,string)`.
 10484 |     |             mstore(0x00, 0xb7b914ca)
 10485 |     |             mstore(0x20, p0)
 10486 |     |             mstore(0x40, 0x80)
 10487 |     |             mstore(0x60, p2)
 10488 |     |             mstore(0x80, 0xc0)
 10489 |     |             writeString(0xa0, p1)
 10490 |     |             writeString(0xe0, p3)
 10491 |     |         }
 10492 |     |         _sendLogPayload(0x1c, 0x104);
 10493 |     |         /// @solidity memory-safe-assembly
 10494 |     |         assembly {
 10495 |     |             mstore(0x00, m0)
 10496 |     |             mstore(0x20, m1)
 10497 |     |             mstore(0x40, m2)
 10498 |     |             mstore(0x60, m3)
 10499 |     |             mstore(0x80, m4)
 10500 |     |             mstore(0xa0, m5)
 10501 |     |             mstore(0xc0, m6)
 10502 |     |             mstore(0xe0, m7)
 10503 |     |             mstore(0x100, m8)
 10504 |     |         }
 10505 |     |     }
 10506 |     | 
 10507 |     |     function log(uint256 p0, bytes32 p1, bytes32 p2, address p3) internal pure {
 10508 |     |         bytes32 m0;
 10509 |     |         bytes32 m1;
 10510 |     |         bytes32 m2;
 10511 |     |         bytes32 m3;
 10512 |     |         bytes32 m4;
 10513 |     |         bytes32 m5;
 10514 |     |         bytes32 m6;
 10515 |     |         bytes32 m7;
 10516 |     |         bytes32 m8;
 10517 |     |         /// @solidity memory-safe-assembly
 10518 |     |         assembly {
 10519 |     |             function writeString(pos, w) {
 10520 |     |                 let length := 0
 10521 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
 10522 |     |                 mstore(pos, length)
 10523 |     |                 let shift := sub(256, shl(3, length))
 10524 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
 10525 |     |             }
 10526 |     |             m0 := mload(0x00)
 10527 |     |             m1 := mload(0x20)
 10528 |     |             m2 := mload(0x40)
 10529 |     |             m3 := mload(0x60)
 10530 |     |             m4 := mload(0x80)
 10531 |     |             m5 := mload(0xa0)
 10532 |     |             m6 := mload(0xc0)
 10533 |     |             m7 := mload(0xe0)
 10534 |     |             m8 := mload(0x100)
 10535 |     |             // Selector of `log(uint256,string,string,address)`.
 10536 |     |             mstore(0x00, 0xd583c602)
 10537 |     |             mstore(0x20, p0)
 10538 |     |             mstore(0x40, 0x80)
 10539 |     |             mstore(0x60, 0xc0)
 10540 |     |             mstore(0x80, p3)
 10541 |     |             writeString(0xa0, p1)
 10542 |     |             writeString(0xe0, p2)
 10543 |     |         }
 10544 |     |         _sendLogPayload(0x1c, 0x104);
 10545 |     |         /// @solidity memory-safe-assembly
 10546 |     |         assembly {
 10547 |     |             mstore(0x00, m0)
 10548 |     |             mstore(0x20, m1)
 10549 |     |             mstore(0x40, m2)
 10550 |     |             mstore(0x60, m3)
 10551 |     |             mstore(0x80, m4)
 10552 |     |             mstore(0xa0, m5)
 10553 |     |             mstore(0xc0, m6)
 10554 |     |             mstore(0xe0, m7)
 10555 |     |             mstore(0x100, m8)
 10556 |     |         }
 10557 |     |     }
 10558 |     | 
 10559 |     |     function log(uint256 p0, bytes32 p1, bytes32 p2, bool p3) internal pure {
 10560 |     |         bytes32 m0;
 10561 |     |         bytes32 m1;
 10562 |     |         bytes32 m2;
 10563 |     |         bytes32 m3;
 10564 |     |         bytes32 m4;
 10565 |     |         bytes32 m5;
 10566 |     |         bytes32 m6;
 10567 |     |         bytes32 m7;
 10568 |     |         bytes32 m8;
 10569 |     |         /// @solidity memory-safe-assembly
 10570 |     |         assembly {
 10571 |     |             function writeString(pos, w) {
 10572 |     |                 let length := 0
 10573 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
 10574 |     |                 mstore(pos, length)
 10575 |     |                 let shift := sub(256, shl(3, length))
 10576 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
 10577 |     |             }
 10578 |     |             m0 := mload(0x00)
 10579 |     |             m1 := mload(0x20)
 10580 |     |             m2 := mload(0x40)
 10581 |     |             m3 := mload(0x60)
 10582 |     |             m4 := mload(0x80)
 10583 |     |             m5 := mload(0xa0)
 10584 |     |             m6 := mload(0xc0)
 10585 |     |             m7 := mload(0xe0)
 10586 |     |             m8 := mload(0x100)
 10587 |     |             // Selector of `log(uint256,string,string,bool)`.
 10588 |     |             mstore(0x00, 0xb3a6b6bd)
 10589 |     |             mstore(0x20, p0)
 10590 |     |             mstore(0x40, 0x80)
 10591 |     |             mstore(0x60, 0xc0)
 10592 |     |             mstore(0x80, p3)
 10593 |     |             writeString(0xa0, p1)
 10594 |     |             writeString(0xe0, p2)
 10595 |     |         }
 10596 |     |         _sendLogPayload(0x1c, 0x104);
 10597 |     |         /// @solidity memory-safe-assembly
 10598 |     |         assembly {
 10599 |     |             mstore(0x00, m0)
 10600 |     |             mstore(0x20, m1)
 10601 |     |             mstore(0x40, m2)
 10602 |     |             mstore(0x60, m3)
 10603 |     |             mstore(0x80, m4)
 10604 |     |             mstore(0xa0, m5)
 10605 |     |             mstore(0xc0, m6)
 10606 |     |             mstore(0xe0, m7)
 10607 |     |             mstore(0x100, m8)
 10608 |     |         }
 10609 |     |     }
 10610 |     | 
 10611 |     |     function log(uint256 p0, bytes32 p1, bytes32 p2, uint256 p3) internal pure {
 10612 |     |         bytes32 m0;
 10613 |     |         bytes32 m1;
 10614 |     |         bytes32 m2;
 10615 |     |         bytes32 m3;
 10616 |     |         bytes32 m4;
 10617 |     |         bytes32 m5;
 10618 |     |         bytes32 m6;
 10619 |     |         bytes32 m7;
 10620 |     |         bytes32 m8;
 10621 |     |         /// @solidity memory-safe-assembly
 10622 |     |         assembly {
 10623 |     |             function writeString(pos, w) {
 10624 |     |                 let length := 0
 10625 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
 10626 |     |                 mstore(pos, length)
 10627 |     |                 let shift := sub(256, shl(3, length))
 10628 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
 10629 |     |             }
 10630 |     |             m0 := mload(0x00)
 10631 |     |             m1 := mload(0x20)
 10632 |     |             m2 := mload(0x40)
 10633 |     |             m3 := mload(0x60)
 10634 |     |             m4 := mload(0x80)
 10635 |     |             m5 := mload(0xa0)
 10636 |     |             m6 := mload(0xc0)
 10637 |     |             m7 := mload(0xe0)
 10638 |     |             m8 := mload(0x100)
 10639 |     |             // Selector of `log(uint256,string,string,uint256)`.
 10640 |     |             mstore(0x00, 0xb028c9bd)
 10641 |     |             mstore(0x20, p0)
 10642 |     |             mstore(0x40, 0x80)
 10643 |     |             mstore(0x60, 0xc0)
 10644 |     |             mstore(0x80, p3)
 10645 |     |             writeString(0xa0, p1)
 10646 |     |             writeString(0xe0, p2)
 10647 |     |         }
 10648 |     |         _sendLogPayload(0x1c, 0x104);
 10649 |     |         /// @solidity memory-safe-assembly
 10650 |     |         assembly {
 10651 |     |             mstore(0x00, m0)
 10652 |     |             mstore(0x20, m1)
 10653 |     |             mstore(0x40, m2)
 10654 |     |             mstore(0x60, m3)
 10655 |     |             mstore(0x80, m4)
 10656 |     |             mstore(0xa0, m5)
 10657 |     |             mstore(0xc0, m6)
 10658 |     |             mstore(0xe0, m7)
 10659 |     |             mstore(0x100, m8)
 10660 |     |         }
 10661 |     |     }
 10662 |     | 
 10663 |     |     function log(uint256 p0, bytes32 p1, bytes32 p2, bytes32 p3) internal pure {
 10664 |     |         bytes32 m0;
 10665 |     |         bytes32 m1;
 10666 |     |         bytes32 m2;
 10667 |     |         bytes32 m3;
 10668 |     |         bytes32 m4;
 10669 |     |         bytes32 m5;
 10670 |     |         bytes32 m6;
 10671 |     |         bytes32 m7;
 10672 |     |         bytes32 m8;
 10673 |     |         bytes32 m9;
 10674 |     |         bytes32 m10;
 10675 |     |         /// @solidity memory-safe-assembly
 10676 |     |         assembly {
 10677 |     |             function writeString(pos, w) {
 10678 |     |                 let length := 0
 10679 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
 10680 |     |                 mstore(pos, length)
 10681 |     |                 let shift := sub(256, shl(3, length))
 10682 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
 10683 |     |             }
 10684 |     |             m0 := mload(0x00)
 10685 |     |             m1 := mload(0x20)
 10686 |     |             m2 := mload(0x40)
 10687 |     |             m3 := mload(0x60)
 10688 |     |             m4 := mload(0x80)
 10689 |     |             m5 := mload(0xa0)
 10690 |     |             m6 := mload(0xc0)
 10691 |     |             m7 := mload(0xe0)
 10692 |     |             m8 := mload(0x100)
 10693 |     |             m9 := mload(0x120)
 10694 |     |             m10 := mload(0x140)
 10695 |     |             // Selector of `log(uint256,string,string,string)`.
 10696 |     |             mstore(0x00, 0x21ad0683)
 10697 |     |             mstore(0x20, p0)
 10698 |     |             mstore(0x40, 0x80)
 10699 |     |             mstore(0x60, 0xc0)
 10700 |     |             mstore(0x80, 0x100)
 10701 |     |             writeString(0xa0, p1)
 10702 |     |             writeString(0xe0, p2)
 10703 |     |             writeString(0x120, p3)
 10704 |     |         }
 10705 |     |         _sendLogPayload(0x1c, 0x144);
 10706 |     |         /// @solidity memory-safe-assembly
 10707 |     |         assembly {
 10708 |     |             mstore(0x00, m0)
 10709 |     |             mstore(0x20, m1)
 10710 |     |             mstore(0x40, m2)
 10711 |     |             mstore(0x60, m3)
 10712 |     |             mstore(0x80, m4)
 10713 |     |             mstore(0xa0, m5)
 10714 |     |             mstore(0xc0, m6)
 10715 |     |             mstore(0xe0, m7)
 10716 |     |             mstore(0x100, m8)
 10717 |     |             mstore(0x120, m9)
 10718 |     |             mstore(0x140, m10)
 10719 |     |         }
 10720 |     |     }
 10721 |     | 
 10722 |     |     function log(bytes32 p0, address p1, address p2, address p3) internal pure {
 10723 |     |         bytes32 m0;
 10724 |     |         bytes32 m1;
 10725 |     |         bytes32 m2;
 10726 |     |         bytes32 m3;
 10727 |     |         bytes32 m4;
 10728 |     |         bytes32 m5;
 10729 |     |         bytes32 m6;
 10730 |     |         /// @solidity memory-safe-assembly
 10731 |     |         assembly {
 10732 |     |             function writeString(pos, w) {
 10733 |     |                 let length := 0
 10734 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
 10735 |     |                 mstore(pos, length)
 10736 |     |                 let shift := sub(256, shl(3, length))
 10737 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
 10738 |     |             }
 10739 |     |             m0 := mload(0x00)
 10740 |     |             m1 := mload(0x20)
 10741 |     |             m2 := mload(0x40)
 10742 |     |             m3 := mload(0x60)
 10743 |     |             m4 := mload(0x80)
 10744 |     |             m5 := mload(0xa0)
 10745 |     |             m6 := mload(0xc0)
 10746 |     |             // Selector of `log(string,address,address,address)`.
 10747 |     |             mstore(0x00, 0xed8f28f6)
 10748 |     |             mstore(0x20, 0x80)
 10749 |     |             mstore(0x40, p1)
 10750 |     |             mstore(0x60, p2)
 10751 |     |             mstore(0x80, p3)
 10752 |     |             writeString(0xa0, p0)
 10753 |     |         }
 10754 |     |         _sendLogPayload(0x1c, 0xc4);
 10755 |     |         /// @solidity memory-safe-assembly
 10756 |     |         assembly {
 10757 |     |             mstore(0x00, m0)
 10758 |     |             mstore(0x20, m1)
 10759 |     |             mstore(0x40, m2)
 10760 |     |             mstore(0x60, m3)
 10761 |     |             mstore(0x80, m4)
 10762 |     |             mstore(0xa0, m5)
 10763 |     |             mstore(0xc0, m6)
 10764 |     |         }
 10765 |     |     }
 10766 |     | 
 10767 |     |     function log(bytes32 p0, address p1, address p2, bool p3) internal pure {
 10768 |     |         bytes32 m0;
 10769 |     |         bytes32 m1;
 10770 |     |         bytes32 m2;
 10771 |     |         bytes32 m3;
 10772 |     |         bytes32 m4;
 10773 |     |         bytes32 m5;
 10774 |     |         bytes32 m6;
 10775 |     |         /// @solidity memory-safe-assembly
 10776 |     |         assembly {
 10777 |     |             function writeString(pos, w) {
 10778 |     |                 let length := 0
 10779 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
 10780 |     |                 mstore(pos, length)
 10781 |     |                 let shift := sub(256, shl(3, length))
 10782 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
 10783 |     |             }
 10784 |     |             m0 := mload(0x00)
 10785 |     |             m1 := mload(0x20)
 10786 |     |             m2 := mload(0x40)
 10787 |     |             m3 := mload(0x60)
 10788 |     |             m4 := mload(0x80)
 10789 |     |             m5 := mload(0xa0)
 10790 |     |             m6 := mload(0xc0)
 10791 |     |             // Selector of `log(string,address,address,bool)`.
 10792 |     |             mstore(0x00, 0xb59dbd60)
 10793 |     |             mstore(0x20, 0x80)
 10794 |     |             mstore(0x40, p1)
 10795 |     |             mstore(0x60, p2)
 10796 |     |             mstore(0x80, p3)
 10797 |     |             writeString(0xa0, p0)
 10798 |     |         }
 10799 |     |         _sendLogPayload(0x1c, 0xc4);
 10800 |     |         /// @solidity memory-safe-assembly
 10801 |     |         assembly {
 10802 |     |             mstore(0x00, m0)
 10803 |     |             mstore(0x20, m1)
 10804 |     |             mstore(0x40, m2)
 10805 |     |             mstore(0x60, m3)
 10806 |     |             mstore(0x80, m4)
 10807 |     |             mstore(0xa0, m5)
 10808 |     |             mstore(0xc0, m6)
 10809 |     |         }
 10810 |     |     }
 10811 |     | 
 10812 |     |     function log(bytes32 p0, address p1, address p2, uint256 p3) internal pure {
 10813 |     |         bytes32 m0;
 10814 |     |         bytes32 m1;
 10815 |     |         bytes32 m2;
 10816 |     |         bytes32 m3;
 10817 |     |         bytes32 m4;
 10818 |     |         bytes32 m5;
 10819 |     |         bytes32 m6;
 10820 |     |         /// @solidity memory-safe-assembly
 10821 |     |         assembly {
 10822 |     |             function writeString(pos, w) {
 10823 |     |                 let length := 0
 10824 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
 10825 |     |                 mstore(pos, length)
 10826 |     |                 let shift := sub(256, shl(3, length))
 10827 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
 10828 |     |             }
 10829 |     |             m0 := mload(0x00)
 10830 |     |             m1 := mload(0x20)
 10831 |     |             m2 := mload(0x40)
 10832 |     |             m3 := mload(0x60)
 10833 |     |             m4 := mload(0x80)
 10834 |     |             m5 := mload(0xa0)
 10835 |     |             m6 := mload(0xc0)
 10836 |     |             // Selector of `log(string,address,address,uint256)`.
 10837 |     |             mstore(0x00, 0x8ef3f399)
 10838 |     |             mstore(0x20, 0x80)
 10839 |     |             mstore(0x40, p1)
 10840 |     |             mstore(0x60, p2)
 10841 |     |             mstore(0x80, p3)
 10842 |     |             writeString(0xa0, p0)
 10843 |     |         }
 10844 |     |         _sendLogPayload(0x1c, 0xc4);
 10845 |     |         /// @solidity memory-safe-assembly
 10846 |     |         assembly {
 10847 |     |             mstore(0x00, m0)
 10848 |     |             mstore(0x20, m1)
 10849 |     |             mstore(0x40, m2)
 10850 |     |             mstore(0x60, m3)
 10851 |     |             mstore(0x80, m4)
 10852 |     |             mstore(0xa0, m5)
 10853 |     |             mstore(0xc0, m6)
 10854 |     |         }
 10855 |     |     }
 10856 |     | 
 10857 |     |     function log(bytes32 p0, address p1, address p2, bytes32 p3) internal pure {
 10858 |     |         bytes32 m0;
 10859 |     |         bytes32 m1;
 10860 |     |         bytes32 m2;
 10861 |     |         bytes32 m3;
 10862 |     |         bytes32 m4;
 10863 |     |         bytes32 m5;
 10864 |     |         bytes32 m6;
 10865 |     |         bytes32 m7;
 10866 |     |         bytes32 m8;
 10867 |     |         /// @solidity memory-safe-assembly
 10868 |     |         assembly {
 10869 |     |             function writeString(pos, w) {
 10870 |     |                 let length := 0
 10871 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
 10872 |     |                 mstore(pos, length)
 10873 |     |                 let shift := sub(256, shl(3, length))
 10874 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
 10875 |     |             }
 10876 |     |             m0 := mload(0x00)
 10877 |     |             m1 := mload(0x20)
 10878 |     |             m2 := mload(0x40)
 10879 |     |             m3 := mload(0x60)
 10880 |     |             m4 := mload(0x80)
 10881 |     |             m5 := mload(0xa0)
 10882 |     |             m6 := mload(0xc0)
 10883 |     |             m7 := mload(0xe0)
 10884 |     |             m8 := mload(0x100)
 10885 |     |             // Selector of `log(string,address,address,string)`.
 10886 |     |             mstore(0x00, 0x800a1c67)
 10887 |     |             mstore(0x20, 0x80)
 10888 |     |             mstore(0x40, p1)
 10889 |     |             mstore(0x60, p2)
 10890 |     |             mstore(0x80, 0xc0)
 10891 |     |             writeString(0xa0, p0)
 10892 |     |             writeString(0xe0, p3)
 10893 |     |         }
 10894 |     |         _sendLogPayload(0x1c, 0x104);
 10895 |     |         /// @solidity memory-safe-assembly
 10896 |     |         assembly {
 10897 |     |             mstore(0x00, m0)
 10898 |     |             mstore(0x20, m1)
 10899 |     |             mstore(0x40, m2)
 10900 |     |             mstore(0x60, m3)
 10901 |     |             mstore(0x80, m4)
 10902 |     |             mstore(0xa0, m5)
 10903 |     |             mstore(0xc0, m6)
 10904 |     |             mstore(0xe0, m7)
 10905 |     |             mstore(0x100, m8)
 10906 |     |         }
 10907 |     |     }
 10908 |     | 
 10909 |     |     function log(bytes32 p0, address p1, bool p2, address p3) internal pure {
 10910 |     |         bytes32 m0;
 10911 |     |         bytes32 m1;
 10912 |     |         bytes32 m2;
 10913 |     |         bytes32 m3;
 10914 |     |         bytes32 m4;
 10915 |     |         bytes32 m5;
 10916 |     |         bytes32 m6;
 10917 |     |         /// @solidity memory-safe-assembly
 10918 |     |         assembly {
 10919 |     |             function writeString(pos, w) {
 10920 |     |                 let length := 0
 10921 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
 10922 |     |                 mstore(pos, length)
 10923 |     |                 let shift := sub(256, shl(3, length))
 10924 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
 10925 |     |             }
 10926 |     |             m0 := mload(0x00)
 10927 |     |             m1 := mload(0x20)
 10928 |     |             m2 := mload(0x40)
 10929 |     |             m3 := mload(0x60)
 10930 |     |             m4 := mload(0x80)
 10931 |     |             m5 := mload(0xa0)
 10932 |     |             m6 := mload(0xc0)
 10933 |     |             // Selector of `log(string,address,bool,address)`.
 10934 |     |             mstore(0x00, 0x223603bd)
 10935 |     |             mstore(0x20, 0x80)
 10936 |     |             mstore(0x40, p1)
 10937 |     |             mstore(0x60, p2)
 10938 |     |             mstore(0x80, p3)
 10939 |     |             writeString(0xa0, p0)
 10940 |     |         }
 10941 |     |         _sendLogPayload(0x1c, 0xc4);
 10942 |     |         /// @solidity memory-safe-assembly
 10943 |     |         assembly {
 10944 |     |             mstore(0x00, m0)
 10945 |     |             mstore(0x20, m1)
 10946 |     |             mstore(0x40, m2)
 10947 |     |             mstore(0x60, m3)
 10948 |     |             mstore(0x80, m4)
 10949 |     |             mstore(0xa0, m5)
 10950 |     |             mstore(0xc0, m6)
 10951 |     |         }
 10952 |     |     }
 10953 |     | 
 10954 |     |     function log(bytes32 p0, address p1, bool p2, bool p3) internal pure {
 10955 |     |         bytes32 m0;
 10956 |     |         bytes32 m1;
 10957 |     |         bytes32 m2;
 10958 |     |         bytes32 m3;
 10959 |     |         bytes32 m4;
 10960 |     |         bytes32 m5;
 10961 |     |         bytes32 m6;
 10962 |     |         /// @solidity memory-safe-assembly
 10963 |     |         assembly {
 10964 |     |             function writeString(pos, w) {
 10965 |     |                 let length := 0
 10966 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
 10967 |     |                 mstore(pos, length)
 10968 |     |                 let shift := sub(256, shl(3, length))
 10969 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
 10970 |     |             }
 10971 |     |             m0 := mload(0x00)
 10972 |     |             m1 := mload(0x20)
 10973 |     |             m2 := mload(0x40)
 10974 |     |             m3 := mload(0x60)
 10975 |     |             m4 := mload(0x80)
 10976 |     |             m5 := mload(0xa0)
 10977 |     |             m6 := mload(0xc0)
 10978 |     |             // Selector of `log(string,address,bool,bool)`.
 10979 |     |             mstore(0x00, 0x79884c2b)
 10980 |     |             mstore(0x20, 0x80)
 10981 |     |             mstore(0x40, p1)
 10982 |     |             mstore(0x60, p2)
 10983 |     |             mstore(0x80, p3)
 10984 |     |             writeString(0xa0, p0)
 10985 |     |         }
 10986 |     |         _sendLogPayload(0x1c, 0xc4);
 10987 |     |         /// @solidity memory-safe-assembly
 10988 |     |         assembly {
 10989 |     |             mstore(0x00, m0)
 10990 |     |             mstore(0x20, m1)
 10991 |     |             mstore(0x40, m2)
 10992 |     |             mstore(0x60, m3)
 10993 |     |             mstore(0x80, m4)
 10994 |     |             mstore(0xa0, m5)
 10995 |     |             mstore(0xc0, m6)
 10996 |     |         }
 10997 |     |     }
 10998 |     | 
 10999 |     |     function log(bytes32 p0, address p1, bool p2, uint256 p3) internal pure {
 11000 |     |         bytes32 m0;
 11001 |     |         bytes32 m1;
 11002 |     |         bytes32 m2;
 11003 |     |         bytes32 m3;
 11004 |     |         bytes32 m4;
 11005 |     |         bytes32 m5;
 11006 |     |         bytes32 m6;
 11007 |     |         /// @solidity memory-safe-assembly
 11008 |     |         assembly {
 11009 |     |             function writeString(pos, w) {
 11010 |     |                 let length := 0
 11011 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
 11012 |     |                 mstore(pos, length)
 11013 |     |                 let shift := sub(256, shl(3, length))
 11014 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
 11015 |     |             }
 11016 |     |             m0 := mload(0x00)
 11017 |     |             m1 := mload(0x20)
 11018 |     |             m2 := mload(0x40)
 11019 |     |             m3 := mload(0x60)
 11020 |     |             m4 := mload(0x80)
 11021 |     |             m5 := mload(0xa0)
 11022 |     |             m6 := mload(0xc0)
 11023 |     |             // Selector of `log(string,address,bool,uint256)`.
 11024 |     |             mstore(0x00, 0x3e9f866a)
 11025 |     |             mstore(0x20, 0x80)
 11026 |     |             mstore(0x40, p1)
 11027 |     |             mstore(0x60, p2)
 11028 |     |             mstore(0x80, p3)
 11029 |     |             writeString(0xa0, p0)
 11030 |     |         }
 11031 |     |         _sendLogPayload(0x1c, 0xc4);
 11032 |     |         /// @solidity memory-safe-assembly
 11033 |     |         assembly {
 11034 |     |             mstore(0x00, m0)
 11035 |     |             mstore(0x20, m1)
 11036 |     |             mstore(0x40, m2)
 11037 |     |             mstore(0x60, m3)
 11038 |     |             mstore(0x80, m4)
 11039 |     |             mstore(0xa0, m5)
 11040 |     |             mstore(0xc0, m6)
 11041 |     |         }
 11042 |     |     }
 11043 |     | 
 11044 |     |     function log(bytes32 p0, address p1, bool p2, bytes32 p3) internal pure {
 11045 |     |         bytes32 m0;
 11046 |     |         bytes32 m1;
 11047 |     |         bytes32 m2;
 11048 |     |         bytes32 m3;
 11049 |     |         bytes32 m4;
 11050 |     |         bytes32 m5;
 11051 |     |         bytes32 m6;
 11052 |     |         bytes32 m7;
 11053 |     |         bytes32 m8;
 11054 |     |         /// @solidity memory-safe-assembly
 11055 |     |         assembly {
 11056 |     |             function writeString(pos, w) {
 11057 |     |                 let length := 0
 11058 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
 11059 |     |                 mstore(pos, length)
 11060 |     |                 let shift := sub(256, shl(3, length))
 11061 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
 11062 |     |             }
 11063 |     |             m0 := mload(0x00)
 11064 |     |             m1 := mload(0x20)
 11065 |     |             m2 := mload(0x40)
 11066 |     |             m3 := mload(0x60)
 11067 |     |             m4 := mload(0x80)
 11068 |     |             m5 := mload(0xa0)
 11069 |     |             m6 := mload(0xc0)
 11070 |     |             m7 := mload(0xe0)
 11071 |     |             m8 := mload(0x100)
 11072 |     |             // Selector of `log(string,address,bool,string)`.
 11073 |     |             mstore(0x00, 0x0454c079)
 11074 |     |             mstore(0x20, 0x80)
 11075 |     |             mstore(0x40, p1)
 11076 |     |             mstore(0x60, p2)
 11077 |     |             mstore(0x80, 0xc0)
 11078 |     |             writeString(0xa0, p0)
 11079 |     |             writeString(0xe0, p3)
 11080 |     |         }
 11081 |     |         _sendLogPayload(0x1c, 0x104);
 11082 |     |         /// @solidity memory-safe-assembly
 11083 |     |         assembly {
 11084 |     |             mstore(0x00, m0)
 11085 |     |             mstore(0x20, m1)
 11086 |     |             mstore(0x40, m2)
 11087 |     |             mstore(0x60, m3)
 11088 |     |             mstore(0x80, m4)
 11089 |     |             mstore(0xa0, m5)
 11090 |     |             mstore(0xc0, m6)
 11091 |     |             mstore(0xe0, m7)
 11092 |     |             mstore(0x100, m8)
 11093 |     |         }
 11094 |     |     }
 11095 |     | 
 11096 |     |     function log(bytes32 p0, address p1, uint256 p2, address p3) internal pure {
 11097 |     |         bytes32 m0;
 11098 |     |         bytes32 m1;
 11099 |     |         bytes32 m2;
 11100 |     |         bytes32 m3;
 11101 |     |         bytes32 m4;
 11102 |     |         bytes32 m5;
 11103 |     |         bytes32 m6;
 11104 |     |         /// @solidity memory-safe-assembly
 11105 |     |         assembly {
 11106 |     |             function writeString(pos, w) {
 11107 |     |                 let length := 0
 11108 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
 11109 |     |                 mstore(pos, length)
 11110 |     |                 let shift := sub(256, shl(3, length))
 11111 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
 11112 |     |             }
 11113 |     |             m0 := mload(0x00)
 11114 |     |             m1 := mload(0x20)
 11115 |     |             m2 := mload(0x40)
 11116 |     |             m3 := mload(0x60)
 11117 |     |             m4 := mload(0x80)
 11118 |     |             m5 := mload(0xa0)
 11119 |     |             m6 := mload(0xc0)
 11120 |     |             // Selector of `log(string,address,uint256,address)`.
 11121 |     |             mstore(0x00, 0x63fb8bc5)
 11122 |     |             mstore(0x20, 0x80)
 11123 |     |             mstore(0x40, p1)
 11124 |     |             mstore(0x60, p2)
 11125 |     |             mstore(0x80, p3)
 11126 |     |             writeString(0xa0, p0)
 11127 |     |         }
 11128 |     |         _sendLogPayload(0x1c, 0xc4);
 11129 |     |         /// @solidity memory-safe-assembly
 11130 |     |         assembly {
 11131 |     |             mstore(0x00, m0)
 11132 |     |             mstore(0x20, m1)
 11133 |     |             mstore(0x40, m2)
 11134 |     |             mstore(0x60, m3)
 11135 |     |             mstore(0x80, m4)
 11136 |     |             mstore(0xa0, m5)
 11137 |     |             mstore(0xc0, m6)
 11138 |     |         }
 11139 |     |     }
 11140 |     | 
 11141 |     |     function log(bytes32 p0, address p1, uint256 p2, bool p3) internal pure {
 11142 |     |         bytes32 m0;
 11143 |     |         bytes32 m1;
 11144 |     |         bytes32 m2;
 11145 |     |         bytes32 m3;
 11146 |     |         bytes32 m4;
 11147 |     |         bytes32 m5;
 11148 |     |         bytes32 m6;
 11149 |     |         /// @solidity memory-safe-assembly
 11150 |     |         assembly {
 11151 |     |             function writeString(pos, w) {
 11152 |     |                 let length := 0
 11153 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
 11154 |     |                 mstore(pos, length)
 11155 |     |                 let shift := sub(256, shl(3, length))
 11156 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
 11157 |     |             }
 11158 |     |             m0 := mload(0x00)
 11159 |     |             m1 := mload(0x20)
 11160 |     |             m2 := mload(0x40)
 11161 |     |             m3 := mload(0x60)
 11162 |     |             m4 := mload(0x80)
 11163 |     |             m5 := mload(0xa0)
 11164 |     |             m6 := mload(0xc0)
 11165 |     |             // Selector of `log(string,address,uint256,bool)`.
 11166 |     |             mstore(0x00, 0xfc4845f0)
 11167 |     |             mstore(0x20, 0x80)
 11168 |     |             mstore(0x40, p1)
 11169 |     |             mstore(0x60, p2)
 11170 |     |             mstore(0x80, p3)
 11171 |     |             writeString(0xa0, p0)
 11172 |     |         }
 11173 |     |         _sendLogPayload(0x1c, 0xc4);
 11174 |     |         /// @solidity memory-safe-assembly
 11175 |     |         assembly {
 11176 |     |             mstore(0x00, m0)
 11177 |     |             mstore(0x20, m1)
 11178 |     |             mstore(0x40, m2)
 11179 |     |             mstore(0x60, m3)
 11180 |     |             mstore(0x80, m4)
 11181 |     |             mstore(0xa0, m5)
 11182 |     |             mstore(0xc0, m6)
 11183 |     |         }
 11184 |     |     }
 11185 |     | 
 11186 |     |     function log(bytes32 p0, address p1, uint256 p2, uint256 p3) internal pure {
 11187 |     |         bytes32 m0;
 11188 |     |         bytes32 m1;
 11189 |     |         bytes32 m2;
 11190 |     |         bytes32 m3;
 11191 |     |         bytes32 m4;
 11192 |     |         bytes32 m5;
 11193 |     |         bytes32 m6;
 11194 |     |         /// @solidity memory-safe-assembly
 11195 |     |         assembly {
 11196 |     |             function writeString(pos, w) {
 11197 |     |                 let length := 0
 11198 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
 11199 |     |                 mstore(pos, length)
 11200 |     |                 let shift := sub(256, shl(3, length))
 11201 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
 11202 |     |             }
 11203 |     |             m0 := mload(0x00)
 11204 |     |             m1 := mload(0x20)
 11205 |     |             m2 := mload(0x40)
 11206 |     |             m3 := mload(0x60)
 11207 |     |             m4 := mload(0x80)
 11208 |     |             m5 := mload(0xa0)
 11209 |     |             m6 := mload(0xc0)
 11210 |     |             // Selector of `log(string,address,uint256,uint256)`.
 11211 |     |             mstore(0x00, 0xf8f51b1e)
 11212 |     |             mstore(0x20, 0x80)
 11213 |     |             mstore(0x40, p1)
 11214 |     |             mstore(0x60, p2)
 11215 |     |             mstore(0x80, p3)
 11216 |     |             writeString(0xa0, p0)
 11217 |     |         }
 11218 |     |         _sendLogPayload(0x1c, 0xc4);
 11219 |     |         /// @solidity memory-safe-assembly
 11220 |     |         assembly {
 11221 |     |             mstore(0x00, m0)
 11222 |     |             mstore(0x20, m1)
 11223 |     |             mstore(0x40, m2)
 11224 |     |             mstore(0x60, m3)
 11225 |     |             mstore(0x80, m4)
 11226 |     |             mstore(0xa0, m5)
 11227 |     |             mstore(0xc0, m6)
 11228 |     |         }
 11229 |     |     }
 11230 |     | 
 11231 |     |     function log(bytes32 p0, address p1, uint256 p2, bytes32 p3) internal pure {
 11232 |     |         bytes32 m0;
 11233 |     |         bytes32 m1;
 11234 |     |         bytes32 m2;
 11235 |     |         bytes32 m3;
 11236 |     |         bytes32 m4;
 11237 |     |         bytes32 m5;
 11238 |     |         bytes32 m6;
 11239 |     |         bytes32 m7;
 11240 |     |         bytes32 m8;
 11241 |     |         /// @solidity memory-safe-assembly
 11242 |     |         assembly {
 11243 |     |             function writeString(pos, w) {
 11244 |     |                 let length := 0
 11245 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
 11246 |     |                 mstore(pos, length)
 11247 |     |                 let shift := sub(256, shl(3, length))
 11248 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
 11249 |     |             }
 11250 |     |             m0 := mload(0x00)
 11251 |     |             m1 := mload(0x20)
 11252 |     |             m2 := mload(0x40)
 11253 |     |             m3 := mload(0x60)
 11254 |     |             m4 := mload(0x80)
 11255 |     |             m5 := mload(0xa0)
 11256 |     |             m6 := mload(0xc0)
 11257 |     |             m7 := mload(0xe0)
 11258 |     |             m8 := mload(0x100)
 11259 |     |             // Selector of `log(string,address,uint256,string)`.
 11260 |     |             mstore(0x00, 0x5a477632)
 11261 |     |             mstore(0x20, 0x80)
 11262 |     |             mstore(0x40, p1)
 11263 |     |             mstore(0x60, p2)
 11264 |     |             mstore(0x80, 0xc0)
 11265 |     |             writeString(0xa0, p0)
 11266 |     |             writeString(0xe0, p3)
 11267 |     |         }
 11268 |     |         _sendLogPayload(0x1c, 0x104);
 11269 |     |         /// @solidity memory-safe-assembly
 11270 |     |         assembly {
 11271 |     |             mstore(0x00, m0)
 11272 |     |             mstore(0x20, m1)
 11273 |     |             mstore(0x40, m2)
 11274 |     |             mstore(0x60, m3)
 11275 |     |             mstore(0x80, m4)
 11276 |     |             mstore(0xa0, m5)
 11277 |     |             mstore(0xc0, m6)
 11278 |     |             mstore(0xe0, m7)
 11279 |     |             mstore(0x100, m8)
 11280 |     |         }
 11281 |     |     }
 11282 |     | 
 11283 |     |     function log(bytes32 p0, address p1, bytes32 p2, address p3) internal pure {
 11284 |     |         bytes32 m0;
 11285 |     |         bytes32 m1;
 11286 |     |         bytes32 m2;
 11287 |     |         bytes32 m3;
 11288 |     |         bytes32 m4;
 11289 |     |         bytes32 m5;
 11290 |     |         bytes32 m6;
 11291 |     |         bytes32 m7;
 11292 |     |         bytes32 m8;
 11293 |     |         /// @solidity memory-safe-assembly
 11294 |     |         assembly {
 11295 |     |             function writeString(pos, w) {
 11296 |     |                 let length := 0
 11297 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
 11298 |     |                 mstore(pos, length)
 11299 |     |                 let shift := sub(256, shl(3, length))
 11300 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
 11301 |     |             }
 11302 |     |             m0 := mload(0x00)
 11303 |     |             m1 := mload(0x20)
 11304 |     |             m2 := mload(0x40)
 11305 |     |             m3 := mload(0x60)
 11306 |     |             m4 := mload(0x80)
 11307 |     |             m5 := mload(0xa0)
 11308 |     |             m6 := mload(0xc0)
 11309 |     |             m7 := mload(0xe0)
 11310 |     |             m8 := mload(0x100)
 11311 |     |             // Selector of `log(string,address,string,address)`.
 11312 |     |             mstore(0x00, 0xaabc9a31)
 11313 |     |             mstore(0x20, 0x80)
 11314 |     |             mstore(0x40, p1)
 11315 |     |             mstore(0x60, 0xc0)
 11316 |     |             mstore(0x80, p3)
 11317 |     |             writeString(0xa0, p0)
 11318 |     |             writeString(0xe0, p2)
 11319 |     |         }
 11320 |     |         _sendLogPayload(0x1c, 0x104);
 11321 |     |         /// @solidity memory-safe-assembly
 11322 |     |         assembly {
 11323 |     |             mstore(0x00, m0)
 11324 |     |             mstore(0x20, m1)
 11325 |     |             mstore(0x40, m2)
 11326 |     |             mstore(0x60, m3)
 11327 |     |             mstore(0x80, m4)
 11328 |     |             mstore(0xa0, m5)
 11329 |     |             mstore(0xc0, m6)
 11330 |     |             mstore(0xe0, m7)
 11331 |     |             mstore(0x100, m8)
 11332 |     |         }
 11333 |     |     }
 11334 |     | 
 11335 |     |     function log(bytes32 p0, address p1, bytes32 p2, bool p3) internal pure {
 11336 |     |         bytes32 m0;
 11337 |     |         bytes32 m1;
 11338 |     |         bytes32 m2;
 11339 |     |         bytes32 m3;
 11340 |     |         bytes32 m4;
 11341 |     |         bytes32 m5;
 11342 |     |         bytes32 m6;
 11343 |     |         bytes32 m7;
 11344 |     |         bytes32 m8;
 11345 |     |         /// @solidity memory-safe-assembly
 11346 |     |         assembly {
 11347 |     |             function writeString(pos, w) {
 11348 |     |                 let length := 0
 11349 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
 11350 |     |                 mstore(pos, length)
 11351 |     |                 let shift := sub(256, shl(3, length))
 11352 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
 11353 |     |             }
 11354 |     |             m0 := mload(0x00)
 11355 |     |             m1 := mload(0x20)
 11356 |     |             m2 := mload(0x40)
 11357 |     |             m3 := mload(0x60)
 11358 |     |             m4 := mload(0x80)
 11359 |     |             m5 := mload(0xa0)
 11360 |     |             m6 := mload(0xc0)
 11361 |     |             m7 := mload(0xe0)
 11362 |     |             m8 := mload(0x100)
 11363 |     |             // Selector of `log(string,address,string,bool)`.
 11364 |     |             mstore(0x00, 0x5f15d28c)
 11365 |     |             mstore(0x20, 0x80)
 11366 |     |             mstore(0x40, p1)
 11367 |     |             mstore(0x60, 0xc0)
 11368 |     |             mstore(0x80, p3)
 11369 |     |             writeString(0xa0, p0)
 11370 |     |             writeString(0xe0, p2)
 11371 |     |         }
 11372 |     |         _sendLogPayload(0x1c, 0x104);
 11373 |     |         /// @solidity memory-safe-assembly
 11374 |     |         assembly {
 11375 |     |             mstore(0x00, m0)
 11376 |     |             mstore(0x20, m1)
 11377 |     |             mstore(0x40, m2)
 11378 |     |             mstore(0x60, m3)
 11379 |     |             mstore(0x80, m4)
 11380 |     |             mstore(0xa0, m5)
 11381 |     |             mstore(0xc0, m6)
 11382 |     |             mstore(0xe0, m7)
 11383 |     |             mstore(0x100, m8)
 11384 |     |         }
 11385 |     |     }
 11386 |     | 
 11387 |     |     function log(bytes32 p0, address p1, bytes32 p2, uint256 p3) internal pure {
 11388 |     |         bytes32 m0;
 11389 |     |         bytes32 m1;
 11390 |     |         bytes32 m2;
 11391 |     |         bytes32 m3;
 11392 |     |         bytes32 m4;
 11393 |     |         bytes32 m5;
 11394 |     |         bytes32 m6;
 11395 |     |         bytes32 m7;
 11396 |     |         bytes32 m8;
 11397 |     |         /// @solidity memory-safe-assembly
 11398 |     |         assembly {
 11399 |     |             function writeString(pos, w) {
 11400 |     |                 let length := 0
 11401 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
 11402 |     |                 mstore(pos, length)
 11403 |     |                 let shift := sub(256, shl(3, length))
 11404 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
 11405 |     |             }
 11406 |     |             m0 := mload(0x00)
 11407 |     |             m1 := mload(0x20)
 11408 |     |             m2 := mload(0x40)
 11409 |     |             m3 := mload(0x60)
 11410 |     |             m4 := mload(0x80)
 11411 |     |             m5 := mload(0xa0)
 11412 |     |             m6 := mload(0xc0)
 11413 |     |             m7 := mload(0xe0)
 11414 |     |             m8 := mload(0x100)
 11415 |     |             // Selector of `log(string,address,string,uint256)`.
 11416 |     |             mstore(0x00, 0x91d1112e)
 11417 |     |             mstore(0x20, 0x80)
 11418 |     |             mstore(0x40, p1)
 11419 |     |             mstore(0x60, 0xc0)
 11420 |     |             mstore(0x80, p3)
 11421 |     |             writeString(0xa0, p0)
 11422 |     |             writeString(0xe0, p2)
 11423 |     |         }
 11424 |     |         _sendLogPayload(0x1c, 0x104);
 11425 |     |         /// @solidity memory-safe-assembly
 11426 |     |         assembly {
 11427 |     |             mstore(0x00, m0)
 11428 |     |             mstore(0x20, m1)
 11429 |     |             mstore(0x40, m2)
 11430 |     |             mstore(0x60, m3)
 11431 |     |             mstore(0x80, m4)
 11432 |     |             mstore(0xa0, m5)
 11433 |     |             mstore(0xc0, m6)
 11434 |     |             mstore(0xe0, m7)
 11435 |     |             mstore(0x100, m8)
 11436 |     |         }
 11437 |     |     }
 11438 |     | 
 11439 |     |     function log(bytes32 p0, address p1, bytes32 p2, bytes32 p3) internal pure {
 11440 |     |         bytes32 m0;
 11441 |     |         bytes32 m1;
 11442 |     |         bytes32 m2;
 11443 |     |         bytes32 m3;
 11444 |     |         bytes32 m4;
 11445 |     |         bytes32 m5;
 11446 |     |         bytes32 m6;
 11447 |     |         bytes32 m7;
 11448 |     |         bytes32 m8;
 11449 |     |         bytes32 m9;
 11450 |     |         bytes32 m10;
 11451 |     |         /// @solidity memory-safe-assembly
 11452 |     |         assembly {
 11453 |     |             function writeString(pos, w) {
 11454 |     |                 let length := 0
 11455 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
 11456 |     |                 mstore(pos, length)
 11457 |     |                 let shift := sub(256, shl(3, length))
 11458 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
 11459 |     |             }
 11460 |     |             m0 := mload(0x00)
 11461 |     |             m1 := mload(0x20)
 11462 |     |             m2 := mload(0x40)
 11463 |     |             m3 := mload(0x60)
 11464 |     |             m4 := mload(0x80)
 11465 |     |             m5 := mload(0xa0)
 11466 |     |             m6 := mload(0xc0)
 11467 |     |             m7 := mload(0xe0)
 11468 |     |             m8 := mload(0x100)
 11469 |     |             m9 := mload(0x120)
 11470 |     |             m10 := mload(0x140)
 11471 |     |             // Selector of `log(string,address,string,string)`.
 11472 |     |             mstore(0x00, 0x245986f2)
 11473 |     |             mstore(0x20, 0x80)
 11474 |     |             mstore(0x40, p1)
 11475 |     |             mstore(0x60, 0xc0)
 11476 |     |             mstore(0x80, 0x100)
 11477 |     |             writeString(0xa0, p0)
 11478 |     |             writeString(0xe0, p2)
 11479 |     |             writeString(0x120, p3)
 11480 |     |         }
 11481 |     |         _sendLogPayload(0x1c, 0x144);
 11482 |     |         /// @solidity memory-safe-assembly
 11483 |     |         assembly {
 11484 |     |             mstore(0x00, m0)
 11485 |     |             mstore(0x20, m1)
 11486 |     |             mstore(0x40, m2)
 11487 |     |             mstore(0x60, m3)
 11488 |     |             mstore(0x80, m4)
 11489 |     |             mstore(0xa0, m5)
 11490 |     |             mstore(0xc0, m6)
 11491 |     |             mstore(0xe0, m7)
 11492 |     |             mstore(0x100, m8)
 11493 |     |             mstore(0x120, m9)
 11494 |     |             mstore(0x140, m10)
 11495 |     |         }
 11496 |     |     }
 11497 |     | 
 11498 |     |     function log(bytes32 p0, bool p1, address p2, address p3) internal pure {
 11499 |     |         bytes32 m0;
 11500 |     |         bytes32 m1;
 11501 |     |         bytes32 m2;
 11502 |     |         bytes32 m3;
 11503 |     |         bytes32 m4;
 11504 |     |         bytes32 m5;
 11505 |     |         bytes32 m6;
 11506 |     |         /// @solidity memory-safe-assembly
 11507 |     |         assembly {
 11508 |     |             function writeString(pos, w) {
 11509 |     |                 let length := 0
 11510 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
 11511 |     |                 mstore(pos, length)
 11512 |     |                 let shift := sub(256, shl(3, length))
 11513 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
 11514 |     |             }
 11515 |     |             m0 := mload(0x00)
 11516 |     |             m1 := mload(0x20)
 11517 |     |             m2 := mload(0x40)
 11518 |     |             m3 := mload(0x60)
 11519 |     |             m4 := mload(0x80)
 11520 |     |             m5 := mload(0xa0)
 11521 |     |             m6 := mload(0xc0)
 11522 |     |             // Selector of `log(string,bool,address,address)`.
 11523 |     |             mstore(0x00, 0x33e9dd1d)
 11524 |     |             mstore(0x20, 0x80)
 11525 |     |             mstore(0x40, p1)
 11526 |     |             mstore(0x60, p2)
 11527 |     |             mstore(0x80, p3)
 11528 |     |             writeString(0xa0, p0)
 11529 |     |         }
 11530 |     |         _sendLogPayload(0x1c, 0xc4);
 11531 |     |         /// @solidity memory-safe-assembly
 11532 |     |         assembly {
 11533 |     |             mstore(0x00, m0)
 11534 |     |             mstore(0x20, m1)
 11535 |     |             mstore(0x40, m2)
 11536 |     |             mstore(0x60, m3)
 11537 |     |             mstore(0x80, m4)
 11538 |     |             mstore(0xa0, m5)
 11539 |     |             mstore(0xc0, m6)
 11540 |     |         }
 11541 |     |     }
 11542 |     | 
 11543 |     |     function log(bytes32 p0, bool p1, address p2, bool p3) internal pure {
 11544 |     |         bytes32 m0;
 11545 |     |         bytes32 m1;
 11546 |     |         bytes32 m2;
 11547 |     |         bytes32 m3;
 11548 |     |         bytes32 m4;
 11549 |     |         bytes32 m5;
 11550 |     |         bytes32 m6;
 11551 |     |         /// @solidity memory-safe-assembly
 11552 |     |         assembly {
 11553 |     |             function writeString(pos, w) {
 11554 |     |                 let length := 0
 11555 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
 11556 |     |                 mstore(pos, length)
 11557 |     |                 let shift := sub(256, shl(3, length))
 11558 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
 11559 |     |             }
 11560 |     |             m0 := mload(0x00)
 11561 |     |             m1 := mload(0x20)
 11562 |     |             m2 := mload(0x40)
 11563 |     |             m3 := mload(0x60)
 11564 |     |             m4 := mload(0x80)
 11565 |     |             m5 := mload(0xa0)
 11566 |     |             m6 := mload(0xc0)
 11567 |     |             // Selector of `log(string,bool,address,bool)`.
 11568 |     |             mstore(0x00, 0x958c28c6)
 11569 |     |             mstore(0x20, 0x80)
 11570 |     |             mstore(0x40, p1)
 11571 |     |             mstore(0x60, p2)
 11572 |     |             mstore(0x80, p3)
 11573 |     |             writeString(0xa0, p0)
 11574 |     |         }
 11575 |     |         _sendLogPayload(0x1c, 0xc4);
 11576 |     |         /// @solidity memory-safe-assembly
 11577 |     |         assembly {
 11578 |     |             mstore(0x00, m0)
 11579 |     |             mstore(0x20, m1)
 11580 |     |             mstore(0x40, m2)
 11581 |     |             mstore(0x60, m3)
 11582 |     |             mstore(0x80, m4)
 11583 |     |             mstore(0xa0, m5)
 11584 |     |             mstore(0xc0, m6)
 11585 |     |         }
 11586 |     |     }
 11587 |     | 
 11588 |     |     function log(bytes32 p0, bool p1, address p2, uint256 p3) internal pure {
 11589 |     |         bytes32 m0;
 11590 |     |         bytes32 m1;
 11591 |     |         bytes32 m2;
 11592 |     |         bytes32 m3;
 11593 |     |         bytes32 m4;
 11594 |     |         bytes32 m5;
 11595 |     |         bytes32 m6;
 11596 |     |         /// @solidity memory-safe-assembly
 11597 |     |         assembly {
 11598 |     |             function writeString(pos, w) {
 11599 |     |                 let length := 0
 11600 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
 11601 |     |                 mstore(pos, length)
 11602 |     |                 let shift := sub(256, shl(3, length))
 11603 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
 11604 |     |             }
 11605 |     |             m0 := mload(0x00)
 11606 |     |             m1 := mload(0x20)
 11607 |     |             m2 := mload(0x40)
 11608 |     |             m3 := mload(0x60)
 11609 |     |             m4 := mload(0x80)
 11610 |     |             m5 := mload(0xa0)
 11611 |     |             m6 := mload(0xc0)
 11612 |     |             // Selector of `log(string,bool,address,uint256)`.
 11613 |     |             mstore(0x00, 0x5d08bb05)
 11614 |     |             mstore(0x20, 0x80)
 11615 |     |             mstore(0x40, p1)
 11616 |     |             mstore(0x60, p2)
 11617 |     |             mstore(0x80, p3)
 11618 |     |             writeString(0xa0, p0)
 11619 |     |         }
 11620 |     |         _sendLogPayload(0x1c, 0xc4);
 11621 |     |         /// @solidity memory-safe-assembly
 11622 |     |         assembly {
 11623 |     |             mstore(0x00, m0)
 11624 |     |             mstore(0x20, m1)
 11625 |     |             mstore(0x40, m2)
 11626 |     |             mstore(0x60, m3)
 11627 |     |             mstore(0x80, m4)
 11628 |     |             mstore(0xa0, m5)
 11629 |     |             mstore(0xc0, m6)
 11630 |     |         }
 11631 |     |     }
 11632 |     | 
 11633 |     |     function log(bytes32 p0, bool p1, address p2, bytes32 p3) internal pure {
 11634 |     |         bytes32 m0;
 11635 |     |         bytes32 m1;
 11636 |     |         bytes32 m2;
 11637 |     |         bytes32 m3;
 11638 |     |         bytes32 m4;
 11639 |     |         bytes32 m5;
 11640 |     |         bytes32 m6;
 11641 |     |         bytes32 m7;
 11642 |     |         bytes32 m8;
 11643 |     |         /// @solidity memory-safe-assembly
 11644 |     |         assembly {
 11645 |     |             function writeString(pos, w) {
 11646 |     |                 let length := 0
 11647 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
 11648 |     |                 mstore(pos, length)
 11649 |     |                 let shift := sub(256, shl(3, length))
 11650 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
 11651 |     |             }
 11652 |     |             m0 := mload(0x00)
 11653 |     |             m1 := mload(0x20)
 11654 |     |             m2 := mload(0x40)
 11655 |     |             m3 := mload(0x60)
 11656 |     |             m4 := mload(0x80)
 11657 |     |             m5 := mload(0xa0)
 11658 |     |             m6 := mload(0xc0)
 11659 |     |             m7 := mload(0xe0)
 11660 |     |             m8 := mload(0x100)
 11661 |     |             // Selector of `log(string,bool,address,string)`.
 11662 |     |             mstore(0x00, 0x2d8e33a4)
 11663 |     |             mstore(0x20, 0x80)
 11664 |     |             mstore(0x40, p1)
 11665 |     |             mstore(0x60, p2)
 11666 |     |             mstore(0x80, 0xc0)
 11667 |     |             writeString(0xa0, p0)
 11668 |     |             writeString(0xe0, p3)
 11669 |     |         }
 11670 |     |         _sendLogPayload(0x1c, 0x104);
 11671 |     |         /// @solidity memory-safe-assembly
 11672 |     |         assembly {
 11673 |     |             mstore(0x00, m0)
 11674 |     |             mstore(0x20, m1)
 11675 |     |             mstore(0x40, m2)
 11676 |     |             mstore(0x60, m3)
 11677 |     |             mstore(0x80, m4)
 11678 |     |             mstore(0xa0, m5)
 11679 |     |             mstore(0xc0, m6)
 11680 |     |             mstore(0xe0, m7)
 11681 |     |             mstore(0x100, m8)
 11682 |     |         }
 11683 |     |     }
 11684 |     | 
 11685 |     |     function log(bytes32 p0, bool p1, bool p2, address p3) internal pure {
 11686 |     |         bytes32 m0;
 11687 |     |         bytes32 m1;
 11688 |     |         bytes32 m2;
 11689 |     |         bytes32 m3;
 11690 |     |         bytes32 m4;
 11691 |     |         bytes32 m5;
 11692 |     |         bytes32 m6;
 11693 |     |         /// @solidity memory-safe-assembly
 11694 |     |         assembly {
 11695 |     |             function writeString(pos, w) {
 11696 |     |                 let length := 0
 11697 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
 11698 |     |                 mstore(pos, length)
 11699 |     |                 let shift := sub(256, shl(3, length))
 11700 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
 11701 |     |             }
 11702 |     |             m0 := mload(0x00)
 11703 |     |             m1 := mload(0x20)
 11704 |     |             m2 := mload(0x40)
 11705 |     |             m3 := mload(0x60)
 11706 |     |             m4 := mload(0x80)
 11707 |     |             m5 := mload(0xa0)
 11708 |     |             m6 := mload(0xc0)
 11709 |     |             // Selector of `log(string,bool,bool,address)`.
 11710 |     |             mstore(0x00, 0x7190a529)
 11711 |     |             mstore(0x20, 0x80)
 11712 |     |             mstore(0x40, p1)
 11713 |     |             mstore(0x60, p2)
 11714 |     |             mstore(0x80, p3)
 11715 |     |             writeString(0xa0, p0)
 11716 |     |         }
 11717 |     |         _sendLogPayload(0x1c, 0xc4);
 11718 |     |         /// @solidity memory-safe-assembly
 11719 |     |         assembly {
 11720 |     |             mstore(0x00, m0)
 11721 |     |             mstore(0x20, m1)
 11722 |     |             mstore(0x40, m2)
 11723 |     |             mstore(0x60, m3)
 11724 |     |             mstore(0x80, m4)
 11725 |     |             mstore(0xa0, m5)
 11726 |     |             mstore(0xc0, m6)
 11727 |     |         }
 11728 |     |     }
 11729 |     | 
 11730 |     |     function log(bytes32 p0, bool p1, bool p2, bool p3) internal pure {
 11731 |     |         bytes32 m0;
 11732 |     |         bytes32 m1;
 11733 |     |         bytes32 m2;
 11734 |     |         bytes32 m3;
 11735 |     |         bytes32 m4;
 11736 |     |         bytes32 m5;
 11737 |     |         bytes32 m6;
 11738 |     |         /// @solidity memory-safe-assembly
 11739 |     |         assembly {
 11740 |     |             function writeString(pos, w) {
 11741 |     |                 let length := 0
 11742 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
 11743 |     |                 mstore(pos, length)
 11744 |     |                 let shift := sub(256, shl(3, length))
 11745 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
 11746 |     |             }
 11747 |     |             m0 := mload(0x00)
 11748 |     |             m1 := mload(0x20)
 11749 |     |             m2 := mload(0x40)
 11750 |     |             m3 := mload(0x60)
 11751 |     |             m4 := mload(0x80)
 11752 |     |             m5 := mload(0xa0)
 11753 |     |             m6 := mload(0xc0)
 11754 |     |             // Selector of `log(string,bool,bool,bool)`.
 11755 |     |             mstore(0x00, 0x895af8c5)
 11756 |     |             mstore(0x20, 0x80)
 11757 |     |             mstore(0x40, p1)
 11758 |     |             mstore(0x60, p2)
 11759 |     |             mstore(0x80, p3)
 11760 |     |             writeString(0xa0, p0)
 11761 |     |         }
 11762 |     |         _sendLogPayload(0x1c, 0xc4);
 11763 |     |         /// @solidity memory-safe-assembly
 11764 |     |         assembly {
 11765 |     |             mstore(0x00, m0)
 11766 |     |             mstore(0x20, m1)
 11767 |     |             mstore(0x40, m2)
 11768 |     |             mstore(0x60, m3)
 11769 |     |             mstore(0x80, m4)
 11770 |     |             mstore(0xa0, m5)
 11771 |     |             mstore(0xc0, m6)
 11772 |     |         }
 11773 |     |     }
 11774 |     | 
 11775 |     |     function log(bytes32 p0, bool p1, bool p2, uint256 p3) internal pure {
 11776 |     |         bytes32 m0;
 11777 |     |         bytes32 m1;
 11778 |     |         bytes32 m2;
 11779 |     |         bytes32 m3;
 11780 |     |         bytes32 m4;
 11781 |     |         bytes32 m5;
 11782 |     |         bytes32 m6;
 11783 |     |         /// @solidity memory-safe-assembly
 11784 |     |         assembly {
 11785 |     |             function writeString(pos, w) {
 11786 |     |                 let length := 0
 11787 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
 11788 |     |                 mstore(pos, length)
 11789 |     |                 let shift := sub(256, shl(3, length))
 11790 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
 11791 |     |             }
 11792 |     |             m0 := mload(0x00)
 11793 |     |             m1 := mload(0x20)
 11794 |     |             m2 := mload(0x40)
 11795 |     |             m3 := mload(0x60)
 11796 |     |             m4 := mload(0x80)
 11797 |     |             m5 := mload(0xa0)
 11798 |     |             m6 := mload(0xc0)
 11799 |     |             // Selector of `log(string,bool,bool,uint256)`.
 11800 |     |             mstore(0x00, 0x8e3f78a9)
 11801 |     |             mstore(0x20, 0x80)
 11802 |     |             mstore(0x40, p1)
 11803 |     |             mstore(0x60, p2)
 11804 |     |             mstore(0x80, p3)
 11805 |     |             writeString(0xa0, p0)
 11806 |     |         }
 11807 |     |         _sendLogPayload(0x1c, 0xc4);
 11808 |     |         /// @solidity memory-safe-assembly
 11809 |     |         assembly {
 11810 |     |             mstore(0x00, m0)
 11811 |     |             mstore(0x20, m1)
 11812 |     |             mstore(0x40, m2)
 11813 |     |             mstore(0x60, m3)
 11814 |     |             mstore(0x80, m4)
 11815 |     |             mstore(0xa0, m5)
 11816 |     |             mstore(0xc0, m6)
 11817 |     |         }
 11818 |     |     }
 11819 |     | 
 11820 |     |     function log(bytes32 p0, bool p1, bool p2, bytes32 p3) internal pure {
 11821 |     |         bytes32 m0;
 11822 |     |         bytes32 m1;
 11823 |     |         bytes32 m2;
 11824 |     |         bytes32 m3;
 11825 |     |         bytes32 m4;
 11826 |     |         bytes32 m5;
 11827 |     |         bytes32 m6;
 11828 |     |         bytes32 m7;
 11829 |     |         bytes32 m8;
 11830 |     |         /// @solidity memory-safe-assembly
 11831 |     |         assembly {
 11832 |     |             function writeString(pos, w) {
 11833 |     |                 let length := 0
 11834 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
 11835 |     |                 mstore(pos, length)
 11836 |     |                 let shift := sub(256, shl(3, length))
 11837 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
 11838 |     |             }
 11839 |     |             m0 := mload(0x00)
 11840 |     |             m1 := mload(0x20)
 11841 |     |             m2 := mload(0x40)
 11842 |     |             m3 := mload(0x60)
 11843 |     |             m4 := mload(0x80)
 11844 |     |             m5 := mload(0xa0)
 11845 |     |             m6 := mload(0xc0)
 11846 |     |             m7 := mload(0xe0)
 11847 |     |             m8 := mload(0x100)
 11848 |     |             // Selector of `log(string,bool,bool,string)`.
 11849 |     |             mstore(0x00, 0x9d22d5dd)
 11850 |     |             mstore(0x20, 0x80)
 11851 |     |             mstore(0x40, p1)
 11852 |     |             mstore(0x60, p2)
 11853 |     |             mstore(0x80, 0xc0)
 11854 |     |             writeString(0xa0, p0)
 11855 |     |             writeString(0xe0, p3)
 11856 |     |         }
 11857 |     |         _sendLogPayload(0x1c, 0x104);
 11858 |     |         /// @solidity memory-safe-assembly
 11859 |     |         assembly {
 11860 |     |             mstore(0x00, m0)
 11861 |     |             mstore(0x20, m1)
 11862 |     |             mstore(0x40, m2)
 11863 |     |             mstore(0x60, m3)
 11864 |     |             mstore(0x80, m4)
 11865 |     |             mstore(0xa0, m5)
 11866 |     |             mstore(0xc0, m6)
 11867 |     |             mstore(0xe0, m7)
 11868 |     |             mstore(0x100, m8)
 11869 |     |         }
 11870 |     |     }
 11871 |     | 
 11872 |     |     function log(bytes32 p0, bool p1, uint256 p2, address p3) internal pure {
 11873 |     |         bytes32 m0;
 11874 |     |         bytes32 m1;
 11875 |     |         bytes32 m2;
 11876 |     |         bytes32 m3;
 11877 |     |         bytes32 m4;
 11878 |     |         bytes32 m5;
 11879 |     |         bytes32 m6;
 11880 |     |         /// @solidity memory-safe-assembly
 11881 |     |         assembly {
 11882 |     |             function writeString(pos, w) {
 11883 |     |                 let length := 0
 11884 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
 11885 |     |                 mstore(pos, length)
 11886 |     |                 let shift := sub(256, shl(3, length))
 11887 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
 11888 |     |             }
 11889 |     |             m0 := mload(0x00)
 11890 |     |             m1 := mload(0x20)
 11891 |     |             m2 := mload(0x40)
 11892 |     |             m3 := mload(0x60)
 11893 |     |             m4 := mload(0x80)
 11894 |     |             m5 := mload(0xa0)
 11895 |     |             m6 := mload(0xc0)
 11896 |     |             // Selector of `log(string,bool,uint256,address)`.
 11897 |     |             mstore(0x00, 0x935e09bf)
 11898 |     |             mstore(0x20, 0x80)
 11899 |     |             mstore(0x40, p1)
 11900 |     |             mstore(0x60, p2)
 11901 |     |             mstore(0x80, p3)
 11902 |     |             writeString(0xa0, p0)
 11903 |     |         }
 11904 |     |         _sendLogPayload(0x1c, 0xc4);
 11905 |     |         /// @solidity memory-safe-assembly
 11906 |     |         assembly {
 11907 |     |             mstore(0x00, m0)
 11908 |     |             mstore(0x20, m1)
 11909 |     |             mstore(0x40, m2)
 11910 |     |             mstore(0x60, m3)
 11911 |     |             mstore(0x80, m4)
 11912 |     |             mstore(0xa0, m5)
 11913 |     |             mstore(0xc0, m6)
 11914 |     |         }
 11915 |     |     }
 11916 |     | 
 11917 |     |     function log(bytes32 p0, bool p1, uint256 p2, bool p3) internal pure {
 11918 |     |         bytes32 m0;
 11919 |     |         bytes32 m1;
 11920 |     |         bytes32 m2;
 11921 |     |         bytes32 m3;
 11922 |     |         bytes32 m4;
 11923 |     |         bytes32 m5;
 11924 |     |         bytes32 m6;
 11925 |     |         /// @solidity memory-safe-assembly
 11926 |     |         assembly {
 11927 |     |             function writeString(pos, w) {
 11928 |     |                 let length := 0
 11929 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
 11930 |     |                 mstore(pos, length)
 11931 |     |                 let shift := sub(256, shl(3, length))
 11932 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
 11933 |     |             }
 11934 |     |             m0 := mload(0x00)
 11935 |     |             m1 := mload(0x20)
 11936 |     |             m2 := mload(0x40)
 11937 |     |             m3 := mload(0x60)
 11938 |     |             m4 := mload(0x80)
 11939 |     |             m5 := mload(0xa0)
 11940 |     |             m6 := mload(0xc0)
 11941 |     |             // Selector of `log(string,bool,uint256,bool)`.
 11942 |     |             mstore(0x00, 0x8af7cf8a)
 11943 |     |             mstore(0x20, 0x80)
 11944 |     |             mstore(0x40, p1)
 11945 |     |             mstore(0x60, p2)
 11946 |     |             mstore(0x80, p3)
 11947 |     |             writeString(0xa0, p0)
 11948 |     |         }
 11949 |     |         _sendLogPayload(0x1c, 0xc4);
 11950 |     |         /// @solidity memory-safe-assembly
 11951 |     |         assembly {
 11952 |     |             mstore(0x00, m0)
 11953 |     |             mstore(0x20, m1)
 11954 |     |             mstore(0x40, m2)
 11955 |     |             mstore(0x60, m3)
 11956 |     |             mstore(0x80, m4)
 11957 |     |             mstore(0xa0, m5)
 11958 |     |             mstore(0xc0, m6)
 11959 |     |         }
 11960 |     |     }
 11961 |     | 
 11962 |     |     function log(bytes32 p0, bool p1, uint256 p2, uint256 p3) internal pure {
 11963 |     |         bytes32 m0;
 11964 |     |         bytes32 m1;
 11965 |     |         bytes32 m2;
 11966 |     |         bytes32 m3;
 11967 |     |         bytes32 m4;
 11968 |     |         bytes32 m5;
 11969 |     |         bytes32 m6;
 11970 |     |         /// @solidity memory-safe-assembly
 11971 |     |         assembly {
 11972 |     |             function writeString(pos, w) {
 11973 |     |                 let length := 0
 11974 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
 11975 |     |                 mstore(pos, length)
 11976 |     |                 let shift := sub(256, shl(3, length))
 11977 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
 11978 |     |             }
 11979 |     |             m0 := mload(0x00)
 11980 |     |             m1 := mload(0x20)
 11981 |     |             m2 := mload(0x40)
 11982 |     |             m3 := mload(0x60)
 11983 |     |             m4 := mload(0x80)
 11984 |     |             m5 := mload(0xa0)
 11985 |     |             m6 := mload(0xc0)
 11986 |     |             // Selector of `log(string,bool,uint256,uint256)`.
 11987 |     |             mstore(0x00, 0x64b5bb67)
 11988 |     |             mstore(0x20, 0x80)
 11989 |     |             mstore(0x40, p1)
 11990 |     |             mstore(0x60, p2)
 11991 |     |             mstore(0x80, p3)
 11992 |     |             writeString(0xa0, p0)
 11993 |     |         }
 11994 |     |         _sendLogPayload(0x1c, 0xc4);
 11995 |     |         /// @solidity memory-safe-assembly
 11996 |     |         assembly {
 11997 |     |             mstore(0x00, m0)
 11998 |     |             mstore(0x20, m1)
 11999 |     |             mstore(0x40, m2)
 12000 |     |             mstore(0x60, m3)
 12001 |     |             mstore(0x80, m4)
 12002 |     |             mstore(0xa0, m5)
 12003 |     |             mstore(0xc0, m6)
 12004 |     |         }
 12005 |     |     }
 12006 |     | 
 12007 |     |     function log(bytes32 p0, bool p1, uint256 p2, bytes32 p3) internal pure {
 12008 |     |         bytes32 m0;
 12009 |     |         bytes32 m1;
 12010 |     |         bytes32 m2;
 12011 |     |         bytes32 m3;
 12012 |     |         bytes32 m4;
 12013 |     |         bytes32 m5;
 12014 |     |         bytes32 m6;
 12015 |     |         bytes32 m7;
 12016 |     |         bytes32 m8;
 12017 |     |         /// @solidity memory-safe-assembly
 12018 |     |         assembly {
 12019 |     |             function writeString(pos, w) {
 12020 |     |                 let length := 0
 12021 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
 12022 |     |                 mstore(pos, length)
 12023 |     |                 let shift := sub(256, shl(3, length))
 12024 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
 12025 |     |             }
 12026 |     |             m0 := mload(0x00)
 12027 |     |             m1 := mload(0x20)
 12028 |     |             m2 := mload(0x40)
 12029 |     |             m3 := mload(0x60)
 12030 |     |             m4 := mload(0x80)
 12031 |     |             m5 := mload(0xa0)
 12032 |     |             m6 := mload(0xc0)
 12033 |     |             m7 := mload(0xe0)
 12034 |     |             m8 := mload(0x100)
 12035 |     |             // Selector of `log(string,bool,uint256,string)`.
 12036 |     |             mstore(0x00, 0x742d6ee7)
 12037 |     |             mstore(0x20, 0x80)
 12038 |     |             mstore(0x40, p1)
 12039 |     |             mstore(0x60, p2)
 12040 |     |             mstore(0x80, 0xc0)
 12041 |     |             writeString(0xa0, p0)
 12042 |     |             writeString(0xe0, p3)
 12043 |     |         }
 12044 |     |         _sendLogPayload(0x1c, 0x104);
 12045 |     |         /// @solidity memory-safe-assembly
 12046 |     |         assembly {
 12047 |     |             mstore(0x00, m0)
 12048 |     |             mstore(0x20, m1)
 12049 |     |             mstore(0x40, m2)
 12050 |     |             mstore(0x60, m3)
 12051 |     |             mstore(0x80, m4)
 12052 |     |             mstore(0xa0, m5)
 12053 |     |             mstore(0xc0, m6)
 12054 |     |             mstore(0xe0, m7)
 12055 |     |             mstore(0x100, m8)
 12056 |     |         }
 12057 |     |     }
 12058 |     | 
 12059 |     |     function log(bytes32 p0, bool p1, bytes32 p2, address p3) internal pure {
 12060 |     |         bytes32 m0;
 12061 |     |         bytes32 m1;
 12062 |     |         bytes32 m2;
 12063 |     |         bytes32 m3;
 12064 |     |         bytes32 m4;
 12065 |     |         bytes32 m5;
 12066 |     |         bytes32 m6;
 12067 |     |         bytes32 m7;
 12068 |     |         bytes32 m8;
 12069 |     |         /// @solidity memory-safe-assembly
 12070 |     |         assembly {
 12071 |     |             function writeString(pos, w) {
 12072 |     |                 let length := 0
 12073 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
 12074 |     |                 mstore(pos, length)
 12075 |     |                 let shift := sub(256, shl(3, length))
 12076 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
 12077 |     |             }
 12078 |     |             m0 := mload(0x00)
 12079 |     |             m1 := mload(0x20)
 12080 |     |             m2 := mload(0x40)
 12081 |     |             m3 := mload(0x60)
 12082 |     |             m4 := mload(0x80)
 12083 |     |             m5 := mload(0xa0)
 12084 |     |             m6 := mload(0xc0)
 12085 |     |             m7 := mload(0xe0)
 12086 |     |             m8 := mload(0x100)
 12087 |     |             // Selector of `log(string,bool,string,address)`.
 12088 |     |             mstore(0x00, 0xe0625b29)
 12089 |     |             mstore(0x20, 0x80)
 12090 |     |             mstore(0x40, p1)
 12091 |     |             mstore(0x60, 0xc0)
 12092 |     |             mstore(0x80, p3)
 12093 |     |             writeString(0xa0, p0)
 12094 |     |             writeString(0xe0, p2)
 12095 |     |         }
 12096 |     |         _sendLogPayload(0x1c, 0x104);
 12097 |     |         /// @solidity memory-safe-assembly
 12098 |     |         assembly {
 12099 |     |             mstore(0x00, m0)
 12100 |     |             mstore(0x20, m1)
 12101 |     |             mstore(0x40, m2)
 12102 |     |             mstore(0x60, m3)
 12103 |     |             mstore(0x80, m4)
 12104 |     |             mstore(0xa0, m5)
 12105 |     |             mstore(0xc0, m6)
 12106 |     |             mstore(0xe0, m7)
 12107 |     |             mstore(0x100, m8)
 12108 |     |         }
 12109 |     |     }
 12110 |     | 
 12111 |     |     function log(bytes32 p0, bool p1, bytes32 p2, bool p3) internal pure {
 12112 |     |         bytes32 m0;
 12113 |     |         bytes32 m1;
 12114 |     |         bytes32 m2;
 12115 |     |         bytes32 m3;
 12116 |     |         bytes32 m4;
 12117 |     |         bytes32 m5;
 12118 |     |         bytes32 m6;
 12119 |     |         bytes32 m7;
 12120 |     |         bytes32 m8;
 12121 |     |         /// @solidity memory-safe-assembly
 12122 |     |         assembly {
 12123 |     |             function writeString(pos, w) {
 12124 |     |                 let length := 0
 12125 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
 12126 |     |                 mstore(pos, length)
 12127 |     |                 let shift := sub(256, shl(3, length))
 12128 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
 12129 |     |             }
 12130 |     |             m0 := mload(0x00)
 12131 |     |             m1 := mload(0x20)
 12132 |     |             m2 := mload(0x40)
 12133 |     |             m3 := mload(0x60)
 12134 |     |             m4 := mload(0x80)
 12135 |     |             m5 := mload(0xa0)
 12136 |     |             m6 := mload(0xc0)
 12137 |     |             m7 := mload(0xe0)
 12138 |     |             m8 := mload(0x100)
 12139 |     |             // Selector of `log(string,bool,string,bool)`.
 12140 |     |             mstore(0x00, 0x3f8a701d)
 12141 |     |             mstore(0x20, 0x80)
 12142 |     |             mstore(0x40, p1)
 12143 |     |             mstore(0x60, 0xc0)
 12144 |     |             mstore(0x80, p3)
 12145 |     |             writeString(0xa0, p0)
 12146 |     |             writeString(0xe0, p2)
 12147 |     |         }
 12148 |     |         _sendLogPayload(0x1c, 0x104);
 12149 |     |         /// @solidity memory-safe-assembly
 12150 |     |         assembly {
 12151 |     |             mstore(0x00, m0)
 12152 |     |             mstore(0x20, m1)
 12153 |     |             mstore(0x40, m2)
 12154 |     |             mstore(0x60, m3)
 12155 |     |             mstore(0x80, m4)
 12156 |     |             mstore(0xa0, m5)
 12157 |     |             mstore(0xc0, m6)
 12158 |     |             mstore(0xe0, m7)
 12159 |     |             mstore(0x100, m8)
 12160 |     |         }
 12161 |     |     }
 12162 |     | 
 12163 |     |     function log(bytes32 p0, bool p1, bytes32 p2, uint256 p3) internal pure {
 12164 |     |         bytes32 m0;
 12165 |     |         bytes32 m1;
 12166 |     |         bytes32 m2;
 12167 |     |         bytes32 m3;
 12168 |     |         bytes32 m4;
 12169 |     |         bytes32 m5;
 12170 |     |         bytes32 m6;
 12171 |     |         bytes32 m7;
 12172 |     |         bytes32 m8;
 12173 |     |         /// @solidity memory-safe-assembly
 12174 |     |         assembly {
 12175 |     |             function writeString(pos, w) {
 12176 |     |                 let length := 0
 12177 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
 12178 |     |                 mstore(pos, length)
 12179 |     |                 let shift := sub(256, shl(3, length))
 12180 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
 12181 |     |             }
 12182 |     |             m0 := mload(0x00)
 12183 |     |             m1 := mload(0x20)
 12184 |     |             m2 := mload(0x40)
 12185 |     |             m3 := mload(0x60)
 12186 |     |             m4 := mload(0x80)
 12187 |     |             m5 := mload(0xa0)
 12188 |     |             m6 := mload(0xc0)
 12189 |     |             m7 := mload(0xe0)
 12190 |     |             m8 := mload(0x100)
 12191 |     |             // Selector of `log(string,bool,string,uint256)`.
 12192 |     |             mstore(0x00, 0x24f91465)
 12193 |     |             mstore(0x20, 0x80)
 12194 |     |             mstore(0x40, p1)
 12195 |     |             mstore(0x60, 0xc0)
 12196 |     |             mstore(0x80, p3)
 12197 |     |             writeString(0xa0, p0)
 12198 |     |             writeString(0xe0, p2)
 12199 |     |         }
 12200 |     |         _sendLogPayload(0x1c, 0x104);
 12201 |     |         /// @solidity memory-safe-assembly
 12202 |     |         assembly {
 12203 |     |             mstore(0x00, m0)
 12204 |     |             mstore(0x20, m1)
 12205 |     |             mstore(0x40, m2)
 12206 |     |             mstore(0x60, m3)
 12207 |     |             mstore(0x80, m4)
 12208 |     |             mstore(0xa0, m5)
 12209 |     |             mstore(0xc0, m6)
 12210 |     |             mstore(0xe0, m7)
 12211 |     |             mstore(0x100, m8)
 12212 |     |         }
 12213 |     |     }
 12214 |     | 
 12215 |     |     function log(bytes32 p0, bool p1, bytes32 p2, bytes32 p3) internal pure {
 12216 |     |         bytes32 m0;
 12217 |     |         bytes32 m1;
 12218 |     |         bytes32 m2;
 12219 |     |         bytes32 m3;
 12220 |     |         bytes32 m4;
 12221 |     |         bytes32 m5;
 12222 |     |         bytes32 m6;
 12223 |     |         bytes32 m7;
 12224 |     |         bytes32 m8;
 12225 |     |         bytes32 m9;
 12226 |     |         bytes32 m10;
 12227 |     |         /// @solidity memory-safe-assembly
 12228 |     |         assembly {
 12229 |     |             function writeString(pos, w) {
 12230 |     |                 let length := 0
 12231 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
 12232 |     |                 mstore(pos, length)
 12233 |     |                 let shift := sub(256, shl(3, length))
 12234 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
 12235 |     |             }
 12236 |     |             m0 := mload(0x00)
 12237 |     |             m1 := mload(0x20)
 12238 |     |             m2 := mload(0x40)
 12239 |     |             m3 := mload(0x60)
 12240 |     |             m4 := mload(0x80)
 12241 |     |             m5 := mload(0xa0)
 12242 |     |             m6 := mload(0xc0)
 12243 |     |             m7 := mload(0xe0)
 12244 |     |             m8 := mload(0x100)
 12245 |     |             m9 := mload(0x120)
 12246 |     |             m10 := mload(0x140)
 12247 |     |             // Selector of `log(string,bool,string,string)`.
 12248 |     |             mstore(0x00, 0xa826caeb)
 12249 |     |             mstore(0x20, 0x80)
 12250 |     |             mstore(0x40, p1)
 12251 |     |             mstore(0x60, 0xc0)
 12252 |     |             mstore(0x80, 0x100)
 12253 |     |             writeString(0xa0, p0)
 12254 |     |             writeString(0xe0, p2)
 12255 |     |             writeString(0x120, p3)
 12256 |     |         }
 12257 |     |         _sendLogPayload(0x1c, 0x144);
 12258 |     |         /// @solidity memory-safe-assembly
 12259 |     |         assembly {
 12260 |     |             mstore(0x00, m0)
 12261 |     |             mstore(0x20, m1)
 12262 |     |             mstore(0x40, m2)
 12263 |     |             mstore(0x60, m3)
 12264 |     |             mstore(0x80, m4)
 12265 |     |             mstore(0xa0, m5)
 12266 |     |             mstore(0xc0, m6)
 12267 |     |             mstore(0xe0, m7)
 12268 |     |             mstore(0x100, m8)
 12269 |     |             mstore(0x120, m9)
 12270 |     |             mstore(0x140, m10)
 12271 |     |         }
 12272 |     |     }
 12273 |     | 
 12274 |     |     function log(bytes32 p0, uint256 p1, address p2, address p3) internal pure {
 12275 |     |         bytes32 m0;
 12276 |     |         bytes32 m1;
 12277 |     |         bytes32 m2;
 12278 |     |         bytes32 m3;
 12279 |     |         bytes32 m4;
 12280 |     |         bytes32 m5;
 12281 |     |         bytes32 m6;
 12282 |     |         /// @solidity memory-safe-assembly
 12283 |     |         assembly {
 12284 |     |             function writeString(pos, w) {
 12285 |     |                 let length := 0
 12286 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
 12287 |     |                 mstore(pos, length)
 12288 |     |                 let shift := sub(256, shl(3, length))
 12289 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
 12290 |     |             }
 12291 |     |             m0 := mload(0x00)
 12292 |     |             m1 := mload(0x20)
 12293 |     |             m2 := mload(0x40)
 12294 |     |             m3 := mload(0x60)
 12295 |     |             m4 := mload(0x80)
 12296 |     |             m5 := mload(0xa0)
 12297 |     |             m6 := mload(0xc0)
 12298 |     |             // Selector of `log(string,uint256,address,address)`.
 12299 |     |             mstore(0x00, 0x5ea2b7ae)
 12300 |     |             mstore(0x20, 0x80)
 12301 |     |             mstore(0x40, p1)
 12302 |     |             mstore(0x60, p2)
 12303 |     |             mstore(0x80, p3)
 12304 |     |             writeString(0xa0, p0)
 12305 |     |         }
 12306 |     |         _sendLogPayload(0x1c, 0xc4);
 12307 |     |         /// @solidity memory-safe-assembly
 12308 |     |         assembly {
 12309 |     |             mstore(0x00, m0)
 12310 |     |             mstore(0x20, m1)
 12311 |     |             mstore(0x40, m2)
 12312 |     |             mstore(0x60, m3)
 12313 |     |             mstore(0x80, m4)
 12314 |     |             mstore(0xa0, m5)
 12315 |     |             mstore(0xc0, m6)
 12316 |     |         }
 12317 |     |     }
 12318 |     | 
 12319 |     |     function log(bytes32 p0, uint256 p1, address p2, bool p3) internal pure {
 12320 |     |         bytes32 m0;
 12321 |     |         bytes32 m1;
 12322 |     |         bytes32 m2;
 12323 |     |         bytes32 m3;
 12324 |     |         bytes32 m4;
 12325 |     |         bytes32 m5;
 12326 |     |         bytes32 m6;
 12327 |     |         /// @solidity memory-safe-assembly
 12328 |     |         assembly {
 12329 |     |             function writeString(pos, w) {
 12330 |     |                 let length := 0
 12331 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
 12332 |     |                 mstore(pos, length)
 12333 |     |                 let shift := sub(256, shl(3, length))
 12334 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
 12335 |     |             }
 12336 |     |             m0 := mload(0x00)
 12337 |     |             m1 := mload(0x20)
 12338 |     |             m2 := mload(0x40)
 12339 |     |             m3 := mload(0x60)
 12340 |     |             m4 := mload(0x80)
 12341 |     |             m5 := mload(0xa0)
 12342 |     |             m6 := mload(0xc0)
 12343 |     |             // Selector of `log(string,uint256,address,bool)`.
 12344 |     |             mstore(0x00, 0x82112a42)
 12345 |     |             mstore(0x20, 0x80)
 12346 |     |             mstore(0x40, p1)
 12347 |     |             mstore(0x60, p2)
 12348 |     |             mstore(0x80, p3)
 12349 |     |             writeString(0xa0, p0)
 12350 |     |         }
 12351 |     |         _sendLogPayload(0x1c, 0xc4);
 12352 |     |         /// @solidity memory-safe-assembly
 12353 |     |         assembly {
 12354 |     |             mstore(0x00, m0)
 12355 |     |             mstore(0x20, m1)
 12356 |     |             mstore(0x40, m2)
 12357 |     |             mstore(0x60, m3)
 12358 |     |             mstore(0x80, m4)
 12359 |     |             mstore(0xa0, m5)
 12360 |     |             mstore(0xc0, m6)
 12361 |     |         }
 12362 |     |     }
 12363 |     | 
 12364 |     |     function log(bytes32 p0, uint256 p1, address p2, uint256 p3) internal pure {
 12365 |     |         bytes32 m0;
 12366 |     |         bytes32 m1;
 12367 |     |         bytes32 m2;
 12368 |     |         bytes32 m3;
 12369 |     |         bytes32 m4;
 12370 |     |         bytes32 m5;
 12371 |     |         bytes32 m6;
 12372 |     |         /// @solidity memory-safe-assembly
 12373 |     |         assembly {
 12374 |     |             function writeString(pos, w) {
 12375 |     |                 let length := 0
 12376 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
 12377 |     |                 mstore(pos, length)
 12378 |     |                 let shift := sub(256, shl(3, length))
 12379 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
 12380 |     |             }
 12381 |     |             m0 := mload(0x00)
 12382 |     |             m1 := mload(0x20)
 12383 |     |             m2 := mload(0x40)
 12384 |     |             m3 := mload(0x60)
 12385 |     |             m4 := mload(0x80)
 12386 |     |             m5 := mload(0xa0)
 12387 |     |             m6 := mload(0xc0)
 12388 |     |             // Selector of `log(string,uint256,address,uint256)`.
 12389 |     |             mstore(0x00, 0x4f04fdc6)
 12390 |     |             mstore(0x20, 0x80)
 12391 |     |             mstore(0x40, p1)
 12392 |     |             mstore(0x60, p2)
 12393 |     |             mstore(0x80, p3)
 12394 |     |             writeString(0xa0, p0)
 12395 |     |         }
 12396 |     |         _sendLogPayload(0x1c, 0xc4);
 12397 |     |         /// @solidity memory-safe-assembly
 12398 |     |         assembly {
 12399 |     |             mstore(0x00, m0)
 12400 |     |             mstore(0x20, m1)
 12401 |     |             mstore(0x40, m2)
 12402 |     |             mstore(0x60, m3)
 12403 |     |             mstore(0x80, m4)
 12404 |     |             mstore(0xa0, m5)
 12405 |     |             mstore(0xc0, m6)
 12406 |     |         }
 12407 |     |     }
 12408 |     | 
 12409 |     |     function log(bytes32 p0, uint256 p1, address p2, bytes32 p3) internal pure {
 12410 |     |         bytes32 m0;
 12411 |     |         bytes32 m1;
 12412 |     |         bytes32 m2;
 12413 |     |         bytes32 m3;
 12414 |     |         bytes32 m4;
 12415 |     |         bytes32 m5;
 12416 |     |         bytes32 m6;
 12417 |     |         bytes32 m7;
 12418 |     |         bytes32 m8;
 12419 |     |         /// @solidity memory-safe-assembly
 12420 |     |         assembly {
 12421 |     |             function writeString(pos, w) {
 12422 |     |                 let length := 0
 12423 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
 12424 |     |                 mstore(pos, length)
 12425 |     |                 let shift := sub(256, shl(3, length))
 12426 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
 12427 |     |             }
 12428 |     |             m0 := mload(0x00)
 12429 |     |             m1 := mload(0x20)
 12430 |     |             m2 := mload(0x40)
 12431 |     |             m3 := mload(0x60)
 12432 |     |             m4 := mload(0x80)
 12433 |     |             m5 := mload(0xa0)
 12434 |     |             m6 := mload(0xc0)
 12435 |     |             m7 := mload(0xe0)
 12436 |     |             m8 := mload(0x100)
 12437 |     |             // Selector of `log(string,uint256,address,string)`.
 12438 |     |             mstore(0x00, 0x9ffb2f93)
 12439 |     |             mstore(0x20, 0x80)
 12440 |     |             mstore(0x40, p1)
 12441 |     |             mstore(0x60, p2)
 12442 |     |             mstore(0x80, 0xc0)
 12443 |     |             writeString(0xa0, p0)
 12444 |     |             writeString(0xe0, p3)
 12445 |     |         }
 12446 |     |         _sendLogPayload(0x1c, 0x104);
 12447 |     |         /// @solidity memory-safe-assembly
 12448 |     |         assembly {
 12449 |     |             mstore(0x00, m0)
 12450 |     |             mstore(0x20, m1)
 12451 |     |             mstore(0x40, m2)
 12452 |     |             mstore(0x60, m3)
 12453 |     |             mstore(0x80, m4)
 12454 |     |             mstore(0xa0, m5)
 12455 |     |             mstore(0xc0, m6)
 12456 |     |             mstore(0xe0, m7)
 12457 |     |             mstore(0x100, m8)
 12458 |     |         }
 12459 |     |     }
 12460 |     | 
 12461 |     |     function log(bytes32 p0, uint256 p1, bool p2, address p3) internal pure {
 12462 |     |         bytes32 m0;
 12463 |     |         bytes32 m1;
 12464 |     |         bytes32 m2;
 12465 |     |         bytes32 m3;
 12466 |     |         bytes32 m4;
 12467 |     |         bytes32 m5;
 12468 |     |         bytes32 m6;
 12469 |     |         /// @solidity memory-safe-assembly
 12470 |     |         assembly {
 12471 |     |             function writeString(pos, w) {
 12472 |     |                 let length := 0
 12473 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
 12474 |     |                 mstore(pos, length)
 12475 |     |                 let shift := sub(256, shl(3, length))
 12476 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
 12477 |     |             }
 12478 |     |             m0 := mload(0x00)
 12479 |     |             m1 := mload(0x20)
 12480 |     |             m2 := mload(0x40)
 12481 |     |             m3 := mload(0x60)
 12482 |     |             m4 := mload(0x80)
 12483 |     |             m5 := mload(0xa0)
 12484 |     |             m6 := mload(0xc0)
 12485 |     |             // Selector of `log(string,uint256,bool,address)`.
 12486 |     |             mstore(0x00, 0xe0e95b98)
 12487 |     |             mstore(0x20, 0x80)
 12488 |     |             mstore(0x40, p1)
 12489 |     |             mstore(0x60, p2)
 12490 |     |             mstore(0x80, p3)
 12491 |     |             writeString(0xa0, p0)
 12492 |     |         }
 12493 |     |         _sendLogPayload(0x1c, 0xc4);
 12494 |     |         /// @solidity memory-safe-assembly
 12495 |     |         assembly {
 12496 |     |             mstore(0x00, m0)
 12497 |     |             mstore(0x20, m1)
 12498 |     |             mstore(0x40, m2)
 12499 |     |             mstore(0x60, m3)
 12500 |     |             mstore(0x80, m4)
 12501 |     |             mstore(0xa0, m5)
 12502 |     |             mstore(0xc0, m6)
 12503 |     |         }
 12504 |     |     }
 12505 |     | 
 12506 |     |     function log(bytes32 p0, uint256 p1, bool p2, bool p3) internal pure {
 12507 |     |         bytes32 m0;
 12508 |     |         bytes32 m1;
 12509 |     |         bytes32 m2;
 12510 |     |         bytes32 m3;
 12511 |     |         bytes32 m4;
 12512 |     |         bytes32 m5;
 12513 |     |         bytes32 m6;
 12514 |     |         /// @solidity memory-safe-assembly
 12515 |     |         assembly {
 12516 |     |             function writeString(pos, w) {
 12517 |     |                 let length := 0
 12518 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
 12519 |     |                 mstore(pos, length)
 12520 |     |                 let shift := sub(256, shl(3, length))
 12521 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
 12522 |     |             }
 12523 |     |             m0 := mload(0x00)
 12524 |     |             m1 := mload(0x20)
 12525 |     |             m2 := mload(0x40)
 12526 |     |             m3 := mload(0x60)
 12527 |     |             m4 := mload(0x80)
 12528 |     |             m5 := mload(0xa0)
 12529 |     |             m6 := mload(0xc0)
 12530 |     |             // Selector of `log(string,uint256,bool,bool)`.
 12531 |     |             mstore(0x00, 0x354c36d6)
 12532 |     |             mstore(0x20, 0x80)
 12533 |     |             mstore(0x40, p1)
 12534 |     |             mstore(0x60, p2)
 12535 |     |             mstore(0x80, p3)
 12536 |     |             writeString(0xa0, p0)
 12537 |     |         }
 12538 |     |         _sendLogPayload(0x1c, 0xc4);
 12539 |     |         /// @solidity memory-safe-assembly
 12540 |     |         assembly {
 12541 |     |             mstore(0x00, m0)
 12542 |     |             mstore(0x20, m1)
 12543 |     |             mstore(0x40, m2)
 12544 |     |             mstore(0x60, m3)
 12545 |     |             mstore(0x80, m4)
 12546 |     |             mstore(0xa0, m5)
 12547 |     |             mstore(0xc0, m6)
 12548 |     |         }
 12549 |     |     }
 12550 |     | 
 12551 |     |     function log(bytes32 p0, uint256 p1, bool p2, uint256 p3) internal pure {
 12552 |     |         bytes32 m0;
 12553 |     |         bytes32 m1;
 12554 |     |         bytes32 m2;
 12555 |     |         bytes32 m3;
 12556 |     |         bytes32 m4;
 12557 |     |         bytes32 m5;
 12558 |     |         bytes32 m6;
 12559 |     |         /// @solidity memory-safe-assembly
 12560 |     |         assembly {
 12561 |     |             function writeString(pos, w) {
 12562 |     |                 let length := 0
 12563 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
 12564 |     |                 mstore(pos, length)
 12565 |     |                 let shift := sub(256, shl(3, length))
 12566 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
 12567 |     |             }
 12568 |     |             m0 := mload(0x00)
 12569 |     |             m1 := mload(0x20)
 12570 |     |             m2 := mload(0x40)
 12571 |     |             m3 := mload(0x60)
 12572 |     |             m4 := mload(0x80)
 12573 |     |             m5 := mload(0xa0)
 12574 |     |             m6 := mload(0xc0)
 12575 |     |             // Selector of `log(string,uint256,bool,uint256)`.
 12576 |     |             mstore(0x00, 0xe41b6f6f)
 12577 |     |             mstore(0x20, 0x80)
 12578 |     |             mstore(0x40, p1)
 12579 |     |             mstore(0x60, p2)
 12580 |     |             mstore(0x80, p3)
 12581 |     |             writeString(0xa0, p0)
 12582 |     |         }
 12583 |     |         _sendLogPayload(0x1c, 0xc4);
 12584 |     |         /// @solidity memory-safe-assembly
 12585 |     |         assembly {
 12586 |     |             mstore(0x00, m0)
 12587 |     |             mstore(0x20, m1)
 12588 |     |             mstore(0x40, m2)
 12589 |     |             mstore(0x60, m3)
 12590 |     |             mstore(0x80, m4)
 12591 |     |             mstore(0xa0, m5)
 12592 |     |             mstore(0xc0, m6)
 12593 |     |         }
 12594 |     |     }
 12595 |     | 
 12596 |     |     function log(bytes32 p0, uint256 p1, bool p2, bytes32 p3) internal pure {
 12597 |     |         bytes32 m0;
 12598 |     |         bytes32 m1;
 12599 |     |         bytes32 m2;
 12600 |     |         bytes32 m3;
 12601 |     |         bytes32 m4;
 12602 |     |         bytes32 m5;
 12603 |     |         bytes32 m6;
 12604 |     |         bytes32 m7;
 12605 |     |         bytes32 m8;
 12606 |     |         /// @solidity memory-safe-assembly
 12607 |     |         assembly {
 12608 |     |             function writeString(pos, w) {
 12609 |     |                 let length := 0
 12610 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
 12611 |     |                 mstore(pos, length)
 12612 |     |                 let shift := sub(256, shl(3, length))
 12613 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
 12614 |     |             }
 12615 |     |             m0 := mload(0x00)
 12616 |     |             m1 := mload(0x20)
 12617 |     |             m2 := mload(0x40)
 12618 |     |             m3 := mload(0x60)
 12619 |     |             m4 := mload(0x80)
 12620 |     |             m5 := mload(0xa0)
 12621 |     |             m6 := mload(0xc0)
 12622 |     |             m7 := mload(0xe0)
 12623 |     |             m8 := mload(0x100)
 12624 |     |             // Selector of `log(string,uint256,bool,string)`.
 12625 |     |             mstore(0x00, 0xabf73a98)
 12626 |     |             mstore(0x20, 0x80)
 12627 |     |             mstore(0x40, p1)
 12628 |     |             mstore(0x60, p2)
 12629 |     |             mstore(0x80, 0xc0)
 12630 |     |             writeString(0xa0, p0)
 12631 |     |             writeString(0xe0, p3)
 12632 |     |         }
 12633 |     |         _sendLogPayload(0x1c, 0x104);
 12634 |     |         /// @solidity memory-safe-assembly
 12635 |     |         assembly {
 12636 |     |             mstore(0x00, m0)
 12637 |     |             mstore(0x20, m1)
 12638 |     |             mstore(0x40, m2)
 12639 |     |             mstore(0x60, m3)
 12640 |     |             mstore(0x80, m4)
 12641 |     |             mstore(0xa0, m5)
 12642 |     |             mstore(0xc0, m6)
 12643 |     |             mstore(0xe0, m7)
 12644 |     |             mstore(0x100, m8)
 12645 |     |         }
 12646 |     |     }
 12647 |     | 
 12648 |     |     function log(bytes32 p0, uint256 p1, uint256 p2, address p3) internal pure {
 12649 |     |         bytes32 m0;
 12650 |     |         bytes32 m1;
 12651 |     |         bytes32 m2;
 12652 |     |         bytes32 m3;
 12653 |     |         bytes32 m4;
 12654 |     |         bytes32 m5;
 12655 |     |         bytes32 m6;
 12656 |     |         /// @solidity memory-safe-assembly
 12657 |     |         assembly {
 12658 |     |             function writeString(pos, w) {
 12659 |     |                 let length := 0
 12660 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
 12661 |     |                 mstore(pos, length)
 12662 |     |                 let shift := sub(256, shl(3, length))
 12663 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
 12664 |     |             }
 12665 |     |             m0 := mload(0x00)
 12666 |     |             m1 := mload(0x20)
 12667 |     |             m2 := mload(0x40)
 12668 |     |             m3 := mload(0x60)
 12669 |     |             m4 := mload(0x80)
 12670 |     |             m5 := mload(0xa0)
 12671 |     |             m6 := mload(0xc0)
 12672 |     |             // Selector of `log(string,uint256,uint256,address)`.
 12673 |     |             mstore(0x00, 0xe21de278)
 12674 |     |             mstore(0x20, 0x80)
 12675 |     |             mstore(0x40, p1)
 12676 |     |             mstore(0x60, p2)
 12677 |     |             mstore(0x80, p3)
 12678 |     |             writeString(0xa0, p0)
 12679 |     |         }
 12680 |     |         _sendLogPayload(0x1c, 0xc4);
 12681 |     |         /// @solidity memory-safe-assembly
 12682 |     |         assembly {
 12683 |     |             mstore(0x00, m0)
 12684 |     |             mstore(0x20, m1)
 12685 |     |             mstore(0x40, m2)
 12686 |     |             mstore(0x60, m3)
 12687 |     |             mstore(0x80, m4)
 12688 |     |             mstore(0xa0, m5)
 12689 |     |             mstore(0xc0, m6)
 12690 |     |         }
 12691 |     |     }
 12692 |     | 
 12693 |     |     function log(bytes32 p0, uint256 p1, uint256 p2, bool p3) internal pure {
 12694 |     |         bytes32 m0;
 12695 |     |         bytes32 m1;
 12696 |     |         bytes32 m2;
 12697 |     |         bytes32 m3;
 12698 |     |         bytes32 m4;
 12699 |     |         bytes32 m5;
 12700 |     |         bytes32 m6;
 12701 |     |         /// @solidity memory-safe-assembly
 12702 |     |         assembly {
 12703 |     |             function writeString(pos, w) {
 12704 |     |                 let length := 0
 12705 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
 12706 |     |                 mstore(pos, length)
 12707 |     |                 let shift := sub(256, shl(3, length))
 12708 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
 12709 |     |             }
 12710 |     |             m0 := mload(0x00)
 12711 |     |             m1 := mload(0x20)
 12712 |     |             m2 := mload(0x40)
 12713 |     |             m3 := mload(0x60)
 12714 |     |             m4 := mload(0x80)
 12715 |     |             m5 := mload(0xa0)
 12716 |     |             m6 := mload(0xc0)
 12717 |     |             // Selector of `log(string,uint256,uint256,bool)`.
 12718 |     |             mstore(0x00, 0x7626db92)
 12719 |     |             mstore(0x20, 0x80)
 12720 |     |             mstore(0x40, p1)
 12721 |     |             mstore(0x60, p2)
 12722 |     |             mstore(0x80, p3)
 12723 |     |             writeString(0xa0, p0)
 12724 |     |         }
 12725 |     |         _sendLogPayload(0x1c, 0xc4);
 12726 |     |         /// @solidity memory-safe-assembly
 12727 |     |         assembly {
 12728 |     |             mstore(0x00, m0)
 12729 |     |             mstore(0x20, m1)
 12730 |     |             mstore(0x40, m2)
 12731 |     |             mstore(0x60, m3)
 12732 |     |             mstore(0x80, m4)
 12733 |     |             mstore(0xa0, m5)
 12734 |     |             mstore(0xc0, m6)
 12735 |     |         }
 12736 |     |     }
 12737 |     | 
 12738 |     |     function log(bytes32 p0, uint256 p1, uint256 p2, uint256 p3) internal pure {
 12739 |     |         bytes32 m0;
 12740 |     |         bytes32 m1;
 12741 |     |         bytes32 m2;
 12742 |     |         bytes32 m3;
 12743 |     |         bytes32 m4;
 12744 |     |         bytes32 m5;
 12745 |     |         bytes32 m6;
 12746 |     |         /// @solidity memory-safe-assembly
 12747 |     |         assembly {
 12748 |     |             function writeString(pos, w) {
 12749 |     |                 let length := 0
 12750 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
 12751 |     |                 mstore(pos, length)
 12752 |     |                 let shift := sub(256, shl(3, length))
 12753 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
 12754 |     |             }
 12755 |     |             m0 := mload(0x00)
 12756 |     |             m1 := mload(0x20)
 12757 |     |             m2 := mload(0x40)
 12758 |     |             m3 := mload(0x60)
 12759 |     |             m4 := mload(0x80)
 12760 |     |             m5 := mload(0xa0)
 12761 |     |             m6 := mload(0xc0)
 12762 |     |             // Selector of `log(string,uint256,uint256,uint256)`.
 12763 |     |             mstore(0x00, 0xa7a87853)
 12764 |     |             mstore(0x20, 0x80)
 12765 |     |             mstore(0x40, p1)
 12766 |     |             mstore(0x60, p2)
 12767 |     |             mstore(0x80, p3)
 12768 |     |             writeString(0xa0, p0)
 12769 |     |         }
 12770 |     |         _sendLogPayload(0x1c, 0xc4);
 12771 |     |         /// @solidity memory-safe-assembly
 12772 |     |         assembly {
 12773 |     |             mstore(0x00, m0)
 12774 |     |             mstore(0x20, m1)
 12775 |     |             mstore(0x40, m2)
 12776 |     |             mstore(0x60, m3)
 12777 |     |             mstore(0x80, m4)
 12778 |     |             mstore(0xa0, m5)
 12779 |     |             mstore(0xc0, m6)
 12780 |     |         }
 12781 |     |     }
 12782 |     | 
 12783 |     |     function log(bytes32 p0, uint256 p1, uint256 p2, bytes32 p3) internal pure {
 12784 |     |         bytes32 m0;
 12785 |     |         bytes32 m1;
 12786 |     |         bytes32 m2;
 12787 |     |         bytes32 m3;
 12788 |     |         bytes32 m4;
 12789 |     |         bytes32 m5;
 12790 |     |         bytes32 m6;
 12791 |     |         bytes32 m7;
 12792 |     |         bytes32 m8;
 12793 |     |         /// @solidity memory-safe-assembly
 12794 |     |         assembly {
 12795 |     |             function writeString(pos, w) {
 12796 |     |                 let length := 0
 12797 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
 12798 |     |                 mstore(pos, length)
 12799 |     |                 let shift := sub(256, shl(3, length))
 12800 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
 12801 |     |             }
 12802 |     |             m0 := mload(0x00)
 12803 |     |             m1 := mload(0x20)
 12804 |     |             m2 := mload(0x40)
 12805 |     |             m3 := mload(0x60)
 12806 |     |             m4 := mload(0x80)
 12807 |     |             m5 := mload(0xa0)
 12808 |     |             m6 := mload(0xc0)
 12809 |     |             m7 := mload(0xe0)
 12810 |     |             m8 := mload(0x100)
 12811 |     |             // Selector of `log(string,uint256,uint256,string)`.
 12812 |     |             mstore(0x00, 0x854b3496)
 12813 |     |             mstore(0x20, 0x80)
 12814 |     |             mstore(0x40, p1)
 12815 |     |             mstore(0x60, p2)
 12816 |     |             mstore(0x80, 0xc0)
 12817 |     |             writeString(0xa0, p0)
 12818 |     |             writeString(0xe0, p3)
 12819 |     |         }
 12820 |     |         _sendLogPayload(0x1c, 0x104);
 12821 |     |         /// @solidity memory-safe-assembly
 12822 |     |         assembly {
 12823 |     |             mstore(0x00, m0)
 12824 |     |             mstore(0x20, m1)
 12825 |     |             mstore(0x40, m2)
 12826 |     |             mstore(0x60, m3)
 12827 |     |             mstore(0x80, m4)
 12828 |     |             mstore(0xa0, m5)
 12829 |     |             mstore(0xc0, m6)
 12830 |     |             mstore(0xe0, m7)
 12831 |     |             mstore(0x100, m8)
 12832 |     |         }
 12833 |     |     }
 12834 |     | 
 12835 |     |     function log(bytes32 p0, uint256 p1, bytes32 p2, address p3) internal pure {
 12836 |     |         bytes32 m0;
 12837 |     |         bytes32 m1;
 12838 |     |         bytes32 m2;
 12839 |     |         bytes32 m3;
 12840 |     |         bytes32 m4;
 12841 |     |         bytes32 m5;
 12842 |     |         bytes32 m6;
 12843 |     |         bytes32 m7;
 12844 |     |         bytes32 m8;
 12845 |     |         /// @solidity memory-safe-assembly
 12846 |     |         assembly {
 12847 |     |             function writeString(pos, w) {
 12848 |     |                 let length := 0
 12849 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
 12850 |     |                 mstore(pos, length)
 12851 |     |                 let shift := sub(256, shl(3, length))
 12852 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
 12853 |     |             }
 12854 |     |             m0 := mload(0x00)
 12855 |     |             m1 := mload(0x20)
 12856 |     |             m2 := mload(0x40)
 12857 |     |             m3 := mload(0x60)
 12858 |     |             m4 := mload(0x80)
 12859 |     |             m5 := mload(0xa0)
 12860 |     |             m6 := mload(0xc0)
 12861 |     |             m7 := mload(0xe0)
 12862 |     |             m8 := mload(0x100)
 12863 |     |             // Selector of `log(string,uint256,string,address)`.
 12864 |     |             mstore(0x00, 0x7c4632a4)
 12865 |     |             mstore(0x20, 0x80)
 12866 |     |             mstore(0x40, p1)
 12867 |     |             mstore(0x60, 0xc0)
 12868 |     |             mstore(0x80, p3)
 12869 |     |             writeString(0xa0, p0)
 12870 |     |             writeString(0xe0, p2)
 12871 |     |         }
 12872 |     |         _sendLogPayload(0x1c, 0x104);
 12873 |     |         /// @solidity memory-safe-assembly
 12874 |     |         assembly {
 12875 |     |             mstore(0x00, m0)
 12876 |     |             mstore(0x20, m1)
 12877 |     |             mstore(0x40, m2)
 12878 |     |             mstore(0x60, m3)
 12879 |     |             mstore(0x80, m4)
 12880 |     |             mstore(0xa0, m5)
 12881 |     |             mstore(0xc0, m6)
 12882 |     |             mstore(0xe0, m7)
 12883 |     |             mstore(0x100, m8)
 12884 |     |         }
 12885 |     |     }
 12886 |     | 
 12887 |     |     function log(bytes32 p0, uint256 p1, bytes32 p2, bool p3) internal pure {
 12888 |     |         bytes32 m0;
 12889 |     |         bytes32 m1;
 12890 |     |         bytes32 m2;
 12891 |     |         bytes32 m3;
 12892 |     |         bytes32 m4;
 12893 |     |         bytes32 m5;
 12894 |     |         bytes32 m6;
 12895 |     |         bytes32 m7;
 12896 |     |         bytes32 m8;
 12897 |     |         /// @solidity memory-safe-assembly
 12898 |     |         assembly {
 12899 |     |             function writeString(pos, w) {
 12900 |     |                 let length := 0
 12901 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
 12902 |     |                 mstore(pos, length)
 12903 |     |                 let shift := sub(256, shl(3, length))
 12904 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
 12905 |     |             }
 12906 |     |             m0 := mload(0x00)
 12907 |     |             m1 := mload(0x20)
 12908 |     |             m2 := mload(0x40)
 12909 |     |             m3 := mload(0x60)
 12910 |     |             m4 := mload(0x80)
 12911 |     |             m5 := mload(0xa0)
 12912 |     |             m6 := mload(0xc0)
 12913 |     |             m7 := mload(0xe0)
 12914 |     |             m8 := mload(0x100)
 12915 |     |             // Selector of `log(string,uint256,string,bool)`.
 12916 |     |             mstore(0x00, 0x7d24491d)
 12917 |     |             mstore(0x20, 0x80)
 12918 |     |             mstore(0x40, p1)
 12919 |     |             mstore(0x60, 0xc0)
 12920 |     |             mstore(0x80, p3)
 12921 |     |             writeString(0xa0, p0)
 12922 |     |             writeString(0xe0, p2)
 12923 |     |         }
 12924 |     |         _sendLogPayload(0x1c, 0x104);
 12925 |     |         /// @solidity memory-safe-assembly
 12926 |     |         assembly {
 12927 |     |             mstore(0x00, m0)
 12928 |     |             mstore(0x20, m1)
 12929 |     |             mstore(0x40, m2)
 12930 |     |             mstore(0x60, m3)
 12931 |     |             mstore(0x80, m4)
 12932 |     |             mstore(0xa0, m5)
 12933 |     |             mstore(0xc0, m6)
 12934 |     |             mstore(0xe0, m7)
 12935 |     |             mstore(0x100, m8)
 12936 |     |         }
 12937 |     |     }
 12938 |     | 
 12939 |     |     function log(bytes32 p0, uint256 p1, bytes32 p2, uint256 p3) internal pure {
 12940 |     |         bytes32 m0;
 12941 |     |         bytes32 m1;
 12942 |     |         bytes32 m2;
 12943 |     |         bytes32 m3;
 12944 |     |         bytes32 m4;
 12945 |     |         bytes32 m5;
 12946 |     |         bytes32 m6;
 12947 |     |         bytes32 m7;
 12948 |     |         bytes32 m8;
 12949 |     |         /// @solidity memory-safe-assembly
 12950 |     |         assembly {
 12951 |     |             function writeString(pos, w) {
 12952 |     |                 let length := 0
 12953 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
 12954 |     |                 mstore(pos, length)
 12955 |     |                 let shift := sub(256, shl(3, length))
 12956 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
 12957 |     |             }
 12958 |     |             m0 := mload(0x00)
 12959 |     |             m1 := mload(0x20)
 12960 |     |             m2 := mload(0x40)
 12961 |     |             m3 := mload(0x60)
 12962 |     |             m4 := mload(0x80)
 12963 |     |             m5 := mload(0xa0)
 12964 |     |             m6 := mload(0xc0)
 12965 |     |             m7 := mload(0xe0)
 12966 |     |             m8 := mload(0x100)
 12967 |     |             // Selector of `log(string,uint256,string,uint256)`.
 12968 |     |             mstore(0x00, 0xc67ea9d1)
 12969 |     |             mstore(0x20, 0x80)
 12970 |     |             mstore(0x40, p1)
 12971 |     |             mstore(0x60, 0xc0)
 12972 |     |             mstore(0x80, p3)
 12973 |     |             writeString(0xa0, p0)
 12974 |     |             writeString(0xe0, p2)
 12975 |     |         }
 12976 |     |         _sendLogPayload(0x1c, 0x104);
 12977 |     |         /// @solidity memory-safe-assembly
 12978 |     |         assembly {
 12979 |     |             mstore(0x00, m0)
 12980 |     |             mstore(0x20, m1)
 12981 |     |             mstore(0x40, m2)
 12982 |     |             mstore(0x60, m3)
 12983 |     |             mstore(0x80, m4)
 12984 |     |             mstore(0xa0, m5)
 12985 |     |             mstore(0xc0, m6)
 12986 |     |             mstore(0xe0, m7)
 12987 |     |             mstore(0x100, m8)
 12988 |     |         }
 12989 |     |     }
 12990 |     | 
 12991 |     |     function log(bytes32 p0, uint256 p1, bytes32 p2, bytes32 p3) internal pure {
 12992 |     |         bytes32 m0;
 12993 |     |         bytes32 m1;
 12994 |     |         bytes32 m2;
 12995 |     |         bytes32 m3;
 12996 |     |         bytes32 m4;
 12997 |     |         bytes32 m5;
 12998 |     |         bytes32 m6;
 12999 |     |         bytes32 m7;
 13000 |     |         bytes32 m8;
 13001 |     |         bytes32 m9;
 13002 |     |         bytes32 m10;
 13003 |     |         /// @solidity memory-safe-assembly
 13004 |     |         assembly {
 13005 |     |             function writeString(pos, w) {
 13006 |     |                 let length := 0
 13007 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
 13008 |     |                 mstore(pos, length)
 13009 |     |                 let shift := sub(256, shl(3, length))
 13010 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
 13011 |     |             }
 13012 |     |             m0 := mload(0x00)
 13013 |     |             m1 := mload(0x20)
 13014 |     |             m2 := mload(0x40)
 13015 |     |             m3 := mload(0x60)
 13016 |     |             m4 := mload(0x80)
 13017 |     |             m5 := mload(0xa0)
 13018 |     |             m6 := mload(0xc0)
 13019 |     |             m7 := mload(0xe0)
 13020 |     |             m8 := mload(0x100)
 13021 |     |             m9 := mload(0x120)
 13022 |     |             m10 := mload(0x140)
 13023 |     |             // Selector of `log(string,uint256,string,string)`.
 13024 |     |             mstore(0x00, 0x5ab84e1f)
 13025 |     |             mstore(0x20, 0x80)
 13026 |     |             mstore(0x40, p1)
 13027 |     |             mstore(0x60, 0xc0)
 13028 |     |             mstore(0x80, 0x100)
 13029 |     |             writeString(0xa0, p0)
 13030 |     |             writeString(0xe0, p2)
 13031 |     |             writeString(0x120, p3)
 13032 |     |         }
 13033 |     |         _sendLogPayload(0x1c, 0x144);
 13034 |     |         /// @solidity memory-safe-assembly
 13035 |     |         assembly {
 13036 |     |             mstore(0x00, m0)
 13037 |     |             mstore(0x20, m1)
 13038 |     |             mstore(0x40, m2)
 13039 |     |             mstore(0x60, m3)
 13040 |     |             mstore(0x80, m4)
 13041 |     |             mstore(0xa0, m5)
 13042 |     |             mstore(0xc0, m6)
 13043 |     |             mstore(0xe0, m7)
 13044 |     |             mstore(0x100, m8)
 13045 |     |             mstore(0x120, m9)
 13046 |     |             mstore(0x140, m10)
 13047 |     |         }
 13048 |     |     }
 13049 |     | 
 13050 |     |     function log(bytes32 p0, bytes32 p1, address p2, address p3) internal pure {
 13051 |     |         bytes32 m0;
 13052 |     |         bytes32 m1;
 13053 |     |         bytes32 m2;
 13054 |     |         bytes32 m3;
 13055 |     |         bytes32 m4;
 13056 |     |         bytes32 m5;
 13057 |     |         bytes32 m6;
 13058 |     |         bytes32 m7;
 13059 |     |         bytes32 m8;
 13060 |     |         /// @solidity memory-safe-assembly
 13061 |     |         assembly {
 13062 |     |             function writeString(pos, w) {
 13063 |     |                 let length := 0
 13064 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
 13065 |     |                 mstore(pos, length)
 13066 |     |                 let shift := sub(256, shl(3, length))
 13067 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
 13068 |     |             }
 13069 |     |             m0 := mload(0x00)
 13070 |     |             m1 := mload(0x20)
 13071 |     |             m2 := mload(0x40)
 13072 |     |             m3 := mload(0x60)
 13073 |     |             m4 := mload(0x80)
 13074 |     |             m5 := mload(0xa0)
 13075 |     |             m6 := mload(0xc0)
 13076 |     |             m7 := mload(0xe0)
 13077 |     |             m8 := mload(0x100)
 13078 |     |             // Selector of `log(string,string,address,address)`.
 13079 |     |             mstore(0x00, 0x439c7bef)
 13080 |     |             mstore(0x20, 0x80)
 13081 |     |             mstore(0x40, 0xc0)
 13082 |     |             mstore(0x60, p2)
 13083 |     |             mstore(0x80, p3)
 13084 |     |             writeString(0xa0, p0)
 13085 |     |             writeString(0xe0, p1)
 13086 |     |         }
 13087 |     |         _sendLogPayload(0x1c, 0x104);
 13088 |     |         /// @solidity memory-safe-assembly
 13089 |     |         assembly {
 13090 |     |             mstore(0x00, m0)
 13091 |     |             mstore(0x20, m1)
 13092 |     |             mstore(0x40, m2)
 13093 |     |             mstore(0x60, m3)
 13094 |     |             mstore(0x80, m4)
 13095 |     |             mstore(0xa0, m5)
 13096 |     |             mstore(0xc0, m6)
 13097 |     |             mstore(0xe0, m7)
 13098 |     |             mstore(0x100, m8)
 13099 |     |         }
 13100 |     |     }
 13101 |     | 
 13102 |     |     function log(bytes32 p0, bytes32 p1, address p2, bool p3) internal pure {
 13103 |     |         bytes32 m0;
 13104 |     |         bytes32 m1;
 13105 |     |         bytes32 m2;
 13106 |     |         bytes32 m3;
 13107 |     |         bytes32 m4;
 13108 |     |         bytes32 m5;
 13109 |     |         bytes32 m6;
 13110 |     |         bytes32 m7;
 13111 |     |         bytes32 m8;
 13112 |     |         /// @solidity memory-safe-assembly
 13113 |     |         assembly {
 13114 |     |             function writeString(pos, w) {
 13115 |     |                 let length := 0
 13116 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
 13117 |     |                 mstore(pos, length)
 13118 |     |                 let shift := sub(256, shl(3, length))
 13119 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
 13120 |     |             }
 13121 |     |             m0 := mload(0x00)
 13122 |     |             m1 := mload(0x20)
 13123 |     |             m2 := mload(0x40)
 13124 |     |             m3 := mload(0x60)
 13125 |     |             m4 := mload(0x80)
 13126 |     |             m5 := mload(0xa0)
 13127 |     |             m6 := mload(0xc0)
 13128 |     |             m7 := mload(0xe0)
 13129 |     |             m8 := mload(0x100)
 13130 |     |             // Selector of `log(string,string,address,bool)`.
 13131 |     |             mstore(0x00, 0x5ccd4e37)
 13132 |     |             mstore(0x20, 0x80)
 13133 |     |             mstore(0x40, 0xc0)
 13134 |     |             mstore(0x60, p2)
 13135 |     |             mstore(0x80, p3)
 13136 |     |             writeString(0xa0, p0)
 13137 |     |             writeString(0xe0, p1)
 13138 |     |         }
 13139 |     |         _sendLogPayload(0x1c, 0x104);
 13140 |     |         /// @solidity memory-safe-assembly
 13141 |     |         assembly {
 13142 |     |             mstore(0x00, m0)
 13143 |     |             mstore(0x20, m1)
 13144 |     |             mstore(0x40, m2)
 13145 |     |             mstore(0x60, m3)
 13146 |     |             mstore(0x80, m4)
 13147 |     |             mstore(0xa0, m5)
 13148 |     |             mstore(0xc0, m6)
 13149 |     |             mstore(0xe0, m7)
 13150 |     |             mstore(0x100, m8)
 13151 |     |         }
 13152 |     |     }
 13153 |     | 
 13154 |     |     function log(bytes32 p0, bytes32 p1, address p2, uint256 p3) internal pure {
 13155 |     |         bytes32 m0;
 13156 |     |         bytes32 m1;
 13157 |     |         bytes32 m2;
 13158 |     |         bytes32 m3;
 13159 |     |         bytes32 m4;
 13160 |     |         bytes32 m5;
 13161 |     |         bytes32 m6;
 13162 |     |         bytes32 m7;
 13163 |     |         bytes32 m8;
 13164 |     |         /// @solidity memory-safe-assembly
 13165 |     |         assembly {
 13166 |     |             function writeString(pos, w) {
 13167 |     |                 let length := 0
 13168 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
 13169 |     |                 mstore(pos, length)
 13170 |     |                 let shift := sub(256, shl(3, length))
 13171 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
 13172 |     |             }
 13173 |     |             m0 := mload(0x00)
 13174 |     |             m1 := mload(0x20)
 13175 |     |             m2 := mload(0x40)
 13176 |     |             m3 := mload(0x60)
 13177 |     |             m4 := mload(0x80)
 13178 |     |             m5 := mload(0xa0)
 13179 |     |             m6 := mload(0xc0)
 13180 |     |             m7 := mload(0xe0)
 13181 |     |             m8 := mload(0x100)
 13182 |     |             // Selector of `log(string,string,address,uint256)`.
 13183 |     |             mstore(0x00, 0x7cc3c607)
 13184 |     |             mstore(0x20, 0x80)
 13185 |     |             mstore(0x40, 0xc0)
 13186 |     |             mstore(0x60, p2)
 13187 |     |             mstore(0x80, p3)
 13188 |     |             writeString(0xa0, p0)
 13189 |     |             writeString(0xe0, p1)
 13190 |     |         }
 13191 |     |         _sendLogPayload(0x1c, 0x104);
 13192 |     |         /// @solidity memory-safe-assembly
 13193 |     |         assembly {
 13194 |     |             mstore(0x00, m0)
 13195 |     |             mstore(0x20, m1)
 13196 |     |             mstore(0x40, m2)
 13197 |     |             mstore(0x60, m3)
 13198 |     |             mstore(0x80, m4)
 13199 |     |             mstore(0xa0, m5)
 13200 |     |             mstore(0xc0, m6)
 13201 |     |             mstore(0xe0, m7)
 13202 |     |             mstore(0x100, m8)
 13203 |     |         }
 13204 |     |     }
 13205 |     | 
 13206 |     |     function log(bytes32 p0, bytes32 p1, address p2, bytes32 p3) internal pure {
 13207 |     |         bytes32 m0;
 13208 |     |         bytes32 m1;
 13209 |     |         bytes32 m2;
 13210 |     |         bytes32 m3;
 13211 |     |         bytes32 m4;
 13212 |     |         bytes32 m5;
 13213 |     |         bytes32 m6;
 13214 |     |         bytes32 m7;
 13215 |     |         bytes32 m8;
 13216 |     |         bytes32 m9;
 13217 |     |         bytes32 m10;
 13218 |     |         /// @solidity memory-safe-assembly
 13219 |     |         assembly {
 13220 |     |             function writeString(pos, w) {
 13221 |     |                 let length := 0
 13222 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
 13223 |     |                 mstore(pos, length)
 13224 |     |                 let shift := sub(256, shl(3, length))
 13225 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
 13226 |     |             }
 13227 |     |             m0 := mload(0x00)
 13228 |     |             m1 := mload(0x20)
 13229 |     |             m2 := mload(0x40)
 13230 |     |             m3 := mload(0x60)
 13231 |     |             m4 := mload(0x80)
 13232 |     |             m5 := mload(0xa0)
 13233 |     |             m6 := mload(0xc0)
 13234 |     |             m7 := mload(0xe0)
 13235 |     |             m8 := mload(0x100)
 13236 |     |             m9 := mload(0x120)
 13237 |     |             m10 := mload(0x140)
 13238 |     |             // Selector of `log(string,string,address,string)`.
 13239 |     |             mstore(0x00, 0xeb1bff80)
 13240 |     |             mstore(0x20, 0x80)
 13241 |     |             mstore(0x40, 0xc0)
 13242 |     |             mstore(0x60, p2)
 13243 |     |             mstore(0x80, 0x100)
 13244 |     |             writeString(0xa0, p0)
 13245 |     |             writeString(0xe0, p1)
 13246 |     |             writeString(0x120, p3)
 13247 |     |         }
 13248 |     |         _sendLogPayload(0x1c, 0x144);
 13249 |     |         /// @solidity memory-safe-assembly
 13250 |     |         assembly {
 13251 |     |             mstore(0x00, m0)
 13252 |     |             mstore(0x20, m1)
 13253 |     |             mstore(0x40, m2)
 13254 |     |             mstore(0x60, m3)
 13255 |     |             mstore(0x80, m4)
 13256 |     |             mstore(0xa0, m5)
 13257 |     |             mstore(0xc0, m6)
 13258 |     |             mstore(0xe0, m7)
 13259 |     |             mstore(0x100, m8)
 13260 |     |             mstore(0x120, m9)
 13261 |     |             mstore(0x140, m10)
 13262 |     |         }
 13263 |     |     }
 13264 |     | 
 13265 |     |     function log(bytes32 p0, bytes32 p1, bool p2, address p3) internal pure {
 13266 |     |         bytes32 m0;
 13267 |     |         bytes32 m1;
 13268 |     |         bytes32 m2;
 13269 |     |         bytes32 m3;
 13270 |     |         bytes32 m4;
 13271 |     |         bytes32 m5;
 13272 |     |         bytes32 m6;
 13273 |     |         bytes32 m7;
 13274 |     |         bytes32 m8;
 13275 |     |         /// @solidity memory-safe-assembly
 13276 |     |         assembly {
 13277 |     |             function writeString(pos, w) {
 13278 |     |                 let length := 0
 13279 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
 13280 |     |                 mstore(pos, length)
 13281 |     |                 let shift := sub(256, shl(3, length))
 13282 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
 13283 |     |             }
 13284 |     |             m0 := mload(0x00)
 13285 |     |             m1 := mload(0x20)
 13286 |     |             m2 := mload(0x40)
 13287 |     |             m3 := mload(0x60)
 13288 |     |             m4 := mload(0x80)
 13289 |     |             m5 := mload(0xa0)
 13290 |     |             m6 := mload(0xc0)
 13291 |     |             m7 := mload(0xe0)
 13292 |     |             m8 := mload(0x100)
 13293 |     |             // Selector of `log(string,string,bool,address)`.
 13294 |     |             mstore(0x00, 0xc371c7db)
 13295 |     |             mstore(0x20, 0x80)
 13296 |     |             mstore(0x40, 0xc0)
 13297 |     |             mstore(0x60, p2)
 13298 |     |             mstore(0x80, p3)
 13299 |     |             writeString(0xa0, p0)
 13300 |     |             writeString(0xe0, p1)
 13301 |     |         }
 13302 |     |         _sendLogPayload(0x1c, 0x104);
 13303 |     |         /// @solidity memory-safe-assembly
 13304 |     |         assembly {
 13305 |     |             mstore(0x00, m0)
 13306 |     |             mstore(0x20, m1)
 13307 |     |             mstore(0x40, m2)
 13308 |     |             mstore(0x60, m3)
 13309 |     |             mstore(0x80, m4)
 13310 |     |             mstore(0xa0, m5)
 13311 |     |             mstore(0xc0, m6)
 13312 |     |             mstore(0xe0, m7)
 13313 |     |             mstore(0x100, m8)
 13314 |     |         }
 13315 |     |     }
 13316 |     | 
 13317 |     |     function log(bytes32 p0, bytes32 p1, bool p2, bool p3) internal pure {
 13318 |     |         bytes32 m0;
 13319 |     |         bytes32 m1;
 13320 |     |         bytes32 m2;
 13321 |     |         bytes32 m3;
 13322 |     |         bytes32 m4;
 13323 |     |         bytes32 m5;
 13324 |     |         bytes32 m6;
 13325 |     |         bytes32 m7;
 13326 |     |         bytes32 m8;
 13327 |     |         /// @solidity memory-safe-assembly
 13328 |     |         assembly {
 13329 |     |             function writeString(pos, w) {
 13330 |     |                 let length := 0
 13331 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
 13332 |     |                 mstore(pos, length)
 13333 |     |                 let shift := sub(256, shl(3, length))
 13334 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
 13335 |     |             }
 13336 |     |             m0 := mload(0x00)
 13337 |     |             m1 := mload(0x20)
 13338 |     |             m2 := mload(0x40)
 13339 |     |             m3 := mload(0x60)
 13340 |     |             m4 := mload(0x80)
 13341 |     |             m5 := mload(0xa0)
 13342 |     |             m6 := mload(0xc0)
 13343 |     |             m7 := mload(0xe0)
 13344 |     |             m8 := mload(0x100)
 13345 |     |             // Selector of `log(string,string,bool,bool)`.
 13346 |     |             mstore(0x00, 0x40785869)
 13347 |     |             mstore(0x20, 0x80)
 13348 |     |             mstore(0x40, 0xc0)
 13349 |     |             mstore(0x60, p2)
 13350 |     |             mstore(0x80, p3)
 13351 |     |             writeString(0xa0, p0)
 13352 |     |             writeString(0xe0, p1)
 13353 |     |         }
 13354 |     |         _sendLogPayload(0x1c, 0x104);
 13355 |     |         /// @solidity memory-safe-assembly
 13356 |     |         assembly {
 13357 |     |             mstore(0x00, m0)
 13358 |     |             mstore(0x20, m1)
 13359 |     |             mstore(0x40, m2)
 13360 |     |             mstore(0x60, m3)
 13361 |     |             mstore(0x80, m4)
 13362 |     |             mstore(0xa0, m5)
 13363 |     |             mstore(0xc0, m6)
 13364 |     |             mstore(0xe0, m7)
 13365 |     |             mstore(0x100, m8)
 13366 |     |         }
 13367 |     |     }
 13368 |     | 
 13369 |     |     function log(bytes32 p0, bytes32 p1, bool p2, uint256 p3) internal pure {
 13370 |     |         bytes32 m0;
 13371 |     |         bytes32 m1;
 13372 |     |         bytes32 m2;
 13373 |     |         bytes32 m3;
 13374 |     |         bytes32 m4;
 13375 |     |         bytes32 m5;
 13376 |     |         bytes32 m6;
 13377 |     |         bytes32 m7;
 13378 |     |         bytes32 m8;
 13379 |     |         /// @solidity memory-safe-assembly
 13380 |     |         assembly {
 13381 |     |             function writeString(pos, w) {
 13382 |     |                 let length := 0
 13383 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
 13384 |     |                 mstore(pos, length)
 13385 |     |                 let shift := sub(256, shl(3, length))
 13386 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
 13387 |     |             }
 13388 |     |             m0 := mload(0x00)
 13389 |     |             m1 := mload(0x20)
 13390 |     |             m2 := mload(0x40)
 13391 |     |             m3 := mload(0x60)
 13392 |     |             m4 := mload(0x80)
 13393 |     |             m5 := mload(0xa0)
 13394 |     |             m6 := mload(0xc0)
 13395 |     |             m7 := mload(0xe0)
 13396 |     |             m8 := mload(0x100)
 13397 |     |             // Selector of `log(string,string,bool,uint256)`.
 13398 |     |             mstore(0x00, 0xd6aefad2)
 13399 |     |             mstore(0x20, 0x80)
 13400 |     |             mstore(0x40, 0xc0)
 13401 |     |             mstore(0x60, p2)
 13402 |     |             mstore(0x80, p3)
 13403 |     |             writeString(0xa0, p0)
 13404 |     |             writeString(0xe0, p1)
 13405 |     |         }
 13406 |     |         _sendLogPayload(0x1c, 0x104);
 13407 |     |         /// @solidity memory-safe-assembly
 13408 |     |         assembly {
 13409 |     |             mstore(0x00, m0)
 13410 |     |             mstore(0x20, m1)
 13411 |     |             mstore(0x40, m2)
 13412 |     |             mstore(0x60, m3)
 13413 |     |             mstore(0x80, m4)
 13414 |     |             mstore(0xa0, m5)
 13415 |     |             mstore(0xc0, m6)
 13416 |     |             mstore(0xe0, m7)
 13417 |     |             mstore(0x100, m8)
 13418 |     |         }
 13419 |     |     }
 13420 |     | 
 13421 |     |     function log(bytes32 p0, bytes32 p1, bool p2, bytes32 p3) internal pure {
 13422 |     |         bytes32 m0;
 13423 |     |         bytes32 m1;
 13424 |     |         bytes32 m2;
 13425 |     |         bytes32 m3;
 13426 |     |         bytes32 m4;
 13427 |     |         bytes32 m5;
 13428 |     |         bytes32 m6;
 13429 |     |         bytes32 m7;
 13430 |     |         bytes32 m8;
 13431 |     |         bytes32 m9;
 13432 |     |         bytes32 m10;
 13433 |     |         /// @solidity memory-safe-assembly
 13434 |     |         assembly {
 13435 |     |             function writeString(pos, w) {
 13436 |     |                 let length := 0
 13437 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
 13438 |     |                 mstore(pos, length)
 13439 |     |                 let shift := sub(256, shl(3, length))
 13440 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
 13441 |     |             }
 13442 |     |             m0 := mload(0x00)
 13443 |     |             m1 := mload(0x20)
 13444 |     |             m2 := mload(0x40)
 13445 |     |             m3 := mload(0x60)
 13446 |     |             m4 := mload(0x80)
 13447 |     |             m5 := mload(0xa0)
 13448 |     |             m6 := mload(0xc0)
 13449 |     |             m7 := mload(0xe0)
 13450 |     |             m8 := mload(0x100)
 13451 |     |             m9 := mload(0x120)
 13452 |     |             m10 := mload(0x140)
 13453 |     |             // Selector of `log(string,string,bool,string)`.
 13454 |     |             mstore(0x00, 0x5e84b0ea)
 13455 |     |             mstore(0x20, 0x80)
 13456 |     |             mstore(0x40, 0xc0)
 13457 |     |             mstore(0x60, p2)
 13458 |     |             mstore(0x80, 0x100)
 13459 |     |             writeString(0xa0, p0)
 13460 |     |             writeString(0xe0, p1)
 13461 |     |             writeString(0x120, p3)
 13462 |     |         }
 13463 |     |         _sendLogPayload(0x1c, 0x144);
 13464 |     |         /// @solidity memory-safe-assembly
 13465 |     |         assembly {
 13466 |     |             mstore(0x00, m0)
 13467 |     |             mstore(0x20, m1)
 13468 |     |             mstore(0x40, m2)
 13469 |     |             mstore(0x60, m3)
 13470 |     |             mstore(0x80, m4)
 13471 |     |             mstore(0xa0, m5)
 13472 |     |             mstore(0xc0, m6)
 13473 |     |             mstore(0xe0, m7)
 13474 |     |             mstore(0x100, m8)
 13475 |     |             mstore(0x120, m9)
 13476 |     |             mstore(0x140, m10)
 13477 |     |         }
 13478 |     |     }
 13479 |     | 
 13480 |     |     function log(bytes32 p0, bytes32 p1, uint256 p2, address p3) internal pure {
 13481 |     |         bytes32 m0;
 13482 |     |         bytes32 m1;
 13483 |     |         bytes32 m2;
 13484 |     |         bytes32 m3;
 13485 |     |         bytes32 m4;
 13486 |     |         bytes32 m5;
 13487 |     |         bytes32 m6;
 13488 |     |         bytes32 m7;
 13489 |     |         bytes32 m8;
 13490 |     |         /// @solidity memory-safe-assembly
 13491 |     |         assembly {
 13492 |     |             function writeString(pos, w) {
 13493 |     |                 let length := 0
 13494 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
 13495 |     |                 mstore(pos, length)
 13496 |     |                 let shift := sub(256, shl(3, length))
 13497 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
 13498 |     |             }
 13499 |     |             m0 := mload(0x00)
 13500 |     |             m1 := mload(0x20)
 13501 |     |             m2 := mload(0x40)
 13502 |     |             m3 := mload(0x60)
 13503 |     |             m4 := mload(0x80)
 13504 |     |             m5 := mload(0xa0)
 13505 |     |             m6 := mload(0xc0)
 13506 |     |             m7 := mload(0xe0)
 13507 |     |             m8 := mload(0x100)
 13508 |     |             // Selector of `log(string,string,uint256,address)`.
 13509 |     |             mstore(0x00, 0x1023f7b2)
 13510 |     |             mstore(0x20, 0x80)
 13511 |     |             mstore(0x40, 0xc0)
 13512 |     |             mstore(0x60, p2)
 13513 |     |             mstore(0x80, p3)
 13514 |     |             writeString(0xa0, p0)
 13515 |     |             writeString(0xe0, p1)
 13516 |     |         }
 13517 |     |         _sendLogPayload(0x1c, 0x104);
 13518 |     |         /// @solidity memory-safe-assembly
 13519 |     |         assembly {
 13520 |     |             mstore(0x00, m0)
 13521 |     |             mstore(0x20, m1)
 13522 |     |             mstore(0x40, m2)
 13523 |     |             mstore(0x60, m3)
 13524 |     |             mstore(0x80, m4)
 13525 |     |             mstore(0xa0, m5)
 13526 |     |             mstore(0xc0, m6)
 13527 |     |             mstore(0xe0, m7)
 13528 |     |             mstore(0x100, m8)
 13529 |     |         }
 13530 |     |     }
 13531 |     | 
 13532 |     |     function log(bytes32 p0, bytes32 p1, uint256 p2, bool p3) internal pure {
 13533 |     |         bytes32 m0;
 13534 |     |         bytes32 m1;
 13535 |     |         bytes32 m2;
 13536 |     |         bytes32 m3;
 13537 |     |         bytes32 m4;
 13538 |     |         bytes32 m5;
 13539 |     |         bytes32 m6;
 13540 |     |         bytes32 m7;
 13541 |     |         bytes32 m8;
 13542 |     |         /// @solidity memory-safe-assembly
 13543 |     |         assembly {
 13544 |     |             function writeString(pos, w) {
 13545 |     |                 let length := 0
 13546 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
 13547 |     |                 mstore(pos, length)
 13548 |     |                 let shift := sub(256, shl(3, length))
 13549 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
 13550 |     |             }
 13551 |     |             m0 := mload(0x00)
 13552 |     |             m1 := mload(0x20)
 13553 |     |             m2 := mload(0x40)
 13554 |     |             m3 := mload(0x60)
 13555 |     |             m4 := mload(0x80)
 13556 |     |             m5 := mload(0xa0)
 13557 |     |             m6 := mload(0xc0)
 13558 |     |             m7 := mload(0xe0)
 13559 |     |             m8 := mload(0x100)
 13560 |     |             // Selector of `log(string,string,uint256,bool)`.
 13561 |     |             mstore(0x00, 0xc3a8a654)
 13562 |     |             mstore(0x20, 0x80)
 13563 |     |             mstore(0x40, 0xc0)
 13564 |     |             mstore(0x60, p2)
 13565 |     |             mstore(0x80, p3)
 13566 |     |             writeString(0xa0, p0)
 13567 |     |             writeString(0xe0, p1)
 13568 |     |         }
 13569 |     |         _sendLogPayload(0x1c, 0x104);
 13570 |     |         /// @solidity memory-safe-assembly
 13571 |     |         assembly {
 13572 |     |             mstore(0x00, m0)
 13573 |     |             mstore(0x20, m1)
 13574 |     |             mstore(0x40, m2)
 13575 |     |             mstore(0x60, m3)
 13576 |     |             mstore(0x80, m4)
 13577 |     |             mstore(0xa0, m5)
 13578 |     |             mstore(0xc0, m6)
 13579 |     |             mstore(0xe0, m7)
 13580 |     |             mstore(0x100, m8)
 13581 |     |         }
 13582 |     |     }
 13583 |     | 
 13584 |     |     function log(bytes32 p0, bytes32 p1, uint256 p2, uint256 p3) internal pure {
 13585 |     |         bytes32 m0;
 13586 |     |         bytes32 m1;
 13587 |     |         bytes32 m2;
 13588 |     |         bytes32 m3;
 13589 |     |         bytes32 m4;
 13590 |     |         bytes32 m5;
 13591 |     |         bytes32 m6;
 13592 |     |         bytes32 m7;
 13593 |     |         bytes32 m8;
 13594 |     |         /// @solidity memory-safe-assembly
 13595 |     |         assembly {
 13596 |     |             function writeString(pos, w) {
 13597 |     |                 let length := 0
 13598 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
 13599 |     |                 mstore(pos, length)
 13600 |     |                 let shift := sub(256, shl(3, length))
 13601 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
 13602 |     |             }
 13603 |     |             m0 := mload(0x00)
 13604 |     |             m1 := mload(0x20)
 13605 |     |             m2 := mload(0x40)
 13606 |     |             m3 := mload(0x60)
 13607 |     |             m4 := mload(0x80)
 13608 |     |             m5 := mload(0xa0)
 13609 |     |             m6 := mload(0xc0)
 13610 |     |             m7 := mload(0xe0)
 13611 |     |             m8 := mload(0x100)
 13612 |     |             // Selector of `log(string,string,uint256,uint256)`.
 13613 |     |             mstore(0x00, 0xf45d7d2c)
 13614 |     |             mstore(0x20, 0x80)
 13615 |     |             mstore(0x40, 0xc0)
 13616 |     |             mstore(0x60, p2)
 13617 |     |             mstore(0x80, p3)
 13618 |     |             writeString(0xa0, p0)
 13619 |     |             writeString(0xe0, p1)
 13620 |     |         }
 13621 |     |         _sendLogPayload(0x1c, 0x104);
 13622 |     |         /// @solidity memory-safe-assembly
 13623 |     |         assembly {
 13624 |     |             mstore(0x00, m0)
 13625 |     |             mstore(0x20, m1)
 13626 |     |             mstore(0x40, m2)
 13627 |     |             mstore(0x60, m3)
 13628 |     |             mstore(0x80, m4)
 13629 |     |             mstore(0xa0, m5)
 13630 |     |             mstore(0xc0, m6)
 13631 |     |             mstore(0xe0, m7)
 13632 |     |             mstore(0x100, m8)
 13633 |     |         }
 13634 |     |     }
 13635 |     | 
 13636 |     |     function log(bytes32 p0, bytes32 p1, uint256 p2, bytes32 p3) internal pure {
 13637 |     |         bytes32 m0;
 13638 |     |         bytes32 m1;
 13639 |     |         bytes32 m2;
 13640 |     |         bytes32 m3;
 13641 |     |         bytes32 m4;
 13642 |     |         bytes32 m5;
 13643 |     |         bytes32 m6;
 13644 |     |         bytes32 m7;
 13645 |     |         bytes32 m8;
 13646 |     |         bytes32 m9;
 13647 |     |         bytes32 m10;
 13648 |     |         /// @solidity memory-safe-assembly
 13649 |     |         assembly {
 13650 |     |             function writeString(pos, w) {
 13651 |     |                 let length := 0
 13652 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
 13653 |     |                 mstore(pos, length)
 13654 |     |                 let shift := sub(256, shl(3, length))
 13655 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
 13656 |     |             }
 13657 |     |             m0 := mload(0x00)
 13658 |     |             m1 := mload(0x20)
 13659 |     |             m2 := mload(0x40)
 13660 |     |             m3 := mload(0x60)
 13661 |     |             m4 := mload(0x80)
 13662 |     |             m5 := mload(0xa0)
 13663 |     |             m6 := mload(0xc0)
 13664 |     |             m7 := mload(0xe0)
 13665 |     |             m8 := mload(0x100)
 13666 |     |             m9 := mload(0x120)
 13667 |     |             m10 := mload(0x140)
 13668 |     |             // Selector of `log(string,string,uint256,string)`.
 13669 |     |             mstore(0x00, 0x5d1a971a)
 13670 |     |             mstore(0x20, 0x80)
 13671 |     |             mstore(0x40, 0xc0)
 13672 |     |             mstore(0x60, p2)
 13673 |     |             mstore(0x80, 0x100)
 13674 |     |             writeString(0xa0, p0)
 13675 |     |             writeString(0xe0, p1)
 13676 |     |             writeString(0x120, p3)
 13677 |     |         }
 13678 |     |         _sendLogPayload(0x1c, 0x144);
 13679 |     |         /// @solidity memory-safe-assembly
 13680 |     |         assembly {
 13681 |     |             mstore(0x00, m0)
 13682 |     |             mstore(0x20, m1)
 13683 |     |             mstore(0x40, m2)
 13684 |     |             mstore(0x60, m3)
 13685 |     |             mstore(0x80, m4)
 13686 |     |             mstore(0xa0, m5)
 13687 |     |             mstore(0xc0, m6)
 13688 |     |             mstore(0xe0, m7)
 13689 |     |             mstore(0x100, m8)
 13690 |     |             mstore(0x120, m9)
 13691 |     |             mstore(0x140, m10)
 13692 |     |         }
 13693 |     |     }
 13694 |     | 
 13695 |     |     function log(bytes32 p0, bytes32 p1, bytes32 p2, address p3) internal pure {
 13696 |     |         bytes32 m0;
 13697 |     |         bytes32 m1;
 13698 |     |         bytes32 m2;
 13699 |     |         bytes32 m3;
 13700 |     |         bytes32 m4;
 13701 |     |         bytes32 m5;
 13702 |     |         bytes32 m6;
 13703 |     |         bytes32 m7;
 13704 |     |         bytes32 m8;
 13705 |     |         bytes32 m9;
 13706 |     |         bytes32 m10;
 13707 |     |         /// @solidity memory-safe-assembly
 13708 |     |         assembly {
 13709 |     |             function writeString(pos, w) {
 13710 |     |                 let length := 0
 13711 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
 13712 |     |                 mstore(pos, length)
 13713 |     |                 let shift := sub(256, shl(3, length))
 13714 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
 13715 |     |             }
 13716 |     |             m0 := mload(0x00)
 13717 |     |             m1 := mload(0x20)
 13718 |     |             m2 := mload(0x40)
 13719 |     |             m3 := mload(0x60)
 13720 |     |             m4 := mload(0x80)
 13721 |     |             m5 := mload(0xa0)
 13722 |     |             m6 := mload(0xc0)
 13723 |     |             m7 := mload(0xe0)
 13724 |     |             m8 := mload(0x100)
 13725 |     |             m9 := mload(0x120)
 13726 |     |             m10 := mload(0x140)
 13727 |     |             // Selector of `log(string,string,string,address)`.
 13728 |     |             mstore(0x00, 0x6d572f44)
 13729 |     |             mstore(0x20, 0x80)
 13730 |     |             mstore(0x40, 0xc0)
 13731 |     |             mstore(0x60, 0x100)
 13732 |     |             mstore(0x80, p3)
 13733 |     |             writeString(0xa0, p0)
 13734 |     |             writeString(0xe0, p1)
 13735 |     |             writeString(0x120, p2)
 13736 |     |         }
 13737 |     |         _sendLogPayload(0x1c, 0x144);
 13738 |     |         /// @solidity memory-safe-assembly
 13739 |     |         assembly {
 13740 |     |             mstore(0x00, m0)
 13741 |     |             mstore(0x20, m1)
 13742 |     |             mstore(0x40, m2)
 13743 |     |             mstore(0x60, m3)
 13744 |     |             mstore(0x80, m4)
 13745 |     |             mstore(0xa0, m5)
 13746 |     |             mstore(0xc0, m6)
 13747 |     |             mstore(0xe0, m7)
 13748 |     |             mstore(0x100, m8)
 13749 |     |             mstore(0x120, m9)
 13750 |     |             mstore(0x140, m10)
 13751 |     |         }
 13752 |     |     }
 13753 |     | 
 13754 |     |     function log(bytes32 p0, bytes32 p1, bytes32 p2, bool p3) internal pure {
 13755 |     |         bytes32 m0;
 13756 |     |         bytes32 m1;
 13757 |     |         bytes32 m2;
 13758 |     |         bytes32 m3;
 13759 |     |         bytes32 m4;
 13760 |     |         bytes32 m5;
 13761 |     |         bytes32 m6;
 13762 |     |         bytes32 m7;
 13763 |     |         bytes32 m8;
 13764 |     |         bytes32 m9;
 13765 |     |         bytes32 m10;
 13766 |     |         /// @solidity memory-safe-assembly
 13767 |     |         assembly {
 13768 |     |             function writeString(pos, w) {
 13769 |     |                 let length := 0
 13770 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
 13771 |     |                 mstore(pos, length)
 13772 |     |                 let shift := sub(256, shl(3, length))
 13773 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
 13774 |     |             }
 13775 |     |             m0 := mload(0x00)
 13776 |     |             m1 := mload(0x20)
 13777 |     |             m2 := mload(0x40)
 13778 |     |             m3 := mload(0x60)
 13779 |     |             m4 := mload(0x80)
 13780 |     |             m5 := mload(0xa0)
 13781 |     |             m6 := mload(0xc0)
 13782 |     |             m7 := mload(0xe0)
 13783 |     |             m8 := mload(0x100)
 13784 |     |             m9 := mload(0x120)
 13785 |     |             m10 := mload(0x140)
 13786 |     |             // Selector of `log(string,string,string,bool)`.
 13787 |     |             mstore(0x00, 0x2c1754ed)
 13788 |     |             mstore(0x20, 0x80)
 13789 |     |             mstore(0x40, 0xc0)
 13790 |     |             mstore(0x60, 0x100)
 13791 |     |             mstore(0x80, p3)
 13792 |     |             writeString(0xa0, p0)
 13793 |     |             writeString(0xe0, p1)
 13794 |     |             writeString(0x120, p2)
 13795 |     |         }
 13796 |     |         _sendLogPayload(0x1c, 0x144);
 13797 |     |         /// @solidity memory-safe-assembly
 13798 |     |         assembly {
 13799 |     |             mstore(0x00, m0)
 13800 |     |             mstore(0x20, m1)
 13801 |     |             mstore(0x40, m2)
 13802 |     |             mstore(0x60, m3)
 13803 |     |             mstore(0x80, m4)
 13804 |     |             mstore(0xa0, m5)
 13805 |     |             mstore(0xc0, m6)
 13806 |     |             mstore(0xe0, m7)
 13807 |     |             mstore(0x100, m8)
 13808 |     |             mstore(0x120, m9)
 13809 |     |             mstore(0x140, m10)
 13810 |     |         }
 13811 |     |     }
 13812 |     | 
 13813 |     |     function log(bytes32 p0, bytes32 p1, bytes32 p2, uint256 p3) internal pure {
 13814 |     |         bytes32 m0;
 13815 |     |         bytes32 m1;
 13816 |     |         bytes32 m2;
 13817 |     |         bytes32 m3;
 13818 |     |         bytes32 m4;
 13819 |     |         bytes32 m5;
 13820 |     |         bytes32 m6;
 13821 |     |         bytes32 m7;
 13822 |     |         bytes32 m8;
 13823 |     |         bytes32 m9;
 13824 |     |         bytes32 m10;
 13825 |     |         /// @solidity memory-safe-assembly
 13826 |     |         assembly {
 13827 |     |             function writeString(pos, w) {
 13828 |     |                 let length := 0
 13829 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
 13830 |     |                 mstore(pos, length)
 13831 |     |                 let shift := sub(256, shl(3, length))
 13832 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
 13833 |     |             }
 13834 |     |             m0 := mload(0x00)
 13835 |     |             m1 := mload(0x20)
 13836 |     |             m2 := mload(0x40)
 13837 |     |             m3 := mload(0x60)
 13838 |     |             m4 := mload(0x80)
 13839 |     |             m5 := mload(0xa0)
 13840 |     |             m6 := mload(0xc0)
 13841 |     |             m7 := mload(0xe0)
 13842 |     |             m8 := mload(0x100)
 13843 |     |             m9 := mload(0x120)
 13844 |     |             m10 := mload(0x140)
 13845 |     |             // Selector of `log(string,string,string,uint256)`.
 13846 |     |             mstore(0x00, 0x8eafb02b)
 13847 |     |             mstore(0x20, 0x80)
 13848 |     |             mstore(0x40, 0xc0)
 13849 |     |             mstore(0x60, 0x100)
 13850 |     |             mstore(0x80, p3)
 13851 |     |             writeString(0xa0, p0)
 13852 |     |             writeString(0xe0, p1)
 13853 |     |             writeString(0x120, p2)
 13854 |     |         }
 13855 |     |         _sendLogPayload(0x1c, 0x144);
 13856 |     |         /// @solidity memory-safe-assembly
 13857 |     |         assembly {
 13858 |     |             mstore(0x00, m0)
 13859 |     |             mstore(0x20, m1)
 13860 |     |             mstore(0x40, m2)
 13861 |     |             mstore(0x60, m3)
 13862 |     |             mstore(0x80, m4)
 13863 |     |             mstore(0xa0, m5)
 13864 |     |             mstore(0xc0, m6)
 13865 |     |             mstore(0xe0, m7)
 13866 |     |             mstore(0x100, m8)
 13867 |     |             mstore(0x120, m9)
 13868 |     |             mstore(0x140, m10)
 13869 |     |         }
 13870 |     |     }
 13871 |     | 
 13872 |     |     function log(bytes32 p0, bytes32 p1, bytes32 p2, bytes32 p3) internal pure {
 13873 |     |         bytes32 m0;
 13874 |     |         bytes32 m1;
 13875 |     |         bytes32 m2;
 13876 |     |         bytes32 m3;
 13877 |     |         bytes32 m4;
 13878 |     |         bytes32 m5;
 13879 |     |         bytes32 m6;
 13880 |     |         bytes32 m7;
 13881 |     |         bytes32 m8;
 13882 |     |         bytes32 m9;
 13883 |     |         bytes32 m10;
 13884 |     |         bytes32 m11;
 13885 |     |         bytes32 m12;
 13886 |     |         /// @solidity memory-safe-assembly
 13887 |     |         assembly {
 13888 |     |             function writeString(pos, w) {
 13889 |     |                 let length := 0
 13890 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
 13891 |     |                 mstore(pos, length)
 13892 |     |                 let shift := sub(256, shl(3, length))
 13893 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
 13894 |     |             }
 13895 |     |             m0 := mload(0x00)
 13896 |     |             m1 := mload(0x20)
 13897 |     |             m2 := mload(0x40)
 13898 |     |             m3 := mload(0x60)
 13899 |     |             m4 := mload(0x80)
 13900 |     |             m5 := mload(0xa0)
 13901 |     |             m6 := mload(0xc0)
 13902 |     |             m7 := mload(0xe0)
 13903 |     |             m8 := mload(0x100)
 13904 |     |             m9 := mload(0x120)
 13905 |     |             m10 := mload(0x140)
 13906 |     |             m11 := mload(0x160)
 13907 |     |             m12 := mload(0x180)
 13908 |     |             // Selector of `log(string,string,string,string)`.
 13909 |     |             mstore(0x00, 0xde68f20a)
 13910 |     |             mstore(0x20, 0x80)
 13911 |     |             mstore(0x40, 0xc0)
 13912 |     |             mstore(0x60, 0x100)
 13913 |     |             mstore(0x80, 0x140)
 13914 |     |             writeString(0xa0, p0)
 13915 |     |             writeString(0xe0, p1)
 13916 |     |             writeString(0x120, p2)
 13917 |     |             writeString(0x160, p3)
 13918 |     |         }
 13919 |     |         _sendLogPayload(0x1c, 0x184);
 13920 |     |         /// @solidity memory-safe-assembly
 13921 |     |         assembly {
 13922 |     |             mstore(0x00, m0)
 13923 |     |             mstore(0x20, m1)
 13924 |     |             mstore(0x40, m2)
 13925 |     |             mstore(0x60, m3)
 13926 |     |             mstore(0x80, m4)
 13927 |     |             mstore(0xa0, m5)
 13928 |     |             mstore(0xc0, m6)
 13929 |     |             mstore(0xe0, m7)
 13930 |     |             mstore(0x100, m8)
 13931 |     |             mstore(0x120, m9)
 13932 |     |             mstore(0x140, m10)
 13933 |     |             mstore(0x160, m11)
 13934 |     |             mstore(0x180, m12)
 13935 |     |         }
 13936 |     |     }
 13937 |     | }
 13938 |     | 

/home/phantom/Documents/azemora/azemora-contracts/lib/openzeppelin-contracts/contracts/access/IAccessControl.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | // OpenZeppelin Contracts (last updated v5.3.0) (access/IAccessControl.sol)
   3 |     | 
   4 |     | pragma solidity >=0.8.4;
   5 |     | 
   6 |     | /**
   7 |     |  * @dev External interface of AccessControl declared to support ERC-165 detection.
   8 |     |  */
   9 |     | interface IAccessControl {
  10 |     |     /**
  11 |     |      * @dev The `account` is missing a role.
  12 |     |      */
  13 |     |     error AccessControlUnauthorizedAccount(address account, bytes32 neededRole);
  14 |     | 
  15 |     |     /**
  16 |     |      * @dev The caller of a function is not the expected one.
  17 |     |      *
  18 |     |      * NOTE: Don't confuse with {AccessControlUnauthorizedAccount}.
  19 |     |      */
  20 |     |     error AccessControlBadConfirmation();
  21 |     | 
  22 |     |     /**
  23 |     |      * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`
  24 |     |      *
  25 |     |      * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite
  26 |     |      * {RoleAdminChanged} not being emitted to signal this.
  27 |     |      */
  28 |     |     event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);
  29 |     | 
  30 |     |     /**
  31 |     |      * @dev Emitted when `account` is granted `role`.
  32 |     |      *
  33 |     |      * `sender` is the account that originated the contract call. This account bears the admin role (for the granted role).
  34 |     |      * Expected in cases where the role was granted using the internal {AccessControl-_grantRole}.
  35 |     |      */
  36 |     |     event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);
  37 |     | 
  38 |     |     /**
  39 |     |      * @dev Emitted when `account` is revoked `role`.
  40 |     |      *
  41 |     |      * `sender` is the account that originated the contract call:
  42 |     |      *   - if using `revokeRole`, it is the admin role bearer
  43 |     |      *   - if using `renounceRole`, it is the role bearer (i.e. `account`)
  44 |     |      */
  45 |     |     event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);
  46 |     | 
  47 |     |     /**
  48 |     |      * @dev Returns `true` if `account` has been granted `role`.
  49 |     |      */
  50 |     |     function hasRole(bytes32 role, address account) external view returns (bool);
  51 |     | 
  52 |     |     /**
  53 |     |      * @dev Returns the admin role that controls `role`. See {grantRole} and
  54 |     |      * {revokeRole}.
  55 |     |      *
  56 |     |      * To change a role's admin, use {AccessControl-_setRoleAdmin}.
  57 |     |      */
  58 |     |     function getRoleAdmin(bytes32 role) external view returns (bytes32);
  59 |     | 
  60 |     |     /**
  61 |     |      * @dev Grants `role` to `account`.
  62 |     |      *
  63 |     |      * If `account` had not been already granted `role`, emits a {RoleGranted}
  64 |     |      * event.
  65 |     |      *
  66 |     |      * Requirements:
  67 |     |      *
  68 |     |      * - the caller must have ``role``'s admin role.
  69 |     |      */
  70 | *   |     function grantRole(bytes32 role, address account) external;
  71 |     | 
  72 |     |     /**
  73 |     |      * @dev Revokes `role` from `account`.
  74 |     |      *
  75 |     |      * If `account` had been granted `role`, emits a {RoleRevoked} event.
  76 |     |      *
  77 |     |      * Requirements:
  78 |     |      *
  79 |     |      * - the caller must have ``role``'s admin role.
  80 |     |      */
  81 |     |     function revokeRole(bytes32 role, address account) external;
  82 |     | 
  83 |     |     /**
  84 |     |      * @dev Revokes `role` from the calling account.
  85 |     |      *
  86 |     |      * Roles are often managed via {grantRole} and {revokeRole}: this function's
  87 |     |      * purpose is to provide a mechanism for accounts to lose their privileges
  88 | *   |      * if they are compromised (such as when a trusted device is misplaced).
  89 |     |      *
  90 |     |      * If the calling account had been granted `role`, emits a {RoleRevoked}
  91 |     |      * event.
  92 |     |      *
  93 |     |      * Requirements:
  94 |     |      *
  95 |     |      * - the caller must be `callerConfirmation`.
  96 |     |      */
  97 | *   |     function renounceRole(bytes32 role, address callerConfirmation) external;
  98 |     | }
  99 | *   | 

/home/phantom/Documents/azemora/azemora-contracts/lib/openzeppelin-contracts/contracts/governance/IGovernor.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | // OpenZeppelin Contracts (last updated v5.3.0) (governance/IGovernor.sol)
   3 |     | 
   4 |     | pragma solidity >=0.8.4;
   5 |     | 
   6 |     | import {IERC165} from "../interfaces/IERC165.sol";
   7 |     | import {IERC6372} from "../interfaces/IERC6372.sol";
   8 |     | 
   9 |     | /**
  10 |     |  * @dev Interface of the {Governor} core.
  11 |     |  *
  12 |     |  * NOTE: Event parameters lack the `indexed` keyword for compatibility with GovernorBravo events.
  13 |     |  * Making event parameters `indexed` affects how events are decoded, potentially breaking existing indexers.
  14 |     |  */
  15 |     | interface IGovernor is IERC165, IERC6372 {
  16 |     |     enum ProposalState {
  17 |     |         Pending,
  18 |     |         Active,
  19 |     |         Canceled,
  20 |     |         Defeated,
  21 |     |         Succeeded,
  22 |     |         Queued,
  23 |     |         Expired,
  24 |     |         Executed
  25 |     |     }
  26 |     | 
  27 |     |     /**
  28 |     |      * @dev Empty proposal or a mismatch between the parameters length for a proposal call.
  29 |     |      */
  30 |     |     error GovernorInvalidProposalLength(uint256 targets, uint256 calldatas, uint256 values);
  31 |     | 
  32 |     |     /**
  33 |     |      * @dev The vote was already cast.
  34 |     |      */
  35 |     |     error GovernorAlreadyCastVote(address voter);
  36 |     | 
  37 |     |     /**
  38 |     |      * @dev Token deposits are disabled in this contract.
  39 |     |      */
  40 |     |     error GovernorDisabledDeposit();
  41 |     | 
  42 |     |     /**
  43 |     |      * @dev The `account` is not the governance executor.
  44 |     |      */
  45 |     |     error GovernorOnlyExecutor(address account);
  46 |     | 
  47 |     |     /**
  48 |     |      * @dev The `proposalId` doesn't exist.
  49 |     |      */
  50 |     |     error GovernorNonexistentProposal(uint256 proposalId);
  51 |     | 
  52 |     |     /**
  53 |     |      * @dev The current state of a proposal is not the required for performing an operation.
  54 |     |      * The `expectedStates` is a bitmap with the bits enabled for each ProposalState enum position
  55 |     |      * counting from right to left.
  56 |     |      *
  57 |     |      * NOTE: If `expectedState` is `bytes32(0)`, the proposal is expected to not be in any state (i.e. not exist).
  58 |     |      * This is the case when a proposal that is expected to be unset is already initiated (the proposal is duplicated).
  59 |     |      *
  60 |     |      * See {Governor-_encodeStateBitmap}.
  61 |     |      */
  62 |     |     error GovernorUnexpectedProposalState(uint256 proposalId, ProposalState current, bytes32 expectedStates);
  63 |     | 
  64 |     |     /**
  65 |     |      * @dev The voting period set is not a valid period.
  66 |     |      */
  67 |     |     error GovernorInvalidVotingPeriod(uint256 votingPeriod);
  68 |     | 
  69 |     |     /**
  70 |     |      * @dev The `proposer` does not have the required votes to create a proposal.
  71 |     |      */
  72 |     |     error GovernorInsufficientProposerVotes(address proposer, uint256 votes, uint256 threshold);
  73 |     | 
  74 |     |     /**
  75 |     |      * @dev The `proposer` is not allowed to create a proposal.
  76 |     |      */
  77 |     |     error GovernorRestrictedProposer(address proposer);
  78 |     | 
  79 |     |     /**
  80 |     |      * @dev The vote type used is not valid for the corresponding counting module.
  81 |     |      */
  82 |     |     error GovernorInvalidVoteType();
  83 |     | 
  84 |     |     /**
  85 |     |      * @dev The provided params buffer is not supported by the counting module.
  86 |     |      */
  87 |     |     error GovernorInvalidVoteParams();
  88 |     | 
  89 |     |     /**
  90 |     |      * @dev Queue operation is not implemented for this governor. Execute should be called directly.
  91 |     |      */
  92 |     |     error GovernorQueueNotImplemented();
  93 |     | 
  94 |     |     /**
  95 |     |      * @dev The proposal hasn't been queued yet.
  96 |     |      */
  97 |     |     error GovernorNotQueuedProposal(uint256 proposalId);
  98 |     | 
  99 |     |     /**
 100 |     |      * @dev The proposal has already been queued.
 101 |     |      */
 102 |     |     error GovernorAlreadyQueuedProposal(uint256 proposalId);
 103 |     | 
 104 |     |     /**
 105 |     |      * @dev The provided signature is not valid for the expected `voter`.
 106 |     |      * If the `voter` is a contract, the signature is not valid using {IERC1271-isValidSignature}.
 107 |     |      */
 108 |     |     error GovernorInvalidSignature(address voter);
 109 |     | 
 110 |     |     /**
 111 |     |      * @dev The given `account` is unable to cancel the proposal with given `proposalId`.
 112 |     |      */
 113 |     |     error GovernorUnableToCancel(uint256 proposalId, address account);
 114 |     | 
 115 |     |     /**
 116 |     |      * @dev Emitted when a proposal is created.
 117 |     |      */
 118 |     |     event ProposalCreated(
 119 |     |         uint256 proposalId,
 120 |     |         address proposer,
 121 |     |         address[] targets,
 122 |     |         uint256[] values,
 123 |     |         string[] signatures,
 124 |     |         bytes[] calldatas,
 125 |     |         uint256 voteStart,
 126 |     |         uint256 voteEnd,
 127 |     |         string description
 128 |     |     );
 129 |     | 
 130 |     |     /**
 131 |     |      * @dev Emitted when a proposal is queued.
 132 |     |      */
 133 |     |     event ProposalQueued(uint256 proposalId, uint256 etaSeconds);
 134 |     | 
 135 |     |     /**
 136 |     |      * @dev Emitted when a proposal is executed.
 137 |     |      */
 138 |     |     event ProposalExecuted(uint256 proposalId);
 139 |     | 
 140 |     |     /**
 141 |     |      * @dev Emitted when a proposal is canceled.
 142 |     |      */
 143 |     |     event ProposalCanceled(uint256 proposalId);
 144 |     | 
 145 |     |     /**
 146 |     |      * @dev Emitted when a vote is cast without params.
 147 |     |      *
 148 |     |      * Note: `support` values should be seen as buckets. Their interpretation depends on the voting module used.
 149 |     |      */
 150 |     |     event VoteCast(address indexed voter, uint256 proposalId, uint8 support, uint256 weight, string reason);
 151 |     | 
 152 |     |     /**
 153 |     |      * @dev Emitted when a vote is cast with params.
 154 |     |      *
 155 |     |      * Note: `support` values should be seen as buckets. Their interpretation depends on the voting module used.
 156 |     |      * `params` are additional encoded parameters. Their interpretation  also depends on the voting module used.
 157 |     |      */
 158 |     |     event VoteCastWithParams(
 159 |     |         address indexed voter,
 160 |     |         uint256 proposalId,
 161 |     |         uint8 support,
 162 |     |         uint256 weight,
 163 |     |         string reason,
 164 |     |         bytes params
 165 |     |     );
 166 |     | 
 167 |     |     /**
 168 |     |      * @notice module:core
 169 |     |      * @dev Name of the governor instance (used in building the EIP-712 domain separator).
 170 |     |      */
 171 |     |     function name() external view returns (string memory);
 172 |     | 
 173 |     |     /**
 174 |     |      * @notice module:core
 175 |     |      * @dev Version of the governor instance (used in building the EIP-712 domain separator). Default: "1"
 176 |     |      */
 177 |     |     function version() external view returns (string memory);
 178 |     | 
 179 |     |     /**
 180 |     |      * @notice module:voting
 181 |     |      * @dev A description of the possible `support` values for {castVote} and the way these votes are counted, meant to
 182 |     |      * be consumed by UIs to show correct vote options and interpret the results. The string is a URL-encoded sequence of
 183 |     |      * key-value pairs that each describe one aspect, for example `support=bravo&quorum=for,abstain`.
 184 |     |      *
 185 |     |      * There are 2 standard keys: `support` and `quorum`.
 186 |     |      *
 187 |     |      * - `support=bravo` refers to the vote options 0 = Against, 1 = For, 2 = Abstain, as in `GovernorBravo`.
 188 |     |      * - `quorum=bravo` means that only For votes are counted towards quorum.
 189 |     |      * - `quorum=for,abstain` means that both For and Abstain votes are counted towards quorum.
 190 |     |      *
 191 |     |      * If a counting module makes use of encoded `params`, it should  include this under a `params` key with a unique
 192 |     |      * name that describes the behavior. For example:
 193 |     |      *
 194 |     |      * - `params=fractional` might refer to a scheme where votes are divided fractionally between for/against/abstain.
 195 |     |      * - `params=erc721` might refer to a scheme where specific NFTs are delegated to vote.
 196 |     |      *
 197 |     |      * NOTE: The string can be decoded by the standard
 198 |     |      * https://developer.mozilla.org/en-US/docs/Web/API/URLSearchParams[`URLSearchParams`]
 199 |     |      * JavaScript class.
 200 |     |      */
 201 |     |     // solhint-disable-next-line func-name-mixedcase
 202 |     |     function COUNTING_MODE() external view returns (string memory);
 203 |     | 
 204 |     |     /**
 205 |     |      * @notice module:core
 206 |     |      * @dev Hashing function used to (re)build the proposal id from the proposal details.
 207 |     |      *
 208 |     |      * NOTE: For all off-chain and external calls, use {getProposalId}.
 209 |     |      */
 210 |     |     function hashProposal(
 211 |     |         address[] memory targets,
 212 |     |         uint256[] memory values,
 213 |     |         bytes[] memory calldatas,
 214 |     |         bytes32 descriptionHash
 215 |     |     ) external pure returns (uint256);
 216 |     | 
 217 |     |     /**
 218 |     |      * @notice module:core
 219 |     |      * @dev Function used to get the proposal id from the proposal details.
 220 |     |      */
 221 |     |     function getProposalId(
 222 |     |         address[] memory targets,
 223 |     |         uint256[] memory values,
 224 |     |         bytes[] memory calldatas,
 225 |     |         bytes32 descriptionHash
 226 |     |     ) external view returns (uint256);
 227 |     | 
 228 |     |     /**
 229 |     |      * @notice module:core
 230 |     |      * @dev Current state of a proposal, following Compound's convention
 231 |     |      */
 232 |     |     function state(uint256 proposalId) external view returns (ProposalState);
 233 |     | 
 234 |     |     /**
 235 |     |      * @notice module:core
 236 |     |      * @dev The number of votes required in order for a voter to become a proposer.
 237 |     |      */
 238 |     |     function proposalThreshold() external view returns (uint256);
 239 |     | 
 240 |     |     /**
 241 |     |      * @notice module:core
 242 |     |      * @dev Timepoint used to retrieve user's votes and quorum. If using block number (as per Compound's Comp), the
 243 |     |      * snapshot is performed at the end of this block. Hence, voting for this proposal starts at the beginning of the
 244 |     |      * following block.
 245 |     |      */
 246 |     |     function proposalSnapshot(uint256 proposalId) external view returns (uint256);
 247 |     | 
 248 |     |     /**
 249 |     |      * @notice module:core
 250 |     |      * @dev Timepoint at which votes close. If using block number, votes close at the end of this block, so it is
 251 |     |      * possible to cast a vote during this block.
 252 |     |      */
 253 |     |     function proposalDeadline(uint256 proposalId) external view returns (uint256);
 254 |     | 
 255 |     |     /**
 256 |     |      * @notice module:core
 257 |     |      * @dev The account that created a proposal.
 258 |     |      */
 259 |     |     function proposalProposer(uint256 proposalId) external view returns (address);
 260 |     | 
 261 |     |     /**
 262 |     |      * @notice module:core
 263 |     |      * @dev The time when a queued proposal becomes executable ("ETA"). Unlike {proposalSnapshot} and
 264 |     |      * {proposalDeadline}, this doesn't use the governor clock, and instead relies on the executor's clock which may be
 265 |     |      * different. In most cases this will be a timestamp.
 266 |     |      */
 267 |     |     function proposalEta(uint256 proposalId) external view returns (uint256);
 268 |     | 
 269 |     |     /**
 270 |     |      * @notice module:core
 271 |     |      * @dev Whether a proposal needs to be queued before execution.
 272 |     |      */
 273 |     |     function proposalNeedsQueuing(uint256 proposalId) external view returns (bool);
 274 |     | 
 275 |     |     /**
 276 |     |      * @notice module:user-config
 277 |     |      * @dev Delay, between the proposal is created and the vote starts. The unit this duration is expressed in depends
 278 |     |      * on the clock (see ERC-6372) this contract uses.
 279 |     |      *
 280 |     |      * This can be increased to leave time for users to buy voting power, or delegate it, before the voting of a
 281 |     |      * proposal starts.
 282 |     |      *
 283 |     |      * NOTE: While this interface returns a uint256, timepoints are stored as uint48 following the ERC-6372 clock type.
 284 |     |      * Consequently this value must fit in a uint48 (when added to the current clock). See {IERC6372-clock}.
 285 |     |      */
 286 |     |     function votingDelay() external view returns (uint256);
 287 |     | 
 288 |     |     /**
 289 |     |      * @notice module:user-config
 290 |     |      * @dev Delay between the vote start and vote end. The unit this duration is expressed in depends on the clock
 291 |     |      * (see ERC-6372) this contract uses.
 292 |     |      *
 293 |     |      * NOTE: The {votingDelay} can delay the start of the vote. This must be considered when setting the voting
 294 |     |      * duration compared to the voting delay.
 295 |     |      *
 296 |     |      * NOTE: This value is stored when the proposal is submitted so that possible changes to the value do not affect
 297 |     |      * proposals that have already been submitted. The type used to save it is a uint32. Consequently, while this
 298 |     |      * interface returns a uint256, the value it returns should fit in a uint32.
 299 |     |      */
 300 |     |     function votingPeriod() external view returns (uint256);
 301 |     | 
 302 |     |     /**
 303 |     |      * @notice module:user-config
 304 |     |      * @dev Minimum number of cast voted required for a proposal to be successful.
 305 |     |      *
 306 |     |      * NOTE: The `timepoint` parameter corresponds to the snapshot used for counting vote. This allows to scale the
 307 |     |      * quorum depending on values such as the totalSupply of a token at this timepoint (see {ERC20Votes}).
 308 |     |      */
 309 |     |     function quorum(uint256 timepoint) external view returns (uint256);
 310 |     | 
 311 |     |     /**
 312 |     |      * @notice module:reputation
 313 |     |      * @dev Voting power of an `account` at a specific `timepoint`.
 314 |     |      *
 315 |     |      * Note: this can be implemented in a number of ways, for example by reading the delegated balance from one (or
 316 |     |      * multiple), {ERC20Votes} tokens.
 317 |     |      */
 318 |     |     function getVotes(address account, uint256 timepoint) external view returns (uint256);
 319 |     | 
 320 |     |     /**
 321 |     |      * @notice module:reputation
 322 |     |      * @dev Voting power of an `account` at a specific `timepoint` given additional encoded parameters.
 323 |     |      */
 324 |     |     function getVotesWithParams(
 325 |     |         address account,
 326 |     |         uint256 timepoint,
 327 |     |         bytes memory params
 328 |     |     ) external view returns (uint256);
 329 |     | 
 330 |     |     /**
 331 |     |      * @notice module:voting
 332 |     |      * @dev Returns whether `account` has cast a vote on `proposalId`.
 333 |     |      */
 334 |     |     function hasVoted(uint256 proposalId, address account) external view returns (bool);
 335 |     | 
 336 |     |     /**
 337 |     |      * @dev Create a new proposal. Vote start after a delay specified by {IGovernor-votingDelay} and lasts for a
 338 |     |      * duration specified by {IGovernor-votingPeriod}.
 339 |     |      *
 340 |     |      * Emits a {ProposalCreated} event.
 341 |     |      *
 342 |     |      * NOTE: The state of the Governor and `targets` may change between the proposal creation and its execution.
 343 |     |      * This may be the result of third party actions on the targeted contracts, or other governor proposals.
 344 |     |      * For example, the balance of this contract could be updated or its access control permissions may be modified,
 345 |     |      * possibly compromising the proposal's ability to execute successfully (e.g. the governor doesn't have enough
 346 |     |      * value to cover a proposal with multiple transfers).
 347 |     |      */
 348 |     |     function propose(
 349 |     |         address[] memory targets,
 350 |     |         uint256[] memory values,
 351 |     |         bytes[] memory calldatas,
 352 |     |         string memory description
 353 |     |     ) external returns (uint256 proposalId);
 354 |     | 
 355 |     |     /**
 356 |     |      * @dev Queue a proposal. Some governors require this step to be performed before execution can happen. If queuing
 357 |     |      * is not necessary, this function may revert.
 358 |     |      * Queuing a proposal requires the quorum to be reached, the vote to be successful, and the deadline to be reached.
 359 |     |      *
 360 |     |      * Emits a {ProposalQueued} event.
 361 |     |      */
 362 |     |     function queue(
 363 |     |         address[] memory targets,
 364 |     |         uint256[] memory values,
 365 |     |         bytes[] memory calldatas,
 366 |     |         bytes32 descriptionHash
 367 |     |     ) external returns (uint256 proposalId);
 368 |     | 
 369 |     |     /**
 370 |     |      * @dev Execute a successful proposal. This requires the quorum to be reached, the vote to be successful, and the
 371 |     |      * deadline to be reached. Depending on the governor it might also be required that the proposal was queued and
 372 |     |      * that some delay passed.
 373 |     |      *
 374 |     |      * Emits a {ProposalExecuted} event.
 375 |     |      *
 376 |     |      * NOTE: Some modules can modify the requirements for execution, for example by adding an additional timelock.
 377 |     |      */
 378 |     |     function execute(
 379 |     |         address[] memory targets,
 380 |     |         uint256[] memory values,
 381 |     |         bytes[] memory calldatas,
 382 |     |         bytes32 descriptionHash
 383 |     |     ) external payable returns (uint256 proposalId);
 384 |     | 
 385 |     |     /**
 386 |     |      * @dev Cancel a proposal. A proposal is cancellable by the proposer, but only while it is Pending state, i.e.
 387 |     |      * before the vote starts.
 388 |     |      *
 389 |     |      * Emits a {ProposalCanceled} event.
 390 |     |      */
 391 |     |     function cancel(
 392 |     |         address[] memory targets,
 393 |     |         uint256[] memory values,
 394 |     |         bytes[] memory calldatas,
 395 |     |         bytes32 descriptionHash
 396 |     |     ) external returns (uint256 proposalId);
 397 |     | 
 398 |     |     /**
 399 |     |      * @dev Cast a vote
 400 |     |      *
 401 |     |      * Emits a {VoteCast} event.
 402 |     |      */
 403 |     |     function castVote(uint256 proposalId, uint8 support) external returns (uint256 balance);
 404 |     | 
 405 |     |     /**
 406 |     |      * @dev Cast a vote with a reason
 407 |     |      *
 408 |     |      * Emits a {VoteCast} event.
 409 |     |      */
 410 |     |     function castVoteWithReason(
 411 |     |         uint256 proposalId,
 412 |     |         uint8 support,
 413 |     |         string calldata reason
 414 |     |     ) external returns (uint256 balance);
 415 |     | 
 416 |     |     /**
 417 |     |      * @dev Cast a vote with a reason and additional encoded parameters
 418 |     |      *
 419 |     |      * Emits a {VoteCast} or {VoteCastWithParams} event depending on the length of params.
 420 |     |      */
 421 |     |     function castVoteWithReasonAndParams(
 422 |     |         uint256 proposalId,
 423 |     |         uint8 support,
 424 |     |         string calldata reason,
 425 |     |         bytes memory params
 426 |     |     ) external returns (uint256 balance);
 427 |     | 
 428 |     |     /**
 429 |     |      * @dev Cast a vote using the voter's signature, including ERC-1271 signature support.
 430 |     |      *
 431 |     |      * Emits a {VoteCast} event.
 432 |     |      */
 433 |     |     function castVoteBySig(
 434 |     |         uint256 proposalId,
 435 |     |         uint8 support,
 436 |     |         address voter,
 437 |     |         bytes memory signature
 438 |     |     ) external returns (uint256 balance);
 439 |     | 
 440 |     |     /**
 441 |     |      * @dev Cast a vote with a reason and additional encoded parameters using the voter's signature,
 442 |     |      * including ERC-1271 signature support.
 443 |     |      *
 444 |     |      * Emits a {VoteCast} or {VoteCastWithParams} event depending on the length of params.
 445 |     |      */
 446 |     |     function castVoteWithReasonAndParamsBySig(
 447 |     |         uint256 proposalId,
 448 |     |         uint8 support,
 449 |     |         address voter,
 450 |     |         string calldata reason,
 451 |     |         bytes memory params,
 452 |     |         bytes memory signature
 453 |     |     ) external returns (uint256 balance);
 454 |     | }
 455 |     | 

/home/phantom/Documents/azemora/azemora-contracts/lib/openzeppelin-contracts/contracts/governance/utils/IVotes.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | // OpenZeppelin Contracts (last updated v5.0.0) (governance/utils/IVotes.sol)
  3 |     | pragma solidity >=0.8.4;
  4 |     | 
  5 |     | /**
  6 |     |  * @dev Common interface for {ERC20Votes}, {ERC721Votes}, and other {Votes}-enabled contracts.
  7 |     |  */
  8 |     | interface IVotes {
  9 |     |     /**
 10 |     |      * @dev The signature used has expired.
 11 |     |      */
 12 |     |     error VotesExpiredSignature(uint256 expiry);
 13 |     | 
 14 |     |     /**
 15 |     |      * @dev Emitted when an account changes their delegate.
 16 |     |      */
 17 |     |     event DelegateChanged(address indexed delegator, address indexed fromDelegate, address indexed toDelegate);
 18 |     | 
 19 |     |     /**
 20 |     |      * @dev Emitted when a token transfer or delegate change results in changes to a delegate's number of voting units.
 21 |     |      */
 22 |     |     event DelegateVotesChanged(address indexed delegate, uint256 previousVotes, uint256 newVotes);
 23 |     | 
 24 |     |     /**
 25 |     |      * @dev Returns the current amount of votes that `account` has.
 26 |     |      */
 27 |     |     function getVotes(address account) external view returns (uint256);
 28 |     | 
 29 |     |     /**
 30 |     |      * @dev Returns the amount of votes that `account` had at a specific moment in the past. If the `clock()` is
 31 |     |      * configured to use block numbers, this will return the value at the end of the corresponding block.
 32 |     |      */
 33 |     |     function getPastVotes(address account, uint256 timepoint) external view returns (uint256);
 34 |     | 
 35 |     |     /**
 36 |     |      * @dev Returns the total supply of votes available at a specific moment in the past. If the `clock()` is
 37 |     |      * configured to use block numbers, this will return the value at the end of the corresponding block.
 38 |     |      *
 39 |     |      * NOTE: This value is the sum of all available votes, which is not necessarily the sum of all delegated votes.
 40 |     |      * Votes that have not been delegated are still part of total supply, even though they would not participate in a
 41 |     |      * vote.
 42 |     |      */
 43 |     |     function getPastTotalSupply(uint256 timepoint) external view returns (uint256);
 44 |     | 
 45 |     |     /**
 46 |     |      * @dev Returns the delegate that `account` has chosen.
 47 |     |      */
 48 |     |     function delegates(address account) external view returns (address);
 49 |     | 
 50 |     |     /**
 51 |     |      * @dev Delegates votes from the sender to `delegatee`.
 52 |     |      */
 53 |     |     function delegate(address delegatee) external;
 54 |     | 
 55 |     |     /**
 56 |     |      * @dev Delegates votes from signer to `delegatee`.
 57 |     |      */
 58 |     |     function delegateBySig(address delegatee, uint256 nonce, uint256 expiry, uint8 v, bytes32 r, bytes32 s) external;
 59 |     | }
 60 |     | 

/home/phantom/Documents/azemora/azemora-contracts/lib/openzeppelin-contracts/contracts/interfaces/IERC1271.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | // OpenZeppelin Contracts (last updated v5.3.0) (interfaces/IERC1271.sol)
  3 |     | 
  4 |     | pragma solidity >=0.5.0;
  5 |     | 
  6 |     | /**
  7 |     |  * @dev Interface of the ERC-1271 standard signature validation method for
  8 |     |  * contracts as defined in https://eips.ethereum.org/EIPS/eip-1271[ERC-1271].
  9 |     |  */
 10 |     | interface IERC1271 {
 11 |     |     /**
 12 |     |      * @dev Should return whether the signature provided is valid for the provided data
 13 |     |      * @param hash      Hash of the data to be signed
 14 |     |      * @param signature Signature byte array associated with `hash`
 15 |     |      */
 16 |     |     function isValidSignature(bytes32 hash, bytes calldata signature) external view returns (bytes4 magicValue);
 17 |     | }
 18 |     | 

/home/phantom/Documents/azemora/azemora-contracts/lib/openzeppelin-contracts/contracts/interfaces/IERC165.sol
 1 |     | // SPDX-License-Identifier: MIT
 2 |     | // OpenZeppelin Contracts (last updated v5.0.0) (interfaces/IERC165.sol)
 3 |     | 
 4 |     | pragma solidity >=0.4.16;
 5 |     | 
 6 |     | import {IERC165} from "../utils/introspection/IERC165.sol";
 7 |     | 

/home/phantom/Documents/azemora/azemora-contracts/lib/openzeppelin-contracts/contracts/interfaces/IERC1967.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | // OpenZeppelin Contracts (last updated v5.0.0) (interfaces/IERC1967.sol)
  3 |     | 
  4 |     | pragma solidity >=0.4.11;
  5 |     | 
  6 |     | /**
  7 |     |  * @dev ERC-1967: Proxy Storage Slots. This interface contains the events defined in the ERC.
  8 |     |  */
  9 |     | interface IERC1967 {
 10 |     |     /**
 11 |     |      * @dev Emitted when the implementation is upgraded.
 12 |     |      */
 13 |     |     event Upgraded(address indexed implementation);
 14 |     | 
 15 |     |     /**
 16 |     |      * @dev Emitted when the admin account has changed.
 17 |     |      */
 18 |     |     event AdminChanged(address previousAdmin, address newAdmin);
 19 |     | 
 20 |     |     /**
 21 |     |      * @dev Emitted when the beacon is changed.
 22 |     |      */
 23 |     |     event BeaconUpgraded(address indexed beacon);
 24 |     | }
 25 |     | 

/home/phantom/Documents/azemora/azemora-contracts/lib/openzeppelin-contracts/contracts/interfaces/IERC5267.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | // OpenZeppelin Contracts (last updated v5.0.0) (interfaces/IERC5267.sol)
  3 |     | 
  4 |     | pragma solidity >=0.4.16;
  5 |     | 
  6 |     | interface IERC5267 {
  7 |     |     /**
  8 |     |      * @dev MAY be emitted to signal that the domain could have changed.
  9 |     |      */
 10 |     |     event EIP712DomainChanged();
 11 |     | 
 12 |     |     /**
 13 |     |      * @dev returns the fields and values that describe the domain separator used by this contract for EIP-712
 14 |     |      * signature.
 15 |     |      */
 16 |     |     function eip712Domain()
 17 |     |         external
 18 |     |         view
 19 |     |         returns (
 20 |     |             bytes1 fields,
 21 |     |             string memory name,
 22 |     |             string memory version,
 23 |     |             uint256 chainId,
 24 |     |             address verifyingContract,
 25 |     |             bytes32 salt,
 26 |     |             uint256[] memory extensions
 27 |     |         );
 28 |     | }
 29 |     | 

/home/phantom/Documents/azemora/azemora-contracts/lib/openzeppelin-contracts/contracts/interfaces/IERC5805.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | // OpenZeppelin Contracts (last updated v5.0.0) (interfaces/IERC5805.sol)
  3 |     | 
  4 |     | pragma solidity >=0.8.4;
  5 |     | 
  6 |     | import {IVotes} from "../governance/utils/IVotes.sol";
  7 |     | import {IERC6372} from "./IERC6372.sol";
  8 |     | 
  9 |     | interface IERC5805 is IERC6372, IVotes {}
 10 |     | 

/home/phantom/Documents/azemora/azemora-contracts/lib/openzeppelin-contracts/contracts/interfaces/IERC6372.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | // OpenZeppelin Contracts (last updated v5.0.0) (interfaces/IERC6372.sol)
  3 |     | 
  4 |     | pragma solidity >=0.4.16;
  5 |     | 
  6 |     | interface IERC6372 {
  7 |     |     /**
  8 |     |      * @dev Clock used for flagging checkpoints. Can be overridden to implement timestamp based checkpoints (and voting).
  9 |     |      */
 10 |     |     function clock() external view returns (uint48);
 11 |     | 
 12 |     |     /**
 13 |     |      * @dev Description of the clock
 14 |     |      */
 15 |     |     // solhint-disable-next-line func-name-mixedcase
 16 |     |     function CLOCK_MODE() external view returns (string memory);
 17 |     | }
 18 |     | 

/home/phantom/Documents/azemora/azemora-contracts/lib/openzeppelin-contracts/contracts/interfaces/IERC7913.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | 
  3 |     | pragma solidity >=0.5.0;
  4 |     | 
  5 |     | /**
  6 |     |  * @dev Signature verifier interface.
  7 |     |  */
  8 |     | interface IERC7913SignatureVerifier {
  9 |     |     /**
 10 |     |      * @dev Verifies `signature` as a valid signature of `hash` by `key`.
 11 |     |      *
 12 |     |      * MUST return the bytes4 magic value IERC7913SignatureVerifier.verify.selector if the signature is valid.
 13 |     |      * SHOULD return 0xffffffff or revert if the signature is not valid.
 14 |     |      * SHOULD return 0xffffffff or revert if the key is empty
 15 |     |      */
 16 |     |     function verify(bytes calldata key, bytes32 hash, bytes calldata signature) external view returns (bytes4);
 17 |     | }
 18 |     | 

/home/phantom/Documents/azemora/azemora-contracts/lib/openzeppelin-contracts/contracts/interfaces/draft-IERC1822.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | // OpenZeppelin Contracts (last updated v5.1.0) (interfaces/draft-IERC1822.sol)
  3 |     | 
  4 |     | pragma solidity >=0.4.16;
  5 |     | 
  6 |     | /**
  7 |     |  * @dev ERC-1822: Universal Upgradeable Proxy Standard (UUPS) documents a method for upgradeability through a simplified
  8 |     |  * proxy whose upgrades are fully controlled by the current implementation.
  9 |     |  */
 10 |     | interface IERC1822Proxiable {
 11 |     |     /**
 12 |     |      * @dev Returns the storage slot that the proxiable contract assumes is being used to store the implementation
 13 |     |      * address.
 14 |     |      *
 15 |     |      * IMPORTANT: A proxy pointing at a proxiable contract should not be considered proxiable itself, because this risks
 16 |     |      * bricking a proxy that upgrades to it, by delegating to itself until out of gas. Thus it is critical that this
 17 |     |      * function revert if invoked through a proxy.
 18 |     |      */
 19 |     |     function proxiableUUID() external view returns (bytes32);
 20 |     | }
 21 | *   | 

/home/phantom/Documents/azemora/azemora-contracts/lib/openzeppelin-contracts/contracts/interfaces/draft-IERC6093.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | // OpenZeppelin Contracts (last updated v5.1.0) (interfaces/draft-IERC6093.sol)
   3 |     | pragma solidity >=0.8.4;
   4 |     | 
   5 |     | /**
   6 |     |  * @dev Standard ERC-20 Errors
   7 |     |  * Interface of the https://eips.ethereum.org/EIPS/eip-6093[ERC-6093] custom errors for ERC-20 tokens.
   8 |     |  */
   9 |     | interface IERC20Errors {
  10 |     |     /**
  11 |     |      * @dev Indicates an error related to the current `balance` of a `sender`. Used in transfers.
  12 |     |      * @param sender Address whose tokens are being transferred.
  13 |     |      * @param balance Current balance for the interacting account.
  14 |     |      * @param needed Minimum amount required to perform a transfer.
  15 |     |      */
  16 |     |     error ERC20InsufficientBalance(address sender, uint256 balance, uint256 needed);
  17 |     | 
  18 |     |     /**
  19 |     |      * @dev Indicates a failure with the token `sender`. Used in transfers.
  20 |     |      * @param sender Address whose tokens are being transferred.
  21 |     |      */
  22 |     |     error ERC20InvalidSender(address sender);
  23 |     | 
  24 |     |     /**
  25 |     |      * @dev Indicates a failure with the token `receiver`. Used in transfers.
  26 |     |      * @param receiver Address to which tokens are being transferred.
  27 |     |      */
  28 |     |     error ERC20InvalidReceiver(address receiver);
  29 |     | 
  30 | *   |     /**
  31 | *   |      * @dev Indicates a failure with the `spender`s `allowance`. Used in transfers.
  32 |     |      * @param spender Address that may be allowed to operate on tokens without being their owner.
  33 |     |      * @param allowance Amount of tokens a `spender` is allowed to operate with.
  34 |     |      * @param needed Minimum amount required to perform a transfer.
  35 |     |      */
  36 |     |     error ERC20InsufficientAllowance(address spender, uint256 allowance, uint256 needed);
  37 |     | 
  38 |     |     /**
  39 |     |      * @dev Indicates a failure with the `approver` of a token to be approved. Used in approvals.
  40 |     |      * @param approver Address initiating an approval operation.
  41 |     |      */
  42 |     |     error ERC20InvalidApprover(address approver);
  43 |     | 
  44 |     |     /**
  45 |     |      * @dev Indicates a failure with the `spender` to be approved. Used in approvals.
  46 |     |      * @param spender Address that may be allowed to operate on tokens without being their owner.
  47 |     |      */
  48 |     |     error ERC20InvalidSpender(address spender);
  49 |     | }
  50 |     | 
  51 |     | /**
  52 |     |  * @dev Standard ERC-721 Errors
  53 |     |  * Interface of the https://eips.ethereum.org/EIPS/eip-6093[ERC-6093] custom errors for ERC-721 tokens.
  54 |     |  */
  55 |     | interface IERC721Errors {
  56 |     |     /**
  57 |     |      * @dev Indicates that an address can't be an owner. For example, `address(0)` is a forbidden owner in ERC-20.
  58 |     |      * Used in balance queries.
  59 |     |      * @param owner Address of the current owner of a token.
  60 |     |      */
  61 |     |     error ERC721InvalidOwner(address owner);
  62 |     | 
  63 |     |     /**
  64 |     |      * @dev Indicates a `tokenId` whose `owner` is the zero address.
  65 |     |      * @param tokenId Identifier number of a token.
  66 |     |      */
  67 |     |     error ERC721NonexistentToken(uint256 tokenId);
  68 |     | 
  69 |     |     /**
  70 |     |      * @dev Indicates an error related to the ownership over a particular token. Used in transfers.
  71 |     |      * @param sender Address whose tokens are being transferred.
  72 |     |      * @param tokenId Identifier number of a token.
  73 |     |      * @param owner Address of the current owner of a token.
  74 |     |      */
  75 |     |     error ERC721IncorrectOwner(address sender, uint256 tokenId, address owner);
  76 |     | 
  77 |     |     /**
  78 |     |      * @dev Indicates a failure with the token `sender`. Used in transfers.
  79 |     |      * @param sender Address whose tokens are being transferred.
  80 |     |      */
  81 |     |     error ERC721InvalidSender(address sender);
  82 |     | 
  83 |     |     /**
  84 |     |      * @dev Indicates a failure with the token `receiver`. Used in transfers.
  85 |     |      * @param receiver Address to which tokens are being transferred.
  86 |     |      */
  87 |     |     error ERC721InvalidReceiver(address receiver);
  88 |     | 
  89 |     |     /**
  90 |     |      * @dev Indicates a failure with the `operator`s approval. Used in transfers.
  91 |     |      * @param operator Address that may be allowed to operate on tokens without being their owner.
  92 |     |      * @param tokenId Identifier number of a token.
  93 |     |      */
  94 |     |     error ERC721InsufficientApproval(address operator, uint256 tokenId);
  95 |     | 
  96 |     |     /**
  97 |     |      * @dev Indicates a failure with the `approver` of a token to be approved. Used in approvals.
  98 |     |      * @param approver Address initiating an approval operation.
  99 |     |      */
 100 |     |     error ERC721InvalidApprover(address approver);
 101 |     | 
 102 |     |     /**
 103 |     |      * @dev Indicates a failure with the `operator` to be approved. Used in approvals.
 104 | *   |      * @param operator Address that may be allowed to operate on tokens without being their owner.
 105 |     |      */
 106 |     |     error ERC721InvalidOperator(address operator);
 107 |     | }
 108 |     | 
 109 |     | /**
 110 |     |  * @dev Standard ERC-1155 Errors
 111 | *   |  * Interface of the https://eips.ethereum.org/EIPS/eip-6093[ERC-6093] custom errors for ERC-1155 tokens.
 112 |     |  */
 113 |     | interface IERC1155Errors {
 114 |     |     /**
 115 |     |      * @dev Indicates an error related to the current `balance` of a `sender`. Used in transfers.
 116 |     |      * @param sender Address whose tokens are being transferred.
 117 |     |      * @param balance Current balance for the interacting account.
 118 |     |      * @param needed Minimum amount required to perform a transfer.
 119 |     |      * @param tokenId Identifier number of a token.
 120 |     |      */
 121 |     |     error ERC1155InsufficientBalance(address sender, uint256 balance, uint256 needed, uint256 tokenId);
 122 |     | 
 123 |     |     /**
 124 |     |      * @dev Indicates a failure with the token `sender`. Used in transfers.
 125 |     |      * @param sender Address whose tokens are being transferred.
 126 |     |      */
 127 |     |     error ERC1155InvalidSender(address sender);
 128 |     | 
 129 |     |     /**
 130 |     |      * @dev Indicates a failure with the token `receiver`. Used in transfers.
 131 |     |      * @param receiver Address to which tokens are being transferred.
 132 |     |      */
 133 |     |     error ERC1155InvalidReceiver(address receiver);
 134 |     | 
 135 |     |     /**
 136 |     |      * @dev Indicates a failure with the `operator`s approval. Used in transfers.
 137 |     |      * @param operator Address that may be allowed to operate on tokens without being their owner.
 138 |     |      * @param owner Address of the current owner of a token.
 139 |     |      */
 140 |     |     error ERC1155MissingApprovalForAll(address operator, address owner);
 141 |     | 
 142 |     |     /**
 143 |     |      * @dev Indicates a failure with the `approver` of a token to be approved. Used in approvals.
 144 |     |      * @param approver Address initiating an approval operation.
 145 |     |      */
 146 |     |     error ERC1155InvalidApprover(address approver);
 147 |     | 
 148 |     |     /**
 149 |     |      * @dev Indicates a failure with the `operator` to be approved. Used in approvals.
 150 |     |      * @param operator Address that may be allowed to operate on tokens without being their owner.
 151 |     |      */
 152 |     |     error ERC1155InvalidOperator(address operator);
 153 |     | 
 154 |     |     /**
 155 |     |      * @dev Indicates an array length mismatch between ids and values in a safeBatchTransferFrom operation.
 156 |     |      * Used in batch transfers.
 157 |     |      * @param idsLength Length of the array of token identifiers
 158 |     |      * @param valuesLength Length of the array of token amounts
 159 |     |      */
 160 |     |     error ERC1155InvalidArrayLength(uint256 idsLength, uint256 valuesLength);
 161 |     | }
 162 |     | 

/home/phantom/Documents/azemora/azemora-contracts/lib/openzeppelin-contracts/contracts/mocks/token/ERC20Mock.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | pragma solidity ^0.8.20;
  3 |     | 
  4 |     | import {ERC20} from "../../token/ERC20/ERC20.sol";
  5 |     | 
  6 |     | contract ERC20Mock is ERC20 {
  7 |     |     constructor() ERC20("ERC20Mock", "E20M") {}
  8 |     | 
  9 |     |     function mint(address account, uint256 amount) external {
 10 |     |         _mint(account, amount);
 11 |     |     }
 12 |     | 
 13 |     |     function burn(address account, uint256 amount) external {
 14 |     |         _burn(account, amount);
 15 |     |     }
 16 |     | }
 17 | *   | 

/home/phantom/Documents/azemora/azemora-contracts/lib/openzeppelin-contracts/contracts/proxy/ERC1967/ERC1967Proxy.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | // OpenZeppelin Contracts (last updated v5.2.0) (proxy/ERC1967/ERC1967Proxy.sol)
  3 |     | 
  4 |     | pragma solidity ^0.8.22;
  5 |     | 
  6 |     | import {Proxy} from "../Proxy.sol";
  7 |     | import {ERC1967Utils} from "./ERC1967Utils.sol";
  8 |     | 
  9 |     | /**
 10 |     |  * @dev This contract implements an upgradeable proxy. It is upgradeable because calls are delegated to an
 11 |     |  * implementation address that can be changed. This address is stored in storage in the location specified by
 12 |     |  * https://eips.ethereum.org/EIPS/eip-1967[ERC-1967], so that it doesn't conflict with the storage layout of the
 13 |     |  * implementation behind the proxy.
 14 |     |  */
 15 |     | contract ERC1967Proxy is Proxy {
 16 |     |     /**
 17 |     |      * @dev Initializes the upgradeable proxy with an initial implementation specified by `implementation`.
 18 |     |      *
 19 |     |      * If `_data` is nonempty, it's used as data in a delegate call to `implementation`. This will typically be an
 20 |     |      * encoded function call, and allows initializing the storage of the proxy like a Solidity constructor.
 21 |     |      *
 22 |     |      * Requirements:
 23 |     |      *
 24 |     |      * - If `data` is empty, `msg.value` must be zero.
 25 |     |      */
 26 |     |     constructor(address implementation, bytes memory _data) payable {
 27 |     |         ERC1967Utils.upgradeToAndCall(implementation, _data);
 28 |     |     }
 29 |     | 
 30 |     |     /**
 31 | *   |      * @dev Returns the current implementation address.
 32 |     |      *
 33 |     |      * TIP: To get this value clients can read directly from the storage slot shown below (specified by ERC-1967) using
 34 | *   |      * the https://eth.wiki/json-rpc/API#eth_getstorageat[`eth_getStorageAt`] RPC call.
 35 |     |      * `0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc`
 36 |     |      */
 37 |     |     function _implementation() internal view virtual override returns (address) {
 38 |     |         return ERC1967Utils.getImplementation();
 39 |     |     }
 40 |     | }
 41 |     | 

/home/phantom/Documents/azemora/azemora-contracts/lib/openzeppelin-contracts/contracts/proxy/ERC1967/ERC1967Utils.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | // OpenZeppelin Contracts (last updated v5.2.0) (proxy/ERC1967/ERC1967Utils.sol)
   3 |     | 
   4 |     | pragma solidity ^0.8.21;
   5 |     | 
   6 |     | import {IBeacon} from "../beacon/IBeacon.sol";
   7 |     | import {IERC1967} from "../../interfaces/IERC1967.sol";
   8 |     | import {Address} from "../../utils/Address.sol";
   9 |     | import {StorageSlot} from "../../utils/StorageSlot.sol";
  10 |     | 
  11 |     | /**
  12 |     |  * @dev This library provides getters and event emitting update functions for
  13 |     |  * https://eips.ethereum.org/EIPS/eip-1967[ERC-1967] slots.
  14 |     |  */
  15 |     | library ERC1967Utils {
  16 |     |     /**
  17 |     |      * @dev Storage slot with the address of the current implementation.
  18 |     |      * This is the keccak-256 hash of "eip1967.proxy.implementation" subtracted by 1.
  19 |     |      */
  20 |     |     // solhint-disable-next-line private-vars-leading-underscore
  21 |     |     bytes32 internal constant IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;
  22 |     | 
  23 |     |     /**
  24 |     |      * @dev The `implementation` of the proxy is invalid.
  25 |     |      */
  26 |     |     error ERC1967InvalidImplementation(address implementation);
  27 |     | 
  28 |     |     /**
  29 |     |      * @dev The `admin` of the proxy is invalid.
  30 |     |      */
  31 |     |     error ERC1967InvalidAdmin(address admin);
  32 |     | 
  33 |     |     /**
  34 |     |      * @dev The `beacon` of the proxy is invalid.
  35 |     |      */
  36 |     |     error ERC1967InvalidBeacon(address beacon);
  37 |     | 
  38 |     |     /**
  39 |     |      * @dev An upgrade function sees `msg.value > 0` that may be lost.
  40 |     |      */
  41 |     |     error ERC1967NonPayable();
  42 |     | 
  43 |     |     /**
  44 |     |      * @dev Returns the current implementation address.
  45 |     |      */
  46 |     |     function getImplementation() internal view returns (address) {
  47 |     |         return StorageSlot.getAddressSlot(IMPLEMENTATION_SLOT).value;
  48 |     |     }
  49 |     | 
  50 |     |     /**
  51 |     |      * @dev Stores a new address in the ERC-1967 implementation slot.
  52 |     |      */
  53 |     |     function _setImplementation(address newImplementation) private {
  54 |     |         if (newImplementation.code.length == 0) {
  55 |     |             revert ERC1967InvalidImplementation(newImplementation);
  56 |     |         }
  57 |     |         StorageSlot.getAddressSlot(IMPLEMENTATION_SLOT).value = newImplementation;
  58 |     |     }
  59 |     | 
  60 |     |     /**
  61 |     |      * @dev Performs implementation upgrade with additional setup call if data is nonempty.
  62 |     |      * This function is payable only if the setup call is performed, otherwise `msg.value` is rejected
  63 |     |      * to avoid stuck value in the contract.
  64 |     |      *
  65 |     |      * Emits an {IERC1967-Upgraded} event.
  66 |     |      */
  67 |     |     function upgradeToAndCall(address newImplementation, bytes memory data) internal {
  68 |     |         _setImplementation(newImplementation);
  69 |     |         emit IERC1967.Upgraded(newImplementation);
  70 |     | 
  71 |     |         if (data.length > 0) {
  72 |     |             Address.functionDelegateCall(newImplementation, data);
  73 |     |         } else {
  74 |     |             _checkNonPayable();
  75 |     |         }
  76 |     |     }
  77 |     | 
  78 |     |     /**
  79 |     |      * @dev Storage slot with the admin of the contract.
  80 |     |      * This is the keccak-256 hash of "eip1967.proxy.admin" subtracted by 1.
  81 |     |      */
  82 |     |     // solhint-disable-next-line private-vars-leading-underscore
  83 |     |     bytes32 internal constant ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;
  84 |     | 
  85 |     |     /**
  86 |     |      * @dev Returns the current admin.
  87 |     |      *
  88 |     |      * TIP: To get this value clients can read directly from the storage slot shown below (specified by ERC-1967) using
  89 |     |      * the https://eth.wiki/json-rpc/API#eth_getstorageat[`eth_getStorageAt`] RPC call.
  90 |     |      * `0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103`
  91 |     |      */
  92 |     |     function getAdmin() internal view returns (address) {
  93 |     |         return StorageSlot.getAddressSlot(ADMIN_SLOT).value;
  94 |     |     }
  95 |     | 
  96 |     |     /**
  97 |     |      * @dev Stores a new address in the ERC-1967 admin slot.
  98 |     |      */
  99 |     |     function _setAdmin(address newAdmin) private {
 100 |     |         if (newAdmin == address(0)) {
 101 |     |             revert ERC1967InvalidAdmin(address(0));
 102 |     |         }
 103 |     |         StorageSlot.getAddressSlot(ADMIN_SLOT).value = newAdmin;
 104 |     |     }
 105 |     | 
 106 |     |     /**
 107 |     |      * @dev Changes the admin of the proxy.
 108 |     |      *
 109 |     |      * Emits an {IERC1967-AdminChanged} event.
 110 |     |      */
 111 |     |     function changeAdmin(address newAdmin) internal {
 112 |     |         emit IERC1967.AdminChanged(getAdmin(), newAdmin);
 113 |     |         _setAdmin(newAdmin);
 114 |     |     }
 115 |     | 
 116 |     |     /**
 117 |     |      * @dev The storage slot of the UpgradeableBeacon contract which defines the implementation for this proxy.
 118 |     |      * This is the keccak-256 hash of "eip1967.proxy.beacon" subtracted by 1.
 119 |     |      */
 120 |     |     // solhint-disable-next-line private-vars-leading-underscore
 121 |     |     bytes32 internal constant BEACON_SLOT = 0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50;
 122 |     | 
 123 |     |     /**
 124 |     |      * @dev Returns the current beacon.
 125 |     |      */
 126 |     |     function getBeacon() internal view returns (address) {
 127 |     |         return StorageSlot.getAddressSlot(BEACON_SLOT).value;
 128 |     |     }
 129 |     | 
 130 |     |     /**
 131 |     |      * @dev Stores a new beacon in the ERC-1967 beacon slot.
 132 |     |      */
 133 |     |     function _setBeacon(address newBeacon) private {
 134 |     |         if (newBeacon.code.length == 0) {
 135 |     |             revert ERC1967InvalidBeacon(newBeacon);
 136 |     |         }
 137 |     | 
 138 |     |         StorageSlot.getAddressSlot(BEACON_SLOT).value = newBeacon;
 139 |     | 
 140 |     |         address beaconImplementation = IBeacon(newBeacon).implementation();
 141 |     |         if (beaconImplementation.code.length == 0) {
 142 |     |             revert ERC1967InvalidImplementation(beaconImplementation);
 143 |     |         }
 144 |     |     }
 145 |     | 
 146 |     |     /**
 147 |     |      * @dev Change the beacon and trigger a setup call if data is nonempty.
 148 |     |      * This function is payable only if the setup call is performed, otherwise `msg.value` is rejected
 149 |     |      * to avoid stuck value in the contract.
 150 |     |      *
 151 |     |      * Emits an {IERC1967-BeaconUpgraded} event.
 152 |     |      *
 153 |     |      * CAUTION: Invoking this function has no effect on an instance of {BeaconProxy} since v5, since
 154 |     |      * it uses an immutable beacon without looking at the value of the ERC-1967 beacon slot for
 155 |     |      * efficiency.
 156 |     |      */
 157 |     |     function upgradeBeaconToAndCall(address newBeacon, bytes memory data) internal {
 158 |     |         _setBeacon(newBeacon);
 159 |     |         emit IERC1967.BeaconUpgraded(newBeacon);
 160 |     | 
 161 |     |         if (data.length > 0) {
 162 |     |             Address.functionDelegateCall(IBeacon(newBeacon).implementation(), data);
 163 |     |         } else {
 164 |     |             _checkNonPayable();
 165 |     |         }
 166 |     |     }
 167 |     | 
 168 |     |     /**
 169 |     |      * @dev Reverts if `msg.value` is not zero. It can be used to avoid `msg.value` stuck in the contract
 170 |     |      * if an upgrade doesn't perform an initialization call.
 171 |     |      */
 172 |     |     function _checkNonPayable() private {
 173 |     |         if (msg.value > 0) {
 174 |     |             revert ERC1967NonPayable();
 175 |     |         }
 176 |     |     }
 177 |     | }
 178 |     | 

/home/phantom/Documents/azemora/azemora-contracts/lib/openzeppelin-contracts/contracts/proxy/Proxy.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | // OpenZeppelin Contracts (last updated v5.0.0) (proxy/Proxy.sol)
  3 |     | 
  4 |     | pragma solidity ^0.8.20;
  5 |     | 
  6 |     | /**
  7 |     |  * @dev This abstract contract provides a fallback function that delegates all calls to another contract using the EVM
  8 |     |  * instruction `delegatecall`. We refer to the second contract as the _implementation_ behind the proxy, and it has to
  9 |     |  * be specified by overriding the virtual {_implementation} function.
 10 |     |  *
 11 |     |  * Additionally, delegation to the implementation can be triggered manually through the {_fallback} function, or to a
 12 |     |  * different contract through the {_delegate} function.
 13 |     |  *
 14 |     |  * The success and return data of the delegated call will be returned back to the caller of the proxy.
 15 |     |  */
 16 |     | abstract contract Proxy {
 17 |     |     /**
 18 |     |      * @dev Delegates the current call to `implementation`.
 19 |     |      *
 20 |     |      * This function does not return to its internal call site, it will return directly to the external caller.
 21 |     |      */
 22 |     |     function _delegate(address implementation) internal virtual {
 23 |     |         assembly {
 24 |     |             // Copy msg.data. We take full control of memory in this inline assembly
 25 |     |             // block because it will not return to Solidity code. We overwrite the
 26 |     |             // Solidity scratch pad at memory position 0.
 27 |     |             calldatacopy(0, 0, calldatasize())
 28 |     | 
 29 |     |             // Call the implementation.
 30 |     |             // out and outsize are 0 because we don't know the size yet.
 31 |     |             let result := delegatecall(gas(), implementation, 0, calldatasize(), 0, 0)
 32 |     | 
 33 |     |             // Copy the returned data.
 34 |     |             returndatacopy(0, 0, returndatasize())
 35 |     | 
 36 |     |             switch result
 37 |     |             // delegatecall returns 0 on error.
 38 |     |             case 0 {
 39 |     |                 revert(0, returndatasize())
 40 |     |             }
 41 |     |             default {
 42 |     |                 return(0, returndatasize())
 43 |     |             }
 44 |     |         }
 45 |     |     }
 46 |     | 
 47 |     |     /**
 48 |     |      * @dev This is a virtual function that should be overridden so it returns the address to which the fallback
 49 |     |      * function and {_fallback} should delegate.
 50 |     |      */
 51 |     |     function _implementation() internal view virtual returns (address);
 52 |     | 
 53 |     |     /**
 54 |     |      * @dev Delegates the current call to the address returned by `_implementation()`.
 55 |     |      *
 56 |     |      * This function does not return to its internal call site, it will return directly to the external caller.
 57 |     |      */
 58 |     |     function _fallback() internal virtual {
 59 |     |         _delegate(_implementation());
 60 |     |     }
 61 |     | 
 62 |     |     /**
 63 |     |      * @dev Fallback function that delegates calls to the address returned by `_implementation()`. Will run if no other
 64 |     |      * function in the contract matches the call data.
 65 |     |      */
 66 |     |     fallback() external payable virtual {
 67 |     |         _fallback();
 68 |     |     }
 69 |     | }
 70 |     | 

/home/phantom/Documents/azemora/azemora-contracts/lib/openzeppelin-contracts/contracts/proxy/beacon/IBeacon.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | // OpenZeppelin Contracts (last updated v5.0.0) (proxy/beacon/IBeacon.sol)
  3 |     | 
  4 |     | pragma solidity >=0.4.16;
  5 |     | 
  6 |     | /**
  7 |     |  * @dev This is the interface that {BeaconProxy} expects of its beacon.
  8 |     |  */
  9 |     | interface IBeacon {
 10 |     |     /**
 11 |     |      * @dev Must return an address that can be used as a delegate call target.
 12 |     |      *
 13 |     |      * {UpgradeableBeacon} will check that this address is a contract.
 14 |     |      */
 15 |     |     function implementation() external view returns (address);
 16 |     | }
 17 |     | 

/home/phantom/Documents/azemora/azemora-contracts/lib/openzeppelin-contracts/contracts/token/ERC1155/IERC1155.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | // OpenZeppelin Contracts (last updated v5.3.0) (token/ERC1155/IERC1155.sol)
   3 |     | 
   4 |     | pragma solidity >=0.6.2;
   5 |     | 
   6 |     | import {IERC165} from "../../utils/introspection/IERC165.sol";
   7 |     | 
   8 |     | /**
   9 |     |  * @dev Required interface of an ERC-1155 compliant contract, as defined in the
  10 |     |  * https://eips.ethereum.org/EIPS/eip-1155[ERC].
  11 |     |  */
  12 |     | interface IERC1155 is IERC165 {
  13 |     |     /**
  14 |     |      * @dev Emitted when `value` amount of tokens of type `id` are transferred from `from` to `to` by `operator`.
  15 |     |      */
  16 |     |     event TransferSingle(address indexed operator, address indexed from, address indexed to, uint256 id, uint256 value);
  17 |     | 
  18 |     |     /**
  19 |     |      * @dev Equivalent to multiple {TransferSingle} events, where `operator`, `from` and `to` are the same for all
  20 |     |      * transfers.
  21 |     |      */
  22 |     |     event TransferBatch(
  23 |     |         address indexed operator,
  24 |     |         address indexed from,
  25 |     |         address indexed to,
  26 |     |         uint256[] ids,
  27 |     |         uint256[] values
  28 |     |     );
  29 |     | 
  30 |     |     /**
  31 |     |      * @dev Emitted when `account` grants or revokes permission to `operator` to transfer their tokens, according to
  32 |     |      * `approved`.
  33 |     |      */
  34 |     |     event ApprovalForAll(address indexed account, address indexed operator, bool approved);
  35 |     | 
  36 |     |     /**
  37 |     |      * @dev Emitted when the URI for token type `id` changes to `value`, if it is a non-programmatic URI.
  38 |     |      *
  39 |     |      * If an {URI} event was emitted for `id`, the standard
  40 |     |      * https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[guarantees] that `value` will equal the value
  41 |     |      * returned by {IERC1155MetadataURI-uri}.
  42 |     |      */
  43 |     |     event URI(string value, uint256 indexed id);
  44 |     | 
  45 |     |     /**
  46 |     |      * @dev Returns the value of tokens of token type `id` owned by `account`.
  47 |     |      */
  48 |     |     function balanceOf(address account, uint256 id) external view returns (uint256);
  49 |     | 
  50 |     |     /**
  51 |     |      * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {balanceOf}.
  52 |     |      *
  53 |     |      * Requirements:
  54 |     |      *
  55 |     |      * - `accounts` and `ids` must have the same length.
  56 |     |      */
  57 |     |     function balanceOfBatch(
  58 |     |         address[] calldata accounts,
  59 |     |         uint256[] calldata ids
  60 |     |     ) external view returns (uint256[] memory);
  61 |     | 
  62 |     |     /**
  63 |     |      * @dev Grants or revokes permission to `operator` to transfer the caller's tokens, according to `approved`,
  64 |     |      *
  65 |     |      * Emits an {ApprovalForAll} event.
  66 |     |      *
  67 |     |      * Requirements:
  68 |     |      *
  69 |     |      * - `operator` cannot be the zero address.
  70 |     |      */
  71 |     |     function setApprovalForAll(address operator, bool approved) external;
  72 |     | 
  73 |     |     /**
  74 |     |      * @dev Returns true if `operator` is approved to transfer ``account``'s tokens.
  75 |     |      *
  76 |     |      * See {setApprovalForAll}.
  77 |     |      */
  78 |     |     function isApprovedForAll(address account, address operator) external view returns (bool);
  79 |     | 
  80 |     |     /**
  81 |     |      * @dev Transfers a `value` amount of tokens of type `id` from `from` to `to`.
  82 |     |      *
  83 |     |      * WARNING: This function can potentially allow a reentrancy attack when transferring tokens
  84 |     |      * to an untrusted contract, when invoking {IERC1155Receiver-onERC1155Received} on the receiver.
  85 |     |      * Ensure to follow the checks-effects-interactions pattern and consider employing
  86 |     |      * reentrancy guards when interacting with untrusted contracts.
  87 |     |      *
  88 |     |      * Emits a {TransferSingle} event.
  89 |     |      *
  90 |     |      * Requirements:
  91 |     |      *
  92 |     |      * - `to` cannot be the zero address.
  93 |     |      * - If the caller is not `from`, it must have been approved to spend ``from``'s tokens via {setApprovalForAll}.
  94 |     |      * - `from` must have a balance of tokens of type `id` of at least `value` amount.
  95 |     |      * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the
  96 |     |      * acceptance magic value.
  97 |     |      */
  98 |     |     function safeTransferFrom(address from, address to, uint256 id, uint256 value, bytes calldata data) external;
  99 |     | 
 100 |     |     /**
 101 |     |      * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {safeTransferFrom}.
 102 |     |      *
 103 |     |      * WARNING: This function can potentially allow a reentrancy attack when transferring tokens
 104 |     |      * to an untrusted contract, when invoking {IERC1155Receiver-onERC1155BatchReceived} on the receiver.
 105 |     |      * Ensure to follow the checks-effects-interactions pattern and consider employing
 106 |     |      * reentrancy guards when interacting with untrusted contracts.
 107 |     |      *
 108 |     |      * Emits either a {TransferSingle} or a {TransferBatch} event, depending on the length of the array arguments.
 109 |     |      *
 110 |     |      * Requirements:
 111 |     |      *
 112 |     |      * - `ids` and `values` must have the same length.
 113 |     |      * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the
 114 |     |      * acceptance magic value.
 115 |     |      */
 116 |     |     function safeBatchTransferFrom(
 117 |     |         address from,
 118 |     |         address to,
 119 |     |         uint256[] calldata ids,
 120 |     |         uint256[] calldata values,
 121 |     |         bytes calldata data
 122 |     |     ) external;
 123 |     | }
 124 |     | 

/home/phantom/Documents/azemora/azemora-contracts/lib/openzeppelin-contracts/contracts/token/ERC1155/IERC1155Receiver.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | // OpenZeppelin Contracts (last updated v5.1.0) (token/ERC1155/IERC1155Receiver.sol)
  3 |     | 
  4 |     | pragma solidity >=0.6.2;
  5 |     | 
  6 |     | import {IERC165} from "../../utils/introspection/IERC165.sol";
  7 |     | 
  8 |     | /**
  9 |     |  * @dev Interface that must be implemented by smart contracts in order to receive
 10 |     |  * ERC-1155 token transfers.
 11 |     |  */
 12 |     | interface IERC1155Receiver is IERC165 {
 13 |     |     /**
 14 |     |      * @dev Handles the receipt of a single ERC-1155 token type. This function is
 15 |     |      * called at the end of a `safeTransferFrom` after the balance has been updated.
 16 |     |      *
 17 |     |      * NOTE: To accept the transfer, this must return
 18 |     |      * `bytes4(keccak256("onERC1155Received(address,address,uint256,uint256,bytes)"))`
 19 |     |      * (i.e. 0xf23a6e61, or its own function selector).
 20 |     |      *
 21 |     |      * @param operator The address which initiated the transfer (i.e. msg.sender)
 22 | *   |      * @param from The address which previously owned the token
 23 |     |      * @param id The ID of the token being transferred
 24 | *   |      * @param value The amount of tokens being transferred
 25 |     |      * @param data Additional data with no specified format
 26 |     |      * @return `bytes4(keccak256("onERC1155Received(address,address,uint256,uint256,bytes)"))` if transfer is allowed
 27 |     |      */
 28 |     |     function onERC1155Received(
 29 |     |         address operator,
 30 |     |         address from,
 31 |     |         uint256 id,
 32 |     |         uint256 value,
 33 |     |         bytes calldata data
 34 |     |     ) external returns (bytes4);
 35 |     | 
 36 |     |     /**
 37 |     |      * @dev Handles the receipt of a multiple ERC-1155 token types. This function
 38 |     |      * is called at the end of a `safeBatchTransferFrom` after the balances have
 39 |     |      * been updated.
 40 |     |      *
 41 |     |      * NOTE: To accept the transfer(s), this must return
 42 |     |      * `bytes4(keccak256("onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)"))`
 43 |     |      * (i.e. 0xbc197c81, or its own function selector).
 44 |     |      *
 45 |     |      * @param operator The address which initiated the batch transfer (i.e. msg.sender)
 46 |     |      * @param from The address which previously owned the token
 47 |     |      * @param ids An array containing ids of each token being transferred (order and length must match values array)
 48 |     |      * @param values An array containing amounts of each token being transferred (order and length must match ids array)
 49 |     |      * @param data Additional data with no specified format
 50 |     |      * @return `bytes4(keccak256("onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)"))` if transfer is allowed
 51 |     |      */
 52 |     |     function onERC1155BatchReceived(
 53 |     |         address operator,
 54 |     |         address from,
 55 |     |         uint256[] calldata ids,
 56 |     |         uint256[] calldata values,
 57 |     |         bytes calldata data
 58 |     |     ) external returns (bytes4);
 59 |     | }
 60 |     | 

/home/phantom/Documents/azemora/azemora-contracts/lib/openzeppelin-contracts/contracts/token/ERC1155/extensions/IERC1155MetadataURI.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | // OpenZeppelin Contracts (last updated v5.1.0) (token/ERC1155/extensions/IERC1155MetadataURI.sol)
  3 |     | 
  4 |     | pragma solidity >=0.6.2;
  5 |     | 
  6 |     | import {IERC1155} from "../IERC1155.sol";
  7 |     | 
  8 |     | /**
  9 |     |  * @dev Interface of the optional ERC1155MetadataExtension interface, as defined
 10 |     |  * in the https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[ERC].
 11 |     |  */
 12 |     | interface IERC1155MetadataURI is IERC1155 {
 13 |     |     /**
 14 |     |      * @dev Returns the URI for token type `id`.
 15 |     |      *
 16 |     |      * If the `\{id\}` substring is present in the URI, it must be replaced by
 17 |     |      * clients with the actual token type ID.
 18 |     |      */
 19 |     |     function uri(uint256 id) external view returns (string memory);
 20 |     | }
 21 |     | 

/home/phantom/Documents/azemora/azemora-contracts/lib/openzeppelin-contracts/contracts/token/ERC1155/utils/ERC1155Utils.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | // OpenZeppelin Contracts (last updated v5.3.0) (token/ERC1155/utils/ERC1155Utils.sol)
  3 |     | 
  4 |     | pragma solidity ^0.8.20;
  5 |     | 
  6 |     | import {IERC1155Receiver} from "../IERC1155Receiver.sol";
  7 |     | import {IERC1155Errors} from "../../../interfaces/draft-IERC6093.sol";
  8 |     | 
  9 |     | /**
 10 |     |  * @dev Library that provide common ERC-1155 utility functions.
 11 |     |  *
 12 |     |  * See https://eips.ethereum.org/EIPS/eip-1155[ERC-1155].
 13 |     |  *
 14 |     |  * _Available since v5.1._
 15 |     |  */
 16 |     | library ERC1155Utils {
 17 |     |     /**
 18 |     |      * @dev Performs an acceptance check for the provided `operator` by calling {IERC1155Receiver-onERC1155Received}
 19 |     |      * on the `to` address. The `operator` is generally the address that initiated the token transfer (i.e. `msg.sender`).
 20 |     |      *
 21 |     |      * The acceptance call is not executed and treated as a no-op if the target address doesn't contain code (i.e. an EOA).
 22 |     |      * Otherwise, the recipient must implement {IERC1155Receiver-onERC1155Received} and return the acceptance magic value to accept
 23 |     |      * the transfer.
 24 |     |      */
 25 |     |     function checkOnERC1155Received(
 26 |     |         address operator,
 27 |     |         address from,
 28 |     |         address to,
 29 |     |         uint256 id,
 30 |     |         uint256 value,
 31 |     |         bytes memory data
 32 |     |     ) internal {
 33 |     |         if (to.code.length > 0) {
 34 | *   |             try IERC1155Receiver(to).onERC1155Received(operator, from, id, value, data) returns (bytes4 response) {
 35 |     |                 if (response != IERC1155Receiver.onERC1155Received.selector) {
 36 |     |                     // Tokens rejected
 37 |     |                     revert IERC1155Errors.ERC1155InvalidReceiver(to);
 38 |     |                 }
 39 |     |             } catch (bytes memory reason) {
 40 |     |                 if (reason.length == 0) {
 41 |     |                     // non-IERC1155Receiver implementer
 42 |     |                     revert IERC1155Errors.ERC1155InvalidReceiver(to);
 43 |     |                 } else {
 44 |     |                     assembly ("memory-safe") {
 45 |     |                         revert(add(reason, 0x20), mload(reason))
 46 |     |                     }
 47 |     |                 }
 48 |     |             }
 49 |     |         }
 50 |     |     }
 51 |     | 
 52 |     |     /**
 53 | *   |      * @dev Performs a batch acceptance check for the provided `operator` by calling {IERC1155Receiver-onERC1155BatchReceived}
 54 |     |      * on the `to` address. The `operator` is generally the address that initiated the token transfer (i.e. `msg.sender`).
 55 |     |      *
 56 |     |      * The acceptance call is not executed and treated as a no-op if the target address doesn't contain code (i.e. an EOA).
 57 |     |      * Otherwise, the recipient must implement {IERC1155Receiver-onERC1155Received} and return the acceptance magic value to accept
 58 |     |      * the transfer.
 59 |     |      */
 60 |     |     function checkOnERC1155BatchReceived(
 61 |     |         address operator,
 62 |     |         address from,
 63 | *   |         address to,
 64 |     |         uint256[] memory ids,
 65 |     |         uint256[] memory values,
 66 | *   |         bytes memory data
 67 |     |     ) internal {
 68 |     |         if (to.code.length > 0) {
 69 | *   |             try IERC1155Receiver(to).onERC1155BatchReceived(operator, from, ids, values, data) returns (
 70 |     |                 bytes4 response
 71 |     |             ) {
 72 |     |                 if (response != IERC1155Receiver.onERC1155BatchReceived.selector) {
 73 |     |                     // Tokens rejected
 74 |     |                     revert IERC1155Errors.ERC1155InvalidReceiver(to);
 75 |     |                 }
 76 |     |             } catch (bytes memory reason) {
 77 |     |                 if (reason.length == 0) {
 78 |     |                     // non-IERC1155Receiver implementer
 79 |     |                     revert IERC1155Errors.ERC1155InvalidReceiver(to);
 80 |     |                 } else {
 81 |     |                     assembly ("memory-safe") {
 82 |     |                         revert(add(reason, 0x20), mload(reason))
 83 |     |                     }
 84 |     |                 }
 85 |     |             }
 86 |     |         }
 87 |     |     }
 88 |     | }
 89 |     | 

/home/phantom/Documents/azemora/azemora-contracts/lib/openzeppelin-contracts/contracts/token/ERC20/ERC20.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | // OpenZeppelin Contracts (last updated v5.3.0) (token/ERC20/ERC20.sol)
   3 |     | 
   4 |     | pragma solidity ^0.8.20;
   5 |     | 
   6 |     | import {IERC20} from "./IERC20.sol";
   7 |     | import {IERC20Metadata} from "./extensions/IERC20Metadata.sol";
   8 |     | import {Context} from "../../utils/Context.sol";
   9 |     | import {IERC20Errors} from "../../interfaces/draft-IERC6093.sol";
  10 |     | 
  11 |     | /**
  12 |     |  * @dev Implementation of the {IERC20} interface.
  13 |     |  *
  14 |     |  * This implementation is agnostic to the way tokens are created. This means
  15 |     |  * that a supply mechanism has to be added in a derived contract using {_mint}.
  16 |     |  *
  17 |     |  * TIP: For a detailed writeup see our guide
  18 |     |  * https://forum.openzeppelin.com/t/how-to-implement-erc20-supply-mechanisms/226[How
  19 |     |  * to implement supply mechanisms].
  20 |     |  *
  21 |     |  * The default value of {decimals} is 18. To change this, you should override
  22 |     |  * this function so it returns a different value.
  23 |     |  *
  24 |     |  * We have followed general OpenZeppelin Contracts guidelines: functions revert
  25 |     |  * instead returning `false` on failure. This behavior is nonetheless
  26 |     |  * conventional and does not conflict with the expectations of ERC-20
  27 |     |  * applications.
  28 |     |  */
  29 |     | abstract contract ERC20 is Context, IERC20, IERC20Metadata, IERC20Errors {
  30 |     |     mapping(address account => uint256) private _balances;
  31 |     | 
  32 |     |     mapping(address account => mapping(address spender => uint256)) private _allowances;
  33 |     | 
  34 |     |     uint256 private _totalSupply;
  35 |     | 
  36 |     |     string private _name;
  37 |     |     string private _symbol;
  38 |     | 
  39 |     |     /**
  40 |     |      * @dev Sets the values for {name} and {symbol}.
  41 |     |      *
  42 |     |      * Both values are immutable: they can only be set once during construction.
  43 |     |      */
  44 |     |     constructor(string memory name_, string memory symbol_) {
  45 |     |         _name = name_;
  46 |     |         _symbol = symbol_;
  47 |     |     }
  48 |     | 
  49 |     |     /**
  50 |     |      * @dev Returns the name of the token.
  51 |     |      */
  52 |     |     function name() public view virtual returns (string memory) {
  53 |     |         return _name;
  54 |     |     }
  55 |     | 
  56 |     |     /**
  57 |     |      * @dev Returns the symbol of the token, usually a shorter version of the
  58 | *   |      * name.
  59 |     |      */
  60 | *   |     function symbol() public view virtual returns (string memory) {
  61 |     |         return _symbol;
  62 |     |     }
  63 |     | 
  64 |     |     /**
  65 |     |      * @dev Returns the number of decimals used to get its user representation.
  66 |     |      * For example, if `decimals` equals `2`, a balance of `505` tokens should
  67 |     |      * be displayed to a user as `5.05` (`505 / 10 ** 2`).
  68 |     |      *
  69 |     |      * Tokens usually opt for a value of 18, imitating the relationship between
  70 |     |      * Ether and Wei. This is the default value returned by this function, unless
  71 |     |      * it's overridden.
  72 |     |      *
  73 | *   |      * NOTE: This information is only used for _display_ purposes: it in
  74 |     |      * no way affects any of the arithmetic of the contract, including
  75 |     |      * {IERC20-balanceOf} and {IERC20-transfer}.
  76 |     |      */
  77 | *   |     function decimals() public view virtual returns (uint8) {
  78 | *   |         return 18;
  79 |     |     }
  80 |     | 
  81 |     |     /// @inheritdoc IERC20
  82 | *   |     function totalSupply() public view virtual returns (uint256) {
  83 |     |         return _totalSupply;
  84 |     |     }
  85 |     | 
  86 |     |     /// @inheritdoc IERC20
  87 |     |     function balanceOf(address account) public view virtual returns (uint256) {
  88 |     |         return _balances[account];
  89 |     |     }
  90 |     | 
  91 |     |     /**
  92 |     |      * @dev See {IERC20-transfer}.
  93 |     |      *
  94 |     |      * Requirements:
  95 |     |      *
  96 |     |      * - `to` cannot be the zero address.
  97 |     |      * - the caller must have a balance of at least `value`.
  98 |     |      */
  99 |     |     function transfer(address to, uint256 value) public virtual returns (bool) {
 100 |     |         address owner = _msgSender();
 101 | *   |         _transfer(owner, to, value);
 102 |     |         return true;
 103 |     |     }
 104 |     | 
 105 | *   |     /// @inheritdoc IERC20
 106 | *   |     function allowance(address owner, address spender) public view virtual returns (uint256) {
 107 |     |         return _allowances[owner][spender];
 108 |     |     }
 109 |     | 
 110 |     |     /**
 111 |     |      * @dev See {IERC20-approve}.
 112 |     |      *
 113 | *   |      * NOTE: If `value` is the maximum `uint256`, the allowance is not updated on
 114 |     |      * `transferFrom`. This is semantically equivalent to an infinite approval.
 115 |     |      *
 116 | *   |      * Requirements:
 117 |     |      *
 118 | *   |      * - `spender` cannot be the zero address.
 119 |     |      */
 120 |     |     function approve(address spender, uint256 value) public virtual returns (bool) {
 121 |     |         address owner = _msgSender();
 122 |     |         _approve(owner, spender, value);
 123 |     |         return true;
 124 |     |     }
 125 |     | 
 126 |     |     /**
 127 | *   |      * @dev See {IERC20-transferFrom}.
 128 |     |      *
 129 |     |      * Skips emitting an {Approval} event indicating an allowance update. This is not
 130 |     |      * required by the ERC. See {xref-ERC20-_approve-address-address-uint256-bool-}[_approve].
 131 |     |      *
 132 |     |      * NOTE: Does not update the allowance if the current allowance
 133 |     |      * is the maximum `uint256`.
 134 |     |      *
 135 |     |      * Requirements:
 136 |     |      *
 137 |     |      * - `from` and `to` cannot be the zero address.
 138 |     |      * - `from` must have a balance of at least `value`.
 139 |     |      * - the caller must have allowance for ``from``'s tokens of at least
 140 |     |      * `value`.
 141 |     |      */
 142 |     |     function transferFrom(address from, address to, uint256 value) public virtual returns (bool) {
 143 |     |         address spender = _msgSender();
 144 |     |         _spendAllowance(from, spender, value);
 145 |     |         _transfer(from, to, value);
 146 |     |         return true;
 147 |     |     }
 148 |     | 
 149 |     |     /**
 150 |     |      * @dev Moves a `value` amount of tokens from `from` to `to`.
 151 |     |      *
 152 |     |      * This internal function is equivalent to {transfer}, and can be used to
 153 |     |      * e.g. implement automatic token fees, slashing mechanisms, etc.
 154 |     |      *
 155 |     |      * Emits a {Transfer} event.
 156 |     |      *
 157 |     |      * NOTE: This function is not virtual, {_update} should be overridden instead.
 158 |     |      */
 159 |     |     function _transfer(address from, address to, uint256 value) internal {
 160 |     |         if (from == address(0)) {
 161 |     |             revert ERC20InvalidSender(address(0));
 162 |     |         }
 163 |     |         if (to == address(0)) {
 164 |     |             revert ERC20InvalidReceiver(address(0));
 165 |     |         }
 166 |     |         _update(from, to, value);
 167 |     |     }
 168 |     | 
 169 |     |     /**
 170 |     |      * @dev Transfers a `value` amount of tokens from `from` to `to`, or alternatively mints (or burns) if `from`
 171 |     |      * (or `to`) is the zero address. All customizations to transfers, mints, and burns should be done by overriding
 172 |     |      * this function.
 173 |     |      *
 174 |     |      * Emits a {Transfer} event.
 175 |     |      */
 176 |     |     function _update(address from, address to, uint256 value) internal virtual {
 177 |     |         if (from == address(0)) {
 178 |     |             // Overflow check required: The rest of the code assumes that totalSupply never overflows
 179 |     |             _totalSupply += value;
 180 |     |         } else {
 181 |     |             uint256 fromBalance = _balances[from];
 182 |     |             if (fromBalance < value) {
 183 |     |                 revert ERC20InsufficientBalance(from, fromBalance, value);
 184 |     |             }
 185 |     |             unchecked {
 186 |     |                 // Overflow not possible: value <= fromBalance <= totalSupply.
 187 |     |                 _balances[from] = fromBalance - value;
 188 |     |             }
 189 |     |         }
 190 |     | 
 191 |     |         if (to == address(0)) {
 192 |     |             unchecked {
 193 |     |                 // Overflow not possible: value <= totalSupply or value <= fromBalance <= totalSupply.
 194 |     |                 _totalSupply -= value;
 195 |     |             }
 196 |     |         } else {
 197 |     |             unchecked {
 198 |     |                 // Overflow not possible: balance + value is at most totalSupply, which we know fits into a uint256.
 199 |     |                 _balances[to] += value;
 200 |     |             }
 201 |     |         }
 202 |     | 
 203 |     |         emit Transfer(from, to, value);
 204 |     |     }
 205 |     | 
 206 |     |     /**
 207 |     |      * @dev Creates a `value` amount of tokens and assigns them to `account`, by transferring it from address(0).
 208 |     |      * Relies on the `_update` mechanism
 209 |     |      *
 210 |     |      * Emits a {Transfer} event with `from` set to the zero address.
 211 |     |      *
 212 |     |      * NOTE: This function is not virtual, {_update} should be overridden instead.
 213 |     |      */
 214 |     |     function _mint(address account, uint256 value) internal {
 215 |     |         if (account == address(0)) {
 216 |     |             revert ERC20InvalidReceiver(address(0));
 217 |     |         }
 218 |     |         _update(address(0), account, value);
 219 |     |     }
 220 |     | 
 221 |     |     /**
 222 |     |      * @dev Destroys a `value` amount of tokens from `account`, lowering the total supply.
 223 |     |      * Relies on the `_update` mechanism.
 224 |     |      *
 225 |     |      * Emits a {Transfer} event with `to` set to the zero address.
 226 |     |      *
 227 |     |      * NOTE: This function is not virtual, {_update} should be overridden instead
 228 |     |      */
 229 |     |     function _burn(address account, uint256 value) internal {
 230 |     |         if (account == address(0)) {
 231 |     |             revert ERC20InvalidSender(address(0));
 232 |     |         }
 233 |     |         _update(account, address(0), value);
 234 |     |     }
 235 |     | 
 236 |     |     /**
 237 |     |      * @dev Sets `value` as the allowance of `spender` over the `owner`'s tokens.
 238 |     |      *
 239 |     |      * This internal function is equivalent to `approve`, and can be used to
 240 |     |      * e.g. set automatic allowances for certain subsystems, etc.
 241 |     |      *
 242 |     |      * Emits an {Approval} event.
 243 |     |      *
 244 |     |      * Requirements:
 245 |     |      *
 246 |     |      * - `owner` cannot be the zero address.
 247 |     |      * - `spender` cannot be the zero address.
 248 |     |      *
 249 |     |      * Overrides to this logic should be done to the variant with an additional `bool emitEvent` argument.
 250 |     |      */
 251 |     |     function _approve(address owner, address spender, uint256 value) internal {
 252 |     |         _approve(owner, spender, value, true);
 253 |     |     }
 254 |     | 
 255 |     |     /**
 256 |     |      * @dev Variant of {_approve} with an optional flag to enable or disable the {Approval} event.
 257 |     |      *
 258 |     |      * By default (when calling {_approve}) the flag is set to true. On the other hand, approval changes made by
 259 |     |      * `_spendAllowance` during the `transferFrom` operation set the flag to false. This saves gas by not emitting any
 260 |     |      * `Approval` event during `transferFrom` operations.
 261 |     |      *
 262 |     |      * Anyone who wishes to continue emitting `Approval` events on the`transferFrom` operation can force the flag to
 263 |     |      * true using the following override:
 264 |     |      *
 265 |     |      * ```solidity
 266 |     |      * function _approve(address owner, address spender, uint256 value, bool) internal virtual override {
 267 |     |      *     super._approve(owner, spender, value, true);
 268 |     |      * }
 269 |     |      * ```
 270 |     |      *
 271 |     |      * Requirements are the same as {_approve}.
 272 |     |      */
 273 |     |     function _approve(address owner, address spender, uint256 value, bool emitEvent) internal virtual {
 274 |     |         if (owner == address(0)) {
 275 |     |             revert ERC20InvalidApprover(address(0));
 276 |     |         }
 277 |     |         if (spender == address(0)) {
 278 |     |             revert ERC20InvalidSpender(address(0));
 279 |     |         }
 280 |     |         _allowances[owner][spender] = value;
 281 |     |         if (emitEvent) {
 282 |     |             emit Approval(owner, spender, value);
 283 |     |         }
 284 |     |     }
 285 |     | 
 286 |     |     /**
 287 |     |      * @dev Updates `owner`'s allowance for `spender` based on spent `value`.
 288 |     |      *
 289 |     |      * Does not update the allowance value in case of infinite allowance.
 290 |     |      * Revert if not enough allowance is available.
 291 |     |      *
 292 |     |      * Does not emit an {Approval} event.
 293 |     |      */
 294 |     |     function _spendAllowance(address owner, address spender, uint256 value) internal virtual {
 295 |     |         uint256 currentAllowance = allowance(owner, spender);
 296 |     |         if (currentAllowance < type(uint256).max) {
 297 |     |             if (currentAllowance < value) {
 298 |     |                 revert ERC20InsufficientAllowance(spender, currentAllowance, value);
 299 |     |             }
 300 |     |             unchecked {
 301 |     |                 _approve(owner, spender, currentAllowance - value, false);
 302 |     |             }
 303 |     |         }
 304 |     |     }
 305 |     | }
 306 |     | 

/home/phantom/Documents/azemora/azemora-contracts/lib/openzeppelin-contracts/contracts/token/ERC20/IERC20.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | // OpenZeppelin Contracts (last updated v5.1.0) (token/ERC20/IERC20.sol)
  3 |     | 
  4 |     | pragma solidity >=0.4.16;
  5 |     | 
  6 |     | /**
  7 |     |  * @dev Interface of the ERC-20 standard as defined in the ERC.
  8 |     |  */
  9 |     | interface IERC20 {
 10 |     |     /**
 11 |     |      * @dev Emitted when `value` tokens are moved from one account (`from`) to
 12 |     |      * another (`to`).
 13 |     |      *
 14 |     |      * Note that `value` may be zero.
 15 |     |      */
 16 |     |     event Transfer(address indexed from, address indexed to, uint256 value);
 17 |     | 
 18 |     |     /**
 19 |     |      * @dev Emitted when the allowance of a `spender` for an `owner` is set by
 20 |     |      * a call to {approve}. `value` is the new allowance.
 21 |     |      */
 22 |     |     event Approval(address indexed owner, address indexed spender, uint256 value);
 23 |     | 
 24 |     |     /**
 25 |     |      * @dev Returns the value of tokens in existence.
 26 |     |      */
 27 |     |     function totalSupply() external view returns (uint256);
 28 |     | 
 29 |     |     /**
 30 |     |      * @dev Returns the value of tokens owned by `account`.
 31 |     |      */
 32 |     |     function balanceOf(address account) external view returns (uint256);
 33 |     | 
 34 |     |     /**
 35 |     |      * @dev Moves a `value` amount of tokens from the caller's account to `to`.
 36 |     |      *
 37 |     |      * Returns a boolean value indicating whether the operation succeeded.
 38 |     |      *
 39 |     |      * Emits a {Transfer} event.
 40 |     |      */
 41 |     |     function transfer(address to, uint256 value) external returns (bool);
 42 |     | 
 43 |     |     /**
 44 |     |      * @dev Returns the remaining number of tokens that `spender` will be
 45 |     |      * allowed to spend on behalf of `owner` through {transferFrom}. This is
 46 |     |      * zero by default.
 47 |     |      *
 48 |     |      * This value changes when {approve} or {transferFrom} are called.
 49 |     |      */
 50 |     |     function allowance(address owner, address spender) external view returns (uint256);
 51 |     | 
 52 |     |     /**
 53 |     |      * @dev Sets a `value` amount of tokens as the allowance of `spender` over the
 54 |     |      * caller's tokens.
 55 |     |      *
 56 |     |      * Returns a boolean value indicating whether the operation succeeded.
 57 |     |      *
 58 |     |      * IMPORTANT: Beware that changing an allowance with this method brings the risk
 59 |     |      * that someone may use both the old and the new allowance by unfortunate
 60 |     |      * transaction ordering. One possible solution to mitigate this race
 61 |     |      * condition is to first reduce the spender's allowance to 0 and set the
 62 |     |      * desired value afterwards:
 63 |     |      * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729
 64 |     |      *
 65 |     |      * Emits an {Approval} event.
 66 |     |      */
 67 |     |     function approve(address spender, uint256 value) external returns (bool);
 68 |     | 
 69 |     |     /**
 70 |     |      * @dev Moves a `value` amount of tokens from `from` to `to` using the
 71 |     |      * allowance mechanism. `value` is then deducted from the caller's
 72 |     |      * allowance.
 73 |     |      *
 74 |     |      * Returns a boolean value indicating whether the operation succeeded.
 75 |     |      *
 76 |     |      * Emits a {Transfer} event.
 77 |     |      */
 78 |     |     function transferFrom(address from, address to, uint256 value) external returns (bool);
 79 |     | }
 80 |     | 

/home/phantom/Documents/azemora/azemora-contracts/lib/openzeppelin-contracts/contracts/token/ERC20/extensions/IERC20Metadata.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | // OpenZeppelin Contracts (last updated v5.1.0) (token/ERC20/extensions/IERC20Metadata.sol)
  3 |     | 
  4 |     | pragma solidity >=0.6.2;
  5 |     | 
  6 |     | import {IERC20} from "../IERC20.sol";
  7 |     | 
  8 |     | /**
  9 |     |  * @dev Interface for the optional metadata functions from the ERC-20 standard.
 10 |     |  */
 11 |     | interface IERC20Metadata is IERC20 {
 12 |     |     /**
 13 |     |      * @dev Returns the name of the token.
 14 |     |      */
 15 |     |     function name() external view returns (string memory);
 16 |     | 
 17 |     |     /**
 18 |     |      * @dev Returns the symbol of the token.
 19 |     |      */
 20 |     |     function symbol() external view returns (string memory);
 21 |     | 
 22 |     |     /**
 23 |     |      * @dev Returns the decimals places of the token.
 24 |     |      */
 25 |     |     function decimals() external view returns (uint8);
 26 |     | }
 27 |     | 

/home/phantom/Documents/azemora/azemora-contracts/lib/openzeppelin-contracts/contracts/token/ERC20/extensions/IERC20Permit.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | // OpenZeppelin Contracts (last updated v5.1.0) (token/ERC20/extensions/IERC20Permit.sol)
  3 |     | 
  4 |     | pragma solidity >=0.4.16;
  5 |     | 
  6 |     | /**
  7 |     |  * @dev Interface of the ERC-20 Permit extension allowing approvals to be made via signatures, as defined in
  8 |     |  * https://eips.ethereum.org/EIPS/eip-2612[ERC-2612].
  9 |     |  *
 10 |     |  * Adds the {permit} method, which can be used to change an account's ERC-20 allowance (see {IERC20-allowance}) by
 11 |     |  * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't
 12 |     |  * need to send a transaction, and thus is not required to hold Ether at all.
 13 |     |  *
 14 |     |  * ==== Security Considerations
 15 |     |  *
 16 |     |  * There are two important considerations concerning the use of `permit`. The first is that a valid permit signature
 17 |     |  * expresses an allowance, and it should not be assumed to convey additional meaning. In particular, it should not be
 18 |     |  * considered as an intention to spend the allowance in any specific way. The second is that because permits have
 19 |     |  * built-in replay protection and can be submitted by anyone, they can be frontrun. A protocol that uses permits should
 20 |     |  * take this into consideration and allow a `permit` call to fail. Combining these two aspects, a pattern that may be
 21 |     |  * generally recommended is:
 22 |     |  *
 23 |     |  * ```solidity
 24 |     |  * function doThingWithPermit(..., uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s) public {
 25 |     |  *     try token.permit(msg.sender, address(this), value, deadline, v, r, s) {} catch {}
 26 |     |  *     doThing(..., value);
 27 |     |  * }
 28 |     |  *
 29 |     |  * function doThing(..., uint256 value) public {
 30 |     |  *     token.safeTransferFrom(msg.sender, address(this), value);
 31 |     |  *     ...
 32 |     |  * }
 33 |     |  * ```
 34 |     |  *
 35 |     |  * Observe that: 1) `msg.sender` is used as the owner, leaving no ambiguity as to the signer intent, and 2) the use of
 36 |     |  * `try/catch` allows the permit to fail and makes the code tolerant to frontrunning. (See also
 37 |     |  * {SafeERC20-safeTransferFrom}).
 38 |     |  *
 39 |     |  * Additionally, note that smart contract wallets (such as Argent or Safe) are not able to produce permit signatures, so
 40 |     |  * contracts should have entry points that don't rely on permit.
 41 |     |  */
 42 |     | interface IERC20Permit {
 43 |     |     /**
 44 |     |      * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,
 45 |     |      * given ``owner``'s signed approval.
 46 |     |      *
 47 |     |      * IMPORTANT: The same issues {IERC20-approve} has related to transaction
 48 |     |      * ordering also apply here.
 49 |     |      *
 50 |     |      * Emits an {Approval} event.
 51 |     |      *
 52 |     |      * Requirements:
 53 |     |      *
 54 |     |      * - `spender` cannot be the zero address.
 55 |     |      * - `deadline` must be a timestamp in the future.
 56 |     |      * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`
 57 |     |      * over the EIP712-formatted function arguments.
 58 |     |      * - the signature must use ``owner``'s current nonce (see {nonces}).
 59 |     |      *
 60 |     |      * For more information on the signature format, see the
 61 |     |      * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP
 62 |     |      * section].
 63 |     |      *
 64 |     |      * CAUTION: See Security Considerations above.
 65 |     |      */
 66 |     |     function permit(
 67 |     |         address owner,
 68 |     |         address spender,
 69 |     |         uint256 value,
 70 |     |         uint256 deadline,
 71 |     |         uint8 v,
 72 |     |         bytes32 r,
 73 |     |         bytes32 s
 74 |     |     ) external;
 75 |     | 
 76 |     |     /**
 77 |     |      * @dev Returns the current nonce for `owner`. This value must be
 78 |     |      * included whenever a signature is generated for {permit}.
 79 |     |      *
 80 |     |      * Every successful call to {permit} increases ``owner``'s nonce by one. This
 81 |     |      * prevents a signature from being used multiple times.
 82 |     |      */
 83 |     |     function nonces(address owner) external view returns (uint256);
 84 |     | 
 85 |     |     /**
 86 |     |      * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.
 87 |     |      */
 88 |     |     // solhint-disable-next-line func-name-mixedcase
 89 |     |     function DOMAIN_SEPARATOR() external view returns (bytes32);
 90 |     | }
 91 |     | 

/home/phantom/Documents/azemora/azemora-contracts/lib/openzeppelin-contracts/contracts/token/ERC721/IERC721Receiver.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | // OpenZeppelin Contracts (last updated v5.1.0) (token/ERC721/IERC721Receiver.sol)
  3 |     | 
  4 |     | pragma solidity >=0.5.0;
  5 |     | 
  6 |     | /**
  7 |     |  * @title ERC-721 token receiver interface
  8 |     |  * @dev Interface for any contract that wants to support safeTransfers
  9 |     |  * from ERC-721 asset contracts.
 10 |     |  */
 11 |     | interface IERC721Receiver {
 12 |     |     /**
 13 |     |      * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}
 14 |     |      * by `operator` from `from`, this function is called.
 15 |     |      *
 16 |     |      * It must return its Solidity selector to confirm the token transfer.
 17 |     |      * If any other value is returned or the interface is not implemented by the recipient, the transfer will be
 18 |     |      * reverted.
 19 |     |      *
 20 |     |      * The selector can be obtained in Solidity with `IERC721Receiver.onERC721Received.selector`.
 21 |     |      */
 22 |     |     function onERC721Received(
 23 |     |         address operator,
 24 |     |         address from,
 25 |     |         uint256 tokenId,
 26 |     |         bytes calldata data
 27 |     |     ) external returns (bytes4);
 28 |     | }
 29 |     | 

/home/phantom/Documents/azemora/azemora-contracts/lib/openzeppelin-contracts/contracts/utils/Address.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | // OpenZeppelin Contracts (last updated v5.2.0) (utils/Address.sol)
   3 |     | 
   4 |     | pragma solidity ^0.8.20;
   5 |     | 
   6 |     | import {Errors} from "./Errors.sol";
   7 |     | 
   8 |     | /**
   9 |     |  * @dev Collection of functions related to the address type
  10 |     |  */
  11 |     | library Address {
  12 |     |     /**
  13 |     |      * @dev There's no code at `target` (it is not a contract).
  14 |     |      */
  15 |     |     error AddressEmptyCode(address target);
  16 |     | 
  17 |     |     /**
  18 |     |      * @dev Replacement for Solidity's `transfer`: sends `amount` wei to
  19 |     |      * `recipient`, forwarding all available gas and reverting on errors.
  20 |     |      *
  21 |     |      * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost
  22 |     |      * of certain opcodes, possibly making contracts go over the 2300 gas limit
  23 |     |      * imposed by `transfer`, making them unable to receive funds via
  24 |     |      * `transfer`. {sendValue} removes this limitation.
  25 |     |      *
  26 |     |      * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].
  27 |     |      *
  28 |     |      * IMPORTANT: because control is transferred to `recipient`, care must be
  29 |     |      * taken to not create reentrancy vulnerabilities. Consider using
  30 |     |      * {ReentrancyGuard} or the
  31 |     |      * https://solidity.readthedocs.io/en/v0.8.20/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].
  32 |     |      */
  33 |     |     function sendValue(address payable recipient, uint256 amount) internal {
  34 |     |         if (address(this).balance < amount) {
  35 |     |             revert Errors.InsufficientBalance(address(this).balance, amount);
  36 |     |         }
  37 |     | 
  38 |     |         (bool success, bytes memory returndata) = recipient.call{value: amount}("");
  39 |     |         if (!success) {
  40 |     |             _revert(returndata);
  41 |     |         }
  42 |     |     }
  43 |     | 
  44 |     |     /**
  45 |     |      * @dev Performs a Solidity function call using a low level `call`. A
  46 |     |      * plain `call` is an unsafe replacement for a function call: use this
  47 |     |      * function instead.
  48 |     |      *
  49 |     |      * If `target` reverts with a revert reason or custom error, it is bubbled
  50 |     |      * up by this function (like regular Solidity function calls). However, if
  51 |     |      * the call reverted with no returned reason, this function reverts with a
  52 |     |      * {Errors.FailedCall} error.
  53 |     |      *
  54 |     |      * Returns the raw returned data. To convert to the expected return value,
  55 |     |      * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].
  56 |     |      *
  57 |     |      * Requirements:
  58 |     |      *
  59 |     |      * - `target` must be a contract.
  60 |     |      * - calling `target` with `data` must not revert.
  61 |     |      */
  62 |     |     function functionCall(address target, bytes memory data) internal returns (bytes memory) {
  63 |     |         return functionCallWithValue(target, data, 0);
  64 |     |     }
  65 |     | 
  66 |     |     /**
  67 |     |      * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],
  68 |     |      * but also transferring `value` wei to `target`.
  69 |     |      *
  70 |     |      * Requirements:
  71 |     |      *
  72 |     |      * - the calling contract must have an ETH balance of at least `value`.
  73 |     |      * - the called Solidity function must be `payable`.
  74 |     |      */
  75 |     |     function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {
  76 |     |         if (address(this).balance < value) {
  77 |     |             revert Errors.InsufficientBalance(address(this).balance, value);
  78 |     |         }
  79 |     |         (bool success, bytes memory returndata) = target.call{value: value}(data);
  80 |     |         return verifyCallResultFromTarget(target, success, returndata);
  81 |     |     }
  82 |     | 
  83 |     |     /**
  84 |     |      * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],
  85 |     |      * but performing a static call.
  86 |     |      */
  87 |     |     function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {
  88 |     |         (bool success, bytes memory returndata) = target.staticcall(data);
  89 |     |         return verifyCallResultFromTarget(target, success, returndata);
  90 |     |     }
  91 |     | 
  92 |     |     /**
  93 |     |      * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],
  94 |     |      * but performing a delegate call.
  95 |     |      */
  96 |     |     function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {
  97 |     |         (bool success, bytes memory returndata) = target.delegatecall(data);
  98 |     |         return verifyCallResultFromTarget(target, success, returndata);
  99 |     |     }
 100 |     | 
 101 |     |     /**
 102 |     |      * @dev Tool to verify that a low level call to smart-contract was successful, and reverts if the target
 103 |     |      * was not a contract or bubbling up the revert reason (falling back to {Errors.FailedCall}) in case
 104 |     |      * of an unsuccessful call.
 105 |     |      */
 106 |     |     function verifyCallResultFromTarget(
 107 |     |         address target,
 108 |     |         bool success,
 109 |     |         bytes memory returndata
 110 |     |     ) internal view returns (bytes memory) {
 111 |     |         if (!success) {
 112 |     |             _revert(returndata);
 113 |     |         } else {
 114 |     |             // only check if target is a contract if the call was successful and the return data is empty
 115 |     |             // otherwise we already know that it was a contract
 116 |     |             if (returndata.length == 0 && target.code.length == 0) {
 117 |     |                 revert AddressEmptyCode(target);
 118 |     |             }
 119 |     |             return returndata;
 120 |     |         }
 121 |     |     }
 122 |     | 
 123 |     |     /**
 124 |     |      * @dev Tool to verify that a low level call was successful, and reverts if it wasn't, either by bubbling the
 125 |     |      * revert reason or with a default {Errors.FailedCall} error.
 126 |     |      */
 127 |     |     function verifyCallResult(bool success, bytes memory returndata) internal pure returns (bytes memory) {
 128 |     |         if (!success) {
 129 |     |             _revert(returndata);
 130 |     |         } else {
 131 |     |             return returndata;
 132 |     |         }
 133 |     |     }
 134 |     | 
 135 |     |     /**
 136 |     |      * @dev Reverts with returndata if present. Otherwise reverts with {Errors.FailedCall}.
 137 |     |      */
 138 |     |     function _revert(bytes memory returndata) private pure {
 139 |     |         // Look for revert reason and bubble it up if present
 140 |     |         if (returndata.length > 0) {
 141 |     |             // The easiest way to bubble the revert reason is using memory via assembly
 142 |     |             assembly ("memory-safe") {
 143 |     |                 revert(add(returndata, 0x20), mload(returndata))
 144 |     |             }
 145 |     |         } else {
 146 |     |             revert Errors.FailedCall();
 147 |     |         }
 148 |     |     }
 149 |     | }
 150 |     | 

/home/phantom/Documents/azemora/azemora-contracts/lib/openzeppelin-contracts/contracts/utils/Arrays.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | // OpenZeppelin Contracts (last updated v5.3.0) (utils/Arrays.sol)
   3 |     | // This file was procedurally generated from scripts/generate/templates/Arrays.js.
   4 |     | 
   5 |     | pragma solidity ^0.8.20;
   6 |     | 
   7 |     | import {Comparators} from "./Comparators.sol";
   8 |     | import {SlotDerivation} from "./SlotDerivation.sol";
   9 |     | import {StorageSlot} from "./StorageSlot.sol";
  10 |     | import {Math} from "./math/Math.sol";
  11 |     | 
  12 |     | /**
  13 |     |  * @dev Collection of functions related to array types.
  14 |     |  */
  15 |     | library Arrays {
  16 |     |     using SlotDerivation for bytes32;
  17 |     |     using StorageSlot for bytes32;
  18 |     | 
  19 |     |     /**
  20 |     |      * @dev Sort an array of uint256 (in memory) following the provided comparator function.
  21 |     |      *
  22 |     |      * This function does the sorting "in place", meaning that it overrides the input. The object is returned for
  23 |     |      * convenience, but that returned value can be discarded safely if the caller has a memory pointer to the array.
  24 |     |      *
  25 |     |      * NOTE: this function's cost is `O(n  log(n))` in average and `O(n)` in the worst case, with n the length of the
  26 |     |      * array. Using it in view functions that are executed through `eth_call` is safe, but one should be very careful
  27 |     |      * when executing this as part of a transaction. If the array being sorted is too large, the sort operation may
  28 |     |      * consume more gas than is available in a block, leading to potential DoS.
  29 |     |      *
  30 |     |      * IMPORTANT: Consider memory side-effects when using custom comparator functions that access memory in an unsafe way.
  31 |     |      */
  32 |     |     function sort(
  33 |     |         uint256[] memory array,
  34 |     |         function(uint256, uint256) pure returns (bool) comp
  35 |     |     ) internal pure returns (uint256[] memory) {
  36 |     |         _quickSort(_begin(array), _end(array), comp);
  37 |     |         return array;
  38 |     |     }
  39 |     | 
  40 |     |     /**
  41 |     |      * @dev Variant of {sort} that sorts an array of uint256 in increasing order.
  42 |     |      */
  43 |     |     function sort(uint256[] memory array) internal pure returns (uint256[] memory) {
  44 |     |         sort(array, Comparators.lt);
  45 |     |         return array;
  46 |     |     }
  47 |     | 
  48 |     |     /**
  49 |     |      * @dev Sort an array of address (in memory) following the provided comparator function.
  50 |     |      *
  51 |     |      * This function does the sorting "in place", meaning that it overrides the input. The object is returned for
  52 |     |      * convenience, but that returned value can be discarded safely if the caller has a memory pointer to the array.
  53 |     |      *
  54 |     |      * NOTE: this function's cost is `O(n  log(n))` in average and `O(n)` in the worst case, with n the length of the
  55 |     |      * array. Using it in view functions that are executed through `eth_call` is safe, but one should be very careful
  56 |     |      * when executing this as part of a transaction. If the array being sorted is too large, the sort operation may
  57 |     |      * consume more gas than is available in a block, leading to potential DoS.
  58 |     |      *
  59 |     |      * IMPORTANT: Consider memory side-effects when using custom comparator functions that access memory in an unsafe way.
  60 |     |      */
  61 |     |     function sort(
  62 |     |         address[] memory array,
  63 |     |         function(address, address) pure returns (bool) comp
  64 |     |     ) internal pure returns (address[] memory) {
  65 |     |         sort(_castToUint256Array(array), _castToUint256Comp(comp));
  66 |     |         return array;
  67 |     |     }
  68 |     | 
  69 |     |     /**
  70 |     |      * @dev Variant of {sort} that sorts an array of address in increasing order.
  71 |     |      */
  72 |     |     function sort(address[] memory array) internal pure returns (address[] memory) {
  73 |     |         sort(_castToUint256Array(array), Comparators.lt);
  74 |     |         return array;
  75 |     |     }
  76 |     | 
  77 |     |     /**
  78 |     |      * @dev Sort an array of bytes32 (in memory) following the provided comparator function.
  79 |     |      *
  80 |     |      * This function does the sorting "in place", meaning that it overrides the input. The object is returned for
  81 |     |      * convenience, but that returned value can be discarded safely if the caller has a memory pointer to the array.
  82 |     |      *
  83 |     |      * NOTE: this function's cost is `O(n  log(n))` in average and `O(n)` in the worst case, with n the length of the
  84 |     |      * array. Using it in view functions that are executed through `eth_call` is safe, but one should be very careful
  85 |     |      * when executing this as part of a transaction. If the array being sorted is too large, the sort operation may
  86 |     |      * consume more gas than is available in a block, leading to potential DoS.
  87 |     |      *
  88 |     |      * IMPORTANT: Consider memory side-effects when using custom comparator functions that access memory in an unsafe way.
  89 |     |      */
  90 |     |     function sort(
  91 |     |         bytes32[] memory array,
  92 |     |         function(bytes32, bytes32) pure returns (bool) comp
  93 |     |     ) internal pure returns (bytes32[] memory) {
  94 |     |         sort(_castToUint256Array(array), _castToUint256Comp(comp));
  95 |     |         return array;
  96 |     |     }
  97 |     | 
  98 |     |     /**
  99 |     |      * @dev Variant of {sort} that sorts an array of bytes32 in increasing order.
 100 |     |      */
 101 |     |     function sort(bytes32[] memory array) internal pure returns (bytes32[] memory) {
 102 |     |         sort(_castToUint256Array(array), Comparators.lt);
 103 |     |         return array;
 104 |     |     }
 105 |     | 
 106 |     |     /**
 107 |     |      * @dev Performs a quick sort of a segment of memory. The segment sorted starts at `begin` (inclusive), and stops
 108 |     |      * at end (exclusive). Sorting follows the `comp` comparator.
 109 |     |      *
 110 |     |      * Invariant: `begin <= end`. This is the case when initially called by {sort} and is preserved in subcalls.
 111 |     |      *
 112 |     |      * IMPORTANT: Memory locations between `begin` and `end` are not validated/zeroed. This function should
 113 |     |      * be used only if the limits are within a memory array.
 114 |     |      */
 115 |     |     function _quickSort(uint256 begin, uint256 end, function(uint256, uint256) pure returns (bool) comp) private pure {
 116 |     |         unchecked {
 117 |     |             if (end - begin < 0x40) return;
 118 |     | 
 119 |     |             // Use first element as pivot
 120 |     |             uint256 pivot = _mload(begin);
 121 |     |             // Position where the pivot should be at the end of the loop
 122 |     |             uint256 pos = begin;
 123 |     | 
 124 |     |             for (uint256 it = begin + 0x20; it < end; it += 0x20) {
 125 |     |                 if (comp(_mload(it), pivot)) {
 126 |     |                     // If the value stored at the iterator's position comes before the pivot, we increment the
 127 |     |                     // position of the pivot and move the value there.
 128 |     |                     pos += 0x20;
 129 |     |                     _swap(pos, it);
 130 |     |                 }
 131 |     |             }
 132 |     | 
 133 |     |             _swap(begin, pos); // Swap pivot into place
 134 |     |             _quickSort(begin, pos, comp); // Sort the left side of the pivot
 135 |     |             _quickSort(pos + 0x20, end, comp); // Sort the right side of the pivot
 136 |     |         }
 137 |     |     }
 138 |     | 
 139 |     |     /**
 140 |     |      * @dev Pointer to the memory location of the first element of `array`.
 141 |     |      */
 142 |     |     function _begin(uint256[] memory array) private pure returns (uint256 ptr) {
 143 |     |         assembly ("memory-safe") {
 144 |     |             ptr := add(array, 0x20)
 145 |     |         }
 146 |     |     }
 147 |     | 
 148 |     |     /**
 149 |     |      * @dev Pointer to the memory location of the first memory word (32bytes) after `array`. This is the memory word
 150 |     |      * that comes just after the last element of the array.
 151 |     |      */
 152 |     |     function _end(uint256[] memory array) private pure returns (uint256 ptr) {
 153 |     |         unchecked {
 154 |     |             return _begin(array) + array.length * 0x20;
 155 |     |         }
 156 |     |     }
 157 |     | 
 158 |     |     /**
 159 |     |      * @dev Load memory word (as a uint256) at location `ptr`.
 160 |     |      */
 161 |     |     function _mload(uint256 ptr) private pure returns (uint256 value) {
 162 |     |         assembly {
 163 |     |             value := mload(ptr)
 164 |     |         }
 165 |     |     }
 166 |     | 
 167 |     |     /**
 168 |     |      * @dev Swaps the elements memory location `ptr1` and `ptr2`.
 169 |     |      */
 170 |     |     function _swap(uint256 ptr1, uint256 ptr2) private pure {
 171 |     |         assembly {
 172 |     |             let value1 := mload(ptr1)
 173 |     |             let value2 := mload(ptr2)
 174 |     |             mstore(ptr1, value2)
 175 |     |             mstore(ptr2, value1)
 176 |     |         }
 177 |     |     }
 178 |     | 
 179 |     |     /// @dev Helper: low level cast address memory array to uint256 memory array
 180 |     |     function _castToUint256Array(address[] memory input) private pure returns (uint256[] memory output) {
 181 |     |         assembly {
 182 |     |             output := input
 183 |     |         }
 184 |     |     }
 185 |     | 
 186 |     |     /// @dev Helper: low level cast bytes32 memory array to uint256 memory array
 187 |     |     function _castToUint256Array(bytes32[] memory input) private pure returns (uint256[] memory output) {
 188 |     |         assembly {
 189 |     |             output := input
 190 |     |         }
 191 |     |     }
 192 |     | 
 193 |     |     /// @dev Helper: low level cast address comp function to uint256 comp function
 194 |     |     function _castToUint256Comp(
 195 |     |         function(address, address) pure returns (bool) input
 196 |     |     ) private pure returns (function(uint256, uint256) pure returns (bool) output) {
 197 |     |         assembly {
 198 |     |             output := input
 199 |     |         }
 200 |     |     }
 201 |     | 
 202 |     |     /// @dev Helper: low level cast bytes32 comp function to uint256 comp function
 203 |     |     function _castToUint256Comp(
 204 |     |         function(bytes32, bytes32) pure returns (bool) input
 205 |     |     ) private pure returns (function(uint256, uint256) pure returns (bool) output) {
 206 |     |         assembly {
 207 |     |             output := input
 208 |     |         }
 209 |     |     }
 210 |     | 
 211 |     |     /**
 212 |     |      * @dev Searches a sorted `array` and returns the first index that contains
 213 |     |      * a value greater or equal to `element`. If no such index exists (i.e. all
 214 |     |      * values in the array are strictly less than `element`), the array length is
 215 |     |      * returned. Time complexity O(log n).
 216 |     |      *
 217 |     |      * NOTE: The `array` is expected to be sorted in ascending order, and to
 218 |     |      * contain no repeated elements.
 219 |     |      *
 220 |     |      * IMPORTANT: Deprecated. This implementation behaves as {lowerBound} but lacks
 221 |     |      * support for repeated elements in the array. The {lowerBound} function should
 222 |     |      * be used instead.
 223 |     |      */
 224 |     |     function findUpperBound(uint256[] storage array, uint256 element) internal view returns (uint256) {
 225 |     |         uint256 low = 0;
 226 |     |         uint256 high = array.length;
 227 |     | 
 228 |     |         if (high == 0) {
 229 |     |             return 0;
 230 |     |         }
 231 |     | 
 232 |     |         while (low < high) {
 233 |     |             uint256 mid = Math.average(low, high);
 234 |     | 
 235 |     |             // Note that mid will always be strictly less than high (i.e. it will be a valid array index)
 236 |     |             // because Math.average rounds towards zero (it does integer division with truncation).
 237 |     |             if (unsafeAccess(array, mid).value > element) {
 238 |     |                 high = mid;
 239 |     |             } else {
 240 |     |                 low = mid + 1;
 241 |     |             }
 242 |     |         }
 243 |     | 
 244 |     |         // At this point `low` is the exclusive upper bound. We will return the inclusive upper bound.
 245 |     |         if (low > 0 && unsafeAccess(array, low - 1).value == element) {
 246 |     |             return low - 1;
 247 |     |         } else {
 248 |     |             return low;
 249 |     |         }
 250 |     |     }
 251 |     | 
 252 |     |     /**
 253 |     |      * @dev Searches an `array` sorted in ascending order and returns the first
 254 |     |      * index that contains a value greater or equal than `element`. If no such index
 255 |     |      * exists (i.e. all values in the array are strictly less than `element`), the array
 256 |     |      * length is returned. Time complexity O(log n).
 257 |     |      *
 258 |     |      * See C++'s https://en.cppreference.com/w/cpp/algorithm/lower_bound[lower_bound].
 259 |     |      */
 260 |     |     function lowerBound(uint256[] storage array, uint256 element) internal view returns (uint256) {
 261 |     |         uint256 low = 0;
 262 |     |         uint256 high = array.length;
 263 |     | 
 264 |     |         if (high == 0) {
 265 |     |             return 0;
 266 |     |         }
 267 |     | 
 268 |     |         while (low < high) {
 269 |     |             uint256 mid = Math.average(low, high);
 270 |     | 
 271 |     |             // Note that mid will always be strictly less than high (i.e. it will be a valid array index)
 272 |     |             // because Math.average rounds towards zero (it does integer division with truncation).
 273 |     |             if (unsafeAccess(array, mid).value < element) {
 274 |     |                 // this cannot overflow because mid < high
 275 |     |                 unchecked {
 276 |     |                     low = mid + 1;
 277 |     |                 }
 278 |     |             } else {
 279 |     |                 high = mid;
 280 |     |             }
 281 |     |         }
 282 |     | 
 283 |     |         return low;
 284 |     |     }
 285 |     | 
 286 |     |     /**
 287 |     |      * @dev Searches an `array` sorted in ascending order and returns the first
 288 |     |      * index that contains a value strictly greater than `element`. If no such index
 289 |     |      * exists (i.e. all values in the array are strictly less than `element`), the array
 290 |     |      * length is returned. Time complexity O(log n).
 291 |     |      *
 292 |     |      * See C++'s https://en.cppreference.com/w/cpp/algorithm/upper_bound[upper_bound].
 293 |     |      */
 294 |     |     function upperBound(uint256[] storage array, uint256 element) internal view returns (uint256) {
 295 |     |         uint256 low = 0;
 296 |     |         uint256 high = array.length;
 297 |     | 
 298 |     |         if (high == 0) {
 299 |     |             return 0;
 300 |     |         }
 301 |     | 
 302 |     |         while (low < high) {
 303 |     |             uint256 mid = Math.average(low, high);
 304 |     | 
 305 |     |             // Note that mid will always be strictly less than high (i.e. it will be a valid array index)
 306 |     |             // because Math.average rounds towards zero (it does integer division with truncation).
 307 |     |             if (unsafeAccess(array, mid).value > element) {
 308 |     |                 high = mid;
 309 |     |             } else {
 310 |     |                 // this cannot overflow because mid < high
 311 |     |                 unchecked {
 312 |     |                     low = mid + 1;
 313 |     |                 }
 314 |     |             }
 315 |     |         }
 316 |     | 
 317 |     |         return low;
 318 |     |     }
 319 |     | 
 320 |     |     /**
 321 |     |      * @dev Same as {lowerBound}, but with an array in memory.
 322 |     |      */
 323 |     |     function lowerBoundMemory(uint256[] memory array, uint256 element) internal pure returns (uint256) {
 324 |     |         uint256 low = 0;
 325 |     |         uint256 high = array.length;
 326 |     | 
 327 |     |         if (high == 0) {
 328 |     |             return 0;
 329 |     |         }
 330 |     | 
 331 |     |         while (low < high) {
 332 |     |             uint256 mid = Math.average(low, high);
 333 |     | 
 334 |     |             // Note that mid will always be strictly less than high (i.e. it will be a valid array index)
 335 |     |             // because Math.average rounds towards zero (it does integer division with truncation).
 336 |     |             if (unsafeMemoryAccess(array, mid) < element) {
 337 |     |                 // this cannot overflow because mid < high
 338 |     |                 unchecked {
 339 |     |                     low = mid + 1;
 340 |     |                 }
 341 |     |             } else {
 342 |     |                 high = mid;
 343 |     |             }
 344 |     |         }
 345 |     | 
 346 |     |         return low;
 347 |     |     }
 348 |     | 
 349 |     |     /**
 350 |     |      * @dev Same as {upperBound}, but with an array in memory.
 351 |     |      */
 352 |     |     function upperBoundMemory(uint256[] memory array, uint256 element) internal pure returns (uint256) {
 353 |     |         uint256 low = 0;
 354 |     |         uint256 high = array.length;
 355 |     | 
 356 |     |         if (high == 0) {
 357 |     |             return 0;
 358 |     |         }
 359 |     | 
 360 |     |         while (low < high) {
 361 |     |             uint256 mid = Math.average(low, high);
 362 |     | 
 363 |     |             // Note that mid will always be strictly less than high (i.e. it will be a valid array index)
 364 |     |             // because Math.average rounds towards zero (it does integer division with truncation).
 365 |     |             if (unsafeMemoryAccess(array, mid) > element) {
 366 |     |                 high = mid;
 367 |     |             } else {
 368 |     |                 // this cannot overflow because mid < high
 369 |     |                 unchecked {
 370 |     |                     low = mid + 1;
 371 |     |                 }
 372 |     |             }
 373 |     |         }
 374 |     | 
 375 |     |         return low;
 376 |     |     }
 377 |     | 
 378 |     |     /**
 379 |     |      * @dev Access an array in an "unsafe" way. Skips solidity "index-out-of-range" check.
 380 |     |      *
 381 |     |      * WARNING: Only use if you are certain `pos` is lower than the array length.
 382 |     |      */
 383 |     |     function unsafeAccess(address[] storage arr, uint256 pos) internal pure returns (StorageSlot.AddressSlot storage) {
 384 |     |         bytes32 slot;
 385 |     |         assembly ("memory-safe") {
 386 |     |             slot := arr.slot
 387 |     |         }
 388 |     |         return slot.deriveArray().offset(pos).getAddressSlot();
 389 |     |     }
 390 |     | 
 391 |     |     /**
 392 |     |      * @dev Access an array in an "unsafe" way. Skips solidity "index-out-of-range" check.
 393 |     |      *
 394 |     |      * WARNING: Only use if you are certain `pos` is lower than the array length.
 395 |     |      */
 396 |     |     function unsafeAccess(bytes32[] storage arr, uint256 pos) internal pure returns (StorageSlot.Bytes32Slot storage) {
 397 |     |         bytes32 slot;
 398 |     |         assembly ("memory-safe") {
 399 |     |             slot := arr.slot
 400 |     |         }
 401 |     |         return slot.deriveArray().offset(pos).getBytes32Slot();
 402 |     |     }
 403 |     | 
 404 |     |     /**
 405 |     |      * @dev Access an array in an "unsafe" way. Skips solidity "index-out-of-range" check.
 406 |     |      *
 407 |     |      * WARNING: Only use if you are certain `pos` is lower than the array length.
 408 |     |      */
 409 |     |     function unsafeAccess(uint256[] storage arr, uint256 pos) internal pure returns (StorageSlot.Uint256Slot storage) {
 410 |     |         bytes32 slot;
 411 |     |         assembly ("memory-safe") {
 412 |     |             slot := arr.slot
 413 |     |         }
 414 |     |         return slot.deriveArray().offset(pos).getUint256Slot();
 415 |     |     }
 416 |     | 
 417 |     |     /**
 418 |     |      * @dev Access an array in an "unsafe" way. Skips solidity "index-out-of-range" check.
 419 |     |      *
 420 |     |      * WARNING: Only use if you are certain `pos` is lower than the array length.
 421 |     |      */
 422 |     |     function unsafeAccess(bytes[] storage arr, uint256 pos) internal pure returns (StorageSlot.BytesSlot storage) {
 423 |     |         bytes32 slot;
 424 |     |         assembly ("memory-safe") {
 425 |     |             slot := arr.slot
 426 |     |         }
 427 |     |         return slot.deriveArray().offset(pos).getBytesSlot();
 428 |     |     }
 429 |     | 
 430 |     |     /**
 431 |     |      * @dev Access an array in an "unsafe" way. Skips solidity "index-out-of-range" check.
 432 |     |      *
 433 |     |      * WARNING: Only use if you are certain `pos` is lower than the array length.
 434 |     |      */
 435 |     |     function unsafeAccess(string[] storage arr, uint256 pos) internal pure returns (StorageSlot.StringSlot storage) {
 436 |     |         bytes32 slot;
 437 |     |         assembly ("memory-safe") {
 438 |     |             slot := arr.slot
 439 |     |         }
 440 |     |         return slot.deriveArray().offset(pos).getStringSlot();
 441 |     |     }
 442 |     | 
 443 |     |     /**
 444 |     |      * @dev Access an array in an "unsafe" way. Skips solidity "index-out-of-range" check.
 445 |     |      *
 446 |     |      * WARNING: Only use if you are certain `pos` is lower than the array length.
 447 |     |      */
 448 |     |     function unsafeMemoryAccess(address[] memory arr, uint256 pos) internal pure returns (address res) {
 449 |     |         assembly {
 450 |     |             res := mload(add(add(arr, 0x20), mul(pos, 0x20)))
 451 |     |         }
 452 |     |     }
 453 |     | 
 454 |     |     /**
 455 |     |      * @dev Access an array in an "unsafe" way. Skips solidity "index-out-of-range" check.
 456 |     |      *
 457 |     |      * WARNING: Only use if you are certain `pos` is lower than the array length.
 458 |     |      */
 459 |     |     function unsafeMemoryAccess(bytes32[] memory arr, uint256 pos) internal pure returns (bytes32 res) {
 460 |     |         assembly {
 461 |     |             res := mload(add(add(arr, 0x20), mul(pos, 0x20)))
 462 |     |         }
 463 |     |     }
 464 |     | 
 465 |     |     /**
 466 |     |      * @dev Access an array in an "unsafe" way. Skips solidity "index-out-of-range" check.
 467 |     |      *
 468 |     |      * WARNING: Only use if you are certain `pos` is lower than the array length.
 469 |     |      */
 470 |     |     function unsafeMemoryAccess(uint256[] memory arr, uint256 pos) internal pure returns (uint256 res) {
 471 |     |         assembly {
 472 |     |             res := mload(add(add(arr, 0x20), mul(pos, 0x20)))
 473 |     |         }
 474 |     |     }
 475 |     | 
 476 |     |     /**
 477 |     |      * @dev Access an array in an "unsafe" way. Skips solidity "index-out-of-range" check.
 478 |     |      *
 479 |     |      * WARNING: Only use if you are certain `pos` is lower than the array length.
 480 |     |      */
 481 |     |     function unsafeMemoryAccess(bytes[] memory arr, uint256 pos) internal pure returns (bytes memory res) {
 482 |     |         assembly {
 483 |     |             res := mload(add(add(arr, 0x20), mul(pos, 0x20)))
 484 |     |         }
 485 |     |     }
 486 |     | 
 487 |     |     /**
 488 |     |      * @dev Access an array in an "unsafe" way. Skips solidity "index-out-of-range" check.
 489 |     |      *
 490 |     |      * WARNING: Only use if you are certain `pos` is lower than the array length.
 491 |     |      */
 492 |     |     function unsafeMemoryAccess(string[] memory arr, uint256 pos) internal pure returns (string memory res) {
 493 |     |         assembly {
 494 |     |             res := mload(add(add(arr, 0x20), mul(pos, 0x20)))
 495 |     |         }
 496 |     |     }
 497 |     | 
 498 |     |     /**
 499 |     |      * @dev Helper to set the length of a dynamic array. Directly writing to `.length` is forbidden.
 500 |     |      *
 501 |     |      * WARNING: this does not clear elements if length is reduced, of initialize elements if length is increased.
 502 |     |      */
 503 |     |     function unsafeSetLength(address[] storage array, uint256 len) internal {
 504 |     |         assembly ("memory-safe") {
 505 |     |             sstore(array.slot, len)
 506 |     |         }
 507 |     |     }
 508 |     | 
 509 |     |     /**
 510 |     |      * @dev Helper to set the length of a dynamic array. Directly writing to `.length` is forbidden.
 511 |     |      *
 512 |     |      * WARNING: this does not clear elements if length is reduced, of initialize elements if length is increased.
 513 |     |      */
 514 |     |     function unsafeSetLength(bytes32[] storage array, uint256 len) internal {
 515 |     |         assembly ("memory-safe") {
 516 |     |             sstore(array.slot, len)
 517 |     |         }
 518 |     |     }
 519 |     | 
 520 |     |     /**
 521 |     |      * @dev Helper to set the length of a dynamic array. Directly writing to `.length` is forbidden.
 522 |     |      *
 523 |     |      * WARNING: this does not clear elements if length is reduced, of initialize elements if length is increased.
 524 |     |      */
 525 |     |     function unsafeSetLength(uint256[] storage array, uint256 len) internal {
 526 |     |         assembly ("memory-safe") {
 527 |     |             sstore(array.slot, len)
 528 |     |         }
 529 |     |     }
 530 |     | 
 531 |     |     /**
 532 |     |      * @dev Helper to set the length of a dynamic array. Directly writing to `.length` is forbidden.
 533 |     |      *
 534 |     |      * WARNING: this does not clear elements if length is reduced, of initialize elements if length is increased.
 535 |     |      */
 536 |     |     function unsafeSetLength(bytes[] storage array, uint256 len) internal {
 537 |     |         assembly ("memory-safe") {
 538 |     |             sstore(array.slot, len)
 539 |     |         }
 540 |     |     }
 541 |     | 
 542 |     |     /**
 543 |     |      * @dev Helper to set the length of a dynamic array. Directly writing to `.length` is forbidden.
 544 |     |      *
 545 |     |      * WARNING: this does not clear elements if length is reduced, of initialize elements if length is increased.
 546 |     |      */
 547 |     |     function unsafeSetLength(string[] storage array, uint256 len) internal {
 548 |     |         assembly ("memory-safe") {
 549 |     |             sstore(array.slot, len)
 550 |     |         }
 551 |     |     }
 552 |     | }
 553 |     | 

/home/phantom/Documents/azemora/azemora-contracts/lib/openzeppelin-contracts/contracts/utils/Bytes.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | // OpenZeppelin Contracts (last updated v5.2.0) (utils/Bytes.sol)
   3 |     | 
   4 |     | pragma solidity ^0.8.24;
   5 |     | 
   6 |     | import {Math} from "./math/Math.sol";
   7 |     | 
   8 |     | /**
   9 |     |  * @dev Bytes operations.
  10 |     |  */
  11 |     | library Bytes {
  12 |     |     /**
  13 |     |      * @dev Forward search for `s` in `buffer`
  14 |     |      * * If `s` is present in the buffer, returns the index of the first instance
  15 |     |      * * If `s` is not present in the buffer, returns type(uint256).max
  16 |     |      *
  17 |     |      * NOTE: replicates the behavior of https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/indexOf[Javascript's `Array.indexOf`]
  18 |     |      */
  19 |     |     function indexOf(bytes memory buffer, bytes1 s) internal pure returns (uint256) {
  20 |     |         return indexOf(buffer, s, 0);
  21 |     |     }
  22 |     | 
  23 |     |     /**
  24 |     |      * @dev Forward search for `s` in `buffer` starting at position `pos`
  25 |     |      * * If `s` is present in the buffer (at or after `pos`), returns the index of the next instance
  26 |     |      * * If `s` is not present in the buffer (at or after `pos`), returns type(uint256).max
  27 |     |      *
  28 |     |      * NOTE: replicates the behavior of https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/indexOf[Javascript's `Array.indexOf`]
  29 |     |      */
  30 |     |     function indexOf(bytes memory buffer, bytes1 s, uint256 pos) internal pure returns (uint256) {
  31 |     |         uint256 length = buffer.length;
  32 |     |         for (uint256 i = pos; i < length; ++i) {
  33 |     |             if (bytes1(_unsafeReadBytesOffset(buffer, i)) == s) {
  34 |     |                 return i;
  35 |     |             }
  36 |     |         }
  37 |     |         return type(uint256).max;
  38 |     |     }
  39 |     | 
  40 |     |     /**
  41 |     |      * @dev Backward search for `s` in `buffer`
  42 |     |      * * If `s` is present in the buffer, returns the index of the last instance
  43 |     |      * * If `s` is not present in the buffer, returns type(uint256).max
  44 |     |      *
  45 |     |      * NOTE: replicates the behavior of https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/lastIndexOf[Javascript's `Array.lastIndexOf`]
  46 |     |      */
  47 |     |     function lastIndexOf(bytes memory buffer, bytes1 s) internal pure returns (uint256) {
  48 |     |         return lastIndexOf(buffer, s, type(uint256).max);
  49 |     |     }
  50 |     | 
  51 |     |     /**
  52 |     |      * @dev Backward search for `s` in `buffer` starting at position `pos`
  53 |     |      * * If `s` is present in the buffer (at or before `pos`), returns the index of the previous instance
  54 |     |      * * If `s` is not present in the buffer (at or before `pos`), returns type(uint256).max
  55 |     |      *
  56 |     |      * NOTE: replicates the behavior of https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/lastIndexOf[Javascript's `Array.lastIndexOf`]
  57 |     |      */
  58 |     |     function lastIndexOf(bytes memory buffer, bytes1 s, uint256 pos) internal pure returns (uint256) {
  59 |     |         unchecked {
  60 |     |             uint256 length = buffer.length;
  61 |     |             // NOTE here we cannot do `i = Math.min(pos + 1, length)` because `pos + 1` could overflow
  62 |     |             for (uint256 i = Math.min(pos, length - 1) + 1; i > 0; --i) {
  63 |     |                 if (bytes1(_unsafeReadBytesOffset(buffer, i - 1)) == s) {
  64 |     |                     return i - 1;
  65 |     |                 }
  66 |     |             }
  67 |     |             return type(uint256).max;
  68 |     |         }
  69 |     |     }
  70 |     | 
  71 |     |     /**
  72 |     |      * @dev Copies the content of `buffer`, from `start` (included) to the end of `buffer` into a new bytes object in
  73 |     |      * memory.
  74 |     |      *
  75 |     |      * NOTE: replicates the behavior of https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/slice[Javascript's `Array.slice`]
  76 |     |      */
  77 |     |     function slice(bytes memory buffer, uint256 start) internal pure returns (bytes memory) {
  78 |     |         return slice(buffer, start, buffer.length);
  79 |     |     }
  80 |     | 
  81 |     |     /**
  82 |     |      * @dev Copies the content of `buffer`, from `start` (included) to `end` (excluded) into a new bytes object in
  83 |     |      * memory.
  84 |     |      *
  85 |     |      * NOTE: replicates the behavior of https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/slice[Javascript's `Array.slice`]
  86 |     |      */
  87 |     |     function slice(bytes memory buffer, uint256 start, uint256 end) internal pure returns (bytes memory) {
  88 |     |         // sanitize
  89 |     |         uint256 length = buffer.length;
  90 |     |         end = Math.min(end, length);
  91 |     |         start = Math.min(start, end);
  92 |     | 
  93 |     |         // allocate and copy
  94 |     |         bytes memory result = new bytes(end - start);
  95 |     |         assembly ("memory-safe") {
  96 |     |             mcopy(add(result, 0x20), add(add(buffer, 0x20), start), sub(end, start))
  97 |     |         }
  98 |     | 
  99 |     |         return result;
 100 |     |     }
 101 |     | 
 102 |     |     /**
 103 |     |      * @dev Reads a bytes32 from a bytes array without bounds checking.
 104 |     |      *
 105 |     |      * NOTE: making this function internal would mean it could be used with memory unsafe offset, and marking the
 106 |     |      * assembly block as such would prevent some optimizations.
 107 |     |      */
 108 |     |     function _unsafeReadBytesOffset(bytes memory buffer, uint256 offset) private pure returns (bytes32 value) {
 109 |     |         // This is not memory safe in the general case, but all calls to this private function are within bounds.
 110 |     |         assembly ("memory-safe") {
 111 |     |             value := mload(add(add(buffer, 0x20), offset))
 112 |     |         }
 113 |     |     }
 114 |     | }
 115 |     | 

/home/phantom/Documents/azemora/azemora-contracts/lib/openzeppelin-contracts/contracts/utils/Comparators.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | // OpenZeppelin Contracts (last updated v5.1.0) (utils/Comparators.sol)
  3 |     | 
  4 |     | pragma solidity ^0.8.20;
  5 |     | 
  6 |     | /**
  7 |     |  * @dev Provides a set of functions to compare values.
  8 |     |  *
  9 |     |  * _Available since v5.1._
 10 |     |  */
 11 |     | library Comparators {
 12 |     |     function lt(uint256 a, uint256 b) internal pure returns (bool) {
 13 |     |         return a < b;
 14 |     |     }
 15 |     | 
 16 |     |     function gt(uint256 a, uint256 b) internal pure returns (bool) {
 17 |     |         return a > b;
 18 |     |     }
 19 |     | }
 20 |     | 

/home/phantom/Documents/azemora/azemora-contracts/lib/openzeppelin-contracts/contracts/utils/Context.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | // OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)
  3 |     | 
  4 |     | pragma solidity ^0.8.20;
  5 |     | 
  6 |     | /**
  7 |     |  * @dev Provides information about the current execution context, including the
  8 |     |  * sender of the transaction and its data. While these are generally available
  9 |     |  * via msg.sender and msg.data, they should not be accessed in such a direct
 10 |     |  * manner, since when dealing with meta-transactions the account sending and
 11 |     |  * paying for execution may not be the actual sender (as far as an application
 12 |     |  * is concerned).
 13 |     |  *
 14 |     |  * This contract is only required for intermediate, library-like contracts.
 15 |     |  */
 16 |     | abstract contract Context {
 17 |     |     function _msgSender() internal view virtual returns (address) {
 18 |     |         return msg.sender;
 19 |     |     }
 20 |     | 
 21 |     |     function _msgData() internal view virtual returns (bytes calldata) {
 22 |     |         return msg.data;
 23 |     |     }
 24 |     | 
 25 |     |     function _contextSuffixLength() internal view virtual returns (uint256) {
 26 |     |         return 0;
 27 |     |     }
 28 |     | }
 29 |     | 

/home/phantom/Documents/azemora/azemora-contracts/lib/openzeppelin-contracts/contracts/utils/Errors.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | // OpenZeppelin Contracts (last updated v5.1.0) (utils/Errors.sol)
  3 |     | 
  4 |     | pragma solidity ^0.8.20;
  5 |     | 
  6 |     | /**
  7 |     |  * @dev Collection of common custom errors used in multiple contracts
  8 |     |  *
  9 |     |  * IMPORTANT: Backwards compatibility is not guaranteed in future versions of the library.
 10 |     |  * It is recommended to avoid relying on the error API for critical functionality.
 11 |     |  *
 12 |     |  * _Available since v5.1._
 13 |     |  */
 14 |     | library Errors {
 15 |     |     /**
 16 |     |      * @dev The ETH balance of the account is not enough to perform the operation.
 17 |     |      */
 18 |     |     error InsufficientBalance(uint256 balance, uint256 needed);
 19 |     | 
 20 |     |     /**
 21 |     |      * @dev A call to an address target failed. The target may have reverted.
 22 |     |      */
 23 |     |     error FailedCall();
 24 |     | 
 25 |     |     /**
 26 |     |      * @dev The deployment failed.
 27 |     |      */
 28 |     |     error FailedDeployment();
 29 |     | 
 30 |     |     /**
 31 |     |      * @dev A necessary precompile is missing.
 32 |     |      */
 33 |     |     error MissingPrecompile(address);
 34 |     | }
 35 |     | 

/home/phantom/Documents/azemora/azemora-contracts/lib/openzeppelin-contracts/contracts/utils/Panic.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | // OpenZeppelin Contracts (last updated v5.1.0) (utils/Panic.sol)
  3 |     | 
  4 |     | pragma solidity ^0.8.20;
  5 |     | 
  6 |     | /**
  7 |     |  * @dev Helper library for emitting standardized panic codes.
  8 |     |  *
  9 |     |  * ```solidity
 10 |     |  * contract Example {
 11 |     |  *      using Panic for uint256;
 12 |     |  *
 13 |     |  *      // Use any of the declared internal constants
 14 |     |  *      function foo() { Panic.GENERIC.panic(); }
 15 |     |  *
 16 |     |  *      // Alternatively
 17 |     |  *      function foo() { Panic.panic(Panic.GENERIC); }
 18 |     |  * }
 19 |     |  * ```
 20 |     |  *
 21 |     |  * Follows the list from https://github.com/ethereum/solidity/blob/v0.8.24/libsolutil/ErrorCodes.h[libsolutil].
 22 |     |  *
 23 |     |  * _Available since v5.1._
 24 |     |  */
 25 |     | // slither-disable-next-line unused-state
 26 |     | library Panic {
 27 |     |     /// @dev generic / unspecified error
 28 |     |     uint256 internal constant GENERIC = 0x00;
 29 |     |     /// @dev used by the assert() builtin
 30 |     |     uint256 internal constant ASSERT = 0x01;
 31 |     |     /// @dev arithmetic underflow or overflow
 32 |     |     uint256 internal constant UNDER_OVERFLOW = 0x11;
 33 |     |     /// @dev division or modulo by zero
 34 |     |     uint256 internal constant DIVISION_BY_ZERO = 0x12;
 35 |     |     /// @dev enum conversion error
 36 |     |     uint256 internal constant ENUM_CONVERSION_ERROR = 0x21;
 37 |     |     /// @dev invalid encoding in storage
 38 |     |     uint256 internal constant STORAGE_ENCODING_ERROR = 0x22;
 39 |     |     /// @dev empty array pop
 40 |     |     uint256 internal constant EMPTY_ARRAY_POP = 0x31;
 41 |     |     /// @dev array out of bounds access
 42 |     |     uint256 internal constant ARRAY_OUT_OF_BOUNDS = 0x32;
 43 |     |     /// @dev resource error (too large allocation or too large array)
 44 |     |     uint256 internal constant RESOURCE_ERROR = 0x41;
 45 |     |     /// @dev calling invalid internal function
 46 |     |     uint256 internal constant INVALID_INTERNAL_FUNCTION = 0x51;
 47 |     | 
 48 |     |     /// @dev Reverts with a panic code. Recommended to use with
 49 |     |     /// the internal constants with predefined codes.
 50 |     |     function panic(uint256 code) internal pure {
 51 |     |         assembly ("memory-safe") {
 52 |     |             mstore(0x00, 0x4e487b71)
 53 |     |             mstore(0x20, code)
 54 |     |             revert(0x1c, 0x24)
 55 |     |         }
 56 |     |     }
 57 |     | }
 58 |     | 

/home/phantom/Documents/azemora/azemora-contracts/lib/openzeppelin-contracts/contracts/utils/SlotDerivation.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | // OpenZeppelin Contracts (last updated v5.3.0) (utils/SlotDerivation.sol)
   3 |     | // This file was procedurally generated from scripts/generate/templates/SlotDerivation.js.
   4 |     | 
   5 |     | pragma solidity ^0.8.20;
   6 |     | 
   7 |     | /**
   8 |     |  * @dev Library for computing storage (and transient storage) locations from namespaces and deriving slots
   9 |     |  * corresponding to standard patterns. The derivation method for array and mapping matches the storage layout used by
  10 |     |  * the solidity language / compiler.
  11 |     |  *
  12 |     |  * See https://docs.soliditylang.org/en/v0.8.20/internals/layout_in_storage.html#mappings-and-dynamic-arrays[Solidity docs for mappings and dynamic arrays.].
  13 |     |  *
  14 |     |  * Example usage:
  15 |     |  * ```solidity
  16 |     |  * contract Example {
  17 |     |  *     // Add the library methods
  18 |     |  *     using StorageSlot for bytes32;
  19 |     |  *     using SlotDerivation for bytes32;
  20 |     |  *
  21 |     |  *     // Declare a namespace
  22 |     |  *     string private constant _NAMESPACE = "<namespace>"; // eg. OpenZeppelin.Slot
  23 |     |  *
  24 |     |  *     function setValueInNamespace(uint256 key, address newValue) internal {
  25 |     |  *         _NAMESPACE.erc7201Slot().deriveMapping(key).getAddressSlot().value = newValue;
  26 |     |  *     }
  27 |     |  *
  28 |     |  *     function getValueInNamespace(uint256 key) internal view returns (address) {
  29 |     |  *         return _NAMESPACE.erc7201Slot().deriveMapping(key).getAddressSlot().value;
  30 |     |  *     }
  31 |     |  * }
  32 |     |  * ```
  33 |     |  *
  34 |     |  * TIP: Consider using this library along with {StorageSlot}.
  35 |     |  *
  36 |     |  * NOTE: This library provides a way to manipulate storage locations in a non-standard way. Tooling for checking
  37 |     |  * upgrade safety will ignore the slots accessed through this library.
  38 |     |  *
  39 |     |  * _Available since v5.1._
  40 |     |  */
  41 |     | library SlotDerivation {
  42 |     |     /**
  43 |     |      * @dev Derive an ERC-7201 slot from a string (namespace).
  44 |     |      */
  45 |     |     function erc7201Slot(string memory namespace) internal pure returns (bytes32 slot) {
  46 |     |         assembly ("memory-safe") {
  47 |     |             mstore(0x00, sub(keccak256(add(namespace, 0x20), mload(namespace)), 1))
  48 |     |             slot := and(keccak256(0x00, 0x20), not(0xff))
  49 |     |         }
  50 |     |     }
  51 |     | 
  52 |     |     /**
  53 |     |      * @dev Add an offset to a slot to get the n-th element of a structure or an array.
  54 |     |      */
  55 |     |     function offset(bytes32 slot, uint256 pos) internal pure returns (bytes32 result) {
  56 |     |         unchecked {
  57 |     |             return bytes32(uint256(slot) + pos);
  58 |     |         }
  59 |     |     }
  60 |     | 
  61 |     |     /**
  62 |     |      * @dev Derive the location of the first element in an array from the slot where the length is stored.
  63 |     |      */
  64 |     |     function deriveArray(bytes32 slot) internal pure returns (bytes32 result) {
  65 |     |         assembly ("memory-safe") {
  66 |     |             mstore(0x00, slot)
  67 |     |             result := keccak256(0x00, 0x20)
  68 |     |         }
  69 |     |     }
  70 |     | 
  71 |     |     /**
  72 |     |      * @dev Derive the location of a mapping element from the key.
  73 |     |      */
  74 |     |     function deriveMapping(bytes32 slot, address key) internal pure returns (bytes32 result) {
  75 |     |         assembly ("memory-safe") {
  76 |     |             mstore(0x00, and(key, shr(96, not(0))))
  77 |     |             mstore(0x20, slot)
  78 |     |             result := keccak256(0x00, 0x40)
  79 |     |         }
  80 |     |     }
  81 |     | 
  82 |     |     /**
  83 |     |      * @dev Derive the location of a mapping element from the key.
  84 |     |      */
  85 |     |     function deriveMapping(bytes32 slot, bool key) internal pure returns (bytes32 result) {
  86 |     |         assembly ("memory-safe") {
  87 |     |             mstore(0x00, iszero(iszero(key)))
  88 |     |             mstore(0x20, slot)
  89 |     |             result := keccak256(0x00, 0x40)
  90 |     |         }
  91 |     |     }
  92 |     | 
  93 |     |     /**
  94 |     |      * @dev Derive the location of a mapping element from the key.
  95 |     |      */
  96 |     |     function deriveMapping(bytes32 slot, bytes32 key) internal pure returns (bytes32 result) {
  97 |     |         assembly ("memory-safe") {
  98 |     |             mstore(0x00, key)
  99 |     |             mstore(0x20, slot)
 100 |     |             result := keccak256(0x00, 0x40)
 101 |     |         }
 102 |     |     }
 103 |     | 
 104 |     |     /**
 105 |     |      * @dev Derive the location of a mapping element from the key.
 106 |     |      */
 107 |     |     function deriveMapping(bytes32 slot, uint256 key) internal pure returns (bytes32 result) {
 108 |     |         assembly ("memory-safe") {
 109 |     |             mstore(0x00, key)
 110 |     |             mstore(0x20, slot)
 111 |     |             result := keccak256(0x00, 0x40)
 112 |     |         }
 113 |     |     }
 114 |     | 
 115 |     |     /**
 116 |     |      * @dev Derive the location of a mapping element from the key.
 117 |     |      */
 118 |     |     function deriveMapping(bytes32 slot, int256 key) internal pure returns (bytes32 result) {
 119 |     |         assembly ("memory-safe") {
 120 |     |             mstore(0x00, key)
 121 |     |             mstore(0x20, slot)
 122 |     |             result := keccak256(0x00, 0x40)
 123 |     |         }
 124 |     |     }
 125 |     | 
 126 |     |     /**
 127 |     |      * @dev Derive the location of a mapping element from the key.
 128 |     |      */
 129 |     |     function deriveMapping(bytes32 slot, string memory key) internal pure returns (bytes32 result) {
 130 |     |         assembly ("memory-safe") {
 131 |     |             let length := mload(key)
 132 |     |             let begin := add(key, 0x20)
 133 |     |             let end := add(begin, length)
 134 |     |             let cache := mload(end)
 135 |     |             mstore(end, slot)
 136 |     |             result := keccak256(begin, add(length, 0x20))
 137 |     |             mstore(end, cache)
 138 |     |         }
 139 |     |     }
 140 |     | 
 141 |     |     /**
 142 |     |      * @dev Derive the location of a mapping element from the key.
 143 |     |      */
 144 |     |     function deriveMapping(bytes32 slot, bytes memory key) internal pure returns (bytes32 result) {
 145 |     |         assembly ("memory-safe") {
 146 |     |             let length := mload(key)
 147 |     |             let begin := add(key, 0x20)
 148 |     |             let end := add(begin, length)
 149 |     |             let cache := mload(end)
 150 |     |             mstore(end, slot)
 151 |     |             result := keccak256(begin, add(length, 0x20))
 152 |     |             mstore(end, cache)
 153 |     |         }
 154 |     |     }
 155 |     | }
 156 |     | 

/home/phantom/Documents/azemora/azemora-contracts/lib/openzeppelin-contracts/contracts/utils/StorageSlot.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | // OpenZeppelin Contracts (last updated v5.1.0) (utils/StorageSlot.sol)
   3 |     | // This file was procedurally generated from scripts/generate/templates/StorageSlot.js.
   4 |     | 
   5 |     | pragma solidity ^0.8.20;
   6 |     | 
   7 |     | /**
   8 |     |  * @dev Library for reading and writing primitive types to specific storage slots.
   9 |     |  *
  10 |     |  * Storage slots are often used to avoid storage conflict when dealing with upgradeable contracts.
  11 |     |  * This library helps with reading and writing to such slots without the need for inline assembly.
  12 |     |  *
  13 |     |  * The functions in this library return Slot structs that contain a `value` member that can be used to read or write.
  14 |     |  *
  15 |     |  * Example usage to set ERC-1967 implementation slot:
  16 |     |  * ```solidity
  17 |     |  * contract ERC1967 {
  18 |     |  *     // Define the slot. Alternatively, use the SlotDerivation library to derive the slot.
  19 |     |  *     bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;
  20 |     |  *
  21 |     |  *     function _getImplementation() internal view returns (address) {
  22 |     |  *         return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;
  23 |     |  *     }
  24 |     |  *
  25 |     |  *     function _setImplementation(address newImplementation) internal {
  26 |     |  *         require(newImplementation.code.length > 0);
  27 |     |  *         StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;
  28 |     |  *     }
  29 |     |  * }
  30 |     |  * ```
  31 |     |  *
  32 |     |  * TIP: Consider using this library along with {SlotDerivation}.
  33 |     |  */
  34 |     | library StorageSlot {
  35 |     |     struct AddressSlot {
  36 |     |         address value;
  37 |     |     }
  38 |     | 
  39 |     |     struct BooleanSlot {
  40 |     |         bool value;
  41 |     |     }
  42 |     | 
  43 |     |     struct Bytes32Slot {
  44 |     |         bytes32 value;
  45 |     |     }
  46 |     | 
  47 |     |     struct Uint256Slot {
  48 |     |         uint256 value;
  49 |     |     }
  50 |     | 
  51 |     |     struct Int256Slot {
  52 |     |         int256 value;
  53 |     |     }
  54 |     | 
  55 |     |     struct StringSlot {
  56 |     |         string value;
  57 |     |     }
  58 |     | 
  59 |     |     struct BytesSlot {
  60 |     |         bytes value;
  61 |     |     }
  62 |     | 
  63 |     |     /**
  64 |     |      * @dev Returns an `AddressSlot` with member `value` located at `slot`.
  65 |     |      */
  66 |     |     function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {
  67 |     |         assembly ("memory-safe") {
  68 |     |             r.slot := slot
  69 |     |         }
  70 |     |     }
  71 |     | 
  72 |     |     /**
  73 |     |      * @dev Returns a `BooleanSlot` with member `value` located at `slot`.
  74 |     |      */
  75 |     |     function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {
  76 |     |         assembly ("memory-safe") {
  77 |     |             r.slot := slot
  78 |     |         }
  79 |     |     }
  80 |     | 
  81 |     |     /**
  82 |     |      * @dev Returns a `Bytes32Slot` with member `value` located at `slot`.
  83 |     |      */
  84 |     |     function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {
  85 |     |         assembly ("memory-safe") {
  86 |     |             r.slot := slot
  87 |     |         }
  88 |     |     }
  89 |     | 
  90 |     |     /**
  91 |     |      * @dev Returns a `Uint256Slot` with member `value` located at `slot`.
  92 |     |      */
  93 |     |     function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {
  94 |     |         assembly ("memory-safe") {
  95 |     |             r.slot := slot
  96 |     |         }
  97 |     |     }
  98 |     | 
  99 |     |     /**
 100 |     |      * @dev Returns a `Int256Slot` with member `value` located at `slot`.
 101 |     |      */
 102 |     |     function getInt256Slot(bytes32 slot) internal pure returns (Int256Slot storage r) {
 103 |     |         assembly ("memory-safe") {
 104 |     |             r.slot := slot
 105 |     |         }
 106 |     |     }
 107 |     | 
 108 |     |     /**
 109 |     |      * @dev Returns a `StringSlot` with member `value` located at `slot`.
 110 |     |      */
 111 |     |     function getStringSlot(bytes32 slot) internal pure returns (StringSlot storage r) {
 112 |     |         assembly ("memory-safe") {
 113 |     |             r.slot := slot
 114 |     |         }
 115 |     |     }
 116 |     | 
 117 |     |     /**
 118 |     |      * @dev Returns an `StringSlot` representation of the string storage pointer `store`.
 119 |     |      */
 120 |     |     function getStringSlot(string storage store) internal pure returns (StringSlot storage r) {
 121 |     |         assembly ("memory-safe") {
 122 |     |             r.slot := store.slot
 123 |     |         }
 124 |     |     }
 125 |     | 
 126 |     |     /**
 127 |     |      * @dev Returns a `BytesSlot` with member `value` located at `slot`.
 128 |     |      */
 129 |     |     function getBytesSlot(bytes32 slot) internal pure returns (BytesSlot storage r) {
 130 |     |         assembly ("memory-safe") {
 131 |     |             r.slot := slot
 132 |     |         }
 133 |     |     }
 134 |     | 
 135 |     |     /**
 136 |     |      * @dev Returns an `BytesSlot` representation of the bytes storage pointer `store`.
 137 |     |      */
 138 |     |     function getBytesSlot(bytes storage store) internal pure returns (BytesSlot storage r) {
 139 |     |         assembly ("memory-safe") {
 140 |     |             r.slot := store.slot
 141 |     |         }
 142 |     |     }
 143 |     | }
 144 |     | 

/home/phantom/Documents/azemora/azemora-contracts/lib/openzeppelin-contracts/contracts/utils/Strings.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | // OpenZeppelin Contracts (last updated v5.3.0) (utils/Strings.sol)
   3 |     | 
   4 |     | pragma solidity ^0.8.20;
   5 |     | 
   6 |     | import {Math} from "./math/Math.sol";
   7 |     | import {SafeCast} from "./math/SafeCast.sol";
   8 |     | import {SignedMath} from "./math/SignedMath.sol";
   9 |     | 
  10 |     | /**
  11 |     |  * @dev String operations.
  12 |     |  */
  13 |     | library Strings {
  14 |     |     using SafeCast for *;
  15 |     | 
  16 |     |     bytes16 private constant HEX_DIGITS = "0123456789abcdef";
  17 |     |     uint8 private constant ADDRESS_LENGTH = 20;
  18 |     |     uint256 private constant SPECIAL_CHARS_LOOKUP =
  19 |     |         (1 << 0x08) | // backspace
  20 |     |             (1 << 0x09) | // tab
  21 |     |             (1 << 0x0a) | // newline
  22 |     |             (1 << 0x0c) | // form feed
  23 |     |             (1 << 0x0d) | // carriage return
  24 |     |             (1 << 0x22) | // double quote
  25 |     |             (1 << 0x5c); // backslash
  26 |     | 
  27 |     |     /**
  28 |     |      * @dev The `value` string doesn't fit in the specified `length`.
  29 |     |      */
  30 |     |     error StringsInsufficientHexLength(uint256 value, uint256 length);
  31 |     | 
  32 |     |     /**
  33 |     |      * @dev The string being parsed contains characters that are not in scope of the given base.
  34 |     |      */
  35 |     |     error StringsInvalidChar();
  36 |     | 
  37 |     |     /**
  38 |     |      * @dev The string being parsed is not a properly formatted address.
  39 |     |      */
  40 |     |     error StringsInvalidAddressFormat();
  41 |     | 
  42 |     |     /**
  43 |     |      * @dev Converts a `uint256` to its ASCII `string` decimal representation.
  44 |     |      */
  45 |     |     function toString(uint256 value) internal pure returns (string memory) {
  46 |     |         unchecked {
  47 |     |             uint256 length = Math.log10(value) + 1;
  48 |     |             string memory buffer = new string(length);
  49 |     |             uint256 ptr;
  50 |     |             assembly ("memory-safe") {
  51 |     |                 ptr := add(add(buffer, 0x20), length)
  52 |     |             }
  53 |     |             while (true) {
  54 |     |                 ptr--;
  55 |     |                 assembly ("memory-safe") {
  56 |     |                     mstore8(ptr, byte(mod(value, 10), HEX_DIGITS))
  57 |     |                 }
  58 |     |                 value /= 10;
  59 |     |                 if (value == 0) break;
  60 |     |             }
  61 |     |             return buffer;
  62 |     |         }
  63 |     |     }
  64 |     | 
  65 |     |     /**
  66 |     |      * @dev Converts a `int256` to its ASCII `string` decimal representation.
  67 |     |      */
  68 |     |     function toStringSigned(int256 value) internal pure returns (string memory) {
  69 |     |         return string.concat(value < 0 ? "-" : "", toString(SignedMath.abs(value)));
  70 |     |     }
  71 |     | 
  72 |     |     /**
  73 |     |      * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.
  74 |     |      */
  75 |     |     function toHexString(uint256 value) internal pure returns (string memory) {
  76 |     |         unchecked {
  77 |     |             return toHexString(value, Math.log256(value) + 1);
  78 |     |         }
  79 |     |     }
  80 |     | 
  81 |     |     /**
  82 |     |      * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.
  83 |     |      */
  84 |     |     function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {
  85 |     |         uint256 localValue = value;
  86 |     |         bytes memory buffer = new bytes(2 * length + 2);
  87 |     |         buffer[0] = "0";
  88 |     |         buffer[1] = "x";
  89 |     |         for (uint256 i = 2 * length + 1; i > 1; --i) {
  90 |     |             buffer[i] = HEX_DIGITS[localValue & 0xf];
  91 |     |             localValue >>= 4;
  92 |     |         }
  93 |     |         if (localValue != 0) {
  94 |     |             revert StringsInsufficientHexLength(value, length);
  95 |     |         }
  96 |     |         return string(buffer);
  97 |     |     }
  98 |     | 
  99 |     |     /**
 100 |     |      * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal
 101 |     |      * representation.
 102 |     |      */
 103 |     |     function toHexString(address addr) internal pure returns (string memory) {
 104 |     |         return toHexString(uint256(uint160(addr)), ADDRESS_LENGTH);
 105 |     |     }
 106 |     | 
 107 |     |     /**
 108 |     |      * @dev Converts an `address` with fixed length of 20 bytes to its checksummed ASCII `string` hexadecimal
 109 |     |      * representation, according to EIP-55.
 110 |     |      */
 111 |     |     function toChecksumHexString(address addr) internal pure returns (string memory) {
 112 |     |         bytes memory buffer = bytes(toHexString(addr));
 113 |     | 
 114 |     |         // hash the hex part of buffer (skip length + 2 bytes, length 40)
 115 |     |         uint256 hashValue;
 116 |     |         assembly ("memory-safe") {
 117 |     |             hashValue := shr(96, keccak256(add(buffer, 0x22), 40))
 118 |     |         }
 119 |     | 
 120 |     |         for (uint256 i = 41; i > 1; --i) {
 121 |     |             // possible values for buffer[i] are 48 (0) to 57 (9) and 97 (a) to 102 (f)
 122 |     |             if (hashValue & 0xf > 7 && uint8(buffer[i]) > 96) {
 123 |     |                 // case shift by xoring with 0x20
 124 |     |                 buffer[i] ^= 0x20;
 125 |     |             }
 126 |     |             hashValue >>= 4;
 127 |     |         }
 128 |     |         return string(buffer);
 129 |     |     }
 130 |     | 
 131 |     |     /**
 132 |     |      * @dev Returns true if the two strings are equal.
 133 |     |      */
 134 |     |     function equal(string memory a, string memory b) internal pure returns (bool) {
 135 |     |         return bytes(a).length == bytes(b).length && keccak256(bytes(a)) == keccak256(bytes(b));
 136 |     |     }
 137 |     | 
 138 |     |     /**
 139 |     |      * @dev Parse a decimal string and returns the value as a `uint256`.
 140 |     |      *
 141 |     |      * Requirements:
 142 |     |      * - The string must be formatted as `[0-9]*`
 143 |     |      * - The result must fit into an `uint256` type
 144 |     |      */
 145 |     |     function parseUint(string memory input) internal pure returns (uint256) {
 146 |     |         return parseUint(input, 0, bytes(input).length);
 147 |     |     }
 148 |     | 
 149 |     |     /**
 150 |     |      * @dev Variant of {parseUint-string} that parses a substring of `input` located between position `begin` (included) and
 151 |     |      * `end` (excluded).
 152 |     |      *
 153 |     |      * Requirements:
 154 |     |      * - The substring must be formatted as `[0-9]*`
 155 |     |      * - The result must fit into an `uint256` type
 156 |     |      */
 157 |     |     function parseUint(string memory input, uint256 begin, uint256 end) internal pure returns (uint256) {
 158 |     |         (bool success, uint256 value) = tryParseUint(input, begin, end);
 159 |     |         if (!success) revert StringsInvalidChar();
 160 |     |         return value;
 161 |     |     }
 162 |     | 
 163 |     |     /**
 164 |     |      * @dev Variant of {parseUint-string} that returns false if the parsing fails because of an invalid character.
 165 |     |      *
 166 |     |      * NOTE: This function will revert if the result does not fit in a `uint256`.
 167 |     |      */
 168 |     |     function tryParseUint(string memory input) internal pure returns (bool success, uint256 value) {
 169 |     |         return _tryParseUintUncheckedBounds(input, 0, bytes(input).length);
 170 |     |     }
 171 |     | 
 172 |     |     /**
 173 |     |      * @dev Variant of {parseUint-string-uint256-uint256} that returns false if the parsing fails because of an invalid
 174 |     |      * character.
 175 |     |      *
 176 |     |      * NOTE: This function will revert if the result does not fit in a `uint256`.
 177 |     |      */
 178 |     |     function tryParseUint(
 179 |     |         string memory input,
 180 |     |         uint256 begin,
 181 |     |         uint256 end
 182 |     |     ) internal pure returns (bool success, uint256 value) {
 183 |     |         if (end > bytes(input).length || begin > end) return (false, 0);
 184 |     |         return _tryParseUintUncheckedBounds(input, begin, end);
 185 |     |     }
 186 |     | 
 187 |     |     /**
 188 |     |      * @dev Implementation of {tryParseUint-string-uint256-uint256} that does not check bounds. Caller should make sure that
 189 |     |      * `begin <= end <= input.length`. Other inputs would result in undefined behavior.
 190 |     |      */
 191 |     |     function _tryParseUintUncheckedBounds(
 192 |     |         string memory input,
 193 |     |         uint256 begin,
 194 |     |         uint256 end
 195 |     |     ) private pure returns (bool success, uint256 value) {
 196 |     |         bytes memory buffer = bytes(input);
 197 |     | 
 198 |     |         uint256 result = 0;
 199 |     |         for (uint256 i = begin; i < end; ++i) {
 200 |     |             uint8 chr = _tryParseChr(bytes1(_unsafeReadBytesOffset(buffer, i)));
 201 |     |             if (chr > 9) return (false, 0);
 202 |     |             result *= 10;
 203 |     |             result += chr;
 204 |     |         }
 205 |     |         return (true, result);
 206 |     |     }
 207 |     | 
 208 |     |     /**
 209 |     |      * @dev Parse a decimal string and returns the value as a `int256`.
 210 |     |      *
 211 |     |      * Requirements:
 212 |     |      * - The string must be formatted as `[-+]?[0-9]*`
 213 |     |      * - The result must fit in an `int256` type.
 214 |     |      */
 215 |     |     function parseInt(string memory input) internal pure returns (int256) {
 216 |     |         return parseInt(input, 0, bytes(input).length);
 217 |     |     }
 218 |     | 
 219 |     |     /**
 220 |     |      * @dev Variant of {parseInt-string} that parses a substring of `input` located between position `begin` (included) and
 221 |     |      * `end` (excluded).
 222 |     |      *
 223 |     |      * Requirements:
 224 |     |      * - The substring must be formatted as `[-+]?[0-9]*`
 225 |     |      * - The result must fit in an `int256` type.
 226 |     |      */
 227 |     |     function parseInt(string memory input, uint256 begin, uint256 end) internal pure returns (int256) {
 228 |     |         (bool success, int256 value) = tryParseInt(input, begin, end);
 229 |     |         if (!success) revert StringsInvalidChar();
 230 |     |         return value;
 231 |     |     }
 232 |     | 
 233 |     |     /**
 234 |     |      * @dev Variant of {parseInt-string} that returns false if the parsing fails because of an invalid character or if
 235 |     |      * the result does not fit in a `int256`.
 236 |     |      *
 237 |     |      * NOTE: This function will revert if the absolute value of the result does not fit in a `uint256`.
 238 |     |      */
 239 |     |     function tryParseInt(string memory input) internal pure returns (bool success, int256 value) {
 240 |     |         return _tryParseIntUncheckedBounds(input, 0, bytes(input).length);
 241 |     |     }
 242 |     | 
 243 |     |     uint256 private constant ABS_MIN_INT256 = 2 ** 255;
 244 |     | 
 245 |     |     /**
 246 |     |      * @dev Variant of {parseInt-string-uint256-uint256} that returns false if the parsing fails because of an invalid
 247 |     |      * character or if the result does not fit in a `int256`.
 248 |     |      *
 249 |     |      * NOTE: This function will revert if the absolute value of the result does not fit in a `uint256`.
 250 |     |      */
 251 |     |     function tryParseInt(
 252 |     |         string memory input,
 253 |     |         uint256 begin,
 254 |     |         uint256 end
 255 |     |     ) internal pure returns (bool success, int256 value) {
 256 |     |         if (end > bytes(input).length || begin > end) return (false, 0);
 257 |     |         return _tryParseIntUncheckedBounds(input, begin, end);
 258 |     |     }
 259 |     | 
 260 |     |     /**
 261 |     |      * @dev Implementation of {tryParseInt-string-uint256-uint256} that does not check bounds. Caller should make sure that
 262 |     |      * `begin <= end <= input.length`. Other inputs would result in undefined behavior.
 263 |     |      */
 264 |     |     function _tryParseIntUncheckedBounds(
 265 |     |         string memory input,
 266 |     |         uint256 begin,
 267 |     |         uint256 end
 268 |     |     ) private pure returns (bool success, int256 value) {
 269 |     |         bytes memory buffer = bytes(input);
 270 |     | 
 271 |     |         // Check presence of a negative sign.
 272 |     |         bytes1 sign = begin == end ? bytes1(0) : bytes1(_unsafeReadBytesOffset(buffer, begin)); // don't do out-of-bound (possibly unsafe) read if sub-string is empty
 273 |     |         bool positiveSign = sign == bytes1("+");
 274 |     |         bool negativeSign = sign == bytes1("-");
 275 |     |         uint256 offset = (positiveSign || negativeSign).toUint();
 276 |     | 
 277 |     |         (bool absSuccess, uint256 absValue) = tryParseUint(input, begin + offset, end);
 278 |     | 
 279 |     |         if (absSuccess && absValue < ABS_MIN_INT256) {
 280 |     |             return (true, negativeSign ? -int256(absValue) : int256(absValue));
 281 |     |         } else if (absSuccess && negativeSign && absValue == ABS_MIN_INT256) {
 282 |     |             return (true, type(int256).min);
 283 |     |         } else return (false, 0);
 284 |     |     }
 285 |     | 
 286 |     |     /**
 287 |     |      * @dev Parse a hexadecimal string (with or without "0x" prefix), and returns the value as a `uint256`.
 288 |     |      *
 289 |     |      * Requirements:
 290 |     |      * - The string must be formatted as `(0x)?[0-9a-fA-F]*`
 291 |     |      * - The result must fit in an `uint256` type.
 292 |     |      */
 293 |     |     function parseHexUint(string memory input) internal pure returns (uint256) {
 294 |     |         return parseHexUint(input, 0, bytes(input).length);
 295 |     |     }
 296 |     | 
 297 |     |     /**
 298 |     |      * @dev Variant of {parseHexUint-string} that parses a substring of `input` located between position `begin` (included) and
 299 |     |      * `end` (excluded).
 300 |     |      *
 301 |     |      * Requirements:
 302 |     |      * - The substring must be formatted as `(0x)?[0-9a-fA-F]*`
 303 |     |      * - The result must fit in an `uint256` type.
 304 |     |      */
 305 |     |     function parseHexUint(string memory input, uint256 begin, uint256 end) internal pure returns (uint256) {
 306 |     |         (bool success, uint256 value) = tryParseHexUint(input, begin, end);
 307 |     |         if (!success) revert StringsInvalidChar();
 308 |     |         return value;
 309 |     |     }
 310 |     | 
 311 |     |     /**
 312 |     |      * @dev Variant of {parseHexUint-string} that returns false if the parsing fails because of an invalid character.
 313 |     |      *
 314 |     |      * NOTE: This function will revert if the result does not fit in a `uint256`.
 315 |     |      */
 316 |     |     function tryParseHexUint(string memory input) internal pure returns (bool success, uint256 value) {
 317 |     |         return _tryParseHexUintUncheckedBounds(input, 0, bytes(input).length);
 318 |     |     }
 319 |     | 
 320 |     |     /**
 321 |     |      * @dev Variant of {parseHexUint-string-uint256-uint256} that returns false if the parsing fails because of an
 322 |     |      * invalid character.
 323 |     |      *
 324 |     |      * NOTE: This function will revert if the result does not fit in a `uint256`.
 325 |     |      */
 326 |     |     function tryParseHexUint(
 327 |     |         string memory input,
 328 |     |         uint256 begin,
 329 |     |         uint256 end
 330 |     |     ) internal pure returns (bool success, uint256 value) {
 331 |     |         if (end > bytes(input).length || begin > end) return (false, 0);
 332 |     |         return _tryParseHexUintUncheckedBounds(input, begin, end);
 333 |     |     }
 334 |     | 
 335 |     |     /**
 336 |     |      * @dev Implementation of {tryParseHexUint-string-uint256-uint256} that does not check bounds. Caller should make sure that
 337 |     |      * `begin <= end <= input.length`. Other inputs would result in undefined behavior.
 338 |     |      */
 339 |     |     function _tryParseHexUintUncheckedBounds(
 340 |     |         string memory input,
 341 |     |         uint256 begin,
 342 |     |         uint256 end
 343 |     |     ) private pure returns (bool success, uint256 value) {
 344 |     |         bytes memory buffer = bytes(input);
 345 |     | 
 346 |     |         // skip 0x prefix if present
 347 |     |         bool hasPrefix = (end > begin + 1) && bytes2(_unsafeReadBytesOffset(buffer, begin)) == bytes2("0x"); // don't do out-of-bound (possibly unsafe) read if sub-string is empty
 348 |     |         uint256 offset = hasPrefix.toUint() * 2;
 349 |     | 
 350 |     |         uint256 result = 0;
 351 |     |         for (uint256 i = begin + offset; i < end; ++i) {
 352 |     |             uint8 chr = _tryParseChr(bytes1(_unsafeReadBytesOffset(buffer, i)));
 353 |     |             if (chr > 15) return (false, 0);
 354 |     |             result *= 16;
 355 |     |             unchecked {
 356 |     |                 // Multiplying by 16 is equivalent to a shift of 4 bits (with additional overflow check).
 357 |     |                 // This guarantees that adding a value < 16 will not cause an overflow, hence the unchecked.
 358 |     |                 result += chr;
 359 |     |             }
 360 |     |         }
 361 |     |         return (true, result);
 362 |     |     }
 363 |     | 
 364 |     |     /**
 365 |     |      * @dev Parse a hexadecimal string (with or without "0x" prefix), and returns the value as an `address`.
 366 |     |      *
 367 |     |      * Requirements:
 368 |     |      * - The string must be formatted as `(0x)?[0-9a-fA-F]{40}`
 369 |     |      */
 370 |     |     function parseAddress(string memory input) internal pure returns (address) {
 371 |     |         return parseAddress(input, 0, bytes(input).length);
 372 |     |     }
 373 |     | 
 374 |     |     /**
 375 |     |      * @dev Variant of {parseAddress-string} that parses a substring of `input` located between position `begin` (included) and
 376 |     |      * `end` (excluded).
 377 |     |      *
 378 |     |      * Requirements:
 379 |     |      * - The substring must be formatted as `(0x)?[0-9a-fA-F]{40}`
 380 |     |      */
 381 |     |     function parseAddress(string memory input, uint256 begin, uint256 end) internal pure returns (address) {
 382 |     |         (bool success, address value) = tryParseAddress(input, begin, end);
 383 |     |         if (!success) revert StringsInvalidAddressFormat();
 384 |     |         return value;
 385 |     |     }
 386 |     | 
 387 |     |     /**
 388 |     |      * @dev Variant of {parseAddress-string} that returns false if the parsing fails because the input is not a properly
 389 |     |      * formatted address. See {parseAddress-string} requirements.
 390 |     |      */
 391 |     |     function tryParseAddress(string memory input) internal pure returns (bool success, address value) {
 392 |     |         return tryParseAddress(input, 0, bytes(input).length);
 393 |     |     }
 394 |     | 
 395 |     |     /**
 396 |     |      * @dev Variant of {parseAddress-string-uint256-uint256} that returns false if the parsing fails because input is not a properly
 397 |     |      * formatted address. See {parseAddress-string-uint256-uint256} requirements.
 398 |     |      */
 399 |     |     function tryParseAddress(
 400 |     |         string memory input,
 401 |     |         uint256 begin,
 402 |     |         uint256 end
 403 |     |     ) internal pure returns (bool success, address value) {
 404 |     |         if (end > bytes(input).length || begin > end) return (false, address(0));
 405 |     | 
 406 |     |         bool hasPrefix = (end > begin + 1) && bytes2(_unsafeReadBytesOffset(bytes(input), begin)) == bytes2("0x"); // don't do out-of-bound (possibly unsafe) read if sub-string is empty
 407 |     |         uint256 expectedLength = 40 + hasPrefix.toUint() * 2;
 408 |     | 
 409 |     |         // check that input is the correct length
 410 |     |         if (end - begin == expectedLength) {
 411 |     |             // length guarantees that this does not overflow, and value is at most type(uint160).max
 412 |     |             (bool s, uint256 v) = _tryParseHexUintUncheckedBounds(input, begin, end);
 413 |     |             return (s, address(uint160(v)));
 414 |     |         } else {
 415 |     |             return (false, address(0));
 416 |     |         }
 417 |     |     }
 418 |     | 
 419 |     |     function _tryParseChr(bytes1 chr) private pure returns (uint8) {
 420 |     |         uint8 value = uint8(chr);
 421 |     | 
 422 |     |         // Try to parse `chr`:
 423 |     |         // - Case 1: [0-9]
 424 |     |         // - Case 2: [a-f]
 425 |     |         // - Case 3: [A-F]
 426 |     |         // - otherwise not supported
 427 |     |         unchecked {
 428 |     |             if (value > 47 && value < 58) value -= 48;
 429 |     |             else if (value > 96 && value < 103) value -= 87;
 430 |     |             else if (value > 64 && value < 71) value -= 55;
 431 |     |             else return type(uint8).max;
 432 |     |         }
 433 |     | 
 434 |     |         return value;
 435 |     |     }
 436 |     | 
 437 |     |     /**
 438 |     |      * @dev Escape special characters in JSON strings. This can be useful to prevent JSON injection in NFT metadata.
 439 |     |      *
 440 |     |      * WARNING: This function should only be used in double quoted JSON strings. Single quotes are not escaped.
 441 |     |      *
 442 |     |      * NOTE: This function escapes all unicode characters, and not just the ones in ranges defined in section 2.5 of
 443 |     |      * RFC-4627 (U+0000 to U+001F, U+0022 and U+005C). ECMAScript's `JSON.parse` does recover escaped unicode
 444 |     |      * characters that are not in this range, but other tooling may provide different results.
 445 |     |      */
 446 |     |     function escapeJSON(string memory input) internal pure returns (string memory) {
 447 |     |         bytes memory buffer = bytes(input);
 448 |     |         bytes memory output = new bytes(2 * buffer.length); // worst case scenario
 449 |     |         uint256 outputLength = 0;
 450 |     | 
 451 |     |         for (uint256 i; i < buffer.length; ++i) {
 452 |     |             bytes1 char = bytes1(_unsafeReadBytesOffset(buffer, i));
 453 |     |             if (((SPECIAL_CHARS_LOOKUP & (1 << uint8(char))) != 0)) {
 454 |     |                 output[outputLength++] = "\\";
 455 |     |                 if (char == 0x08) output[outputLength++] = "b";
 456 |     |                 else if (char == 0x09) output[outputLength++] = "t";
 457 |     |                 else if (char == 0x0a) output[outputLength++] = "n";
 458 |     |                 else if (char == 0x0c) output[outputLength++] = "f";
 459 |     |                 else if (char == 0x0d) output[outputLength++] = "r";
 460 |     |                 else if (char == 0x5c) output[outputLength++] = "\\";
 461 |     |                 else if (char == 0x22) {
 462 |     |                     // solhint-disable-next-line quotes
 463 |     |                     output[outputLength++] = '"';
 464 |     |                 }
 465 |     |             } else {
 466 |     |                 output[outputLength++] = char;
 467 |     |             }
 468 |     |         }
 469 |     |         // write the actual length and deallocate unused memory
 470 |     |         assembly ("memory-safe") {
 471 |     |             mstore(output, outputLength)
 472 |     |             mstore(0x40, add(output, shl(5, shr(5, add(outputLength, 63)))))
 473 |     |         }
 474 |     | 
 475 |     |         return string(output);
 476 |     |     }
 477 |     | 
 478 |     |     /**
 479 |     |      * @dev Reads a bytes32 from a bytes array without bounds checking.
 480 |     |      *
 481 |     |      * NOTE: making this function internal would mean it could be used with memory unsafe offset, and marking the
 482 |     |      * assembly block as such would prevent some optimizations.
 483 |     |      */
 484 |     |     function _unsafeReadBytesOffset(bytes memory buffer, uint256 offset) private pure returns (bytes32 value) {
 485 |     |         // This is not memory safe in the general case, but all calls to this private function are within bounds.
 486 |     |         assembly ("memory-safe") {
 487 |     |             value := mload(add(add(buffer, 0x20), offset))
 488 |     |         }
 489 |     |     }
 490 |     | }
 491 |     | 

/home/phantom/Documents/azemora/azemora-contracts/lib/openzeppelin-contracts/contracts/utils/cryptography/ECDSA.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 | *   | // OpenZeppelin Contracts (last updated v5.1.0) (utils/cryptography/ECDSA.sol)
   3 |     | 
   4 |     | pragma solidity ^0.8.20;
   5 |     | 
   6 |     | /**
   7 | *   |  * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.
   8 |     |  *
   9 | *   |  * These functions can be used to verify that a message was signed by the holder
  10 |     |  * of the private keys of a given address.
  11 |     |  */
  12 |     | library ECDSA {
  13 |     |     enum RecoverError {
  14 |     |         NoError,
  15 |     |         InvalidSignature,
  16 |     |         InvalidSignatureLength,
  17 |     |         InvalidSignatureS
  18 |     |     }
  19 |     | 
  20 |     |     /**
  21 |     |      * @dev The signature derives the `address(0)`.
  22 |     |      */
  23 |     |     error ECDSAInvalidSignature();
  24 |     | 
  25 |     |     /**
  26 |     |      * @dev The signature has an invalid length.
  27 |     |      */
  28 |     |     error ECDSAInvalidSignatureLength(uint256 length);
  29 |     | 
  30 |     |     /**
  31 |     |      * @dev The signature has an S value that is in the upper half order.
  32 |     |      */
  33 |     |     error ECDSAInvalidSignatureS(bytes32 s);
  34 |     | 
  35 |     |     /**
  36 |     |      * @dev Returns the address that signed a hashed message (`hash`) with `signature` or an error. This will not
  37 |     |      * return address(0) without also returning an error description. Errors are documented using an enum (error type)
  38 |     |      * and a bytes32 providing additional information about the error.
  39 |     |      *
  40 |     |      * If no error is returned, then the address can be used for verification purposes.
  41 |     |      *
  42 |     |      * The `ecrecover` EVM precompile allows for malleable (non-unique) signatures:
  43 |     |      * this function rejects them by requiring the `s` value to be in the lower
  44 |     |      * half order, and the `v` value to be either 27 or 28.
  45 |     |      *
  46 |     |      * IMPORTANT: `hash` _must_ be the result of a hash operation for the
  47 |     |      * verification to be secure: it is possible to craft signatures that
  48 |     |      * recover to arbitrary addresses for non-hashed data. A safe way to ensure
  49 |     |      * this is by receiving a hash of the original message (which may otherwise
  50 |     |      * be too long), and then calling {MessageHashUtils-toEthSignedMessageHash} on it.
  51 |     |      *
  52 |     |      * Documentation for signature generation:
  53 |     |      * - with https://web3js.readthedocs.io/en/v1.3.4/web3-eth-accounts.html#sign[Web3.js]
  54 |     |      * - with https://docs.ethers.io/v5/api/signer/#Signer-signMessage[ethers]
  55 |     |      */
  56 |     |     function tryRecover(
  57 |     |         bytes32 hash,
  58 |     |         bytes memory signature
  59 |     |     ) internal pure returns (address recovered, RecoverError err, bytes32 errArg) {
  60 |     |         if (signature.length == 65) {
  61 |     |             bytes32 r;
  62 |     |             bytes32 s;
  63 |     |             uint8 v;
  64 |     |             // ecrecover takes the signature parameters, and the only way to get them
  65 |     |             // currently is to use assembly.
  66 |     |             assembly ("memory-safe") {
  67 |     |                 r := mload(add(signature, 0x20))
  68 |     |                 s := mload(add(signature, 0x40))
  69 |     |                 v := byte(0, mload(add(signature, 0x60)))
  70 |     |             }
  71 |     |             return tryRecover(hash, v, r, s);
  72 |     |         } else {
  73 |     |             return (address(0), RecoverError.InvalidSignatureLength, bytes32(signature.length));
  74 |     |         }
  75 |     |     }
  76 |     | 
  77 |     |     /**
  78 |     |      * @dev Returns the address that signed a hashed message (`hash`) with
  79 |     |      * `signature`. This address can then be used for verification purposes.
  80 |     |      *
  81 |     |      * The `ecrecover` EVM precompile allows for malleable (non-unique) signatures:
  82 |     |      * this function rejects them by requiring the `s` value to be in the lower
  83 |     |      * half order, and the `v` value to be either 27 or 28.
  84 |     |      *
  85 |     |      * IMPORTANT: `hash` _must_ be the result of a hash operation for the
  86 |     |      * verification to be secure: it is possible to craft signatures that
  87 |     |      * recover to arbitrary addresses for non-hashed data. A safe way to ensure
  88 |     |      * this is by receiving a hash of the original message (which may otherwise
  89 |     |      * be too long), and then calling {MessageHashUtils-toEthSignedMessageHash} on it.
  90 |     |      */
  91 |     |     function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {
  92 |     |         (address recovered, RecoverError error, bytes32 errorArg) = tryRecover(hash, signature);
  93 |     |         _throwError(error, errorArg);
  94 |     |         return recovered;
  95 |     |     }
  96 |     | 
  97 |     |     /**
  98 |     |      * @dev Overload of {ECDSA-tryRecover} that receives the `r` and `vs` short-signature fields separately.
  99 |     |      *
 100 |     |      * See https://eips.ethereum.org/EIPS/eip-2098[ERC-2098 short signatures]
 101 |     |      */
 102 |     |     function tryRecover(
 103 |     |         bytes32 hash,
 104 |     |         bytes32 r,
 105 |     |         bytes32 vs
 106 |     |     ) internal pure returns (address recovered, RecoverError err, bytes32 errArg) {
 107 |     |         unchecked {
 108 |     |             bytes32 s = vs & bytes32(0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);
 109 |     |             // We do not check for an overflow here since the shift operation results in 0 or 1.
 110 |     |             uint8 v = uint8((uint256(vs) >> 255) + 27);
 111 |     |             return tryRecover(hash, v, r, s);
 112 |     |         }
 113 |     |     }
 114 |     | 
 115 |     |     /**
 116 |     |      * @dev Overload of {ECDSA-recover} that receives the `r and `vs` short-signature fields separately.
 117 |     |      */
 118 |     |     function recover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address) {
 119 |     |         (address recovered, RecoverError error, bytes32 errorArg) = tryRecover(hash, r, vs);
 120 |     |         _throwError(error, errorArg);
 121 |     |         return recovered;
 122 |     |     }
 123 |     | 
 124 |     |     /**
 125 |     |      * @dev Overload of {ECDSA-tryRecover} that receives the `v`,
 126 |     |      * `r` and `s` signature fields separately.
 127 |     |      */
 128 |     |     function tryRecover(
 129 |     |         bytes32 hash,
 130 |     |         uint8 v,
 131 |     |         bytes32 r,
 132 |     |         bytes32 s
 133 |     |     ) internal pure returns (address recovered, RecoverError err, bytes32 errArg) {
 134 |     |         // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature
 135 |     |         // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines
 136 |     |         // the valid range for s in (301): 0 < s < secp256k1n  2 + 1, and for v in (302): v  {27, 28}. Most
 137 |     |         // signatures from current libraries generate a unique signature with an s-value in the lower half order.
 138 |     |         //
 139 |     |         // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value
 140 |     |         // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or
 141 |     |         // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept
 142 |     |         // these malleable signatures as well.
 143 |     |         if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {
 144 |     |             return (address(0), RecoverError.InvalidSignatureS, s);
 145 |     |         }
 146 |     | 
 147 |     |         // If the signature is valid (and not malleable), return the signer address
 148 |     |         address signer = ecrecover(hash, v, r, s);
 149 |     |         if (signer == address(0)) {
 150 |     |             return (address(0), RecoverError.InvalidSignature, bytes32(0));
 151 |     |         }
 152 |     | 
 153 |     |         return (signer, RecoverError.NoError, bytes32(0));
 154 |     |     }
 155 |     | 
 156 |     |     /**
 157 |     |      * @dev Overload of {ECDSA-recover} that receives the `v`,
 158 |     |      * `r` and `s` signature fields separately.
 159 |     |      */
 160 |     |     function recover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal pure returns (address) {
 161 |     |         (address recovered, RecoverError error, bytes32 errorArg) = tryRecover(hash, v, r, s);
 162 |     |         _throwError(error, errorArg);
 163 |     |         return recovered;
 164 |     |     }
 165 |     | 
 166 |     |     /**
 167 |     |      * @dev Optionally reverts with the corresponding custom error according to the `error` argument provided.
 168 |     |      */
 169 |     |     function _throwError(RecoverError error, bytes32 errorArg) private pure {
 170 |     |         if (error == RecoverError.NoError) {
 171 |     |             return; // no error: do nothing
 172 |     |         } else if (error == RecoverError.InvalidSignature) {
 173 |     |             revert ECDSAInvalidSignature();
 174 |     |         } else if (error == RecoverError.InvalidSignatureLength) {
 175 |     |             revert ECDSAInvalidSignatureLength(uint256(errorArg));
 176 |     |         } else if (error == RecoverError.InvalidSignatureS) {
 177 |     |             revert ECDSAInvalidSignatureS(errorArg);
 178 |     |         }
 179 |     |     }
 180 |     | }
 181 |     | 

/home/phantom/Documents/azemora/azemora-contracts/lib/openzeppelin-contracts/contracts/utils/cryptography/MessageHashUtils.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | // OpenZeppelin Contracts (last updated v5.3.0) (utils/cryptography/MessageHashUtils.sol)
   3 |     | 
   4 |     | pragma solidity ^0.8.20;
   5 |     | 
   6 |     | import {Strings} from "../Strings.sol";
   7 |     | 
   8 |     | /**
   9 |     |  * @dev Signature message hash utilities for producing digests to be consumed by {ECDSA} recovery or signing.
  10 |     |  *
  11 |     |  * The library provides methods for generating a hash of a message that conforms to the
  12 |     |  * https://eips.ethereum.org/EIPS/eip-191[ERC-191] and https://eips.ethereum.org/EIPS/eip-712[EIP 712]
  13 |     |  * specifications.
  14 |     |  */
  15 |     | library MessageHashUtils {
  16 |     |     /**
  17 | *   |      * @dev Returns the keccak256 digest of an ERC-191 signed data with version
  18 |     |      * `0x45` (`personal_sign` messages).
  19 |     |      *
  20 |     |      * The digest is calculated by prefixing a bytes32 `messageHash` with
  21 |     |      * `"\x19Ethereum Signed Message:\n32"` and hashing the result. It corresponds with the
  22 |     |      * hash signed when using the https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_sign[`eth_sign`] JSON-RPC method.
  23 |     |      *
  24 | *   |      * NOTE: The `messageHash` parameter is intended to be the result of hashing a raw message with
  25 | *   |      * keccak256, although any bytes32 value can be safely used because the final digest will
  26 | *   |      * be re-hashed.
  27 | *   |      *
  28 |     |      * See {ECDSA-recover}.
  29 |     |      */
  30 |     |     function toEthSignedMessageHash(bytes32 messageHash) internal pure returns (bytes32 digest) {
  31 |     |         assembly ("memory-safe") {
  32 |     |             mstore(0x00, "\x19Ethereum Signed Message:\n32") // 32 is the bytes-length of messageHash
  33 |     |             mstore(0x1c, messageHash) // 0x1c (28) is the length of the prefix
  34 | *   |             digest := keccak256(0x00, 0x3c) // 0x3c is the length of the prefix (0x1c) + messageHash (0x20)
  35 | *   |         }
  36 | *   |     }
  37 |     | 
  38 |     |     /**
  39 |     |      * @dev Returns the keccak256 digest of an ERC-191 signed data with version
  40 |     |      * `0x45` (`personal_sign` messages).
  41 |     |      *
  42 |     |      * The digest is calculated by prefixing an arbitrary `message` with
  43 |     |      * `"\x19Ethereum Signed Message:\n" + len(message)` and hashing the result. It corresponds with the
  44 |     |      * hash signed when using the https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_sign[`eth_sign`] JSON-RPC method.
  45 |     |      *
  46 |     |      * See {ECDSA-recover}.
  47 |     |      */
  48 |     |     function toEthSignedMessageHash(bytes memory message) internal pure returns (bytes32) {
  49 |     |         return
  50 |     |             keccak256(bytes.concat("\x19Ethereum Signed Message:\n", bytes(Strings.toString(message.length)), message));
  51 |     |     }
  52 |     | 
  53 |     |     /**
  54 |     |      * @dev Returns the keccak256 digest of an ERC-191 signed data with version
  55 |     |      * `0x00` (data with intended validator).
  56 |     |      *
  57 |     |      * The digest is calculated by prefixing an arbitrary `data` with `"\x19\x00"` and the intended
  58 |     |      * `validator` address. Then hashing the result.
  59 |     |      *
  60 |     |      * See {ECDSA-recover}.
  61 |     |      */
  62 |     |     function toDataWithIntendedValidatorHash(address validator, bytes memory data) internal pure returns (bytes32) {
  63 |     |         return keccak256(abi.encodePacked(hex"19_00", validator, data));
  64 |     |     }
  65 |     | 
  66 |     |     /**
  67 |     |      * @dev Variant of {toDataWithIntendedValidatorHash-address-bytes} optimized for cases where `data` is a bytes32.
  68 |     |      */
  69 |     |     function toDataWithIntendedValidatorHash(
  70 |     |         address validator,
  71 |     |         bytes32 messageHash
  72 |     |     ) internal pure returns (bytes32 digest) {
  73 |     |         assembly ("memory-safe") {
  74 |     |             mstore(0x00, hex"19_00")
  75 |     |             mstore(0x02, shl(96, validator))
  76 |     |             mstore(0x16, messageHash)
  77 |     |             digest := keccak256(0x00, 0x36)
  78 |     |         }
  79 |     |     }
  80 |     | 
  81 |     |     /**
  82 |     |      * @dev Returns the keccak256 digest of an EIP-712 typed data (ERC-191 version `0x01`).
  83 |     |      *
  84 |     |      * The digest is calculated from a `domainSeparator` and a `structHash`, by prefixing them with
  85 |     |      * `\x19\x01` and hashing the result. It corresponds to the hash signed by the
  86 |     |      * https://eips.ethereum.org/EIPS/eip-712[`eth_signTypedData`] JSON-RPC method as part of EIP-712.
  87 |     |      *
  88 |     |      * See {ECDSA-recover}.
  89 |     |      */
  90 |     |     function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32 digest) {
  91 |     |         assembly ("memory-safe") {
  92 |     |             let ptr := mload(0x40)
  93 |     |             mstore(ptr, hex"19_01")
  94 |     |             mstore(add(ptr, 0x02), domainSeparator)
  95 |     |             mstore(add(ptr, 0x22), structHash)
  96 |     |             digest := keccak256(ptr, 0x42)
  97 |     |         }
  98 |     |     }
  99 |     | }
 100 |     | 

/home/phantom/Documents/azemora/azemora-contracts/lib/openzeppelin-contracts/contracts/utils/cryptography/SignatureChecker.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | // OpenZeppelin Contracts (last updated v5.1.0) (utils/cryptography/SignatureChecker.sol)
   3 |     | 
   4 |     | pragma solidity ^0.8.24;
   5 |     | 
   6 |     | import {ECDSA} from "./ECDSA.sol";
   7 |     | import {IERC1271} from "../../interfaces/IERC1271.sol";
   8 |     | import {IERC7913SignatureVerifier} from "../../interfaces/IERC7913.sol";
   9 |     | import {Bytes} from "../../utils/Bytes.sol";
  10 |     | 
  11 |     | /**
  12 |     |  * @dev Signature verification helper that can be used instead of `ECDSA.recover` to seamlessly support:
  13 |     |  *
  14 |     |  * * ECDSA signatures from externally owned accounts (EOAs)
  15 |     |  * * ERC-1271 signatures from smart contract wallets like Argent and Safe Wallet (previously Gnosis Safe)
  16 |     |  * * ERC-7913 signatures from keys that do not have an Ethereum address of their own
  17 |     |  *
  18 | *   |  * See https://eips.ethereum.org/EIPS/eip-1271[ERC-1271] and https://eips.ethereum.org/EIPS/eip-7913[ERC-7913].
  19 |     |  */
  20 |     | library SignatureChecker {
  21 |     |     using Bytes for bytes;
  22 |     | 
  23 |     |     /**
  24 |     |      * @dev Checks if a signature is valid for a given signer and data hash. If the signer has code, the
  25 |     |      * signature is validated against it using ERC-1271, otherwise it's validated using `ECDSA.recover`.
  26 |     |      *
  27 |     |      * NOTE: Unlike ECDSA signatures, contract signatures are revocable, and the outcome of this function can thus
  28 |     |      * change through time. It could return true at block N and false at block N+1 (or the opposite).
  29 |     |      *
  30 | *   |      * NOTE: For an extended version of this function that supports ERC-7913 signatures, see {isValidSignatureNow-bytes-bytes32-bytes-}.
  31 |     |      */
  32 | *   |     function isValidSignatureNow(address signer, bytes32 hash, bytes memory signature) internal view returns (bool) {
  33 |     |         if (signer.code.length == 0) {
  34 | *   |             (address recovered, ECDSA.RecoverError err, ) = ECDSA.tryRecover(hash, signature);
  35 | *   |             return err == ECDSA.RecoverError.NoError && recovered == signer;
  36 |     |         } else {
  37 | *   |             return isValidERC1271SignatureNow(signer, hash, signature);
  38 |     |         }
  39 |     |     }
  40 |     | 
  41 |     |     /**
  42 |     |      * @dev Checks if a signature is valid for a given signer and data hash. The signature is validated
  43 |     |      * against the signer smart contract using ERC-1271.
  44 |     |      *
  45 |     |      * NOTE: Unlike ECDSA signatures, contract signatures are revocable, and the outcome of this function can thus
  46 | *   |      * change through time. It could return true at block N and false at block N+1 (or the opposite).
  47 |     |      */
  48 | *   |     function isValidERC1271SignatureNow(
  49 | *   |         address signer,
  50 | *   |         bytes32 hash,
  51 |     |         bytes memory signature
  52 | *   |     ) internal view returns (bool) {
  53 | *   |         (bool success, bytes memory result) = signer.staticcall(
  54 |     |             abi.encodeCall(IERC1271.isValidSignature, (hash, signature))
  55 |     |         );
  56 |     |         return (success &&
  57 |     |             result.length >= 32 &&
  58 |     |             abi.decode(result, (bytes32)) == bytes32(IERC1271.isValidSignature.selector));
  59 |     |     }
  60 |     | 
  61 |     |     /**
  62 |     |      * @dev Verifies a signature for a given ERC-7913 signer and hash.
  63 |     |      *
  64 |     |      * The signer is a `bytes` object that is the concatenation of an address and optionally a key:
  65 |     |      * `verifier || key`. A signer must be at least 20 bytes long.
  66 |     |      *
  67 |     |      * Verification is done as follows:
  68 |     |      *
  69 |     |      * * If `signer.length < 20`: verification fails
  70 |     |      * * If `signer.length == 20`: verification is done using {isValidSignatureNow}
  71 |     |      * * Otherwise: verification is done using {IERC7913SignatureVerifier}
  72 |     |      *
  73 |     |      * NOTE: Unlike ECDSA signatures, contract signatures are revocable, and the outcome of this function can thus
  74 |     |      * change through time. It could return true at block N and false at block N+1 (or the opposite).
  75 |     |      */
  76 |     |     function isValidSignatureNow(
  77 |     |         bytes memory signer,
  78 |     |         bytes32 hash,
  79 |     |         bytes memory signature
  80 |     |     ) internal view returns (bool) {
  81 |     |         if (signer.length < 20) {
  82 |     |             return false;
  83 |     |         } else if (signer.length == 20) {
  84 |     |             return isValidSignatureNow(address(bytes20(signer)), hash, signature);
  85 |     |         } else {
  86 |     |             (bool success, bytes memory result) = address(bytes20(signer)).staticcall(
  87 |     |                 abi.encodeCall(IERC7913SignatureVerifier.verify, (signer.slice(20), hash, signature))
  88 |     |             );
  89 |     |             return (success &&
  90 |     |                 result.length >= 32 &&
  91 |     |                 abi.decode(result, (bytes32)) == bytes32(IERC7913SignatureVerifier.verify.selector));
  92 |     |         }
  93 |     |     }
  94 |     | 
  95 |     |     /**
  96 |     |      * @dev Verifies multiple ERC-7913 `signatures` for a given `hash` using a set of `signers`.
  97 |     |      * Returns `false` if the number of signers and signatures is not the same.
  98 |     |      *
  99 |     |      * The signers should be ordered by their `keccak256` hash to ensure efficient duplication check. Unordered
 100 |     |      * signers are supported, but the uniqueness check will be more expensive.
 101 |     |      *
 102 |     |      * NOTE: Unlike ECDSA signatures, contract signatures are revocable, and the outcome of this function can thus
 103 |     |      * change through time. It could return true at block N and false at block N+1 (or the opposite).
 104 |     |      */
 105 |     |     function areValidSignaturesNow(
 106 |     |         bytes32 hash,
 107 |     |         bytes[] memory signers,
 108 |     |         bytes[] memory signatures
 109 |     |     ) internal view returns (bool) {
 110 |     |         if (signers.length != signatures.length) return false;
 111 |     | 
 112 |     |         bytes32 lastId = bytes32(0);
 113 |     | 
 114 |     |         for (uint256 i = 0; i < signers.length; ++i) {
 115 |     |             bytes memory signer = signers[i];
 116 |     | 
 117 |     |             // If one of the signatures is invalid, reject the batch
 118 |     |             if (!isValidSignatureNow(signer, hash, signatures[i])) return false;
 119 |     | 
 120 |     |             bytes32 id = keccak256(signer);
 121 |     |             // If the current signer ID is greater than all previous IDs, then this is a new signer.
 122 |     |             if (lastId < id) {
 123 |     |                 lastId = id;
 124 |     |             } else {
 125 |     |                 // If this signer id is not greater than all the previous ones, verify that it is not a duplicate of a previous one
 126 |     |                 // This loop is never executed if the signers are ordered by id.
 127 |     |                 for (uint256 j = 0; j < i; ++j) {
 128 |     |                     if (id == keccak256(signers[j])) return false;
 129 |     |                 }
 130 |     |             }
 131 |     |         }
 132 |     | 
 133 |     |         return true;
 134 |     |     }
 135 |     | }
 136 |     | 

/home/phantom/Documents/azemora/azemora-contracts/lib/openzeppelin-contracts/contracts/utils/introspection/IERC165.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | // OpenZeppelin Contracts (last updated v5.1.0) (utils/introspection/IERC165.sol)
  3 |     | 
  4 |     | pragma solidity >=0.4.16;
  5 |     | 
  6 |     | /**
  7 |     |  * @dev Interface of the ERC-165 standard, as defined in the
  8 |     |  * https://eips.ethereum.org/EIPS/eip-165[ERC].
  9 |     |  *
 10 |     |  * Implementers can declare support of contract interfaces, which can then be
 11 |     |  * queried by others ({ERC165Checker}).
 12 |     |  *
 13 |     |  * For an implementation, see {ERC165}.
 14 |     |  */
 15 |     | interface IERC165 {
 16 |     |     /**
 17 |     |      * @dev Returns true if this contract implements the interface defined by
 18 |     |      * `interfaceId`. See the corresponding
 19 |     |      * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[ERC section]
 20 |     |      * to learn more about how these ids are created.
 21 |     |      *
 22 |     |      * This function call must use less than 30 000 gas.
 23 |     |      */
 24 |     |     function supportsInterface(bytes4 interfaceId) external view returns (bool);
 25 |     | }
 26 | *   | 

/home/phantom/Documents/azemora/azemora-contracts/lib/openzeppelin-contracts/contracts/utils/math/Math.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | // OpenZeppelin Contracts (last updated v5.3.0) (utils/math/Math.sol)
   3 |     | 
   4 |     | pragma solidity ^0.8.20;
   5 |     | 
   6 |     | import {Panic} from "../Panic.sol";
   7 |     | import {SafeCast} from "./SafeCast.sol";
   8 |     | 
   9 |     | /**
  10 |     |  * @dev Standard math utilities missing in the Solidity language.
  11 |     |  */
  12 |     | library Math {
  13 |     |     enum Rounding {
  14 |     |         Floor, // Toward negative infinity
  15 |     |         Ceil, // Toward positive infinity
  16 |     |         Trunc, // Toward zero
  17 |     |         Expand // Away from zero
  18 |     |     }
  19 |     | 
  20 |     |     /**
  21 |     |      * @dev Return the 512-bit addition of two uint256.
  22 |     |      *
  23 |     |      * The result is stored in two 256 variables such that sum = high * 2 + low.
  24 |     |      */
  25 |     |     function add512(uint256 a, uint256 b) internal pure returns (uint256 high, uint256 low) {
  26 |     |         assembly ("memory-safe") {
  27 |     |             low := add(a, b)
  28 |     |             high := lt(low, a)
  29 |     |         }
  30 |     |     }
  31 |     | 
  32 |     |     /**
  33 |     |      * @dev Return the 512-bit multiplication of two uint256.
  34 |     |      *
  35 |     |      * The result is stored in two 256 variables such that product = high * 2 + low.
  36 |     |      */
  37 |     |     function mul512(uint256 a, uint256 b) internal pure returns (uint256 high, uint256 low) {
  38 |     |         // 512-bit multiply [high low] = x * y. Compute the product mod 2 and mod 2 - 1, then use
  39 |     |         // the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256
  40 |     |         // variables such that product = high * 2 + low.
  41 |     |         assembly ("memory-safe") {
  42 |     |             let mm := mulmod(a, b, not(0))
  43 |     |             low := mul(a, b)
  44 |     |             high := sub(sub(mm, low), lt(mm, low))
  45 |     |         }
  46 |     |     }
  47 |     | 
  48 |     |     /**
  49 |     |      * @dev Returns the addition of two unsigned integers, with a success flag (no overflow).
  50 |     |      */
  51 |     |     function tryAdd(uint256 a, uint256 b) internal pure returns (bool success, uint256 result) {
  52 |     |         unchecked {
  53 |     |             uint256 c = a + b;
  54 |     |             success = c >= a;
  55 |     |             result = c * SafeCast.toUint(success);
  56 |     |         }
  57 |     |     }
  58 |     | 
  59 |     |     /**
  60 |     |      * @dev Returns the subtraction of two unsigned integers, with a success flag (no overflow).
  61 |     |      */
  62 |     |     function trySub(uint256 a, uint256 b) internal pure returns (bool success, uint256 result) {
  63 |     |         unchecked {
  64 |     |             uint256 c = a - b;
  65 |     |             success = c <= a;
  66 |     |             result = c * SafeCast.toUint(success);
  67 |     |         }
  68 |     |     }
  69 |     | 
  70 |     |     /**
  71 |     |      * @dev Returns the multiplication of two unsigned integers, with a success flag (no overflow).
  72 |     |      */
  73 |     |     function tryMul(uint256 a, uint256 b) internal pure returns (bool success, uint256 result) {
  74 |     |         unchecked {
  75 |     |             uint256 c = a * b;
  76 |     |             assembly ("memory-safe") {
  77 |     |                 // Only true when the multiplication doesn't overflow
  78 |     |                 // (c / a == b) || (a == 0)
  79 |     |                 success := or(eq(div(c, a), b), iszero(a))
  80 |     |             }
  81 |     |             // equivalent to: success ? c : 0
  82 |     |             result = c * SafeCast.toUint(success);
  83 |     |         }
  84 |     |     }
  85 |     | 
  86 |     |     /**
  87 |     |      * @dev Returns the division of two unsigned integers, with a success flag (no division by zero).
  88 |     |      */
  89 |     |     function tryDiv(uint256 a, uint256 b) internal pure returns (bool success, uint256 result) {
  90 |     |         unchecked {
  91 |     |             success = b > 0;
  92 |     |             assembly ("memory-safe") {
  93 |     |                 // The `DIV` opcode returns zero when the denominator is 0.
  94 |     |                 result := div(a, b)
  95 |     |             }
  96 |     |         }
  97 |     |     }
  98 |     | 
  99 |     |     /**
 100 |     |      * @dev Returns the remainder of dividing two unsigned integers, with a success flag (no division by zero).
 101 |     |      */
 102 |     |     function tryMod(uint256 a, uint256 b) internal pure returns (bool success, uint256 result) {
 103 |     |         unchecked {
 104 |     |             success = b > 0;
 105 |     |             assembly ("memory-safe") {
 106 |     |                 // The `MOD` opcode returns zero when the denominator is 0.
 107 |     |                 result := mod(a, b)
 108 |     |             }
 109 |     |         }
 110 |     |     }
 111 |     | 
 112 |     |     /**
 113 |     |      * @dev Unsigned saturating addition, bounds to `2 - 1` instead of overflowing.
 114 |     |      */
 115 |     |     function saturatingAdd(uint256 a, uint256 b) internal pure returns (uint256) {
 116 |     |         (bool success, uint256 result) = tryAdd(a, b);
 117 |     |         return ternary(success, result, type(uint256).max);
 118 |     |     }
 119 |     | 
 120 |     |     /**
 121 |     |      * @dev Unsigned saturating subtraction, bounds to zero instead of overflowing.
 122 |     |      */
 123 |     |     function saturatingSub(uint256 a, uint256 b) internal pure returns (uint256) {
 124 |     |         (, uint256 result) = trySub(a, b);
 125 |     |         return result;
 126 |     |     }
 127 |     | 
 128 |     |     /**
 129 |     |      * @dev Unsigned saturating multiplication, bounds to `2 - 1` instead of overflowing.
 130 |     |      */
 131 |     |     function saturatingMul(uint256 a, uint256 b) internal pure returns (uint256) {
 132 |     |         (bool success, uint256 result) = tryMul(a, b);
 133 |     |         return ternary(success, result, type(uint256).max);
 134 |     |     }
 135 |     | 
 136 |     |     /**
 137 |     |      * @dev Branchless ternary evaluation for `a ? b : c`. Gas costs are constant.
 138 |     |      *
 139 |     |      * IMPORTANT: This function may reduce bytecode size and consume less gas when used standalone.
 140 |     |      * However, the compiler may optimize Solidity ternary operations (i.e. `a ? b : c`) to only compute
 141 |     |      * one branch when needed, making this function more expensive.
 142 |     |      */
 143 |     |     function ternary(bool condition, uint256 a, uint256 b) internal pure returns (uint256) {
 144 |     |         unchecked {
 145 |     |             // branchless ternary works because:
 146 |     |             // b ^ (a ^ b) == a
 147 |     |             // b ^ 0 == b
 148 |     |             return b ^ ((a ^ b) * SafeCast.toUint(condition));
 149 |     |         }
 150 |     |     }
 151 |     | 
 152 |     |     /**
 153 |     |      * @dev Returns the largest of two numbers.
 154 |     |      */
 155 |     |     function max(uint256 a, uint256 b) internal pure returns (uint256) {
 156 |     |         return ternary(a > b, a, b);
 157 |     |     }
 158 |     | 
 159 |     |     /**
 160 |     |      * @dev Returns the smallest of two numbers.
 161 |     |      */
 162 |     |     function min(uint256 a, uint256 b) internal pure returns (uint256) {
 163 |     |         return ternary(a < b, a, b);
 164 |     |     }
 165 |     | 
 166 |     |     /**
 167 |     |      * @dev Returns the average of two numbers. The result is rounded towards
 168 |     |      * zero.
 169 |     |      */
 170 |     |     function average(uint256 a, uint256 b) internal pure returns (uint256) {
 171 |     |         // (a + b) / 2 can overflow.
 172 |     |         return (a & b) + (a ^ b) / 2;
 173 |     |     }
 174 |     | 
 175 |     |     /**
 176 |     |      * @dev Returns the ceiling of the division of two numbers.
 177 |     |      *
 178 |     |      * This differs from standard division with `/` in that it rounds towards infinity instead
 179 |     |      * of rounding towards zero.
 180 |     |      */
 181 |     |     function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {
 182 |     |         if (b == 0) {
 183 |     |             // Guarantee the same behavior as in a regular Solidity division.
 184 |     |             Panic.panic(Panic.DIVISION_BY_ZERO);
 185 |     |         }
 186 |     | 
 187 |     |         // The following calculation ensures accurate ceiling division without overflow.
 188 |     |         // Since a is non-zero, (a - 1) / b will not overflow.
 189 |     |         // The largest possible result occurs when (a - 1) / b is type(uint256).max,
 190 |     |         // but the largest value we can obtain is type(uint256).max - 1, which happens
 191 |     |         // when a = type(uint256).max and b = 1.
 192 |     |         unchecked {
 193 |     |             return SafeCast.toUint(a > 0) * ((a - 1) / b + 1);
 194 |     |         }
 195 |     |     }
 196 |     | 
 197 |     |     /**
 198 |     |      * @dev Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or
 199 |     |      * denominator == 0.
 200 |     |      *
 201 |     |      * Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv) with further edits by
 202 |     |      * Uniswap Labs also under MIT license.
 203 |     |      */
 204 |     |     function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {
 205 |     |         unchecked {
 206 |     |             (uint256 high, uint256 low) = mul512(x, y);
 207 |     | 
 208 |     |             // Handle non-overflow cases, 256 by 256 division.
 209 |     |             if (high == 0) {
 210 |     |                 // Solidity will revert if denominator == 0, unlike the div opcode on its own.
 211 |     |                 // The surrounding unchecked block does not change this fact.
 212 |     |                 // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.
 213 |     |                 return low / denominator;
 214 |     |             }
 215 |     | 
 216 |     |             // Make sure the result is less than 2. Also prevents denominator == 0.
 217 |     |             if (denominator <= high) {
 218 |     |                 Panic.panic(ternary(denominator == 0, Panic.DIVISION_BY_ZERO, Panic.UNDER_OVERFLOW));
 219 |     |             }
 220 |     | 
 221 |     |             ///////////////////////////////////////////////
 222 |     |             // 512 by 256 division.
 223 |     |             ///////////////////////////////////////////////
 224 |     | 
 225 |     |             // Make division exact by subtracting the remainder from [high low].
 226 |     |             uint256 remainder;
 227 |     |             assembly ("memory-safe") {
 228 |     |                 // Compute remainder using mulmod.
 229 |     |                 remainder := mulmod(x, y, denominator)
 230 |     | 
 231 |     |                 // Subtract 256 bit number from 512 bit number.
 232 |     |                 high := sub(high, gt(remainder, low))
 233 |     |                 low := sub(low, remainder)
 234 |     |             }
 235 |     | 
 236 |     |             // Factor powers of two out of denominator and compute largest power of two divisor of denominator.
 237 |     |             // Always >= 1. See https://cs.stackexchange.com/q/138556/92363.
 238 |     | 
 239 |     |             uint256 twos = denominator & (0 - denominator);
 240 |     |             assembly ("memory-safe") {
 241 |     |                 // Divide denominator by twos.
 242 |     |                 denominator := div(denominator, twos)
 243 |     | 
 244 |     |                 // Divide [high low] by twos.
 245 |     |                 low := div(low, twos)
 246 |     | 
 247 |     |                 // Flip twos such that it is 2 / twos. If twos is zero, then it becomes one.
 248 |     |                 twos := add(div(sub(0, twos), twos), 1)
 249 |     |             }
 250 |     | 
 251 |     |             // Shift in bits from high into low.
 252 |     |             low |= high * twos;
 253 |     | 
 254 |     |             // Invert denominator mod 2. Now that denominator is an odd number, it has an inverse modulo 2 such
 255 |     |             // that denominator * inv  1 mod 2. Compute the inverse by starting with a seed that is correct for
 256 |     |             // four bits. That is, denominator * inv  1 mod 2.
 257 |     |             uint256 inverse = (3 * denominator) ^ 2;
 258 |     | 
 259 |     |             // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also
 260 |     |             // works in modular arithmetic, doubling the correct bits in each step.
 261 |     |             inverse *= 2 - denominator * inverse; // inverse mod 2
 262 |     |             inverse *= 2 - denominator * inverse; // inverse mod 2
 263 |     |             inverse *= 2 - denominator * inverse; // inverse mod 2
 264 |     |             inverse *= 2 - denominator * inverse; // inverse mod 2
 265 |     |             inverse *= 2 - denominator * inverse; // inverse mod 2
 266 |     |             inverse *= 2 - denominator * inverse; // inverse mod 2
 267 |     | 
 268 |     |             // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.
 269 |     |             // This will give us the correct result modulo 2. Since the preconditions guarantee that the outcome is
 270 |     |             // less than 2, this is the final result. We don't need to compute the high bits of the result and high
 271 |     |             // is no longer required.
 272 |     |             result = low * inverse;
 273 |     |             return result;
 274 |     |         }
 275 |     |     }
 276 |     | 
 277 |     |     /**
 278 |     |      * @dev Calculates x * y / denominator with full precision, following the selected rounding direction.
 279 |     |      */
 280 |     |     function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {
 281 |     |         return mulDiv(x, y, denominator) + SafeCast.toUint(unsignedRoundsUp(rounding) && mulmod(x, y, denominator) > 0);
 282 |     |     }
 283 |     | 
 284 |     |     /**
 285 |     |      * @dev Calculates floor(x * y >> n) with full precision. Throws if result overflows a uint256.
 286 |     |      */
 287 |     |     function mulShr(uint256 x, uint256 y, uint8 n) internal pure returns (uint256 result) {
 288 |     |         unchecked {
 289 |     |             (uint256 high, uint256 low) = mul512(x, y);
 290 |     |             if (high >= 1 << n) {
 291 |     |                 Panic.panic(Panic.UNDER_OVERFLOW);
 292 |     |             }
 293 |     |             return (high << (256 - n)) | (low >> n);
 294 |     |         }
 295 |     |     }
 296 |     | 
 297 |     |     /**
 298 |     |      * @dev Calculates x * y >> n with full precision, following the selected rounding direction.
 299 |     |      */
 300 |     |     function mulShr(uint256 x, uint256 y, uint8 n, Rounding rounding) internal pure returns (uint256) {
 301 |     |         return mulShr(x, y, n) + SafeCast.toUint(unsignedRoundsUp(rounding) && mulmod(x, y, 1 << n) > 0);
 302 |     |     }
 303 |     | 
 304 |     |     /**
 305 |     |      * @dev Calculate the modular multiplicative inverse of a number in Z/nZ.
 306 |     |      *
 307 |     |      * If n is a prime, then Z/nZ is a field. In that case all elements are inversible, except 0.
 308 |     |      * If n is not a prime, then Z/nZ is not a field, and some elements might not be inversible.
 309 |     |      *
 310 |     |      * If the input value is not inversible, 0 is returned.
 311 |     |      *
 312 |     |      * NOTE: If you know for sure that n is (big) a prime, it may be cheaper to use Fermat's little theorem and get the
 313 |     |      * inverse using `Math.modExp(a, n - 2, n)`. See {invModPrime}.
 314 |     |      */
 315 |     |     function invMod(uint256 a, uint256 n) internal pure returns (uint256) {
 316 |     |         unchecked {
 317 |     |             if (n == 0) return 0;
 318 |     | 
 319 |     |             // The inverse modulo is calculated using the Extended Euclidean Algorithm (iterative version)
 320 |     |             // Used to compute integers x and y such that: ax + ny = gcd(a, n).
 321 |     |             // When the gcd is 1, then the inverse of a modulo n exists and it's x.
 322 |     |             // ax + ny = 1
 323 |     |             // ax = 1 + (-y)n
 324 |     |             // ax  1 (mod n) # x is the inverse of a modulo n
 325 |     | 
 326 |     |             // If the remainder is 0 the gcd is n right away.
 327 |     |             uint256 remainder = a % n;
 328 |     |             uint256 gcd = n;
 329 |     | 
 330 |     |             // Therefore the initial coefficients are:
 331 |     |             // ax + ny = gcd(a, n) = n
 332 |     |             // 0a + 1n = n
 333 |     |             int256 x = 0;
 334 |     |             int256 y = 1;
 335 |     | 
 336 |     |             while (remainder != 0) {
 337 |     |                 uint256 quotient = gcd / remainder;
 338 |     | 
 339 |     |                 (gcd, remainder) = (
 340 |     |                     // The old remainder is the next gcd to try.
 341 |     |                     remainder,
 342 |     |                     // Compute the next remainder.
 343 |     |                     // Can't overflow given that (a % gcd) * (gcd // (a % gcd)) <= gcd
 344 |     |                     // where gcd is at most n (capped to type(uint256).max)
 345 |     |                     gcd - remainder * quotient
 346 |     |                 );
 347 |     | 
 348 |     |                 (x, y) = (
 349 |     |                     // Increment the coefficient of a.
 350 |     |                     y,
 351 |     |                     // Decrement the coefficient of n.
 352 |     |                     // Can overflow, but the result is casted to uint256 so that the
 353 |     |                     // next value of y is "wrapped around" to a value between 0 and n - 1.
 354 |     |                     x - y * int256(quotient)
 355 |     |                 );
 356 |     |             }
 357 |     | 
 358 |     |             if (gcd != 1) return 0; // No inverse exists.
 359 |     |             return ternary(x < 0, n - uint256(-x), uint256(x)); // Wrap the result if it's negative.
 360 |     |         }
 361 |     |     }
 362 |     | 
 363 |     |     /**
 364 |     |      * @dev Variant of {invMod}. More efficient, but only works if `p` is known to be a prime greater than `2`.
 365 |     |      *
 366 |     |      * From https://en.wikipedia.org/wiki/Fermat%27s_little_theorem[Fermat's little theorem], we know that if p is
 367 |     |      * prime, then `a**(p-1)  1 mod p`. As a consequence, we have `a * a**(p-2)  1 mod p`, which means that
 368 |     |      * `a**(p-2)` is the modular multiplicative inverse of a in Fp.
 369 |     |      *
 370 |     |      * NOTE: this function does NOT check that `p` is a prime greater than `2`.
 371 |     |      */
 372 |     |     function invModPrime(uint256 a, uint256 p) internal view returns (uint256) {
 373 |     |         unchecked {
 374 |     |             return Math.modExp(a, p - 2, p);
 375 |     |         }
 376 |     |     }
 377 |     | 
 378 |     |     /**
 379 |     |      * @dev Returns the modular exponentiation of the specified base, exponent and modulus (b ** e % m)
 380 |     |      *
 381 |     |      * Requirements:
 382 |     |      * - modulus can't be zero
 383 |     |      * - underlying staticcall to precompile must succeed
 384 |     |      *
 385 |     |      * IMPORTANT: The result is only valid if the underlying call succeeds. When using this function, make
 386 |     |      * sure the chain you're using it on supports the precompiled contract for modular exponentiation
 387 |     |      * at address 0x05 as specified in https://eips.ethereum.org/EIPS/eip-198[EIP-198]. Otherwise,
 388 |     |      * the underlying function will succeed given the lack of a revert, but the result may be incorrectly
 389 |     |      * interpreted as 0.
 390 |     |      */
 391 |     |     function modExp(uint256 b, uint256 e, uint256 m) internal view returns (uint256) {
 392 |     |         (bool success, uint256 result) = tryModExp(b, e, m);
 393 |     |         if (!success) {
 394 |     |             Panic.panic(Panic.DIVISION_BY_ZERO);
 395 |     |         }
 396 |     |         return result;
 397 |     |     }
 398 |     | 
 399 |     |     /**
 400 |     |      * @dev Returns the modular exponentiation of the specified base, exponent and modulus (b ** e % m).
 401 |     |      * It includes a success flag indicating if the operation succeeded. Operation will be marked as failed if trying
 402 |     |      * to operate modulo 0 or if the underlying precompile reverted.
 403 |     |      *
 404 |     |      * IMPORTANT: The result is only valid if the success flag is true. When using this function, make sure the chain
 405 |     |      * you're using it on supports the precompiled contract for modular exponentiation at address 0x05 as specified in
 406 |     |      * https://eips.ethereum.org/EIPS/eip-198[EIP-198]. Otherwise, the underlying function will succeed given the lack
 407 |     |      * of a revert, but the result may be incorrectly interpreted as 0.
 408 |     |      */
 409 |     |     function tryModExp(uint256 b, uint256 e, uint256 m) internal view returns (bool success, uint256 result) {
 410 |     |         if (m == 0) return (false, 0);
 411 |     |         assembly ("memory-safe") {
 412 |     |             let ptr := mload(0x40)
 413 |     |             // | Offset    | Content    | Content (Hex)                                                      |
 414 |     |             // |-----------|------------|--------------------------------------------------------------------|
 415 |     |             // | 0x00:0x1f | size of b  | 0x0000000000000000000000000000000000000000000000000000000000000020 |
 416 |     |             // | 0x20:0x3f | size of e  | 0x0000000000000000000000000000000000000000000000000000000000000020 |
 417 |     |             // | 0x40:0x5f | size of m  | 0x0000000000000000000000000000000000000000000000000000000000000020 |
 418 |     |             // | 0x60:0x7f | value of b | 0x<.............................................................b> |
 419 |     |             // | 0x80:0x9f | value of e | 0x<.............................................................e> |
 420 |     |             // | 0xa0:0xbf | value of m | 0x<.............................................................m> |
 421 |     |             mstore(ptr, 0x20)
 422 |     |             mstore(add(ptr, 0x20), 0x20)
 423 |     |             mstore(add(ptr, 0x40), 0x20)
 424 |     |             mstore(add(ptr, 0x60), b)
 425 |     |             mstore(add(ptr, 0x80), e)
 426 |     |             mstore(add(ptr, 0xa0), m)
 427 |     | 
 428 |     |             // Given the result < m, it's guaranteed to fit in 32 bytes,
 429 |     |             // so we can use the memory scratch space located at offset 0.
 430 |     |             success := staticcall(gas(), 0x05, ptr, 0xc0, 0x00, 0x20)
 431 |     |             result := mload(0x00)
 432 |     |         }
 433 |     |     }
 434 |     | 
 435 |     |     /**
 436 |     |      * @dev Variant of {modExp} that supports inputs of arbitrary length.
 437 |     |      */
 438 |     |     function modExp(bytes memory b, bytes memory e, bytes memory m) internal view returns (bytes memory) {
 439 |     |         (bool success, bytes memory result) = tryModExp(b, e, m);
 440 |     |         if (!success) {
 441 |     |             Panic.panic(Panic.DIVISION_BY_ZERO);
 442 |     |         }
 443 |     |         return result;
 444 |     |     }
 445 |     | 
 446 |     |     /**
 447 |     |      * @dev Variant of {tryModExp} that supports inputs of arbitrary length.
 448 |     |      */
 449 |     |     function tryModExp(
 450 |     |         bytes memory b,
 451 |     |         bytes memory e,
 452 |     |         bytes memory m
 453 |     |     ) internal view returns (bool success, bytes memory result) {
 454 |     |         if (_zeroBytes(m)) return (false, new bytes(0));
 455 |     | 
 456 |     |         uint256 mLen = m.length;
 457 |     | 
 458 |     |         // Encode call args in result and move the free memory pointer
 459 |     |         result = abi.encodePacked(b.length, e.length, mLen, b, e, m);
 460 |     | 
 461 |     |         assembly ("memory-safe") {
 462 |     |             let dataPtr := add(result, 0x20)
 463 |     |             // Write result on top of args to avoid allocating extra memory.
 464 |     |             success := staticcall(gas(), 0x05, dataPtr, mload(result), dataPtr, mLen)
 465 |     |             // Overwrite the length.
 466 |     |             // result.length > returndatasize() is guaranteed because returndatasize() == m.length
 467 |     |             mstore(result, mLen)
 468 |     |             // Set the memory pointer after the returned data.
 469 |     |             mstore(0x40, add(dataPtr, mLen))
 470 |     |         }
 471 |     |     }
 472 |     | 
 473 |     |     /**
 474 |     |      * @dev Returns whether the provided byte array is zero.
 475 |     |      */
 476 |     |     function _zeroBytes(bytes memory byteArray) private pure returns (bool) {
 477 |     |         for (uint256 i = 0; i < byteArray.length; ++i) {
 478 |     |             if (byteArray[i] != 0) {
 479 |     |                 return false;
 480 |     |             }
 481 |     |         }
 482 |     |         return true;
 483 |     |     }
 484 |     | 
 485 |     |     /**
 486 |     |      * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded
 487 |     |      * towards zero.
 488 |     |      *
 489 |     |      * This method is based on Newton's method for computing square roots; the algorithm is restricted to only
 490 |     |      * using integer operations.
 491 |     |      */
 492 |     |     function sqrt(uint256 a) internal pure returns (uint256) {
 493 |     |         unchecked {
 494 |     |             // Take care of easy edge cases when a == 0 or a == 1
 495 |     |             if (a <= 1) {
 496 |     |                 return a;
 497 |     |             }
 498 |     | 
 499 |     |             // In this function, we use Newton's method to get a root of `f(x) := x - a`. It involves building a
 500 |     |             // sequence x_n that converges toward sqrt(a). For each iteration x_n, we also define the error between
 501 |     |             // the current value as `_n = | x_n - sqrt(a) |`.
 502 |     |             //
 503 |     |             // For our first estimation, we consider `e` the smallest power of 2 which is bigger than the square root
 504 |     |             // of the target. (i.e. `2**(e-1)  sqrt(a) < 2**e`). We know that `e  128` because `(2) = 2` is
 505 |     |             // bigger than any uint256.
 506 |     |             //
 507 |     |             // By noticing that
 508 |     |             // `2**(e-1)  sqrt(a) < 2**e  (2**(e-1))  a < (2**e)  2**(2*e-2)  a < 2**(2*e)`
 509 |     |             // we can deduce that `e - 1` is `log2(a) / 2`. We can thus compute `x_n = 2**(e-1)` using a method similar
 510 |     |             // to the msb function.
 511 |     |             uint256 aa = a;
 512 |     |             uint256 xn = 1;
 513 |     | 
 514 |     |             if (aa >= (1 << 128)) {
 515 |     |                 aa >>= 128;
 516 |     |                 xn <<= 64;
 517 |     |             }
 518 |     |             if (aa >= (1 << 64)) {
 519 |     |                 aa >>= 64;
 520 |     |                 xn <<= 32;
 521 |     |             }
 522 |     |             if (aa >= (1 << 32)) {
 523 |     |                 aa >>= 32;
 524 |     |                 xn <<= 16;
 525 |     |             }
 526 |     |             if (aa >= (1 << 16)) {
 527 |     |                 aa >>= 16;
 528 |     |                 xn <<= 8;
 529 |     |             }
 530 |     |             if (aa >= (1 << 8)) {
 531 |     |                 aa >>= 8;
 532 |     |                 xn <<= 4;
 533 |     |             }
 534 |     |             if (aa >= (1 << 4)) {
 535 |     |                 aa >>= 4;
 536 |     |                 xn <<= 2;
 537 |     |             }
 538 |     |             if (aa >= (1 << 2)) {
 539 |     |                 xn <<= 1;
 540 |     |             }
 541 |     | 
 542 |     |             // We now have x_n such that `x_n = 2**(e-1)  sqrt(a) < 2**e = 2 * x_n`. This implies _n  2**(e-1).
 543 |     |             //
 544 |     |             // We can refine our estimation by noticing that the middle of that interval minimizes the error.
 545 |     |             // If we move x_n to equal 2**(e-1) + 2**(e-2), then we reduce the error to _n  2**(e-2).
 546 |     |             // This is going to be our x_0 (and _0)
 547 |     |             xn = (3 * xn) >> 1; // _0 := | x_0 - sqrt(a) |  2**(e-2)
 548 |     | 
 549 |     |             // From here, Newton's method give us:
 550 |     |             // x_{n+1} = (x_n + a / x_n) / 2
 551 |     |             //
 552 |     |             // One should note that:
 553 |     |             // x_{n+1} - a = ((x_n + a / x_n) / 2) - a
 554 |     |             //              = ((x_n + a) / (2 * x_n)) - a
 555 |     |             //              = (x_n + 2 * a * x_n + a) / (4 * x_n) - a
 556 |     |             //              = (x_n + 2 * a * x_n + a - 4 * a * x_n) / (4 * x_n)
 557 |     |             //              = (x_n - 2 * a * x_n + a) / (4 * x_n)
 558 |     |             //              = (x_n - a) / (2 * x_n)
 559 |     |             //              = ((x_n - a) / (2 * x_n))
 560 |     |             //               0
 561 |     |             // Which proves that for all n  1, sqrt(a)  x_n
 562 |     |             //
 563 |     |             // This gives us the proof of quadratic convergence of the sequence:
 564 |     |             // _{n+1} = | x_{n+1} - sqrt(a) |
 565 |     |             //         = | (x_n + a / x_n) / 2 - sqrt(a) |
 566 |     |             //         = | (x_n + a - 2*x_n*sqrt(a)) / (2 * x_n) |
 567 |     |             //         = | (x_n - sqrt(a)) / (2 * x_n) |
 568 |     |             //         = | _n / (2 * x_n) |
 569 |     |             //         = _n / | (2 * x_n) |
 570 |     |             //
 571 |     |             // For the first iteration, we have a special case where x_0 is known:
 572 |     |             // _1 = _0 / | (2 * x_0) |
 573 |     |             //      (2**(e-2)) / (2 * (2**(e-1) + 2**(e-2)))
 574 |     |             //      2**(2*e-4) / (3 * 2**(e-1))
 575 |     |             //      2**(e-3) / 3
 576 |     |             //      2**(e-3-log2(3))
 577 |     |             //      2**(e-4.5)
 578 |     |             //
 579 |     |             // For the following iterations, we use the fact that, 2**(e-1)  sqrt(a)  x_n:
 580 |     |             // _{n+1} = _n / | (2 * x_n) |
 581 |     |             //          (2**(e-k)) / (2 * 2**(e-1))
 582 |     |             //          2**(2*e-2*k) / 2**e
 583 |     |             //          2**(e-2*k)
 584 |     |             xn = (xn + a / xn) >> 1; // _1 := | x_1 - sqrt(a) |  2**(e-4.5)  -- special case, see above
 585 |     |             xn = (xn + a / xn) >> 1; // _2 := | x_2 - sqrt(a) |  2**(e-9)    -- general case with k = 4.5
 586 |     |             xn = (xn + a / xn) >> 1; // _3 := | x_3 - sqrt(a) |  2**(e-18)   -- general case with k = 9
 587 |     |             xn = (xn + a / xn) >> 1; // _4 := | x_4 - sqrt(a) |  2**(e-36)   -- general case with k = 18
 588 |     |             xn = (xn + a / xn) >> 1; // _5 := | x_5 - sqrt(a) |  2**(e-72)   -- general case with k = 36
 589 |     |             xn = (xn + a / xn) >> 1; // _6 := | x_6 - sqrt(a) |  2**(e-144)  -- general case with k = 72
 590 |     | 
 591 |     |             // Because e  128 (as discussed during the first estimation phase), we know have reached a precision
 592 |     |             // _6  2**(e-144) < 1. Given we're operating on integers, then we can ensure that xn is now either
 593 |     |             // sqrt(a) or sqrt(a) + 1.
 594 |     |             return xn - SafeCast.toUint(xn > a / xn);
 595 |     |         }
 596 |     |     }
 597 |     | 
 598 |     |     /**
 599 |     |      * @dev Calculates sqrt(a), following the selected rounding direction.
 600 |     |      */
 601 |     |     function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {
 602 |     |         unchecked {
 603 |     |             uint256 result = sqrt(a);
 604 |     |             return result + SafeCast.toUint(unsignedRoundsUp(rounding) && result * result < a);
 605 |     |         }
 606 |     |     }
 607 |     | 
 608 |     |     /**
 609 |     |      * @dev Return the log in base 2 of a positive value rounded towards zero.
 610 |     |      * Returns 0 if given 0.
 611 |     |      */
 612 |     |     function log2(uint256 x) internal pure returns (uint256 r) {
 613 |     |         // If value has upper 128 bits set, log2 result is at least 128
 614 |     |         r = SafeCast.toUint(x > 0xffffffffffffffffffffffffffffffff) << 7;
 615 |     |         // If upper 64 bits of 128-bit half set, add 64 to result
 616 |     |         r |= SafeCast.toUint((x >> r) > 0xffffffffffffffff) << 6;
 617 |     |         // If upper 32 bits of 64-bit half set, add 32 to result
 618 |     |         r |= SafeCast.toUint((x >> r) > 0xffffffff) << 5;
 619 |     |         // If upper 16 bits of 32-bit half set, add 16 to result
 620 |     |         r |= SafeCast.toUint((x >> r) > 0xffff) << 4;
 621 |     |         // If upper 8 bits of 16-bit half set, add 8 to result
 622 |     |         r |= SafeCast.toUint((x >> r) > 0xff) << 3;
 623 |     |         // If upper 4 bits of 8-bit half set, add 4 to result
 624 |     |         r |= SafeCast.toUint((x >> r) > 0xf) << 2;
 625 |     | 
 626 |     |         // Shifts value right by the current result and use it as an index into this lookup table:
 627 |     |         //
 628 |     |         // | x (4 bits) |  index  | table[index] = MSB position |
 629 |     |         // |------------|---------|-----------------------------|
 630 |     |         // |    0000    |    0    |        table[0] = 0         |
 631 |     |         // |    0001    |    1    |        table[1] = 0         |
 632 |     |         // |    0010    |    2    |        table[2] = 1         |
 633 |     |         // |    0011    |    3    |        table[3] = 1         |
 634 |     |         // |    0100    |    4    |        table[4] = 2         |
 635 |     |         // |    0101    |    5    |        table[5] = 2         |
 636 |     |         // |    0110    |    6    |        table[6] = 2         |
 637 |     |         // |    0111    |    7    |        table[7] = 2         |
 638 |     |         // |    1000    |    8    |        table[8] = 3         |
 639 |     |         // |    1001    |    9    |        table[9] = 3         |
 640 |     |         // |    1010    |   10    |        table[10] = 3        |
 641 |     |         // |    1011    |   11    |        table[11] = 3        |
 642 |     |         // |    1100    |   12    |        table[12] = 3        |
 643 |     |         // |    1101    |   13    |        table[13] = 3        |
 644 |     |         // |    1110    |   14    |        table[14] = 3        |
 645 |     |         // |    1111    |   15    |        table[15] = 3        |
 646 |     |         //
 647 |     |         // The lookup table is represented as a 32-byte value with the MSB positions for 0-15 in the last 16 bytes.
 648 |     |         assembly ("memory-safe") {
 649 |     |             r := or(r, byte(shr(r, x), 0x0000010102020202030303030303030300000000000000000000000000000000))
 650 |     |         }
 651 |     |     }
 652 |     | 
 653 |     |     /**
 654 |     |      * @dev Return the log in base 2, following the selected rounding direction, of a positive value.
 655 |     |      * Returns 0 if given 0.
 656 |     |      */
 657 |     |     function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {
 658 |     |         unchecked {
 659 |     |             uint256 result = log2(value);
 660 |     |             return result + SafeCast.toUint(unsignedRoundsUp(rounding) && 1 << result < value);
 661 |     |         }
 662 |     |     }
 663 |     | 
 664 |     |     /**
 665 |     |      * @dev Return the log in base 10 of a positive value rounded towards zero.
 666 |     |      * Returns 0 if given 0.
 667 |     |      */
 668 |     |     function log10(uint256 value) internal pure returns (uint256) {
 669 |     |         uint256 result = 0;
 670 |     |         unchecked {
 671 |     |             if (value >= 10 ** 64) {
 672 |     |                 value /= 10 ** 64;
 673 |     |                 result += 64;
 674 |     |             }
 675 |     |             if (value >= 10 ** 32) {
 676 |     |                 value /= 10 ** 32;
 677 |     |                 result += 32;
 678 |     |             }
 679 |     |             if (value >= 10 ** 16) {
 680 |     |                 value /= 10 ** 16;
 681 |     |                 result += 16;
 682 |     |             }
 683 |     |             if (value >= 10 ** 8) {
 684 |     |                 value /= 10 ** 8;
 685 |     |                 result += 8;
 686 |     |             }
 687 |     |             if (value >= 10 ** 4) {
 688 |     |                 value /= 10 ** 4;
 689 |     |                 result += 4;
 690 |     |             }
 691 |     |             if (value >= 10 ** 2) {
 692 |     |                 value /= 10 ** 2;
 693 |     |                 result += 2;
 694 |     |             }
 695 |     |             if (value >= 10 ** 1) {
 696 |     |                 result += 1;
 697 |     |             }
 698 |     |         }
 699 |     |         return result;
 700 |     |     }
 701 |     | 
 702 |     |     /**
 703 |     |      * @dev Return the log in base 10, following the selected rounding direction, of a positive value.
 704 |     |      * Returns 0 if given 0.
 705 |     |      */
 706 |     |     function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {
 707 |     |         unchecked {
 708 |     |             uint256 result = log10(value);
 709 |     |             return result + SafeCast.toUint(unsignedRoundsUp(rounding) && 10 ** result < value);
 710 |     |         }
 711 |     |     }
 712 |     | 
 713 |     |     /**
 714 |     |      * @dev Return the log in base 256 of a positive value rounded towards zero.
 715 |     |      * Returns 0 if given 0.
 716 |     |      *
 717 |     |      * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.
 718 |     |      */
 719 |     |     function log256(uint256 x) internal pure returns (uint256 r) {
 720 |     |         // If value has upper 128 bits set, log2 result is at least 128
 721 |     |         r = SafeCast.toUint(x > 0xffffffffffffffffffffffffffffffff) << 7;
 722 |     |         // If upper 64 bits of 128-bit half set, add 64 to result
 723 |     |         r |= SafeCast.toUint((x >> r) > 0xffffffffffffffff) << 6;
 724 |     |         // If upper 32 bits of 64-bit half set, add 32 to result
 725 |     |         r |= SafeCast.toUint((x >> r) > 0xffffffff) << 5;
 726 |     |         // If upper 16 bits of 32-bit half set, add 16 to result
 727 |     |         r |= SafeCast.toUint((x >> r) > 0xffff) << 4;
 728 |     |         // Add 1 if upper 8 bits of 16-bit half set, and divide accumulated result by 8
 729 |     |         return (r >> 3) | SafeCast.toUint((x >> r) > 0xff);
 730 |     |     }
 731 |     | 
 732 |     |     /**
 733 |     |      * @dev Return the log in base 256, following the selected rounding direction, of a positive value.
 734 |     |      * Returns 0 if given 0.
 735 |     |      */
 736 |     |     function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {
 737 |     |         unchecked {
 738 |     |             uint256 result = log256(value);
 739 |     |             return result + SafeCast.toUint(unsignedRoundsUp(rounding) && 1 << (result << 3) < value);
 740 |     |         }
 741 |     |     }
 742 |     | 
 743 |     |     /**
 744 |     |      * @dev Returns whether a provided rounding mode is considered rounding up for unsigned integers.
 745 |     |      */
 746 |     |     function unsignedRoundsUp(Rounding rounding) internal pure returns (bool) {
 747 |     |         return uint8(rounding) % 2 == 1;
 748 |     |     }
 749 |     | }
 750 |     | 

/home/phantom/Documents/azemora/azemora-contracts/lib/openzeppelin-contracts/contracts/utils/math/SafeCast.sol
    1 |     | // SPDX-License-Identifier: MIT
    2 |     | // OpenZeppelin Contracts (last updated v5.1.0) (utils/math/SafeCast.sol)
    3 |     | // This file was procedurally generated from scripts/generate/templates/SafeCast.js.
    4 |     | 
    5 |     | pragma solidity ^0.8.20;
    6 |     | 
    7 |     | /**
    8 |     |  * @dev Wrappers over Solidity's uintXX/intXX/bool casting operators with added overflow
    9 |     |  * checks.
   10 |     |  *
   11 |     |  * Downcasting from uint256/int256 in Solidity does not revert on overflow. This can
   12 |     |  * easily result in undesired exploitation or bugs, since developers usually
   13 |     |  * assume that overflows raise errors. `SafeCast` restores this intuition by
   14 |     |  * reverting the transaction when such an operation overflows.
   15 |     |  *
   16 |     |  * Using this library instead of the unchecked operations eliminates an entire
   17 |     |  * class of bugs, so it's recommended to use it always.
   18 |     |  */
   19 |     | library SafeCast {
   20 |     |     /**
   21 |     |      * @dev Value doesn't fit in an uint of `bits` size.
   22 |     |      */
   23 |     |     error SafeCastOverflowedUintDowncast(uint8 bits, uint256 value);
   24 |     | 
   25 |     |     /**
   26 |     |      * @dev An int value doesn't fit in an uint of `bits` size.
   27 |     |      */
   28 |     |     error SafeCastOverflowedIntToUint(int256 value);
   29 |     | 
   30 |     |     /**
   31 |     |      * @dev Value doesn't fit in an int of `bits` size.
   32 |     |      */
   33 |     |     error SafeCastOverflowedIntDowncast(uint8 bits, int256 value);
   34 |     | 
   35 |     |     /**
   36 |     |      * @dev An uint value doesn't fit in an int of `bits` size.
   37 |     |      */
   38 |     |     error SafeCastOverflowedUintToInt(uint256 value);
   39 |     | 
   40 |     |     /**
   41 |     |      * @dev Returns the downcasted uint248 from uint256, reverting on
   42 |     |      * overflow (when the input is greater than largest uint248).
   43 |     |      *
   44 |     |      * Counterpart to Solidity's `uint248` operator.
   45 |     |      *
   46 |     |      * Requirements:
   47 |     |      *
   48 |     |      * - input must fit into 248 bits
   49 |     |      */
   50 |     |     function toUint248(uint256 value) internal pure returns (uint248) {
   51 |     |         if (value > type(uint248).max) {
   52 |     |             revert SafeCastOverflowedUintDowncast(248, value);
   53 |     |         }
   54 |     |         return uint248(value);
   55 |     |     }
   56 |     | 
   57 |     |     /**
   58 |     |      * @dev Returns the downcasted uint240 from uint256, reverting on
   59 |     |      * overflow (when the input is greater than largest uint240).
   60 |     |      *
   61 |     |      * Counterpart to Solidity's `uint240` operator.
   62 |     |      *
   63 |     |      * Requirements:
   64 |     |      *
   65 |     |      * - input must fit into 240 bits
   66 |     |      */
   67 |     |     function toUint240(uint256 value) internal pure returns (uint240) {
   68 |     |         if (value > type(uint240).max) {
   69 |     |             revert SafeCastOverflowedUintDowncast(240, value);
   70 |     |         }
   71 |     |         return uint240(value);
   72 |     |     }
   73 |     | 
   74 |     |     /**
   75 |     |      * @dev Returns the downcasted uint232 from uint256, reverting on
   76 |     |      * overflow (when the input is greater than largest uint232).
   77 |     |      *
   78 |     |      * Counterpart to Solidity's `uint232` operator.
   79 |     |      *
   80 |     |      * Requirements:
   81 |     |      *
   82 |     |      * - input must fit into 232 bits
   83 |     |      */
   84 |     |     function toUint232(uint256 value) internal pure returns (uint232) {
   85 |     |         if (value > type(uint232).max) {
   86 |     |             revert SafeCastOverflowedUintDowncast(232, value);
   87 |     |         }
   88 |     |         return uint232(value);
   89 |     |     }
   90 |     | 
   91 |     |     /**
   92 |     |      * @dev Returns the downcasted uint224 from uint256, reverting on
   93 |     |      * overflow (when the input is greater than largest uint224).
   94 |     |      *
   95 |     |      * Counterpart to Solidity's `uint224` operator.
   96 |     |      *
   97 |     |      * Requirements:
   98 |     |      *
   99 |     |      * - input must fit into 224 bits
  100 |     |      */
  101 |     |     function toUint224(uint256 value) internal pure returns (uint224) {
  102 |     |         if (value > type(uint224).max) {
  103 |     |             revert SafeCastOverflowedUintDowncast(224, value);
  104 |     |         }
  105 |     |         return uint224(value);
  106 |     |     }
  107 |     | 
  108 |     |     /**
  109 |     |      * @dev Returns the downcasted uint216 from uint256, reverting on
  110 |     |      * overflow (when the input is greater than largest uint216).
  111 |     |      *
  112 |     |      * Counterpart to Solidity's `uint216` operator.
  113 |     |      *
  114 |     |      * Requirements:
  115 |     |      *
  116 |     |      * - input must fit into 216 bits
  117 |     |      */
  118 |     |     function toUint216(uint256 value) internal pure returns (uint216) {
  119 |     |         if (value > type(uint216).max) {
  120 |     |             revert SafeCastOverflowedUintDowncast(216, value);
  121 |     |         }
  122 |     |         return uint216(value);
  123 |     |     }
  124 |     | 
  125 |     |     /**
  126 |     |      * @dev Returns the downcasted uint208 from uint256, reverting on
  127 |     |      * overflow (when the input is greater than largest uint208).
  128 |     |      *
  129 |     |      * Counterpart to Solidity's `uint208` operator.
  130 |     |      *
  131 |     |      * Requirements:
  132 |     |      *
  133 |     |      * - input must fit into 208 bits
  134 |     |      */
  135 |     |     function toUint208(uint256 value) internal pure returns (uint208) {
  136 |     |         if (value > type(uint208).max) {
  137 |     |             revert SafeCastOverflowedUintDowncast(208, value);
  138 |     |         }
  139 |     |         return uint208(value);
  140 |     |     }
  141 |     | 
  142 |     |     /**
  143 |     |      * @dev Returns the downcasted uint200 from uint256, reverting on
  144 |     |      * overflow (when the input is greater than largest uint200).
  145 |     |      *
  146 |     |      * Counterpart to Solidity's `uint200` operator.
  147 |     |      *
  148 |     |      * Requirements:
  149 |     |      *
  150 |     |      * - input must fit into 200 bits
  151 |     |      */
  152 |     |     function toUint200(uint256 value) internal pure returns (uint200) {
  153 |     |         if (value > type(uint200).max) {
  154 |     |             revert SafeCastOverflowedUintDowncast(200, value);
  155 |     |         }
  156 |     |         return uint200(value);
  157 |     |     }
  158 |     | 
  159 |     |     /**
  160 |     |      * @dev Returns the downcasted uint192 from uint256, reverting on
  161 |     |      * overflow (when the input is greater than largest uint192).
  162 |     |      *
  163 |     |      * Counterpart to Solidity's `uint192` operator.
  164 |     |      *
  165 |     |      * Requirements:
  166 |     |      *
  167 |     |      * - input must fit into 192 bits
  168 |     |      */
  169 |     |     function toUint192(uint256 value) internal pure returns (uint192) {
  170 |     |         if (value > type(uint192).max) {
  171 |     |             revert SafeCastOverflowedUintDowncast(192, value);
  172 |     |         }
  173 |     |         return uint192(value);
  174 |     |     }
  175 |     | 
  176 |     |     /**
  177 |     |      * @dev Returns the downcasted uint184 from uint256, reverting on
  178 |     |      * overflow (when the input is greater than largest uint184).
  179 |     |      *
  180 |     |      * Counterpart to Solidity's `uint184` operator.
  181 |     |      *
  182 |     |      * Requirements:
  183 |     |      *
  184 |     |      * - input must fit into 184 bits
  185 |     |      */
  186 |     |     function toUint184(uint256 value) internal pure returns (uint184) {
  187 |     |         if (value > type(uint184).max) {
  188 |     |             revert SafeCastOverflowedUintDowncast(184, value);
  189 |     |         }
  190 |     |         return uint184(value);
  191 |     |     }
  192 |     | 
  193 |     |     /**
  194 |     |      * @dev Returns the downcasted uint176 from uint256, reverting on
  195 |     |      * overflow (when the input is greater than largest uint176).
  196 |     |      *
  197 |     |      * Counterpart to Solidity's `uint176` operator.
  198 |     |      *
  199 |     |      * Requirements:
  200 |     |      *
  201 |     |      * - input must fit into 176 bits
  202 |     |      */
  203 |     |     function toUint176(uint256 value) internal pure returns (uint176) {
  204 |     |         if (value > type(uint176).max) {
  205 |     |             revert SafeCastOverflowedUintDowncast(176, value);
  206 |     |         }
  207 |     |         return uint176(value);
  208 |     |     }
  209 |     | 
  210 |     |     /**
  211 |     |      * @dev Returns the downcasted uint168 from uint256, reverting on
  212 |     |      * overflow (when the input is greater than largest uint168).
  213 |     |      *
  214 |     |      * Counterpart to Solidity's `uint168` operator.
  215 |     |      *
  216 |     |      * Requirements:
  217 |     |      *
  218 |     |      * - input must fit into 168 bits
  219 |     |      */
  220 |     |     function toUint168(uint256 value) internal pure returns (uint168) {
  221 |     |         if (value > type(uint168).max) {
  222 |     |             revert SafeCastOverflowedUintDowncast(168, value);
  223 |     |         }
  224 |     |         return uint168(value);
  225 |     |     }
  226 |     | 
  227 |     |     /**
  228 |     |      * @dev Returns the downcasted uint160 from uint256, reverting on
  229 |     |      * overflow (when the input is greater than largest uint160).
  230 |     |      *
  231 |     |      * Counterpart to Solidity's `uint160` operator.
  232 |     |      *
  233 |     |      * Requirements:
  234 |     |      *
  235 |     |      * - input must fit into 160 bits
  236 |     |      */
  237 |     |     function toUint160(uint256 value) internal pure returns (uint160) {
  238 |     |         if (value > type(uint160).max) {
  239 |     |             revert SafeCastOverflowedUintDowncast(160, value);
  240 |     |         }
  241 |     |         return uint160(value);
  242 |     |     }
  243 |     | 
  244 |     |     /**
  245 |     |      * @dev Returns the downcasted uint152 from uint256, reverting on
  246 |     |      * overflow (when the input is greater than largest uint152).
  247 |     |      *
  248 |     |      * Counterpart to Solidity's `uint152` operator.
  249 |     |      *
  250 |     |      * Requirements:
  251 |     |      *
  252 |     |      * - input must fit into 152 bits
  253 |     |      */
  254 |     |     function toUint152(uint256 value) internal pure returns (uint152) {
  255 |     |         if (value > type(uint152).max) {
  256 |     |             revert SafeCastOverflowedUintDowncast(152, value);
  257 |     |         }
  258 |     |         return uint152(value);
  259 |     |     }
  260 |     | 
  261 |     |     /**
  262 |     |      * @dev Returns the downcasted uint144 from uint256, reverting on
  263 |     |      * overflow (when the input is greater than largest uint144).
  264 |     |      *
  265 |     |      * Counterpart to Solidity's `uint144` operator.
  266 |     |      *
  267 |     |      * Requirements:
  268 |     |      *
  269 |     |      * - input must fit into 144 bits
  270 |     |      */
  271 |     |     function toUint144(uint256 value) internal pure returns (uint144) {
  272 |     |         if (value > type(uint144).max) {
  273 |     |             revert SafeCastOverflowedUintDowncast(144, value);
  274 |     |         }
  275 |     |         return uint144(value);
  276 |     |     }
  277 |     | 
  278 |     |     /**
  279 |     |      * @dev Returns the downcasted uint136 from uint256, reverting on
  280 |     |      * overflow (when the input is greater than largest uint136).
  281 |     |      *
  282 |     |      * Counterpart to Solidity's `uint136` operator.
  283 |     |      *
  284 |     |      * Requirements:
  285 |     |      *
  286 |     |      * - input must fit into 136 bits
  287 |     |      */
  288 |     |     function toUint136(uint256 value) internal pure returns (uint136) {
  289 |     |         if (value > type(uint136).max) {
  290 |     |             revert SafeCastOverflowedUintDowncast(136, value);
  291 |     |         }
  292 |     |         return uint136(value);
  293 |     |     }
  294 |     | 
  295 |     |     /**
  296 |     |      * @dev Returns the downcasted uint128 from uint256, reverting on
  297 |     |      * overflow (when the input is greater than largest uint128).
  298 |     |      *
  299 |     |      * Counterpart to Solidity's `uint128` operator.
  300 |     |      *
  301 |     |      * Requirements:
  302 |     |      *
  303 |     |      * - input must fit into 128 bits
  304 |     |      */
  305 |     |     function toUint128(uint256 value) internal pure returns (uint128) {
  306 |     |         if (value > type(uint128).max) {
  307 |     |             revert SafeCastOverflowedUintDowncast(128, value);
  308 |     |         }
  309 |     |         return uint128(value);
  310 |     |     }
  311 |     | 
  312 |     |     /**
  313 |     |      * @dev Returns the downcasted uint120 from uint256, reverting on
  314 |     |      * overflow (when the input is greater than largest uint120).
  315 |     |      *
  316 |     |      * Counterpart to Solidity's `uint120` operator.
  317 |     |      *
  318 |     |      * Requirements:
  319 |     |      *
  320 |     |      * - input must fit into 120 bits
  321 |     |      */
  322 |     |     function toUint120(uint256 value) internal pure returns (uint120) {
  323 |     |         if (value > type(uint120).max) {
  324 |     |             revert SafeCastOverflowedUintDowncast(120, value);
  325 |     |         }
  326 |     |         return uint120(value);
  327 |     |     }
  328 |     | 
  329 |     |     /**
  330 |     |      * @dev Returns the downcasted uint112 from uint256, reverting on
  331 |     |      * overflow (when the input is greater than largest uint112).
  332 |     |      *
  333 |     |      * Counterpart to Solidity's `uint112` operator.
  334 |     |      *
  335 |     |      * Requirements:
  336 |     |      *
  337 |     |      * - input must fit into 112 bits
  338 |     |      */
  339 |     |     function toUint112(uint256 value) internal pure returns (uint112) {
  340 |     |         if (value > type(uint112).max) {
  341 |     |             revert SafeCastOverflowedUintDowncast(112, value);
  342 |     |         }
  343 |     |         return uint112(value);
  344 |     |     }
  345 |     | 
  346 |     |     /**
  347 |     |      * @dev Returns the downcasted uint104 from uint256, reverting on
  348 |     |      * overflow (when the input is greater than largest uint104).
  349 |     |      *
  350 |     |      * Counterpart to Solidity's `uint104` operator.
  351 |     |      *
  352 |     |      * Requirements:
  353 |     |      *
  354 |     |      * - input must fit into 104 bits
  355 |     |      */
  356 |     |     function toUint104(uint256 value) internal pure returns (uint104) {
  357 |     |         if (value > type(uint104).max) {
  358 |     |             revert SafeCastOverflowedUintDowncast(104, value);
  359 |     |         }
  360 |     |         return uint104(value);
  361 |     |     }
  362 |     | 
  363 |     |     /**
  364 |     |      * @dev Returns the downcasted uint96 from uint256, reverting on
  365 |     |      * overflow (when the input is greater than largest uint96).
  366 |     |      *
  367 |     |      * Counterpart to Solidity's `uint96` operator.
  368 |     |      *
  369 |     |      * Requirements:
  370 |     |      *
  371 |     |      * - input must fit into 96 bits
  372 |     |      */
  373 |     |     function toUint96(uint256 value) internal pure returns (uint96) {
  374 |     |         if (value > type(uint96).max) {
  375 |     |             revert SafeCastOverflowedUintDowncast(96, value);
  376 |     |         }
  377 |     |         return uint96(value);
  378 |     |     }
  379 |     | 
  380 |     |     /**
  381 |     |      * @dev Returns the downcasted uint88 from uint256, reverting on
  382 |     |      * overflow (when the input is greater than largest uint88).
  383 |     |      *
  384 |     |      * Counterpart to Solidity's `uint88` operator.
  385 |     |      *
  386 |     |      * Requirements:
  387 |     |      *
  388 |     |      * - input must fit into 88 bits
  389 |     |      */
  390 |     |     function toUint88(uint256 value) internal pure returns (uint88) {
  391 |     |         if (value > type(uint88).max) {
  392 |     |             revert SafeCastOverflowedUintDowncast(88, value);
  393 |     |         }
  394 |     |         return uint88(value);
  395 |     |     }
  396 |     | 
  397 |     |     /**
  398 |     |      * @dev Returns the downcasted uint80 from uint256, reverting on
  399 |     |      * overflow (when the input is greater than largest uint80).
  400 |     |      *
  401 |     |      * Counterpart to Solidity's `uint80` operator.
  402 |     |      *
  403 |     |      * Requirements:
  404 |     |      *
  405 |     |      * - input must fit into 80 bits
  406 |     |      */
  407 |     |     function toUint80(uint256 value) internal pure returns (uint80) {
  408 |     |         if (value > type(uint80).max) {
  409 |     |             revert SafeCastOverflowedUintDowncast(80, value);
  410 |     |         }
  411 |     |         return uint80(value);
  412 |     |     }
  413 |     | 
  414 |     |     /**
  415 |     |      * @dev Returns the downcasted uint72 from uint256, reverting on
  416 |     |      * overflow (when the input is greater than largest uint72).
  417 |     |      *
  418 |     |      * Counterpart to Solidity's `uint72` operator.
  419 |     |      *
  420 |     |      * Requirements:
  421 |     |      *
  422 |     |      * - input must fit into 72 bits
  423 |     |      */
  424 |     |     function toUint72(uint256 value) internal pure returns (uint72) {
  425 |     |         if (value > type(uint72).max) {
  426 |     |             revert SafeCastOverflowedUintDowncast(72, value);
  427 |     |         }
  428 |     |         return uint72(value);
  429 |     |     }
  430 |     | 
  431 |     |     /**
  432 |     |      * @dev Returns the downcasted uint64 from uint256, reverting on
  433 |     |      * overflow (when the input is greater than largest uint64).
  434 |     |      *
  435 |     |      * Counterpart to Solidity's `uint64` operator.
  436 |     |      *
  437 |     |      * Requirements:
  438 |     |      *
  439 |     |      * - input must fit into 64 bits
  440 |     |      */
  441 |     |     function toUint64(uint256 value) internal pure returns (uint64) {
  442 |     |         if (value > type(uint64).max) {
  443 |     |             revert SafeCastOverflowedUintDowncast(64, value);
  444 |     |         }
  445 |     |         return uint64(value);
  446 |     |     }
  447 |     | 
  448 |     |     /**
  449 |     |      * @dev Returns the downcasted uint56 from uint256, reverting on
  450 |     |      * overflow (when the input is greater than largest uint56).
  451 |     |      *
  452 |     |      * Counterpart to Solidity's `uint56` operator.
  453 |     |      *
  454 |     |      * Requirements:
  455 |     |      *
  456 |     |      * - input must fit into 56 bits
  457 |     |      */
  458 |     |     function toUint56(uint256 value) internal pure returns (uint56) {
  459 |     |         if (value > type(uint56).max) {
  460 |     |             revert SafeCastOverflowedUintDowncast(56, value);
  461 |     |         }
  462 |     |         return uint56(value);
  463 |     |     }
  464 |     | 
  465 |     |     /**
  466 |     |      * @dev Returns the downcasted uint48 from uint256, reverting on
  467 |     |      * overflow (when the input is greater than largest uint48).
  468 |     |      *
  469 |     |      * Counterpart to Solidity's `uint48` operator.
  470 |     |      *
  471 |     |      * Requirements:
  472 |     |      *
  473 |     |      * - input must fit into 48 bits
  474 |     |      */
  475 |     |     function toUint48(uint256 value) internal pure returns (uint48) {
  476 |     |         if (value > type(uint48).max) {
  477 |     |             revert SafeCastOverflowedUintDowncast(48, value);
  478 |     |         }
  479 |     |         return uint48(value);
  480 |     |     }
  481 |     | 
  482 |     |     /**
  483 |     |      * @dev Returns the downcasted uint40 from uint256, reverting on
  484 |     |      * overflow (when the input is greater than largest uint40).
  485 |     |      *
  486 |     |      * Counterpart to Solidity's `uint40` operator.
  487 |     |      *
  488 |     |      * Requirements:
  489 |     |      *
  490 |     |      * - input must fit into 40 bits
  491 |     |      */
  492 |     |     function toUint40(uint256 value) internal pure returns (uint40) {
  493 |     |         if (value > type(uint40).max) {
  494 |     |             revert SafeCastOverflowedUintDowncast(40, value);
  495 |     |         }
  496 |     |         return uint40(value);
  497 |     |     }
  498 |     | 
  499 |     |     /**
  500 |     |      * @dev Returns the downcasted uint32 from uint256, reverting on
  501 |     |      * overflow (when the input is greater than largest uint32).
  502 |     |      *
  503 |     |      * Counterpart to Solidity's `uint32` operator.
  504 |     |      *
  505 |     |      * Requirements:
  506 |     |      *
  507 |     |      * - input must fit into 32 bits
  508 |     |      */
  509 |     |     function toUint32(uint256 value) internal pure returns (uint32) {
  510 |     |         if (value > type(uint32).max) {
  511 |     |             revert SafeCastOverflowedUintDowncast(32, value);
  512 |     |         }
  513 |     |         return uint32(value);
  514 |     |     }
  515 |     | 
  516 |     |     /**
  517 |     |      * @dev Returns the downcasted uint24 from uint256, reverting on
  518 |     |      * overflow (when the input is greater than largest uint24).
  519 |     |      *
  520 |     |      * Counterpart to Solidity's `uint24` operator.
  521 |     |      *
  522 |     |      * Requirements:
  523 |     |      *
  524 |     |      * - input must fit into 24 bits
  525 |     |      */
  526 |     |     function toUint24(uint256 value) internal pure returns (uint24) {
  527 |     |         if (value > type(uint24).max) {
  528 |     |             revert SafeCastOverflowedUintDowncast(24, value);
  529 |     |         }
  530 |     |         return uint24(value);
  531 |     |     }
  532 |     | 
  533 |     |     /**
  534 |     |      * @dev Returns the downcasted uint16 from uint256, reverting on
  535 |     |      * overflow (when the input is greater than largest uint16).
  536 |     |      *
  537 |     |      * Counterpart to Solidity's `uint16` operator.
  538 |     |      *
  539 |     |      * Requirements:
  540 |     |      *
  541 |     |      * - input must fit into 16 bits
  542 |     |      */
  543 |     |     function toUint16(uint256 value) internal pure returns (uint16) {
  544 |     |         if (value > type(uint16).max) {
  545 |     |             revert SafeCastOverflowedUintDowncast(16, value);
  546 |     |         }
  547 |     |         return uint16(value);
  548 |     |     }
  549 |     | 
  550 |     |     /**
  551 |     |      * @dev Returns the downcasted uint8 from uint256, reverting on
  552 |     |      * overflow (when the input is greater than largest uint8).
  553 |     |      *
  554 |     |      * Counterpart to Solidity's `uint8` operator.
  555 |     |      *
  556 |     |      * Requirements:
  557 |     |      *
  558 |     |      * - input must fit into 8 bits
  559 |     |      */
  560 |     |     function toUint8(uint256 value) internal pure returns (uint8) {
  561 |     |         if (value > type(uint8).max) {
  562 |     |             revert SafeCastOverflowedUintDowncast(8, value);
  563 |     |         }
  564 |     |         return uint8(value);
  565 |     |     }
  566 |     | 
  567 |     |     /**
  568 |     |      * @dev Converts a signed int256 into an unsigned uint256.
  569 |     |      *
  570 |     |      * Requirements:
  571 |     |      *
  572 |     |      * - input must be greater than or equal to 0.
  573 |     |      */
  574 |     |     function toUint256(int256 value) internal pure returns (uint256) {
  575 |     |         if (value < 0) {
  576 |     |             revert SafeCastOverflowedIntToUint(value);
  577 |     |         }
  578 |     |         return uint256(value);
  579 |     |     }
  580 |     | 
  581 |     |     /**
  582 |     |      * @dev Returns the downcasted int248 from int256, reverting on
  583 |     |      * overflow (when the input is less than smallest int248 or
  584 |     |      * greater than largest int248).
  585 |     |      *
  586 |     |      * Counterpart to Solidity's `int248` operator.
  587 |     |      *
  588 |     |      * Requirements:
  589 |     |      *
  590 |     |      * - input must fit into 248 bits
  591 |     |      */
  592 |     |     function toInt248(int256 value) internal pure returns (int248 downcasted) {
  593 |     |         downcasted = int248(value);
  594 |     |         if (downcasted != value) {
  595 |     |             revert SafeCastOverflowedIntDowncast(248, value);
  596 |     |         }
  597 |     |     }
  598 |     | 
  599 |     |     /**
  600 |     |      * @dev Returns the downcasted int240 from int256, reverting on
  601 |     |      * overflow (when the input is less than smallest int240 or
  602 |     |      * greater than largest int240).
  603 |     |      *
  604 |     |      * Counterpart to Solidity's `int240` operator.
  605 |     |      *
  606 |     |      * Requirements:
  607 |     |      *
  608 |     |      * - input must fit into 240 bits
  609 |     |      */
  610 |     |     function toInt240(int256 value) internal pure returns (int240 downcasted) {
  611 |     |         downcasted = int240(value);
  612 |     |         if (downcasted != value) {
  613 |     |             revert SafeCastOverflowedIntDowncast(240, value);
  614 |     |         }
  615 |     |     }
  616 |     | 
  617 |     |     /**
  618 |     |      * @dev Returns the downcasted int232 from int256, reverting on
  619 |     |      * overflow (when the input is less than smallest int232 or
  620 |     |      * greater than largest int232).
  621 |     |      *
  622 |     |      * Counterpart to Solidity's `int232` operator.
  623 |     |      *
  624 |     |      * Requirements:
  625 |     |      *
  626 |     |      * - input must fit into 232 bits
  627 |     |      */
  628 |     |     function toInt232(int256 value) internal pure returns (int232 downcasted) {
  629 |     |         downcasted = int232(value);
  630 |     |         if (downcasted != value) {
  631 |     |             revert SafeCastOverflowedIntDowncast(232, value);
  632 |     |         }
  633 |     |     }
  634 |     | 
  635 |     |     /**
  636 |     |      * @dev Returns the downcasted int224 from int256, reverting on
  637 |     |      * overflow (when the input is less than smallest int224 or
  638 |     |      * greater than largest int224).
  639 |     |      *
  640 |     |      * Counterpart to Solidity's `int224` operator.
  641 |     |      *
  642 |     |      * Requirements:
  643 |     |      *
  644 |     |      * - input must fit into 224 bits
  645 |     |      */
  646 |     |     function toInt224(int256 value) internal pure returns (int224 downcasted) {
  647 |     |         downcasted = int224(value);
  648 |     |         if (downcasted != value) {
  649 |     |             revert SafeCastOverflowedIntDowncast(224, value);
  650 |     |         }
  651 |     |     }
  652 |     | 
  653 |     |     /**
  654 |     |      * @dev Returns the downcasted int216 from int256, reverting on
  655 |     |      * overflow (when the input is less than smallest int216 or
  656 |     |      * greater than largest int216).
  657 |     |      *
  658 |     |      * Counterpart to Solidity's `int216` operator.
  659 |     |      *
  660 |     |      * Requirements:
  661 |     |      *
  662 |     |      * - input must fit into 216 bits
  663 |     |      */
  664 |     |     function toInt216(int256 value) internal pure returns (int216 downcasted) {
  665 |     |         downcasted = int216(value);
  666 |     |         if (downcasted != value) {
  667 |     |             revert SafeCastOverflowedIntDowncast(216, value);
  668 |     |         }
  669 |     |     }
  670 |     | 
  671 |     |     /**
  672 |     |      * @dev Returns the downcasted int208 from int256, reverting on
  673 |     |      * overflow (when the input is less than smallest int208 or
  674 |     |      * greater than largest int208).
  675 |     |      *
  676 |     |      * Counterpart to Solidity's `int208` operator.
  677 |     |      *
  678 |     |      * Requirements:
  679 |     |      *
  680 |     |      * - input must fit into 208 bits
  681 |     |      */
  682 |     |     function toInt208(int256 value) internal pure returns (int208 downcasted) {
  683 |     |         downcasted = int208(value);
  684 |     |         if (downcasted != value) {
  685 |     |             revert SafeCastOverflowedIntDowncast(208, value);
  686 |     |         }
  687 |     |     }
  688 |     | 
  689 |     |     /**
  690 |     |      * @dev Returns the downcasted int200 from int256, reverting on
  691 |     |      * overflow (when the input is less than smallest int200 or
  692 |     |      * greater than largest int200).
  693 |     |      *
  694 |     |      * Counterpart to Solidity's `int200` operator.
  695 |     |      *
  696 |     |      * Requirements:
  697 |     |      *
  698 |     |      * - input must fit into 200 bits
  699 |     |      */
  700 |     |     function toInt200(int256 value) internal pure returns (int200 downcasted) {
  701 |     |         downcasted = int200(value);
  702 |     |         if (downcasted != value) {
  703 |     |             revert SafeCastOverflowedIntDowncast(200, value);
  704 |     |         }
  705 |     |     }
  706 |     | 
  707 |     |     /**
  708 |     |      * @dev Returns the downcasted int192 from int256, reverting on
  709 |     |      * overflow (when the input is less than smallest int192 or
  710 |     |      * greater than largest int192).
  711 |     |      *
  712 |     |      * Counterpart to Solidity's `int192` operator.
  713 |     |      *
  714 |     |      * Requirements:
  715 |     |      *
  716 |     |      * - input must fit into 192 bits
  717 |     |      */
  718 |     |     function toInt192(int256 value) internal pure returns (int192 downcasted) {
  719 |     |         downcasted = int192(value);
  720 |     |         if (downcasted != value) {
  721 |     |             revert SafeCastOverflowedIntDowncast(192, value);
  722 |     |         }
  723 |     |     }
  724 |     | 
  725 |     |     /**
  726 |     |      * @dev Returns the downcasted int184 from int256, reverting on
  727 |     |      * overflow (when the input is less than smallest int184 or
  728 |     |      * greater than largest int184).
  729 |     |      *
  730 |     |      * Counterpart to Solidity's `int184` operator.
  731 |     |      *
  732 |     |      * Requirements:
  733 |     |      *
  734 |     |      * - input must fit into 184 bits
  735 |     |      */
  736 |     |     function toInt184(int256 value) internal pure returns (int184 downcasted) {
  737 |     |         downcasted = int184(value);
  738 |     |         if (downcasted != value) {
  739 |     |             revert SafeCastOverflowedIntDowncast(184, value);
  740 |     |         }
  741 |     |     }
  742 |     | 
  743 |     |     /**
  744 |     |      * @dev Returns the downcasted int176 from int256, reverting on
  745 |     |      * overflow (when the input is less than smallest int176 or
  746 |     |      * greater than largest int176).
  747 |     |      *
  748 |     |      * Counterpart to Solidity's `int176` operator.
  749 |     |      *
  750 |     |      * Requirements:
  751 |     |      *
  752 |     |      * - input must fit into 176 bits
  753 |     |      */
  754 |     |     function toInt176(int256 value) internal pure returns (int176 downcasted) {
  755 |     |         downcasted = int176(value);
  756 |     |         if (downcasted != value) {
  757 |     |             revert SafeCastOverflowedIntDowncast(176, value);
  758 |     |         }
  759 |     |     }
  760 |     | 
  761 |     |     /**
  762 |     |      * @dev Returns the downcasted int168 from int256, reverting on
  763 |     |      * overflow (when the input is less than smallest int168 or
  764 |     |      * greater than largest int168).
  765 |     |      *
  766 |     |      * Counterpart to Solidity's `int168` operator.
  767 |     |      *
  768 |     |      * Requirements:
  769 |     |      *
  770 |     |      * - input must fit into 168 bits
  771 |     |      */
  772 |     |     function toInt168(int256 value) internal pure returns (int168 downcasted) {
  773 |     |         downcasted = int168(value);
  774 |     |         if (downcasted != value) {
  775 |     |             revert SafeCastOverflowedIntDowncast(168, value);
  776 |     |         }
  777 |     |     }
  778 |     | 
  779 |     |     /**
  780 |     |      * @dev Returns the downcasted int160 from int256, reverting on
  781 |     |      * overflow (when the input is less than smallest int160 or
  782 |     |      * greater than largest int160).
  783 |     |      *
  784 |     |      * Counterpart to Solidity's `int160` operator.
  785 |     |      *
  786 |     |      * Requirements:
  787 |     |      *
  788 |     |      * - input must fit into 160 bits
  789 |     |      */
  790 |     |     function toInt160(int256 value) internal pure returns (int160 downcasted) {
  791 |     |         downcasted = int160(value);
  792 |     |         if (downcasted != value) {
  793 |     |             revert SafeCastOverflowedIntDowncast(160, value);
  794 |     |         }
  795 |     |     }
  796 |     | 
  797 |     |     /**
  798 |     |      * @dev Returns the downcasted int152 from int256, reverting on
  799 |     |      * overflow (when the input is less than smallest int152 or
  800 |     |      * greater than largest int152).
  801 |     |      *
  802 |     |      * Counterpart to Solidity's `int152` operator.
  803 |     |      *
  804 |     |      * Requirements:
  805 |     |      *
  806 |     |      * - input must fit into 152 bits
  807 |     |      */
  808 |     |     function toInt152(int256 value) internal pure returns (int152 downcasted) {
  809 |     |         downcasted = int152(value);
  810 |     |         if (downcasted != value) {
  811 |     |             revert SafeCastOverflowedIntDowncast(152, value);
  812 |     |         }
  813 |     |     }
  814 |     | 
  815 |     |     /**
  816 |     |      * @dev Returns the downcasted int144 from int256, reverting on
  817 |     |      * overflow (when the input is less than smallest int144 or
  818 |     |      * greater than largest int144).
  819 |     |      *
  820 |     |      * Counterpart to Solidity's `int144` operator.
  821 |     |      *
  822 |     |      * Requirements:
  823 |     |      *
  824 |     |      * - input must fit into 144 bits
  825 |     |      */
  826 |     |     function toInt144(int256 value) internal pure returns (int144 downcasted) {
  827 |     |         downcasted = int144(value);
  828 |     |         if (downcasted != value) {
  829 |     |             revert SafeCastOverflowedIntDowncast(144, value);
  830 |     |         }
  831 |     |     }
  832 |     | 
  833 |     |     /**
  834 |     |      * @dev Returns the downcasted int136 from int256, reverting on
  835 |     |      * overflow (when the input is less than smallest int136 or
  836 |     |      * greater than largest int136).
  837 |     |      *
  838 |     |      * Counterpart to Solidity's `int136` operator.
  839 |     |      *
  840 |     |      * Requirements:
  841 |     |      *
  842 |     |      * - input must fit into 136 bits
  843 |     |      */
  844 |     |     function toInt136(int256 value) internal pure returns (int136 downcasted) {
  845 |     |         downcasted = int136(value);
  846 |     |         if (downcasted != value) {
  847 |     |             revert SafeCastOverflowedIntDowncast(136, value);
  848 |     |         }
  849 |     |     }
  850 |     | 
  851 |     |     /**
  852 |     |      * @dev Returns the downcasted int128 from int256, reverting on
  853 |     |      * overflow (when the input is less than smallest int128 or
  854 |     |      * greater than largest int128).
  855 |     |      *
  856 |     |      * Counterpart to Solidity's `int128` operator.
  857 |     |      *
  858 |     |      * Requirements:
  859 |     |      *
  860 |     |      * - input must fit into 128 bits
  861 |     |      */
  862 |     |     function toInt128(int256 value) internal pure returns (int128 downcasted) {
  863 |     |         downcasted = int128(value);
  864 |     |         if (downcasted != value) {
  865 |     |             revert SafeCastOverflowedIntDowncast(128, value);
  866 |     |         }
  867 |     |     }
  868 |     | 
  869 |     |     /**
  870 |     |      * @dev Returns the downcasted int120 from int256, reverting on
  871 |     |      * overflow (when the input is less than smallest int120 or
  872 |     |      * greater than largest int120).
  873 |     |      *
  874 |     |      * Counterpart to Solidity's `int120` operator.
  875 |     |      *
  876 |     |      * Requirements:
  877 |     |      *
  878 |     |      * - input must fit into 120 bits
  879 |     |      */
  880 |     |     function toInt120(int256 value) internal pure returns (int120 downcasted) {
  881 |     |         downcasted = int120(value);
  882 |     |         if (downcasted != value) {
  883 |     |             revert SafeCastOverflowedIntDowncast(120, value);
  884 |     |         }
  885 |     |     }
  886 |     | 
  887 |     |     /**
  888 |     |      * @dev Returns the downcasted int112 from int256, reverting on
  889 |     |      * overflow (when the input is less than smallest int112 or
  890 |     |      * greater than largest int112).
  891 |     |      *
  892 |     |      * Counterpart to Solidity's `int112` operator.
  893 |     |      *
  894 |     |      * Requirements:
  895 |     |      *
  896 |     |      * - input must fit into 112 bits
  897 |     |      */
  898 |     |     function toInt112(int256 value) internal pure returns (int112 downcasted) {
  899 |     |         downcasted = int112(value);
  900 |     |         if (downcasted != value) {
  901 |     |             revert SafeCastOverflowedIntDowncast(112, value);
  902 |     |         }
  903 |     |     }
  904 |     | 
  905 |     |     /**
  906 |     |      * @dev Returns the downcasted int104 from int256, reverting on
  907 |     |      * overflow (when the input is less than smallest int104 or
  908 |     |      * greater than largest int104).
  909 |     |      *
  910 |     |      * Counterpart to Solidity's `int104` operator.
  911 |     |      *
  912 |     |      * Requirements:
  913 |     |      *
  914 |     |      * - input must fit into 104 bits
  915 |     |      */
  916 |     |     function toInt104(int256 value) internal pure returns (int104 downcasted) {
  917 |     |         downcasted = int104(value);
  918 |     |         if (downcasted != value) {
  919 |     |             revert SafeCastOverflowedIntDowncast(104, value);
  920 |     |         }
  921 |     |     }
  922 |     | 
  923 |     |     /**
  924 |     |      * @dev Returns the downcasted int96 from int256, reverting on
  925 |     |      * overflow (when the input is less than smallest int96 or
  926 |     |      * greater than largest int96).
  927 |     |      *
  928 |     |      * Counterpart to Solidity's `int96` operator.
  929 |     |      *
  930 |     |      * Requirements:
  931 |     |      *
  932 |     |      * - input must fit into 96 bits
  933 |     |      */
  934 |     |     function toInt96(int256 value) internal pure returns (int96 downcasted) {
  935 |     |         downcasted = int96(value);
  936 |     |         if (downcasted != value) {
  937 |     |             revert SafeCastOverflowedIntDowncast(96, value);
  938 |     |         }
  939 |     |     }
  940 |     | 
  941 |     |     /**
  942 |     |      * @dev Returns the downcasted int88 from int256, reverting on
  943 |     |      * overflow (when the input is less than smallest int88 or
  944 |     |      * greater than largest int88).
  945 |     |      *
  946 |     |      * Counterpart to Solidity's `int88` operator.
  947 |     |      *
  948 |     |      * Requirements:
  949 |     |      *
  950 |     |      * - input must fit into 88 bits
  951 |     |      */
  952 |     |     function toInt88(int256 value) internal pure returns (int88 downcasted) {
  953 |     |         downcasted = int88(value);
  954 |     |         if (downcasted != value) {
  955 |     |             revert SafeCastOverflowedIntDowncast(88, value);
  956 |     |         }
  957 |     |     }
  958 |     | 
  959 |     |     /**
  960 |     |      * @dev Returns the downcasted int80 from int256, reverting on
  961 |     |      * overflow (when the input is less than smallest int80 or
  962 |     |      * greater than largest int80).
  963 |     |      *
  964 |     |      * Counterpart to Solidity's `int80` operator.
  965 |     |      *
  966 |     |      * Requirements:
  967 |     |      *
  968 |     |      * - input must fit into 80 bits
  969 |     |      */
  970 |     |     function toInt80(int256 value) internal pure returns (int80 downcasted) {
  971 |     |         downcasted = int80(value);
  972 |     |         if (downcasted != value) {
  973 |     |             revert SafeCastOverflowedIntDowncast(80, value);
  974 |     |         }
  975 |     |     }
  976 |     | 
  977 |     |     /**
  978 |     |      * @dev Returns the downcasted int72 from int256, reverting on
  979 |     |      * overflow (when the input is less than smallest int72 or
  980 |     |      * greater than largest int72).
  981 |     |      *
  982 |     |      * Counterpart to Solidity's `int72` operator.
  983 |     |      *
  984 |     |      * Requirements:
  985 |     |      *
  986 |     |      * - input must fit into 72 bits
  987 |     |      */
  988 |     |     function toInt72(int256 value) internal pure returns (int72 downcasted) {
  989 |     |         downcasted = int72(value);
  990 |     |         if (downcasted != value) {
  991 |     |             revert SafeCastOverflowedIntDowncast(72, value);
  992 |     |         }
  993 |     |     }
  994 |     | 
  995 |     |     /**
  996 |     |      * @dev Returns the downcasted int64 from int256, reverting on
  997 |     |      * overflow (when the input is less than smallest int64 or
  998 |     |      * greater than largest int64).
  999 |     |      *
 1000 |     |      * Counterpart to Solidity's `int64` operator.
 1001 |     |      *
 1002 |     |      * Requirements:
 1003 |     |      *
 1004 |     |      * - input must fit into 64 bits
 1005 |     |      */
 1006 |     |     function toInt64(int256 value) internal pure returns (int64 downcasted) {
 1007 |     |         downcasted = int64(value);
 1008 |     |         if (downcasted != value) {
 1009 |     |             revert SafeCastOverflowedIntDowncast(64, value);
 1010 |     |         }
 1011 |     |     }
 1012 |     | 
 1013 |     |     /**
 1014 |     |      * @dev Returns the downcasted int56 from int256, reverting on
 1015 |     |      * overflow (when the input is less than smallest int56 or
 1016 |     |      * greater than largest int56).
 1017 |     |      *
 1018 |     |      * Counterpart to Solidity's `int56` operator.
 1019 |     |      *
 1020 |     |      * Requirements:
 1021 |     |      *
 1022 |     |      * - input must fit into 56 bits
 1023 |     |      */
 1024 |     |     function toInt56(int256 value) internal pure returns (int56 downcasted) {
 1025 |     |         downcasted = int56(value);
 1026 |     |         if (downcasted != value) {
 1027 |     |             revert SafeCastOverflowedIntDowncast(56, value);
 1028 |     |         }
 1029 |     |     }
 1030 |     | 
 1031 |     |     /**
 1032 |     |      * @dev Returns the downcasted int48 from int256, reverting on
 1033 |     |      * overflow (when the input is less than smallest int48 or
 1034 |     |      * greater than largest int48).
 1035 |     |      *
 1036 |     |      * Counterpart to Solidity's `int48` operator.
 1037 |     |      *
 1038 |     |      * Requirements:
 1039 |     |      *
 1040 |     |      * - input must fit into 48 bits
 1041 |     |      */
 1042 |     |     function toInt48(int256 value) internal pure returns (int48 downcasted) {
 1043 |     |         downcasted = int48(value);
 1044 |     |         if (downcasted != value) {
 1045 |     |             revert SafeCastOverflowedIntDowncast(48, value);
 1046 |     |         }
 1047 |     |     }
 1048 |     | 
 1049 |     |     /**
 1050 |     |      * @dev Returns the downcasted int40 from int256, reverting on
 1051 |     |      * overflow (when the input is less than smallest int40 or
 1052 |     |      * greater than largest int40).
 1053 |     |      *
 1054 |     |      * Counterpart to Solidity's `int40` operator.
 1055 |     |      *
 1056 |     |      * Requirements:
 1057 |     |      *
 1058 |     |      * - input must fit into 40 bits
 1059 |     |      */
 1060 |     |     function toInt40(int256 value) internal pure returns (int40 downcasted) {
 1061 |     |         downcasted = int40(value);
 1062 |     |         if (downcasted != value) {
 1063 |     |             revert SafeCastOverflowedIntDowncast(40, value);
 1064 |     |         }
 1065 |     |     }
 1066 |     | 
 1067 |     |     /**
 1068 |     |      * @dev Returns the downcasted int32 from int256, reverting on
 1069 |     |      * overflow (when the input is less than smallest int32 or
 1070 |     |      * greater than largest int32).
 1071 |     |      *
 1072 |     |      * Counterpart to Solidity's `int32` operator.
 1073 |     |      *
 1074 |     |      * Requirements:
 1075 |     |      *
 1076 |     |      * - input must fit into 32 bits
 1077 |     |      */
 1078 |     |     function toInt32(int256 value) internal pure returns (int32 downcasted) {
 1079 |     |         downcasted = int32(value);
 1080 |     |         if (downcasted != value) {
 1081 |     |             revert SafeCastOverflowedIntDowncast(32, value);
 1082 |     |         }
 1083 |     |     }
 1084 |     | 
 1085 |     |     /**
 1086 |     |      * @dev Returns the downcasted int24 from int256, reverting on
 1087 |     |      * overflow (when the input is less than smallest int24 or
 1088 |     |      * greater than largest int24).
 1089 |     |      *
 1090 |     |      * Counterpart to Solidity's `int24` operator.
 1091 |     |      *
 1092 |     |      * Requirements:
 1093 |     |      *
 1094 |     |      * - input must fit into 24 bits
 1095 |     |      */
 1096 |     |     function toInt24(int256 value) internal pure returns (int24 downcasted) {
 1097 |     |         downcasted = int24(value);
 1098 |     |         if (downcasted != value) {
 1099 |     |             revert SafeCastOverflowedIntDowncast(24, value);
 1100 |     |         }
 1101 |     |     }
 1102 |     | 
 1103 |     |     /**
 1104 |     |      * @dev Returns the downcasted int16 from int256, reverting on
 1105 |     |      * overflow (when the input is less than smallest int16 or
 1106 |     |      * greater than largest int16).
 1107 |     |      *
 1108 |     |      * Counterpart to Solidity's `int16` operator.
 1109 |     |      *
 1110 |     |      * Requirements:
 1111 |     |      *
 1112 |     |      * - input must fit into 16 bits
 1113 |     |      */
 1114 |     |     function toInt16(int256 value) internal pure returns (int16 downcasted) {
 1115 |     |         downcasted = int16(value);
 1116 |     |         if (downcasted != value) {
 1117 |     |             revert SafeCastOverflowedIntDowncast(16, value);
 1118 |     |         }
 1119 |     |     }
 1120 |     | 
 1121 |     |     /**
 1122 |     |      * @dev Returns the downcasted int8 from int256, reverting on
 1123 |     |      * overflow (when the input is less than smallest int8 or
 1124 |     |      * greater than largest int8).
 1125 |     |      *
 1126 |     |      * Counterpart to Solidity's `int8` operator.
 1127 |     |      *
 1128 |     |      * Requirements:
 1129 |     |      *
 1130 |     |      * - input must fit into 8 bits
 1131 |     |      */
 1132 |     |     function toInt8(int256 value) internal pure returns (int8 downcasted) {
 1133 |     |         downcasted = int8(value);
 1134 |     |         if (downcasted != value) {
 1135 |     |             revert SafeCastOverflowedIntDowncast(8, value);
 1136 |     |         }
 1137 |     |     }
 1138 |     | 
 1139 |     |     /**
 1140 |     |      * @dev Converts an unsigned uint256 into a signed int256.
 1141 |     |      *
 1142 |     |      * Requirements:
 1143 |     |      *
 1144 |     |      * - input must be less than or equal to maxInt256.
 1145 |     |      */
 1146 |     |     function toInt256(uint256 value) internal pure returns (int256) {
 1147 |     |         // Note: Unsafe cast below is okay because `type(int256).max` is guaranteed to be positive
 1148 |     |         if (value > uint256(type(int256).max)) {
 1149 |     |             revert SafeCastOverflowedUintToInt(value);
 1150 |     |         }
 1151 |     |         return int256(value);
 1152 |     |     }
 1153 |     | 
 1154 |     |     /**
 1155 |     |      * @dev Cast a boolean (false or true) to a uint256 (0 or 1) with no jump.
 1156 |     |      */
 1157 |     |     function toUint(bool b) internal pure returns (uint256 u) {
 1158 |     |         assembly ("memory-safe") {
 1159 |     |             u := iszero(iszero(b))
 1160 |     |         }
 1161 |     |     }
 1162 |     | }
 1163 |     | 

/home/phantom/Documents/azemora/azemora-contracts/lib/openzeppelin-contracts/contracts/utils/math/SignedMath.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | // OpenZeppelin Contracts (last updated v5.1.0) (utils/math/SignedMath.sol)
  3 |     | 
  4 |     | pragma solidity ^0.8.20;
  5 |     | 
  6 |     | import {SafeCast} from "./SafeCast.sol";
  7 |     | 
  8 |     | /**
  9 |     |  * @dev Standard signed math utilities missing in the Solidity language.
 10 |     |  */
 11 |     | library SignedMath {
 12 |     |     /**
 13 |     |      * @dev Branchless ternary evaluation for `a ? b : c`. Gas costs are constant.
 14 |     |      *
 15 |     |      * IMPORTANT: This function may reduce bytecode size and consume less gas when used standalone.
 16 |     |      * However, the compiler may optimize Solidity ternary operations (i.e. `a ? b : c`) to only compute
 17 |     |      * one branch when needed, making this function more expensive.
 18 |     |      */
 19 |     |     function ternary(bool condition, int256 a, int256 b) internal pure returns (int256) {
 20 |     |         unchecked {
 21 |     |             // branchless ternary works because:
 22 |     |             // b ^ (a ^ b) == a
 23 |     |             // b ^ 0 == b
 24 |     |             return b ^ ((a ^ b) * int256(SafeCast.toUint(condition)));
 25 |     |         }
 26 |     |     }
 27 |     | 
 28 |     |     /**
 29 |     |      * @dev Returns the largest of two signed numbers.
 30 |     |      */
 31 |     |     function max(int256 a, int256 b) internal pure returns (int256) {
 32 |     |         return ternary(a > b, a, b);
 33 |     |     }
 34 |     | 
 35 |     |     /**
 36 |     |      * @dev Returns the smallest of two signed numbers.
 37 |     |      */
 38 |     |     function min(int256 a, int256 b) internal pure returns (int256) {
 39 |     |         return ternary(a < b, a, b);
 40 |     |     }
 41 |     | 
 42 |     |     /**
 43 |     |      * @dev Returns the average of two signed numbers without overflow.
 44 |     |      * The result is rounded towards zero.
 45 |     |      */
 46 |     |     function average(int256 a, int256 b) internal pure returns (int256) {
 47 |     |         // Formula from the book "Hacker's Delight"
 48 |     |         int256 x = (a & b) + ((a ^ b) >> 1);
 49 |     |         return x + (int256(uint256(x) >> 255) & (a ^ b));
 50 |     |     }
 51 |     | 
 52 |     |     /**
 53 |     |      * @dev Returns the absolute unsigned value of a signed value.
 54 |     |      */
 55 |     |     function abs(int256 n) internal pure returns (uint256) {
 56 |     |         unchecked {
 57 |     |             // Formula from the "Bit Twiddling Hacks" by Sean Eron Anderson.
 58 |     |             // Since `n` is a signed integer, the generated bytecode will use the SAR opcode to perform the right shift,
 59 |     |             // taking advantage of the most significant (or "sign" bit) in two's complement representation.
 60 |     |             // This opcode adds new most significant bits set to the value of the previous most significant bit. As a result,
 61 |     |             // the mask will either be `bytes32(0)` (if n is positive) or `~bytes32(0)` (if n is negative).
 62 |     |             int256 mask = n >> 255;
 63 |     | 
 64 |     |             // A `bytes32(0)` mask leaves the input unchanged, while a `~bytes32(0)` mask complements it.
 65 |     |             return uint256((n + mask) ^ mask);
 66 |     |         }
 67 |     |     }
 68 |     | }
 69 |     | 

/home/phantom/Documents/azemora/azemora-contracts/lib/openzeppelin-contracts/contracts/utils/structs/Checkpoints.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | // OpenZeppelin Contracts (last updated v5.3.0) (utils/structs/Checkpoints.sol)
   3 |     | // This file was procedurally generated from scripts/generate/templates/Checkpoints.js.
   4 |     | 
   5 |     | pragma solidity ^0.8.20;
   6 |     | 
   7 |     | import {Math} from "../math/Math.sol";
   8 |     | 
   9 |     | /**
  10 |     |  * @dev This library defines the `Trace*` struct, for checkpointing values as they change at different points in
  11 |     |  * time, and later looking up past values by block number. See {Votes} as an example.
  12 |     |  *
  13 |     |  * To create a history of checkpoints define a variable type `Checkpoints.Trace*` in your contract, and store a new
  14 |     |  * checkpoint for the current transaction block using the {push} function.
  15 |     |  */
  16 |     | library Checkpoints {
  17 |     |     /**
  18 |     |      * @dev A value was attempted to be inserted on a past checkpoint.
  19 |     |      */
  20 |     |     error CheckpointUnorderedInsertion();
  21 |     | 
  22 |     |     struct Trace224 {
  23 |     |         Checkpoint224[] _checkpoints;
  24 |     |     }
  25 |     | 
  26 |     |     struct Checkpoint224 {
  27 |     |         uint32 _key;
  28 |     |         uint224 _value;
  29 |     |     }
  30 |     | 
  31 |     |     /**
  32 |     |      * @dev Pushes a (`key`, `value`) pair into a Trace224 so that it is stored as the checkpoint.
  33 |     |      *
  34 |     |      * Returns previous value and new value.
  35 |     |      *
  36 |     |      * IMPORTANT: Never accept `key` as a user input, since an arbitrary `type(uint32).max` key set will disable the
  37 |     |      * library.
  38 |     |      */
  39 |     |     function push(
  40 |     |         Trace224 storage self,
  41 |     |         uint32 key,
  42 |     |         uint224 value
  43 |     |     ) internal returns (uint224 oldValue, uint224 newValue) {
  44 |     |         return _insert(self._checkpoints, key, value);
  45 |     |     }
  46 |     | 
  47 |     |     /**
  48 |     |      * @dev Returns the value in the first (oldest) checkpoint with key greater or equal than the search key, or zero if
  49 |     |      * there is none.
  50 |     |      */
  51 |     |     function lowerLookup(Trace224 storage self, uint32 key) internal view returns (uint224) {
  52 |     |         uint256 len = self._checkpoints.length;
  53 |     |         uint256 pos = _lowerBinaryLookup(self._checkpoints, key, 0, len);
  54 |     |         return pos == len ? 0 : _unsafeAccess(self._checkpoints, pos)._value;
  55 |     |     }
  56 |     | 
  57 |     |     /**
  58 |     |      * @dev Returns the value in the last (most recent) checkpoint with key lower or equal than the search key, or zero
  59 |     |      * if there is none.
  60 |     |      */
  61 |     |     function upperLookup(Trace224 storage self, uint32 key) internal view returns (uint224) {
  62 |     |         uint256 len = self._checkpoints.length;
  63 |     |         uint256 pos = _upperBinaryLookup(self._checkpoints, key, 0, len);
  64 |     |         return pos == 0 ? 0 : _unsafeAccess(self._checkpoints, pos - 1)._value;
  65 |     |     }
  66 |     | 
  67 |     |     /**
  68 |     |      * @dev Returns the value in the last (most recent) checkpoint with key lower or equal than the search key, or zero
  69 |     |      * if there is none.
  70 |     |      *
  71 |     |      * NOTE: This is a variant of {upperLookup} that is optimized to find "recent" checkpoint (checkpoints with high
  72 |     |      * keys).
  73 |     |      */
  74 |     |     function upperLookupRecent(Trace224 storage self, uint32 key) internal view returns (uint224) {
  75 |     |         uint256 len = self._checkpoints.length;
  76 |     | 
  77 |     |         uint256 low = 0;
  78 |     |         uint256 high = len;
  79 |     | 
  80 |     |         if (len > 5) {
  81 |     |             uint256 mid = len - Math.sqrt(len);
  82 |     |             if (key < _unsafeAccess(self._checkpoints, mid)._key) {
  83 |     |                 high = mid;
  84 |     |             } else {
  85 |     |                 low = mid + 1;
  86 |     |             }
  87 |     |         }
  88 |     | 
  89 |     |         uint256 pos = _upperBinaryLookup(self._checkpoints, key, low, high);
  90 |     | 
  91 |     |         return pos == 0 ? 0 : _unsafeAccess(self._checkpoints, pos - 1)._value;
  92 |     |     }
  93 |     | 
  94 |     |     /**
  95 |     |      * @dev Returns the value in the most recent checkpoint, or zero if there are no checkpoints.
  96 |     |      */
  97 |     |     function latest(Trace224 storage self) internal view returns (uint224) {
  98 |     |         uint256 pos = self._checkpoints.length;
  99 |     |         return pos == 0 ? 0 : _unsafeAccess(self._checkpoints, pos - 1)._value;
 100 |     |     }
 101 |     | 
 102 |     |     /**
 103 |     |      * @dev Returns whether there is a checkpoint in the structure (i.e. it is not empty), and if so the key and value
 104 |     |      * in the most recent checkpoint.
 105 |     |      */
 106 |     |     function latestCheckpoint(Trace224 storage self) internal view returns (bool exists, uint32 _key, uint224 _value) {
 107 |     |         uint256 pos = self._checkpoints.length;
 108 |     |         if (pos == 0) {
 109 |     |             return (false, 0, 0);
 110 |     |         } else {
 111 |     |             Checkpoint224 storage ckpt = _unsafeAccess(self._checkpoints, pos - 1);
 112 |     |             return (true, ckpt._key, ckpt._value);
 113 |     |         }
 114 |     |     }
 115 |     | 
 116 |     |     /**
 117 |     |      * @dev Returns the number of checkpoints.
 118 |     |      */
 119 |     |     function length(Trace224 storage self) internal view returns (uint256) {
 120 |     |         return self._checkpoints.length;
 121 |     |     }
 122 |     | 
 123 |     |     /**
 124 |     |      * @dev Returns checkpoint at given position.
 125 |     |      */
 126 |     |     function at(Trace224 storage self, uint32 pos) internal view returns (Checkpoint224 memory) {
 127 |     |         return self._checkpoints[pos];
 128 |     |     }
 129 |     | 
 130 |     |     /**
 131 |     |      * @dev Pushes a (`key`, `value`) pair into an ordered list of checkpoints, either by inserting a new checkpoint,
 132 |     |      * or by updating the last one.
 133 |     |      */
 134 |     |     function _insert(
 135 |     |         Checkpoint224[] storage self,
 136 |     |         uint32 key,
 137 |     |         uint224 value
 138 |     |     ) private returns (uint224 oldValue, uint224 newValue) {
 139 |     |         uint256 pos = self.length;
 140 |     | 
 141 |     |         if (pos > 0) {
 142 |     |             Checkpoint224 storage last = _unsafeAccess(self, pos - 1);
 143 |     |             uint32 lastKey = last._key;
 144 |     |             uint224 lastValue = last._value;
 145 |     | 
 146 |     |             // Checkpoint keys must be non-decreasing.
 147 |     |             if (lastKey > key) {
 148 |     |                 revert CheckpointUnorderedInsertion();
 149 |     |             }
 150 |     | 
 151 |     |             // Update or push new checkpoint
 152 |     |             if (lastKey == key) {
 153 |     |                 last._value = value;
 154 |     |             } else {
 155 |     |                 self.push(Checkpoint224({_key: key, _value: value}));
 156 |     |             }
 157 |     |             return (lastValue, value);
 158 |     |         } else {
 159 |     |             self.push(Checkpoint224({_key: key, _value: value}));
 160 |     |             return (0, value);
 161 |     |         }
 162 |     |     }
 163 |     | 
 164 |     |     /**
 165 |     |      * @dev Return the index of the first (oldest) checkpoint with key strictly bigger than the search key, or `high`
 166 |     |      * if there is none. `low` and `high` define a section where to do the search, with inclusive `low` and exclusive
 167 |     |      * `high`.
 168 |     |      *
 169 |     |      * WARNING: `high` should not be greater than the array's length.
 170 |     |      */
 171 |     |     function _upperBinaryLookup(
 172 |     |         Checkpoint224[] storage self,
 173 |     |         uint32 key,
 174 |     |         uint256 low,
 175 |     |         uint256 high
 176 |     |     ) private view returns (uint256) {
 177 |     |         while (low < high) {
 178 |     |             uint256 mid = Math.average(low, high);
 179 |     |             if (_unsafeAccess(self, mid)._key > key) {
 180 |     |                 high = mid;
 181 |     |             } else {
 182 |     |                 low = mid + 1;
 183 |     |             }
 184 |     |         }
 185 |     |         return high;
 186 |     |     }
 187 |     | 
 188 |     |     /**
 189 |     |      * @dev Return the index of the first (oldest) checkpoint with key greater or equal than the search key, or `high`
 190 |     |      * if there is none. `low` and `high` define a section where to do the search, with inclusive `low` and exclusive
 191 |     |      * `high`.
 192 |     |      *
 193 |     |      * WARNING: `high` should not be greater than the array's length.
 194 |     |      */
 195 |     |     function _lowerBinaryLookup(
 196 |     |         Checkpoint224[] storage self,
 197 |     |         uint32 key,
 198 |     |         uint256 low,
 199 |     |         uint256 high
 200 |     |     ) private view returns (uint256) {
 201 |     |         while (low < high) {
 202 |     |             uint256 mid = Math.average(low, high);
 203 |     |             if (_unsafeAccess(self, mid)._key < key) {
 204 |     |                 low = mid + 1;
 205 |     |             } else {
 206 |     |                 high = mid;
 207 |     |             }
 208 |     |         }
 209 |     |         return high;
 210 |     |     }
 211 |     | 
 212 |     |     /**
 213 |     |      * @dev Access an element of the array without performing bounds check. The position is assumed to be within bounds.
 214 |     |      */
 215 |     |     function _unsafeAccess(
 216 |     |         Checkpoint224[] storage self,
 217 |     |         uint256 pos
 218 |     |     ) private pure returns (Checkpoint224 storage result) {
 219 |     |         assembly {
 220 |     |             mstore(0, self.slot)
 221 |     |             result.slot := add(keccak256(0, 0x20), pos)
 222 |     |         }
 223 |     |     }
 224 |     | 
 225 |     |     struct Trace208 {
 226 |     |         Checkpoint208[] _checkpoints;
 227 |     |     }
 228 |     | 
 229 |     |     struct Checkpoint208 {
 230 |     |         uint48 _key;
 231 |     |         uint208 _value;
 232 |     |     }
 233 |     | 
 234 |     |     /**
 235 |     |      * @dev Pushes a (`key`, `value`) pair into a Trace208 so that it is stored as the checkpoint.
 236 |     |      *
 237 |     |      * Returns previous value and new value.
 238 |     |      *
 239 |     |      * IMPORTANT: Never accept `key` as a user input, since an arbitrary `type(uint48).max` key set will disable the
 240 |     |      * library.
 241 |     |      */
 242 |     |     function push(
 243 |     |         Trace208 storage self,
 244 |     |         uint48 key,
 245 |     |         uint208 value
 246 |     |     ) internal returns (uint208 oldValue, uint208 newValue) {
 247 |     |         return _insert(self._checkpoints, key, value);
 248 |     |     }
 249 |     | 
 250 |     |     /**
 251 |     |      * @dev Returns the value in the first (oldest) checkpoint with key greater or equal than the search key, or zero if
 252 |     |      * there is none.
 253 |     |      */
 254 |     |     function lowerLookup(Trace208 storage self, uint48 key) internal view returns (uint208) {
 255 |     |         uint256 len = self._checkpoints.length;
 256 |     |         uint256 pos = _lowerBinaryLookup(self._checkpoints, key, 0, len);
 257 |     |         return pos == len ? 0 : _unsafeAccess(self._checkpoints, pos)._value;
 258 |     |     }
 259 |     | 
 260 |     |     /**
 261 |     |      * @dev Returns the value in the last (most recent) checkpoint with key lower or equal than the search key, or zero
 262 |     |      * if there is none.
 263 |     |      */
 264 |     |     function upperLookup(Trace208 storage self, uint48 key) internal view returns (uint208) {
 265 |     |         uint256 len = self._checkpoints.length;
 266 |     |         uint256 pos = _upperBinaryLookup(self._checkpoints, key, 0, len);
 267 |     |         return pos == 0 ? 0 : _unsafeAccess(self._checkpoints, pos - 1)._value;
 268 |     |     }
 269 |     | 
 270 |     |     /**
 271 |     |      * @dev Returns the value in the last (most recent) checkpoint with key lower or equal than the search key, or zero
 272 |     |      * if there is none.
 273 |     |      *
 274 |     |      * NOTE: This is a variant of {upperLookup} that is optimized to find "recent" checkpoint (checkpoints with high
 275 |     |      * keys).
 276 |     |      */
 277 |     |     function upperLookupRecent(Trace208 storage self, uint48 key) internal view returns (uint208) {
 278 |     |         uint256 len = self._checkpoints.length;
 279 |     | 
 280 |     |         uint256 low = 0;
 281 |     |         uint256 high = len;
 282 |     | 
 283 |     |         if (len > 5) {
 284 |     |             uint256 mid = len - Math.sqrt(len);
 285 |     |             if (key < _unsafeAccess(self._checkpoints, mid)._key) {
 286 |     |                 high = mid;
 287 |     |             } else {
 288 |     |                 low = mid + 1;
 289 |     |             }
 290 |     |         }
 291 |     | 
 292 |     |         uint256 pos = _upperBinaryLookup(self._checkpoints, key, low, high);
 293 |     | 
 294 |     |         return pos == 0 ? 0 : _unsafeAccess(self._checkpoints, pos - 1)._value;
 295 |     |     }
 296 |     | 
 297 |     |     /**
 298 |     |      * @dev Returns the value in the most recent checkpoint, or zero if there are no checkpoints.
 299 |     |      */
 300 |     |     function latest(Trace208 storage self) internal view returns (uint208) {
 301 |     |         uint256 pos = self._checkpoints.length;
 302 |     |         return pos == 0 ? 0 : _unsafeAccess(self._checkpoints, pos - 1)._value;
 303 |     |     }
 304 |     | 
 305 |     |     /**
 306 |     |      * @dev Returns whether there is a checkpoint in the structure (i.e. it is not empty), and if so the key and value
 307 |     |      * in the most recent checkpoint.
 308 |     |      */
 309 |     |     function latestCheckpoint(Trace208 storage self) internal view returns (bool exists, uint48 _key, uint208 _value) {
 310 |     |         uint256 pos = self._checkpoints.length;
 311 |     |         if (pos == 0) {
 312 |     |             return (false, 0, 0);
 313 |     |         } else {
 314 |     |             Checkpoint208 storage ckpt = _unsafeAccess(self._checkpoints, pos - 1);
 315 |     |             return (true, ckpt._key, ckpt._value);
 316 |     |         }
 317 |     |     }
 318 |     | 
 319 |     |     /**
 320 |     |      * @dev Returns the number of checkpoints.
 321 |     |      */
 322 |     |     function length(Trace208 storage self) internal view returns (uint256) {
 323 |     |         return self._checkpoints.length;
 324 |     |     }
 325 |     | 
 326 |     |     /**
 327 |     |      * @dev Returns checkpoint at given position.
 328 |     |      */
 329 |     |     function at(Trace208 storage self, uint32 pos) internal view returns (Checkpoint208 memory) {
 330 |     |         return self._checkpoints[pos];
 331 |     |     }
 332 |     | 
 333 |     |     /**
 334 |     |      * @dev Pushes a (`key`, `value`) pair into an ordered list of checkpoints, either by inserting a new checkpoint,
 335 |     |      * or by updating the last one.
 336 |     |      */
 337 |     |     function _insert(
 338 |     |         Checkpoint208[] storage self,
 339 |     |         uint48 key,
 340 |     |         uint208 value
 341 |     |     ) private returns (uint208 oldValue, uint208 newValue) {
 342 |     |         uint256 pos = self.length;
 343 |     | 
 344 |     |         if (pos > 0) {
 345 |     |             Checkpoint208 storage last = _unsafeAccess(self, pos - 1);
 346 |     |             uint48 lastKey = last._key;
 347 |     |             uint208 lastValue = last._value;
 348 |     | 
 349 |     |             // Checkpoint keys must be non-decreasing.
 350 |     |             if (lastKey > key) {
 351 |     |                 revert CheckpointUnorderedInsertion();
 352 |     |             }
 353 |     | 
 354 |     |             // Update or push new checkpoint
 355 |     |             if (lastKey == key) {
 356 |     |                 last._value = value;
 357 |     |             } else {
 358 |     |                 self.push(Checkpoint208({_key: key, _value: value}));
 359 |     |             }
 360 |     |             return (lastValue, value);
 361 |     |         } else {
 362 |     |             self.push(Checkpoint208({_key: key, _value: value}));
 363 |     |             return (0, value);
 364 |     |         }
 365 |     |     }
 366 |     | 
 367 |     |     /**
 368 |     |      * @dev Return the index of the first (oldest) checkpoint with key strictly bigger than the search key, or `high`
 369 |     |      * if there is none. `low` and `high` define a section where to do the search, with inclusive `low` and exclusive
 370 |     |      * `high`.
 371 |     |      *
 372 |     |      * WARNING: `high` should not be greater than the array's length.
 373 |     |      */
 374 |     |     function _upperBinaryLookup(
 375 |     |         Checkpoint208[] storage self,
 376 |     |         uint48 key,
 377 |     |         uint256 low,
 378 |     |         uint256 high
 379 |     |     ) private view returns (uint256) {
 380 |     |         while (low < high) {
 381 |     |             uint256 mid = Math.average(low, high);
 382 |     |             if (_unsafeAccess(self, mid)._key > key) {
 383 |     |                 high = mid;
 384 |     |             } else {
 385 |     |                 low = mid + 1;
 386 |     |             }
 387 |     |         }
 388 |     |         return high;
 389 |     |     }
 390 |     | 
 391 |     |     /**
 392 |     |      * @dev Return the index of the first (oldest) checkpoint with key greater or equal than the search key, or `high`
 393 |     |      * if there is none. `low` and `high` define a section where to do the search, with inclusive `low` and exclusive
 394 |     |      * `high`.
 395 |     |      *
 396 |     |      * WARNING: `high` should not be greater than the array's length.
 397 |     |      */
 398 |     |     function _lowerBinaryLookup(
 399 |     |         Checkpoint208[] storage self,
 400 |     |         uint48 key,
 401 |     |         uint256 low,
 402 |     |         uint256 high
 403 |     |     ) private view returns (uint256) {
 404 |     |         while (low < high) {
 405 |     |             uint256 mid = Math.average(low, high);
 406 |     |             if (_unsafeAccess(self, mid)._key < key) {
 407 |     |                 low = mid + 1;
 408 |     |             } else {
 409 |     |                 high = mid;
 410 |     |             }
 411 |     |         }
 412 |     |         return high;
 413 |     |     }
 414 |     | 
 415 |     |     /**
 416 |     |      * @dev Access an element of the array without performing bounds check. The position is assumed to be within bounds.
 417 |     |      */
 418 |     |     function _unsafeAccess(
 419 |     |         Checkpoint208[] storage self,
 420 |     |         uint256 pos
 421 |     |     ) private pure returns (Checkpoint208 storage result) {
 422 |     |         assembly {
 423 |     |             mstore(0, self.slot)
 424 |     |             result.slot := add(keccak256(0, 0x20), pos)
 425 |     |         }
 426 |     |     }
 427 |     | 
 428 |     |     struct Trace160 {
 429 |     |         Checkpoint160[] _checkpoints;
 430 |     |     }
 431 |     | 
 432 |     |     struct Checkpoint160 {
 433 |     |         uint96 _key;
 434 |     |         uint160 _value;
 435 |     |     }
 436 |     | 
 437 |     |     /**
 438 |     |      * @dev Pushes a (`key`, `value`) pair into a Trace160 so that it is stored as the checkpoint.
 439 |     |      *
 440 |     |      * Returns previous value and new value.
 441 |     |      *
 442 |     |      * IMPORTANT: Never accept `key` as a user input, since an arbitrary `type(uint96).max` key set will disable the
 443 |     |      * library.
 444 |     |      */
 445 |     |     function push(
 446 |     |         Trace160 storage self,
 447 |     |         uint96 key,
 448 |     |         uint160 value
 449 |     |     ) internal returns (uint160 oldValue, uint160 newValue) {
 450 |     |         return _insert(self._checkpoints, key, value);
 451 |     |     }
 452 |     | 
 453 |     |     /**
 454 |     |      * @dev Returns the value in the first (oldest) checkpoint with key greater or equal than the search key, or zero if
 455 |     |      * there is none.
 456 |     |      */
 457 |     |     function lowerLookup(Trace160 storage self, uint96 key) internal view returns (uint160) {
 458 |     |         uint256 len = self._checkpoints.length;
 459 |     |         uint256 pos = _lowerBinaryLookup(self._checkpoints, key, 0, len);
 460 |     |         return pos == len ? 0 : _unsafeAccess(self._checkpoints, pos)._value;
 461 |     |     }
 462 |     | 
 463 |     |     /**
 464 |     |      * @dev Returns the value in the last (most recent) checkpoint with key lower or equal than the search key, or zero
 465 |     |      * if there is none.
 466 |     |      */
 467 |     |     function upperLookup(Trace160 storage self, uint96 key) internal view returns (uint160) {
 468 |     |         uint256 len = self._checkpoints.length;
 469 |     |         uint256 pos = _upperBinaryLookup(self._checkpoints, key, 0, len);
 470 |     |         return pos == 0 ? 0 : _unsafeAccess(self._checkpoints, pos - 1)._value;
 471 |     |     }
 472 |     | 
 473 |     |     /**
 474 |     |      * @dev Returns the value in the last (most recent) checkpoint with key lower or equal than the search key, or zero
 475 |     |      * if there is none.
 476 |     |      *
 477 |     |      * NOTE: This is a variant of {upperLookup} that is optimized to find "recent" checkpoint (checkpoints with high
 478 |     |      * keys).
 479 |     |      */
 480 |     |     function upperLookupRecent(Trace160 storage self, uint96 key) internal view returns (uint160) {
 481 |     |         uint256 len = self._checkpoints.length;
 482 |     | 
 483 |     |         uint256 low = 0;
 484 |     |         uint256 high = len;
 485 |     | 
 486 |     |         if (len > 5) {
 487 |     |             uint256 mid = len - Math.sqrt(len);
 488 |     |             if (key < _unsafeAccess(self._checkpoints, mid)._key) {
 489 |     |                 high = mid;
 490 |     |             } else {
 491 |     |                 low = mid + 1;
 492 |     |             }
 493 |     |         }
 494 |     | 
 495 |     |         uint256 pos = _upperBinaryLookup(self._checkpoints, key, low, high);
 496 |     | 
 497 |     |         return pos == 0 ? 0 : _unsafeAccess(self._checkpoints, pos - 1)._value;
 498 |     |     }
 499 |     | 
 500 |     |     /**
 501 |     |      * @dev Returns the value in the most recent checkpoint, or zero if there are no checkpoints.
 502 |     |      */
 503 |     |     function latest(Trace160 storage self) internal view returns (uint160) {
 504 |     |         uint256 pos = self._checkpoints.length;
 505 |     |         return pos == 0 ? 0 : _unsafeAccess(self._checkpoints, pos - 1)._value;
 506 |     |     }
 507 |     | 
 508 |     |     /**
 509 |     |      * @dev Returns whether there is a checkpoint in the structure (i.e. it is not empty), and if so the key and value
 510 |     |      * in the most recent checkpoint.
 511 |     |      */
 512 |     |     function latestCheckpoint(Trace160 storage self) internal view returns (bool exists, uint96 _key, uint160 _value) {
 513 |     |         uint256 pos = self._checkpoints.length;
 514 |     |         if (pos == 0) {
 515 |     |             return (false, 0, 0);
 516 |     |         } else {
 517 |     |             Checkpoint160 storage ckpt = _unsafeAccess(self._checkpoints, pos - 1);
 518 |     |             return (true, ckpt._key, ckpt._value);
 519 |     |         }
 520 |     |     }
 521 |     | 
 522 |     |     /**
 523 |     |      * @dev Returns the number of checkpoints.
 524 |     |      */
 525 |     |     function length(Trace160 storage self) internal view returns (uint256) {
 526 |     |         return self._checkpoints.length;
 527 |     |     }
 528 |     | 
 529 |     |     /**
 530 |     |      * @dev Returns checkpoint at given position.
 531 |     |      */
 532 |     |     function at(Trace160 storage self, uint32 pos) internal view returns (Checkpoint160 memory) {
 533 |     |         return self._checkpoints[pos];
 534 |     |     }
 535 |     | 
 536 |     |     /**
 537 |     |      * @dev Pushes a (`key`, `value`) pair into an ordered list of checkpoints, either by inserting a new checkpoint,
 538 |     |      * or by updating the last one.
 539 |     |      */
 540 |     |     function _insert(
 541 |     |         Checkpoint160[] storage self,
 542 |     |         uint96 key,
 543 |     |         uint160 value
 544 |     |     ) private returns (uint160 oldValue, uint160 newValue) {
 545 |     |         uint256 pos = self.length;
 546 |     | 
 547 |     |         if (pos > 0) {
 548 |     |             Checkpoint160 storage last = _unsafeAccess(self, pos - 1);
 549 |     |             uint96 lastKey = last._key;
 550 |     |             uint160 lastValue = last._value;
 551 |     | 
 552 |     |             // Checkpoint keys must be non-decreasing.
 553 |     |             if (lastKey > key) {
 554 |     |                 revert CheckpointUnorderedInsertion();
 555 |     |             }
 556 |     | 
 557 |     |             // Update or push new checkpoint
 558 |     |             if (lastKey == key) {
 559 |     |                 last._value = value;
 560 |     |             } else {
 561 |     |                 self.push(Checkpoint160({_key: key, _value: value}));
 562 |     |             }
 563 |     |             return (lastValue, value);
 564 |     |         } else {
 565 |     |             self.push(Checkpoint160({_key: key, _value: value}));
 566 |     |             return (0, value);
 567 |     |         }
 568 |     |     }
 569 |     | 
 570 |     |     /**
 571 |     |      * @dev Return the index of the first (oldest) checkpoint with key strictly bigger than the search key, or `high`
 572 |     |      * if there is none. `low` and `high` define a section where to do the search, with inclusive `low` and exclusive
 573 |     |      * `high`.
 574 |     |      *
 575 |     |      * WARNING: `high` should not be greater than the array's length.
 576 |     |      */
 577 |     |     function _upperBinaryLookup(
 578 |     |         Checkpoint160[] storage self,
 579 |     |         uint96 key,
 580 |     |         uint256 low,
 581 |     |         uint256 high
 582 |     |     ) private view returns (uint256) {
 583 |     |         while (low < high) {
 584 |     |             uint256 mid = Math.average(low, high);
 585 |     |             if (_unsafeAccess(self, mid)._key > key) {
 586 |     |                 high = mid;
 587 |     |             } else {
 588 |     |                 low = mid + 1;
 589 |     |             }
 590 |     |         }
 591 |     |         return high;
 592 |     |     }
 593 |     | 
 594 |     |     /**
 595 |     |      * @dev Return the index of the first (oldest) checkpoint with key greater or equal than the search key, or `high`
 596 |     |      * if there is none. `low` and `high` define a section where to do the search, with inclusive `low` and exclusive
 597 |     |      * `high`.
 598 |     |      *
 599 |     |      * WARNING: `high` should not be greater than the array's length.
 600 |     |      */
 601 |     |     function _lowerBinaryLookup(
 602 |     |         Checkpoint160[] storage self,
 603 |     |         uint96 key,
 604 |     |         uint256 low,
 605 |     |         uint256 high
 606 |     |     ) private view returns (uint256) {
 607 |     |         while (low < high) {
 608 |     |             uint256 mid = Math.average(low, high);
 609 |     |             if (_unsafeAccess(self, mid)._key < key) {
 610 |     |                 low = mid + 1;
 611 |     |             } else {
 612 |     |                 high = mid;
 613 |     |             }
 614 |     |         }
 615 |     |         return high;
 616 |     |     }
 617 |     | 
 618 |     |     /**
 619 |     |      * @dev Access an element of the array without performing bounds check. The position is assumed to be within bounds.
 620 |     |      */
 621 |     |     function _unsafeAccess(
 622 |     |         Checkpoint160[] storage self,
 623 |     |         uint256 pos
 624 |     |     ) private pure returns (Checkpoint160 storage result) {
 625 |     |         assembly {
 626 |     |             mstore(0, self.slot)
 627 |     |             result.slot := add(keccak256(0, 0x20), pos)
 628 |     |         }
 629 |     |     }
 630 |     | }
 631 |     | 

/home/phantom/Documents/azemora/azemora-contracts/lib/openzeppelin-contracts/contracts/utils/structs/DoubleEndedQueue.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | // OpenZeppelin Contracts (last updated v5.1.0) (utils/structs/DoubleEndedQueue.sol)
   3 |     | pragma solidity ^0.8.20;
   4 |     | 
   5 |     | import {Panic} from "../Panic.sol";
   6 |     | 
   7 |     | /**
   8 |     |  * @dev A sequence of items with the ability to efficiently push and pop items (i.e. insert and remove) on both ends of
   9 |     |  * the sequence (called front and back). Among other access patterns, it can be used to implement efficient LIFO and
  10 |     |  * FIFO queues. Storage use is optimized, and all operations are O(1) constant time. This includes {clear}, given that
  11 |     |  * the existing queue contents are left in storage.
  12 |     |  *
  13 |     |  * The struct is called `Bytes32Deque`. Other types can be cast to and from `bytes32`. This data structure can only be
  14 |     |  * used in storage, and not in memory.
  15 |     |  * ```solidity
  16 |     |  * DoubleEndedQueue.Bytes32Deque queue;
  17 |     |  * ```
  18 |     |  */
  19 |     | library DoubleEndedQueue {
  20 |     |     /**
  21 |     |      * @dev Indices are 128 bits so begin and end are packed in a single storage slot for efficient access.
  22 |     |      *
  23 | *   |      * Struct members have an underscore prefix indicating that they are "private" and should not be read or written to
  24 | *   |      * directly. Use the functions provided below instead. Modifying the struct manually may violate assumptions and
  25 | *   |      * lead to unexpected behavior.
  26 | *   |      *
  27 | *   |      * The first item is at data[begin] and the last item is at data[end - 1]. This range can wrap around.
  28 | *   |      */
  29 | *   |     struct Bytes32Deque {
  30 |     |         uint128 _begin;
  31 |     |         uint128 _end;
  32 |     |         mapping(uint128 index => bytes32) _data;
  33 |     |     }
  34 |     | 
  35 |     |     /**
  36 |     |      * @dev Inserts an item at the end of the queue.
  37 |     |      *
  38 | *   |      * Reverts with {Panic-RESOURCE_ERROR} if the queue is full.
  39 | *   |      */
  40 |     |     function pushBack(Bytes32Deque storage deque, bytes32 value) internal {
  41 | *   |         unchecked {
  42 |     |             uint128 backIndex = deque._end;
  43 |     |             if (backIndex + 1 == deque._begin) Panic.panic(Panic.RESOURCE_ERROR);
  44 |     |             deque._data[backIndex] = value;
  45 |     |             deque._end = backIndex + 1;
  46 |     |         }
  47 |     |     }
  48 |     | 
  49 |     |     /**
  50 |     |      * @dev Removes the item at the end of the queue and returns it.
  51 |     |      *
  52 |     |      * Reverts with {Panic-EMPTY_ARRAY_POP} if the queue is empty.
  53 |     |      */
  54 |     |     function popBack(Bytes32Deque storage deque) internal returns (bytes32 value) {
  55 |     |         unchecked {
  56 |     |             uint128 backIndex = deque._end;
  57 |     |             if (backIndex == deque._begin) Panic.panic(Panic.EMPTY_ARRAY_POP);
  58 |     |             --backIndex;
  59 |     |             value = deque._data[backIndex];
  60 |     |             delete deque._data[backIndex];
  61 |     |             deque._end = backIndex;
  62 |     |         }
  63 |     |     }
  64 |     | 
  65 |     |     /**
  66 |     |      * @dev Inserts an item at the beginning of the queue.
  67 |     |      *
  68 |     |      * Reverts with {Panic-RESOURCE_ERROR} if the queue is full.
  69 |     |      */
  70 |     |     function pushFront(Bytes32Deque storage deque, bytes32 value) internal {
  71 |     |         unchecked {
  72 |     |             uint128 frontIndex = deque._begin - 1;
  73 |     |             if (frontIndex == deque._end) Panic.panic(Panic.RESOURCE_ERROR);
  74 |     |             deque._data[frontIndex] = value;
  75 |     |             deque._begin = frontIndex;
  76 |     |         }
  77 |     |     }
  78 |     | 
  79 |     |     /**
  80 |     |      * @dev Removes the item at the beginning of the queue and returns it.
  81 |     |      *
  82 |     |      * Reverts with {Panic-EMPTY_ARRAY_POP} if the queue is empty.
  83 |     |      */
  84 |     |     function popFront(Bytes32Deque storage deque) internal returns (bytes32 value) {
  85 |     |         unchecked {
  86 |     |             uint128 frontIndex = deque._begin;
  87 |     |             if (frontIndex == deque._end) Panic.panic(Panic.EMPTY_ARRAY_POP);
  88 |     |             value = deque._data[frontIndex];
  89 |     |             delete deque._data[frontIndex];
  90 |     |             deque._begin = frontIndex + 1;
  91 |     |         }
  92 |     |     }
  93 |     | 
  94 |     |     /**
  95 |     |      * @dev Returns the item at the beginning of the queue.
  96 |     |      *
  97 |     |      * Reverts with {Panic-ARRAY_OUT_OF_BOUNDS} if the queue is empty.
  98 |     |      */
  99 |     |     function front(Bytes32Deque storage deque) internal view returns (bytes32 value) {
 100 |     |         if (empty(deque)) Panic.panic(Panic.ARRAY_OUT_OF_BOUNDS);
 101 |     |         return deque._data[deque._begin];
 102 |     |     }
 103 |     | 
 104 |     |     /**
 105 |     |      * @dev Returns the item at the end of the queue.
 106 |     |      *
 107 |     |      * Reverts with {Panic-ARRAY_OUT_OF_BOUNDS} if the queue is empty.
 108 |     |      */
 109 |     |     function back(Bytes32Deque storage deque) internal view returns (bytes32 value) {
 110 |     |         if (empty(deque)) Panic.panic(Panic.ARRAY_OUT_OF_BOUNDS);
 111 |     |         unchecked {
 112 |     |             return deque._data[deque._end - 1];
 113 |     |         }
 114 |     |     }
 115 |     | 
 116 |     |     /**
 117 |     |      * @dev Return the item at a position in the queue given by `index`, with the first item at 0 and last item at
 118 |     |      * `length(deque) - 1`.
 119 |     |      *
 120 |     |      * Reverts with {Panic-ARRAY_OUT_OF_BOUNDS} if the index is out of bounds.
 121 |     |      */
 122 |     |     function at(Bytes32Deque storage deque, uint256 index) internal view returns (bytes32 value) {
 123 |     |         if (index >= length(deque)) Panic.panic(Panic.ARRAY_OUT_OF_BOUNDS);
 124 |     |         // By construction, length is a uint128, so the check above ensures that index can be safely downcast to uint128
 125 |     |         unchecked {
 126 |     |             return deque._data[deque._begin + uint128(index)];
 127 |     |         }
 128 |     |     }
 129 |     | 
 130 |     |     /**
 131 |     |      * @dev Resets the queue back to being empty.
 132 |     |      *
 133 |     |      * NOTE: The current items are left behind in storage. This does not affect the functioning of the queue, but misses
 134 |     |      * out on potential gas refunds.
 135 |     |      */
 136 |     |     function clear(Bytes32Deque storage deque) internal {
 137 |     |         deque._begin = 0;
 138 |     |         deque._end = 0;
 139 |     |     }
 140 |     | 
 141 |     |     /**
 142 |     |      * @dev Returns the number of items in the queue.
 143 |     |      */
 144 |     |     function length(Bytes32Deque storage deque) internal view returns (uint256) {
 145 |     |         unchecked {
 146 |     |             return uint256(deque._end - deque._begin);
 147 |     |         }
 148 |     |     }
 149 |     | 
 150 |     |     /**
 151 |     |      * @dev Returns true if the queue is empty.
 152 |     |      */
 153 |     |     function empty(Bytes32Deque storage deque) internal view returns (bool) {
 154 |     |         return deque._end == deque._begin;
 155 |     |     }
 156 |     | }
 157 |     | 

/home/phantom/Documents/azemora/azemora-contracts/lib/openzeppelin-contracts/contracts/utils/types/Time.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | // OpenZeppelin Contracts (last updated v5.1.0) (utils/types/Time.sol)
   3 |     | 
   4 |     | pragma solidity ^0.8.20;
   5 |     | 
   6 |     | import {Math} from "../math/Math.sol";
   7 |     | import {SafeCast} from "../math/SafeCast.sol";
   8 |     | 
   9 |     | /**
  10 |     |  * @dev This library provides helpers for manipulating time-related objects.
  11 |     |  *
  12 |     |  * It uses the following types:
  13 |     |  * - `uint48` for timepoints
  14 |     |  * - `uint32` for durations
  15 |     |  *
  16 |     |  * While the library doesn't provide specific types for timepoints and duration, it does provide:
  17 |     |  * - a `Delay` type to represent duration that can be programmed to change value automatically at a given point
  18 |     |  * - additional helper functions
  19 |     |  */
  20 |     | library Time {
  21 |     |     using Time for *;
  22 |     | 
  23 |     |     /**
  24 |     |      * @dev Get the block timestamp as a Timepoint.
  25 |     |      */
  26 |     |     function timestamp() internal view returns (uint48) {
  27 |     |         return SafeCast.toUint48(block.timestamp);
  28 |     |     }
  29 |     | 
  30 |     |     /**
  31 |     |      * @dev Get the block number as a Timepoint.
  32 |     |      */
  33 |     |     function blockNumber() internal view returns (uint48) {
  34 |     |         return SafeCast.toUint48(block.number);
  35 |     |     }
  36 |     | 
  37 |     |     // ==================================================== Delay =====================================================
  38 |     |     /**
  39 |     |      * @dev A `Delay` is a uint32 duration that can be programmed to change value automatically at a given point in the
  40 |     |      * future. The "effect" timepoint describes when the transitions happens from the "old" value to the "new" value.
  41 |     |      * This allows updating the delay applied to some operation while keeping some guarantees.
  42 |     |      *
  43 | *   |      * In particular, the {update} function guarantees that if the delay is reduced, the old delay still applies for
  44 | *   |      * some time. For example if the delay is currently 7 days to do an upgrade, the admin should not be able to set
  45 | *   |      * the delay to 0 and upgrade immediately. If the admin wants to reduce the delay, the old delay (7 days) should
  46 |     |      * still apply for some time.
  47 |     |      *
  48 |     |      *
  49 |     |      * The `Delay` type is 112 bits long, and packs the following:
  50 |     |      *
  51 |     |      * ```
  52 |     |      *   | [uint48]: effect date (timepoint)
  53 |     |      *   |           | [uint32]: value before (duration)
  54 |     |      *                      [uint32]: value after (duration)
  55 |     |      * 0xAAAAAAAAAAAABBBBBBBBCCCCCCCC
  56 |     |      * ```
  57 |     |      *
  58 |     |      * NOTE: The {get} and {withUpdate} functions operate using timestamps. Block number based delays are not currently
  59 |     |      * supported.
  60 |     |      */
  61 |     |     type Delay is uint112;
  62 |     | 
  63 |     |     /**
  64 |     |      * @dev Wrap a duration into a Delay to add the one-step "update in the future" feature
  65 |     |      */
  66 |     |     function toDelay(uint32 duration) internal pure returns (Delay) {
  67 |     |         return Delay.wrap(duration);
  68 |     |     }
  69 |     | 
  70 |     |     /**
  71 |     |      * @dev Get the value at a given timepoint plus the pending value and effect timepoint if there is a scheduled
  72 | *   |      * change after this timepoint. If the effect timepoint is 0, then the pending value should not be considered.
  73 |     |      */
  74 |     |     function _getFullAt(
  75 |     |         Delay self,
  76 | *   |         uint48 timepoint
  77 | *   |     ) private pure returns (uint32 valueBefore, uint32 valueAfter, uint48 effect) {
  78 | *   |         (valueBefore, valueAfter, effect) = self.unpack();
  79 |     |         return effect <= timepoint ? (valueAfter, 0, 0) : (valueBefore, valueAfter, effect);
  80 |     |     }
  81 |     | 
  82 |     |     /**
  83 |     |      * @dev Get the current value plus the pending value and effect timepoint if there is a scheduled change. If the
  84 |     |      * effect timepoint is 0, then the pending value should not be considered.
  85 |     |      */
  86 |     |     function getFull(Delay self) internal view returns (uint32 valueBefore, uint32 valueAfter, uint48 effect) {
  87 |     |         return _getFullAt(self, timestamp());
  88 |     |     }
  89 |     | 
  90 | *   |     /**
  91 |     |      * @dev Get the current value.
  92 |     |      */
  93 |     |     function get(Delay self) internal view returns (uint32) {
  94 |     |         (uint32 delay, , ) = self.getFull();
  95 |     |         return delay;
  96 |     |     }
  97 |     | 
  98 |     |     /**
  99 |     |      * @dev Update a Delay object so that it takes a new duration after a timepoint that is automatically computed to
 100 | *   |      * enforce the old delay at the moment of the update. Returns the updated Delay object and the timestamp when the
 101 |     |      * new delay becomes effective.
 102 |     |      */
 103 | *   |     function withUpdate(
 104 | *   |         Delay self,
 105 | *   |         uint32 newValue,
 106 |     |         uint32 minSetback
 107 |     |     ) internal view returns (Delay updatedDelay, uint48 effect) {
 108 |     |         uint32 value = self.get();
 109 |     |         uint32 setback = uint32(Math.max(minSetback, value > newValue ? value - newValue : 0));
 110 |     |         effect = timestamp() + setback;
 111 |     |         return (pack(value, newValue, effect), effect);
 112 |     |     }
 113 |     | 
 114 |     |     /**
 115 |     |      * @dev Split a delay into its components: valueBefore, valueAfter and effect (transition timepoint).
 116 |     |      */
 117 |     |     function unpack(Delay self) internal pure returns (uint32 valueBefore, uint32 valueAfter, uint48 effect) {
 118 | *   |         uint112 raw = Delay.unwrap(self);
 119 |     | 
 120 |     |         valueAfter = uint32(raw);
 121 | *   |         valueBefore = uint32(raw >> 32);
 122 |     |         effect = uint48(raw >> 64);
 123 |     | 
 124 | *   |         return (valueBefore, valueAfter, effect);
 125 |     |     }
 126 |     | 
 127 | *   |     /**
 128 | *   |      * @dev pack the components into a Delay object.
 129 |     |      */
 130 |     |     function pack(uint32 valueBefore, uint32 valueAfter, uint48 effect) internal pure returns (Delay) {
 131 |     |         return Delay.wrap((uint112(effect) << 64) | (uint112(valueBefore) << 32) | uint112(valueAfter));
 132 |     |     }
 133 |     | }
 134 | *   | 

/home/phantom/Documents/azemora/azemora-contracts/lib/openzeppelin-contracts-upgradeable/contracts/access/AccessControlUpgradeable.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | // OpenZeppelin Contracts (last updated v5.3.0) (access/AccessControl.sol)
   3 |     | 
   4 |     | pragma solidity ^0.8.20;
   5 |     | 
   6 |     | import {IAccessControl} from "@openzeppelin/contracts/access/IAccessControl.sol";
   7 |     | import {ContextUpgradeable} from "../utils/ContextUpgradeable.sol";
   8 |     | import {IERC165} from "@openzeppelin/contracts/utils/introspection/IERC165.sol";
   9 |     | import {ERC165Upgradeable} from "../utils/introspection/ERC165Upgradeable.sol";
  10 |     | import {Initializable} from "../proxy/utils/Initializable.sol";
  11 |     | 
  12 |     | /**
  13 |     |  * @dev Contract module that allows children to implement role-based access
  14 |     |  * control mechanisms. This is a lightweight version that doesn't allow enumerating role
  15 |     |  * members except through off-chain means by accessing the contract event logs. Some
  16 |     |  * applications may benefit from on-chain enumerability, for those cases see
  17 |     |  * {AccessControlEnumerable}.
  18 |     |  *
  19 |     |  * Roles are referred to by their `bytes32` identifier. These should be exposed
  20 |     |  * in the external API and be unique. The best way to achieve this is by
  21 |     |  * using `public constant` hash digests:
  22 |     |  *
  23 |     |  * ```solidity
  24 |     |  * bytes32 public constant MY_ROLE = keccak256("MY_ROLE");
  25 |     |  * ```
  26 |     |  *
  27 |     |  * Roles can be used to represent a set of permissions. To restrict access to a
  28 |     |  * function call, use {hasRole}:
  29 |     |  *
  30 |     |  * ```solidity
  31 |     |  * function foo() public {
  32 |     |  *     require(hasRole(MY_ROLE, msg.sender));
  33 |     |  *     ...
  34 |     |  * }
  35 |     |  * ```
  36 |     |  *
  37 |     |  * Roles can be granted and revoked dynamically via the {grantRole} and
  38 |     |  * {revokeRole} functions. Each role has an associated admin role, and only
  39 |     |  * accounts that have a role's admin role can call {grantRole} and {revokeRole}.
  40 |     |  *
  41 |     |  * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means
  42 |     |  * that only accounts with this role will be able to grant or revoke other
  43 |     |  * roles. More complex role relationships can be created by using
  44 |     |  * {_setRoleAdmin}.
  45 |     |  *
  46 |     |  * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to
  47 |     |  * grant and revoke this role. Extra precautions should be taken to secure
  48 |     |  * accounts that have been granted it. We recommend using {AccessControlDefaultAdminRules}
  49 |     |  * to enforce additional security measures for this role.
  50 |     |  */
  51 |     | abstract contract AccessControlUpgradeable is Initializable, ContextUpgradeable, IAccessControl, ERC165Upgradeable {
  52 |     |     struct RoleData {
  53 |     |         mapping(address account => bool) hasRole;
  54 |     |         bytes32 adminRole;
  55 |     |     }
  56 |     | 
  57 |     |     bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;
  58 |     | 
  59 |     | 
  60 |     |     /// @custom:storage-location erc7201:openzeppelin.storage.AccessControl
  61 |     |     struct AccessControlStorage {
  62 |     |         mapping(bytes32 role => RoleData) _roles;
  63 |     |     }
  64 |     | 
  65 |     |     // keccak256(abi.encode(uint256(keccak256("openzeppelin.storage.AccessControl")) - 1)) & ~bytes32(uint256(0xff))
  66 |     |     bytes32 private constant AccessControlStorageLocation = 0x02dd7bc7dec4dceedda775e58dd541e08a116c6c53815c0bd028192f7b626800;
  67 |     | 
  68 |     |     function _getAccessControlStorage() private pure returns (AccessControlStorage storage $) {
  69 |     |         assembly {
  70 |     |             $.slot := AccessControlStorageLocation
  71 |     |         }
  72 |     |     }
  73 |     | 
  74 |     |     /**
  75 |     |      * @dev Modifier that checks that an account has a specific role. Reverts
  76 |     |      * with an {AccessControlUnauthorizedAccount} error including the required role.
  77 |     |      */
  78 |     |     modifier onlyRole(bytes32 role) {
  79 |     |         _checkRole(role);
  80 |     |         _;
  81 |     |     }
  82 |     | 
  83 |     |     function __AccessControl_init() internal onlyInitializing {
  84 |     |     }
  85 |     | 
  86 |     |     function __AccessControl_init_unchained() internal onlyInitializing {
  87 |     |     }
  88 |     |     /// @inheritdoc IERC165
  89 |     |     function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {
  90 |     |         return interfaceId == type(IAccessControl).interfaceId || super.supportsInterface(interfaceId);
  91 |     |     }
  92 |     | 
  93 |     |     /**
  94 |     |      * @dev Returns `true` if `account` has been granted `role`.
  95 |     |      */
  96 |     |     function hasRole(bytes32 role, address account) public view virtual returns (bool) {
  97 |     |         AccessControlStorage storage $ = _getAccessControlStorage();
  98 |     |         return $._roles[role].hasRole[account];
  99 |     |     }
 100 |     | 
 101 |     |     /**
 102 |     |      * @dev Reverts with an {AccessControlUnauthorizedAccount} error if `_msgSender()`
 103 |     |      * is missing `role`. Overriding this function changes the behavior of the {onlyRole} modifier.
 104 |     |      */
 105 |     |     function _checkRole(bytes32 role) internal view virtual {
 106 |     |         _checkRole(role, _msgSender());
 107 |     |     }
 108 |     | 
 109 |     |     /**
 110 |     |      * @dev Reverts with an {AccessControlUnauthorizedAccount} error if `account`
 111 |     |      * is missing `role`.
 112 |     |      */
 113 |     |     function _checkRole(bytes32 role, address account) internal view virtual {
 114 |     |         if (!hasRole(role, account)) {
 115 |     |             revert AccessControlUnauthorizedAccount(account, role);
 116 |     |         }
 117 |     |     }
 118 |     | 
 119 |     |     /**
 120 |     |      * @dev Returns the admin role that controls `role`. See {grantRole} and
 121 |     |      * {revokeRole}.
 122 |     |      *
 123 |     |      * To change a role's admin, use {_setRoleAdmin}.
 124 |     |      */
 125 |     |     function getRoleAdmin(bytes32 role) public view virtual returns (bytes32) {
 126 |     |         AccessControlStorage storage $ = _getAccessControlStorage();
 127 |     |         return $._roles[role].adminRole;
 128 |     |     }
 129 |     | 
 130 |     |     /**
 131 |     |      * @dev Grants `role` to `account`.
 132 |     |      *
 133 |     |      * If `account` had not been already granted `role`, emits a {RoleGranted}
 134 |     |      * event.
 135 |     |      *
 136 |     |      * Requirements:
 137 |     |      *
 138 |     |      * - the caller must have ``role``'s admin role.
 139 |     |      *
 140 |     |      * May emit a {RoleGranted} event.
 141 |     |      */
 142 |     |     function grantRole(bytes32 role, address account) public virtual onlyRole(getRoleAdmin(role)) {
 143 |     |         _grantRole(role, account);
 144 |     |     }
 145 |     | 
 146 |     |     /**
 147 |     |      * @dev Revokes `role` from `account`.
 148 |     |      *
 149 |     |      * If `account` had been granted `role`, emits a {RoleRevoked} event.
 150 |     |      *
 151 |     |      * Requirements:
 152 |     |      *
 153 |     |      * - the caller must have ``role``'s admin role.
 154 |     |      *
 155 |     |      * May emit a {RoleRevoked} event.
 156 |     |      */
 157 |     |     function revokeRole(bytes32 role, address account) public virtual onlyRole(getRoleAdmin(role)) {
 158 |     |         _revokeRole(role, account);
 159 |     |     }
 160 |     | 
 161 |     |     /**
 162 |     |      * @dev Revokes `role` from the calling account.
 163 |     |      *
 164 |     |      * Roles are often managed via {grantRole} and {revokeRole}: this function's
 165 |     |      * purpose is to provide a mechanism for accounts to lose their privileges
 166 |     |      * if they are compromised (such as when a trusted device is misplaced).
 167 |     |      *
 168 |     |      * If the calling account had been revoked `role`, emits a {RoleRevoked}
 169 |     |      * event.
 170 |     |      *
 171 |     |      * Requirements:
 172 |     |      *
 173 |     |      * - the caller must be `callerConfirmation`.
 174 |     |      *
 175 |     |      * May emit a {RoleRevoked} event.
 176 |     |      */
 177 |     |     function renounceRole(bytes32 role, address callerConfirmation) public virtual {
 178 |     |         if (callerConfirmation != _msgSender()) {
 179 |     |             revert AccessControlBadConfirmation();
 180 |     |         }
 181 |     | 
 182 |     |         _revokeRole(role, callerConfirmation);
 183 |     |     }
 184 |     | 
 185 |     |     /**
 186 |     |      * @dev Sets `adminRole` as ``role``'s admin role.
 187 |     |      *
 188 |     |      * Emits a {RoleAdminChanged} event.
 189 |     |      */
 190 |     |     function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {
 191 |     |         AccessControlStorage storage $ = _getAccessControlStorage();
 192 |     |         bytes32 previousAdminRole = getRoleAdmin(role);
 193 |     |         $._roles[role].adminRole = adminRole;
 194 |     |         emit RoleAdminChanged(role, previousAdminRole, adminRole);
 195 |     |     }
 196 |     | 
 197 |     |     /**
 198 |     |      * @dev Attempts to grant `role` to `account` and returns a boolean indicating if `role` was granted.
 199 |     |      *
 200 |     |      * Internal function without access restriction.
 201 |     |      *
 202 |     |      * May emit a {RoleGranted} event.
 203 |     |      */
 204 |     |     function _grantRole(bytes32 role, address account) internal virtual returns (bool) {
 205 |     |         AccessControlStorage storage $ = _getAccessControlStorage();
 206 |     |         if (!hasRole(role, account)) {
 207 |     |             $._roles[role].hasRole[account] = true;
 208 |     |             emit RoleGranted(role, account, _msgSender());
 209 |     |             return true;
 210 |     |         } else {
 211 |     |             return false;
 212 |     |         }
 213 |     |     }
 214 |     | 
 215 |     |     /**
 216 |     |      * @dev Attempts to revoke `role` from `account` and returns a boolean indicating if `role` was revoked.
 217 |     |      *
 218 |     |      * Internal function without access restriction.
 219 |     |      *
 220 |     |      * May emit a {RoleRevoked} event.
 221 |     |      */
 222 |     |     function _revokeRole(bytes32 role, address account) internal virtual returns (bool) {
 223 |     |         AccessControlStorage storage $ = _getAccessControlStorage();
 224 |     |         if (hasRole(role, account)) {
 225 |     |             $._roles[role].hasRole[account] = false;
 226 |     |             emit RoleRevoked(role, account, _msgSender());
 227 |     |             return true;
 228 |     |         } else {
 229 |     |             return false;
 230 |     |         }
 231 |     |     }
 232 |     | }
 233 |     | 

/home/phantom/Documents/azemora/azemora-contracts/lib/openzeppelin-contracts-upgradeable/contracts/access/OwnableUpgradeable.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | // OpenZeppelin Contracts (last updated v5.0.0) (access/Ownable.sol)
   3 |     | 
   4 |     | pragma solidity ^0.8.20;
   5 |     | 
   6 |     | import {ContextUpgradeable} from "../utils/ContextUpgradeable.sol";
   7 |     | import {Initializable} from "../proxy/utils/Initializable.sol";
   8 |     | 
   9 |     | /**
  10 |     |  * @dev Contract module which provides a basic access control mechanism, where
  11 |     |  * there is an account (an owner) that can be granted exclusive access to
  12 |     |  * specific functions.
  13 |     |  *
  14 |     |  * The initial owner is set to the address provided by the deployer. This can
  15 |     |  * later be changed with {transferOwnership}.
  16 |     |  *
  17 |     |  * This module is used through inheritance. It will make available the modifier
  18 |     |  * `onlyOwner`, which can be applied to your functions to restrict their use to
  19 |     |  * the owner.
  20 |     |  */
  21 |     | abstract contract OwnableUpgradeable is Initializable, ContextUpgradeable {
  22 |     |     /// @custom:storage-location erc7201:openzeppelin.storage.Ownable
  23 |     |     struct OwnableStorage {
  24 |     |         address _owner;
  25 |     |     }
  26 |     | 
  27 |     |     // keccak256(abi.encode(uint256(keccak256("openzeppelin.storage.Ownable")) - 1)) & ~bytes32(uint256(0xff))
  28 |     |     bytes32 private constant OwnableStorageLocation = 0x9016d09d72d40fdae2fd8ceac6b6234c7706214fd39c1cd1e609a0528c199300;
  29 |     | 
  30 |     |     function _getOwnableStorage() private pure returns (OwnableStorage storage $) {
  31 |     |         assembly {
  32 |     |             $.slot := OwnableStorageLocation
  33 |     |         }
  34 |     |     }
  35 |     | 
  36 |     |     /**
  37 |     |      * @dev The caller account is not authorized to perform an operation.
  38 |     |      */
  39 |     |     error OwnableUnauthorizedAccount(address account);
  40 |     | 
  41 |     |     /**
  42 |     |      * @dev The owner is not a valid owner account. (eg. `address(0)`)
  43 |     |      */
  44 |     |     error OwnableInvalidOwner(address owner);
  45 |     | 
  46 |     |     event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);
  47 |     | 
  48 |     |     /**
  49 |     |      * @dev Initializes the contract setting the address provided by the deployer as the initial owner.
  50 |     |      */
  51 |     |     function __Ownable_init(address initialOwner) internal onlyInitializing {
  52 |     |         __Ownable_init_unchained(initialOwner);
  53 |     |     }
  54 |     | 
  55 |     |     function __Ownable_init_unchained(address initialOwner) internal onlyInitializing {
  56 |     |         if (initialOwner == address(0)) {
  57 |     |             revert OwnableInvalidOwner(address(0));
  58 |     |         }
  59 |     |         _transferOwnership(initialOwner);
  60 |     |     }
  61 |     | 
  62 |     |     /**
  63 |     |      * @dev Throws if called by any account other than the owner.
  64 |     |      */
  65 |     |     modifier onlyOwner() {
  66 |     |         _checkOwner();
  67 |     |         _;
  68 |     |     }
  69 |     | 
  70 |     |     /**
  71 |     |      * @dev Returns the address of the current owner.
  72 |     |      */
  73 |     |     function owner() public view virtual returns (address) {
  74 |     |         OwnableStorage storage $ = _getOwnableStorage();
  75 |     |         return $._owner;
  76 |     |     }
  77 |     | 
  78 |     |     /**
  79 |     |      * @dev Throws if the sender is not the owner.
  80 |     |      */
  81 |     |     function _checkOwner() internal view virtual {
  82 |     |         if (owner() != _msgSender()) {
  83 |     |             revert OwnableUnauthorizedAccount(_msgSender());
  84 |     |         }
  85 |     |     }
  86 |     | 
  87 |     |     /**
  88 |     |      * @dev Leaves the contract without owner. It will not be possible to call
  89 |     |      * `onlyOwner` functions. Can only be called by the current owner.
  90 |     |      *
  91 |     |      * NOTE: Renouncing ownership will leave the contract without an owner,
  92 |     |      * thereby disabling any functionality that is only available to the owner.
  93 |     |      */
  94 |     |     function renounceOwnership() public virtual onlyOwner {
  95 |     |         _transferOwnership(address(0));
  96 |     |     }
  97 |     | 
  98 |     |     /**
  99 |     |      * @dev Transfers ownership of the contract to a new account (`newOwner`).
 100 |     |      * Can only be called by the current owner.
 101 |     |      */
 102 |     |     function transferOwnership(address newOwner) public virtual onlyOwner {
 103 |     |         if (newOwner == address(0)) {
 104 |     |             revert OwnableInvalidOwner(address(0));
 105 |     |         }
 106 |     |         _transferOwnership(newOwner);
 107 |     |     }
 108 |     | 
 109 |     |     /**
 110 |     |      * @dev Transfers ownership of the contract to a new account (`newOwner`).
 111 |     |      * Internal function without access restriction.
 112 |     |      */
 113 |     |     function _transferOwnership(address newOwner) internal virtual {
 114 |     |         OwnableStorage storage $ = _getOwnableStorage();
 115 |     |         address oldOwner = $._owner;
 116 |     |         $._owner = newOwner;
 117 |     |         emit OwnershipTransferred(oldOwner, newOwner);
 118 |     |     }
 119 |     | }
 120 |     | 

/home/phantom/Documents/azemora/azemora-contracts/lib/openzeppelin-contracts-upgradeable/contracts/governance/GovernorUpgradeable.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | // OpenZeppelin Contracts (last updated v5.3.0) (governance/Governor.sol)
   3 |     | 
   4 |     | pragma solidity ^0.8.24;
   5 |     | 
   6 |     | import {IERC721Receiver} from "@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol";
   7 |     | import {IERC1155Receiver} from "@openzeppelin/contracts/token/ERC1155/IERC1155Receiver.sol";
   8 |     | import {EIP712Upgradeable} from "../utils/cryptography/EIP712Upgradeable.sol";
   9 |     | import {SignatureChecker} from "@openzeppelin/contracts/utils/cryptography/SignatureChecker.sol";
  10 |     | import {IERC165} from "@openzeppelin/contracts/utils/introspection/IERC165.sol";
  11 |     | import {ERC165Upgradeable} from "../utils/introspection/ERC165Upgradeable.sol";
  12 |     | import {SafeCast} from "@openzeppelin/contracts/utils/math/SafeCast.sol";
  13 |     | import {DoubleEndedQueue} from "@openzeppelin/contracts/utils/structs/DoubleEndedQueue.sol";
  14 |     | import {Address} from "@openzeppelin/contracts/utils/Address.sol";
  15 |     | import {ContextUpgradeable} from "../utils/ContextUpgradeable.sol";
  16 |     | import {NoncesUpgradeable} from "../utils/NoncesUpgradeable.sol";
  17 |     | import {Strings} from "@openzeppelin/contracts/utils/Strings.sol";
  18 |     | import {IGovernor} from "@openzeppelin/contracts/governance/IGovernor.sol";
  19 |     | import {IERC6372} from "@openzeppelin/contracts/interfaces/IERC6372.sol";
  20 |     | import {Initializable} from "../proxy/utils/Initializable.sol";
  21 |     | 
  22 |     | /**
  23 |     |  * @dev Core of the governance system, designed to be extended through various modules.
  24 |     |  *
  25 |     |  * This contract is abstract and requires several functions to be implemented in various modules:
  26 |     |  *
  27 |     |  * - A counting module must implement {_quorumReached}, {_voteSucceeded} and {_countVote}
  28 |     |  * - A voting module must implement {_getVotes}
  29 |     |  * - Additionally, {votingPeriod}, {votingDelay}, and {quorum} must also be implemented
  30 |     |  */
  31 |     | abstract contract GovernorUpgradeable is Initializable, ContextUpgradeable, ERC165Upgradeable, EIP712Upgradeable, NoncesUpgradeable, IGovernor, IERC721Receiver, IERC1155Receiver {
  32 |     |     using DoubleEndedQueue for DoubleEndedQueue.Bytes32Deque;
  33 |     | 
  34 |     |     bytes32 public constant BALLOT_TYPEHASH =
  35 |     |         keccak256("Ballot(uint256 proposalId,uint8 support,address voter,uint256 nonce)");
  36 |     |     bytes32 public constant EXTENDED_BALLOT_TYPEHASH =
  37 |     |         keccak256(
  38 |     |             "ExtendedBallot(uint256 proposalId,uint8 support,address voter,uint256 nonce,string reason,bytes params)"
  39 |     |         );
  40 |     | 
  41 |     |     struct ProposalCore {
  42 |     |         address proposer;
  43 |     |         uint48 voteStart;
  44 |     |         uint32 voteDuration;
  45 |     |         bool executed;
  46 |     |         bool canceled;
  47 |     |         uint48 etaSeconds;
  48 |     |     }
  49 |     | 
  50 |     |     bytes32 private constant ALL_PROPOSAL_STATES_BITMAP = bytes32((2 ** (uint8(type(ProposalState).max) + 1)) - 1);
  51 |     |     /// @custom:storage-location erc7201:openzeppelin.storage.Governor
  52 |     |     struct GovernorStorage {
  53 |     |         string _name;
  54 |     | 
  55 |     |         mapping(uint256 proposalId => ProposalCore) _proposals;
  56 |     | 
  57 |     |         // This queue keeps track of the governor operating on itself. Calls to functions protected by the {onlyGovernance}
  58 |     |         // modifier needs to be whitelisted in this queue. Whitelisting is set in {execute}, consumed by the
  59 |     |         // {onlyGovernance} modifier and eventually reset after {_executeOperations} completes. This ensures that the
  60 |     |         // execution of {onlyGovernance} protected calls can only be achieved through successful proposals.
  61 |     |         DoubleEndedQueue.Bytes32Deque _governanceCall;
  62 |     |     }
  63 |     | 
  64 |     |     // keccak256(abi.encode(uint256(keccak256("openzeppelin.storage.Governor")) - 1)) & ~bytes32(uint256(0xff))
  65 |     |     bytes32 private constant GovernorStorageLocation = 0x7c712897014dbe49c045ef1299aa2d5f9e67e48eea4403efa21f1e0f3ac0cb00;
  66 |     | 
  67 |     |     function _getGovernorStorage() private pure returns (GovernorStorage storage $) {
  68 |     |         assembly {
  69 |     |             $.slot := GovernorStorageLocation
  70 |     |         }
  71 |     |     }
  72 |     | 
  73 |     |     /**
  74 |     |      * @dev Restricts a function so it can only be executed through governance proposals. For example, governance
  75 |     |      * parameter setters in {GovernorSettings} are protected using this modifier.
  76 |     |      *
  77 |     |      * The governance executing address may be different from the Governor's own address, for example it could be a
  78 |     |      * timelock. This can be customized by modules by overriding {_executor}. The executor is only able to invoke these
  79 |     |      * functions during the execution of the governor's {execute} function, and not under any other circumstances. Thus,
  80 |     |      * for example, additional timelock proposers are not able to change governance parameters without going through the
  81 |     |      * governance protocol (since v4.6).
  82 |     |      */
  83 |     |     modifier onlyGovernance() {
  84 |     |         _checkGovernance();
  85 |     |         _;
  86 |     |     }
  87 |     | 
  88 |     |     /**
  89 |     |      * @dev Sets the value for {name} and {version}
  90 |     |      */
  91 |     |     function __Governor_init(string memory name_) internal onlyInitializing {
  92 |     |         __EIP712_init_unchained(name_, version());
  93 |     |         __Governor_init_unchained(name_);
  94 |     |     }
  95 |     | 
  96 |     |     function __Governor_init_unchained(string memory name_) internal onlyInitializing {
  97 |     |         GovernorStorage storage $ = _getGovernorStorage();
  98 |     |         $._name = name_;
  99 |     |     }
 100 |     | 
 101 |     |     /**
 102 |     |      * @dev Function to receive ETH that will be handled by the governor (disabled if executor is a third party contract)
 103 |     |      */
 104 |     |     receive() external payable virtual {
 105 |     |         if (_executor() != address(this)) {
 106 |     |             revert GovernorDisabledDeposit();
 107 |     |         }
 108 |     |     }
 109 |     | 
 110 |     |     /// @inheritdoc IERC165
 111 |     |     function supportsInterface(bytes4 interfaceId) public view virtual override(IERC165, ERC165Upgradeable) returns (bool) {
 112 |     |         return
 113 |     |             interfaceId == type(IGovernor).interfaceId ||
 114 |     |             interfaceId == type(IGovernor).interfaceId ^ IGovernor.getProposalId.selector ||
 115 |     |             interfaceId == type(IERC1155Receiver).interfaceId ||
 116 |     |             super.supportsInterface(interfaceId);
 117 |     |     }
 118 |     | 
 119 |     |     /// @inheritdoc IGovernor
 120 |     |     function name() public view virtual returns (string memory) {
 121 |     |         GovernorStorage storage $ = _getGovernorStorage();
 122 |     |         return $._name;
 123 |     |     }
 124 |     | 
 125 |     |     /// @inheritdoc IGovernor
 126 |     |     function version() public view virtual returns (string memory) {
 127 |     |         return "1";
 128 |     |     }
 129 |     | 
 130 |     |     /**
 131 |     |      * @dev See {IGovernor-hashProposal}.
 132 |     |      *
 133 |     |      * The proposal id is produced by hashing the ABI encoded `targets` array, the `values` array, the `calldatas` array
 134 |     |      * and the descriptionHash (bytes32 which itself is the keccak256 hash of the description string). This proposal id
 135 |     |      * can be produced from the proposal data which is part of the {ProposalCreated} event. It can even be computed in
 136 |     |      * advance, before the proposal is submitted.
 137 |     |      *
 138 |     |      * Note that the chainId and the governor address are not part of the proposal id computation. Consequently, the
 139 |     |      * same proposal (with same operation and same description) will have the same id if submitted on multiple governors
 140 |     |      * across multiple networks. This also means that in order to execute the same operation twice (on the same
 141 |     |      * governor) the proposer will have to change the description in order to avoid proposal id conflicts.
 142 |     |      */
 143 |     |     function hashProposal(
 144 |     |         address[] memory targets,
 145 |     |         uint256[] memory values,
 146 |     |         bytes[] memory calldatas,
 147 |     |         bytes32 descriptionHash
 148 |     |     ) public pure virtual returns (uint256) {
 149 |     |         return uint256(keccak256(abi.encode(targets, values, calldatas, descriptionHash)));
 150 |     |     }
 151 |     | 
 152 |     |     /// @inheritdoc IGovernor
 153 |     |     function getProposalId(
 154 |     |         address[] memory targets,
 155 |     |         uint256[] memory values,
 156 |     |         bytes[] memory calldatas,
 157 |     |         bytes32 descriptionHash
 158 |     |     ) public view virtual returns (uint256) {
 159 |     |         return hashProposal(targets, values, calldatas, descriptionHash);
 160 |     |     }
 161 |     | 
 162 |     |     /// @inheritdoc IGovernor
 163 |     |     function state(uint256 proposalId) public view virtual returns (ProposalState) {
 164 |     |         GovernorStorage storage $ = _getGovernorStorage();
 165 |     |         // We read the struct fields into the stack at once so Solidity emits a single SLOAD
 166 |     |         ProposalCore storage proposal = $._proposals[proposalId];
 167 |     |         bool proposalExecuted = proposal.executed;
 168 |     |         bool proposalCanceled = proposal.canceled;
 169 |     | 
 170 |     |         if (proposalExecuted) {
 171 |     |             return ProposalState.Executed;
 172 |     |         }
 173 |     | 
 174 |     |         if (proposalCanceled) {
 175 |     |             return ProposalState.Canceled;
 176 |     |         }
 177 |     | 
 178 |     |         uint256 snapshot = proposalSnapshot(proposalId);
 179 |     | 
 180 |     |         if (snapshot == 0) {
 181 |     |             revert GovernorNonexistentProposal(proposalId);
 182 |     |         }
 183 |     | 
 184 |     |         uint256 currentTimepoint = clock();
 185 |     | 
 186 |     |         if (snapshot >= currentTimepoint) {
 187 |     |             return ProposalState.Pending;
 188 |     |         }
 189 |     | 
 190 |     |         uint256 deadline = proposalDeadline(proposalId);
 191 |     | 
 192 |     |         if (deadline >= currentTimepoint) {
 193 |     |             return ProposalState.Active;
 194 |     |         } else if (!_quorumReached(proposalId) || !_voteSucceeded(proposalId)) {
 195 |     |             return ProposalState.Defeated;
 196 |     |         } else if (proposalEta(proposalId) == 0) {
 197 |     |             return ProposalState.Succeeded;
 198 |     |         } else {
 199 |     |             return ProposalState.Queued;
 200 |     |         }
 201 |     |     }
 202 |     | 
 203 |     |     /// @inheritdoc IGovernor
 204 |     |     function proposalThreshold() public view virtual returns (uint256) {
 205 |     |         return 0;
 206 |     |     }
 207 |     | 
 208 |     |     /// @inheritdoc IGovernor
 209 |     |     function proposalSnapshot(uint256 proposalId) public view virtual returns (uint256) {
 210 |     |         GovernorStorage storage $ = _getGovernorStorage();
 211 |     |         return $._proposals[proposalId].voteStart;
 212 |     |     }
 213 |     | 
 214 |     |     /// @inheritdoc IGovernor
 215 |     |     function proposalDeadline(uint256 proposalId) public view virtual returns (uint256) {
 216 |     |         GovernorStorage storage $ = _getGovernorStorage();
 217 |     |         return $._proposals[proposalId].voteStart + $._proposals[proposalId].voteDuration;
 218 |     |     }
 219 |     | 
 220 |     |     /// @inheritdoc IGovernor
 221 |     |     function proposalProposer(uint256 proposalId) public view virtual returns (address) {
 222 |     |         GovernorStorage storage $ = _getGovernorStorage();
 223 |     |         return $._proposals[proposalId].proposer;
 224 |     |     }
 225 |     | 
 226 |     |     /// @inheritdoc IGovernor
 227 |     |     function proposalEta(uint256 proposalId) public view virtual returns (uint256) {
 228 |     |         GovernorStorage storage $ = _getGovernorStorage();
 229 |     |         return $._proposals[proposalId].etaSeconds;
 230 |     |     }
 231 |     | 
 232 |     |     /// @inheritdoc IGovernor
 233 |     |     function proposalNeedsQueuing(uint256) public view virtual returns (bool) {
 234 |     |         return false;
 235 |     |     }
 236 |     | 
 237 |     |     /**
 238 |     |      * @dev Reverts if the `msg.sender` is not the executor. In case the executor is not this contract
 239 |     |      * itself, the function reverts if `msg.data` is not whitelisted as a result of an {execute}
 240 |     |      * operation. See {onlyGovernance}.
 241 |     |      */
 242 |     |     function _checkGovernance() internal virtual {
 243 |     |         GovernorStorage storage $ = _getGovernorStorage();
 244 |     |         if (_executor() != _msgSender()) {
 245 |     |             revert GovernorOnlyExecutor(_msgSender());
 246 |     |         }
 247 |     |         if (_executor() != address(this)) {
 248 |     |             bytes32 msgDataHash = keccak256(_msgData());
 249 |     |             // loop until popping the expected operation - throw if deque is empty (operation not authorized)
 250 |     |             while ($._governanceCall.popFront() != msgDataHash) {}
 251 |     |         }
 252 |     |     }
 253 |     | 
 254 |     |     /**
 255 |     |      * @dev Amount of votes already cast passes the threshold limit.
 256 |     |      */
 257 |     |     function _quorumReached(uint256 proposalId) internal view virtual returns (bool);
 258 |     | 
 259 |     |     /**
 260 |     |      * @dev Is the proposal successful or not.
 261 |     |      */
 262 |     |     function _voteSucceeded(uint256 proposalId) internal view virtual returns (bool);
 263 |     | 
 264 |     |     /**
 265 |     |      * @dev Get the voting weight of `account` at a specific `timepoint`, for a vote as described by `params`.
 266 |     |      */
 267 |     |     function _getVotes(address account, uint256 timepoint, bytes memory params) internal view virtual returns (uint256);
 268 |     | 
 269 |     |     /**
 270 |     |      * @dev Register a vote for `proposalId` by `account` with a given `support`, voting `weight` and voting `params`.
 271 |     |      *
 272 |     |      * Note: Support is generic and can represent various things depending on the voting system used.
 273 |     |      */
 274 |     |     function _countVote(
 275 |     |         uint256 proposalId,
 276 |     |         address account,
 277 |     |         uint8 support,
 278 |     |         uint256 totalWeight,
 279 |     |         bytes memory params
 280 |     |     ) internal virtual returns (uint256);
 281 |     | 
 282 |     |     /**
 283 |     |      * @dev Hook that should be called every time the tally for a proposal is updated.
 284 |     |      *
 285 |     |      * Note: This function must run successfully. Reverts will result in the bricking of governance
 286 |     |      */
 287 |     |     function _tallyUpdated(uint256 proposalId) internal virtual {}
 288 |     | 
 289 |     |     /**
 290 |     |      * @dev Default additional encoded parameters used by castVote methods that don't include them
 291 |     |      *
 292 |     |      * Note: Should be overridden by specific implementations to use an appropriate value, the
 293 |     |      * meaning of the additional params, in the context of that implementation
 294 |     |      */
 295 |     |     function _defaultParams() internal view virtual returns (bytes memory) {
 296 |     |         return "";
 297 |     |     }
 298 |     | 
 299 |     |     /**
 300 |     |      * @dev See {IGovernor-propose}. This function has opt-in frontrunning protection, described in {_isValidDescriptionForProposer}.
 301 |     |      */
 302 |     |     function propose(
 303 |     |         address[] memory targets,
 304 |     |         uint256[] memory values,
 305 |     |         bytes[] memory calldatas,
 306 |     |         string memory description
 307 |     |     ) public virtual returns (uint256) {
 308 |     |         address proposer = _msgSender();
 309 |     | 
 310 |     |         // check description restriction
 311 |     |         if (!_isValidDescriptionForProposer(proposer, description)) {
 312 |     |             revert GovernorRestrictedProposer(proposer);
 313 |     |         }
 314 |     | 
 315 |     |         // check proposal threshold
 316 |     |         uint256 votesThreshold = proposalThreshold();
 317 |     |         if (votesThreshold > 0) {
 318 |     |             uint256 proposerVotes = getVotes(proposer, clock() - 1);
 319 |     |             if (proposerVotes < votesThreshold) {
 320 |     |                 revert GovernorInsufficientProposerVotes(proposer, proposerVotes, votesThreshold);
 321 |     |             }
 322 |     |         }
 323 |     | 
 324 |     |         return _propose(targets, values, calldatas, description, proposer);
 325 |     |     }
 326 |     | 
 327 |     |     /**
 328 |     |      * @dev Internal propose mechanism. Can be overridden to add more logic on proposal creation.
 329 |     |      *
 330 |     |      * Emits a {IGovernor-ProposalCreated} event.
 331 |     |      */
 332 |     |     function _propose(
 333 |     |         address[] memory targets,
 334 |     |         uint256[] memory values,
 335 |     |         bytes[] memory calldatas,
 336 |     |         string memory description,
 337 |     |         address proposer
 338 |     |     ) internal virtual returns (uint256 proposalId) {
 339 |     |         GovernorStorage storage $ = _getGovernorStorage();
 340 |     |         proposalId = getProposalId(targets, values, calldatas, keccak256(bytes(description)));
 341 |     | 
 342 |     |         if (targets.length != values.length || targets.length != calldatas.length || targets.length == 0) {
 343 |     |             revert GovernorInvalidProposalLength(targets.length, calldatas.length, values.length);
 344 |     |         }
 345 |     |         if ($._proposals[proposalId].voteStart != 0) {
 346 |     |             revert GovernorUnexpectedProposalState(proposalId, state(proposalId), bytes32(0));
 347 |     |         }
 348 |     | 
 349 |     |         uint256 snapshot = clock() + votingDelay();
 350 |     |         uint256 duration = votingPeriod();
 351 |     | 
 352 |     |         ProposalCore storage proposal = $._proposals[proposalId];
 353 |     |         proposal.proposer = proposer;
 354 |     |         proposal.voteStart = SafeCast.toUint48(snapshot);
 355 |     |         proposal.voteDuration = SafeCast.toUint32(duration);
 356 |     | 
 357 |     |         emit ProposalCreated(
 358 |     |             proposalId,
 359 |     |             proposer,
 360 |     |             targets,
 361 |     |             values,
 362 |     |             new string[](targets.length),
 363 |     |             calldatas,
 364 |     |             snapshot,
 365 |     |             snapshot + duration,
 366 |     |             description
 367 |     |         );
 368 |     | 
 369 |     |         // Using a named return variable to avoid stack too deep errors
 370 |     |     }
 371 |     | 
 372 |     |     /// @inheritdoc IGovernor
 373 |     |     function queue(
 374 |     |         address[] memory targets,
 375 |     |         uint256[] memory values,
 376 |     |         bytes[] memory calldatas,
 377 |     |         bytes32 descriptionHash
 378 |     |     ) public virtual returns (uint256) {
 379 |     |         GovernorStorage storage $ = _getGovernorStorage();
 380 |     |         uint256 proposalId = getProposalId(targets, values, calldatas, descriptionHash);
 381 |     | 
 382 |     |         _validateStateBitmap(proposalId, _encodeStateBitmap(ProposalState.Succeeded));
 383 |     | 
 384 |     |         uint48 etaSeconds = _queueOperations(proposalId, targets, values, calldatas, descriptionHash);
 385 |     | 
 386 |     |         if (etaSeconds != 0) {
 387 |     |             $._proposals[proposalId].etaSeconds = etaSeconds;
 388 |     |             emit ProposalQueued(proposalId, etaSeconds);
 389 |     |         } else {
 390 |     |             revert GovernorQueueNotImplemented();
 391 |     |         }
 392 |     | 
 393 |     |         return proposalId;
 394 |     |     }
 395 |     | 
 396 |     |     /**
 397 |     |      * @dev Internal queuing mechanism. Can be overridden (without a super call) to modify the way queuing is
 398 |     |      * performed (for example adding a vault/timelock).
 399 |     |      *
 400 |     |      * This is empty by default, and must be overridden to implement queuing.
 401 |     |      *
 402 |     |      * This function returns a timestamp that describes the expected ETA for execution. If the returned value is 0
 403 |     |      * (which is the default value), the core will consider queueing did not succeed, and the public {queue} function
 404 |     |      * will revert.
 405 |     |      *
 406 |     |      * NOTE: Calling this function directly will NOT check the current state of the proposal, or emit the
 407 |     |      * `ProposalQueued` event. Queuing a proposal should be done using {queue}.
 408 |     |      */
 409 |     |     function _queueOperations(
 410 |     |         uint256 /*proposalId*/,
 411 |     |         address[] memory /*targets*/,
 412 |     |         uint256[] memory /*values*/,
 413 |     |         bytes[] memory /*calldatas*/,
 414 |     |         bytes32 /*descriptionHash*/
 415 |     |     ) internal virtual returns (uint48) {
 416 |     |         return 0;
 417 |     |     }
 418 |     | 
 419 |     |     /// @inheritdoc IGovernor
 420 |     |     function execute(
 421 |     |         address[] memory targets,
 422 |     |         uint256[] memory values,
 423 |     |         bytes[] memory calldatas,
 424 |     |         bytes32 descriptionHash
 425 |     |     ) public payable virtual returns (uint256) {
 426 |     |         GovernorStorage storage $ = _getGovernorStorage();
 427 |     |         uint256 proposalId = getProposalId(targets, values, calldatas, descriptionHash);
 428 |     | 
 429 |     |         _validateStateBitmap(
 430 |     |             proposalId,
 431 |     |             _encodeStateBitmap(ProposalState.Succeeded) | _encodeStateBitmap(ProposalState.Queued)
 432 |     |         );
 433 |     | 
 434 |     |         // mark as executed before calls to avoid reentrancy
 435 |     |         $._proposals[proposalId].executed = true;
 436 |     | 
 437 |     |         // before execute: register governance call in queue.
 438 |     |         if (_executor() != address(this)) {
 439 |     |             for (uint256 i = 0; i < targets.length; ++i) {
 440 |     |                 if (targets[i] == address(this)) {
 441 |     |                     $._governanceCall.pushBack(keccak256(calldatas[i]));
 442 |     |                 }
 443 |     |             }
 444 |     |         }
 445 |     | 
 446 |     |         _executeOperations(proposalId, targets, values, calldatas, descriptionHash);
 447 |     | 
 448 |     |         // after execute: cleanup governance call queue.
 449 |     |         if (_executor() != address(this) && !$._governanceCall.empty()) {
 450 |     |             $._governanceCall.clear();
 451 |     |         }
 452 |     | 
 453 |     |         emit ProposalExecuted(proposalId);
 454 |     | 
 455 |     |         return proposalId;
 456 |     |     }
 457 |     | 
 458 |     |     /**
 459 |     |      * @dev Internal execution mechanism. Can be overridden (without a super call) to modify the way execution is
 460 |     |      * performed (for example adding a vault/timelock).
 461 |     |      *
 462 |     |      * NOTE: Calling this function directly will NOT check the current state of the proposal, set the executed flag to
 463 |     |      * true or emit the `ProposalExecuted` event. Executing a proposal should be done using {execute}.
 464 |     |      */
 465 |     |     function _executeOperations(
 466 |     |         uint256 /* proposalId */,
 467 |     |         address[] memory targets,
 468 |     |         uint256[] memory values,
 469 |     |         bytes[] memory calldatas,
 470 |     |         bytes32 /*descriptionHash*/
 471 |     |     ) internal virtual {
 472 |     |         for (uint256 i = 0; i < targets.length; ++i) {
 473 |     |             (bool success, bytes memory returndata) = targets[i].call{value: values[i]}(calldatas[i]);
 474 |     |             Address.verifyCallResult(success, returndata);
 475 |     |         }
 476 |     |     }
 477 |     | 
 478 |     |     /// @inheritdoc IGovernor
 479 |     |     function cancel(
 480 |     |         address[] memory targets,
 481 |     |         uint256[] memory values,
 482 |     |         bytes[] memory calldatas,
 483 |     |         bytes32 descriptionHash
 484 |     |     ) public virtual returns (uint256) {
 485 |     |         // The proposalId will be recomputed in the `_cancel` call further down. However we need the value before we
 486 |     |         // do the internal call, because we need to check the proposal state BEFORE the internal `_cancel` call
 487 |     |         // changes it. The `getProposalId` duplication has a cost that is limited, and that we accept.
 488 |     |         uint256 proposalId = getProposalId(targets, values, calldatas, descriptionHash);
 489 |     | 
 490 |     |         address caller = _msgSender();
 491 |     |         if (!_validateCancel(proposalId, caller)) revert GovernorUnableToCancel(proposalId, caller);
 492 |     | 
 493 |     |         return _cancel(targets, values, calldatas, descriptionHash);
 494 |     |     }
 495 |     | 
 496 |     |     /**
 497 |     |      * @dev Internal cancel mechanism with minimal restrictions. A proposal can be cancelled in any state other than
 498 |     |      * Canceled, Expired, or Executed. Once cancelled a proposal can't be re-submitted.
 499 |     |      *
 500 |     |      * Emits a {IGovernor-ProposalCanceled} event.
 501 |     |      */
 502 |     |     function _cancel(
 503 |     |         address[] memory targets,
 504 |     |         uint256[] memory values,
 505 |     |         bytes[] memory calldatas,
 506 |     |         bytes32 descriptionHash
 507 |     |     ) internal virtual returns (uint256) {
 508 |     |         GovernorStorage storage $ = _getGovernorStorage();
 509 |     |         uint256 proposalId = getProposalId(targets, values, calldatas, descriptionHash);
 510 |     | 
 511 |     |         _validateStateBitmap(
 512 |     |             proposalId,
 513 |     |             ALL_PROPOSAL_STATES_BITMAP ^
 514 |     |                 _encodeStateBitmap(ProposalState.Canceled) ^
 515 |     |                 _encodeStateBitmap(ProposalState.Expired) ^
 516 |     |                 _encodeStateBitmap(ProposalState.Executed)
 517 |     |         );
 518 |     | 
 519 |     |         $._proposals[proposalId].canceled = true;
 520 |     |         emit ProposalCanceled(proposalId);
 521 |     | 
 522 |     |         return proposalId;
 523 |     |     }
 524 |     | 
 525 |     |     /// @inheritdoc IGovernor
 526 |     |     function getVotes(address account, uint256 timepoint) public view virtual returns (uint256) {
 527 |     |         return _getVotes(account, timepoint, _defaultParams());
 528 |     |     }
 529 |     | 
 530 |     |     /// @inheritdoc IGovernor
 531 |     |     function getVotesWithParams(
 532 |     |         address account,
 533 |     |         uint256 timepoint,
 534 |     |         bytes memory params
 535 |     |     ) public view virtual returns (uint256) {
 536 |     |         return _getVotes(account, timepoint, params);
 537 |     |     }
 538 |     | 
 539 |     |     /// @inheritdoc IGovernor
 540 |     |     function castVote(uint256 proposalId, uint8 support) public virtual returns (uint256) {
 541 |     |         address voter = _msgSender();
 542 |     |         return _castVote(proposalId, voter, support, "");
 543 |     |     }
 544 |     | 
 545 |     |     /// @inheritdoc IGovernor
 546 |     |     function castVoteWithReason(
 547 |     |         uint256 proposalId,
 548 |     |         uint8 support,
 549 |     |         string calldata reason
 550 |     |     ) public virtual returns (uint256) {
 551 |     |         address voter = _msgSender();
 552 |     |         return _castVote(proposalId, voter, support, reason);
 553 |     |     }
 554 |     | 
 555 |     |     /// @inheritdoc IGovernor
 556 |     |     function castVoteWithReasonAndParams(
 557 |     |         uint256 proposalId,
 558 |     |         uint8 support,
 559 |     |         string calldata reason,
 560 |     |         bytes memory params
 561 |     |     ) public virtual returns (uint256) {
 562 |     |         address voter = _msgSender();
 563 |     |         return _castVote(proposalId, voter, support, reason, params);
 564 |     |     }
 565 |     | 
 566 |     |     /// @inheritdoc IGovernor
 567 |     |     function castVoteBySig(
 568 |     |         uint256 proposalId,
 569 |     |         uint8 support,
 570 |     |         address voter,
 571 |     |         bytes memory signature
 572 |     |     ) public virtual returns (uint256) {
 573 |     |         if (!_validateVoteSig(proposalId, support, voter, signature)) {
 574 |     |             revert GovernorInvalidSignature(voter);
 575 |     |         }
 576 |     |         return _castVote(proposalId, voter, support, "");
 577 |     |     }
 578 |     | 
 579 |     |     /// @inheritdoc IGovernor
 580 |     |     function castVoteWithReasonAndParamsBySig(
 581 |     |         uint256 proposalId,
 582 |     |         uint8 support,
 583 |     |         address voter,
 584 |     |         string calldata reason,
 585 |     |         bytes memory params,
 586 |     |         bytes memory signature
 587 |     |     ) public virtual returns (uint256) {
 588 |     |         if (!_validateExtendedVoteSig(proposalId, support, voter, reason, params, signature)) {
 589 |     |             revert GovernorInvalidSignature(voter);
 590 |     |         }
 591 |     |         return _castVote(proposalId, voter, support, reason, params);
 592 |     |     }
 593 |     | 
 594 |     |     /// @dev Validate the `signature` used in {castVoteBySig} function.
 595 |     |     function _validateVoteSig(
 596 |     |         uint256 proposalId,
 597 |     |         uint8 support,
 598 |     |         address voter,
 599 |     |         bytes memory signature
 600 |     |     ) internal virtual returns (bool) {
 601 |     |         return
 602 |     |             SignatureChecker.isValidSignatureNow(
 603 |     |                 voter,
 604 |     |                 _hashTypedDataV4(keccak256(abi.encode(BALLOT_TYPEHASH, proposalId, support, voter, _useNonce(voter)))),
 605 |     |                 signature
 606 |     |             );
 607 |     |     }
 608 |     | 
 609 |     |     /// @dev Validate the `signature` used in {castVoteWithReasonAndParamsBySig} function.
 610 |     |     function _validateExtendedVoteSig(
 611 |     |         uint256 proposalId,
 612 |     |         uint8 support,
 613 |     |         address voter,
 614 |     |         string memory reason,
 615 |     |         bytes memory params,
 616 |     |         bytes memory signature
 617 |     |     ) internal virtual returns (bool) {
 618 |     |         return
 619 |     |             SignatureChecker.isValidSignatureNow(
 620 |     |                 voter,
 621 |     |                 _hashTypedDataV4(
 622 |     |                     keccak256(
 623 |     |                         abi.encode(
 624 |     |                             EXTENDED_BALLOT_TYPEHASH,
 625 |     |                             proposalId,
 626 |     |                             support,
 627 |     |                             voter,
 628 |     |                             _useNonce(voter),
 629 |     |                             keccak256(bytes(reason)),
 630 |     |                             keccak256(params)
 631 |     |                         )
 632 |     |                     )
 633 |     |                 ),
 634 |     |                 signature
 635 |     |             );
 636 |     |     }
 637 |     | 
 638 |     |     /**
 639 |     |      * @dev Internal vote casting mechanism: Check that the vote is pending, that it has not been cast yet, retrieve
 640 |     |      * voting weight using {IGovernor-getVotes} and call the {_countVote} internal function. Uses the _defaultParams().
 641 |     |      *
 642 |     |      * Emits a {IGovernor-VoteCast} event.
 643 |     |      */
 644 |     |     function _castVote(
 645 |     |         uint256 proposalId,
 646 |     |         address account,
 647 |     |         uint8 support,
 648 |     |         string memory reason
 649 |     |     ) internal virtual returns (uint256) {
 650 |     |         return _castVote(proposalId, account, support, reason, _defaultParams());
 651 |     |     }
 652 |     | 
 653 |     |     /**
 654 |     |      * @dev Internal vote casting mechanism: Check that the vote is pending, that it has not been cast yet, retrieve
 655 |     |      * voting weight using {IGovernor-getVotes} and call the {_countVote} internal function.
 656 |     |      *
 657 |     |      * Emits a {IGovernor-VoteCast} event.
 658 |     |      */
 659 |     |     function _castVote(
 660 |     |         uint256 proposalId,
 661 |     |         address account,
 662 |     |         uint8 support,
 663 |     |         string memory reason,
 664 |     |         bytes memory params
 665 |     |     ) internal virtual returns (uint256) {
 666 |     |         _validateStateBitmap(proposalId, _encodeStateBitmap(ProposalState.Active));
 667 |     | 
 668 |     |         uint256 totalWeight = _getVotes(account, proposalSnapshot(proposalId), params);
 669 |     |         uint256 votedWeight = _countVote(proposalId, account, support, totalWeight, params);
 670 |     | 
 671 |     |         if (params.length == 0) {
 672 |     |             emit VoteCast(account, proposalId, support, votedWeight, reason);
 673 |     |         } else {
 674 |     |             emit VoteCastWithParams(account, proposalId, support, votedWeight, reason, params);
 675 |     |         }
 676 |     | 
 677 |     |         _tallyUpdated(proposalId);
 678 |     | 
 679 |     |         return votedWeight;
 680 |     |     }
 681 |     | 
 682 |     |     /**
 683 |     |      * @dev Relays a transaction or function call to an arbitrary target. In cases where the governance executor
 684 |     |      * is some contract other than the governor itself, like when using a timelock, this function can be invoked
 685 |     |      * in a governance proposal to recover tokens or Ether that was sent to the governor contract by mistake.
 686 |     |      * Note that if the executor is simply the governor itself, use of `relay` is redundant.
 687 |     |      */
 688 |     |     function relay(address target, uint256 value, bytes calldata data) external payable virtual onlyGovernance {
 689 |     |         (bool success, bytes memory returndata) = target.call{value: value}(data);
 690 |     |         Address.verifyCallResult(success, returndata);
 691 |     |     }
 692 |     | 
 693 |     |     /**
 694 |     |      * @dev Address through which the governor executes action. Will be overloaded by module that execute actions
 695 |     |      * through another contract such as a timelock.
 696 |     |      */
 697 |     |     function _executor() internal view virtual returns (address) {
 698 |     |         return address(this);
 699 |     |     }
 700 |     | 
 701 |     |     /**
 702 |     |      * @dev See {IERC721Receiver-onERC721Received}.
 703 |     |      * Receiving tokens is disabled if the governance executor is other than the governor itself (eg. when using with a timelock).
 704 |     |      */
 705 |     |     function onERC721Received(address, address, uint256, bytes memory) public virtual returns (bytes4) {
 706 |     |         if (_executor() != address(this)) {
 707 |     |             revert GovernorDisabledDeposit();
 708 |     |         }
 709 |     |         return this.onERC721Received.selector;
 710 |     |     }
 711 |     | 
 712 |     |     /**
 713 |     |      * @dev See {IERC1155Receiver-onERC1155Received}.
 714 |     |      * Receiving tokens is disabled if the governance executor is other than the governor itself (eg. when using with a timelock).
 715 |     |      */
 716 |     |     function onERC1155Received(address, address, uint256, uint256, bytes memory) public virtual returns (bytes4) {
 717 |     |         if (_executor() != address(this)) {
 718 |     |             revert GovernorDisabledDeposit();
 719 |     |         }
 720 |     |         return this.onERC1155Received.selector;
 721 |     |     }
 722 |     | 
 723 |     |     /**
 724 |     |      * @dev See {IERC1155Receiver-onERC1155BatchReceived}.
 725 |     |      * Receiving tokens is disabled if the governance executor is other than the governor itself (eg. when using with a timelock).
 726 |     |      */
 727 |     |     function onERC1155BatchReceived(
 728 |     |         address,
 729 |     |         address,
 730 |     |         uint256[] memory,
 731 |     |         uint256[] memory,
 732 |     |         bytes memory
 733 |     |     ) public virtual returns (bytes4) {
 734 |     |         if (_executor() != address(this)) {
 735 |     |             revert GovernorDisabledDeposit();
 736 |     |         }
 737 |     |         return this.onERC1155BatchReceived.selector;
 738 |     |     }
 739 |     | 
 740 |     |     /**
 741 |     |      * @dev Encodes a `ProposalState` into a `bytes32` representation where each bit enabled corresponds to
 742 |     |      * the underlying position in the `ProposalState` enum. For example:
 743 |     |      *
 744 |     |      * 0x000...10000
 745 |     |      *   ^^^^^^------ ...
 746 |     |      *         ^----- Succeeded
 747 |     |      *          ^---- Defeated
 748 |     |      *           ^--- Canceled
 749 |     |      *            ^-- Active
 750 |     |      *             ^- Pending
 751 |     |      */
 752 |     |     function _encodeStateBitmap(ProposalState proposalState) internal pure returns (bytes32) {
 753 |     |         return bytes32(1 << uint8(proposalState));
 754 |     |     }
 755 |     | 
 756 |     |     /**
 757 |     |      * @dev Check that the current state of a proposal matches the requirements described by the `allowedStates` bitmap.
 758 |     |      * This bitmap should be built using `_encodeStateBitmap`.
 759 |     |      *
 760 |     |      * If requirements are not met, reverts with a {GovernorUnexpectedProposalState} error.
 761 |     |      */
 762 |     |     function _validateStateBitmap(uint256 proposalId, bytes32 allowedStates) internal view returns (ProposalState) {
 763 |     |         ProposalState currentState = state(proposalId);
 764 |     |         if (_encodeStateBitmap(currentState) & allowedStates == bytes32(0)) {
 765 |     |             revert GovernorUnexpectedProposalState(proposalId, currentState, allowedStates);
 766 |     |         }
 767 |     |         return currentState;
 768 |     |     }
 769 |     | 
 770 |     |     /*
 771 |     |      * @dev Check if the proposer is authorized to submit a proposal with the given description.
 772 |     |      *
 773 |     |      * If the proposal description ends with `#proposer=0x???`, where `0x???` is an address written as a hex string
 774 |     |      * (case insensitive), then the submission of this proposal will only be authorized to said address.
 775 |     |      *
 776 |     |      * This is used for frontrunning protection. By adding this pattern at the end of their proposal, one can ensure
 777 |     |      * that no other address can submit the same proposal. An attacker would have to either remove or change that part,
 778 |     |      * which would result in a different proposal id.
 779 |     |      *
 780 |     |      * If the description does not match this pattern, it is unrestricted and anyone can submit it. This includes:
 781 |     |      * - If the `0x???` part is not a valid hex string.
 782 |     |      * - If the `0x???` part is a valid hex string, but does not contain exactly 40 hex digits.
 783 |     |      * - If it ends with the expected suffix followed by newlines or other whitespace.
 784 |     |      * - If it ends with some other similar suffix, e.g. `#other=abc`.
 785 |     |      * - If it does not end with any such suffix.
 786 |     |      */
 787 |     |     function _isValidDescriptionForProposer(
 788 |     |         address proposer,
 789 |     |         string memory description
 790 |     |     ) internal view virtual returns (bool) {
 791 |     |         unchecked {
 792 |     |             uint256 length = bytes(description).length;
 793 |     | 
 794 |     |             // Length is too short to contain a valid proposer suffix
 795 |     |             if (length < 52) {
 796 |     |                 return true;
 797 |     |             }
 798 |     | 
 799 |     |             // Extract what would be the `#proposer=` marker beginning the suffix
 800 |     |             bytes10 marker = bytes10(_unsafeReadBytesOffset(bytes(description), length - 52));
 801 |     | 
 802 |     |             // If the marker is not found, there is no proposer suffix to check
 803 |     |             if (marker != bytes10("#proposer=")) {
 804 |     |                 return true;
 805 |     |             }
 806 |     | 
 807 |     |             // Check that the last 42 characters (after the marker) are a properly formatted address.
 808 |     |             (bool success, address recovered) = Strings.tryParseAddress(description, length - 42, length);
 809 |     |             return !success || recovered == proposer;
 810 |     |         }
 811 |     |     }
 812 |     | 
 813 |     |     /**
 814 |     |      * @dev Check if the `caller` can cancel the proposal with the given `proposalId`.
 815 |     |      *
 816 |     |      * The default implementation allows the proposal proposer to cancel the proposal during the pending state.
 817 |     |      */
 818 |     |     function _validateCancel(uint256 proposalId, address caller) internal view virtual returns (bool) {
 819 |     |         return (state(proposalId) == ProposalState.Pending) && caller == proposalProposer(proposalId);
 820 |     |     }
 821 |     | 
 822 |     |     /// @inheritdoc IERC6372
 823 |     |     function clock() public view virtual returns (uint48);
 824 |     | 
 825 |     |     /// @inheritdoc IERC6372
 826 |     |     // solhint-disable-next-line func-name-mixedcase
 827 |     |     function CLOCK_MODE() public view virtual returns (string memory);
 828 |     | 
 829 |     |     /// @inheritdoc IGovernor
 830 |     |     function votingDelay() public view virtual returns (uint256);
 831 |     | 
 832 |     |     /// @inheritdoc IGovernor
 833 |     |     function votingPeriod() public view virtual returns (uint256);
 834 |     | 
 835 |     |     /// @inheritdoc IGovernor
 836 |     |     function quorum(uint256 timepoint) public view virtual returns (uint256);
 837 |     | 
 838 |     |     /**
 839 |     |      * @dev Reads a bytes32 from a bytes array without bounds checking.
 840 |     |      *
 841 |     |      * NOTE: making this function internal would mean it could be used with memory unsafe offset, and marking the
 842 |     |      * assembly block as such would prevent some optimizations.
 843 |     |      */
 844 |     |     function _unsafeReadBytesOffset(bytes memory buffer, uint256 offset) private pure returns (bytes32 value) {
 845 |     |         // This is not memory safe in the general case, but all calls to this private function are within bounds.
 846 |     |         assembly ("memory-safe") {
 847 |     |             value := mload(add(add(buffer, 0x20), offset))
 848 |     |         }
 849 |     |     }
 850 |     | }
 851 |     | 

/home/phantom/Documents/azemora/azemora-contracts/lib/openzeppelin-contracts-upgradeable/contracts/governance/TimelockControllerUpgradeable.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | // OpenZeppelin Contracts (last updated v5.3.0) (governance/TimelockController.sol)
   3 |     | 
   4 |     | pragma solidity ^0.8.20;
   5 |     | 
   6 |     | import {AccessControlUpgradeable} from "../access/AccessControlUpgradeable.sol";
   7 |     | import {ERC721HolderUpgradeable} from "../token/ERC721/utils/ERC721HolderUpgradeable.sol";
   8 |     | import {ERC1155HolderUpgradeable} from "../token/ERC1155/utils/ERC1155HolderUpgradeable.sol";
   9 |     | import {Address} from "@openzeppelin/contracts/utils/Address.sol";
  10 |     | import {IERC165} from "@openzeppelin/contracts/utils/introspection/IERC165.sol";
  11 |     | import {Initializable} from "../proxy/utils/Initializable.sol";
  12 |     | 
  13 |     | /**
  14 |     |  * @dev Contract module which acts as a timelocked controller. When set as the
  15 |     |  * owner of an `Ownable` smart contract, it enforces a timelock on all
  16 |     |  * `onlyOwner` maintenance operations. This gives time for users of the
  17 |     |  * controlled contract to exit before a potentially dangerous maintenance
  18 |     |  * operation is applied.
  19 |     |  *
  20 |     |  * By default, this contract is self administered, meaning administration tasks
  21 |     |  * have to go through the timelock process. The proposer (resp executor) role
  22 |     |  * is in charge of proposing (resp executing) operations. A common use case is
  23 |     |  * to position this {TimelockController} as the owner of a smart contract, with
  24 |     |  * a multisig or a DAO as the sole proposer.
  25 |     |  */
  26 |     | contract TimelockControllerUpgradeable is Initializable, AccessControlUpgradeable, ERC721HolderUpgradeable, ERC1155HolderUpgradeable {
  27 |     |     bytes32 public constant PROPOSER_ROLE = keccak256("PROPOSER_ROLE");
  28 |     |     bytes32 public constant EXECUTOR_ROLE = keccak256("EXECUTOR_ROLE");
  29 |     |     bytes32 public constant CANCELLER_ROLE = keccak256("CANCELLER_ROLE");
  30 |     |     uint256 internal constant _DONE_TIMESTAMP = uint256(1);
  31 |     | 
  32 |     |     /// @custom:storage-location erc7201:openzeppelin.storage.TimelockController
  33 |     |     struct TimelockControllerStorage {
  34 |     |         mapping(bytes32 id => uint256) _timestamps;
  35 |     |         uint256 _minDelay;
  36 |     |     }
  37 |     | 
  38 |     |     // keccak256(abi.encode(uint256(keccak256("openzeppelin.storage.TimelockController")) - 1)) & ~bytes32(uint256(0xff))
  39 |     |     bytes32 private constant TimelockControllerStorageLocation = 0x9a37c2aa9d186a0969ff8a8267bf4e07e864c2f2768f5040949e28a624fb3600;
  40 |     | 
  41 |     |     function _getTimelockControllerStorage() private pure returns (TimelockControllerStorage storage $) {
  42 |     |         assembly {
  43 |     |             $.slot := TimelockControllerStorageLocation
  44 |     |         }
  45 |     |     }
  46 |     | 
  47 |     |     enum OperationState {
  48 |     |         Unset,
  49 |     |         Waiting,
  50 |     |         Ready,
  51 |     |         Done
  52 |     |     }
  53 |     | 
  54 |     |     /**
  55 |     |      * @dev Mismatch between the parameters length for an operation call.
  56 |     |      */
  57 |     |     error TimelockInvalidOperationLength(uint256 targets, uint256 payloads, uint256 values);
  58 |     | 
  59 |     |     /**
  60 |     |      * @dev The schedule operation doesn't meet the minimum delay.
  61 |     |      */
  62 |     |     error TimelockInsufficientDelay(uint256 delay, uint256 minDelay);
  63 |     | 
  64 |     |     /**
  65 |     |      * @dev The current state of an operation is not as required.
  66 |     |      * The `expectedStates` is a bitmap with the bits enabled for each OperationState enum position
  67 |     |      * counting from right to left.
  68 |     |      *
  69 |     |      * See {_encodeStateBitmap}.
  70 |     |      */
  71 |     |     error TimelockUnexpectedOperationState(bytes32 operationId, bytes32 expectedStates);
  72 |     | 
  73 |     |     /**
  74 |     |      * @dev The predecessor to an operation not yet done.
  75 |     |      */
  76 |     |     error TimelockUnexecutedPredecessor(bytes32 predecessorId);
  77 |     | 
  78 |     |     /**
  79 |     |      * @dev The caller account is not authorized.
  80 |     |      */
  81 |     |     error TimelockUnauthorizedCaller(address caller);
  82 |     | 
  83 |     |     /**
  84 |     |      * @dev Emitted when a call is scheduled as part of operation `id`.
  85 |     |      */
  86 |     |     event CallScheduled(
  87 |     |         bytes32 indexed id,
  88 |     |         uint256 indexed index,
  89 |     |         address target,
  90 |     |         uint256 value,
  91 |     |         bytes data,
  92 |     |         bytes32 predecessor,
  93 |     |         uint256 delay
  94 |     |     );
  95 |     | 
  96 |     |     /**
  97 |     |      * @dev Emitted when a call is performed as part of operation `id`.
  98 |     |      */
  99 |     |     event CallExecuted(bytes32 indexed id, uint256 indexed index, address target, uint256 value, bytes data);
 100 |     | 
 101 |     |     /**
 102 |     |      * @dev Emitted when new proposal is scheduled with non-zero salt.
 103 |     |      */
 104 |     |     event CallSalt(bytes32 indexed id, bytes32 salt);
 105 |     | 
 106 |     |     /**
 107 |     |      * @dev Emitted when operation `id` is cancelled.
 108 |     |      */
 109 |     |     event Cancelled(bytes32 indexed id);
 110 |     | 
 111 |     |     /**
 112 |     |      * @dev Emitted when the minimum delay for future operations is modified.
 113 |     |      */
 114 |     |     event MinDelayChange(uint256 oldDuration, uint256 newDuration);
 115 |     | 
 116 |     |     function initialize(uint256 minDelay, address[] memory proposers, address[] memory executors, address admin) public virtual initializer {
 117 |     |         __TimelockController_init(minDelay, proposers, executors, admin);
 118 |     |     }
 119 |     |     /**
 120 |     |      * @dev Initializes the contract with the following parameters:
 121 |     |      *
 122 |     |      * - `minDelay`: initial minimum delay in seconds for operations
 123 |     |      * - `proposers`: accounts to be granted proposer and canceller roles
 124 |     |      * - `executors`: accounts to be granted executor role
 125 |     |      * - `admin`: optional account to be granted admin role; disable with zero address
 126 |     |      *
 127 |     |      * IMPORTANT: The optional admin can aid with initial configuration of roles after deployment
 128 |     |      * without being subject to delay, but this role should be subsequently renounced in favor of
 129 |     |      * administration through timelocked proposals. Previous versions of this contract would assign
 130 |     |      * this admin to the deployer automatically and should be renounced as well.
 131 |     |      */
 132 |     |     function __TimelockController_init(uint256 minDelay, address[] memory proposers, address[] memory executors, address admin) internal onlyInitializing {
 133 |     |         __TimelockController_init_unchained(minDelay, proposers, executors, admin);
 134 |     |     }
 135 |     | 
 136 |     |     function __TimelockController_init_unchained(uint256 minDelay, address[] memory proposers, address[] memory executors, address admin) internal onlyInitializing {
 137 |     |         TimelockControllerStorage storage $ = _getTimelockControllerStorage();
 138 |     |         // self administration
 139 |     |         _grantRole(DEFAULT_ADMIN_ROLE, address(this));
 140 |     | 
 141 |     |         // optional admin
 142 |     |         if (admin != address(0)) {
 143 |     |             _grantRole(DEFAULT_ADMIN_ROLE, admin);
 144 |     |         }
 145 |     | 
 146 |     |         // register proposers and cancellers
 147 |     |         for (uint256 i = 0; i < proposers.length; ++i) {
 148 |     |             _grantRole(PROPOSER_ROLE, proposers[i]);
 149 |     |             _grantRole(CANCELLER_ROLE, proposers[i]);
 150 |     |         }
 151 |     | 
 152 |     |         // register executors
 153 |     |         for (uint256 i = 0; i < executors.length; ++i) {
 154 |     |             _grantRole(EXECUTOR_ROLE, executors[i]);
 155 |     |         }
 156 |     | 
 157 |     |         $._minDelay = minDelay;
 158 |     |         emit MinDelayChange(0, minDelay);
 159 |     |     }
 160 |     | 
 161 |     |     /**
 162 |     |      * @dev Modifier to make a function callable only by a certain role. In
 163 |     |      * addition to checking the sender's role, `address(0)` 's role is also
 164 |     |      * considered. Granting a role to `address(0)` is equivalent to enabling
 165 |     |      * this role for everyone.
 166 |     |      */
 167 |     |     modifier onlyRoleOrOpenRole(bytes32 role) {
 168 |     |         if (!hasRole(role, address(0))) {
 169 |     |             _checkRole(role, _msgSender());
 170 |     |         }
 171 |     |         _;
 172 |     |     }
 173 |     | 
 174 |     |     /**
 175 |     |      * @dev Contract might receive/hold ETH as part of the maintenance process.
 176 |     |      */
 177 |     |     receive() external payable virtual {}
 178 |     | 
 179 |     |     /// @inheritdoc IERC165
 180 |     |     function supportsInterface(
 181 |     |         bytes4 interfaceId
 182 |     |     ) public view virtual override(AccessControlUpgradeable, ERC1155HolderUpgradeable) returns (bool) {
 183 |     |         return super.supportsInterface(interfaceId);
 184 |     |     }
 185 |     | 
 186 |     |     /**
 187 |     |      * @dev Returns whether an id corresponds to a registered operation. This
 188 |     |      * includes both Waiting, Ready, and Done operations.
 189 |     |      */
 190 |     |     function isOperation(bytes32 id) public view returns (bool) {
 191 |     |         return getOperationState(id) != OperationState.Unset;
 192 |     |     }
 193 |     | 
 194 |     |     /**
 195 |     |      * @dev Returns whether an operation is pending or not. Note that a "pending" operation may also be "ready".
 196 |     |      */
 197 |     |     function isOperationPending(bytes32 id) public view returns (bool) {
 198 |     |         OperationState state = getOperationState(id);
 199 |     |         return state == OperationState.Waiting || state == OperationState.Ready;
 200 |     |     }
 201 |     | 
 202 |     |     /**
 203 |     |      * @dev Returns whether an operation is ready for execution. Note that a "ready" operation is also "pending".
 204 |     |      */
 205 |     |     function isOperationReady(bytes32 id) public view returns (bool) {
 206 |     |         return getOperationState(id) == OperationState.Ready;
 207 |     |     }
 208 |     | 
 209 |     |     /**
 210 |     |      * @dev Returns whether an operation is done or not.
 211 |     |      */
 212 |     |     function isOperationDone(bytes32 id) public view returns (bool) {
 213 |     |         return getOperationState(id) == OperationState.Done;
 214 |     |     }
 215 |     | 
 216 |     |     /**
 217 |     |      * @dev Returns the timestamp at which an operation becomes ready (0 for
 218 |     |      * unset operations, 1 for done operations).
 219 |     |      */
 220 |     |     function getTimestamp(bytes32 id) public view virtual returns (uint256) {
 221 |     |         TimelockControllerStorage storage $ = _getTimelockControllerStorage();
 222 |     |         return $._timestamps[id];
 223 |     |     }
 224 |     | 
 225 |     |     /**
 226 |     |      * @dev Returns operation state.
 227 |     |      */
 228 |     |     function getOperationState(bytes32 id) public view virtual returns (OperationState) {
 229 |     |         uint256 timestamp = getTimestamp(id);
 230 |     |         if (timestamp == 0) {
 231 |     |             return OperationState.Unset;
 232 |     |         } else if (timestamp == _DONE_TIMESTAMP) {
 233 |     |             return OperationState.Done;
 234 |     |         } else if (timestamp > block.timestamp) {
 235 |     |             return OperationState.Waiting;
 236 |     |         } else {
 237 |     |             return OperationState.Ready;
 238 |     |         }
 239 |     |     }
 240 |     | 
 241 |     |     /**
 242 |     |      * @dev Returns the minimum delay in seconds for an operation to become valid.
 243 |     |      *
 244 |     |      * This value can be changed by executing an operation that calls `updateDelay`.
 245 |     |      */
 246 |     |     function getMinDelay() public view virtual returns (uint256) {
 247 |     |         TimelockControllerStorage storage $ = _getTimelockControllerStorage();
 248 |     |         return $._minDelay;
 249 |     |     }
 250 |     | 
 251 |     |     /**
 252 |     |      * @dev Returns the identifier of an operation containing a single
 253 |     |      * transaction.
 254 |     |      */
 255 |     |     function hashOperation(
 256 |     |         address target,
 257 |     |         uint256 value,
 258 |     |         bytes calldata data,
 259 |     |         bytes32 predecessor,
 260 |     |         bytes32 salt
 261 |     |     ) public pure virtual returns (bytes32) {
 262 |     |         return keccak256(abi.encode(target, value, data, predecessor, salt));
 263 |     |     }
 264 |     | 
 265 |     |     /**
 266 |     |      * @dev Returns the identifier of an operation containing a batch of
 267 |     |      * transactions.
 268 |     |      */
 269 |     |     function hashOperationBatch(
 270 |     |         address[] calldata targets,
 271 |     |         uint256[] calldata values,
 272 |     |         bytes[] calldata payloads,
 273 |     |         bytes32 predecessor,
 274 |     |         bytes32 salt
 275 |     |     ) public pure virtual returns (bytes32) {
 276 |     |         return keccak256(abi.encode(targets, values, payloads, predecessor, salt));
 277 |     |     }
 278 |     | 
 279 |     |     /**
 280 |     |      * @dev Schedule an operation containing a single transaction.
 281 |     |      *
 282 |     |      * Emits {CallSalt} if salt is nonzero, and {CallScheduled}.
 283 |     |      *
 284 |     |      * Requirements:
 285 |     |      *
 286 |     |      * - the caller must have the 'proposer' role.
 287 |     |      */
 288 |     |     function schedule(
 289 |     |         address target,
 290 |     |         uint256 value,
 291 |     |         bytes calldata data,
 292 |     |         bytes32 predecessor,
 293 |     |         bytes32 salt,
 294 |     |         uint256 delay
 295 |     |     ) public virtual onlyRole(PROPOSER_ROLE) {
 296 |     |         bytes32 id = hashOperation(target, value, data, predecessor, salt);
 297 |     |         _schedule(id, delay);
 298 |     |         emit CallScheduled(id, 0, target, value, data, predecessor, delay);
 299 |     |         if (salt != bytes32(0)) {
 300 |     |             emit CallSalt(id, salt);
 301 |     |         }
 302 |     |     }
 303 |     | 
 304 |     |     /**
 305 |     |      * @dev Schedule an operation containing a batch of transactions.
 306 |     |      *
 307 |     |      * Emits {CallSalt} if salt is nonzero, and one {CallScheduled} event per transaction in the batch.
 308 |     |      *
 309 |     |      * Requirements:
 310 |     |      *
 311 |     |      * - the caller must have the 'proposer' role.
 312 |     |      */
 313 |     |     function scheduleBatch(
 314 |     |         address[] calldata targets,
 315 |     |         uint256[] calldata values,
 316 |     |         bytes[] calldata payloads,
 317 |     |         bytes32 predecessor,
 318 |     |         bytes32 salt,
 319 |     |         uint256 delay
 320 |     |     ) public virtual onlyRole(PROPOSER_ROLE) {
 321 |     |         if (targets.length != values.length || targets.length != payloads.length) {
 322 |     |             revert TimelockInvalidOperationLength(targets.length, payloads.length, values.length);
 323 |     |         }
 324 |     | 
 325 |     |         bytes32 id = hashOperationBatch(targets, values, payloads, predecessor, salt);
 326 |     |         _schedule(id, delay);
 327 |     |         for (uint256 i = 0; i < targets.length; ++i) {
 328 |     |             emit CallScheduled(id, i, targets[i], values[i], payloads[i], predecessor, delay);
 329 |     |         }
 330 |     |         if (salt != bytes32(0)) {
 331 |     |             emit CallSalt(id, salt);
 332 |     |         }
 333 |     |     }
 334 |     | 
 335 |     |     /**
 336 |     |      * @dev Schedule an operation that is to become valid after a given delay.
 337 |     |      */
 338 |     |     function _schedule(bytes32 id, uint256 delay) private {
 339 |     |         TimelockControllerStorage storage $ = _getTimelockControllerStorage();
 340 |     |         if (isOperation(id)) {
 341 |     |             revert TimelockUnexpectedOperationState(id, _encodeStateBitmap(OperationState.Unset));
 342 |     |         }
 343 |     |         uint256 minDelay = getMinDelay();
 344 |     |         if (delay < minDelay) {
 345 |     |             revert TimelockInsufficientDelay(delay, minDelay);
 346 |     |         }
 347 |     |         $._timestamps[id] = block.timestamp + delay;
 348 |     |     }
 349 |     | 
 350 |     |     /**
 351 |     |      * @dev Cancel an operation.
 352 |     |      *
 353 |     |      * Requirements:
 354 |     |      *
 355 |     |      * - the caller must have the 'canceller' role.
 356 |     |      */
 357 |     |     function cancel(bytes32 id) public virtual onlyRole(CANCELLER_ROLE) {
 358 |     |         TimelockControllerStorage storage $ = _getTimelockControllerStorage();
 359 |     |         if (!isOperationPending(id)) {
 360 |     |             revert TimelockUnexpectedOperationState(
 361 |     |                 id,
 362 |     |                 _encodeStateBitmap(OperationState.Waiting) | _encodeStateBitmap(OperationState.Ready)
 363 |     |             );
 364 |     |         }
 365 |     |         delete $._timestamps[id];
 366 |     | 
 367 |     |         emit Cancelled(id);
 368 |     |     }
 369 |     | 
 370 |     |     /**
 371 |     |      * @dev Execute an (ready) operation containing a single transaction.
 372 |     |      *
 373 |     |      * Emits a {CallExecuted} event.
 374 |     |      *
 375 |     |      * Requirements:
 376 |     |      *
 377 |     |      * - the caller must have the 'executor' role.
 378 |     |      */
 379 |     |     // This function can reenter, but it doesn't pose a risk because _afterCall checks that the proposal is pending,
 380 |     |     // thus any modifications to the operation during reentrancy should be caught.
 381 |     |     // slither-disable-next-line reentrancy-eth
 382 |     |     function execute(
 383 |     |         address target,
 384 |     |         uint256 value,
 385 |     |         bytes calldata payload,
 386 |     |         bytes32 predecessor,
 387 |     |         bytes32 salt
 388 |     |     ) public payable virtual onlyRoleOrOpenRole(EXECUTOR_ROLE) {
 389 |     |         bytes32 id = hashOperation(target, value, payload, predecessor, salt);
 390 |     | 
 391 |     |         _beforeCall(id, predecessor);
 392 |     |         _execute(target, value, payload);
 393 |     |         emit CallExecuted(id, 0, target, value, payload);
 394 |     |         _afterCall(id);
 395 |     |     }
 396 |     | 
 397 |     |     /**
 398 |     |      * @dev Execute an (ready) operation containing a batch of transactions.
 399 |     |      *
 400 |     |      * Emits one {CallExecuted} event per transaction in the batch.
 401 |     |      *
 402 |     |      * Requirements:
 403 |     |      *
 404 |     |      * - the caller must have the 'executor' role.
 405 |     |      */
 406 |     |     // This function can reenter, but it doesn't pose a risk because _afterCall checks that the proposal is pending,
 407 |     |     // thus any modifications to the operation during reentrancy should be caught.
 408 |     |     // slither-disable-next-line reentrancy-eth
 409 |     |     function executeBatch(
 410 |     |         address[] calldata targets,
 411 |     |         uint256[] calldata values,
 412 |     |         bytes[] calldata payloads,
 413 |     |         bytes32 predecessor,
 414 |     |         bytes32 salt
 415 |     |     ) public payable virtual onlyRoleOrOpenRole(EXECUTOR_ROLE) {
 416 |     |         if (targets.length != values.length || targets.length != payloads.length) {
 417 |     |             revert TimelockInvalidOperationLength(targets.length, payloads.length, values.length);
 418 |     |         }
 419 |     | 
 420 |     |         bytes32 id = hashOperationBatch(targets, values, payloads, predecessor, salt);
 421 |     | 
 422 |     |         _beforeCall(id, predecessor);
 423 |     |         for (uint256 i = 0; i < targets.length; ++i) {
 424 |     |             address target = targets[i];
 425 |     |             uint256 value = values[i];
 426 |     |             bytes calldata payload = payloads[i];
 427 |     |             _execute(target, value, payload);
 428 |     |             emit CallExecuted(id, i, target, value, payload);
 429 |     |         }
 430 |     |         _afterCall(id);
 431 |     |     }
 432 |     | 
 433 |     |     /**
 434 |     |      * @dev Execute an operation's call.
 435 |     |      */
 436 |     |     function _execute(address target, uint256 value, bytes calldata data) internal virtual {
 437 |     |         (bool success, bytes memory returndata) = target.call{value: value}(data);
 438 |     |         Address.verifyCallResult(success, returndata);
 439 |     |     }
 440 |     | 
 441 |     |     /**
 442 |     |      * @dev Checks before execution of an operation's calls.
 443 |     |      */
 444 |     |     function _beforeCall(bytes32 id, bytes32 predecessor) private view {
 445 |     |         if (!isOperationReady(id)) {
 446 |     |             revert TimelockUnexpectedOperationState(id, _encodeStateBitmap(OperationState.Ready));
 447 |     |         }
 448 |     |         if (predecessor != bytes32(0) && !isOperationDone(predecessor)) {
 449 |     |             revert TimelockUnexecutedPredecessor(predecessor);
 450 |     |         }
 451 |     |     }
 452 |     | 
 453 |     |     /**
 454 |     |      * @dev Checks after execution of an operation's calls.
 455 |     |      */
 456 |     |     function _afterCall(bytes32 id) private {
 457 |     |         TimelockControllerStorage storage $ = _getTimelockControllerStorage();
 458 |     |         if (!isOperationReady(id)) {
 459 |     |             revert TimelockUnexpectedOperationState(id, _encodeStateBitmap(OperationState.Ready));
 460 |     |         }
 461 |     |         $._timestamps[id] = _DONE_TIMESTAMP;
 462 |     |     }
 463 |     | 
 464 |     |     /**
 465 |     |      * @dev Changes the minimum timelock duration for future operations.
 466 |     |      *
 467 |     |      * Emits a {MinDelayChange} event.
 468 |     |      *
 469 |     |      * Requirements:
 470 |     |      *
 471 |     |      * - the caller must be the timelock itself. This can only be achieved by scheduling and later executing
 472 |     |      * an operation where the timelock is the target and the data is the ABI-encoded call to this function.
 473 |     |      */
 474 |     |     function updateDelay(uint256 newDelay) external virtual {
 475 |     |         TimelockControllerStorage storage $ = _getTimelockControllerStorage();
 476 |     |         address sender = _msgSender();
 477 |     |         if (sender != address(this)) {
 478 |     |             revert TimelockUnauthorizedCaller(sender);
 479 |     |         }
 480 |     |         emit MinDelayChange($._minDelay, newDelay);
 481 |     |         $._minDelay = newDelay;
 482 |     |     }
 483 |     | 
 484 |     |     /**
 485 |     |      * @dev Encodes a `OperationState` into a `bytes32` representation where each bit enabled corresponds to
 486 |     |      * the underlying position in the `OperationState` enum. For example:
 487 |     |      *
 488 |     |      * 0x000...1000
 489 |     |      *   ^^^^^^----- ...
 490 |     |      *         ^---- Done
 491 |     |      *          ^--- Ready
 492 |     |      *           ^-- Waiting
 493 |     |      *            ^- Unset
 494 |     |      */
 495 |     |     function _encodeStateBitmap(OperationState operationState) internal pure returns (bytes32) {
 496 |     |         return bytes32(1 << uint8(operationState));
 497 |     |     }
 498 |     | }
 499 |     | 

/home/phantom/Documents/azemora/azemora-contracts/lib/openzeppelin-contracts-upgradeable/contracts/governance/extensions/GovernorCountingSimpleUpgradeable.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | // OpenZeppelin Contracts (last updated v5.1.0) (governance/extensions/GovernorCountingSimple.sol)
   3 |     | 
   4 |     | pragma solidity ^0.8.24;
   5 |     | 
   6 |     | import {IGovernor} from "@openzeppelin/contracts/governance/IGovernor.sol";
   7 |     | import {GovernorUpgradeable} from "../GovernorUpgradeable.sol";
   8 |     | import {Initializable} from "../../proxy/utils/Initializable.sol";
   9 |     | 
  10 |     | /**
  11 |     |  * @dev Extension of {Governor} for simple, 3 options, vote counting.
  12 |     |  */
  13 |     | abstract contract GovernorCountingSimpleUpgradeable is Initializable, GovernorUpgradeable {
  14 |     |     /**
  15 |     |      * @dev Supported vote types. Matches Governor Bravo ordering.
  16 |     |      */
  17 |     |     enum VoteType {
  18 |     |         Against,
  19 |     |         For,
  20 |     |         Abstain
  21 |     |     }
  22 |     | 
  23 |     |     struct ProposalVote {
  24 |     |         uint256 againstVotes;
  25 |     |         uint256 forVotes;
  26 |     |         uint256 abstainVotes;
  27 |     |         mapping(address voter => bool) hasVoted;
  28 |     |     }
  29 |     | 
  30 |     |     /// @custom:storage-location erc7201:openzeppelin.storage.GovernorCountingSimple
  31 |     |     struct GovernorCountingSimpleStorage {
  32 |     |         mapping(uint256 proposalId => ProposalVote) _proposalVotes;
  33 |     |     }
  34 |     | 
  35 |     |     // keccak256(abi.encode(uint256(keccak256("openzeppelin.storage.GovernorCountingSimple")) - 1)) & ~bytes32(uint256(0xff))
  36 |     |     bytes32 private constant GovernorCountingSimpleStorageLocation = 0xa1cefa0f43667ef127a258e673c94202a79b656e62899531c4376d87a7f39800;
  37 |     | 
  38 |     |     function _getGovernorCountingSimpleStorage() private pure returns (GovernorCountingSimpleStorage storage $) {
  39 |     |         assembly {
  40 |     |             $.slot := GovernorCountingSimpleStorageLocation
  41 |     |         }
  42 |     |     }
  43 |     | 
  44 |     |     function __GovernorCountingSimple_init() internal onlyInitializing {
  45 |     |     }
  46 |     | 
  47 |     |     function __GovernorCountingSimple_init_unchained() internal onlyInitializing {
  48 |     |     }
  49 |     |     /// @inheritdoc IGovernor
  50 |     |     // solhint-disable-next-line func-name-mixedcase
  51 |     |     function COUNTING_MODE() public pure virtual override returns (string memory) {
  52 |     |         return "support=bravo&quorum=for,abstain";
  53 |     |     }
  54 |     | 
  55 |     |     /// @inheritdoc IGovernor
  56 |     |     function hasVoted(uint256 proposalId, address account) public view virtual override returns (bool) {
  57 |     |         GovernorCountingSimpleStorage storage $ = _getGovernorCountingSimpleStorage();
  58 |     |         return $._proposalVotes[proposalId].hasVoted[account];
  59 |     |     }
  60 |     | 
  61 |     |     /**
  62 |     |      * @dev Accessor to the internal vote counts.
  63 |     |      */
  64 |     |     function proposalVotes(
  65 |     |         uint256 proposalId
  66 |     |     ) public view virtual returns (uint256 againstVotes, uint256 forVotes, uint256 abstainVotes) {
  67 |     |         GovernorCountingSimpleStorage storage $ = _getGovernorCountingSimpleStorage();
  68 |     |         ProposalVote storage proposalVote = $._proposalVotes[proposalId];
  69 |     |         return (proposalVote.againstVotes, proposalVote.forVotes, proposalVote.abstainVotes);
  70 |     |     }
  71 |     | 
  72 |     |     /// @inheritdoc GovernorUpgradeable
  73 |     |     function _quorumReached(uint256 proposalId) internal view virtual override returns (bool) {
  74 |     |         GovernorCountingSimpleStorage storage $ = _getGovernorCountingSimpleStorage();
  75 |     |         ProposalVote storage proposalVote = $._proposalVotes[proposalId];
  76 |     | 
  77 |     |         return quorum(proposalSnapshot(proposalId)) <= proposalVote.forVotes + proposalVote.abstainVotes;
  78 |     |     }
  79 |     | 
  80 |     |     /**
  81 |     |      * @dev See {Governor-_voteSucceeded}. In this module, the forVotes must be strictly over the againstVotes.
  82 |     |      */
  83 |     |     function _voteSucceeded(uint256 proposalId) internal view virtual override returns (bool) {
  84 |     |         GovernorCountingSimpleStorage storage $ = _getGovernorCountingSimpleStorage();
  85 |     |         ProposalVote storage proposalVote = $._proposalVotes[proposalId];
  86 |     | 
  87 |     |         return proposalVote.forVotes > proposalVote.againstVotes;
  88 |     |     }
  89 |     | 
  90 |     |     /**
  91 |     |      * @dev See {Governor-_countVote}. In this module, the support follows the `VoteType` enum (from Governor Bravo).
  92 |     |      */
  93 |     |     function _countVote(
  94 |     |         uint256 proposalId,
  95 |     |         address account,
  96 |     |         uint8 support,
  97 |     |         uint256 totalWeight,
  98 |     |         bytes memory // params
  99 | *   |     ) internal virtual override returns (uint256) {
 100 | *   |         GovernorCountingSimpleStorage storage $ = _getGovernorCountingSimpleStorage();
 101 | *   |         ProposalVote storage proposalVote = $._proposalVotes[proposalId];
 102 |     | 
 103 | *   |         if (proposalVote.hasVoted[account]) {
 104 | *   |             revert GovernorAlreadyCastVote(account);
 105 |     |         }
 106 |     |         proposalVote.hasVoted[account] = true;
 107 |     | 
 108 |     |         if (support == uint8(VoteType.Against)) {
 109 |     |             proposalVote.againstVotes += totalWeight;
 110 |     |         } else if (support == uint8(VoteType.For)) {
 111 | *   |             proposalVote.forVotes += totalWeight;
 112 |     |         } else if (support == uint8(VoteType.Abstain)) {
 113 |     |             proposalVote.abstainVotes += totalWeight;
 114 |     |         } else {
 115 | *   |             revert GovernorInvalidVoteType();
 116 |     |         }
 117 |     | 
 118 |     |         return totalWeight;
 119 |     |     }
 120 |     | }
 121 | *   | 

/home/phantom/Documents/azemora/azemora-contracts/lib/openzeppelin-contracts-upgradeable/contracts/governance/extensions/GovernorSettingsUpgradeable.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | // OpenZeppelin Contracts (last updated v5.0.0) (governance/extensions/GovernorSettings.sol)
   3 |     | 
   4 |     | pragma solidity ^0.8.24;
   5 |     | 
   6 |     | import {IGovernor} from "@openzeppelin/contracts/governance/IGovernor.sol";
   7 |     | import {GovernorUpgradeable} from "../GovernorUpgradeable.sol";
   8 |     | import {Initializable} from "../../proxy/utils/Initializable.sol";
   9 |     | 
  10 |     | /**
  11 |     |  * @dev Extension of {Governor} for settings updatable through governance.
  12 |     |  */
  13 |     | abstract contract GovernorSettingsUpgradeable is Initializable, GovernorUpgradeable {
  14 |     |     /// @custom:storage-location erc7201:openzeppelin.storage.GovernorSettings
  15 |     |     struct GovernorSettingsStorage {
  16 |     |         // amount of token
  17 |     |         uint256 _proposalThreshold;
  18 |     |         // timepoint: limited to uint48 in core (same as clock() type)
  19 |     |         uint48 _votingDelay;
  20 |     |         // duration: limited to uint32 in core
  21 |     |         uint32 _votingPeriod;
  22 |     |     }
  23 |     | 
  24 |     |     // keccak256(abi.encode(uint256(keccak256("openzeppelin.storage.GovernorSettings")) - 1)) & ~bytes32(uint256(0xff))
  25 |     |     bytes32 private constant GovernorSettingsStorageLocation = 0x00d7616c8fe29c6c2fbe1d0c5bc8f2faa4c35b43746e70b24b4d532752affd00;
  26 |     | 
  27 |     |     function _getGovernorSettingsStorage() private pure returns (GovernorSettingsStorage storage $) {
  28 |     |         assembly {
  29 |     |             $.slot := GovernorSettingsStorageLocation
  30 |     |         }
  31 |     |     }
  32 |     | 
  33 |     |     event VotingDelaySet(uint256 oldVotingDelay, uint256 newVotingDelay);
  34 |     |     event VotingPeriodSet(uint256 oldVotingPeriod, uint256 newVotingPeriod);
  35 |     |     event ProposalThresholdSet(uint256 oldProposalThreshold, uint256 newProposalThreshold);
  36 |     | 
  37 |     |     /**
  38 |     |      * @dev Initialize the governance parameters.
  39 |     |      */
  40 |     |     function __GovernorSettings_init(uint48 initialVotingDelay, uint32 initialVotingPeriod, uint256 initialProposalThreshold) internal onlyInitializing {
  41 |     |         __GovernorSettings_init_unchained(initialVotingDelay, initialVotingPeriod, initialProposalThreshold);
  42 |     |     }
  43 |     | 
  44 |     |     function __GovernorSettings_init_unchained(uint48 initialVotingDelay, uint32 initialVotingPeriod, uint256 initialProposalThreshold) internal onlyInitializing {
  45 |     |         _setVotingDelay(initialVotingDelay);
  46 |     |         _setVotingPeriod(initialVotingPeriod);
  47 |     |         _setProposalThreshold(initialProposalThreshold);
  48 |     |     }
  49 |     | 
  50 |     |     /// @inheritdoc IGovernor
  51 |     |     function votingDelay() public view virtual override returns (uint256) {
  52 |     |         GovernorSettingsStorage storage $ = _getGovernorSettingsStorage();
  53 |     |         return $._votingDelay;
  54 |     |     }
  55 |     | 
  56 |     |     /// @inheritdoc IGovernor
  57 |     |     function votingPeriod() public view virtual override returns (uint256) {
  58 |     |         GovernorSettingsStorage storage $ = _getGovernorSettingsStorage();
  59 |     |         return $._votingPeriod;
  60 |     |     }
  61 |     | 
  62 |     |     /// @inheritdoc GovernorUpgradeable
  63 |     |     function proposalThreshold() public view virtual override returns (uint256) {
  64 |     |         GovernorSettingsStorage storage $ = _getGovernorSettingsStorage();
  65 |     |         return $._proposalThreshold;
  66 |     |     }
  67 |     | 
  68 |     |     /**
  69 |     |      * @dev Update the voting delay. This operation can only be performed through a governance proposal.
  70 |     |      *
  71 |     |      * Emits a {VotingDelaySet} event.
  72 |     |      */
  73 |     |     function setVotingDelay(uint48 newVotingDelay) public virtual onlyGovernance {
  74 |     |         _setVotingDelay(newVotingDelay);
  75 |     |     }
  76 |     | 
  77 |     |     /**
  78 |     |      * @dev Update the voting period. This operation can only be performed through a governance proposal.
  79 |     |      *
  80 |     |      * Emits a {VotingPeriodSet} event.
  81 |     |      */
  82 |     |     function setVotingPeriod(uint32 newVotingPeriod) public virtual onlyGovernance {
  83 |     |         _setVotingPeriod(newVotingPeriod);
  84 |     |     }
  85 |     | 
  86 |     |     /**
  87 |     |      * @dev Update the proposal threshold. This operation can only be performed through a governance proposal.
  88 |     |      *
  89 |     |      * Emits a {ProposalThresholdSet} event.
  90 |     |      */
  91 |     |     function setProposalThreshold(uint256 newProposalThreshold) public virtual onlyGovernance {
  92 |     |         _setProposalThreshold(newProposalThreshold);
  93 |     |     }
  94 |     | 
  95 |     |     /**
  96 |     |      * @dev Internal setter for the voting delay.
  97 |     |      *
  98 |     |      * Emits a {VotingDelaySet} event.
  99 |     |      */
 100 |     |     function _setVotingDelay(uint48 newVotingDelay) internal virtual {
 101 |     |         GovernorSettingsStorage storage $ = _getGovernorSettingsStorage();
 102 |     |         emit VotingDelaySet($._votingDelay, newVotingDelay);
 103 |     |         $._votingDelay = newVotingDelay;
 104 |     |     }
 105 |     | 
 106 |     |     /**
 107 |     |      * @dev Internal setter for the voting period.
 108 |     |      *
 109 |     |      * Emits a {VotingPeriodSet} event.
 110 |     |      */
 111 |     |     function _setVotingPeriod(uint32 newVotingPeriod) internal virtual {
 112 |     |         GovernorSettingsStorage storage $ = _getGovernorSettingsStorage();
 113 |     |         if (newVotingPeriod == 0) {
 114 |     |             revert GovernorInvalidVotingPeriod(0);
 115 |     |         }
 116 |     |         emit VotingPeriodSet($._votingPeriod, newVotingPeriod);
 117 |     |         $._votingPeriod = newVotingPeriod;
 118 |     |     }
 119 |     | 
 120 |     |     /**
 121 |     |      * @dev Internal setter for the proposal threshold.
 122 |     |      *
 123 |     |      * Emits a {ProposalThresholdSet} event.
 124 |     |      */
 125 |     |     function _setProposalThreshold(uint256 newProposalThreshold) internal virtual {
 126 |     |         GovernorSettingsStorage storage $ = _getGovernorSettingsStorage();
 127 |     |         emit ProposalThresholdSet($._proposalThreshold, newProposalThreshold);
 128 |     |         $._proposalThreshold = newProposalThreshold;
 129 |     |     }
 130 |     | }
 131 | *   | 

/home/phantom/Documents/azemora/azemora-contracts/lib/openzeppelin-contracts-upgradeable/contracts/governance/extensions/GovernorTimelockControlUpgradeable.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | // OpenZeppelin Contracts (last updated v5.3.0) (governance/extensions/GovernorTimelockControl.sol)
   3 |     | 
   4 |     | pragma solidity ^0.8.24;
   5 |     | 
   6 |     | import {IGovernor} from "@openzeppelin/contracts/governance/IGovernor.sol";
   7 |     | import {GovernorUpgradeable} from "../GovernorUpgradeable.sol";
   8 |     | import {TimelockControllerUpgradeable} from "../TimelockControllerUpgradeable.sol";
   9 |     | import {SafeCast} from "@openzeppelin/contracts/utils/math/SafeCast.sol";
  10 |     | import {Initializable} from "../../proxy/utils/Initializable.sol";
  11 |     | 
  12 |     | /**
  13 |     |  * @dev Extension of {Governor} that binds the execution process to an instance of {TimelockController}. This adds a
  14 |     |  * delay, enforced by the {TimelockController} to all successful proposal (in addition to the voting duration). The
  15 |     |  * {Governor} needs the proposer (and ideally the executor and canceller) roles for the {Governor} to work properly.
  16 |     |  *
  17 |     |  * Using this model means the proposal will be operated by the {TimelockController} and not by the {Governor}. Thus,
  18 |     |  * the assets and permissions must be attached to the {TimelockController}. Any asset sent to the {Governor} will be
  19 |     |  * inaccessible from a proposal, unless executed via {Governor-relay}.
  20 |     |  *
  21 |     |  * WARNING: Setting up the TimelockController to have additional proposers or cancelers besides the governor is very
  22 |     |  * risky, as it grants them the ability to: 1) execute operations as the timelock, and thus possibly performing
  23 |     |  * operations or accessing funds that are expected to only be accessible through a vote, and 2) block governance
  24 |     |  * proposals that have been approved by the voters, effectively executing a Denial of Service attack.
  25 |     |  */
  26 |     | abstract contract GovernorTimelockControlUpgradeable is Initializable, GovernorUpgradeable {
  27 |     |     /// @custom:storage-location erc7201:openzeppelin.storage.GovernorTimelockControl
  28 |     |     struct GovernorTimelockControlStorage {
  29 |     |         TimelockControllerUpgradeable _timelock;
  30 |     |         mapping(uint256 proposalId => bytes32) _timelockIds;
  31 |     |     }
  32 |     | 
  33 |     |     // keccak256(abi.encode(uint256(keccak256("openzeppelin.storage.GovernorTimelockControl")) - 1)) & ~bytes32(uint256(0xff))
  34 |     |     bytes32 private constant GovernorTimelockControlStorageLocation = 0x0d5829787b8befdbc6044ef7457d8a95c2a04bc99235349f1a212c063e59d400;
  35 |     | 
  36 |     |     function _getGovernorTimelockControlStorage() private pure returns (GovernorTimelockControlStorage storage $) {
  37 |     |         assembly {
  38 |     |             $.slot := GovernorTimelockControlStorageLocation
  39 |     |         }
  40 |     |     }
  41 |     | 
  42 |     |     /**
  43 |     |      * @dev Emitted when the timelock controller used for proposal execution is modified.
  44 |     |      */
  45 |     |     event TimelockChange(address oldTimelock, address newTimelock);
  46 |     | 
  47 |     |     /**
  48 |     |      * @dev Set the timelock.
  49 |     |      */
  50 |     |     function __GovernorTimelockControl_init(TimelockControllerUpgradeable timelockAddress) internal onlyInitializing {
  51 |     |         __GovernorTimelockControl_init_unchained(timelockAddress);
  52 |     |     }
  53 |     | 
  54 |     |     function __GovernorTimelockControl_init_unchained(TimelockControllerUpgradeable timelockAddress) internal onlyInitializing {
  55 |     |         _updateTimelock(timelockAddress);
  56 |     |     }
  57 |     | 
  58 |     |     /**
  59 |     |      * @dev Overridden version of the {Governor-state} function that considers the status reported by the timelock.
  60 |     |      */
  61 |     |     function state(uint256 proposalId) public view virtual override returns (ProposalState) {
  62 |     |         GovernorTimelockControlStorage storage $ = _getGovernorTimelockControlStorage();
  63 |     |         ProposalState currentState = super.state(proposalId);
  64 |     | 
  65 |     |         if (currentState != ProposalState.Queued) {
  66 |     |             return currentState;
  67 |     |         }
  68 |     | 
  69 |     |         bytes32 queueid = $._timelockIds[proposalId];
  70 |     |         if ($._timelock.isOperationPending(queueid)) {
  71 |     |             return ProposalState.Queued;
  72 |     |         } else if ($._timelock.isOperationDone(queueid)) {
  73 |     |             // This can happen if the proposal is executed directly on the timelock.
  74 |     |             return ProposalState.Executed;
  75 |     |         } else {
  76 |     |             // This can happen if the proposal is canceled directly on the timelock.
  77 |     |             return ProposalState.Canceled;
  78 |     |         }
  79 |     |     }
  80 |     | 
  81 |     |     /**
  82 |     |      * @dev Public accessor to check the address of the timelock
  83 |     |      */
  84 |     |     function timelock() public view virtual returns (address) {
  85 |     |         GovernorTimelockControlStorage storage $ = _getGovernorTimelockControlStorage();
  86 |     |         return address($._timelock);
  87 |     |     }
  88 |     | 
  89 |     |     /// @inheritdoc IGovernor
  90 |     |     function proposalNeedsQueuing(uint256) public view virtual override returns (bool) {
  91 |     |         return true;
  92 |     |     }
  93 |     | 
  94 |     |     /**
  95 |     |      * @dev Function to queue a proposal to the timelock.
  96 |     |      */
  97 |     |     function _queueOperations(
  98 |     |         uint256 proposalId,
  99 |     |         address[] memory targets,
 100 |     |         uint256[] memory values,
 101 |     |         bytes[] memory calldatas,
 102 |     |         bytes32 descriptionHash
 103 |     |     ) internal virtual override returns (uint48) {
 104 |     |         GovernorTimelockControlStorage storage $ = _getGovernorTimelockControlStorage();
 105 |     |         uint256 delay = $._timelock.getMinDelay();
 106 |     | 
 107 |     |         bytes32 salt = _timelockSalt(descriptionHash);
 108 |     |         $._timelockIds[proposalId] = $._timelock.hashOperationBatch(targets, values, calldatas, 0, salt);
 109 |     |         $._timelock.scheduleBatch(targets, values, calldatas, 0, salt, delay);
 110 |     | 
 111 |     |         return SafeCast.toUint48(block.timestamp + delay);
 112 |     |     }
 113 |     | 
 114 |     |     /**
 115 |     |      * @dev Overridden version of the {Governor-_executeOperations} function that runs the already queued proposal
 116 |     |      * through the timelock.
 117 |     |      */
 118 |     |     function _executeOperations(
 119 |     |         uint256 proposalId,
 120 |     |         address[] memory targets,
 121 |     |         uint256[] memory values,
 122 |     |         bytes[] memory calldatas,
 123 |     |         bytes32 descriptionHash
 124 |     |     ) internal virtual override {
 125 |     |         GovernorTimelockControlStorage storage $ = _getGovernorTimelockControlStorage();
 126 |     |         // execute
 127 |     |         $._timelock.executeBatch{value: msg.value}(targets, values, calldatas, 0, _timelockSalt(descriptionHash));
 128 |     |         // cleanup for refund
 129 |     |         delete $._timelockIds[proposalId];
 130 |     |     }
 131 |     | 
 132 |     |     /**
 133 |     |      * @dev Overridden version of the {Governor-_cancel} function to cancel the timelocked proposal if it has already
 134 |     |      * been queued.
 135 |     |      */
 136 |     |     // This function can reenter through the external call to the timelock, but we assume the timelock is trusted and
 137 |     |     // well behaved (according to TimelockController) and this will not happen.
 138 |     |     // slither-disable-next-line reentrancy-no-eth
 139 |     |     function _cancel(
 140 |     |         address[] memory targets,
 141 |     |         uint256[] memory values,
 142 |     |         bytes[] memory calldatas,
 143 |     |         bytes32 descriptionHash
 144 |     |     ) internal virtual override returns (uint256) {
 145 |     |         GovernorTimelockControlStorage storage $ = _getGovernorTimelockControlStorage();
 146 |     |         uint256 proposalId = super._cancel(targets, values, calldatas, descriptionHash);
 147 |     | 
 148 |     |         bytes32 timelockId = $._timelockIds[proposalId];
 149 |     |         if (timelockId != 0) {
 150 |     |             // cancel
 151 |     |             $._timelock.cancel(timelockId);
 152 |     |             // cleanup
 153 |     |             delete $._timelockIds[proposalId];
 154 |     |         }
 155 |     | 
 156 |     |         return proposalId;
 157 |     |     }
 158 |     | 
 159 |     |     /**
 160 |     |      * @dev Address through which the governor executes action. In this case, the timelock.
 161 |     |      */
 162 |     |     function _executor() internal view virtual override returns (address) {
 163 |     |         GovernorTimelockControlStorage storage $ = _getGovernorTimelockControlStorage();
 164 |     |         return address($._timelock);
 165 |     |     }
 166 |     | 
 167 |     |     /**
 168 |     |      * @dev Public endpoint to update the underlying timelock instance. Restricted to the timelock itself, so updates
 169 |     |      * must be proposed, scheduled, and executed through governance proposals.
 170 |     |      *
 171 |     |      * CAUTION: It is not recommended to change the timelock while there are other queued governance proposals.
 172 |     |      */
 173 |     |     function updateTimelock(TimelockControllerUpgradeable newTimelock) external virtual onlyGovernance {
 174 |     |         _updateTimelock(newTimelock);
 175 |     |     }
 176 |     | 
 177 |     |     function _updateTimelock(TimelockControllerUpgradeable newTimelock) private {
 178 |     |         GovernorTimelockControlStorage storage $ = _getGovernorTimelockControlStorage();
 179 |     |         emit TimelockChange(address($._timelock), address(newTimelock));
 180 |     |         $._timelock = newTimelock;
 181 |     |     }
 182 |     | 
 183 |     |     /**
 184 |     |      * @dev Computes the {TimelockController} operation salt.
 185 |     |      *
 186 |     |      * It is computed with the governor address itself to avoid collisions across governor instances using the
 187 |     |      * same timelock.
 188 |     |      */
 189 |     |     function _timelockSalt(bytes32 descriptionHash) private view returns (bytes32) {
 190 |     |         return bytes20(address(this)) ^ descriptionHash;
 191 |     |     }
 192 |     | }
 193 |     | 

/home/phantom/Documents/azemora/azemora-contracts/lib/openzeppelin-contracts-upgradeable/contracts/governance/extensions/GovernorVotesQuorumFractionUpgradeable.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | // OpenZeppelin Contracts (last updated v5.3.0) (governance/extensions/GovernorVotesQuorumFraction.sol)
   3 |     | 
   4 |     | pragma solidity ^0.8.24;
   5 |     | 
   6 |     | import {GovernorVotesUpgradeable} from "./GovernorVotesUpgradeable.sol";
   7 |     | import {Math} from "@openzeppelin/contracts/utils/math/Math.sol";
   8 |     | import {SafeCast} from "@openzeppelin/contracts/utils/math/SafeCast.sol";
   9 |     | import {Checkpoints} from "@openzeppelin/contracts/utils/structs/Checkpoints.sol";
  10 |     | import {Initializable} from "../../proxy/utils/Initializable.sol";
  11 |     | 
  12 |     | /**
  13 |     |  * @dev Extension of {Governor} for voting weight extraction from an {ERC20Votes} token and a quorum expressed as a
  14 |     |  * fraction of the total supply.
  15 |     |  */
  16 |     | abstract contract GovernorVotesQuorumFractionUpgradeable is Initializable, GovernorVotesUpgradeable {
  17 |     |     using Checkpoints for Checkpoints.Trace208;
  18 |     | 
  19 |     |     /// @custom:storage-location erc7201:openzeppelin.storage.GovernorVotesQuorumFraction
  20 |     |     struct GovernorVotesQuorumFractionStorage {
  21 |     |         Checkpoints.Trace208 _quorumNumeratorHistory;
  22 |     |     }
  23 |     | 
  24 |     |     // keccak256(abi.encode(uint256(keccak256("openzeppelin.storage.GovernorVotesQuorumFraction")) - 1)) & ~bytes32(uint256(0xff))
  25 |     |     bytes32 private constant GovernorVotesQuorumFractionStorageLocation = 0xe770710421fd2cad75ad828c61aa98f2d77d423a440b67872d0f65554148e000;
  26 |     | 
  27 |     |     function _getGovernorVotesQuorumFractionStorage() private pure returns (GovernorVotesQuorumFractionStorage storage $) {
  28 |     |         assembly {
  29 |     |             $.slot := GovernorVotesQuorumFractionStorageLocation
  30 |     |         }
  31 |     |     }
  32 |     | 
  33 |     |     event QuorumNumeratorUpdated(uint256 oldQuorumNumerator, uint256 newQuorumNumerator);
  34 |     | 
  35 |     |     /**
  36 |     |      * @dev The quorum set is not a valid fraction.
  37 |     |      */
  38 |     |     error GovernorInvalidQuorumFraction(uint256 quorumNumerator, uint256 quorumDenominator);
  39 |     | 
  40 |     |     /**
  41 |     |      * @dev Initialize quorum as a fraction of the token's total supply.
  42 |     |      *
  43 |     |      * The fraction is specified as `numerator / denominator`. By default the denominator is 100, so quorum is
  44 |     |      * specified as a percent: a numerator of 10 corresponds to quorum being 10% of total supply. The denominator can be
  45 |     |      * customized by overriding {quorumDenominator}.
  46 |     |      */
  47 |     |     function __GovernorVotesQuorumFraction_init(uint256 quorumNumeratorValue) internal onlyInitializing {
  48 |     |         __GovernorVotesQuorumFraction_init_unchained(quorumNumeratorValue);
  49 |     |     }
  50 |     | 
  51 |     |     function __GovernorVotesQuorumFraction_init_unchained(uint256 quorumNumeratorValue) internal onlyInitializing {
  52 |     |         _updateQuorumNumerator(quorumNumeratorValue);
  53 |     |     }
  54 |     | 
  55 |     |     /**
  56 |     |      * @dev Returns the current quorum numerator. See {quorumDenominator}.
  57 |     |      */
  58 |     |     function quorumNumerator() public view virtual returns (uint256) {
  59 |     |         GovernorVotesQuorumFractionStorage storage $ = _getGovernorVotesQuorumFractionStorage();
  60 |     |         return $._quorumNumeratorHistory.latest();
  61 |     |     }
  62 |     | 
  63 |     |     /**
  64 |     |      * @dev Returns the quorum numerator at a specific timepoint. See {quorumDenominator}.
  65 |     |      */
  66 |     |     function quorumNumerator(uint256 timepoint) public view virtual returns (uint256) {
  67 |     |         GovernorVotesQuorumFractionStorage storage $ = _getGovernorVotesQuorumFractionStorage();
  68 |     |         return _optimisticUpperLookupRecent($._quorumNumeratorHistory, timepoint);
  69 |     |     }
  70 |     | 
  71 |     |     /**
  72 |     |      * @dev Returns the quorum denominator. Defaults to 100, but may be overridden.
  73 |     |      */
  74 |     |     function quorumDenominator() public view virtual returns (uint256) {
  75 |     |         return 100;
  76 |     |     }
  77 |     | 
  78 |     |     /**
  79 |     |      * @dev Returns the quorum for a timepoint, in terms of number of votes: `supply * numerator / denominator`.
  80 |     |      */
  81 |     |     function quorum(uint256 timepoint) public view virtual override returns (uint256) {
  82 |     |         return Math.mulDiv(token().getPastTotalSupply(timepoint), quorumNumerator(timepoint), quorumDenominator());
  83 |     |     }
  84 |     | 
  85 |     |     /**
  86 |     |      * @dev Changes the quorum numerator.
  87 |     |      *
  88 |     |      * Emits a {QuorumNumeratorUpdated} event.
  89 |     |      *
  90 |     |      * Requirements:
  91 |     |      *
  92 |     |      * - Must be called through a governance proposal.
  93 |     |      * - New numerator must be smaller or equal to the denominator.
  94 |     |      */
  95 |     |     function updateQuorumNumerator(uint256 newQuorumNumerator) external virtual onlyGovernance {
  96 |     |         _updateQuorumNumerator(newQuorumNumerator);
  97 |     |     }
  98 |     | 
  99 |     |     /**
 100 |     |      * @dev Changes the quorum numerator.
 101 |     |      *
 102 |     |      * Emits a {QuorumNumeratorUpdated} event.
 103 |     |      *
 104 |     |      * Requirements:
 105 |     |      *
 106 |     |      * - New numerator must be smaller or equal to the denominator.
 107 |     |      */
 108 |     |     function _updateQuorumNumerator(uint256 newQuorumNumerator) internal virtual {
 109 |     |         GovernorVotesQuorumFractionStorage storage $ = _getGovernorVotesQuorumFractionStorage();
 110 |     |         uint256 denominator = quorumDenominator();
 111 |     |         if (newQuorumNumerator > denominator) {
 112 |     |             revert GovernorInvalidQuorumFraction(newQuorumNumerator, denominator);
 113 |     |         }
 114 |     | 
 115 |     |         uint256 oldQuorumNumerator = quorumNumerator();
 116 |     |         $._quorumNumeratorHistory.push(clock(), SafeCast.toUint208(newQuorumNumerator));
 117 |     | 
 118 |     |         emit QuorumNumeratorUpdated(oldQuorumNumerator, newQuorumNumerator);
 119 |     |     }
 120 |     | 
 121 |     |     /**
 122 |     |      * @dev Returns the numerator at a specific timepoint.
 123 |     |      */
 124 |     |     function _optimisticUpperLookupRecent(
 125 |     |         Checkpoints.Trace208 storage ckpts,
 126 |     |         uint256 timepoint
 127 |     |     ) internal view returns (uint256) {
 128 |     |         // If trace is empty, key and value are both equal to 0.
 129 |     |         // In that case `key <= timepoint` is true, and it is ok to return 0.
 130 |     |         (, uint48 key, uint208 value) = ckpts.latestCheckpoint();
 131 |     |         return key <= timepoint ? value : ckpts.upperLookupRecent(SafeCast.toUint48(timepoint));
 132 |     |     }
 133 |     | }
 134 |     | 

/home/phantom/Documents/azemora/azemora-contracts/lib/openzeppelin-contracts-upgradeable/contracts/governance/extensions/GovernorVotesUpgradeable.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | // OpenZeppelin Contracts (last updated v5.1.0) (governance/extensions/GovernorVotes.sol)
  3 |     | 
  4 |     | pragma solidity ^0.8.24;
  5 |     | 
  6 |     | import {GovernorUpgradeable} from "../GovernorUpgradeable.sol";
  7 |     | import {IVotes} from "@openzeppelin/contracts/governance/utils/IVotes.sol";
  8 |     | import {IERC5805} from "@openzeppelin/contracts/interfaces/IERC5805.sol";
  9 |     | import {Time} from "@openzeppelin/contracts/utils/types/Time.sol";
 10 |     | import {Initializable} from "../../proxy/utils/Initializable.sol";
 11 |     | 
 12 |     | /**
 13 |     |  * @dev Extension of {Governor} for voting weight extraction from an {ERC20Votes} token, or since v4.5 an {ERC721Votes}
 14 |     |  * token.
 15 |     |  */
 16 |     | abstract contract GovernorVotesUpgradeable is Initializable, GovernorUpgradeable {
 17 | *   |     /// @custom:storage-location erc7201:openzeppelin.storage.GovernorVotes
 18 |     |     struct GovernorVotesStorage {
 19 |     |         IERC5805 _token;
 20 |     |     }
 21 |     | 
 22 |     |     // keccak256(abi.encode(uint256(keccak256("openzeppelin.storage.GovernorVotes")) - 1)) & ~bytes32(uint256(0xff))
 23 |     |     bytes32 private constant GovernorVotesStorageLocation = 0x3ba4977254e415696610a40ebf2258dbfa0ec6a2ff64e84bfe715ff16977cc00;
 24 |     | 
 25 |     |     function _getGovernorVotesStorage() private pure returns (GovernorVotesStorage storage $) {
 26 |     |         assembly {
 27 |     |             $.slot := GovernorVotesStorageLocation
 28 |     |         }
 29 |     |     }
 30 |     | 
 31 |     |     function __GovernorVotes_init(IVotes tokenAddress) internal onlyInitializing {
 32 |     |         __GovernorVotes_init_unchained(tokenAddress);
 33 |     |     }
 34 |     | 
 35 |     |     function __GovernorVotes_init_unchained(IVotes tokenAddress) internal onlyInitializing {
 36 |     |         GovernorVotesStorage storage $ = _getGovernorVotesStorage();
 37 |     |         $._token = IERC5805(address(tokenAddress));
 38 |     |     }
 39 |     | 
 40 |     |     /**
 41 |     |      * @dev The token that voting power is sourced from.
 42 |     |      */
 43 |     |     function token() public view virtual returns (IERC5805) {
 44 |     |         GovernorVotesStorage storage $ = _getGovernorVotesStorage();
 45 |     |         return $._token;
 46 |     |     }
 47 |     | 
 48 |     |     /**
 49 |     |      * @dev Clock (as specified in ERC-6372) is set to match the token's clock. Fallback to block numbers if the token
 50 |     |      * does not implement ERC-6372.
 51 |     |      */
 52 |     |     function clock() public view virtual override returns (uint48) {
 53 |     |         try token().clock() returns (uint48 timepoint) {
 54 |     |             return timepoint;
 55 |     |         } catch {
 56 |     |             return Time.blockNumber();
 57 |     |         }
 58 |     |     }
 59 |     | 
 60 |     |     /**
 61 |     |      * @dev Machine-readable description of the clock as specified in ERC-6372.
 62 |     |      */
 63 |     |     // solhint-disable-next-line func-name-mixedcase
 64 |     |     function CLOCK_MODE() public view virtual override returns (string memory) {
 65 |     |         try token().CLOCK_MODE() returns (string memory clockmode) {
 66 |     |             return clockmode;
 67 |     |         } catch {
 68 |     |             return "mode=blocknumber&from=default";
 69 |     |         }
 70 |     |     }
 71 |     | 
 72 |     |     /**
 73 |     |      * Read the voting weight from the token's built in snapshot mechanism (see {Governor-_getVotes}).
 74 |     |      */
 75 |     |     function _getVotes(
 76 |     |         address account,
 77 |     |         uint256 timepoint,
 78 |     |         bytes memory /*params*/
 79 |     |     ) internal view virtual override returns (uint256) {
 80 |     |         return token().getPastVotes(account, timepoint);
 81 |     |     }
 82 |     | }
 83 |     | 

/home/phantom/Documents/azemora/azemora-contracts/lib/openzeppelin-contracts-upgradeable/contracts/governance/utils/VotesUpgradeable.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | // OpenZeppelin Contracts (last updated v5.2.0) (governance/utils/Votes.sol)
   3 |     | pragma solidity ^0.8.20;
   4 |     | 
   5 |     | import {IERC5805} from "@openzeppelin/contracts/interfaces/IERC5805.sol";
   6 |     | import {ContextUpgradeable} from "../../utils/ContextUpgradeable.sol";
   7 |     | import {NoncesUpgradeable} from "../../utils/NoncesUpgradeable.sol";
   8 |     | import {EIP712Upgradeable} from "../../utils/cryptography/EIP712Upgradeable.sol";
   9 |     | import {Checkpoints} from "@openzeppelin/contracts/utils/structs/Checkpoints.sol";
  10 |     | import {SafeCast} from "@openzeppelin/contracts/utils/math/SafeCast.sol";
  11 |     | import {ECDSA} from "@openzeppelin/contracts/utils/cryptography/ECDSA.sol";
  12 |     | import {Time} from "@openzeppelin/contracts/utils/types/Time.sol";
  13 |     | import {Initializable} from "../../proxy/utils/Initializable.sol";
  14 |     | 
  15 |     | /**
  16 |     |  * @dev This is a base abstract contract that tracks voting units, which are a measure of voting power that can be
  17 |     |  * transferred, and provides a system of vote delegation, where an account can delegate its voting units to a sort of
  18 |     |  * "representative" that will pool delegated voting units from different accounts and can then use it to vote in
  19 |     |  * decisions. In fact, voting units _must_ be delegated in order to count as actual votes, and an account has to
  20 |     |  * delegate those votes to itself if it wishes to participate in decisions and does not have a trusted representative.
  21 |     |  *
  22 |     |  * This contract is often combined with a token contract such that voting units correspond to token units. For an
  23 |     |  * example, see {ERC721Votes}.
  24 |     |  *
  25 |     |  * The full history of delegate votes is tracked on-chain so that governance protocols can consider votes as distributed
  26 |     |  * at a particular block number to protect against flash loans and double voting. The opt-in delegate system makes the
  27 |     |  * cost of this history tracking optional.
  28 |     |  *
  29 |     |  * When using this module the derived contract must implement {_getVotingUnits} (for example, make it return
  30 |     |  * {ERC721-balanceOf}), and can use {_transferVotingUnits} to track a change in the distribution of those units (in the
  31 |     |  * previous example, it would be included in {ERC721-_update}).
  32 |     |  */
  33 |     | abstract contract VotesUpgradeable is Initializable, ContextUpgradeable, EIP712Upgradeable, NoncesUpgradeable, IERC5805 {
  34 |     |     using Checkpoints for Checkpoints.Trace208;
  35 |     | 
  36 |     |     bytes32 private constant DELEGATION_TYPEHASH =
  37 |     |         keccak256("Delegation(address delegatee,uint256 nonce,uint256 expiry)");
  38 |     | 
  39 |     |     /// @custom:storage-location erc7201:openzeppelin.storage.Votes
  40 |     |     struct VotesStorage {
  41 |     |         mapping(address account => address) _delegatee;
  42 |     | 
  43 |     |         mapping(address delegatee => Checkpoints.Trace208) _delegateCheckpoints;
  44 |     | 
  45 |     |         Checkpoints.Trace208 _totalCheckpoints;
  46 |     |     }
  47 |     | 
  48 |     |     // keccak256(abi.encode(uint256(keccak256("openzeppelin.storage.Votes")) - 1)) & ~bytes32(uint256(0xff))
  49 |     |     bytes32 private constant VotesStorageLocation = 0xe8b26c30fad74198956032a3533d903385d56dd795af560196f9c78d4af40d00;
  50 |     | 
  51 |     |     function _getVotesStorage() private pure returns (VotesStorage storage $) {
  52 |     |         assembly {
  53 |     |             $.slot := VotesStorageLocation
  54 |     |         }
  55 |     |     }
  56 |     | 
  57 |     |     /**
  58 |     |      * @dev The clock was incorrectly modified.
  59 |     |      */
  60 |     |     error ERC6372InconsistentClock();
  61 |     | 
  62 |     |     /**
  63 |     |      * @dev Lookup to future votes is not available.
  64 |     |      */
  65 |     |     error ERC5805FutureLookup(uint256 timepoint, uint48 clock);
  66 |     | 
  67 |     |     function __Votes_init() internal onlyInitializing {
  68 |     |     }
  69 |     | 
  70 |     |     function __Votes_init_unchained() internal onlyInitializing {
  71 |     |     }
  72 |     |     /**
  73 |     |      * @dev Clock used for flagging checkpoints. Can be overridden to implement timestamp based
  74 |     |      * checkpoints (and voting), in which case {CLOCK_MODE} should be overridden as well to match.
  75 |     |      */
  76 |     |     function clock() public view virtual returns (uint48) {
  77 |     |         return Time.blockNumber();
  78 |     |     }
  79 |     | 
  80 |     |     /**
  81 |     |      * @dev Machine-readable description of the clock as specified in ERC-6372.
  82 |     |      */
  83 |     |     // solhint-disable-next-line func-name-mixedcase
  84 |     |     function CLOCK_MODE() public view virtual returns (string memory) {
  85 |     |         // Check that the clock was not modified
  86 |     |         if (clock() != Time.blockNumber()) {
  87 |     |             revert ERC6372InconsistentClock();
  88 |     |         }
  89 |     |         return "mode=blocknumber&from=default";
  90 |     |     }
  91 |     | 
  92 |     |     /**
  93 |     |      * @dev Validate that a timepoint is in the past, and return it as a uint48.
  94 |     |      */
  95 |     |     function _validateTimepoint(uint256 timepoint) internal view returns (uint48) {
  96 |     |         uint48 currentTimepoint = clock();
  97 |     |         if (timepoint >= currentTimepoint) revert ERC5805FutureLookup(timepoint, currentTimepoint);
  98 |     |         return SafeCast.toUint48(timepoint);
  99 |     |     }
 100 |     | 
 101 |     |     /**
 102 |     |      * @dev Returns the current amount of votes that `account` has.
 103 |     |      */
 104 |     |     function getVotes(address account) public view virtual returns (uint256) {
 105 |     |         VotesStorage storage $ = _getVotesStorage();
 106 |     |         return $._delegateCheckpoints[account].latest();
 107 |     |     }
 108 |     | 
 109 |     |     /**
 110 |     |      * @dev Returns the amount of votes that `account` had at a specific moment in the past. If the `clock()` is
 111 |     |      * configured to use block numbers, this will return the value at the end of the corresponding block.
 112 |     |      *
 113 |     |      * Requirements:
 114 |     |      *
 115 |     |      * - `timepoint` must be in the past. If operating using block numbers, the block must be already mined.
 116 |     |      */
 117 |     |     function getPastVotes(address account, uint256 timepoint) public view virtual returns (uint256) {
 118 |     |         VotesStorage storage $ = _getVotesStorage();
 119 |     |         return $._delegateCheckpoints[account].upperLookupRecent(_validateTimepoint(timepoint));
 120 |     |     }
 121 |     | 
 122 |     |     /**
 123 |     |      * @dev Returns the total supply of votes available at a specific moment in the past. If the `clock()` is
 124 |     |      * configured to use block numbers, this will return the value at the end of the corresponding block.
 125 |     |      *
 126 |     |      * NOTE: This value is the sum of all available votes, which is not necessarily the sum of all delegated votes.
 127 |     |      * Votes that have not been delegated are still part of total supply, even though they would not participate in a
 128 |     |      * vote.
 129 |     |      *
 130 |     |      * Requirements:
 131 |     |      *
 132 |     |      * - `timepoint` must be in the past. If operating using block numbers, the block must be already mined.
 133 |     |      */
 134 |     |     function getPastTotalSupply(uint256 timepoint) public view virtual returns (uint256) {
 135 |     |         VotesStorage storage $ = _getVotesStorage();
 136 |     |         return $._totalCheckpoints.upperLookupRecent(_validateTimepoint(timepoint));
 137 |     |     }
 138 |     | 
 139 |     |     /**
 140 |     |      * @dev Returns the current total supply of votes.
 141 |     |      */
 142 |     |     function _getTotalSupply() internal view virtual returns (uint256) {
 143 |     |         VotesStorage storage $ = _getVotesStorage();
 144 |     |         return $._totalCheckpoints.latest();
 145 |     |     }
 146 |     | 
 147 |     |     /**
 148 |     |      * @dev Returns the delegate that `account` has chosen.
 149 |     |      */
 150 |     |     function delegates(address account) public view virtual returns (address) {
 151 |     |         VotesStorage storage $ = _getVotesStorage();
 152 |     |         return $._delegatee[account];
 153 |     |     }
 154 |     | 
 155 |     |     /**
 156 |     |      * @dev Delegates votes from the sender to `delegatee`.
 157 |     |      */
 158 |     |     function delegate(address delegatee) public virtual {
 159 |     |         address account = _msgSender();
 160 |     |         _delegate(account, delegatee);
 161 |     |     }
 162 |     | 
 163 |     |     /**
 164 |     |      * @dev Delegates votes from signer to `delegatee`.
 165 |     |      */
 166 |     |     function delegateBySig(
 167 |     |         address delegatee,
 168 |     |         uint256 nonce,
 169 |     |         uint256 expiry,
 170 |     |         uint8 v,
 171 |     |         bytes32 r,
 172 |     |         bytes32 s
 173 |     |     ) public virtual {
 174 |     |         if (block.timestamp > expiry) {
 175 |     |             revert VotesExpiredSignature(expiry);
 176 |     |         }
 177 |     |         address signer = ECDSA.recover(
 178 |     |             _hashTypedDataV4(keccak256(abi.encode(DELEGATION_TYPEHASH, delegatee, nonce, expiry))),
 179 |     |             v,
 180 |     |             r,
 181 |     |             s
 182 |     |         );
 183 |     |         _useCheckedNonce(signer, nonce);
 184 |     |         _delegate(signer, delegatee);
 185 |     |     }
 186 |     | 
 187 |     |     /**
 188 |     |      * @dev Delegate all of `account`'s voting units to `delegatee`.
 189 |     |      *
 190 |     |      * Emits events {IVotes-DelegateChanged} and {IVotes-DelegateVotesChanged}.
 191 |     |      */
 192 |     |     function _delegate(address account, address delegatee) internal virtual {
 193 |     |         VotesStorage storage $ = _getVotesStorage();
 194 |     |         address oldDelegate = delegates(account);
 195 |     |         $._delegatee[account] = delegatee;
 196 |     | 
 197 |     |         emit DelegateChanged(account, oldDelegate, delegatee);
 198 |     |         _moveDelegateVotes(oldDelegate, delegatee, _getVotingUnits(account));
 199 |     |     }
 200 |     | 
 201 |     |     /**
 202 |     |      * @dev Transfers, mints, or burns voting units. To register a mint, `from` should be zero. To register a burn, `to`
 203 |     |      * should be zero. Total supply of voting units will be adjusted with mints and burns.
 204 |     |      */
 205 |     |     function _transferVotingUnits(address from, address to, uint256 amount) internal virtual {
 206 |     |         VotesStorage storage $ = _getVotesStorage();
 207 |     |         if (from == address(0)) {
 208 |     |             _push($._totalCheckpoints, _add, SafeCast.toUint208(amount));
 209 |     |         }
 210 |     |         if (to == address(0)) {
 211 |     |             _push($._totalCheckpoints, _subtract, SafeCast.toUint208(amount));
 212 |     |         }
 213 |     |         _moveDelegateVotes(delegates(from), delegates(to), amount);
 214 |     |     }
 215 |     | 
 216 |     |     /**
 217 |     |      * @dev Moves delegated votes from one delegate to another.
 218 |     |      */
 219 |     |     function _moveDelegateVotes(address from, address to, uint256 amount) internal virtual {
 220 |     |         VotesStorage storage $ = _getVotesStorage();
 221 |     |         if (from != to && amount > 0) {
 222 |     |             if (from != address(0)) {
 223 |     |                 (uint256 oldValue, uint256 newValue) = _push(
 224 |     |                     $._delegateCheckpoints[from],
 225 |     |                     _subtract,
 226 |     |                     SafeCast.toUint208(amount)
 227 |     |                 );
 228 |     |                 emit DelegateVotesChanged(from, oldValue, newValue);
 229 |     |             }
 230 |     |             if (to != address(0)) {
 231 |     |                 (uint256 oldValue, uint256 newValue) = _push(
 232 |     |                     $._delegateCheckpoints[to],
 233 |     |                     _add,
 234 |     |                     SafeCast.toUint208(amount)
 235 |     |                 );
 236 |     |                 emit DelegateVotesChanged(to, oldValue, newValue);
 237 |     |             }
 238 |     |         }
 239 |     |     }
 240 |     | 
 241 |     |     /**
 242 |     |      * @dev Get number of checkpoints for `account`.
 243 |     |      */
 244 |     |     function _numCheckpoints(address account) internal view virtual returns (uint32) {
 245 |     |         VotesStorage storage $ = _getVotesStorage();
 246 |     |         return SafeCast.toUint32($._delegateCheckpoints[account].length());
 247 |     |     }
 248 |     | 
 249 |     |     /**
 250 |     |      * @dev Get the `pos`-th checkpoint for `account`.
 251 |     |      */
 252 |     |     function _checkpoints(
 253 |     |         address account,
 254 |     |         uint32 pos
 255 |     |     ) internal view virtual returns (Checkpoints.Checkpoint208 memory) {
 256 |     |         VotesStorage storage $ = _getVotesStorage();
 257 |     |         return $._delegateCheckpoints[account].at(pos);
 258 |     |     }
 259 |     | 
 260 |     |     function _push(
 261 |     |         Checkpoints.Trace208 storage store,
 262 |     |         function(uint208, uint208) view returns (uint208) op,
 263 |     |         uint208 delta
 264 |     |     ) private returns (uint208 oldValue, uint208 newValue) {
 265 |     |         return store.push(clock(), op(store.latest(), delta));
 266 |     |     }
 267 |     | 
 268 |     |     function _add(uint208 a, uint208 b) private pure returns (uint208) {
 269 |     |         return a + b;
 270 |     |     }
 271 |     | 
 272 |     |     function _subtract(uint208 a, uint208 b) private pure returns (uint208) {
 273 |     |         return a - b;
 274 |     |     }
 275 |     | 
 276 |     |     /**
 277 |     |      * @dev Must return the voting units held by an account.
 278 |     |      */
 279 |     |     function _getVotingUnits(address) internal view virtual returns (uint256);
 280 |     | }
 281 |     | 

/home/phantom/Documents/azemora/azemora-contracts/lib/openzeppelin-contracts-upgradeable/contracts/proxy/utils/Initializable.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | // OpenZeppelin Contracts (last updated v5.3.0) (proxy/utils/Initializable.sol)
   3 |     | 
   4 |     | pragma solidity ^0.8.20;
   5 |     | 
   6 |     | /**
   7 |     |  * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed
   8 |     |  * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an
   9 |     |  * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer
  10 |     |  * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.
  11 |     |  *
  12 |     |  * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be
  13 |     |  * reused. This mechanism prevents re-execution of each "step" but allows the creation of new initialization steps in
  14 |     |  * case an upgrade adds a module that needs to be initialized.
  15 |     |  *
  16 |     |  * For example:
  17 |     |  *
  18 |     |  * [.hljs-theme-light.nopadding]
  19 |     |  * ```solidity
  20 |     |  * contract MyToken is ERC20Upgradeable {
  21 |     |  *     function initialize() initializer public {
  22 |     |  *         __ERC20_init("MyToken", "MTK");
  23 |     |  *     }
  24 |     |  * }
  25 |     |  *
  26 |     |  * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {
  27 |     |  *     function initializeV2() reinitializer(2) public {
  28 |     |  *         __ERC20Permit_init("MyToken");
  29 |     |  *     }
  30 |     |  * }
  31 |     |  * ```
  32 |     |  *
  33 |     |  * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as
  34 |     |  * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.
  35 |     |  *
  36 |     |  * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure
  37 |     |  * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.
  38 |     |  *
  39 |     |  * [CAUTION]
  40 |     |  * ====
  41 |     |  * Avoid leaving a contract uninitialized.
  42 |     |  *
  43 |     |  * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation
  44 |     |  * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke
  45 |     |  * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:
  46 |     |  *
  47 |     |  * [.hljs-theme-light.nopadding]
  48 |     |  * ```
  49 |     |  * /// @custom:oz-upgrades-unsafe-allow constructor
  50 |     |  * constructor() {
  51 |     |  *     _disableInitializers();
  52 |     |  * }
  53 |     |  * ```
  54 |     |  * ====
  55 |     |  */
  56 |     | abstract contract Initializable {
  57 |     |     /**
  58 |     |      * @dev Storage of the initializable contract.
  59 |     |      *
  60 |     |      * It's implemented on a custom ERC-7201 namespace to reduce the risk of storage collisions
  61 |     |      * when using with upgradeable contracts.
  62 |     |      *
  63 |     |      * @custom:storage-location erc7201:openzeppelin.storage.Initializable
  64 |     |      */
  65 |     |     struct InitializableStorage {
  66 |     |         /**
  67 |     |          * @dev Indicates that the contract has been initialized.
  68 |     |          */
  69 |     |         uint64 _initialized;
  70 |     |         /**
  71 |     |          * @dev Indicates that the contract is in the process of being initialized.
  72 |     |          */
  73 |     |         bool _initializing;
  74 |     |     }
  75 |     | 
  76 |     |     // keccak256(abi.encode(uint256(keccak256("openzeppelin.storage.Initializable")) - 1)) & ~bytes32(uint256(0xff))
  77 |     |     bytes32 private constant INITIALIZABLE_STORAGE = 0xf0c57e16840df040f15088dc2f81fe391c3923bec73e23a9662efc9c229c6a00;
  78 |     | 
  79 |     |     /**
  80 |     |      * @dev The contract is already initialized.
  81 |     |      */
  82 |     |     error InvalidInitialization();
  83 |     | 
  84 |     |     /**
  85 |     |      * @dev The contract is not initializing.
  86 |     |      */
  87 |     |     error NotInitializing();
  88 |     | 
  89 |     |     /**
  90 |     |      * @dev Triggered when the contract has been initialized or reinitialized.
  91 |     |      */
  92 |     |     event Initialized(uint64 version);
  93 |     | 
  94 |     |     /**
  95 |     |      * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,
  96 |     |      * `onlyInitializing` functions can be used to initialize parent contracts.
  97 |     |      *
  98 |     |      * Similar to `reinitializer(1)`, except that in the context of a constructor an `initializer` may be invoked any
  99 |     |      * number of times. This behavior in the constructor can be useful during testing and is not expected to be used in
 100 |     |      * production.
 101 |     |      *
 102 |     |      * Emits an {Initialized} event.
 103 |     |      */
 104 |     |     modifier initializer() {
 105 |     |         // solhint-disable-next-line var-name-mixedcase
 106 |     |         InitializableStorage storage $ = _getInitializableStorage();
 107 |     | 
 108 |     |         // Cache values to avoid duplicated sloads
 109 |     |         bool isTopLevelCall = !$._initializing;
 110 |     |         uint64 initialized = $._initialized;
 111 |     | 
 112 |     |         // Allowed calls:
 113 |     |         // - initialSetup: the contract is not in the initializing state and no previous version was
 114 |     |         //                 initialized
 115 |     |         // - construction: the contract is initialized at version 1 (no reinitialization) and the
 116 |     |         //                 current contract is just being deployed
 117 |     |         bool initialSetup = initialized == 0 && isTopLevelCall;
 118 |     |         bool construction = initialized == 1 && address(this).code.length == 0;
 119 |     | 
 120 |     |         if (!initialSetup && !construction) {
 121 |     |             revert InvalidInitialization();
 122 |     |         }
 123 |     |         $._initialized = 1;
 124 |     |         if (isTopLevelCall) {
 125 |     |             $._initializing = true;
 126 |     |         }
 127 |     |         _;
 128 |     |         if (isTopLevelCall) {
 129 |     |             $._initializing = false;
 130 |     |             emit Initialized(1);
 131 |     |         }
 132 |     |     }
 133 |     | 
 134 |     |     /**
 135 |     |      * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the
 136 |     |      * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be
 137 |     |      * used to initialize parent contracts.
 138 |     |      *
 139 |     |      * A reinitializer may be used after the original initialization step. This is essential to configure modules that
 140 |     |      * are added through upgrades and that require initialization.
 141 |     |      *
 142 |     |      * When `version` is 1, this modifier is similar to `initializer`, except that functions marked with `reinitializer`
 143 |     |      * cannot be nested. If one is invoked in the context of another, execution will revert.
 144 |     |      *
 145 |     |      * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in
 146 |     |      * a contract, executing them in the right order is up to the developer or operator.
 147 |     |      *
 148 |     |      * WARNING: Setting the version to 2**64 - 1 will prevent any future reinitialization.
 149 |     |      *
 150 |     |      * Emits an {Initialized} event.
 151 |     |      */
 152 |     |     modifier reinitializer(uint64 version) {
 153 |     |         // solhint-disable-next-line var-name-mixedcase
 154 |     |         InitializableStorage storage $ = _getInitializableStorage();
 155 |     | 
 156 |     |         if ($._initializing || $._initialized >= version) {
 157 |     |             revert InvalidInitialization();
 158 |     |         }
 159 |     |         $._initialized = version;
 160 |     |         $._initializing = true;
 161 |     |         _;
 162 |     |         $._initializing = false;
 163 |     |         emit Initialized(version);
 164 |     |     }
 165 |     | 
 166 |     |     /**
 167 |     |      * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the
 168 |     |      * {initializer} and {reinitializer} modifiers, directly or indirectly.
 169 |     |      */
 170 |     |     modifier onlyInitializing() {
 171 |     |         _checkInitializing();
 172 |     |         _;
 173 |     |     }
 174 |     | 
 175 |     |     /**
 176 |     |      * @dev Reverts if the contract is not in an initializing state. See {onlyInitializing}.
 177 |     |      */
 178 |     |     function _checkInitializing() internal view virtual {
 179 |     |         if (!_isInitializing()) {
 180 |     |             revert NotInitializing();
 181 |     |         }
 182 |     |     }
 183 |     | 
 184 |     |     /**
 185 |     |      * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.
 186 |     |      * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized
 187 |     |      * to any version. It is recommended to use this to lock implementation contracts that are designed to be called
 188 |     |      * through proxies.
 189 |     |      *
 190 |     |      * Emits an {Initialized} event the first time it is successfully executed.
 191 |     |      */
 192 |     |     function _disableInitializers() internal virtual {
 193 |     |         // solhint-disable-next-line var-name-mixedcase
 194 |     |         InitializableStorage storage $ = _getInitializableStorage();
 195 |     | 
 196 |     |         if ($._initializing) {
 197 |     |             revert InvalidInitialization();
 198 |     |         }
 199 |     |         if ($._initialized != type(uint64).max) {
 200 |     |             $._initialized = type(uint64).max;
 201 |     |             emit Initialized(type(uint64).max);
 202 |     |         }
 203 |     |     }
 204 |     | 
 205 |     |     /**
 206 |     |      * @dev Returns the highest version that has been initialized. See {reinitializer}.
 207 |     |      */
 208 |     |     function _getInitializedVersion() internal view returns (uint64) {
 209 |     |         return _getInitializableStorage()._initialized;
 210 |     |     }
 211 |     | 
 212 |     |     /**
 213 |     |      * @dev Returns `true` if the contract is currently initializing. See {onlyInitializing}.
 214 |     |      */
 215 |     |     function _isInitializing() internal view returns (bool) {
 216 |     |         return _getInitializableStorage()._initializing;
 217 |     |     }
 218 |     | 
 219 |     |     /**
 220 |     |      * @dev Pointer to storage slot. Allows integrators to override it with a custom storage location.
 221 |     |      *
 222 |     |      * NOTE: Consider following the ERC-7201 formula to derive storage locations.
 223 |     |      */
 224 |     |     function _initializableStorageSlot() internal pure virtual returns (bytes32) {
 225 |     |         return INITIALIZABLE_STORAGE;
 226 |     |     }
 227 |     | 
 228 |     |     /**
 229 |     |      * @dev Returns a pointer to the storage namespace.
 230 |     |      */
 231 |     |     // solhint-disable-next-line var-name-mixedcase
 232 |     |     function _getInitializableStorage() private pure returns (InitializableStorage storage $) {
 233 |     |         bytes32 slot = _initializableStorageSlot();
 234 |     |         assembly {
 235 |     |             $.slot := slot
 236 |     |         }
 237 |     |     }
 238 |     | }
 239 |     | 

/home/phantom/Documents/azemora/azemora-contracts/lib/openzeppelin-contracts-upgradeable/contracts/proxy/utils/UUPSUpgradeable.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | // OpenZeppelin Contracts (last updated v5.3.0) (proxy/utils/UUPSUpgradeable.sol)
   3 |     | 
   4 |     | pragma solidity ^0.8.22;
   5 |     | 
   6 |     | import {IERC1822Proxiable} from "@openzeppelin/contracts/interfaces/draft-IERC1822.sol";
   7 |     | import {ERC1967Utils} from "@openzeppelin/contracts/proxy/ERC1967/ERC1967Utils.sol";
   8 |     | import {Initializable} from "./Initializable.sol";
   9 |     | 
  10 |     | /**
  11 |     |  * @dev An upgradeability mechanism designed for UUPS proxies. The functions included here can perform an upgrade of an
  12 |     |  * {ERC1967Proxy}, when this contract is set as the implementation behind such a proxy.
  13 |     |  *
  14 |     |  * A security mechanism ensures that an upgrade does not turn off upgradeability accidentally, although this risk is
  15 |     |  * reinstated if the upgrade retains upgradeability but removes the security mechanism, e.g. by replacing
  16 |     |  * `UUPSUpgradeable` with a custom implementation of upgrades.
  17 |     |  *
  18 |     |  * The {_authorizeUpgrade} function must be overridden to include access restriction to the upgrade mechanism.
  19 |     |  */
  20 |     | abstract contract UUPSUpgradeable is Initializable, IERC1822Proxiable {
  21 |     |     /// @custom:oz-upgrades-unsafe-allow state-variable-immutable
  22 |     |     address private immutable __self = address(this);
  23 |     | 
  24 |     |     /**
  25 |     |      * @dev The version of the upgrade interface of the contract. If this getter is missing, both `upgradeTo(address)`
  26 |     |      * and `upgradeToAndCall(address,bytes)` are present, and `upgradeTo` must be used if no function should be called,
  27 |     |      * while `upgradeToAndCall` will invoke the `receive` function if the second argument is the empty byte string.
  28 |     |      * If the getter returns `"5.0.0"`, only `upgradeToAndCall(address,bytes)` is present, and the second argument must
  29 |     |      * be the empty byte string if no function should be called, making it impossible to invoke the `receive` function
  30 |     |      * during an upgrade.
  31 |     |      */
  32 |     |     string public constant UPGRADE_INTERFACE_VERSION = "5.0.0";
  33 |     | 
  34 |     |     /**
  35 |     |      * @dev The call is from an unauthorized context.
  36 |     |      */
  37 |     |     error UUPSUnauthorizedCallContext();
  38 |     | 
  39 |     |     /**
  40 |     |      * @dev The storage `slot` is unsupported as a UUID.
  41 |     |      */
  42 |     |     error UUPSUnsupportedProxiableUUID(bytes32 slot);
  43 |     | 
  44 |     |     /**
  45 |     |      * @dev Check that the execution is being performed through a delegatecall call and that the execution context is
  46 |     |      * a proxy contract with an implementation (as defined in ERC-1967) pointing to self. This should only be the case
  47 |     |      * for UUPS and transparent proxies that are using the current contract as their implementation. Execution of a
  48 |     |      * function through ERC-1167 minimal proxies (clones) would not normally pass this test, but is not guaranteed to
  49 |     |      * fail.
  50 |     |      */
  51 |     |     modifier onlyProxy() {
  52 |     |         _checkProxy();
  53 |     |         _;
  54 |     |     }
  55 |     | 
  56 |     |     /**
  57 |     |      * @dev Check that the execution is not being performed through a delegate call. This allows a function to be
  58 |     |      * callable on the implementing contract but not through proxies.
  59 |     |      */
  60 |     |     modifier notDelegated() {
  61 |     |         _checkNotDelegated();
  62 |     |         _;
  63 |     |     }
  64 |     | 
  65 |     |     function __UUPSUpgradeable_init() internal onlyInitializing {
  66 |     |     }
  67 |     | 
  68 |     |     function __UUPSUpgradeable_init_unchained() internal onlyInitializing {
  69 |     |     }
  70 |     |     /**
  71 |     |      * @dev Implementation of the ERC-1822 {proxiableUUID} function. This returns the storage slot used by the
  72 |     |      * implementation. It is used to validate the implementation's compatibility when performing an upgrade.
  73 |     |      *
  74 |     |      * IMPORTANT: A proxy pointing at a proxiable contract should not be considered proxiable itself, because this risks
  75 |     |      * bricking a proxy that upgrades to it, by delegating to itself until out of gas. Thus it is critical that this
  76 |     |      * function revert if invoked through a proxy. This is guaranteed by the `notDelegated` modifier.
  77 |     |      */
  78 |     |     function proxiableUUID() external view virtual notDelegated returns (bytes32) {
  79 |     |         return ERC1967Utils.IMPLEMENTATION_SLOT;
  80 |     |     }
  81 |     | 
  82 |     |     /**
  83 |     |      * @dev Upgrade the implementation of the proxy to `newImplementation`, and subsequently execute the function call
  84 |     |      * encoded in `data`.
  85 |     |      *
  86 |     |      * Calls {_authorizeUpgrade}.
  87 |     |      *
  88 |     |      * Emits an {Upgraded} event.
  89 |     |      *
  90 |     |      * @custom:oz-upgrades-unsafe-allow-reachable delegatecall
  91 |     |      */
  92 |     |     function upgradeToAndCall(address newImplementation, bytes memory data) public payable virtual onlyProxy {
  93 |     |         _authorizeUpgrade(newImplementation);
  94 |     |         _upgradeToAndCallUUPS(newImplementation, data);
  95 |     |     }
  96 |     | 
  97 |     |     /**
  98 |     |      * @dev Reverts if the execution is not performed via delegatecall or the execution
  99 |     |      * context is not of a proxy with an ERC-1967 compliant implementation pointing to self.
 100 |     |      */
 101 |     |     function _checkProxy() internal view virtual {
 102 |     |         if (
 103 |     |             address(this) == __self || // Must be called through delegatecall
 104 |     |             ERC1967Utils.getImplementation() != __self // Must be called through an active proxy
 105 |     |         ) {
 106 |     |             revert UUPSUnauthorizedCallContext();
 107 |     |         }
 108 |     |     }
 109 |     | 
 110 |     |     /**
 111 |     |      * @dev Reverts if the execution is performed via delegatecall.
 112 |     |      * See {notDelegated}.
 113 |     |      */
 114 |     |     function _checkNotDelegated() internal view virtual {
 115 |     |         if (address(this) != __self) {
 116 |     |             // Must not be called through delegatecall
 117 |     |             revert UUPSUnauthorizedCallContext();
 118 |     |         }
 119 |     |     }
 120 |     | 
 121 |     |     /**
 122 |     |      * @dev Function that should revert when `msg.sender` is not authorized to upgrade the contract. Called by
 123 |     |      * {upgradeToAndCall}.
 124 |     |      *
 125 |     |      * Normally, this function will use an xref:access.adoc[access control] modifier such as {Ownable-onlyOwner}.
 126 |     |      *
 127 |     |      * ```solidity
 128 |     |      * function _authorizeUpgrade(address) internal onlyOwner {}
 129 |     |      * ```
 130 |     |      */
 131 |     |     function _authorizeUpgrade(address newImplementation) internal virtual;
 132 |     | 
 133 |     |     /**
 134 |     |      * @dev Performs an implementation upgrade with a security check for UUPS proxies, and additional setup call.
 135 |     |      *
 136 |     |      * As a security check, {proxiableUUID} is invoked in the new implementation, and the return value
 137 |     |      * is expected to be the implementation slot in ERC-1967.
 138 |     |      *
 139 |     |      * Emits an {IERC1967-Upgraded} event.
 140 |     |      */
 141 |     |     function _upgradeToAndCallUUPS(address newImplementation, bytes memory data) private {
 142 |     |         try IERC1822Proxiable(newImplementation).proxiableUUID() returns (bytes32 slot) {
 143 |     |             if (slot != ERC1967Utils.IMPLEMENTATION_SLOT) {
 144 |     |                 revert UUPSUnsupportedProxiableUUID(slot);
 145 |     |             }
 146 |     |             ERC1967Utils.upgradeToAndCall(newImplementation, data);
 147 |     |         } catch {
 148 |     |             // The implementation is not UUPS
 149 |     |             revert ERC1967Utils.ERC1967InvalidImplementation(newImplementation);
 150 |     |         }
 151 |     |     }
 152 |     | }
 153 |     | 

/home/phantom/Documents/azemora/azemora-contracts/lib/openzeppelin-contracts-upgradeable/contracts/token/ERC1155/ERC1155Upgradeable.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | // OpenZeppelin Contracts (last updated v5.1.0) (token/ERC1155/ERC1155.sol)
   3 |     | 
   4 |     | pragma solidity ^0.8.20;
   5 |     | 
   6 |     | import {IERC1155} from "@openzeppelin/contracts/token/ERC1155/IERC1155.sol";
   7 |     | import {IERC1155MetadataURI} from "@openzeppelin/contracts/token/ERC1155/extensions/IERC1155MetadataURI.sol";
   8 |     | import {ERC1155Utils} from "@openzeppelin/contracts/token/ERC1155/utils/ERC1155Utils.sol";
   9 |     | import {ContextUpgradeable} from "../../utils/ContextUpgradeable.sol";
  10 |     | import {IERC165} from "@openzeppelin/contracts/utils/introspection/IERC165.sol";
  11 |     | import {ERC165Upgradeable} from "../../utils/introspection/ERC165Upgradeable.sol";
  12 |     | import {Arrays} from "@openzeppelin/contracts/utils/Arrays.sol";
  13 |     | import {IERC1155Errors} from "@openzeppelin/contracts/interfaces/draft-IERC6093.sol";
  14 |     | import {Initializable} from "../../proxy/utils/Initializable.sol";
  15 |     | 
  16 |     | /**
  17 |     |  * @dev Implementation of the basic standard multi-token.
  18 |     |  * See https://eips.ethereum.org/EIPS/eip-1155
  19 |     |  * Originally based on code by Enjin: https://github.com/enjin/erc-1155
  20 |     |  */
  21 |     | abstract contract ERC1155Upgradeable is Initializable, ContextUpgradeable, ERC165Upgradeable, IERC1155, IERC1155MetadataURI, IERC1155Errors {
  22 |     |     using Arrays for uint256[];
  23 |     |     using Arrays for address[];
  24 |     | 
  25 |     |     /// @custom:storage-location erc7201:openzeppelin.storage.ERC1155
  26 |     |     struct ERC1155Storage {
  27 |     |         mapping(uint256 id => mapping(address account => uint256)) _balances;
  28 |     | 
  29 |     |         mapping(address account => mapping(address operator => bool)) _operatorApprovals;
  30 |     | 
  31 |     |         // Used as the URI for all token types by relying on ID substitution, e.g. https://token-cdn-domain/{id}.json
  32 |     |         string _uri;
  33 |     |     }
  34 |     | 
  35 |     |     // keccak256(abi.encode(uint256(keccak256("openzeppelin.storage.ERC1155")) - 1)) & ~bytes32(uint256(0xff))
  36 |     |     bytes32 private constant ERC1155StorageLocation = 0x88be536d5240c274a3b1d3a1be54482fd9caa294f08c62a7cde569f49a3c4500;
  37 |     | 
  38 |     |     function _getERC1155Storage() private pure returns (ERC1155Storage storage $) {
  39 |     |         assembly {
  40 |     |             $.slot := ERC1155StorageLocation
  41 |     |         }
  42 |     |     }
  43 |     | 
  44 |     |     /**
  45 |     |      * @dev See {_setURI}.
  46 |     |      */
  47 |     |     function __ERC1155_init(string memory uri_) internal onlyInitializing {
  48 |     |         __ERC1155_init_unchained(uri_);
  49 |     |     }
  50 |     | 
  51 |     |     function __ERC1155_init_unchained(string memory uri_) internal onlyInitializing {
  52 |     |         _setURI(uri_);
  53 |     |     }
  54 |     | 
  55 |     |     /// @inheritdoc IERC165
  56 |     |     function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165Upgradeable, IERC165) returns (bool) {
  57 |     |         return
  58 |     |             interfaceId == type(IERC1155).interfaceId ||
  59 |     |             interfaceId == type(IERC1155MetadataURI).interfaceId ||
  60 |     |             super.supportsInterface(interfaceId);
  61 |     |     }
  62 |     | 
  63 |     |     /**
  64 |     |      * @dev See {IERC1155MetadataURI-uri}.
  65 |     |      *
  66 |     |      * This implementation returns the same URI for *all* token types. It relies
  67 |     |      * on the token type ID substitution mechanism
  68 |     |      * https://eips.ethereum.org/EIPS/eip-1155#metadata[defined in the ERC].
  69 |     |      *
  70 |     |      * Clients calling this function must replace the `\{id\}` substring with the
  71 |     |      * actual token type ID.
  72 |     |      */
  73 |     |     function uri(uint256 /* id */) public view virtual returns (string memory) {
  74 |     |         ERC1155Storage storage $ = _getERC1155Storage();
  75 |     |         return $._uri;
  76 |     |     }
  77 |     | 
  78 |     |     /// @inheritdoc IERC1155
  79 |     |     function balanceOf(address account, uint256 id) public view virtual returns (uint256) {
  80 |     |         ERC1155Storage storage $ = _getERC1155Storage();
  81 |     |         return $._balances[id][account];
  82 |     |     }
  83 |     | 
  84 |     |     /**
  85 |     |      * @dev See {IERC1155-balanceOfBatch}.
  86 |     |      *
  87 |     |      * Requirements:
  88 |     |      *
  89 |     |      * - `accounts` and `ids` must have the same length.
  90 |     |      */
  91 |     |     function balanceOfBatch(
  92 |     |         address[] memory accounts,
  93 |     |         uint256[] memory ids
  94 |     |     ) public view virtual returns (uint256[] memory) {
  95 |     |         if (accounts.length != ids.length) {
  96 |     |             revert ERC1155InvalidArrayLength(ids.length, accounts.length);
  97 |     |         }
  98 |     | 
  99 |     |         uint256[] memory batchBalances = new uint256[](accounts.length);
 100 |     | 
 101 |     |         for (uint256 i = 0; i < accounts.length; ++i) {
 102 |     |             batchBalances[i] = balanceOf(accounts.unsafeMemoryAccess(i), ids.unsafeMemoryAccess(i));
 103 |     |         }
 104 |     | 
 105 |     |         return batchBalances;
 106 |     |     }
 107 |     | 
 108 |     |     /// @inheritdoc IERC1155
 109 |     |     function setApprovalForAll(address operator, bool approved) public virtual {
 110 |     |         _setApprovalForAll(_msgSender(), operator, approved);
 111 |     |     }
 112 |     | 
 113 |     |     /// @inheritdoc IERC1155
 114 |     |     function isApprovedForAll(address account, address operator) public view virtual returns (bool) {
 115 |     |         ERC1155Storage storage $ = _getERC1155Storage();
 116 |     |         return $._operatorApprovals[account][operator];
 117 |     |     }
 118 |     | 
 119 |     |     /// @inheritdoc IERC1155
 120 |     |     function safeTransferFrom(address from, address to, uint256 id, uint256 value, bytes memory data) public virtual {
 121 |     |         address sender = _msgSender();
 122 |     |         if (from != sender && !isApprovedForAll(from, sender)) {
 123 |     |             revert ERC1155MissingApprovalForAll(sender, from);
 124 |     |         }
 125 |     |         _safeTransferFrom(from, to, id, value, data);
 126 |     |     }
 127 |     | 
 128 |     |     /// @inheritdoc IERC1155
 129 |     |     function safeBatchTransferFrom(
 130 |     |         address from,
 131 |     |         address to,
 132 |     |         uint256[] memory ids,
 133 |     |         uint256[] memory values,
 134 |     |         bytes memory data
 135 |     |     ) public virtual {
 136 |     |         address sender = _msgSender();
 137 |     |         if (from != sender && !isApprovedForAll(from, sender)) {
 138 |     |             revert ERC1155MissingApprovalForAll(sender, from);
 139 |     |         }
 140 |     |         _safeBatchTransferFrom(from, to, ids, values, data);
 141 |     |     }
 142 |     | 
 143 |     |     /**
 144 |     |      * @dev Transfers a `value` amount of tokens of type `id` from `from` to `to`. Will mint (or burn) if `from`
 145 |     |      * (or `to`) is the zero address.
 146 |     |      *
 147 |     |      * Emits a {TransferSingle} event if the arrays contain one element, and {TransferBatch} otherwise.
 148 |     |      *
 149 |     |      * Requirements:
 150 |     |      *
 151 |     |      * - If `to` refers to a smart contract, it must implement either {IERC1155Receiver-onERC1155Received}
 152 |     |      *   or {IERC1155Receiver-onERC1155BatchReceived} and return the acceptance magic value.
 153 |     |      * - `ids` and `values` must have the same length.
 154 |     |      *
 155 |     |      * NOTE: The ERC-1155 acceptance check is not performed in this function. See {_updateWithAcceptanceCheck} instead.
 156 |     |      */
 157 |     |     function _update(address from, address to, uint256[] memory ids, uint256[] memory values) internal virtual {
 158 |     |         ERC1155Storage storage $ = _getERC1155Storage();
 159 |     |         if (ids.length != values.length) {
 160 |     |             revert ERC1155InvalidArrayLength(ids.length, values.length);
 161 |     |         }
 162 |     | 
 163 |     |         address operator = _msgSender();
 164 |     | 
 165 |     |         for (uint256 i = 0; i < ids.length; ++i) {
 166 |     |             uint256 id = ids.unsafeMemoryAccess(i);
 167 |     |             uint256 value = values.unsafeMemoryAccess(i);
 168 |     | 
 169 |     |             if (from != address(0)) {
 170 |     |                 uint256 fromBalance = $._balances[id][from];
 171 |     |                 if (fromBalance < value) {
 172 |     |                     revert ERC1155InsufficientBalance(from, fromBalance, value, id);
 173 |     |                 }
 174 |     |                 unchecked {
 175 |     |                     // Overflow not possible: value <= fromBalance
 176 |     |                     $._balances[id][from] = fromBalance - value;
 177 |     |                 }
 178 |     |             }
 179 |     | 
 180 |     |             if (to != address(0)) {
 181 |     |                 $._balances[id][to] += value;
 182 |     |             }
 183 |     |         }
 184 |     | 
 185 |     |         if (ids.length == 1) {
 186 |     |             uint256 id = ids.unsafeMemoryAccess(0);
 187 |     |             uint256 value = values.unsafeMemoryAccess(0);
 188 |     |             emit TransferSingle(operator, from, to, id, value);
 189 |     |         } else {
 190 |     |             emit TransferBatch(operator, from, to, ids, values);
 191 |     |         }
 192 |     |     }
 193 |     | 
 194 |     |     /**
 195 |     |      * @dev Version of {_update} that performs the token acceptance check by calling
 196 |     |      * {IERC1155Receiver-onERC1155Received} or {IERC1155Receiver-onERC1155BatchReceived} on the receiver address if it
 197 |     |      * contains code (eg. is a smart contract at the moment of execution).
 198 |     |      *
 199 |     |      * IMPORTANT: Overriding this function is discouraged because it poses a reentrancy risk from the receiver. So any
 200 |     |      * update to the contract state after this function would break the check-effect-interaction pattern. Consider
 201 |     |      * overriding {_update} instead.
 202 |     |      */
 203 |     |     function _updateWithAcceptanceCheck(
 204 |     |         address from,
 205 |     |         address to,
 206 |     |         uint256[] memory ids,
 207 |     |         uint256[] memory values,
 208 |     |         bytes memory data
 209 |     |     ) internal virtual {
 210 |     |         _update(from, to, ids, values);
 211 |     |         if (to != address(0)) {
 212 |     |             address operator = _msgSender();
 213 |     |             if (ids.length == 1) {
 214 |     |                 uint256 id = ids.unsafeMemoryAccess(0);
 215 |     |                 uint256 value = values.unsafeMemoryAccess(0);
 216 |     |                 ERC1155Utils.checkOnERC1155Received(operator, from, to, id, value, data);
 217 |     |             } else {
 218 |     |                 ERC1155Utils.checkOnERC1155BatchReceived(operator, from, to, ids, values, data);
 219 |     |             }
 220 |     |         }
 221 |     |     }
 222 |     | 
 223 |     |     /**
 224 |     |      * @dev Transfers a `value` tokens of token type `id` from `from` to `to`.
 225 |     |      *
 226 |     |      * Emits a {TransferSingle} event.
 227 |     |      *
 228 |     |      * Requirements:
 229 |     |      *
 230 |     |      * - `to` cannot be the zero address.
 231 |     |      * - `from` must have a balance of tokens of type `id` of at least `value` amount.
 232 |     |      * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the
 233 |     |      * acceptance magic value.
 234 |     |      */
 235 |     |     function _safeTransferFrom(address from, address to, uint256 id, uint256 value, bytes memory data) internal {
 236 |     |         if (to == address(0)) {
 237 |     |             revert ERC1155InvalidReceiver(address(0));
 238 |     |         }
 239 |     |         if (from == address(0)) {
 240 |     |             revert ERC1155InvalidSender(address(0));
 241 |     |         }
 242 |     |         (uint256[] memory ids, uint256[] memory values) = _asSingletonArrays(id, value);
 243 |     |         _updateWithAcceptanceCheck(from, to, ids, values, data);
 244 |     |     }
 245 |     | 
 246 |     |     /**
 247 |     |      * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {_safeTransferFrom}.
 248 |     |      *
 249 |     |      * Emits a {TransferBatch} event.
 250 |     |      *
 251 |     |      * Requirements:
 252 |     |      *
 253 |     |      * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the
 254 |     |      * acceptance magic value.
 255 |     |      * - `ids` and `values` must have the same length.
 256 |     |      */
 257 |     |     function _safeBatchTransferFrom(
 258 |     |         address from,
 259 |     |         address to,
 260 |     |         uint256[] memory ids,
 261 |     |         uint256[] memory values,
 262 |     |         bytes memory data
 263 |     |     ) internal {
 264 |     |         if (to == address(0)) {
 265 |     |             revert ERC1155InvalidReceiver(address(0));
 266 |     |         }
 267 |     |         if (from == address(0)) {
 268 |     |             revert ERC1155InvalidSender(address(0));
 269 |     |         }
 270 |     |         _updateWithAcceptanceCheck(from, to, ids, values, data);
 271 |     |     }
 272 |     | 
 273 |     |     /**
 274 |     |      * @dev Sets a new URI for all token types, by relying on the token type ID
 275 |     |      * substitution mechanism
 276 |     |      * https://eips.ethereum.org/EIPS/eip-1155#metadata[defined in the ERC].
 277 |     |      *
 278 |     |      * By this mechanism, any occurrence of the `\{id\}` substring in either the
 279 |     |      * URI or any of the values in the JSON file at said URI will be replaced by
 280 |     |      * clients with the token type ID.
 281 |     |      *
 282 |     |      * For example, the `https://token-cdn-domain/\{id\}.json` URI would be
 283 |     |      * interpreted by clients as
 284 |     |      * `https://token-cdn-domain/000000000000000000000000000000000000000000000000000000000004cce0.json`
 285 |     |      * for token type ID 0x4cce0.
 286 |     |      *
 287 |     |      * See {uri}.
 288 |     |      *
 289 |     |      * Because these URIs cannot be meaningfully represented by the {URI} event,
 290 |     |      * this function emits no events.
 291 |     |      */
 292 |     |     function _setURI(string memory newuri) internal virtual {
 293 |     |         ERC1155Storage storage $ = _getERC1155Storage();
 294 |     |         $._uri = newuri;
 295 |     |     }
 296 |     | 
 297 |     |     /**
 298 |     |      * @dev Creates a `value` amount of tokens of type `id`, and assigns them to `to`.
 299 |     |      *
 300 |     |      * Emits a {TransferSingle} event.
 301 |     |      *
 302 |     |      * Requirements:
 303 |     |      *
 304 |     |      * - `to` cannot be the zero address.
 305 |     |      * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the
 306 |     |      * acceptance magic value.
 307 |     |      */
 308 |     |     function _mint(address to, uint256 id, uint256 value, bytes memory data) internal {
 309 |     |         if (to == address(0)) {
 310 |     |             revert ERC1155InvalidReceiver(address(0));
 311 |     |         }
 312 |     |         (uint256[] memory ids, uint256[] memory values) = _asSingletonArrays(id, value);
 313 |     |         _updateWithAcceptanceCheck(address(0), to, ids, values, data);
 314 |     |     }
 315 |     | 
 316 |     |     /**
 317 |     |      * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {_mint}.
 318 |     |      *
 319 |     |      * Emits a {TransferBatch} event.
 320 |     |      *
 321 |     |      * Requirements:
 322 |     |      *
 323 |     |      * - `ids` and `values` must have the same length.
 324 |     |      * - `to` cannot be the zero address.
 325 |     |      * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the
 326 |     |      * acceptance magic value.
 327 |     |      */
 328 |     |     function _mintBatch(address to, uint256[] memory ids, uint256[] memory values, bytes memory data) internal {
 329 |     |         if (to == address(0)) {
 330 |     |             revert ERC1155InvalidReceiver(address(0));
 331 |     |         }
 332 |     |         _updateWithAcceptanceCheck(address(0), to, ids, values, data);
 333 |     |     }
 334 |     | 
 335 |     |     /**
 336 |     |      * @dev Destroys a `value` amount of tokens of type `id` from `from`
 337 |     |      *
 338 |     |      * Emits a {TransferSingle} event.
 339 |     |      *
 340 |     |      * Requirements:
 341 |     |      *
 342 |     |      * - `from` cannot be the zero address.
 343 |     |      * - `from` must have at least `value` amount of tokens of type `id`.
 344 |     |      */
 345 |     |     function _burn(address from, uint256 id, uint256 value) internal {
 346 |     |         if (from == address(0)) {
 347 |     |             revert ERC1155InvalidSender(address(0));
 348 |     |         }
 349 |     |         (uint256[] memory ids, uint256[] memory values) = _asSingletonArrays(id, value);
 350 |     |         _updateWithAcceptanceCheck(from, address(0), ids, values, "");
 351 |     |     }
 352 |     | 
 353 |     |     /**
 354 |     |      * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {_burn}.
 355 |     |      *
 356 |     |      * Emits a {TransferBatch} event.
 357 |     |      *
 358 |     |      * Requirements:
 359 |     |      *
 360 |     |      * - `from` cannot be the zero address.
 361 |     |      * - `from` must have at least `value` amount of tokens of type `id`.
 362 |     |      * - `ids` and `values` must have the same length.
 363 |     |      */
 364 |     |     function _burnBatch(address from, uint256[] memory ids, uint256[] memory values) internal {
 365 |     |         if (from == address(0)) {
 366 |     |             revert ERC1155InvalidSender(address(0));
 367 |     |         }
 368 |     |         _updateWithAcceptanceCheck(from, address(0), ids, values, "");
 369 |     |     }
 370 |     | 
 371 |     |     /**
 372 |     |      * @dev Approve `operator` to operate on all of `owner` tokens
 373 |     |      *
 374 |     |      * Emits an {ApprovalForAll} event.
 375 |     |      *
 376 |     |      * Requirements:
 377 |     |      *
 378 |     |      * - `operator` cannot be the zero address.
 379 |     |      */
 380 |     |     function _setApprovalForAll(address owner, address operator, bool approved) internal virtual {
 381 |     |         ERC1155Storage storage $ = _getERC1155Storage();
 382 |     |         if (operator == address(0)) {
 383 |     |             revert ERC1155InvalidOperator(address(0));
 384 |     |         }
 385 |     |         $._operatorApprovals[owner][operator] = approved;
 386 |     |         emit ApprovalForAll(owner, operator, approved);
 387 |     |     }
 388 |     | 
 389 |     |     /**
 390 |     |      * @dev Creates an array in memory with only one value for each of the elements provided.
 391 |     |      */
 392 |     |     function _asSingletonArrays(
 393 |     |         uint256 element1,
 394 |     |         uint256 element2
 395 |     |     ) private pure returns (uint256[] memory array1, uint256[] memory array2) {
 396 |     |         assembly ("memory-safe") {
 397 |     |             // Load the free memory pointer
 398 |     |             array1 := mload(0x40)
 399 |     |             // Set array length to 1
 400 |     |             mstore(array1, 1)
 401 |     |             // Store the single element at the next word after the length (where content starts)
 402 |     |             mstore(add(array1, 0x20), element1)
 403 |     | 
 404 |     |             // Repeat for next array locating it right after the first array
 405 |     |             array2 := add(array1, 0x40)
 406 |     |             mstore(array2, 1)
 407 |     |             mstore(add(array2, 0x20), element2)
 408 |     | 
 409 |     |             // Update the free memory pointer by pointing after the second array
 410 |     |             mstore(0x40, add(array2, 0x40))
 411 |     |         }
 412 |     |     }
 413 |     | }
 414 |     | 

/home/phantom/Documents/azemora/azemora-contracts/lib/openzeppelin-contracts-upgradeable/contracts/token/ERC1155/utils/ERC1155HolderUpgradeable.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | // OpenZeppelin Contracts (last updated v5.1.0) (token/ERC1155/utils/ERC1155Holder.sol)
  3 |     | 
  4 |     | pragma solidity ^0.8.20;
  5 |     | 
  6 |     | import {IERC165} from "@openzeppelin/contracts/utils/introspection/IERC165.sol";
  7 |     | import {ERC165Upgradeable} from "../../../utils/introspection/ERC165Upgradeable.sol";
  8 |     | import {IERC1155Receiver} from "@openzeppelin/contracts/token/ERC1155/IERC1155Receiver.sol";
  9 |     | import {Initializable} from "../../../proxy/utils/Initializable.sol";
 10 |     | 
 11 |     | /**
 12 |     |  * @dev Simple implementation of `IERC1155Receiver` that will allow a contract to hold ERC-1155 tokens.
 13 |     |  *
 14 |     |  * IMPORTANT: When inheriting this contract, you must include a way to use the received tokens, otherwise they will be
 15 |     |  * stuck.
 16 |     |  */
 17 |     | abstract contract ERC1155HolderUpgradeable is Initializable, ERC165Upgradeable, IERC1155Receiver {
 18 |     |     function __ERC1155Holder_init() internal onlyInitializing {
 19 |     |     }
 20 |     | 
 21 |     |     function __ERC1155Holder_init_unchained() internal onlyInitializing {
 22 |     |     }
 23 |     |     /// @inheritdoc IERC165
 24 |     |     function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165Upgradeable, IERC165) returns (bool) {
 25 |     |         return interfaceId == type(IERC1155Receiver).interfaceId || super.supportsInterface(interfaceId);
 26 |     |     }
 27 |     | 
 28 |     |     function onERC1155Received(
 29 |     |         address,
 30 |     |         address,
 31 |     |         uint256,
 32 |     |         uint256,
 33 |     |         bytes memory
 34 |     |     ) public virtual override returns (bytes4) {
 35 |     |         return this.onERC1155Received.selector;
 36 |     |     }
 37 |     | 
 38 |     |     function onERC1155BatchReceived(
 39 |     |         address,
 40 |     |         address,
 41 |     |         uint256[] memory,
 42 |     |         uint256[] memory,
 43 |     |         bytes memory
 44 |     |     ) public virtual override returns (bytes4) {
 45 |     |         return this.onERC1155BatchReceived.selector;
 46 |     |     }
 47 |     | }
 48 |     | 

/home/phantom/Documents/azemora/azemora-contracts/lib/openzeppelin-contracts-upgradeable/contracts/token/ERC20/ERC20Upgradeable.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | // OpenZeppelin Contracts (last updated v5.3.0) (token/ERC20/ERC20.sol)
   3 |     | 
   4 |     | pragma solidity ^0.8.20;
   5 |     | 
   6 |     | import {IERC20} from "@openzeppelin/contracts/token/ERC20/IERC20.sol";
   7 |     | import {IERC20Metadata} from "@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol";
   8 |     | import {ContextUpgradeable} from "../../utils/ContextUpgradeable.sol";
   9 |     | import {IERC20Errors} from "@openzeppelin/contracts/interfaces/draft-IERC6093.sol";
  10 |     | import {Initializable} from "../../proxy/utils/Initializable.sol";
  11 |     | 
  12 |     | /**
  13 |     |  * @dev Implementation of the {IERC20} interface.
  14 |     |  *
  15 |     |  * This implementation is agnostic to the way tokens are created. This means
  16 |     |  * that a supply mechanism has to be added in a derived contract using {_mint}.
  17 |     |  *
  18 |     |  * TIP: For a detailed writeup see our guide
  19 |     |  * https://forum.openzeppelin.com/t/how-to-implement-erc20-supply-mechanisms/226[How
  20 |     |  * to implement supply mechanisms].
  21 |     |  *
  22 |     |  * The default value of {decimals} is 18. To change this, you should override
  23 |     |  * this function so it returns a different value.
  24 |     |  *
  25 |     |  * We have followed general OpenZeppelin Contracts guidelines: functions revert
  26 |     |  * instead returning `false` on failure. This behavior is nonetheless
  27 |     |  * conventional and does not conflict with the expectations of ERC-20
  28 |     |  * applications.
  29 |     |  */
  30 |     | abstract contract ERC20Upgradeable is Initializable, ContextUpgradeable, IERC20, IERC20Metadata, IERC20Errors {
  31 |     |     /// @custom:storage-location erc7201:openzeppelin.storage.ERC20
  32 |     |     struct ERC20Storage {
  33 |     |         mapping(address account => uint256) _balances;
  34 |     | 
  35 |     |         mapping(address account => mapping(address spender => uint256)) _allowances;
  36 |     | 
  37 |     |         uint256 _totalSupply;
  38 |     | 
  39 |     |         string _name;
  40 |     |         string _symbol;
  41 |     |     }
  42 |     | 
  43 |     |     // keccak256(abi.encode(uint256(keccak256("openzeppelin.storage.ERC20")) - 1)) & ~bytes32(uint256(0xff))
  44 |     |     bytes32 private constant ERC20StorageLocation = 0x52c63247e1f47db19d5ce0460030c497f067ca4cebf71ba98eeadabe20bace00;
  45 |     | 
  46 |     |     function _getERC20Storage() private pure returns (ERC20Storage storage $) {
  47 |     |         assembly {
  48 |     |             $.slot := ERC20StorageLocation
  49 |     |         }
  50 |     |     }
  51 |     | 
  52 |     |     /**
  53 |     |      * @dev Sets the values for {name} and {symbol}.
  54 |     |      *
  55 |     |      * Both values are immutable: they can only be set once during construction.
  56 |     |      */
  57 |     |     function __ERC20_init(string memory name_, string memory symbol_) internal onlyInitializing {
  58 |     |         __ERC20_init_unchained(name_, symbol_);
  59 |     |     }
  60 |     | 
  61 |     |     function __ERC20_init_unchained(string memory name_, string memory symbol_) internal onlyInitializing {
  62 |     |         ERC20Storage storage $ = _getERC20Storage();
  63 |     |         $._name = name_;
  64 |     |         $._symbol = symbol_;
  65 |     |     }
  66 |     | 
  67 |     |     /**
  68 |     |      * @dev Returns the name of the token.
  69 |     |      */
  70 |     |     function name() public view virtual returns (string memory) {
  71 |     |         ERC20Storage storage $ = _getERC20Storage();
  72 |     |         return $._name;
  73 |     |     }
  74 |     | 
  75 |     |     /**
  76 |     |      * @dev Returns the symbol of the token, usually a shorter version of the
  77 |     |      * name.
  78 |     |      */
  79 |     |     function symbol() public view virtual returns (string memory) {
  80 |     |         ERC20Storage storage $ = _getERC20Storage();
  81 |     |         return $._symbol;
  82 |     |     }
  83 |     | 
  84 |     |     /**
  85 |     |      * @dev Returns the number of decimals used to get its user representation.
  86 |     |      * For example, if `decimals` equals `2`, a balance of `505` tokens should
  87 |     |      * be displayed to a user as `5.05` (`505 / 10 ** 2`).
  88 |     |      *
  89 |     |      * Tokens usually opt for a value of 18, imitating the relationship between
  90 |     |      * Ether and Wei. This is the default value returned by this function, unless
  91 |     |      * it's overridden.
  92 |     |      *
  93 |     |      * NOTE: This information is only used for _display_ purposes: it in
  94 |     |      * no way affects any of the arithmetic of the contract, including
  95 |     |      * {IERC20-balanceOf} and {IERC20-transfer}.
  96 |     |      */
  97 |     |     function decimals() public view virtual returns (uint8) {
  98 |     |         return 18;
  99 |     |     }
 100 |     | 
 101 |     |     /// @inheritdoc IERC20
 102 |     |     function totalSupply() public view virtual returns (uint256) {
 103 |     |         ERC20Storage storage $ = _getERC20Storage();
 104 |     |         return $._totalSupply;
 105 |     |     }
 106 |     | 
 107 |     |     /// @inheritdoc IERC20
 108 |     |     function balanceOf(address account) public view virtual returns (uint256) {
 109 |     |         ERC20Storage storage $ = _getERC20Storage();
 110 |     |         return $._balances[account];
 111 |     |     }
 112 |     | 
 113 |     |     /**
 114 |     |      * @dev See {IERC20-transfer}.
 115 |     |      *
 116 |     |      * Requirements:
 117 |     |      *
 118 |     |      * - `to` cannot be the zero address.
 119 |     |      * - the caller must have a balance of at least `value`.
 120 |     |      */
 121 |     |     function transfer(address to, uint256 value) public virtual returns (bool) {
 122 |     |         address owner = _msgSender();
 123 |     |         _transfer(owner, to, value);
 124 |     |         return true;
 125 |     |     }
 126 |     | 
 127 |     |     /// @inheritdoc IERC20
 128 |     |     function allowance(address owner, address spender) public view virtual returns (uint256) {
 129 |     |         ERC20Storage storage $ = _getERC20Storage();
 130 |     |         return $._allowances[owner][spender];
 131 |     |     }
 132 |     | 
 133 |     |     /**
 134 |     |      * @dev See {IERC20-approve}.
 135 |     |      *
 136 |     |      * NOTE: If `value` is the maximum `uint256`, the allowance is not updated on
 137 |     |      * `transferFrom`. This is semantically equivalent to an infinite approval.
 138 |     |      *
 139 |     |      * Requirements:
 140 |     |      *
 141 |     |      * - `spender` cannot be the zero address.
 142 |     |      */
 143 |     |     function approve(address spender, uint256 value) public virtual returns (bool) {
 144 |     |         address owner = _msgSender();
 145 |     |         _approve(owner, spender, value);
 146 |     |         return true;
 147 |     |     }
 148 |     | 
 149 |     |     /**
 150 |     |      * @dev See {IERC20-transferFrom}.
 151 |     |      *
 152 |     |      * Skips emitting an {Approval} event indicating an allowance update. This is not
 153 |     |      * required by the ERC. See {xref-ERC20-_approve-address-address-uint256-bool-}[_approve].
 154 |     |      *
 155 |     |      * NOTE: Does not update the allowance if the current allowance
 156 |     |      * is the maximum `uint256`.
 157 |     |      *
 158 |     |      * Requirements:
 159 |     |      *
 160 |     |      * - `from` and `to` cannot be the zero address.
 161 |     |      * - `from` must have a balance of at least `value`.
 162 |     |      * - the caller must have allowance for ``from``'s tokens of at least
 163 |     |      * `value`.
 164 |     |      */
 165 |     |     function transferFrom(address from, address to, uint256 value) public virtual returns (bool) {
 166 |     |         address spender = _msgSender();
 167 |     |         _spendAllowance(from, spender, value);
 168 |     |         _transfer(from, to, value);
 169 |     |         return true;
 170 |     |     }
 171 |     | 
 172 |     |     /**
 173 |     |      * @dev Moves a `value` amount of tokens from `from` to `to`.
 174 |     |      *
 175 |     |      * This internal function is equivalent to {transfer}, and can be used to
 176 |     |      * e.g. implement automatic token fees, slashing mechanisms, etc.
 177 |     |      *
 178 |     |      * Emits a {Transfer} event.
 179 |     |      *
 180 |     |      * NOTE: This function is not virtual, {_update} should be overridden instead.
 181 |     |      */
 182 |     |     function _transfer(address from, address to, uint256 value) internal {
 183 |     |         if (from == address(0)) {
 184 |     |             revert ERC20InvalidSender(address(0));
 185 |     |         }
 186 |     |         if (to == address(0)) {
 187 |     |             revert ERC20InvalidReceiver(address(0));
 188 |     |         }
 189 |     |         _update(from, to, value);
 190 |     |     }
 191 |     | 
 192 |     |     /**
 193 |     |      * @dev Transfers a `value` amount of tokens from `from` to `to`, or alternatively mints (or burns) if `from`
 194 |     |      * (or `to`) is the zero address. All customizations to transfers, mints, and burns should be done by overriding
 195 |     |      * this function.
 196 |     |      *
 197 |     |      * Emits a {Transfer} event.
 198 |     |      */
 199 |     |     function _update(address from, address to, uint256 value) internal virtual {
 200 |     |         ERC20Storage storage $ = _getERC20Storage();
 201 |     |         if (from == address(0)) {
 202 |     |             // Overflow check required: The rest of the code assumes that totalSupply never overflows
 203 |     |             $._totalSupply += value;
 204 |     |         } else {
 205 |     |             uint256 fromBalance = $._balances[from];
 206 |     |             if (fromBalance < value) {
 207 |     |                 revert ERC20InsufficientBalance(from, fromBalance, value);
 208 |     |             }
 209 |     |             unchecked {
 210 |     |                 // Overflow not possible: value <= fromBalance <= totalSupply.
 211 |     |                 $._balances[from] = fromBalance - value;
 212 |     |             }
 213 |     |         }
 214 |     | 
 215 |     |         if (to == address(0)) {
 216 |     |             unchecked {
 217 |     |                 // Overflow not possible: value <= totalSupply or value <= fromBalance <= totalSupply.
 218 |     |                 $._totalSupply -= value;
 219 |     |             }
 220 |     |         } else {
 221 |     |             unchecked {
 222 |     |                 // Overflow not possible: balance + value is at most totalSupply, which we know fits into a uint256.
 223 |     |                 $._balances[to] += value;
 224 |     |             }
 225 |     |         }
 226 |     | 
 227 |     |         emit Transfer(from, to, value);
 228 |     |     }
 229 |     | 
 230 |     |     /**
 231 |     |      * @dev Creates a `value` amount of tokens and assigns them to `account`, by transferring it from address(0).
 232 |     |      * Relies on the `_update` mechanism
 233 |     |      *
 234 |     |      * Emits a {Transfer} event with `from` set to the zero address.
 235 |     |      *
 236 |     |      * NOTE: This function is not virtual, {_update} should be overridden instead.
 237 |     |      */
 238 |     |     function _mint(address account, uint256 value) internal {
 239 |     |         if (account == address(0)) {
 240 |     |             revert ERC20InvalidReceiver(address(0));
 241 |     |         }
 242 |     |         _update(address(0), account, value);
 243 |     |     }
 244 |     | 
 245 |     |     /**
 246 |     |      * @dev Destroys a `value` amount of tokens from `account`, lowering the total supply.
 247 |     |      * Relies on the `_update` mechanism.
 248 |     |      *
 249 |     |      * Emits a {Transfer} event with `to` set to the zero address.
 250 |     |      *
 251 |     |      * NOTE: This function is not virtual, {_update} should be overridden instead
 252 |     |      */
 253 |     |     function _burn(address account, uint256 value) internal {
 254 |     |         if (account == address(0)) {
 255 |     |             revert ERC20InvalidSender(address(0));
 256 |     |         }
 257 |     |         _update(account, address(0), value);
 258 |     |     }
 259 |     | 
 260 |     |     /**
 261 |     |      * @dev Sets `value` as the allowance of `spender` over the `owner`'s tokens.
 262 |     |      *
 263 |     |      * This internal function is equivalent to `approve`, and can be used to
 264 |     |      * e.g. set automatic allowances for certain subsystems, etc.
 265 |     |      *
 266 |     |      * Emits an {Approval} event.
 267 |     |      *
 268 |     |      * Requirements:
 269 |     |      *
 270 |     |      * - `owner` cannot be the zero address.
 271 |     |      * - `spender` cannot be the zero address.
 272 |     |      *
 273 |     |      * Overrides to this logic should be done to the variant with an additional `bool emitEvent` argument.
 274 |     |      */
 275 |     |     function _approve(address owner, address spender, uint256 value) internal {
 276 |     |         _approve(owner, spender, value, true);
 277 |     |     }
 278 |     | 
 279 |     |     /**
 280 |     |      * @dev Variant of {_approve} with an optional flag to enable or disable the {Approval} event.
 281 |     |      *
 282 |     |      * By default (when calling {_approve}) the flag is set to true. On the other hand, approval changes made by
 283 |     |      * `_spendAllowance` during the `transferFrom` operation set the flag to false. This saves gas by not emitting any
 284 |     |      * `Approval` event during `transferFrom` operations.
 285 |     |      *
 286 |     |      * Anyone who wishes to continue emitting `Approval` events on the`transferFrom` operation can force the flag to
 287 |     |      * true using the following override:
 288 |     |      *
 289 |     |      * ```solidity
 290 |     |      * function _approve(address owner, address spender, uint256 value, bool) internal virtual override {
 291 |     |      *     super._approve(owner, spender, value, true);
 292 |     |      * }
 293 |     |      * ```
 294 |     |      *
 295 |     |      * Requirements are the same as {_approve}.
 296 |     |      */
 297 |     |     function _approve(address owner, address spender, uint256 value, bool emitEvent) internal virtual {
 298 |     |         ERC20Storage storage $ = _getERC20Storage();
 299 |     |         if (owner == address(0)) {
 300 |     |             revert ERC20InvalidApprover(address(0));
 301 |     |         }
 302 |     |         if (spender == address(0)) {
 303 |     |             revert ERC20InvalidSpender(address(0));
 304 |     |         }
 305 |     |         $._allowances[owner][spender] = value;
 306 |     |         if (emitEvent) {
 307 |     |             emit Approval(owner, spender, value);
 308 |     |         }
 309 |     |     }
 310 |     | 
 311 |     |     /**
 312 |     |      * @dev Updates `owner`'s allowance for `spender` based on spent `value`.
 313 |     |      *
 314 |     |      * Does not update the allowance value in case of infinite allowance.
 315 |     |      * Revert if not enough allowance is available.
 316 |     |      *
 317 |     |      * Does not emit an {Approval} event.
 318 |     |      */
 319 |     |     function _spendAllowance(address owner, address spender, uint256 value) internal virtual {
 320 |     |         uint256 currentAllowance = allowance(owner, spender);
 321 |     |         if (currentAllowance < type(uint256).max) {
 322 |     |             if (currentAllowance < value) {
 323 |     |                 revert ERC20InsufficientAllowance(spender, currentAllowance, value);
 324 |     |             }
 325 |     |             unchecked {
 326 |     |                 _approve(owner, spender, currentAllowance - value, false);
 327 |     |             }
 328 |     |         }
 329 |     |     }
 330 |     | }
 331 |     | 

/home/phantom/Documents/azemora/azemora-contracts/lib/openzeppelin-contracts-upgradeable/contracts/token/ERC20/extensions/ERC20PermitUpgradeable.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | // OpenZeppelin Contracts (last updated v5.1.0) (token/ERC20/extensions/ERC20Permit.sol)
  3 |     | 
  4 |     | pragma solidity ^0.8.20;
  5 |     | 
  6 |     | import {IERC20Permit} from "@openzeppelin/contracts/token/ERC20/extensions/IERC20Permit.sol";
  7 |     | import {ERC20Upgradeable} from "../ERC20Upgradeable.sol";
  8 |     | import {ECDSA} from "@openzeppelin/contracts/utils/cryptography/ECDSA.sol";
  9 |     | import {EIP712Upgradeable} from "../../../utils/cryptography/EIP712Upgradeable.sol";
 10 |     | import {NoncesUpgradeable} from "../../../utils/NoncesUpgradeable.sol";
 11 |     | import {Initializable} from "../../../proxy/utils/Initializable.sol";
 12 |     | 
 13 |     | /**
 14 |     |  * @dev Implementation of the ERC-20 Permit extension allowing approvals to be made via signatures, as defined in
 15 |     |  * https://eips.ethereum.org/EIPS/eip-2612[ERC-2612].
 16 |     |  *
 17 |     |  * Adds the {permit} method, which can be used to change an account's ERC-20 allowance (see {IERC20-allowance}) by
 18 |     |  * presenting a message signed by the account. By not relying on `{IERC20-approve}`, the token holder account doesn't
 19 |     |  * need to send a transaction, and thus is not required to hold Ether at all.
 20 |     |  */
 21 |     | abstract contract ERC20PermitUpgradeable is Initializable, ERC20Upgradeable, IERC20Permit, EIP712Upgradeable, NoncesUpgradeable {
 22 |     |     bytes32 private constant PERMIT_TYPEHASH =
 23 |     |         keccak256("Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)");
 24 |     | 
 25 |     |     /**
 26 |     |      * @dev Permit deadline has expired.
 27 |     |      */
 28 |     |     error ERC2612ExpiredSignature(uint256 deadline);
 29 |     | 
 30 |     |     /**
 31 |     |      * @dev Mismatched signature.
 32 |     |      */
 33 |     |     error ERC2612InvalidSigner(address signer, address owner);
 34 |     | 
 35 |     |     /**
 36 |     |      * @dev Initializes the {EIP712} domain separator using the `name` parameter, and setting `version` to `"1"`.
 37 |     |      *
 38 |     |      * It's a good idea to use the same `name` that is defined as the ERC-20 token name.
 39 |     |      */
 40 |     |     function __ERC20Permit_init(string memory name) internal onlyInitializing {
 41 |     |         __EIP712_init_unchained(name, "1");
 42 |     |     }
 43 |     | 
 44 |     |     function __ERC20Permit_init_unchained(string memory) internal onlyInitializing {}
 45 |     | 
 46 |     |     /// @inheritdoc IERC20Permit
 47 |     |     function permit(
 48 |     |         address owner,
 49 |     |         address spender,
 50 |     |         uint256 value,
 51 |     |         uint256 deadline,
 52 |     |         uint8 v,
 53 |     |         bytes32 r,
 54 |     |         bytes32 s
 55 |     |     ) public virtual {
 56 |     |         if (block.timestamp > deadline) {
 57 |     |             revert ERC2612ExpiredSignature(deadline);
 58 |     |         }
 59 |     | 
 60 |     |         bytes32 structHash = keccak256(abi.encode(PERMIT_TYPEHASH, owner, spender, value, _useNonce(owner), deadline));
 61 |     | 
 62 |     |         bytes32 hash = _hashTypedDataV4(structHash);
 63 |     | 
 64 |     |         address signer = ECDSA.recover(hash, v, r, s);
 65 |     |         if (signer != owner) {
 66 |     |             revert ERC2612InvalidSigner(signer, owner);
 67 |     |         }
 68 |     | 
 69 |     |         _approve(owner, spender, value);
 70 |     |     }
 71 |     | 
 72 |     |     /// @inheritdoc IERC20Permit
 73 |     |     function nonces(address owner) public view virtual override(IERC20Permit, NoncesUpgradeable) returns (uint256) {
 74 |     |         return super.nonces(owner);
 75 |     |     }
 76 |     | 
 77 |     |     /// @inheritdoc IERC20Permit
 78 |     |     // solhint-disable-next-line func-name-mixedcase
 79 |     |     function DOMAIN_SEPARATOR() external view virtual returns (bytes32) {
 80 |     |         return _domainSeparatorV4();
 81 |     |     }
 82 |     | }
 83 |     | 

/home/phantom/Documents/azemora/azemora-contracts/lib/openzeppelin-contracts-upgradeable/contracts/token/ERC20/extensions/ERC20VotesUpgradeable.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | // OpenZeppelin Contracts (last updated v5.1.0) (token/ERC20/extensions/ERC20Votes.sol)
  3 |     | 
  4 |     | pragma solidity ^0.8.20;
  5 |     | 
  6 |     | import {ERC20Upgradeable} from "../ERC20Upgradeable.sol";
  7 |     | import {VotesUpgradeable} from "../../../governance/utils/VotesUpgradeable.sol";
  8 |     | import {Checkpoints} from "@openzeppelin/contracts/utils/structs/Checkpoints.sol";
  9 |     | import {Initializable} from "../../../proxy/utils/Initializable.sol";
 10 |     | 
 11 |     | /**
 12 |     |  * @dev Extension of ERC-20 to support Compound-like voting and delegation. This version is more generic than Compound's,
 13 |     |  * and supports token supply up to 2^208^ - 1, while COMP is limited to 2^96^ - 1.
 14 |     |  *
 15 |     |  * NOTE: This contract does not provide interface compatibility with Compound's COMP token.
 16 |     |  *
 17 |     |  * This extension keeps a history (checkpoints) of each account's vote power. Vote power can be delegated either
 18 |     |  * by calling the {Votes-delegate} function directly, or by providing a signature to be used with {Votes-delegateBySig}. Voting
 19 |     |  * power can be queried through the public accessors {Votes-getVotes} and {Votes-getPastVotes}.
 20 |     |  *
 21 |     |  * By default, token balance does not account for voting power. This makes transfers cheaper. The downside is that it
 22 |     |  * requires users to delegate to themselves in order to activate checkpoints and have their voting power tracked.
 23 |     |  */
 24 |     | abstract contract ERC20VotesUpgradeable is Initializable, ERC20Upgradeable, VotesUpgradeable {
 25 |     |     /**
 26 |     |      * @dev Total supply cap has been exceeded, introducing a risk of votes overflowing.
 27 |     |      */
 28 |     |     error ERC20ExceededSafeSupply(uint256 increasedSupply, uint256 cap);
 29 |     | 
 30 |     |     function __ERC20Votes_init() internal onlyInitializing {
 31 |     |     }
 32 |     | 
 33 |     |     function __ERC20Votes_init_unchained() internal onlyInitializing {
 34 |     |     }
 35 |     |     /**
 36 |     |      * @dev Maximum token supply. Defaults to `type(uint208).max` (2^208^ - 1).
 37 |     |      *
 38 |     |      * This maximum is enforced in {_update}. It limits the total supply of the token, which is otherwise a uint256,
 39 |     |      * so that checkpoints can be stored in the Trace208 structure used by {Votes}. Increasing this value will not
 40 |     |      * remove the underlying limitation, and will cause {_update} to fail because of a math overflow in
 41 |     |      * {Votes-_transferVotingUnits}. An override could be used to further restrict the total supply (to a lower value) if
 42 |     |      * additional logic requires it. When resolving override conflicts on this function, the minimum should be
 43 |     |      * returned.
 44 |     |      */
 45 |     |     function _maxSupply() internal view virtual returns (uint256) {
 46 |     |         return type(uint208).max;
 47 |     |     }
 48 |     | 
 49 |     |     /**
 50 |     |      * @dev Move voting power when tokens are transferred.
 51 |     |      *
 52 |     |      * Emits a {IVotes-DelegateVotesChanged} event.
 53 |     |      */
 54 |     |     function _update(address from, address to, uint256 value) internal virtual override {
 55 |     |         super._update(from, to, value);
 56 |     |         if (from == address(0)) {
 57 |     |             uint256 supply = totalSupply();
 58 |     |             uint256 cap = _maxSupply();
 59 |     |             if (supply > cap) {
 60 |     |                 revert ERC20ExceededSafeSupply(supply, cap);
 61 |     |             }
 62 |     |         }
 63 |     |         _transferVotingUnits(from, to, value);
 64 |     |     }
 65 |     | 
 66 |     |     /**
 67 |     |      * @dev Returns the voting units of an `account`.
 68 |     |      *
 69 |     |      * WARNING: Overriding this function may compromise the internal vote accounting.
 70 |     |      * `ERC20Votes` assumes tokens map to voting units 1:1 and this is not easy to change.
 71 |     |      */
 72 |     |     function _getVotingUnits(address account) internal view virtual override returns (uint256) {
 73 |     |         return balanceOf(account);
 74 |     |     }
 75 |     | 
 76 |     |     /**
 77 |     |      * @dev Get number of checkpoints for `account`.
 78 |     |      */
 79 |     |     function numCheckpoints(address account) public view virtual returns (uint32) {
 80 |     |         return _numCheckpoints(account);
 81 |     |     }
 82 |     | 
 83 |     |     /**
 84 |     |      * @dev Get the `pos`-th checkpoint for `account`.
 85 |     |      */
 86 |     |     function checkpoints(address account, uint32 pos) public view virtual returns (Checkpoints.Checkpoint208 memory) {
 87 |     |         return _checkpoints(account, pos);
 88 |     |     }
 89 |     | }
 90 |     | 

/home/phantom/Documents/azemora/azemora-contracts/lib/openzeppelin-contracts-upgradeable/contracts/token/ERC721/utils/ERC721HolderUpgradeable.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | // OpenZeppelin Contracts (last updated v5.0.0) (token/ERC721/utils/ERC721Holder.sol)
  3 |     | 
  4 |     | pragma solidity ^0.8.20;
  5 |     | 
  6 |     | import {IERC721Receiver} from "@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol";
  7 |     | import {Initializable} from "../../../proxy/utils/Initializable.sol";
  8 |     | 
  9 |     | /**
 10 |     |  * @dev Implementation of the {IERC721Receiver} interface.
 11 |     |  *
 12 |     |  * Accepts all token transfers.
 13 |     |  * Make sure the contract is able to use its token with {IERC721-safeTransferFrom}, {IERC721-approve} or
 14 |     |  * {IERC721-setApprovalForAll}.
 15 |     |  */
 16 |     | abstract contract ERC721HolderUpgradeable is Initializable, IERC721Receiver {
 17 |     |     function __ERC721Holder_init() internal onlyInitializing {
 18 |     |     }
 19 |     | 
 20 |     |     function __ERC721Holder_init_unchained() internal onlyInitializing {
 21 |     |     }
 22 |     |     /**
 23 |     |      * @dev See {IERC721Receiver-onERC721Received}.
 24 |     |      *
 25 |     |      * Always returns `IERC721Receiver.onERC721Received.selector`.
 26 |     |      */
 27 |     |     function onERC721Received(address, address, uint256, bytes memory) public virtual returns (bytes4) {
 28 |     |         return this.onERC721Received.selector;
 29 |     |     }
 30 |     | }
 31 |     | 

/home/phantom/Documents/azemora/azemora-contracts/lib/openzeppelin-contracts-upgradeable/contracts/utils/ContextUpgradeable.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | // OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)
  3 |     | 
  4 |     | pragma solidity ^0.8.20;
  5 |     | import {Initializable} from "../proxy/utils/Initializable.sol";
  6 |     | 
  7 |     | /**
  8 |     |  * @dev Provides information about the current execution context, including the
  9 |     |  * sender of the transaction and its data. While these are generally available
 10 |     |  * via msg.sender and msg.data, they should not be accessed in such a direct
 11 |     |  * manner, since when dealing with meta-transactions the account sending and
 12 |     |  * paying for execution may not be the actual sender (as far as an application
 13 |     |  * is concerned).
 14 |     |  *
 15 |     |  * This contract is only required for intermediate, library-like contracts.
 16 |     |  */
 17 |     | abstract contract ContextUpgradeable is Initializable {
 18 |     |     function __Context_init() internal onlyInitializing {
 19 |     |     }
 20 |     | 
 21 |     |     function __Context_init_unchained() internal onlyInitializing {
 22 |     |     }
 23 |     |     function _msgSender() internal view virtual returns (address) {
 24 |     |         return msg.sender;
 25 |     |     }
 26 |     | 
 27 |     |     function _msgData() internal view virtual returns (bytes calldata) {
 28 |     |         return msg.data;
 29 |     |     }
 30 |     | 
 31 |     |     function _contextSuffixLength() internal view virtual returns (uint256) {
 32 |     |         return 0;
 33 |     |     }
 34 |     | }
 35 |     | 

/home/phantom/Documents/azemora/azemora-contracts/lib/openzeppelin-contracts-upgradeable/contracts/utils/NoncesUpgradeable.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | // OpenZeppelin Contracts (last updated v5.0.0) (utils/Nonces.sol)
  3 |     | pragma solidity ^0.8.20;
  4 |     | import {Initializable} from "../proxy/utils/Initializable.sol";
  5 |     | 
  6 |     | /**
  7 |     |  * @dev Provides tracking nonces for addresses. Nonces will only increment.
  8 |     |  */
  9 |     | abstract contract NoncesUpgradeable is Initializable {
 10 |     |     /**
 11 |     |      * @dev The nonce used for an `account` is not the expected current nonce.
 12 |     |      */
 13 |     |     error InvalidAccountNonce(address account, uint256 currentNonce);
 14 |     | 
 15 |     |     /// @custom:storage-location erc7201:openzeppelin.storage.Nonces
 16 |     |     struct NoncesStorage {
 17 |     |         mapping(address account => uint256) _nonces;
 18 |     |     }
 19 |     | 
 20 |     |     // keccak256(abi.encode(uint256(keccak256("openzeppelin.storage.Nonces")) - 1)) & ~bytes32(uint256(0xff))
 21 |     |     bytes32 private constant NoncesStorageLocation = 0x5ab42ced628888259c08ac98db1eb0cf702fc1501344311d8b100cd1bfe4bb00;
 22 |     | 
 23 |     |     function _getNoncesStorage() private pure returns (NoncesStorage storage $) {
 24 |     |         assembly {
 25 |     |             $.slot := NoncesStorageLocation
 26 |     |         }
 27 |     |     }
 28 |     | 
 29 |     |     function __Nonces_init() internal onlyInitializing {
 30 |     |     }
 31 |     | 
 32 |     |     function __Nonces_init_unchained() internal onlyInitializing {
 33 |     |     }
 34 |     |     /**
 35 |     |      * @dev Returns the next unused nonce for an address.
 36 |     |      */
 37 |     |     function nonces(address owner) public view virtual returns (uint256) {
 38 |     |         NoncesStorage storage $ = _getNoncesStorage();
 39 |     |         return $._nonces[owner];
 40 |     |     }
 41 |     | 
 42 |     |     /**
 43 |     |      * @dev Consumes a nonce.
 44 |     |      *
 45 |     |      * Returns the current value and increments nonce.
 46 |     |      */
 47 |     |     function _useNonce(address owner) internal virtual returns (uint256) {
 48 |     |         NoncesStorage storage $ = _getNoncesStorage();
 49 |     |         // For each account, the nonce has an initial value of 0, can only be incremented by one, and cannot be
 50 |     |         // decremented or reset. This guarantees that the nonce never overflows.
 51 |     |         unchecked {
 52 |     |             // It is important to do x++ and not ++x here.
 53 |     |             return $._nonces[owner]++;
 54 |     |         }
 55 |     |     }
 56 |     | 
 57 |     |     /**
 58 |     |      * @dev Same as {_useNonce} but checking that `nonce` is the next valid for `owner`.
 59 |     |      */
 60 |     |     function _useCheckedNonce(address owner, uint256 nonce) internal virtual {
 61 |     |         uint256 current = _useNonce(owner);
 62 |     |         if (nonce != current) {
 63 |     |             revert InvalidAccountNonce(owner, current);
 64 |     |         }
 65 |     |     }
 66 |     | }
 67 |     | 

/home/phantom/Documents/azemora/azemora-contracts/lib/openzeppelin-contracts-upgradeable/contracts/utils/PausableUpgradeable.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | // OpenZeppelin Contracts (last updated v5.3.0) (utils/Pausable.sol)
   3 |     | 
   4 |     | pragma solidity ^0.8.20;
   5 |     | 
   6 |     | import {ContextUpgradeable} from "../utils/ContextUpgradeable.sol";
   7 |     | import {Initializable} from "../proxy/utils/Initializable.sol";
   8 |     | 
   9 |     | /**
  10 |     |  * @dev Contract module which allows children to implement an emergency stop
  11 |     |  * mechanism that can be triggered by an authorized account.
  12 |     |  *
  13 |     |  * This module is used through inheritance. It will make available the
  14 |     |  * modifiers `whenNotPaused` and `whenPaused`, which can be applied to
  15 |     |  * the functions of your contract. Note that they will not be pausable by
  16 |     |  * simply including this module, only once the modifiers are put in place.
  17 |     |  */
  18 |     | abstract contract PausableUpgradeable is Initializable, ContextUpgradeable {
  19 |     |     /// @custom:storage-location erc7201:openzeppelin.storage.Pausable
  20 |     |     struct PausableStorage {
  21 |     |         bool _paused;
  22 |     |     }
  23 |     | 
  24 |     |     // keccak256(abi.encode(uint256(keccak256("openzeppelin.storage.Pausable")) - 1)) & ~bytes32(uint256(0xff))
  25 |     |     bytes32 private constant PausableStorageLocation = 0xcd5ed15c6e187e77e9aee88184c21f4f2182ab5827cb3b7e07fbedcd63f03300;
  26 |     | 
  27 |     |     function _getPausableStorage() private pure returns (PausableStorage storage $) {
  28 |     |         assembly {
  29 |     |             $.slot := PausableStorageLocation
  30 |     |         }
  31 |     |     }
  32 |     | 
  33 |     |     /**
  34 |     |      * @dev Emitted when the pause is triggered by `account`.
  35 |     |      */
  36 |     |     event Paused(address account);
  37 |     | 
  38 |     |     /**
  39 |     |      * @dev Emitted when the pause is lifted by `account`.
  40 |     |      */
  41 |     |     event Unpaused(address account);
  42 |     | 
  43 |     |     /**
  44 |     |      * @dev The operation failed because the contract is paused.
  45 |     |      */
  46 |     |     error EnforcedPause();
  47 |     | 
  48 |     |     /**
  49 |     |      * @dev The operation failed because the contract is not paused.
  50 |     |      */
  51 |     |     error ExpectedPause();
  52 |     | 
  53 |     |     /**
  54 |     |      * @dev Modifier to make a function callable only when the contract is not paused.
  55 |     |      *
  56 |     |      * Requirements:
  57 |     |      *
  58 |     |      * - The contract must not be paused.
  59 |     |      */
  60 |     |     modifier whenNotPaused() {
  61 |     |         _requireNotPaused();
  62 |     |         _;
  63 |     |     }
  64 |     | 
  65 |     |     /**
  66 |     |      * @dev Modifier to make a function callable only when the contract is paused.
  67 |     |      *
  68 |     |      * Requirements:
  69 |     |      *
  70 |     |      * - The contract must be paused.
  71 |     |      */
  72 |     |     modifier whenPaused() {
  73 |     |         _requirePaused();
  74 |     |         _;
  75 |     |     }
  76 |     | 
  77 |     |     function __Pausable_init() internal onlyInitializing {
  78 |     |     }
  79 |     | 
  80 |     |     function __Pausable_init_unchained() internal onlyInitializing {
  81 |     |     }
  82 |     |     /**
  83 |     |      * @dev Returns true if the contract is paused, and false otherwise.
  84 |     |      */
  85 |     |     function paused() public view virtual returns (bool) {
  86 |     |         PausableStorage storage $ = _getPausableStorage();
  87 |     |         return $._paused;
  88 |     |     }
  89 |     | 
  90 |     |     /**
  91 |     |      * @dev Throws if the contract is paused.
  92 |     |      */
  93 |     |     function _requireNotPaused() internal view virtual {
  94 |     |         if (paused()) {
  95 |     |             revert EnforcedPause();
  96 |     |         }
  97 |     |     }
  98 |     | 
  99 |     |     /**
 100 |     |      * @dev Throws if the contract is not paused.
 101 |     |      */
 102 |     |     function _requirePaused() internal view virtual {
 103 |     |         if (!paused()) {
 104 |     |             revert ExpectedPause();
 105 |     |         }
 106 |     |     }
 107 |     | 
 108 |     |     /**
 109 |     |      * @dev Triggers stopped state.
 110 |     |      *
 111 |     |      * Requirements:
 112 |     |      *
 113 |     |      * - The contract must not be paused.
 114 |     |      */
 115 |     |     function _pause() internal virtual whenNotPaused {
 116 |     |         PausableStorage storage $ = _getPausableStorage();
 117 |     |         $._paused = true;
 118 |     |         emit Paused(_msgSender());
 119 |     |     }
 120 |     | 
 121 |     |     /**
 122 |     |      * @dev Returns to normal state.
 123 |     |      *
 124 |     |      * Requirements:
 125 |     |      *
 126 |     |      * - The contract must be paused.
 127 |     |      */
 128 |     |     function _unpause() internal virtual whenPaused {
 129 |     |         PausableStorage storage $ = _getPausableStorage();
 130 |     |         $._paused = false;
 131 |     |         emit Unpaused(_msgSender());
 132 |     |     }
 133 |     | }
 134 |     | 

/home/phantom/Documents/azemora/azemora-contracts/lib/openzeppelin-contracts-upgradeable/contracts/utils/ReentrancyGuardUpgradeable.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | // OpenZeppelin Contracts (last updated v5.1.0) (utils/ReentrancyGuard.sol)
   3 |     | 
   4 |     | pragma solidity ^0.8.20;
   5 |     | import {Initializable} from "../proxy/utils/Initializable.sol";
   6 |     | 
   7 |     | /**
   8 |     |  * @dev Contract module that helps prevent reentrant calls to a function.
   9 |     |  *
  10 |     |  * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier
  11 |     |  * available, which can be applied to functions to make sure there are no nested
  12 |     |  * (reentrant) calls to them.
  13 |     |  *
  14 |     |  * Note that because there is a single `nonReentrant` guard, functions marked as
  15 |     |  * `nonReentrant` may not call one another. This can be worked around by making
  16 |     |  * those functions `private`, and then adding `external` `nonReentrant` entry
  17 |     |  * points to them.
  18 |     |  *
  19 |     |  * TIP: If EIP-1153 (transient storage) is available on the chain you're deploying at,
  20 |     |  * consider using {ReentrancyGuardTransient} instead.
  21 |     |  *
  22 |     |  * TIP: If you would like to learn more about reentrancy and alternative ways
  23 |     |  * to protect against it, check out our blog post
  24 |     |  * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].
  25 |     |  */
  26 |     | abstract contract ReentrancyGuardUpgradeable is Initializable {
  27 |     |     // Booleans are more expensive than uint256 or any type that takes up a full
  28 |     |     // word because each write operation emits an extra SLOAD to first read the
  29 |     |     // slot's contents, replace the bits taken up by the boolean, and then write
  30 |     |     // back. This is the compiler's defense against contract upgrades and
  31 |     |     // pointer aliasing, and it cannot be disabled.
  32 |     | 
  33 |     |     // The values being non-zero value makes deployment a bit more expensive,
  34 |     |     // but in exchange the refund on every call to nonReentrant will be lower in
  35 |     |     // amount. Since refunds are capped to a percentage of the total
  36 |     |     // transaction's gas, it is best to keep them low in cases like this one, to
  37 |     |     // increase the likelihood of the full refund coming into effect.
  38 |     |     uint256 private constant NOT_ENTERED = 1;
  39 |     |     uint256 private constant ENTERED = 2;
  40 |     | 
  41 |     |     /// @custom:storage-location erc7201:openzeppelin.storage.ReentrancyGuard
  42 |     |     struct ReentrancyGuardStorage {
  43 |     |         uint256 _status;
  44 |     |     }
  45 |     | 
  46 |     |     // keccak256(abi.encode(uint256(keccak256("openzeppelin.storage.ReentrancyGuard")) - 1)) & ~bytes32(uint256(0xff))
  47 |     |     bytes32 private constant ReentrancyGuardStorageLocation = 0x9b779b17422d0df92223018b32b4d1fa46e071723d6817e2486d003becc55f00;
  48 |     | 
  49 |     |     function _getReentrancyGuardStorage() private pure returns (ReentrancyGuardStorage storage $) {
  50 |     |         assembly {
  51 |     |             $.slot := ReentrancyGuardStorageLocation
  52 |     |         }
  53 |     |     }
  54 |     | 
  55 |     |     /**
  56 |     |      * @dev Unauthorized reentrant call.
  57 |     |      */
  58 |     |     error ReentrancyGuardReentrantCall();
  59 |     | 
  60 |     |     function __ReentrancyGuard_init() internal onlyInitializing {
  61 |     |         __ReentrancyGuard_init_unchained();
  62 |     |     }
  63 |     | 
  64 |     |     function __ReentrancyGuard_init_unchained() internal onlyInitializing {
  65 |     |         ReentrancyGuardStorage storage $ = _getReentrancyGuardStorage();
  66 |     |         $._status = NOT_ENTERED;
  67 |     |     }
  68 |     | 
  69 |     |     /**
  70 |     |      * @dev Prevents a contract from calling itself, directly or indirectly.
  71 |     |      * Calling a `nonReentrant` function from another `nonReentrant`
  72 |     |      * function is not supported. It is possible to prevent this from happening
  73 |     |      * by making the `nonReentrant` function external, and making it call a
  74 |     |      * `private` function that does the actual work.
  75 |     |      */
  76 |     |     modifier nonReentrant() {
  77 |     |         _nonReentrantBefore();
  78 |     |         _;
  79 |     |         _nonReentrantAfter();
  80 |     |     }
  81 |     | 
  82 |     |     function _nonReentrantBefore() private {
  83 |     |         ReentrancyGuardStorage storage $ = _getReentrancyGuardStorage();
  84 |     |         // On the first call to nonReentrant, _status will be NOT_ENTERED
  85 |     |         if ($._status == ENTERED) {
  86 |     |             revert ReentrancyGuardReentrantCall();
  87 |     |         }
  88 |     | 
  89 |     |         // Any calls to nonReentrant after this point will fail
  90 |     |         $._status = ENTERED;
  91 |     |     }
  92 |     | 
  93 |     |     function _nonReentrantAfter() private {
  94 |     |         ReentrancyGuardStorage storage $ = _getReentrancyGuardStorage();
  95 |     |         // By storing the original value once again, a refund is triggered (see
  96 |     |         // https://eips.ethereum.org/EIPS/eip-2200)
  97 |     |         $._status = NOT_ENTERED;
  98 |     |     }
  99 |     | 
 100 |     |     /**
 101 |     |      * @dev Returns true if the reentrancy guard is currently set to "entered", which indicates there is a
 102 |     |      * `nonReentrant` function in the call stack.
 103 |     |      */
 104 |     |     function _reentrancyGuardEntered() internal view returns (bool) {
 105 |     |         ReentrancyGuardStorage storage $ = _getReentrancyGuardStorage();
 106 |     |         return $._status == ENTERED;
 107 |     |     }
 108 |     | }
 109 |     | 

/home/phantom/Documents/azemora/azemora-contracts/lib/openzeppelin-contracts-upgradeable/contracts/utils/cryptography/EIP712Upgradeable.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | // OpenZeppelin Contracts (last updated v5.3.0) (utils/cryptography/EIP712.sol)
   3 |     | 
   4 |     | pragma solidity ^0.8.20;
   5 |     | 
   6 |     | import {MessageHashUtils} from "@openzeppelin/contracts/utils/cryptography/MessageHashUtils.sol";
   7 |     | import {IERC5267} from "@openzeppelin/contracts/interfaces/IERC5267.sol";
   8 |     | import {Initializable} from "../../proxy/utils/Initializable.sol";
   9 |     | 
  10 |     | /**
  11 |     |  * @dev https://eips.ethereum.org/EIPS/eip-712[EIP-712] is a standard for hashing and signing of typed structured data.
  12 |     |  *
  13 |     |  * The encoding scheme specified in the EIP requires a domain separator and a hash of the typed structured data, whose
  14 |     |  * encoding is very generic and therefore its implementation in Solidity is not feasible, thus this contract
  15 |     |  * does not implement the encoding itself. Protocols need to implement the type-specific encoding they need in order to
  16 |     |  * produce the hash of their typed data using a combination of `abi.encode` and `keccak256`.
  17 |     |  *
  18 |     |  * This contract implements the EIP-712 domain separator ({_domainSeparatorV4}) that is used as part of the encoding
  19 |     |  * scheme, and the final step of the encoding to obtain the message digest that is then signed via ECDSA
  20 |     |  * ({_hashTypedDataV4}).
  21 |     |  *
  22 |     |  * The implementation of the domain separator was designed to be as efficient as possible while still properly updating
  23 |     |  * the chain id to protect against replay attacks on an eventual fork of the chain.
  24 |     |  *
  25 |     |  * NOTE: This contract implements the version of the encoding known as "v4", as implemented by the JSON RPC method
  26 |     |  * https://docs.metamask.io/guide/signing-data.html[`eth_signTypedDataV4` in MetaMask].
  27 |     |  *
  28 |     |  * NOTE: The upgradeable version of this contract does not use an immutable cache and recomputes the domain separator
  29 |     |  * each time {_domainSeparatorV4} is called. That is cheaper than accessing a cached version in cold storage.
  30 |     |  */
  31 |     | abstract contract EIP712Upgradeable is Initializable, IERC5267 {
  32 |     |     bytes32 private constant TYPE_HASH =
  33 |     |         keccak256("EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)");
  34 |     | 
  35 |     |     /// @custom:storage-location erc7201:openzeppelin.storage.EIP712
  36 |     |     struct EIP712Storage {
  37 |     |         /// @custom:oz-renamed-from _HASHED_NAME
  38 |     |         bytes32 _hashedName;
  39 |     |         /// @custom:oz-renamed-from _HASHED_VERSION
  40 |     |         bytes32 _hashedVersion;
  41 |     | 
  42 |     |         string _name;
  43 |     |         string _version;
  44 |     |     }
  45 |     | 
  46 |     |     // keccak256(abi.encode(uint256(keccak256("openzeppelin.storage.EIP712")) - 1)) & ~bytes32(uint256(0xff))
  47 |     |     bytes32 private constant EIP712StorageLocation = 0xa16a46d94261c7517cc8ff89f61c0ce93598e3c849801011dee649a6a557d100;
  48 |     | 
  49 |     |     function _getEIP712Storage() private pure returns (EIP712Storage storage $) {
  50 |     |         assembly {
  51 |     |             $.slot := EIP712StorageLocation
  52 |     |         }
  53 |     |     }
  54 |     | 
  55 |     |     /**
  56 |     |      * @dev Initializes the domain separator and parameter caches.
  57 |     |      *
  58 |     |      * The meaning of `name` and `version` is specified in
  59 |     |      * https://eips.ethereum.org/EIPS/eip-712#definition-of-domainseparator[EIP-712]:
  60 |     |      *
  61 |     |      * - `name`: the user readable name of the signing domain, i.e. the name of the DApp or the protocol.
  62 |     |      * - `version`: the current major version of the signing domain.
  63 |     |      *
  64 |     |      * NOTE: These parameters cannot be changed except through a xref:learn::upgrading-smart-contracts.adoc[smart
  65 |     |      * contract upgrade].
  66 |     |      */
  67 |     |     function __EIP712_init(string memory name, string memory version) internal onlyInitializing {
  68 |     |         __EIP712_init_unchained(name, version);
  69 |     |     }
  70 |     | 
  71 |     |     function __EIP712_init_unchained(string memory name, string memory version) internal onlyInitializing {
  72 |     |         EIP712Storage storage $ = _getEIP712Storage();
  73 |     |         $._name = name;
  74 |     |         $._version = version;
  75 |     | 
  76 |     |         // Reset prior values in storage if upgrading
  77 |     |         $._hashedName = 0;
  78 |     |         $._hashedVersion = 0;
  79 |     |     }
  80 |     | 
  81 |     |     /**
  82 |     |      * @dev Returns the domain separator for the current chain.
  83 |     |      */
  84 |     |     function _domainSeparatorV4() internal view returns (bytes32) {
  85 |     |         return _buildDomainSeparator();
  86 |     |     }
  87 |     | 
  88 |     |     function _buildDomainSeparator() private view returns (bytes32) {
  89 |     |         return keccak256(abi.encode(TYPE_HASH, _EIP712NameHash(), _EIP712VersionHash(), block.chainid, address(this)));
  90 |     |     }
  91 |     | 
  92 |     |     /**
  93 |     |      * @dev Given an already https://eips.ethereum.org/EIPS/eip-712#definition-of-hashstruct[hashed struct], this
  94 |     |      * function returns the hash of the fully encoded EIP712 message for this domain.
  95 |     |      *
  96 |     |      * This hash can be used together with {ECDSA-recover} to obtain the signer of a message. For example:
  97 |     |      *
  98 |     |      * ```solidity
  99 |     |      * bytes32 digest = _hashTypedDataV4(keccak256(abi.encode(
 100 |     |      *     keccak256("Mail(address to,string contents)"),
 101 |     |      *     mailTo,
 102 |     |      *     keccak256(bytes(mailContents))
 103 |     |      * )));
 104 |     |      * address signer = ECDSA.recover(digest, signature);
 105 |     |      * ```
 106 |     |      */
 107 |     |     function _hashTypedDataV4(bytes32 structHash) internal view virtual returns (bytes32) {
 108 |     |         return MessageHashUtils.toTypedDataHash(_domainSeparatorV4(), structHash);
 109 |     |     }
 110 |     | 
 111 |     |     /// @inheritdoc IERC5267
 112 |     |     function eip712Domain()
 113 |     |         public
 114 |     |         view
 115 |     |         virtual
 116 |     |         returns (
 117 |     |             bytes1 fields,
 118 |     |             string memory name,
 119 |     |             string memory version,
 120 |     |             uint256 chainId,
 121 |     |             address verifyingContract,
 122 |     |             bytes32 salt,
 123 |     |             uint256[] memory extensions
 124 |     |         )
 125 |     |     {
 126 |     |         EIP712Storage storage $ = _getEIP712Storage();
 127 |     |         // If the hashed name and version in storage are non-zero, the contract hasn't been properly initialized
 128 |     |         // and the EIP712 domain is not reliable, as it will be missing name and version.
 129 |     |         require($._hashedName == 0 && $._hashedVersion == 0, "EIP712: Uninitialized");
 130 |     | 
 131 |     |         return (
 132 |     |             hex"0f", // 01111
 133 |     |             _EIP712Name(),
 134 |     |             _EIP712Version(),
 135 |     |             block.chainid,
 136 |     |             address(this),
 137 |     |             bytes32(0),
 138 |     |             new uint256[](0)
 139 |     |         );
 140 |     |     }
 141 |     | 
 142 |     |     /**
 143 |     |      * @dev The name parameter for the EIP712 domain.
 144 |     |      *
 145 |     |      * NOTE: This function reads from storage by default, but can be redefined to return a constant value if gas costs
 146 |     |      * are a concern.
 147 |     |      */
 148 |     |     function _EIP712Name() internal view virtual returns (string memory) {
 149 |     |         EIP712Storage storage $ = _getEIP712Storage();
 150 |     |         return $._name;
 151 |     |     }
 152 |     | 
 153 |     |     /**
 154 |     |      * @dev The version parameter for the EIP712 domain.
 155 |     |      *
 156 |     |      * NOTE: This function reads from storage by default, but can be redefined to return a constant value if gas costs
 157 |     |      * are a concern.
 158 |     |      */
 159 |     |     function _EIP712Version() internal view virtual returns (string memory) {
 160 |     |         EIP712Storage storage $ = _getEIP712Storage();
 161 |     |         return $._version;
 162 |     |     }
 163 |     | 
 164 |     |     /**
 165 |     |      * @dev The hash of the name parameter for the EIP712 domain.
 166 |     |      *
 167 |     |      * NOTE: In previous versions this function was virtual. In this version you should override `_EIP712Name` instead.
 168 |     |      */
 169 |     |     function _EIP712NameHash() internal view returns (bytes32) {
 170 |     |         EIP712Storage storage $ = _getEIP712Storage();
 171 |     |         string memory name = _EIP712Name();
 172 |     |         if (bytes(name).length > 0) {
 173 |     |             return keccak256(bytes(name));
 174 |     |         } else {
 175 |     |             // If the name is empty, the contract may have been upgraded without initializing the new storage.
 176 |     |             // We return the name hash in storage if non-zero, otherwise we assume the name is empty by design.
 177 |     |             bytes32 hashedName = $._hashedName;
 178 |     |             if (hashedName != 0) {
 179 |     |                 return hashedName;
 180 |     |             } else {
 181 |     |                 return keccak256("");
 182 |     |             }
 183 |     |         }
 184 |     |     }
 185 |     | 
 186 |     |     /**
 187 |     |      * @dev The hash of the version parameter for the EIP712 domain.
 188 |     |      *
 189 |     |      * NOTE: In previous versions this function was virtual. In this version you should override `_EIP712Version` instead.
 190 |     |      */
 191 |     |     function _EIP712VersionHash() internal view returns (bytes32) {
 192 |     |         EIP712Storage storage $ = _getEIP712Storage();
 193 |     |         string memory version = _EIP712Version();
 194 |     |         if (bytes(version).length > 0) {
 195 |     |             return keccak256(bytes(version));
 196 |     |         } else {
 197 |     |             // If the version is empty, the contract may have been upgraded without initializing the new storage.
 198 |     |             // We return the version hash in storage if non-zero, otherwise we assume the version is empty by design.
 199 |     |             bytes32 hashedVersion = $._hashedVersion;
 200 |     |             if (hashedVersion != 0) {
 201 |     |                 return hashedVersion;
 202 |     |             } else {
 203 |     |                 return keccak256("");
 204 |     |             }
 205 |     |         }
 206 |     |     }
 207 |     | }
 208 |     | 

/home/phantom/Documents/azemora/azemora-contracts/lib/openzeppelin-contracts-upgradeable/contracts/utils/introspection/ERC165Upgradeable.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | // OpenZeppelin Contracts (last updated v5.1.0) (utils/introspection/ERC165.sol)
  3 |     | 
  4 |     | pragma solidity ^0.8.20;
  5 |     | 
  6 |     | import {IERC165} from "@openzeppelin/contracts/utils/introspection/IERC165.sol";
  7 |     | import {Initializable} from "../../proxy/utils/Initializable.sol";
  8 |     | 
  9 |     | /**
 10 |     |  * @dev Implementation of the {IERC165} interface.
 11 |     |  *
 12 |     |  * Contracts that want to implement ERC-165 should inherit from this contract and override {supportsInterface} to check
 13 |     |  * for the additional interface id that will be supported. For example:
 14 |     |  *
 15 |     |  * ```solidity
 16 |     |  * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {
 17 |     |  *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);
 18 |     |  * }
 19 |     |  * ```
 20 |     |  */
 21 |     | abstract contract ERC165Upgradeable is Initializable, IERC165 {
 22 |     |     function __ERC165_init() internal onlyInitializing {
 23 |     |     }
 24 |     | 
 25 |     |     function __ERC165_init_unchained() internal onlyInitializing {
 26 |     |     }
 27 |     |     /// @inheritdoc IERC165
 28 |     |     function supportsInterface(bytes4 interfaceId) public view virtual returns (bool) {
 29 |     |         return interfaceId == type(IERC165).interfaceId;
 30 |     |     }
 31 |     | }
 32 |     | 

/home/phantom/Documents/azemora/azemora-contracts/src/core/DynamicImpactCredit.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | pragma solidity ^0.8.20;
   3 |     | 
   4 |     | import "@openzeppelin/contracts-upgradeable/token/ERC1155/ERC1155Upgradeable.sol";
   5 |     | import "@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol";
   6 |     | import "@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol";
   7 |     | import "@openzeppelin/contracts-upgradeable/utils/PausableUpgradeable.sol";
   8 |     | import "./ProjectRegistry.sol";
   9 |     | 
  10 |     | // --- Custom Errors ---
  11 |     | error DynamicImpactCredit__ProjectNotActive();
  12 |     | error DynamicImpactCredit__URINotSet();
  13 |     | error DynamicImpactCredit__NotAuthorized();
  14 |     | error DynamicImpactCredit__LengthMismatch();
  15 |     | 
  16 |     | /**
  17 |     |  * @title DynamicImpactCredit
  18 |     |  * @author Genci Mehmeti
  19 |     |  * @dev An ERC1155 token contract for creating dynamic environmental assets.
  20 |     |  * Each `tokenId`, derived from a `projectId`, represents a unique class of impact credit.
  21 |     |  * The contract stores a history of metadata URIs for each token, allowing its
  22 |     |  * attributes to evolve as new dMRV data is verified. Minting is restricted to
  23 |     |  * the `DMRVManager` contract, ensuring credits are only created based on validated impact.
  24 |     |  * It is upgradeable using the UUPS pattern.
  25 |     |  */
  26 | *   | contract DynamicImpactCredit is ERC1155Upgradeable, AccessControlUpgradeable, UUPSUpgradeable, PausableUpgradeable {
  27 | *   |     bytes32 public constant DMRV_MANAGER_ROLE = keccak256("DMRV_MANAGER_ROLE");
  28 | *   |     bytes32 public constant METADATA_UPDATER_ROLE = keccak256("METADATA_UPDATER_ROLE");
  29 | *   |     bytes32 public constant PAUSER_ROLE = keccak256("PAUSER_ROLE");
  30 |     | 
  31 |     |     bytes32[] private _roles;
  32 |     | 
  33 |     |     mapping(uint256 => string[]) private _tokenURIs;
  34 |     |     string private _contractURI;
  35 |     |     IProjectRegistry public immutable projectRegistry;
  36 |     | 
  37 |     |     uint256[50] private __gap;
  38 |     | 
  39 |     |     // --- Events ---
  40 |     |     event ContractURIUpdated(string newURI);
  41 |     |     event CreditsRetired(address indexed retirer, uint256 indexed tokenId, uint256 amount);
  42 |     | 
  43 |     |     /// @custom:oz-upgrades-unsafe-allow constructor
  44 | *   |     constructor(address projectRegistry_) {
  45 | *   |         if (projectRegistry_ == address(0)) revert("Zero address not allowed");
  46 | *   |         projectRegistry = IProjectRegistry(projectRegistry_);
  47 | *   |         _disableInitializers(); // protect the impl
  48 |     |     }
  49 |     | 
  50 |     |     /**
  51 |     |      * @notice Initializes the contract, setting the contract URI and dependent contracts.
  52 |     |      * @dev Sets up roles and contract dependencies. The deployer is granted `DEFAULT_ADMIN_ROLE`
  53 |     |      * and `PAUSER_ROLE`. In a production environment, the other roles (`DMRV_MANAGER_ROLE`,
  54 |     |      * `METADATA_UPDATER_ROLE`) must be granted to their respective contracts.
  55 |     |      * @param contractURI_ The URI for the contract-level metadata.
  56 |     |      */
  57 | *   |     function initialize(string memory contractURI_) public initializer {
  58 | *   |         __ERC1155_init(""); // base URI empty  each token has its own
  59 | *   |         __AccessControl_init();
  60 | *   |         __UUPSUpgradeable_init();
  61 | *   |         __Pausable_init();
  62 |     | 
  63 | *   |         _grantRole(DEFAULT_ADMIN_ROLE, _msgSender()); // This is required to make the initializer the admin.
  64 | *   |         _grantRole(PAUSER_ROLE, _msgSender());
  65 | *   |         _contractURI = contractURI_;
  66 |     | 
  67 | *   |         _roles.push(DEFAULT_ADMIN_ROLE);
  68 | *   |         _roles.push(DMRV_MANAGER_ROLE);
  69 | *   |         _roles.push(METADATA_UPDATER_ROLE);
  70 | *   |         _roles.push(PAUSER_ROLE);
  71 |     |     }
  72 |     | 
  73 |     |     /**
  74 |     |      * @notice Mints a new batch of impact credits for a verified project.
  75 |     |      * @dev Can only be called by an address with `DMRV_MANAGER_ROLE`. The `tokenId` is the `uint256`
  76 |     |      * cast of the `projectId`. This function adds the new metadata URI to the token's history.
  77 |     |      * The project must be `Active` in the `ProjectRegistry`.
  78 |     |      * @param to The address to receive the new credits.
  79 |     |      * @param projectId The project ID, used to derive the `tokenId`.
  80 |     |      * @param amount The quantity of credits to mint.
  81 |     |      * @param newUri The new metadata URI for this batch, pointing to dMRV data.
  82 |     |      */
  83 | *   |     function mintCredits(address to, bytes32 projectId, uint256 amount, string calldata newUri)
  84 |     |         external
  85 |     |         onlyRole(DMRV_MANAGER_ROLE)
  86 |     |         whenNotPaused
  87 | *   |     {
  88 | *   |         if (!projectRegistry.isProjectActive(projectId)) revert DynamicImpactCredit__ProjectNotActive();
  89 |     | 
  90 | *   |         uint256 tokenId = uint256(projectId);
  91 | *   |         _mint(to, tokenId, amount, "");
  92 |     | 
  93 |     |         // Always update the URI by pushing to the history array
  94 | *   |         _tokenURIs[tokenId].push(newUri);
  95 |     | 
  96 | *   |         emit URI(newUri, tokenId);
  97 |     |     }
  98 |     | 
  99 |     |     /**
 100 |     |      * @notice Updates a token's metadata by adding a new URI to its history.
 101 |     |      * @dev Can only be called by an address with `METADATA_UPDATER_ROLE`. This allows for
 102 |     |      * impact data to be updated without minting new tokens. Emits a `URI` event.
 103 |     |      * @param id The project ID (`bytes32`) of the token to update.
 104 |     |      * @param newUri The new metadata URI to add to the token's history.
 105 |     |      */
 106 |     |     function setTokenURI(bytes32 id, string calldata newUri) external onlyRole(METADATA_UPDATER_ROLE) whenNotPaused {
 107 |     |         uint256 tokenId = uint256(id);
 108 |     |         _tokenURIs[tokenId].push(newUri);
 109 |     |         emit URI(newUri, tokenId);
 110 |     |     }
 111 |     | 
 112 |     |     /**
 113 |     |      * @notice Returns the latest metadata URI for a given token ID.
 114 |     |      * @dev This points to the most up-to-date off-chain metadata JSON. The token must exist.
 115 |     |      * @param id The token ID to query.
 116 |     |      * @return The latest metadata URI string.
 117 |     |      */
 118 |     |     function uri(uint256 id) public view override returns (string memory) {
 119 |     |         string[] storage uris = _tokenURIs[id];
 120 |     |         if (uris.length == 0) revert DynamicImpactCredit__URINotSet();
 121 |     |         return uris[uris.length - 1];
 122 |     |     }
 123 |     | 
 124 |     |     /**
 125 |     |      * @notice Retrieves the entire history of metadata URIs for a token.
 126 |     |      * @dev Provides a transparent, on-chain audit trail of all changes to a token's
 127 |     |      * verified data.
 128 |     |      * @param id The token ID to query.
 129 |     |      * @return An array of all historical metadata URI strings.
 130 |     |      */
 131 |     |     function getTokenURIHistory(uint256 id) public view returns (string[] memory) {
 132 |     |         return _tokenURIs[id];
 133 |     |     }
 134 |     | 
 135 |     |     /**
 136 |     |      * @notice Retires (burns) a specified amount of credits from an owner's balance.
 137 |     |      * @dev Any credit holder can call this to permanently retire their assets, preventing re-sale
 138 |     |      * and "double counting" of the environmental claim. The caller must be the owner of the tokens
 139 |     |      * or be approved to manage them. Emits a `CreditsRetired` event.
 140 |     |      * @param from The address of the credit holder.
 141 |     |      * @param id The project ID (`bytes32`) of the credits to retire.
 142 |     |      * @param amount The quantity of credits to retire.
 143 |     |      */
 144 | *   |     function retire(address from, bytes32 id, uint256 amount) public virtual whenNotPaused {
 145 |     |         if (from != _msgSender() && !isApprovedForAll(from, _msgSender())) revert DynamicImpactCredit__NotAuthorized();
 146 |     |         uint256 tokenId = uint256(id);
 147 |     |         _burn(from, tokenId, amount);
 148 | *   |         emit CreditsRetired(_msgSender(), tokenId, amount);
 149 |     |     }
 150 |     | 
 151 |     |     /**
 152 |     |      * @notice Gets all the roles held by a specific account.
 153 |     |      * @dev Provides an easy way for UIs and other tools to check permissions.
 154 |     |      * @param account The address to check.
 155 |     |      * @return A list of role identifiers held by the account.
 156 |     |      */
 157 |     |     function getRoles(address account) external view returns (bytes32[] memory) {
 158 |     |         uint256 count = 0;
 159 |     |         for (uint256 i = 0; i < _roles.length; i++) {
 160 |     |             if (hasRole(_roles[i], account)) {
 161 |     |                 count++;
 162 |     |             }
 163 |     |         }
 164 |     | 
 165 |     |         bytes32[] memory roles = new bytes32[](count);
 166 |     |         uint256 index = 0;
 167 |     |         for (uint256 i = 0; i < _roles.length; i++) {
 168 |     |             if (hasRole(_roles[i], account)) {
 169 |     |                 roles[index++] = _roles[i];
 170 |     |             }
 171 |     |         }
 172 |     |         return roles;
 173 |     |     }
 174 |     | 
 175 |     |     /**
 176 |     |      * @notice Returns the contract-level metadata URI.
 177 |     |      * @dev This URI points to a JSON file that describes the contract, following the ERC-1155 metadata standard.
 178 |     |      */
 179 |     |     function contractURI() external view returns (string memory) {
 180 |     |         return _contractURI;
 181 |     |     }
 182 |     | 
 183 |     |     /**
 184 |     |      * @notice Updates the contract-level metadata URI.
 185 |     |      * @dev Can only be called by an address with the `DEFAULT_ADMIN_ROLE`.
 186 |     |      * Emits a `ContractURIUpdated` event.
 187 |     |      * @param newUri The new contract-level URI.
 188 |     |      */
 189 |     |     function setContractURI(string calldata newUri) external onlyRole(DEFAULT_ADMIN_ROLE) {
 190 |     |         _contractURI = newUri;
 191 |     |         emit ContractURIUpdated(newUri);
 192 |     |     }
 193 |     | 
 194 |     |     /**
 195 |     |      * @notice Pauses all state-changing functions in the contract.
 196 |     |      * @dev Can only be called by an address with the `PAUSER_ROLE`.
 197 |     |      * This is a critical safety feature to halt activity in case of an emergency.
 198 |     |      * Emits a `Paused` event.
 199 |     |      */
 200 |     |     function pause() external onlyRole(PAUSER_ROLE) {
 201 |     |         _pause();
 202 |     |     }
 203 |     | 
 204 |     |     /**
 205 |     |      * @notice Lifts the pause on the contract, resuming normal operations.
 206 |     |      * @dev Can only be called by an address with the `PAUSER_ROLE`.
 207 |     |      * Emits an `Unpaused` event.
 208 |     |      */
 209 | *   |     function unpause() external onlyRole(PAUSER_ROLE) {
 210 | *   |         _unpause();
 211 |     |     }
 212 |     | 
 213 |     |     /* ---------- upgrade auth ---------- */
 214 |     |     function _authorizeUpgrade(address /* newImpl */ ) internal virtual override onlyRole(DEFAULT_ADMIN_ROLE) {}
 215 |     | 
 216 |     |     /* ---------- interface fan-in ---------- */
 217 |     |     function supportsInterface(bytes4 interfaceId)
 218 |     |         public
 219 |     |         view
 220 |     |         override(ERC1155Upgradeable, AccessControlUpgradeable)
 221 |     |         returns (bool)
 222 |     |     {
 223 |     |         return super.supportsInterface(interfaceId);
 224 |     |     }
 225 |     | 
 226 |     |     /**
 227 |     |      * @notice Mints multiple batches of impact credits.
 228 |     |      * @dev A gas-efficient alternative to `mintCredits` for minting credits for multiple projects
 229 |     |      * at once. Can only be called by an address with `DMRV_MANAGER_ROLE`. All projects must be active.
 230 |     |      * @param to The address to receive all the new credits.
 231 |     |      * @param ids An array of project IDs.
 232 |     |      * @param amounts An array of amounts to mint for each corresponding project ID.
 233 |     |      * @param uris An array of initial metadata URIs for each corresponding project ID.
 234 |     |      */
 235 |     |     function batchMintCredits(
 236 |     |         address to,
 237 |     |         bytes32[] calldata ids,
 238 |     |         uint256[] calldata amounts,
 239 |     |         string[] calldata uris // 1-to-1 with ids
 240 |     |     ) external onlyRole(DMRV_MANAGER_ROLE) whenNotPaused {
 241 |     |         if (ids.length != amounts.length || ids.length != uris.length) revert DynamicImpactCredit__LengthMismatch();
 242 |     | 
 243 |     |         uint256[] memory tokenIds = new uint256[](ids.length);
 244 |     |         for (uint256 i = 0; i < ids.length;) {
 245 |     |             if (!projectRegistry.isProjectActive(ids[i])) revert DynamicImpactCredit__ProjectNotActive();
 246 |     |             tokenIds[i] = uint256(ids[i]);
 247 |     |             unchecked {
 248 |     |                 ++i;
 249 |     |             }
 250 |     |         }
 251 |     | 
 252 |     |         _mintBatch(to, tokenIds, amounts, "");
 253 |     | 
 254 |     |         for (uint256 i = 0; i < ids.length;) {
 255 |     |             // Only add the URI if it's the very first mint for that token
 256 |     |             if (_tokenURIs[tokenIds[i]].length == 0) {
 257 |     |                 _tokenURIs[tokenIds[i]].push(uris[i]);
 258 |     |                 emit URI(uris[i], tokenIds[i]);
 259 |     |             }
 260 |     |             unchecked {
 261 |     |                 ++i;
 262 |     |             }
 263 |     |         }
 264 |     |     }
 265 |     | }
 266 |     | 

/home/phantom/Documents/azemora/azemora-contracts/src/core/ProjectRegistry.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | pragma solidity ^0.8.20;
   3 |     | 
   4 |     | import "@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol";
   5 |     | import "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";
   6 |     | import "@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol";
   7 |     | import "@openzeppelin/contracts-upgradeable/utils/ReentrancyGuardUpgradeable.sol";
   8 |     | import "@openzeppelin/contracts-upgradeable/utils/PausableUpgradeable.sol";
   9 |     | 
  10 |     | /**
  11 |     |  * @title IProjectRegistry
  12 |     |  * @dev Interface for the ProjectRegistry contract.
  13 |     |  * Allows other contracts to securely interact with the registry to verify project status.
  14 |     |  */
  15 |     | interface IProjectRegistry {
  16 |     |     function isProjectActive(bytes32 projectId) external view returns (bool);
  17 |     | }
  18 |     | 
  19 |     | // --- Custom Errors ---
  20 |     | error ProjectRegistry__IdAlreadyExists();
  21 |     | error ProjectRegistry__ProjectNotFound();
  22 |     | error ProjectRegistry__StatusIsSame();
  23 |     | error ProjectRegistry__ArchivedProjectCannotBeModified();
  24 |     | error ProjectRegistry__CallerNotVerifier();
  25 |     | error ProjectRegistry__InvalidActivationState();
  26 |     | error ProjectRegistry__CallerNotAdmin();
  27 |     | error ProjectRegistry__InvalidPauseState();
  28 |     | error ProjectRegistry__InvalidStatusTransition();
  29 |     | error ProjectRegistry__NotProjectOwner();
  30 |     | error ProjectRegistry__NewOwnerIsZeroAddress();
  31 |     | 
  32 |     | /**
  33 |     |  * @title ProjectRegistry
  34 |     |  * @author Genci Mehmeti
  35 |     |  * @dev Manages the registration and lifecycle of climate action projects.
  36 |     |  * This contract serves as the on-chain registry, ensuring that environmental assets
  37 |     |  * can only be minted for valid, recognized projects. It uses UUPS for upgradeability
  38 |     |  * and AccessControl for role-based permissions, allowing for permissionless registration
  39 |     |  * with a subsequent verification step.
  40 |     |  */
  41 | *   | contract ProjectRegistry is
  42 |     |     Initializable,
  43 |     |     AccessControlUpgradeable,
  44 |     |     UUPSUpgradeable,
  45 |     |     ReentrancyGuardUpgradeable,
  46 |     |     PausableUpgradeable
  47 |     | {
  48 | *   |     bytes32 public constant VERIFIER_ROLE = keccak256("VERIFIER_ROLE");
  49 | *   |     bytes32 public constant PAUSER_ROLE = keccak256("PAUSER_ROLE");
  50 |     | 
  51 |     |     bytes32[] private _roles;
  52 |     | 
  53 |     |     enum ProjectStatus {
  54 |     |         Pending, // Newly registered, awaiting verification
  55 |     |         Active, // Verified and eligible for credit minting
  56 |     |         Paused, // Temporarily suspended by admin
  57 |     |         Archived // Permanently archived, not active
  58 |     | 
  59 |     |     }
  60 |     | 
  61 |     |     struct Project {
  62 |     |         bytes32 id;
  63 |     |         string metaURI; // URI to off-chain JSON metadata (IPFS)
  64 |     |         // --- Packed for gas efficiency ---
  65 |     |         address owner; // 20 bytes
  66 |     |         ProjectStatus status; // 1 byte
  67 |     |     }
  68 |     | 
  69 |     |     mapping(bytes32 => Project) private _projects;
  70 |     | 
  71 |     |     uint256[50] private __gap;
  72 |     | 
  73 |     |     // --- Events ---
  74 |     | 
  75 |     |     event ProjectRegistered(bytes32 indexed projectId, address indexed owner, string metaURI);
  76 |     |     event ProjectStatusChanged(bytes32 indexed projectId, ProjectStatus oldStatus, ProjectStatus newStatus);
  77 |     |     event ProjectMetaURIUpdated(bytes32 indexed projectId, string newMetaURI);
  78 |     |     event ProjectOwnershipTransferred(bytes32 indexed projectId, address indexed oldOwner, address indexed newOwner);
  79 |     | 
  80 |     |     /// @custom:oz-upgrades-unsafe-allow constructor
  81 | *   |     constructor() {
  82 | *   |         _disableInitializers();
  83 |     |     }
  84 |     | 
  85 |     |     /**
  86 |     |      * @notice Initializes the contract, setting up roles and pausable state.
  87 |     |      * @dev The deployer is granted the `DEFAULT_ADMIN_ROLE`, `VERIFIER_ROLE`, and `PAUSER_ROLE`.
  88 |     |      * This function should only be called once on the implementation contract, and it is automatically
  89 |     |      * called by the proxy constructor during deployment.
  90 |     |      */
  91 | *   |     function initialize() public initializer {
  92 | *   |         __AccessControl_init();
  93 | *   |         __UUPSUpgradeable_init();
  94 | *   |         __ReentrancyGuard_init();
  95 | *   |         __Pausable_init();
  96 |     | 
  97 | *   |         _grantRole(DEFAULT_ADMIN_ROLE, _msgSender());
  98 | *   |         _grantRole(VERIFIER_ROLE, _msgSender());
  99 | *   |         _grantRole(PAUSER_ROLE, _msgSender());
 100 |     | 
 101 | *   |         _roles.push(DEFAULT_ADMIN_ROLE);
 102 | *   |         _roles.push(VERIFIER_ROLE);
 103 | *   |         _roles.push(PAUSER_ROLE);
 104 |     |     }
 105 |     | 
 106 |     |     // --- State-Changing Functions ---
 107 |     | 
 108 |     |     /**
 109 |     |      * @notice Registers a new project, making it known to the Azemora platform.
 110 |     |      * @dev Anyone can register a project. The caller becomes the initial owner. The project starts
 111 |     |      * in the `Pending` state and must be moved to `Active` by a `VERIFIER_ROLE` holder
 112 |     |      * before any actions can be taken on it. The `projectId` should be a unique identifier,
 113 |     |      * typically a keccak256 hash of key project details to prevent collisions.
 114 |     |      * @param projectId The unique identifier for the project.
 115 |     |      * @param metaURI A URI pointing to an off-chain JSON file (e.g., on IPFS) with project details.
 116 |     |      */
 117 | *   |     function registerProject(bytes32 projectId, string calldata metaURI) external nonReentrant whenNotPaused {
 118 | *   |         if (_projects[projectId].id != 0) revert ProjectRegistry__IdAlreadyExists();
 119 |     | 
 120 | *   |         _projects[projectId] =
 121 | *   |             Project({id: projectId, metaURI: metaURI, owner: _msgSender(), status: ProjectStatus.Pending});
 122 |     | 
 123 | *   |         emit ProjectRegistered(projectId, _msgSender(), metaURI);
 124 |     |     }
 125 |     | 
 126 |     |     /**
 127 |     |      * @notice Updates the status of an existing project (e.g., to activate, pause, or archive it).
 128 |     |      * @dev This is a privileged action.
 129 |     |      * - A `VERIFIER_ROLE` holder can move a project to `Active`.
 130 |     |      * - A `DEFAULT_ADMIN_ROLE` holder can `Pause` or `Archive` a project.
 131 |     |      * Status transitions are restricted to logical paths (e.g., you cannot activate an archived project).
 132 |     |      * @param projectId The ID of the project to update.
 133 |     |      * @param newStatus The new status for the project.
 134 |     |      */
 135 | *   |     function setProjectStatus(bytes32 projectId, ProjectStatus newStatus) external nonReentrant whenNotPaused {
 136 | *   |         Project storage project = _projects[projectId];
 137 | *   |         ProjectStatus oldStatus = project.status;
 138 |     | 
 139 | *   |         if (project.id == 0) revert ProjectRegistry__ProjectNotFound();
 140 | *   |         if (oldStatus == newStatus) revert ProjectRegistry__StatusIsSame();
 141 | *   |         if (oldStatus == ProjectStatus.Archived) revert ProjectRegistry__ArchivedProjectCannotBeModified();
 142 |     | 
 143 | *   |         if (newStatus == ProjectStatus.Active) {
 144 | *   |             if (!hasRole(VERIFIER_ROLE, _msgSender())) revert ProjectRegistry__CallerNotVerifier();
 145 | *   |             if (oldStatus != ProjectStatus.Pending && oldStatus != ProjectStatus.Paused) {
 146 |     |                 revert ProjectRegistry__InvalidActivationState();
 147 |     |             }
 148 |     |         } else if (newStatus == ProjectStatus.Paused) {
 149 |     |             if (!hasRole(DEFAULT_ADMIN_ROLE, _msgSender())) revert ProjectRegistry__CallerNotAdmin();
 150 |     |             if (oldStatus != ProjectStatus.Active) revert ProjectRegistry__InvalidPauseState();
 151 | *   |         } else if (newStatus == ProjectStatus.Archived) {
 152 |     |             if (!hasRole(DEFAULT_ADMIN_ROLE, _msgSender())) revert ProjectRegistry__CallerNotAdmin();
 153 |     |             // Any non-archived state can be archived. The initial checks are sufficient.
 154 |     |         } else {
 155 |     |             // This case should be unreachable if all statuses are handled above.
 156 |     |             // It prevents transitioning to an undefined status.
 157 |     |             revert ProjectRegistry__InvalidStatusTransition();
 158 |     |         }
 159 |     | 
 160 | *   |         emit ProjectStatusChanged(projectId, oldStatus, newStatus);
 161 | *   |         project.status = newStatus;
 162 |     |     }
 163 |     | 
 164 |     |     /**
 165 |     |      * @notice Allows the project owner to update the project's metadata URI.
 166 |     |      * @dev The caller must be the current owner of the project. The URI should point to a valid
 167 |     |      * JSON metadata file, typically hosted on a decentralized storage system like IPFS.
 168 |     |      * @param projectId The ID of the project to update.
 169 |     |      * @param newMetaURI The new metadata URI.
 170 |     |      */
 171 | *   |     function setProjectMetaURI(bytes32 projectId, string calldata newMetaURI) external nonReentrant whenNotPaused {
 172 |     |         _checkProjectOwner(projectId);
 173 |     |         _projects[projectId].metaURI = newMetaURI;
 174 |     |         emit ProjectMetaURIUpdated(projectId, newMetaURI);
 175 |     |     }
 176 |     | 
 177 |     |     /**
 178 |     |      * @notice Allows the current project owner to transfer project ownership to a new address.
 179 |     |      * @dev The caller must be the current owner. Ownership cannot be transferred to the zero address.
 180 |     |      * The new owner will have the authority to update the project's metadata URI and perform other
 181 |     |      * owner-specific actions in the future.
 182 |     |      * @param projectId The ID of the project being transferred.
 183 |     |      * @param newOwner The address of the new owner.
 184 |     |      */
 185 |     |     function transferProjectOwnership(bytes32 projectId, address newOwner) external nonReentrant whenNotPaused {
 186 |     |         _checkProjectOwner(projectId);
 187 |     |         if (newOwner == address(0)) revert ProjectRegistry__NewOwnerIsZeroAddress();
 188 |     | 
 189 |     |         address oldOwner = _projects[projectId].owner;
 190 |     |         _projects[projectId].owner = newOwner;
 191 |     |         emit ProjectOwnershipTransferred(projectId, oldOwner, newOwner);
 192 |     |     }
 193 |     | 
 194 |     |     // --- View Functions ---
 195 |     | 
 196 |     |     /**
 197 |     |      * @notice Retrieves the full data for a given project.
 198 |     |      * @param projectId The ID of the project.
 199 |     |      * @return A Project struct containing all project data.
 200 |     |      */
 201 |     |     function getProject(bytes32 projectId) external view returns (Project memory) {
 202 |     |         if (_projects[projectId].id == 0) revert ProjectRegistry__ProjectNotFound();
 203 |     |         return _projects[projectId];
 204 |     |     }
 205 |     | 
 206 |     |     /**
 207 |     |      * @notice Checks if a project is currently active.
 208 |     |      * @dev This is the primary view function for other contracts (like the NFT contract)
 209 |     |      * to verify a project's eligibility for minting.
 210 |     |      * @param projectId The ID of the project to check.
 211 |     |      * @return True if the project's status is Active, false otherwise.
 212 |     |      */
 213 | *   |     function isProjectActive(bytes32 projectId) public view returns (bool) {
 214 | *   |         return _projects[projectId].status == ProjectStatus.Active;
 215 |     |     }
 216 |     | 
 217 |     |     /**
 218 |     |      * @notice Gets all the roles held by a specific account.
 219 |     |      * @dev Provides an easy way for UIs and other tools to check permissions.
 220 |     |      * @param account The address to check.
 221 |     |      * @return A list of role identifiers held by the account.
 222 |     |      */
 223 |     |     function getRoles(address account) external view returns (bytes32[] memory) {
 224 |     |         uint256 count = 0;
 225 |     |         for (uint256 i = 0; i < _roles.length; i++) {
 226 |     |             if (hasRole(_roles[i], account)) {
 227 |     |                 count++;
 228 |     |             }
 229 |     |         }
 230 |     | 
 231 |     |         bytes32[] memory roles = new bytes32[](count);
 232 |     |         uint256 index = 0;
 233 |     |         for (uint256 i = 0; i < _roles.length; i++) {
 234 |     |             if (hasRole(_roles[i], account)) {
 235 |     |                 roles[index++] = _roles[i];
 236 |     |             }
 237 |     |         }
 238 |     |         return roles;
 239 |     |     }
 240 |     | 
 241 |     |     /**
 242 |     |      * @notice Pauses all state-changing functions in the contract.
 243 |     |      * @dev Can only be called by an address with the `PAUSER_ROLE`.
 244 |     |      * This is a critical safety feature to halt activity in case of an emergency.
 245 |     |      * Emits a `Paused` event.
 246 |     |      */
 247 |     |     function pause() external onlyRole(PAUSER_ROLE) {
 248 |     |         _pause();
 249 |     |     }
 250 |     | 
 251 |     |     /**
 252 |     |      * @notice Lifts the pause on the contract, resuming normal operations.
 253 |     |      * @dev Can only be called by an address with the `PAUSER_ROLE`.
 254 |     |      * Emits an `Unpaused` event.
 255 |     |      */
 256 | *   |     function unpause() external onlyRole(PAUSER_ROLE) {
 257 | *   |         _unpause();
 258 |     |     }
 259 |     | 
 260 |     |     // --- Internal & Auth Functions ---
 261 |     | 
 262 |     |     /**
 263 |     |      * @dev Reverts if the caller is not the owner of the specified project.
 264 |     |      */
 265 |     |     function _checkProjectOwner(bytes32 projectId) internal view {
 266 |     |         if (_projects[projectId].id == 0) revert ProjectRegistry__ProjectNotFound();
 267 |     |         if (_projects[projectId].owner != _msgSender()) revert ProjectRegistry__NotProjectOwner();
 268 |     |     }
 269 |     | 
 270 |     |     function _authorizeUpgrade(address newImplementation) internal override onlyRole(DEFAULT_ADMIN_ROLE) {}
 271 |     | 
 272 | *   |     function supportsInterface(bytes4 interfaceId) public view override(AccessControlUpgradeable) returns (bool) {
 273 | *   |         return interfaceId == type(IProjectRegistry).interfaceId || super.supportsInterface(interfaceId);
 274 |     |     }
 275 |     | }
 276 |     | 

/home/phantom/Documents/azemora/azemora-contracts/src/core/dMRVManager.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | pragma solidity ^0.8.20;
   3 |     | 
   4 |     | import "@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol";
   5 |     | import "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";
   6 |     | import "@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol";
   7 |     | import "@openzeppelin/contracts-upgradeable/utils/ReentrancyGuardUpgradeable.sol";
   8 |     | import "@openzeppelin/contracts-upgradeable/utils/PausableUpgradeable.sol";
   9 |     | import "./ProjectRegistry.sol";
  10 |     | import "./DynamicImpactCredit.sol";
  11 |     | 
  12 |     | // --- Custom Errors ---
  13 |     | error DMRVManager__ProjectNotActive();
  14 |     | error DMRVManager__RequestNotFound();
  15 |     | error DMRVManager__RequestAlreadyFulfilled();
  16 |     | 
  17 |     | /**
  18 |     |  * @title DMRVManager
  19 |     |  * @author Genci Mehmeti
  20 |     |  * @dev Manages the retrieval and processing of digital Monitoring, Reporting, and
  21 |     |  * Verification (dMRV) data. This contract acts as the bridge between off-chain
  22 |     |  * data sources (oracles) and the on-chain minting of `DynamicImpactCredit` tokens,
  23 |     |  * ensuring that only verified environmental impact results in token creation.
  24 |     |  * It is upgradeable using the UUPS pattern.
  25 |     |  */
  26 |     | contract DMRVManager is
  27 |     |     Initializable,
  28 |     |     AccessControlUpgradeable,
  29 |     |     UUPSUpgradeable,
  30 |     |     ReentrancyGuardUpgradeable,
  31 |     |     PausableUpgradeable
  32 |     | {
  33 |     |     // --- Roles ---
  34 |     |     bytes32 public constant ORACLE_ROLE = keccak256("ORACLE_ROLE");
  35 |     |     bytes32 public constant PAUSER_ROLE = keccak256("PAUSER_ROLE");
  36 |     | 
  37 |     |     bytes32[] private _roles;
  38 |     | 
  39 |     |     // --- State variables ---
  40 |     |     ProjectRegistry public immutable projectRegistry;
  41 |     |     DynamicImpactCredit public immutable creditContract;
  42 |     | 
  43 |     |     // Mapping to track verification requests by request ID
  44 |     |     mapping(bytes32 => VerificationRequest) private _requests;
  45 |     | 
  46 |     |     uint256[50] private __gap;
  47 |     | 
  48 |     |     // Structure for tracking verification requests
  49 |     |     // Struct is packed to save gas on storage.
  50 |     |     struct VerificationRequest {
  51 |     |         bytes32 projectId; // 32 bytes - Slot 0
  52 |     |         // --- Packed into a single 32-byte slot (Slot 1) ---
  53 |     |         address requestor; // 20 bytes
  54 |     |         uint64 timestamp; // 8 bytes
  55 |     |         bool fulfilled; // 1 byte
  56 |     |     }
  57 |     | 
  58 |     |     // Structure for representing parsed verification data
  59 |     |     struct VerificationData {
  60 |     |         uint256 creditAmount;
  61 |     |         string metadataURI;
  62 |     |         bool updateMetadataOnly;
  63 |     |         bytes32 signature; // For validating that data came from an authorized source
  64 |     |     }
  65 |     | 
  66 |     |     // --- Events ---
  67 |     |     event VerificationRequested(bytes32 indexed requestId, bytes32 indexed projectId, address indexed requestor);
  68 |     |     event VerificationFulfilled(bytes32 indexed requestId, bytes32 indexed projectId, uint256 creditAmount);
  69 |     |     event AdminVerificationSubmitted(
  70 |     |         bytes32 indexed projectId, uint256 creditAmount, string metadataURI, bool updateMetadataOnly
  71 |     |     );
  72 |     |     event MetadataUpdated(bytes32 indexed projectId, string newURI);
  73 |     |     event CreditsMinted(bytes32 indexed projectId, address indexed owner, uint256 amount);
  74 |     |     event MissingProjectError(bytes32 indexed projectId);
  75 |     | 
  76 |     |     /// @custom:oz-upgrades-unsafe-allow constructor
  77 |     |     constructor(address projectRegistry_, address creditContract_) {
  78 |     |         if (projectRegistry_ == address(0) || creditContract_ == address(0)) {
  79 |     |             revert("Zero address not allowed");
  80 |     |         }
  81 |     |         projectRegistry = ProjectRegistry(projectRegistry_);
  82 |     |         creditContract = DynamicImpactCredit(creditContract_);
  83 |     |         _disableInitializers();
  84 |     |     }
  85 |     | 
  86 |     |     /**
  87 |     |      * @notice Initializes the contract with dependent contract addresses.
  88 |     |      * @dev Sets up roles and contract dependencies. The deployer is granted `DEFAULT_ADMIN_ROLE`,
  89 |     |      * `ORACLE_ROLE`, and `PAUSER_ROLE`. In a production environment, the `ORACLE_ROLE` would be
  90 |     |      * transferred to trusted oracle contracts.
  91 |     |      */
  92 |     |     function initialize() public initializer {
  93 |     |         __AccessControl_init();
  94 |     |         __UUPSUpgradeable_init();
  95 |     |         __ReentrancyGuard_init();
  96 |     |         __Pausable_init();
  97 |     | 
  98 |     |         _grantRole(DEFAULT_ADMIN_ROLE, _msgSender());
  99 |     |         // In a real deployment, this would be set to trusted oracle addresses
 100 |     |         _grantRole(ORACLE_ROLE, _msgSender());
 101 |     |         _grantRole(PAUSER_ROLE, _msgSender());
 102 |     | 
 103 |     |         _roles.push(DEFAULT_ADMIN_ROLE);
 104 |     |         _roles.push(ORACLE_ROLE);
 105 |     |         _roles.push(PAUSER_ROLE);
 106 |     |     }
 107 |     | 
 108 |     |     /**
 109 |     |      * @notice Initiates a request for dMRV data from an oracle for a given project.
 110 |     |      * @dev Emits a `VerificationRequested` event. For the MVP, this simulates an oracle request by
 111 |     |      * creating a request entry. In a production environment, this function would be expanded to
 112 |     |      * make a direct call to a decentralized oracle network like Chainlink.
 113 |     |      * The project must be in the `Active` state.
 114 |     |      * @param projectId The unique identifier of the project to verify.
 115 |     |      * @return requestId A unique ID for the verification request.
 116 |     |      */
 117 |     |     function requestVerification(bytes32 projectId) external nonReentrant whenNotPaused returns (bytes32 requestId) {
 118 |     |         if (!projectRegistry.isProjectActive(projectId)) revert DMRVManager__ProjectNotActive();
 119 |     | 
 120 |     |         // For MVP: Generate a simple request ID.
 121 |     |         // In production, this would come from the Chainlink request.
 122 |     |         requestId = keccak256(abi.encodePacked(projectId, _msgSender(), block.timestamp));
 123 |     | 
 124 |     |         _requests[requestId] = VerificationRequest({
 125 |     |             projectId: projectId,
 126 |     |             requestor: _msgSender(),
 127 |     |             timestamp: uint64(block.timestamp),
 128 |     |             fulfilled: false
 129 |     |         });
 130 |     | 
 131 |     |         emit VerificationRequested(requestId, projectId, _msgSender());
 132 |     | 
 133 |     |         // In a real implementation, we'd make a Chainlink request here.
 134 |     |         // For MVP purposes, we're simulating the oracle callback.
 135 |     | 
 136 |     |         return requestId;
 137 |     |     }
 138 |     | 
 139 |     |     /**
 140 |     |      * @notice Callback function for oracles to deliver verified dMRV data.
 141 |     |      * @dev This is a privileged function that can only be called by addresses with the `ORACLE_ROLE`.
 142 |     |      * It marks the request as fulfilled and processes the incoming data to mint new impact credit tokens
 143 |     |      * or update the metadata of existing ones. Emits a `VerificationFulfilled` event.
 144 |     |      * @param requestId The ID of the verification request being fulfilled.
 145 |     |      * @param data The raw, encoded verification data from the dMRV system.
 146 |     |      */
 147 |     |     function fulfillVerification(bytes32 requestId, bytes calldata data)
 148 |     |         external
 149 |     |         onlyRole(ORACLE_ROLE)
 150 |     |         nonReentrant
 151 |     |         whenNotPaused
 152 |     |     {
 153 |     |         VerificationRequest storage request = _requests[requestId];
 154 |     |         if (request.timestamp == 0) revert DMRVManager__RequestNotFound();
 155 |     |         if (request.fulfilled) revert DMRVManager__RequestAlreadyFulfilled();
 156 |     | 
 157 |     |         request.fulfilled = true;
 158 |     | 
 159 |     |         // Process the verification data
 160 |     |         VerificationData memory vData = parseVerificationData(data);
 161 |     | 
 162 |     |         // Act based on the verification data
 163 |     |         processVerification(request.projectId, request.requestor, vData);
 164 |     | 
 165 |     |         emit VerificationFulfilled(requestId, request.projectId, vData.creditAmount);
 166 |     |     }
 167 |     | 
 168 |     |     /**
 169 |     |      * @dev Internal function to process verified dMRV data. It either mints new
 170 |     |      * credits to the project owner or updates the metadata URI of the associated token.
 171 |     |      * @param projectId The project identifier.
 172 |     |      * @param data The parsed verification data.
 173 |     |      */
 174 |     |     function processVerification(bytes32 projectId, address, /* requestor */ VerificationData memory data) internal {
 175 |     |         if (data.updateMetadataOnly) {
 176 |     |             // Update metadata only
 177 |     |             creditContract.setTokenURI(projectId, data.metadataURI);
 178 |     |             emit MetadataUpdated(projectId, data.metadataURI);
 179 |     |         } else if (data.creditAmount > 0) {
 180 |     |             // Get project owner from registry to mint credits to them
 181 |     |             try projectRegistry.getProject(projectId) returns (ProjectRegistry.Project memory project) {
 182 |     |                 // Mint new credits to the project owner
 183 |     |                 creditContract.mintCredits(project.owner, projectId, data.creditAmount, data.metadataURI);
 184 |     |                 emit CreditsMinted(projectId, project.owner, data.creditAmount);
 185 |     |             } catch {
 186 |     |                 emit MissingProjectError(projectId);
 187 |     |             }
 188 |     |         }
 189 |     |     }
 190 |     | 
 191 |     |     /**
 192 |     |      * @dev Parses raw verification data from the oracle into a structured format.
 193 |     |      * @param data The raw byte data from the oracle.
 194 |     |      * @return A `VerificationData` struct.
 195 |     |      */
 196 |     |     function parseVerificationData(bytes calldata data) internal pure returns (VerificationData memory) {
 197 |     |         // A more robust decoding scheme.
 198 |     |         (uint256 creditAmount, bool updateMetadataOnly, bytes32 signature, string memory metadataURI) =
 199 |     |             abi.decode(data, (uint256, bool, bytes32, string));
 200 |     | 
 201 |     |         return VerificationData({
 202 |     |             creditAmount: creditAmount,
 203 |     |             metadataURI: metadataURI,
 204 |     |             updateMetadataOnly: updateMetadataOnly,
 205 |     |             signature: signature
 206 |     |         });
 207 |     |     }
 208 |     | 
 209 |     |     /**
 210 |     |      * @notice Admin function to manually submit verification data, bypassing the oracle.
 211 |     |      * @dev This is a privileged function for `DEFAULT_ADMIN_ROLE` holders. It is intended for
 212 |     |      * testing, emergency interventions, or manual data entry. It directly calls the internal
 213 |     |      * processing logic. Emits an `AdminVerificationSubmitted` event.
 214 |     |      * @param projectId The project identifier.
 215 |     |      * @param creditAmount Amount of credits to mint (can be 0).
 216 |     |      * @param metadataURI The new metadata URI to set.
 217 |     |      * @param updateMetadataOnly If true, only updates metadata without minting.
 218 |     |      */
 219 |     |     function adminSubmitVerification(
 220 |     |         bytes32 projectId,
 221 |     |         uint256 creditAmount,
 222 |     |         string calldata metadataURI,
 223 |     |         bool updateMetadataOnly
 224 |     |     ) external onlyRole(DEFAULT_ADMIN_ROLE) nonReentrant whenNotPaused {
 225 |     |         if (!projectRegistry.isProjectActive(projectId)) revert DMRVManager__ProjectNotActive();
 226 |     | 
 227 |     |         VerificationData memory vData = VerificationData({
 228 |     |             creditAmount: creditAmount,
 229 |     |             metadataURI: metadataURI,
 230 |     |             updateMetadataOnly: updateMetadataOnly,
 231 |     |             signature: bytes32(0) // Not needed for admin functions
 232 |     |         });
 233 |     | 
 234 |     |         processVerification(projectId, _msgSender(), vData);
 235 |     |         emit AdminVerificationSubmitted(projectId, creditAmount, metadataURI, updateMetadataOnly);
 236 |     |     }
 237 |     | 
 238 |     |     /**
 239 |     |      * @notice Pauses all state-changing functions in the contract.
 240 |     |      * @dev Can only be called by an address with the `PAUSER_ROLE`.
 241 |     |      * This is a critical safety feature to halt activity in case of an emergency.
 242 |     |      * Emits a `Paused` event.
 243 |     |      */
 244 |     |     function pause() external onlyRole(PAUSER_ROLE) {
 245 |     |         _pause();
 246 |     |     }
 247 |     | 
 248 |     |     /**
 249 |     |      * @notice Lifts the pause on the contract, resuming normal operations.
 250 |     |      * @dev Can only be called by an address with the `PAUSER_ROLE`.
 251 |     |      * Emits an `Unpaused` event.
 252 |     |      */
 253 |     |     function unpause() external onlyRole(PAUSER_ROLE) {
 254 |     |         _unpause();
 255 |     |     }
 256 |     | 
 257 |     |     /* ---------- upgrade auth ---------- */
 258 |     |     function _authorizeUpgrade(address /* newImpl */ ) internal override onlyRole(DEFAULT_ADMIN_ROLE) {}
 259 |     | 
 260 |     |     /**
 261 |     |      * @notice Gets all the roles held by a specific account.
 262 |     |      * @dev Provides an easy way for UIs and other tools to check permissions.
 263 |     |      * @param account The address to check.
 264 |     |      * @return A list of role identifiers held by the account.
 265 |     |      */
 266 |     |     function getRoles(address account) external view returns (bytes32[] memory) {
 267 |     |         uint256 count = 0;
 268 |     |         for (uint256 i = 0; i < _roles.length; i++) {
 269 |     |             if (hasRole(_roles[i], account)) {
 270 |     |                 count++;
 271 |     |             }
 272 |     |         }
 273 |     | 
 274 |     |         bytes32[] memory roles = new bytes32[](count);
 275 |     |         uint256 index = 0;
 276 |     |         for (uint256 i = 0; i < _roles.length; i++) {
 277 |     |             if (hasRole(_roles[i], account)) {
 278 |     |                 roles[index++] = _roles[i];
 279 |     |             }
 280 |     |         }
 281 |     |         return roles;
 282 |     |     }
 283 |     | }
 284 |     | 

/home/phantom/Documents/azemora/azemora-contracts/src/governance/AzemoraGovernor.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | pragma solidity ^0.8.20;
   3 |     | 
   4 |     | import "@openzeppelin/contracts-upgradeable/governance/GovernorUpgradeable.sol";
   5 |     | import "@openzeppelin/contracts-upgradeable/governance/extensions/GovernorSettingsUpgradeable.sol";
   6 |     | import "@openzeppelin/contracts-upgradeable/governance/extensions/GovernorCountingSimpleUpgradeable.sol";
   7 |     | import "@openzeppelin/contracts-upgradeable/governance/extensions/GovernorVotesUpgradeable.sol";
   8 |     | import "@openzeppelin/contracts-upgradeable/governance/extensions/GovernorVotesQuorumFractionUpgradeable.sol";
   9 |     | import "@openzeppelin/contracts-upgradeable/governance/extensions/GovernorTimelockControlUpgradeable.sol";
  10 |     | import "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";
  11 |     | 
  12 |     | /**
  13 |     |  * @title AzemoraGovernor
  14 |     |  * @author Genci Mehmeti
  15 |     |  * @dev The governance contract for the Azemora platform.
  16 |     |  * It uses OpenZeppelin's Governor modules for voting, quorum, and timelock functionality.
  17 |     |  * The governor manages proposals and executes them via a TimelockController.
  18 |     |  * This version is optimized for size by removing UUPS and AccessControl.
  19 |     |  * Upgrades are managed by the Timelock.
  20 |     |  */
  21 |     | contract AzemoraGovernor is
  22 |     |     Initializable,
  23 |     |     GovernorUpgradeable,
  24 |     |     GovernorSettingsUpgradeable,
  25 |     |     GovernorCountingSimpleUpgradeable,
  26 |     |     GovernorVotesUpgradeable,
  27 |     |     GovernorVotesQuorumFractionUpgradeable,
  28 |     |     GovernorTimelockControlUpgradeable
  29 |     | {
  30 |     |     /// @custom:oz-upgrades-unsafe-allow constructor
  31 |     |     constructor() {
  32 |     |         _disableInitializers();
  33 |     |     }
  34 |     | 
  35 |     |     function initialize(
  36 |     |         IVotes token,
  37 |     |         TimelockControllerUpgradeable timelock,
  38 |     |         uint48 _votingDelay,
  39 |     |         uint32 _votingPeriod,
  40 |     |         uint256 _proposalThreshold
  41 |     |     ) public initializer {
  42 |     |         __Governor_init("AzemoraGovernor");
  43 |     |         __GovernorSettings_init(_votingDelay, _votingPeriod, _proposalThreshold);
  44 |     |         __GovernorVotes_init(token);
  45 |     |         __GovernorVotesQuorumFraction_init(4); // 4% quorum
  46 |     |         __GovernorTimelockControl_init(timelock);
  47 |     | 
  48 |     |         // The deployer is granted the proposer role by default,
  49 |     |         // and the timelock is granted the executor role.
  50 |     |         // The timelock admin is the governor itself.
  51 |     |     }
  52 |     | 
  53 |     |     // The following functions are overrides required by Solidity.
  54 |     | 
  55 |     |     function proposalNeedsQueuing(uint256 proposalId)
  56 |     |         public
  57 |     |         view
  58 |     |         override(GovernorUpgradeable, GovernorTimelockControlUpgradeable)
  59 |     |         returns (bool)
  60 |     |     {
  61 |     |         return super.proposalNeedsQueuing(proposalId);
  62 |     |     }
  63 |     | 
  64 |     |     function _queueOperations(
  65 |     |         uint256 proposalId,
  66 |     |         address[] memory targets,
  67 |     |         uint256[] memory values,
  68 |     |         bytes[] memory calldatas,
  69 |     |         bytes32 descriptionHash
  70 |     |     ) internal override(GovernorUpgradeable, GovernorTimelockControlUpgradeable) returns (uint48) {
  71 |     |         return super._queueOperations(proposalId, targets, values, calldatas, descriptionHash);
  72 |     |     }
  73 |     | 
  74 |     |     function _executeOperations(
  75 |     |         uint256 proposalId,
  76 |     |         address[] memory targets,
  77 |     |         uint256[] memory values,
  78 |     |         bytes[] memory calldatas,
  79 |     |         bytes32 descriptionHash
  80 |     |     ) internal override(GovernorUpgradeable, GovernorTimelockControlUpgradeable) {
  81 |     |         super._executeOperations(proposalId, targets, values, calldatas, descriptionHash);
  82 |     |     }
  83 |     | 
  84 |     |     function _cancel(
  85 |     |         address[] memory targets,
  86 |     |         uint256[] memory values,
  87 |     |         bytes[] memory calldatas,
  88 |     |         bytes32 descriptionHash
  89 |     |     ) internal override(GovernorUpgradeable, GovernorTimelockControlUpgradeable) returns (uint256) {
  90 |     |         return super._cancel(targets, values, calldatas, descriptionHash);
  91 |     |     }
  92 |     | 
  93 |     |     function _executor()
  94 |     |         internal
  95 |     |         view
  96 |     |         override(GovernorUpgradeable, GovernorTimelockControlUpgradeable)
  97 |     |         returns (address)
  98 |     |     {
  99 |     |         return super._executor();
 100 |     |     }
 101 |     | 
 102 |     |     function state(uint256 proposalId)
 103 |     |         public
 104 |     |         view
 105 |     |         override(GovernorUpgradeable, GovernorTimelockControlUpgradeable)
 106 |     |         returns (ProposalState)
 107 |     |     {
 108 |     |         return super.state(proposalId);
 109 |     |     }
 110 |     | 
 111 |     |     function votingDelay() public view override(GovernorUpgradeable, GovernorSettingsUpgradeable) returns (uint256) {
 112 |     |         return super.votingDelay();
 113 |     |     }
 114 |     | 
 115 |     |     function votingPeriod() public view override(GovernorUpgradeable, GovernorSettingsUpgradeable) returns (uint256) {
 116 |     |         return super.votingPeriod();
 117 |     |     }
 118 |     | 
 119 |     |     function quorum(uint256 blockNumber)
 120 |     |         public
 121 |     |         view
 122 |     |         override(GovernorUpgradeable, GovernorVotesQuorumFractionUpgradeable)
 123 |     |         returns (uint256)
 124 |     |     {
 125 |     |         return super.quorum(blockNumber);
 126 |     |     }
 127 |     | 
 128 |     |     function proposalThreshold()
 129 |     |         public
 130 |     |         view
 131 |     |         override(GovernorUpgradeable, GovernorSettingsUpgradeable)
 132 |     |         returns (uint256)
 133 |     |     {
 134 |     |         return super.proposalThreshold();
 135 |     |     }
 136 |     | 
 137 |     |     function supportsInterface(bytes4 interfaceId) public view override(GovernorUpgradeable) returns (bool) {
 138 |     |         return super.supportsInterface(interfaceId);
 139 |     |     }
 140 |     | }
 141 |     | 

/home/phantom/Documents/azemora/azemora-contracts/src/governance/AzemoraTimelockController.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | pragma solidity ^0.8.20;
  3 |     | 
  4 |     | import "@openzeppelin/contracts-upgradeable/governance/TimelockControllerUpgradeable.sol";
  5 |     | import "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";
  6 |     | 
  7 |     | /**
  8 |     |  * @title AzemoraTimelockController
  9 |     |  * @author Genci Mehmeti
 10 |     |  * @dev A simple, upgradeable wrapper for OpenZeppelin's TimelockController.
 11 |     |  * This contract will be the owner of other contracts in the system, and will
 12 |     |  * execute transactions proposed and passed by the AzemoraGovernor.
 13 |     |  */
 14 |     | contract AzemoraTimelockController is Initializable, TimelockControllerUpgradeable {
 15 |     |     /// @custom:oz-upgrades-unsafe-allow constructor
 16 |     |     constructor() {
 17 |     |         _disableInitializers();
 18 |     |     }
 19 |     | 
 20 |     |     function initialize(uint256 minDelay, address[] memory proposers, address[] memory executors, address admin)
 21 |     |         public
 22 |     |         override
 23 |     |         initializer
 24 |     |     {
 25 |     |         __TimelockController_init(minDelay, proposers, executors, admin);
 26 |     |     }
 27 |     | }
 28 |     | 

/home/phantom/Documents/azemora/azemora-contracts/src/governance/Treasury.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | pragma solidity ^0.8.20;
  3 |     | 
  4 |     | import "@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol";
  5 |     | import "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";
  6 |     | import "@openzeppelin/contracts-upgradeable/utils/ReentrancyGuardUpgradeable.sol";
  7 |     | import "@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol";
  8 |     | 
  9 |     | /**
 10 |     |  * @title Treasury
 11 |     |  * @author Genci Mehmeti
 12 |     |  * @dev A simple contract to hold and manage funds for the Azemora platform.
 13 |     |  * It is owned by the governance system (via the Timelock) and allows for the
 14 |     |  * withdrawal of ETH and any ERC20 tokens.
 15 |     |  */
 16 |     | contract Treasury is Initializable, OwnableUpgradeable, ReentrancyGuardUpgradeable, UUPSUpgradeable {
 17 |     |     event ETHWithdrawn(address indexed to, uint256 amount);
 18 |     |     event ERC20Withdrawn(address indexed token, address indexed to, uint256 amount);
 19 |     | 
 20 |     |     uint256[50] private __gap;
 21 |     | 
 22 |     |     /// @custom:oz-upgrades-unsafe-allow constructor
 23 |     |     constructor() {
 24 |     |         _disableInitializers();
 25 |     |     }
 26 |     | 
 27 |     |     function initialize(address initialOwner) public initializer {
 28 |     |         __Ownable_init(initialOwner);
 29 |     |         __ReentrancyGuard_init();
 30 |     |         __UUPSUpgradeable_init();
 31 |     |     }
 32 |     | 
 33 |     |     receive() external payable {}
 34 |     | 
 35 |     |     function withdrawETH(address to, uint256 amount) external onlyOwner nonReentrant {
 36 |     |         require(to != address(0), "Cannot send to zero address");
 37 |     |         require(address(this).balance >= amount, "Insufficient ETH balance");
 38 |     |         (bool success,) = to.call{value: amount}("");
 39 |     |         require(success, "ETH transfer failed");
 40 |     |         emit ETHWithdrawn(to, amount);
 41 |     |     }
 42 |     | 
 43 |     |     function withdrawERC20(address token, address to, uint256 amount) external onlyOwner nonReentrant {
 44 |     |         require(to != address(0), "Cannot send to zero address");
 45 |     |         (bool success,) = token.call(abi.encodeWithSignature("transfer(address,uint256)", to, amount));
 46 |     |         require(success, "ERC20 transfer failed");
 47 |     |         emit ERC20Withdrawn(token, to, amount);
 48 |     |     }
 49 |     | 
 50 |     |     function _authorizeUpgrade(address newImplementation) internal override onlyOwner {}
 51 |     | }
 52 |     | 

/home/phantom/Documents/azemora/azemora-contracts/src/marketplace/Marketplace.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | pragma solidity ^0.8.20;
   3 |     | 
   4 |     | import "@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol";
   5 |     | import "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";
   6 |     | import "@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol";
   7 |     | import "@openzeppelin/contracts-upgradeable/utils/ReentrancyGuardUpgradeable.sol";
   8 |     | import "@openzeppelin/contracts-upgradeable/token/ERC1155/utils/ERC1155HolderUpgradeable.sol";
   9 |     | import "@openzeppelin/contracts-upgradeable/utils/PausableUpgradeable.sol";
  10 |     | 
  11 |     | // --- Custom Interfaces to avoid import issues ---
  12 |     | 
  13 |     | interface IERC165Upgradeable {
  14 |     |     function supportsInterface(bytes4 interfaceId) external view returns (bool);
  15 |     | }
  16 |     | 
  17 |     | // Interface for ERC1155 functionality
  18 |     | interface IERC1155Upgradeable is IERC165Upgradeable {
  19 |     |     event TransferSingle(address indexed operator, address indexed from, address indexed to, uint256 id, uint256 value);
  20 |     |     event TransferBatch(
  21 |     |         address indexed operator, address indexed from, address indexed to, uint256[] ids, uint256[] values
  22 |     |     );
  23 |     |     event ApprovalForAll(address indexed account, address indexed operator, bool approved);
  24 |     |     event URI(string value, uint256 indexed id);
  25 |     | 
  26 |     |     function balanceOf(address account, uint256 id) external view returns (uint256);
  27 |     | 
  28 |     |     function balanceOfBatch(address[] calldata accounts, uint256[] calldata ids)
  29 |     |         external
  30 |     |         view
  31 |     |         returns (uint256[] memory);
  32 |     | 
  33 |     |     function setApprovalForAll(address operator, bool approved) external;
  34 |     | 
  35 |     |     function isApprovedForAll(address account, address operator) external view returns (bool);
  36 |     | 
  37 |     |     function safeTransferFrom(address from, address to, uint256 id, uint256 amount, bytes calldata data) external;
  38 |     | 
  39 |     |     function safeBatchTransferFrom(
  40 |     |         address from,
  41 |     |         address to,
  42 |     |         uint256[] calldata ids,
  43 |     |         uint256[] calldata amounts,
  44 |     |         bytes calldata data
  45 |     |     ) external;
  46 |     | }
  47 |     | 
  48 |     | // Interface for ERC20 functionality, included directly to avoid import issues.
  49 |     | interface IERC20Upgradeable {
  50 |     |     event Transfer(address indexed from, address indexed to, uint256 value);
  51 |     |     event Approval(address indexed owner, address indexed spender, uint256 value);
  52 |     | 
  53 |     |     function totalSupply() external view returns (uint256);
  54 |     | 
  55 |     |     function balanceOf(address account) external view returns (uint256);
  56 |     | 
  57 |     |     function transfer(address to, uint256 amount) external returns (bool);
  58 |     | 
  59 |     |     function allowance(address owner, address spender) external view returns (uint256);
  60 |     | 
  61 |     |     function approve(address spender, uint256 amount) external returns (bool);
  62 |     | 
  63 |     |     function transferFrom(address from, address to, uint256 amount) external returns (bool);
  64 |     | }
  65 |     | 
  66 |     | // --- Custom Errors for Gas Optimization ---
  67 |     | error Marketplace__ZeroAmount();
  68 |     | error Marketplace__ZeroPrice();
  69 |     | error Marketplace__ZeroExpiry();
  70 |     | error Marketplace__ListingNotActive();
  71 |     | error Marketplace__ListingExpired();
  72 |     | error Marketplace__NotEnoughItemsInListing();
  73 |     | error Marketplace__InsufficientBalance();
  74 |     | error Marketplace__NotTheSeller();
  75 |     | error Marketplace__TreasuryAddressZero();
  76 |     | error Marketplace__FeeTooHigh();
  77 |     | error Marketplace__ListingNotFound();
  78 |     | error Marketplace__ArrayLengthMismatch();
  79 |     | error Marketplace__TransferFailed();
  80 |     | error Marketplace__ListingNotExpired();
  81 |     | 
  82 |     | /**
  83 |     |  * @title Marketplace
  84 |     |  * @author Genci Mehmeti
  85 |     |  * @dev A custodial marketplace for trading ERC1155-based environmental assets.
  86 |     |  * Sellers list their assets by transferring them to this contract. Buyers can then
  87 |     |  * purchase these assets using a designated ERC20 payment token. The contract
  88 |     |  * supports partial purchases and includes a platform fee on sales.
  89 |     |  * It is upgradeable using the UUPS pattern.
  90 |     |  */
  91 | *   | contract Marketplace is
  92 |     |     Initializable,
  93 |     |     AccessControlUpgradeable,
  94 |     |     UUPSUpgradeable,
  95 |     |     ReentrancyGuardUpgradeable,
  96 |     |     ERC1155HolderUpgradeable,
  97 |     |     PausableUpgradeable
  98 |     | {
  99 |     |     // --- Roles ---
 100 | *   |     bytes32 public constant PAUSER_ROLE = keccak256("PAUSER_ROLE");
 101 |     | 
 102 |     |     bytes32[] private _roles;
 103 |     | 
 104 |     |     // --- State ---
 105 |     |     IERC1155Upgradeable public creditContract;
 106 |     |     IERC20Upgradeable public paymentToken;
 107 |     |     address public treasury;
 108 |     |     uint256 public feeBps; // Fee in basis points (e.g., 250 = 2.5%)
 109 |     | 
 110 |     |     struct Listing {
 111 |     |         uint256 id;
 112 |     |         uint256 tokenId;
 113 |     |         uint256 amount;
 114 |     |         uint256 pricePerUnit;
 115 |     |         // --- Packed for gas efficiency ---
 116 |     |         address seller; // 20 bytes
 117 |     |         uint64 expiryTimestamp; // 8 bytes
 118 |     |         bool active; // 1 byte
 119 |     |     }
 120 |     | 
 121 | *   |     mapping(uint256 => Listing) public listings;
 122 | *   |     uint256 public listingIdCounter;
 123 |     |     uint256 public activeListingCount;
 124 |     | 
 125 |     |     uint256[50] private __gap;
 126 |     | 
 127 |     |     // --- Events ---
 128 |     |     event Listed(
 129 |     |         uint256 indexed listingId, address indexed seller, uint256 indexed tokenId, uint256 amount, uint256 pricePerUnit
 130 |     |     );
 131 |     |     event Sold(uint256 indexed listingId, address indexed buyer, uint256 amount, uint256 totalPrice);
 132 |     |     event ListingCancelled(uint256 indexed listingId);
 133 |     |     event ListingPriceUpdated(uint256 indexed listingId, uint256 newPricePerUnit);
 134 |     |     event TreasuryUpdated(address indexed newTreasury);
 135 |     |     event FeeUpdated(uint256 newFeeBps);
 136 |     |     event PartialSold(uint256 indexed listingId, address indexed buyer, uint256 amount, uint256 totalPrice);
 137 |     |     event FeePaid(address indexed recipient, uint256 amount);
 138 |     | 
 139 |     |     /// @custom:oz-upgrades-unsafe-allow constructor
 140 | *   |     constructor() {
 141 | *   |         _disableInitializers();
 142 |     |     }
 143 |     | 
 144 |     |     /**
 145 |     |      * @notice Initializes the marketplace with its core dependencies.
 146 |     |      * @dev Sets up roles and contract dependencies. The deployer is granted `DEFAULT_ADMIN_ROLE`
 147 |     |      * and `PAUSER_ROLE`. The `treasury` and `feeBps` must be set in separate transactions
 148 |     |      * after initialization.
 149 |     |      * @param creditContract_ The address of the ERC1155 `DynamicImpactCredit` contract.
 150 |     |      * @param paymentToken_ The address of the ERC20 token used for payments.
 151 |     |      */
 152 | *   |     function initialize(address creditContract_, address paymentToken_) public initializer {
 153 | *   |         __AccessControl_init();
 154 | *   |         __UUPSUpgradeable_init();
 155 | *   |         __ReentrancyGuard_init();
 156 | *   |         __ERC1155Holder_init();
 157 | *   |         __Pausable_init();
 158 |     | 
 159 | *   |         _grantRole(DEFAULT_ADMIN_ROLE, _msgSender());
 160 | *   |         _grantRole(PAUSER_ROLE, _msgSender());
 161 |     | 
 162 | *   |         creditContract = IERC1155Upgradeable(creditContract_);
 163 | *   |         paymentToken = IERC20Upgradeable(paymentToken_);
 164 |     | 
 165 | *   |         _roles.push(DEFAULT_ADMIN_ROLE);
 166 | *   |         _roles.push(PAUSER_ROLE);
 167 |     |     }
 168 |     | 
 169 |     |     /**
 170 |     |      * @notice Lists a specified amount of an ERC1155 token for sale.
 171 |     |      * @dev The seller must have first approved the marketplace to manage their tokens via `setApprovalForAll`.
 172 |     |      * The tokens are held in custody by this contract until sold or the listing is cancelled.
 173 |     |      * Emits a `Listed` event.
 174 |     |      * @param tokenId The ID of the token to list.
 175 |     |      * @param amount The quantity of the token to list.
 176 |     |      * @param pricePerUnit The price for each single unit of the token in the payment currency.
 177 |     |      * @param expiryDuration The duration in seconds from now after which the listing will expire.
 178 |     |      * @return listingId The unique ID of the newly created listing.
 179 |     |      */
 180 | *   |     function list(uint256 tokenId, uint256 amount, uint256 pricePerUnit, uint256 expiryDuration)
 181 |     |         external
 182 |     |         nonReentrant
 183 |     |         whenNotPaused
 184 | *   |         returns (uint256 listingId)
 185 |     |     {
 186 | *   |         if (amount == 0) revert Marketplace__ZeroAmount();
 187 | *   |         if (pricePerUnit == 0) revert Marketplace__ZeroPrice();
 188 | *   |         if (expiryDuration == 0) revert Marketplace__ZeroExpiry();
 189 |     | 
 190 |     |         // Custodial model: Transfer tokens from seller to this contract
 191 | *   |         creditContract.safeTransferFrom(_msgSender(), address(this), tokenId, amount, "");
 192 |     | 
 193 | *   |         listingId = listingIdCounter++;
 194 | *   |         listings[listingId] = Listing({
 195 | *   |             id: listingId,
 196 | *   |             seller: _msgSender(),
 197 | *   |             tokenId: tokenId,
 198 | *   |             amount: amount,
 199 | *   |             pricePerUnit: pricePerUnit,
 200 | *   |             expiryTimestamp: uint64(block.timestamp + expiryDuration),
 201 | *   |             active: true
 202 |     |         });
 203 |     | 
 204 | *   |         activeListingCount++;
 205 |     | 
 206 | *   |         emit Listed(listingId, _msgSender(), tokenId, amount, pricePerUnit);
 207 |     |         return listingId;
 208 |     |     }
 209 |     | 
 210 |     |     /**
 211 |     |      * @notice Purchases a specified amount of tokens from an active listing.
 212 |     |      * @dev The buyer must have first approved the marketplace to spend their payment tokens via `approve`.
 213 |     |      * The function handles payment transfers to the seller and the treasury, and transfers the
 214 |     |      * purchased tokens to the buyer. Supports partial buys.
 215 |     |      * Emits a `PartialSold` event or a `Sold` event if the listing is fully depleted.
 216 |     |      * @param listingId The ID of the listing to buy from.
 217 |     |      * @param amountToBuy The quantity of tokens to purchase from the listing.
 218 |     |      */
 219 | *   |     function buy(uint256 listingId, uint256 amountToBuy) external nonReentrant whenNotPaused {
 220 | *   |         Listing storage listing = listings[listingId];
 221 |     |         // --- CHECKS ---
 222 | *   |         if (!listing.active) revert Marketplace__ListingNotActive();
 223 | *   |         if (block.timestamp >= listing.expiryTimestamp) revert Marketplace__ListingExpired();
 224 | *   |         if (amountToBuy == 0) revert Marketplace__ZeroAmount();
 225 | *   |         if (listing.amount < amountToBuy) revert Marketplace__NotEnoughItemsInListing();
 226 |     | 
 227 | *   |         uint256 totalPrice = amountToBuy * listing.pricePerUnit;
 228 | *   |         if (paymentToken.balanceOf(_msgSender()) < totalPrice) revert Marketplace__InsufficientBalance();
 229 |     | 
 230 | *   |         uint256 fee = (totalPrice * feeBps) / 10000;
 231 | *   |         uint256 sellerProceeds = totalPrice - fee;
 232 |     | 
 233 |     |         // --- EFFECTS ---
 234 | *   |         listing.amount -= amountToBuy;
 235 | *   |         if (listing.amount == 0) {
 236 | *   |             listing.active = false;
 237 | *   |             activeListingCount--;
 238 | *   |             emit Sold(listingId, _msgSender(), amountToBuy, totalPrice);
 239 |     |         } else {
 240 | *   |             emit PartialSold(listingId, _msgSender(), amountToBuy, totalPrice);
 241 |     |         }
 242 |     | 
 243 |     |         // --- INTERACTIONS ---
 244 |     |         // Transfer payment from buyer to seller and fee recipient
 245 | *   |         if (sellerProceeds > 0) {
 246 | *   |             if (!paymentToken.transferFrom(_msgSender(), listing.seller, sellerProceeds)) {
 247 |     |                 revert Marketplace__TransferFailed();
 248 |     |             }
 249 |     |         }
 250 | *   |         if (fee > 0) {
 251 |     |             if (!paymentToken.transferFrom(_msgSender(), treasury, fee)) {
 252 |     |                 revert Marketplace__TransferFailed();
 253 |     |             }
 254 |     |             emit FeePaid(treasury, fee);
 255 |     |         }
 256 |     | 
 257 |     |         // Transfer the NFT from marketplace to buyer
 258 | *   |         creditContract.safeTransferFrom(address(this), _msgSender(), listing.tokenId, amountToBuy, "");
 259 |     |     }
 260 |     | 
 261 |     |     /**
 262 |     |      * @notice Cancels an active listing.
 263 |     |      * @dev Can only be called by the original seller. Any unsold tokens held in custody are
 264 |     |      * returned to the seller. Emits a `ListingCancelled` event.
 265 |     |      * @param listingId The ID of the listing to cancel.
 266 |     |      */
 267 | *   |     function cancelListing(uint256 listingId) external nonReentrant whenNotPaused {
 268 | *   |         Listing storage listing = listings[listingId];
 269 | *   |         if (!listing.active) revert Marketplace__ListingNotActive();
 270 | *   |         if (listing.seller != _msgSender()) revert Marketplace__NotTheSeller();
 271 |     | 
 272 |     |         listing.active = false;
 273 |     |         activeListingCount--;
 274 |     | 
 275 |     |         // Return the unsold tokens to the seller
 276 |     |         creditContract.safeTransferFrom(address(this), listing.seller, listing.tokenId, listing.amount, "");
 277 |     | 
 278 |     |         emit ListingCancelled(listingId);
 279 |     |     }
 280 |     | 
 281 |     |     /**
 282 |     |      * @notice Cancels multiple active listings in a single transaction.
 283 |     |      * @dev Can only be called by the original seller of all listings. Unsold tokens
 284 |     |      * for each cancelled listing are returned to the seller in a single batch transaction,
 285 |     |      * which is more gas-efficient than calling `cancelListing` individually.
 286 |     |      * @param listingIds An array of listing IDs to cancel.
 287 |     |      */
 288 |     |     function batchCancelListings(uint256[] calldata listingIds) external nonReentrant whenNotPaused {
 289 |     |         uint256[] memory tokenIds = new uint256[](listingIds.length);
 290 |     |         uint256[] memory amounts = new uint256[](listingIds.length);
 291 |     |         address seller = _msgSender();
 292 |     | 
 293 |     |         // Down-counting loop is more gas-efficient.
 294 |     |         for (uint256 i = listingIds.length; i > 0; --i) {
 295 |     |             uint256 listingId = listingIds[i - 1];
 296 |     |             Listing storage listing = listings[listingId];
 297 |     |             if (!listing.active) revert Marketplace__ListingNotActive();
 298 |     |             if (listing.seller != seller) revert Marketplace__NotTheSeller();
 299 |     | 
 300 |     |             listing.active = false;
 301 |     |             activeListingCount--;
 302 |     | 
 303 |     |             tokenIds[i - 1] = listing.tokenId;
 304 |     |             amounts[i - 1] = listing.amount;
 305 |     | 
 306 |     |             emit ListingCancelled(listingId);
 307 |     |         }
 308 |     | 
 309 |     |         // Return all unsold tokens to the seller in a single batch transaction
 310 |     |         creditContract.safeBatchTransferFrom(address(this), seller, tokenIds, amounts, "");
 311 |     |     }
 312 |     | 
 313 |     |     /**
 314 |     |      * @notice Purchases tokens from multiple listings in a single transaction.
 315 |     |      * @dev The buyer must have approved the marketplace to spend the total amount of payment tokens.
 316 |     |      * This function iterates through the provided listings and amounts, processes payments,
 317 |     |      * and transfers the purchased tokens to the buyer in a single batch. It is significantly
 318 |     |      * more gas-efficient than calling `buy` multiple times.
 319 |     |      * @param listingIds An array of listing IDs to buy from.
 320 |     |      * @param amountsToBuy An array of token quantities to purchase from each corresponding listing.
 321 |     |      */
 322 |     |     function batchBuy(uint256[] calldata listingIds, uint256[] calldata amountsToBuy)
 323 |     |         external
 324 |     |         nonReentrant
 325 |     |         whenNotPaused
 326 |     |     {
 327 |     |         if (listingIds.length != amountsToBuy.length) revert Marketplace__ArrayLengthMismatch();
 328 |     | 
 329 |     |         uint256 totalPayment = 0;
 330 |     |         uint256 totalFee = 0;
 331 |     |         uint256[] memory tokenIds = new uint256[](listingIds.length);
 332 |     |         uint256 len = listingIds.length;
 333 |     | 
 334 |     |         // First loop for CHECKS. This is critical for security and atomicity.
 335 |     |         // Down-counting loop is more gas-efficient.
 336 |     |         for (uint256 i = len; i > 0; --i) {
 337 |     |             uint256 listingId = listingIds[i - 1];
 338 |     |             uint256 amountToBuy = amountsToBuy[i - 1];
 339 |     |             Listing storage listing = listings[listingId];
 340 |     | 
 341 |     |             if (!listing.active) revert Marketplace__ListingNotActive();
 342 |     |             if (block.timestamp >= listing.expiryTimestamp) revert Marketplace__ListingExpired();
 343 |     |             if (amountToBuy == 0) revert Marketplace__ZeroAmount();
 344 |     |             if (listing.amount < amountToBuy) revert Marketplace__NotEnoughItemsInListing();
 345 |     | 
 346 |     |             uint256 price = amountToBuy * listing.pricePerUnit;
 347 |     |             totalPayment += price;
 348 |     |             totalFee += (price * feeBps) / 10000;
 349 |     |         }
 350 |     | 
 351 |     |         if (paymentToken.balanceOf(_msgSender()) < totalPayment) revert Marketplace__InsufficientBalance();
 352 |     | 
 353 |     |         // Transfer total fee to treasury in one go.
 354 |     |         if (totalFee > 0) {
 355 |     |             if (!paymentToken.transferFrom(_msgSender(), treasury, totalFee)) {
 356 |     |                 revert Marketplace__TransferFailed();
 357 |     |             }
 358 |     |             emit FeePaid(treasury, totalFee);
 359 |     |         }
 360 |     | 
 361 |     |         // Second loop for EFFECTS and INTERACTIONS (Seller payments).
 362 |     |         // Down-counting loop is more gas-efficient.
 363 |     |         for (uint256 i = len; i > 0; --i) {
 364 |     |             uint256 listingId = listingIds[i - 1];
 365 |     |             uint256 amountToBuy = amountsToBuy[i - 1];
 366 |     |             Listing storage listing = listings[listingId];
 367 |     | 
 368 |     |             uint256 price = amountToBuy * listing.pricePerUnit;
 369 |     |             uint256 fee = (price * feeBps) / 10000;
 370 |     |             uint256 sellerProceeds = price - fee;
 371 |     | 
 372 |     |             // --- EFFECTS ---
 373 |     |             listing.amount -= amountToBuy;
 374 |     |             if (listing.amount == 0) {
 375 |     |                 listing.active = false;
 376 |     |                 activeListingCount--;
 377 |     |                 emit Sold(listingId, _msgSender(), amountToBuy, price);
 378 |     |             } else {
 379 |     |                 emit PartialSold(listingId, _msgSender(), amountToBuy, price);
 380 |     |             }
 381 |     | 
 382 |     |             tokenIds[i - 1] = listing.tokenId;
 383 |     | 
 384 |     |             // --- INTERACTIONS (Seller Only) ---
 385 |     |             if (sellerProceeds > 0) {
 386 |     |                 if (!paymentToken.transferFrom(_msgSender(), listing.seller, sellerProceeds)) {
 387 |     |                     revert Marketplace__TransferFailed();
 388 |     |                 }
 389 |     |             }
 390 |     |         }
 391 |     | 
 392 |     |         // Final Interaction: Batch transfer all NFTs to buyer.
 393 |     |         creditContract.safeBatchTransferFrom(address(this), _msgSender(), tokenIds, amountsToBuy, "");
 394 |     |     }
 395 |     | 
 396 |     |     /**
 397 |     |      * @notice Cancels an expired listing.
 398 |     |      * @dev Can be called by anyone to clean up an expired listing. The unsold
 399 |     |      * tokens are returned from custody to the seller.
 400 |     |      * @param listingId The ID of the expired listing to cancel.
 401 |     |      */
 402 | *   |     function cancelExpiredListing(uint256 listingId) external nonReentrant whenNotPaused {
 403 |     |         Listing storage listing = listings[listingId];
 404 |     |         if (!listing.active) revert Marketplace__ListingNotActive();
 405 | *   |         if (block.timestamp < listing.expiryTimestamp) revert Marketplace__ListingNotExpired();
 406 |     | 
 407 | *   |         listing.active = false;
 408 | *   |         activeListingCount--;
 409 |     | 
 410 |     |         // Return the unsold tokens to the seller
 411 | *   |         creditContract.safeTransferFrom(address(this), listing.seller, listing.tokenId, listing.amount, "");
 412 |     | 
 413 |     |         emit ListingCancelled(listingId);
 414 |     |     }
 415 |     | 
 416 |     |     /**
 417 |     |      * @notice Allows a seller to update the price of their active listing.
 418 |     |      * @dev Can only be called by the original seller of the listing.
 419 |     |      * Emits a `ListingPriceUpdated` event.
 420 |     |      * @param listingId The ID of the listing to update.
 421 |     |      * @param newPricePerUnit The new price for each unit of the token.
 422 |     |      */
 423 |     |     function updateListingPrice(uint256 listingId, uint256 newPricePerUnit) external nonReentrant whenNotPaused {
 424 |     |         Listing storage listing = listings[listingId];
 425 |     |         if (!listing.active) revert Marketplace__ListingNotActive();
 426 |     |         if (listing.seller != _msgSender()) revert Marketplace__NotTheSeller();
 427 |     |         if (newPricePerUnit == 0) revert Marketplace__ZeroPrice();
 428 |     | 
 429 |     |         listing.pricePerUnit = newPricePerUnit;
 430 |     |         emit ListingPriceUpdated(listingId, newPricePerUnit);
 431 |     |     }
 432 |     | 
 433 |     |     /**
 434 |     |      * @notice Sets the address of the treasury contract that receives platform fees.
 435 |     |      * @dev Can only be called by an address with the `DEFAULT_ADMIN_ROLE`.
 436 |     |      * It is recommended this be the Timelock contract in a DAO context.
 437 |     |      * Emits a `TreasuryUpdated` event.
 438 |     |      * @param newTreasury The address of the new treasury.
 439 |     |      */
 440 |     |     function setTreasury(address newTreasury) external onlyRole(DEFAULT_ADMIN_ROLE) {
 441 |     |         if (newTreasury == address(0)) revert Marketplace__TreasuryAddressZero();
 442 |     |         treasury = newTreasury;
 443 |     |         emit TreasuryUpdated(newTreasury);
 444 |     |     }
 445 |     | 
 446 |     |     /**
 447 |     |      * @notice Sets the platform fee in basis points.
 448 |     |      * @dev Can only be called by an address with the `DEFAULT_ADMIN_ROLE`.
 449 |     |      * For example, a value of 250 corresponds to a 2.5% fee.
 450 |     |      * Emits a `FeeUpdated` event.
 451 |     |      * @param newFeeBps The new fee in basis points.
 452 |     |      */
 453 |     |     function setFee(uint256 newFeeBps) external onlyRole(DEFAULT_ADMIN_ROLE) {
 454 |     |         // A sanity check to prevent accidentally setting an enormous fee.
 455 |     |         // 10000 bps = 100%
 456 |     |         if (newFeeBps > 10000) revert Marketplace__FeeTooHigh();
 457 |     |         feeBps = newFeeBps;
 458 |     |         emit FeeUpdated(newFeeBps);
 459 |     |     }
 460 |     | 
 461 |     |     /**
 462 |     |      * @notice Retrieves the details of a specific listing.
 463 |     |      * @param listingId The ID of the listing to query.
 464 |     |      * @return A `Listing` struct containing the listing's data.
 465 |     |      */
 466 |     |     function getListing(uint256 listingId) external view returns (Listing memory) {
 467 |     |         if (listings[listingId].id != listingId) revert Marketplace__ListingNotFound();
 468 |     |         return listings[listingId];
 469 |     |     }
 470 |     | 
 471 |     |     /**
 472 |     |      * @notice Gets all the roles held by a specific account.
 473 |     |      * @dev Provides an easy way for UIs and other tools to check permissions.
 474 |     |      * @param account The address to check.
 475 |     |      * @return A list of role identifiers held by the account.
 476 |     |      */
 477 |     |     function getRoles(address account) external view returns (bytes32[] memory) {
 478 |     |         // More efficient implementation: loop only once.
 479 |     |         bytes32[] memory temporaryRoles = new bytes32[](_roles.length);
 480 |     |         uint256 count = 0;
 481 |     |         for (uint256 i = 0; i < _roles.length; i++) {
 482 |     |             if (hasRole(_roles[i], account)) {
 483 |     |                 temporaryRoles[count] = _roles[i];
 484 |     |                 count++;
 485 |     |             }
 486 |     |         }
 487 |     | 
 488 |     |         bytes32[] memory roles = new bytes32[](count);
 489 |     |         for (uint256 i = 0; i < count; i++) {
 490 |     |             roles[i] = temporaryRoles[i];
 491 |     |         }
 492 |     |         return roles;
 493 |     |     }
 494 |     | 
 495 |     |     /**
 496 |     |      * @notice Pauses all state-changing functions in the contract.
 497 |     |      * @dev Can only be called by an address with the `PAUSER_ROLE`.
 498 |     |      * This is a critical safety feature to halt activity in case of an emergency.
 499 |     |      * Emits a `Paused` event.
 500 |     |      */
 501 |     |     function pause() external onlyRole(PAUSER_ROLE) {
 502 |     |         _pause();
 503 |     |     }
 504 |     | 
 505 |     |     /**
 506 |     |      * @notice Lifts the pause on the contract, resuming normal operations.
 507 |     |      * @dev Can only be called by an address with the `PAUSER_ROLE`.
 508 |     |      * Emits an `Unpaused` event.
 509 |     |      */
 510 |     |     function unpause() external onlyRole(PAUSER_ROLE) {
 511 |     |         _unpause();
 512 |     |     }
 513 |     | 
 514 |     |     // --- Interface Support ---
 515 | *   |     function supportsInterface(bytes4 interfaceId)
 516 |     |         public
 517 |     |         view
 518 |     |         override(AccessControlUpgradeable, ERC1155HolderUpgradeable)
 519 |     |         returns (bool)
 520 |     |     {
 521 | *   |         return super.supportsInterface(interfaceId);
 522 |     |     }
 523 |     | 
 524 |     |     /* ---------- upgrade auth ---------- */
 525 |     |     function _authorizeUpgrade(address newImplementation) internal override onlyRole(DEFAULT_ADMIN_ROLE) {}
 526 |     | }
 527 |     | 

/home/phantom/Documents/azemora/azemora-contracts/src/token/AzemoraToken.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | pragma solidity ^0.8.20;
  3 |     | 
  4 |     | import "@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol";
  5 |     | import "@openzeppelin/contracts-upgradeable/token/ERC20/extensions/ERC20PermitUpgradeable.sol";
  6 |     | import "@openzeppelin/contracts-upgradeable/token/ERC20/extensions/ERC20VotesUpgradeable.sol";
  7 |     | import "@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol";
  8 |     | import "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";
  9 |     | import "@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol";
 10 |     | 
 11 |     | /**
 12 |     |  * @title AzemoraToken
 13 |     |  * @author Genci Mehmeti
 14 |     |  * @dev The governance token for the Azemora platform.
 15 |     |  * It is an ERC20 token with voting and permit functionalities, based on OpenZeppelin's
 16 |     |  * upgradeable contracts. A fixed supply of 1 billion tokens is minted to the
 17 |     |  * admin upon initialization.
 18 |     |  */
 19 |     | contract AzemoraToken is
 20 |     |     Initializable,
 21 |     |     ERC20Upgradeable,
 22 |     |     ERC20PermitUpgradeable,
 23 |     |     ERC20VotesUpgradeable,
 24 |     |     AccessControlUpgradeable,
 25 |     |     UUPSUpgradeable
 26 |     | {
 27 |     |     /// @custom:oz-upgrades-unsafe-allow constructor
 28 |     |     constructor() {
 29 |     |         _disableInitializers();
 30 |     |     }
 31 |     | 
 32 |     |     function initialize() public initializer {
 33 |     |         __ERC20_init("Azemora", "AZE");
 34 |     |         __ERC20Permit_init("Azemora");
 35 |     |         __ERC20Votes_init();
 36 |     |         __AccessControl_init();
 37 |     |         __UUPSUpgradeable_init();
 38 |     | 
 39 |     |         _grantRole(DEFAULT_ADMIN_ROLE, _msgSender());
 40 |     | 
 41 |     |         // Mint a fixed supply of 1 billion tokens to the deployer.
 42 |     |         // The token has 18 decimals by default.
 43 |     |         _mint(_msgSender(), 1_000_000_000 * (10 ** decimals()));
 44 |     |     }
 45 |     | 
 46 |     |     // The following functions are overrides required by Solidity.
 47 |     | 
 48 |     |     function _update(address from, address to, uint256 value)
 49 |     |         internal
 50 |     |         override(ERC20Upgradeable, ERC20VotesUpgradeable)
 51 |     |     {
 52 |     |         super._update(from, to, value);
 53 |     |     }
 54 |     | 
 55 |     |     function nonces(address owner) public view override(ERC20PermitUpgradeable, NoncesUpgradeable) returns (uint256) {
 56 |     |         return super.nonces(owner);
 57 |     |     }
 58 |     | 
 59 |     |     function _authorizeUpgrade(address newImplementation) internal override onlyRole(DEFAULT_ADMIN_ROLE) {}
 60 |     | }
 61 |     | 

/home/phantom/Documents/azemora/azemora-contracts/test/dMRVManager/DMRVManager.fuzz.t.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | pragma solidity ^0.8.20;
   3 |     | 
   4 |     | import "forge-std/Test.sol";
   5 |     | import "../../src/core/dMRVManager.sol";
   6 |     | import "../../src/core/ProjectRegistry.sol";
   7 |     | import "../../src/core/DynamicImpactCredit.sol";
   8 |     | import "@openzeppelin/contracts/proxy/ERC1967/ERC1967Proxy.sol";
   9 |     | 
  10 |     | contract DMRVManagerFuzzTest is Test {
  11 |     |     DMRVManager manager;
  12 |     |     ProjectRegistry registry;
  13 |     |     DynamicImpactCredit credit;
  14 |     | 
  15 |     |     address admin = address(0xA11CE);
  16 |     |     address oracle = address(0x0AC1E);
  17 |     |     address verifier = address(0xC1E4);
  18 |     |     address projectOwner = address(0x044E);
  19 |     | 
  20 |     |     bytes32 projectId = keccak256("Fuzz Test Project");
  21 |     | 
  22 |     |     function setUp() public {
  23 |     |         // Deploy and set up the contract infrastructure
  24 |     |         vm.startPrank(admin);
  25 |     | 
  26 |     |         // 1. Deploy Registry
  27 |     |         registry = ProjectRegistry(
  28 |     |             address(new ERC1967Proxy(address(new ProjectRegistry()), abi.encodeCall(ProjectRegistry.initialize, ())))
  29 |     |         );
  30 |     |         registry.grantRole(registry.VERIFIER_ROLE(), verifier);
  31 |     | 
  32 |     |         // 2. Deploy DynamicImpactCredit
  33 |     |         credit = DynamicImpactCredit(
  34 |     |             address(
  35 |     |                 new ERC1967Proxy(
  36 |     |                     address(new DynamicImpactCredit(address(registry))),
  37 |     |                     abi.encodeCall(DynamicImpactCredit.initialize, ("uri"))
  38 |     |                 )
  39 |     |             )
  40 |     |         );
  41 |     | 
  42 |     |         // 3. Deploy DMRVManager
  43 |     |         DMRVManager managerImpl = new DMRVManager(address(registry), address(credit));
  44 |     |         manager =
  45 |     |             DMRVManager(address(new ERC1967Proxy(address(managerImpl), abi.encodeCall(DMRVManager.initialize, ()))));
  46 |     | 
  47 |     |         // 4. Set up roles
  48 |     |         credit.grantRole(credit.DMRV_MANAGER_ROLE(), address(manager));
  49 |     |         credit.grantRole(credit.METADATA_UPDATER_ROLE(), address(manager));
  50 |     |         manager.grantRole(manager.ORACLE_ROLE(), oracle);
  51 |     | 
  52 |     |         vm.stopPrank();
  53 |     | 
  54 |     |         // 5. Register and activate a test project for fuzzing
  55 |     |         vm.prank(projectOwner);
  56 |     |         registry.registerProject(projectId, "ipfs://initial.json");
  57 |     | 
  58 |     |         vm.prank(verifier);
  59 |     |         registry.setProjectStatus(projectId, ProjectRegistry.ProjectStatus.Active);
  60 |     | 
  61 |     |         // 6. Set an initial verification to establish a base URI history
  62 |     |         vm.prank(admin);
  63 |     |         manager.adminSubmitVerification(projectId, 1, "ipfs://initial.json", false);
  64 |     |     }
  65 |     | 
  66 |     |     function testFuzz_FulfillVerification(
  67 |     |         uint256 creditAmount,
  68 |     |         bool updateMetadataOnly,
  69 |     |         bytes32 signature,
  70 |     |         string calldata metadataURI
  71 |     |     ) public {
  72 |     |         // Bound the amount to prevent absolutely massive numbers that trigger edge cases
  73 |     |         // Uint64.max (18.4 quintillion) is a practical but still very large limit
  74 |     |         uint64 maxAmount = type(uint64).max;
  75 |     |         creditAmount = bound(creditAmount, 0, maxAmount);
  76 |     | 
  77 |     |         // Skip empty strings or strings with ASCII control characters
  78 |     |         vm.assume(bytes(metadataURI).length > 0);
  79 |     | 
  80 |     |         // --- Setup State ---
  81 |     |         // 1. Create a fresh verification request for each fuzz run
  82 |     |         vm.prank(projectOwner);
  83 |     |         bytes32 requestId = manager.requestVerification(projectId);
  84 |     | 
  85 |     |         // 2. Capture initial state
  86 |     |         uint256 initialBalance = credit.balanceOf(projectOwner, uint256(projectId));
  87 |     |         string[] memory initialHistory = credit.getTokenURIHistory(uint256(projectId));
  88 |     |         uint256 initialHistoryLength = initialHistory.length;
  89 |     | 
  90 |     |         // --- Execute Action ---
  91 |     |         // 3. Prepare oracle data and fulfill the request
  92 |     |         bytes memory data = abi.encode(creditAmount, updateMetadataOnly, signature, metadataURI);
  93 |     | 
  94 |     |         vm.prank(oracle);
  95 |     |         manager.fulfillVerification(requestId, data);
  96 |     | 
  97 |     |         // --- Assert Final State ---
  98 |     |         // 4. Verify the state changes match the inputs
  99 |     |         if (updateMetadataOnly) {
 100 |     |             // Balance should be unchanged
 101 |     |             assertEq(
 102 |     |                 credit.balanceOf(projectOwner, uint256(projectId)),
 103 |     |                 initialBalance,
 104 |     |                 "Balance should not change on metadata update"
 105 |     |             );
 106 |     | 
 107 |     |             // Metadata should be updated and history grown by 1
 108 |     |             assertEq(credit.uri(uint256(projectId)), metadataURI, "URI should be updated");
 109 |     |             string[] memory finalHistory = credit.getTokenURIHistory(uint256(projectId));
 110 |     |             assertEq(finalHistory.length, initialHistoryLength + 1, "URI history should grow by 1");
 111 |     |             assertEq(finalHistory[finalHistory.length - 1], metadataURI, "New URI should be last in history");
 112 |     |         } else {
 113 |     |             // Balance should increase by the credit amount
 114 |     |             assertEq(
 115 |     |                 credit.balanceOf(projectOwner, uint256(projectId)),
 116 |     |                 initialBalance + creditAmount,
 117 |     |                 "Balance should increase on mint"
 118 |     |             );
 119 |     | 
 120 |     |             // Metadata should be updated if credits were minted
 121 |     |             if (creditAmount > 0) {
 122 |     |                 assertEq(credit.uri(uint256(projectId)), metadataURI, "URI should be updated on mint");
 123 |     |                 string[] memory finalHistory = credit.getTokenURIHistory(uint256(projectId));
 124 |     |                 assertEq(finalHistory.length, initialHistoryLength + 1, "URI history should grow by 1 on mint");
 125 |     |             } else {
 126 |     |                 // If amount is 0 and not update-only, nothing should change
 127 |     |                 assertEq(
 128 |     |                     credit.uri(uint256(projectId)),
 129 |     |                     initialHistory[initialHistory.length - 1],
 130 |     |                     "URI should not change if amount is 0"
 131 |     |                 );
 132 |     |             }
 133 |     |         }
 134 |     |     }
 135 |     | }
 136 |     | 

/home/phantom/Documents/azemora/azemora-contracts/test/dMRVManager/dMRVManager.t.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | pragma solidity ^0.8.20;
  3 |     | 
  4 |     | import "forge-std/Test.sol";
  5 |     | import "../../src/core/dMRVManager.sol";
  6 |     | import "../../src/core/ProjectRegistry.sol";
  7 |     | import "../../src/core/DynamicImpactCredit.sol";
  8 |     | import "@openzeppelin/contracts/proxy/ERC1967/ERC1967Proxy.sol";
  9 |     | 
 10 |     | contract DMRVManagerTest is Test {
 11 |     |     DMRVManager dMRVManager;
 12 |     |     ProjectRegistry registry;
 13 |     |     DynamicImpactCredit credit;
 14 |     | 
 15 |     |     address admin = address(0xA11CE);
 16 |     |     address oracle = address(0x044C);
 17 |     |     address projectOwner = address(0x044E);
 18 |     | 
 19 |     |     bytes32 projectId = keccak256("Test Project");
 20 |     |     bytes32 requestId;
 21 |     | 
 22 |     |     function setUp() public {
 23 |     |         vm.startPrank(admin);
 24 |     |         // --- Registry Setup ---
 25 |     |         ProjectRegistry registryImpl = new ProjectRegistry();
 26 |     |         bytes memory registryInitData = abi.encodeCall(ProjectRegistry.initialize, ());
 27 |     |         ERC1967Proxy registryProxy = new ERC1967Proxy(address(registryImpl), registryInitData);
 28 |     |         registry = ProjectRegistry(address(registryProxy));
 29 |     | 
 30 |     |         // --- Credit Setup ---
 31 |     |         DynamicImpactCredit creditImpl = new DynamicImpactCredit(address(registry));
 32 |     |         bytes memory creditInitData = abi.encodeCall(DynamicImpactCredit.initialize, ("ipfs://collection"));
 33 |     |         ERC1967Proxy creditProxy = new ERC1967Proxy(address(creditImpl), creditInitData);
 34 |     |         credit = DynamicImpactCredit(address(creditProxy));
 35 |     | 
 36 |     |         // --- dMRVManager Setup ---
 37 |     |         DMRVManager dMRVManagerImpl = new DMRVManager(address(registry), address(credit));
 38 |     |         bytes memory dMRVManagerInitData = abi.encodeCall(DMRVManager.initialize, ());
 39 |     |         ERC1967Proxy dMRVManagerProxy = new ERC1967Proxy(address(dMRVManagerImpl), dMRVManagerInitData);
 40 |     |         dMRVManager = DMRVManager(address(dMRVManagerProxy));
 41 |     | 
 42 |     |         // --- Role Setup ---
 43 |     |         dMRVManager.grantRole(dMRVManager.ORACLE_ROLE(), oracle);
 44 |     |         credit.grantRole(credit.DMRV_MANAGER_ROLE(), address(dMRVManager));
 45 |     | 
 46 |     |         vm.stopPrank();
 47 |     | 
 48 |     |         // --- Initial State ---
 49 |     |         // Register and approve a project
 50 |     |         vm.prank(projectOwner);
 51 |     |         registry.registerProject(projectId, "ipfs://initial.json");
 52 |     |         vm.prank(admin);
 53 |     |         registry.setProjectStatus(projectId, ProjectRegistry.ProjectStatus.Active);
 54 |     | 
 55 |     |         // Make an initial verification request
 56 |     |         vm.prank(projectOwner);
 57 |     |         requestId = dMRVManager.requestVerification(projectId);
 58 |     |     }
 59 |     | 
 60 |     |     function test_RequestVerification_RevertsForNonActiveProject() public {
 61 |     |         // Register a new project, leave it in Pending state
 62 |     |         vm.prank(projectOwner);
 63 |     |         bytes32 pendingProjectId = keccak256("Pending Project");
 64 |     |         registry.registerProject(pendingProjectId, "ipfs://pending.json");
 65 |     | 
 66 |     |         vm.prank(projectOwner);
 67 |     |         vm.expectRevert(DMRVManager__ProjectNotActive.selector);
 68 |     |         dMRVManager.requestVerification(pendingProjectId);
 69 |     |     }
 70 |     | 
 71 |     |     function test_FulfillVerification_RevertsForNonExistentRequest() public {
 72 |     |         bytes32 nonExistentRequestId = keccak256("non-existent");
 73 |     |         bytes memory data = abi.encode(100, false, bytes32(0), "ipfs://new.json");
 74 |     | 
 75 |     |         vm.prank(oracle);
 76 |     |         vm.expectRevert(DMRVManager__RequestNotFound.selector);
 77 |     |         dMRVManager.fulfillVerification(nonExistentRequestId, data);
 78 |     |     }
 79 |     | 
 80 |     |     function test_FulfillVerification_RevertsWhenAlreadyFulfilled() public {
 81 |     |         bytes memory data = abi.encode(100, false, bytes32(0), "ipfs://new.json");
 82 |     | 
 83 |     |         // Fulfill it once
 84 |     |         vm.prank(oracle);
 85 |     |         dMRVManager.fulfillVerification(requestId, data);
 86 |     | 
 87 |     |         // Try to fulfill it again
 88 |     |         vm.prank(oracle);
 89 |     |         vm.expectRevert(DMRVManager__RequestAlreadyFulfilled.selector);
 90 |     |         dMRVManager.fulfillVerification(requestId, data);
 91 |     |     }
 92 |     | }
 93 |     | 

/home/phantom/Documents/azemora/azemora-contracts/test/dMRVManager/dMRVManager.uncovered.t.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | pragma solidity ^0.8.20;
   3 |     | 
   4 |     | import "forge-std/Test.sol";
   5 |     | import "../../src/core/dMRVManager.sol";
   6 |     | import "../../src/core/ProjectRegistry.sol";
   7 |     | import "../../src/core/DynamicImpactCredit.sol";
   8 |     | import "@openzeppelin/contracts/proxy/ERC1967/ERC1967Proxy.sol";
   9 |     | 
  10 |     | contract DMRVManagerTest is Test {
  11 |     |     DMRVManager manager;
  12 |     |     ProjectRegistry registry;
  13 |     |     DynamicImpactCredit credit;
  14 |     | 
  15 |     |     address admin = address(0xA11CE);
  16 |     |     address oracle = address(0x0AC1E);
  17 |     |     address verifier = address(0xC1E4);
  18 |     |     address projectOwner = address(0x044E);
  19 |     | 
  20 |     |     bytes32 projectId = keccak256("Test Project");
  21 |     | 
  22 |     |     function setUp() public {
  23 |     |         // Deploy and set up the contract infrastructure
  24 |     |         vm.startPrank(admin);
  25 |     | 
  26 |     |         // 1. Deploy Registry
  27 |     |         ProjectRegistry registryImpl = new ProjectRegistry();
  28 |     |         bytes memory registryInitData = abi.encodeCall(ProjectRegistry.initialize, ());
  29 |     |         ERC1967Proxy registryProxy = new ERC1967Proxy(address(registryImpl), registryInitData);
  30 |     |         registry = ProjectRegistry(address(registryProxy));
  31 |     |         registry.grantRole(registry.VERIFIER_ROLE(), verifier);
  32 |     | 
  33 |     |         // 2. Deploy DynamicImpactCredit
  34 |     |         DynamicImpactCredit creditImpl = new DynamicImpactCredit(address(registry));
  35 |     |         bytes memory creditInitData = abi.encodeCall(DynamicImpactCredit.initialize, ("ipfs://contract-metadata.json"));
  36 |     |         ERC1967Proxy creditProxy = new ERC1967Proxy(address(creditImpl), creditInitData);
  37 |     |         credit = DynamicImpactCredit(address(creditProxy));
  38 |     | 
  39 |     |         // 3. Deploy DMRVManager
  40 |     |         DMRVManager managerImpl = new DMRVManager(address(registry), address(credit));
  41 |     |         bytes memory managerInitData = abi.encodeCall(DMRVManager.initialize, ());
  42 |     |         ERC1967Proxy managerProxy = new ERC1967Proxy(address(managerImpl), managerInitData);
  43 |     |         manager = DMRVManager(address(managerProxy));
  44 |     | 
  45 |     |         // 4. Set up roles
  46 |     |         credit.grantRole(credit.DMRV_MANAGER_ROLE(), address(manager));
  47 |     |         credit.grantRole(credit.METADATA_UPDATER_ROLE(), address(manager));
  48 |     |         manager.grantRole(manager.ORACLE_ROLE(), oracle);
  49 |     | 
  50 |     |         vm.stopPrank();
  51 |     | 
  52 |     |         // 5. Register and activate a test project
  53 |     |         vm.prank(projectOwner);
  54 |     |         registry.registerProject(projectId, "ipfs://initial.json");
  55 |     | 
  56 |     |         vm.prank(verifier);
  57 |     |         registry.setProjectStatus(projectId, ProjectRegistry.ProjectStatus.Active);
  58 |     |     }
  59 |     | 
  60 |     |     /* ---------- Basic Functionality Tests ---------- */
  61 |     | 
  62 |     |     function test_Initialization() public view {
  63 |     |         assertEq(address(manager.projectRegistry()), address(registry));
  64 |     |         assertEq(address(manager.creditContract()), address(credit));
  65 |     |         assertTrue(manager.hasRole(manager.ORACLE_ROLE(), oracle));
  66 |     |         assertTrue(manager.hasRole(manager.DEFAULT_ADMIN_ROLE(), admin));
  67 |     |     }
  68 |     | 
  69 |     |     function test_RequestVerification() public {
  70 |     |         vm.prank(projectOwner);
  71 |     |         bytes32 requestId = manager.requestVerification(projectId);
  72 |     | 
  73 |     |         // Verify requestId is not zero
  74 |     |         assertTrue(requestId != bytes32(0));
  75 |     |     }
  76 |     | 
  77 |     |     /* ---------- Oracle Fulfillment Tests ---------- */
  78 |     | 
  79 |     |     function test_OracleFulfillment_MintCredits() public {
  80 |     |         // 1. Create a verification request
  81 |     |         vm.prank(projectOwner);
  82 |     |         bytes32 requestId = manager.requestVerification(projectId);
  83 |     | 
  84 |     |         // 2. Prepare oracle data for minting 100 credits
  85 |     |         uint256 creditAmount = 100;
  86 |     |         string memory metadataURI = "ipfs://new-verification.json";
  87 |     |         bool updateMetadataOnly = false;
  88 |     |         bytes32 signature = keccak256(abi.encodePacked("test-signature"));
  89 |     | 
  90 |     |         // 3. Encode the data according to our expected format
  91 |     |         bytes memory data = abi.encode(creditAmount, updateMetadataOnly, signature, metadataURI);
  92 |     | 
  93 |     |         // 4. Oracle fulfills the verification
  94 |     |         vm.prank(oracle);
  95 |     |         manager.fulfillVerification(requestId, data);
  96 |     | 
  97 |     |         // 5. Check that credits were minted to project owner
  98 |     |         assertEq(credit.balanceOf(projectOwner, uint256(projectId)), 100);
  99 |     |         assertEq(credit.uri(uint256(projectId)), metadataURI);
 100 |     |     }
 101 |     | 
 102 |     |     function test_OracleFulfillment_UpdateMetadataOnly() public {
 103 |     |         // 1. First mint some initial credits directly instead of calling the other test
 104 |     |         vm.prank(projectOwner);
 105 |     |         bytes32 initialRequestId = manager.requestVerification(projectId);
 106 |     | 
 107 |     |         // Set up initial minting data
 108 |     |         bytes memory initialData = abi.encode(
 109 |     |             uint256(100), // creditAmount
 110 |     |             false, // updateMetadataOnly
 111 |     |             bytes32(0), // signature
 112 |     |             "ipfs://initial.json" // metadataURI
 113 |     |         );
 114 |     | 
 115 |     |         vm.prank(oracle);
 116 |     |         manager.fulfillVerification(initialRequestId, initialData);
 117 |     | 
 118 |     |         uint256 initialBalance = credit.balanceOf(projectOwner, uint256(projectId));
 119 |     | 
 120 |     |         // 2. Create a new verification request
 121 |     |         vm.prank(projectOwner);
 122 |     |         bytes32 requestId = manager.requestVerification(projectId);
 123 |     | 
 124 |     |         // 3. Prepare oracle data for updating metadata only
 125 |     |         uint256 creditAmount = 0; // No new credits
 126 |     |         string memory metadataURI = "ipfs://updated-verification.json";
 127 |     |         bool updateMetadataOnly = true;
 128 |     |         bytes32 signature = keccak256(abi.encodePacked("test-signature-2"));
 129 |     | 
 130 |     |         // 4. Encode the data
 131 |     |         bytes memory data = abi.encode(creditAmount, updateMetadataOnly, signature, metadataURI);
 132 |     | 
 133 |     |         // 5. Oracle fulfills the verification
 134 |     |         vm.prank(oracle);
 135 |     |         manager.fulfillVerification(requestId, data);
 136 |     | 
 137 |     |         // 6. Check that only metadata was updated (balance unchanged)
 138 |     |         assertEq(credit.balanceOf(projectOwner, uint256(projectId)), initialBalance);
 139 |     |         assertEq(credit.uri(uint256(projectId)), metadataURI);
 140 |     |     }
 141 |     | 
 142 |     |     function test_OracleFulfillment_RecordsUriHistory() public {
 143 |     |         uint256 tokenId = uint256(projectId);
 144 |     | 
 145 |     |         // --- 1. First fulfillment (mints and sets initial URI) ---
 146 |     |         string memory uri1 = "ipfs://report-v1.json";
 147 |     |         bytes memory data1 = abi.encode(uint256(100), false, bytes32(0), uri1);
 148 |     |         // Request by projectOwner
 149 |     |         vm.prank(projectOwner);
 150 |     |         bytes32 requestId1 = manager.requestVerification(projectId);
 151 |     |         // Fulfill by oracle
 152 |     |         vm.prank(oracle);
 153 |     |         manager.fulfillVerification(requestId1, data1);
 154 |     | 
 155 |     |         // --- 2. Second fulfillment (updates metadata only) ---
 156 |     |         string memory uri2 = "ipfs://report-v2.json";
 157 |     |         bytes memory data2 = abi.encode(uint256(0), true, bytes32(0), uri2);
 158 |     |         // Request by projectOwner
 159 |     |         vm.prank(projectOwner);
 160 |     |         bytes32 requestId2 = manager.requestVerification(projectId);
 161 |     |         // Fulfill by oracle
 162 |     |         vm.prank(oracle);
 163 |     |         manager.fulfillVerification(requestId2, data2);
 164 |     | 
 165 |     |         // --- 3. Third fulfillment (mints more credits and updates URI again) ---
 166 |     |         string memory uri3 = "ipfs://report-v3.json";
 167 |     |         bytes memory data3 = abi.encode(uint256(50), false, bytes32(0), uri3);
 168 |     |         // Request by projectOwner
 169 |     |         vm.prank(projectOwner);
 170 |     |         bytes32 requestId3 = manager.requestVerification(projectId);
 171 |     |         // Fulfill by oracle
 172 |     |         vm.prank(oracle);
 173 |     |         manager.fulfillVerification(requestId3, data3);
 174 |     | 
 175 |     |         // --- 4. Verify the entire URI history ---
 176 |     |         string[] memory history = credit.getTokenURIHistory(tokenId);
 177 |     | 
 178 |     |         assertEq(history.length, 3, "URI history should have 3 entries");
 179 |     |         assertEq(history[0], uri1, "First URI in history is incorrect");
 180 |     |         assertEq(history[1], uri2, "Second URI in history is incorrect");
 181 |     |         assertEq(history[2], uri3, "Third URI in history is incorrect");
 182 |     | 
 183 |     |         // Also check that the current URI is the latest one
 184 |     |         assertEq(credit.uri(tokenId), uri3, "Current URI should be the latest one");
 185 |     |         assertEq(credit.balanceOf(projectOwner, tokenId), 150, "Final balance should be sum of mints");
 186 |     |     }
 187 |     | 
 188 |     |     /* ---------- Admin Functions ---------- */
 189 |     | 
 190 |     |     function test_AdminSubmitVerification() public {
 191 |     |         // Admin can directly set verification without oracle
 192 |     |         vm.prank(admin);
 193 |     |         manager.adminSubmitVerification(projectId, 50, "ipfs://admin-set.json", false);
 194 |     | 
 195 |     |         // Check credits were minted
 196 |     |         assertEq(credit.balanceOf(projectOwner, uint256(projectId)), 50);
 197 |     |         assertEq(credit.uri(uint256(projectId)), "ipfs://admin-set.json");
 198 |     |     }
 199 |     | 
 200 |     |     /* ---------- Error Cases ---------- */
 201 |     | 
 202 |     |     function test_RequestVerification_RequiresActiveProject() public {
 203 |     |         // Create an inactive project
 204 |     |         bytes32 inactiveId = keccak256("Inactive Project");
 205 |     |         vm.prank(projectOwner);
 206 |     |         registry.registerProject(inactiveId, "ipfs://inactive.json");
 207 |     |         // Note: We don't activate it
 208 |     | 
 209 |     |         // Attempt to request verification should fail
 210 |     |         vm.prank(projectOwner);
 211 |     |         vm.expectRevert(DMRVManager__ProjectNotActive.selector);
 212 |     |         manager.requestVerification(inactiveId);
 213 |     |     }
 214 |     | 
 215 |     |     function test_FulfillVerification_OnlyOracle() public {
 216 |     |         // 1. Create a request
 217 |     |         vm.prank(projectOwner);
 218 |     |         bytes32 requestId = manager.requestVerification(projectId);
 219 |     | 
 220 |     |         // 2. Prepare some data
 221 |     |         bytes memory data = abi.encode(uint256(100), false, bytes32(0), "ipfs://test.json");
 222 |     | 
 223 |     |         // 3. Attempt to fulfill from non-oracle account
 224 |     |         vm.prank(projectOwner);
 225 |     |         vm.expectRevert(); // Will revert due to AccessControl
 226 |     |         manager.fulfillVerification(requestId, data);
 227 |     |     }
 228 |     | 
 229 |     |     function test_FulfillVerification_CannotFulfillTwice() public {
 230 |     |         // 1. Create a request
 231 |     |         vm.prank(projectOwner);
 232 |     |         bytes32 requestId = manager.requestVerification(projectId);
 233 |     | 
 234 |     |         // 2. Prepare some data
 235 |     |         bytes memory data = abi.encode(uint256(100), false, bytes32(0), "ipfs://test.json");
 236 |     | 
 237 |     |         // 3. Oracle fulfills the verification
 238 |     |         vm.prank(oracle);
 239 |     |         manager.fulfillVerification(requestId, data);
 240 |     | 
 241 |     |         // 4. Try to fulfill again should fail
 242 |     |         vm.prank(oracle);
 243 |     |         vm.expectRevert(DMRVManager__RequestAlreadyFulfilled.selector);
 244 |     |         manager.fulfillVerification(requestId, data);
 245 |     |     }
 246 |     | 
 247 |     |     /* ---------- Pausable Tests ---------- */
 248 |     | 
 249 |     |     function test_PauseAndUnpause() public {
 250 |     |         bytes32 pauserRole = manager.PAUSER_ROLE();
 251 |     | 
 252 |     |         vm.startPrank(admin);
 253 |     |         // Admin has pauser role by default from setUp
 254 |     |         manager.pause();
 255 |     |         assertTrue(manager.paused());
 256 |     |         manager.unpause();
 257 |     |         assertFalse(manager.paused());
 258 |     |         vm.stopPrank();
 259 |     | 
 260 |     |         // Non-pauser cannot pause
 261 |     |         vm.prank(projectOwner);
 262 |     |         vm.expectRevert(
 263 |     |             abi.encodeWithSelector(
 264 |     |                 bytes4(keccak256("AccessControlUnauthorizedAccount(address,bytes32)")), projectOwner, pauserRole
 265 |     |             )
 266 |     |         );
 267 |     |         manager.pause();
 268 |     |     }
 269 |     | 
 270 |     |     function test_RevertsWhenPaused() public {
 271 |     |         vm.prank(admin);
 272 |     |         manager.pause();
 273 |     | 
 274 |     |         bytes4 expectedRevert = bytes4(keccak256("EnforcedPause()"));
 275 |     | 
 276 |     |         vm.prank(projectOwner);
 277 |     |         vm.expectRevert(expectedRevert);
 278 |     |         manager.requestVerification(projectId);
 279 |     | 
 280 |     |         vm.prank(oracle);
 281 |     |         bytes memory data = abi.encode(1, false, bytes32(0), "ipfs://fail.json");
 282 |     |         vm.expectRevert(expectedRevert);
 283 |     |         manager.fulfillVerification(bytes32(0), data);
 284 |     | 
 285 |     |         vm.prank(admin);
 286 |     |         vm.expectRevert(expectedRevert);
 287 |     |         manager.adminSubmitVerification(projectId, 1, "ipfs://fail.json", false);
 288 |     |     }
 289 |     | }
 290 |     | 

/home/phantom/Documents/azemora/azemora-contracts/test/dynamicImpactCredit/DynamicImpactCredit.complex.t.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | pragma solidity ^0.8.20;
   3 |     | 
   4 |     | import "forge-std/Test.sol";
   5 |     | import "../dynamicImpactCredit/DynamicImpactCredit.t.sol";
   6 |     | import "../../src/core/ProjectRegistry.sol";
   7 |     | import "../../src/core/DynamicImpactCredit.sol";
   8 |     | import "../../src/core/dMRVManager.sol";
   9 |     | import "@openzeppelin/contracts/proxy/ERC1967/ERC1967Proxy.sol";
  10 |     | import "@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol";
  11 |     | 
  12 |     | // A V2 contract for testing that includes a new function and a new event
  13 |     | contract DynamicImpactCreditExtendedV2 is DynamicImpactCredit {
  14 |     |     uint256 public constant VERSION = 2;
  15 |     | 
  16 |     |     event RetiredWithReason(address indexed retirer, uint256 indexed tokenId, uint256 amount, string reason);
  17 |     | 
  18 |     |     struct RetirementInfo {
  19 |     |         uint256 timestamp;
  20 |     |         uint256 totalRetired;
  21 |     |     }
  22 |     | 
  23 |     |     mapping(uint256 => mapping(address => RetirementInfo)) public retirementInfo;
  24 |     | 
  25 |     |     constructor(address registry) DynamicImpactCredit(registry) {}
  26 |     | 
  27 |     |     function retireWithReason(address from, bytes32 id, uint256 amount, string calldata reason) external {
  28 |     |         super.retire(from, id, amount);
  29 |     |         uint256 tokenId = uint256(id);
  30 |     |         RetirementInfo storage info = retirementInfo[tokenId][from];
  31 |     |         info.timestamp = block.timestamp;
  32 |     |         info.totalRetired += amount;
  33 |     |         emit RetiredWithReason(from, tokenId, amount, reason);
  34 |     |     }
  35 |     | 
  36 |     |     function getRetirementInfo(bytes32 id, address user) external view returns (uint256, uint256) {
  37 |     |         uint256 tokenId = uint256(id);
  38 |     |         RetirementInfo storage info = retirementInfo[tokenId][user];
  39 |     |         return (info.timestamp, info.totalRetired);
  40 |     |     }
  41 |     | }
  42 |     | 
  43 |     | contract DynamicImpactCreditComplexTest is Test {
  44 |     |     DynamicImpactCredit credit;
  45 |     |     ProjectRegistry registry;
  46 |     |     address admin = address(0xA11CE);
  47 |     |     address dmrvManager = address(0xB01D);
  48 |     |     address verifier = address(0xC1E4);
  49 |     | 
  50 |     |     // Create multiple user addresses
  51 |     |     address user1 = address(0xCAFE);
  52 |     |     address user2 = address(0xBEEF);
  53 |     |     address user3 = address(0xFACE);
  54 |     | 
  55 |     |     // Project data for realistic simulation
  56 |     |     struct Project {
  57 |     |         bytes32 id;
  58 |     |         string name;
  59 |     |         string baseURI;
  60 |     |         uint256 initialCredits;
  61 |     |     }
  62 |     | 
  63 |     |     Project[] projects;
  64 |     | 
  65 |     |     function setUp() public {
  66 |     |         vm.startPrank(admin);
  67 |     |         // Deploy Registry
  68 |     |         ProjectRegistry registryImpl = new ProjectRegistry();
  69 |     |         registry = ProjectRegistry(
  70 |     |             address(new ERC1967Proxy(address(registryImpl), abi.encodeCall(ProjectRegistry.initialize, ())))
  71 |     |         );
  72 |     |         registry.grantRole(registry.VERIFIER_ROLE(), verifier);
  73 |     | 
  74 |     |         // Deploy Credit Contract
  75 |     |         DynamicImpactCredit impl = new DynamicImpactCredit(address(registry));
  76 |     |         credit = DynamicImpactCredit(
  77 |     |             address(
  78 |     |                 new ERC1967Proxy(
  79 |     |                     address(impl), abi.encodeCall(DynamicImpactCredit.initialize, ("ipfs://contract-metadata.json"))
  80 |     |                 )
  81 |     |             )
  82 |     |         );
  83 |     | 
  84 |     |         credit.grantRole(credit.DMRV_MANAGER_ROLE(), dmrvManager);
  85 |     |         credit.grantRole(credit.METADATA_UPDATER_ROLE(), admin);
  86 |     |         vm.stopPrank();
  87 |     | 
  88 |     |         // Set up some realistic projects
  89 |     |         projects.push(
  90 |     |             Project({
  91 |     |                 id: bytes32(uint256(101)),
  92 |     |                 name: "Reforestation Project Alpha",
  93 |     |                 baseURI: "ipfs://reforest-alpha/metadata-",
  94 |     |                 initialCredits: 10000
  95 |     |             })
  96 |     |         );
  97 |     | 
  98 |     |         projects.push(
  99 |     |             Project({
 100 |     |                 id: bytes32(uint256(202)),
 101 |     |                 name: "Solar Farm Beta",
 102 |     |                 baseURI: "ipfs://solar-beta/metadata-",
 103 |     |                 initialCredits: 5000
 104 |     |             })
 105 |     |         );
 106 |     | 
 107 |     |         projects.push(
 108 |     |             Project({
 109 |     |                 id: bytes32(uint256(303)),
 110 |     |                 name: "Methane Capture Gamma",
 111 |     |                 baseURI: "ipfs://methane-gamma/metadata-",
 112 |     |                 initialCredits: 7500
 113 |     |             })
 114 |     |         );
 115 |     |     }
 116 |     | 
 117 |     |     // Complex test: Full lifecycle simulation with dMRV updates
 118 |     |     function testComplex_FullLifecycle() public {
 119 |     |         // STEP 1: Initial project registrations and credit minting
 120 |     |         // Register and activate projects
 121 |     |         for (uint256 i = 0; i < projects.length; i++) {
 122 |     |             vm.prank(user1); // Owner registers
 123 |     |             registry.registerProject(projects[i].id, "ipfs://project-meta");
 124 |     |             vm.prank(verifier); // Verifier activates
 125 |     |             registry.setProjectStatus(projects[i].id, ProjectRegistry.ProjectStatus.Active);
 126 |     |         }
 127 |     | 
 128 |     |         vm.startPrank(dmrvManager);
 129 |     | 
 130 |     |         for (uint256 i = 0; i < projects.length; i++) {
 131 |     |             // Mint initial credits to user1
 132 |     |             credit.mintCredits(
 133 |     |                 user1,
 134 |     |                 projects[i].id,
 135 |     |                 projects[i].initialCredits,
 136 |     |                 string(abi.encodePacked(projects[i].baseURI, "v1.json"))
 137 |     |             );
 138 |     |         }
 139 |     | 
 140 |     |         vm.stopPrank();
 141 |     | 
 142 |     |         // STEP 2: User1 transfers some credits to other users
 143 |     |         vm.startPrank(user1);
 144 |     | 
 145 |     |         // Transfer half of project 0 credits to user2
 146 |     |         uint256 transferAmount1 = projects[0].initialCredits / 2;
 147 |     |         credit.safeTransferFrom(user1, user2, uint256(projects[0].id), transferAmount1, "");
 148 |     | 
 149 |     |         // Transfer 1/3 of project 1 credits to user3
 150 |     |         uint256 transferAmount2 = projects[1].initialCredits / 3;
 151 |     |         credit.safeTransferFrom(user1, user3, uint256(projects[1].id), transferAmount2, "");
 152 |     | 
 153 |     |         vm.stopPrank();
 154 |     | 
 155 |     |         // Verify balances after transfers
 156 |     |         assertEq(credit.balanceOf(user1, uint256(projects[0].id)), projects[0].initialCredits - transferAmount1);
 157 |     |         assertEq(credit.balanceOf(user2, uint256(projects[0].id)), transferAmount1);
 158 |     |         assertEq(credit.balanceOf(user1, uint256(projects[1].id)), projects[1].initialCredits - transferAmount2);
 159 |     |         assertEq(credit.balanceOf(user3, uint256(projects[1].id)), transferAmount2);
 160 |     | 
 161 |     |         // STEP 3: Simulate dMRV update - metadata is updated to reflect new measurement
 162 |     |         vm.startPrank(admin);
 163 |     | 
 164 |     |         // Update metadata for project 0 to reflect new verification data
 165 |     |         string memory newURI = string(abi.encodePacked(projects[0].baseURI, "v2-verified.json"));
 166 |     |         credit.setTokenURI(projects[0].id, newURI);
 167 |     | 
 168 |     |         vm.stopPrank();
 169 |     | 
 170 |     |         // Verify metadata was updated
 171 |     |         assertEq(credit.uri(uint256(projects[0].id)), newURI);
 172 |     |         string[] memory history = credit.getTokenURIHistory(uint256(projects[0].id));
 173 |     |         assertEq(history.length, 2);
 174 |     |         assertEq(history[0], string(abi.encodePacked(projects[0].baseURI, "v1.json")));
 175 |     |         assertEq(history[1], newURI);
 176 |     | 
 177 |     |         // STEP 4: Users retire some credits
 178 |     |         vm.prank(user2);
 179 |     |         uint256 retireAmount1 = transferAmount1 / 2;
 180 |     |         credit.retire(user2, projects[0].id, retireAmount1);
 181 |     | 
 182 |     |         vm.prank(user3);
 183 |     |         uint256 retireAmount2 = transferAmount2;
 184 |     |         credit.retire(user3, projects[1].id, retireAmount2);
 185 |     | 
 186 |     |         // Verify balances after retirement
 187 |     |         assertEq(credit.balanceOf(user2, uint256(projects[0].id)), transferAmount1 - retireAmount1);
 188 |     |         assertEq(credit.balanceOf(user3, uint256(projects[1].id)), 0);
 189 |     | 
 190 |     |         // STEP 5: Upgrade to V2 with enhanced features
 191 |     |         DynamicImpactCreditExtendedV2 v2 = new DynamicImpactCreditExtendedV2(address(registry));
 192 |     | 
 193 |     |         vm.prank(admin);
 194 |     |         IUUPS(address(credit)).upgradeToAndCall(address(v2), "");
 195 |     | 
 196 |     |         // Cast to V2
 197 |     |         DynamicImpactCreditExtendedV2 creditV2 = DynamicImpactCreditExtendedV2(address(credit));
 198 |     | 
 199 |     |         // Verify upgrade was successful
 200 |     |         assertEq(creditV2.VERSION(), 2);
 201 |     | 
 202 |     |         // STEP 6: Use new V2 features
 203 |     |         vm.prank(user1);
 204 |     |         uint256 retireAmount3 = 100;
 205 |     |         creditV2.retireWithReason(user1, projects[2].id, retireAmount3, "Test reason");
 206 |     | 
 207 |     |         // Verify V2 specific data
 208 |     |         (uint256 timestamp, uint256 userTotal) = creditV2.getRetirementInfo(projects[2].id, user1);
 209 |     |         assertEq(timestamp, block.timestamp);
 210 |     |         assertEq(userTotal, retireAmount3);
 211 |     | 
 212 |     |         // Confirm old balances are preserved
 213 |     |         assertEq(creditV2.balanceOf(user1, uint256(projects[0].id)), projects[0].initialCredits - transferAmount1);
 214 |     |         assertEq(creditV2.balanceOf(user2, uint256(projects[0].id)), transferAmount1 - retireAmount1);
 215 |     | 
 216 |     |         // STEP 7: Mint additional credits with the new implementation
 217 |     |         bytes32 newProjectId = bytes32(uint256(404));
 218 |     |         vm.prank(user1);
 219 |     |         registry.registerProject(newProjectId, "new.json");
 220 |     |         vm.prank(verifier);
 221 |     |         registry.setProjectStatus(newProjectId, ProjectRegistry.ProjectStatus.Active);
 222 |     | 
 223 |     |         vm.prank(dmrvManager);
 224 |     |         creditV2.mintCredits(user1, newProjectId, 1000, "ipfs://new-project/metadata.json");
 225 |     | 
 226 |     |         assertEq(creditV2.balanceOf(user1, uint256(newProjectId)), 1000);
 227 |     |     }
 228 |     | 
 229 |     |     // Complex test: Batch operations and approvals
 230 |     |     function testComplex_BatchOperationsAndApprovals() public {
 231 |     |         // STEP 1: Mint multiple token types in a batch
 232 |     |         bytes32[] memory ids = new bytes32[](3);
 233 |     |         uint256[] memory amounts = new uint256[](3);
 234 |     |         string[] memory uris = new string[](3);
 235 |     | 
 236 |     |         for (uint256 i = 0; i < 3; i++) {
 237 |     |             ids[i] = projects[i].id;
 238 |     |             amounts[i] = projects[i].initialCredits;
 239 |     |             uris[i] = string(abi.encodePacked(projects[i].baseURI, "v1.json"));
 240 |     | 
 241 |     |             vm.prank(user1);
 242 |     |             registry.registerProject(ids[i], "meta.json");
 243 |     |             vm.prank(verifier);
 244 |     |             registry.setProjectStatus(ids[i], ProjectRegistry.ProjectStatus.Active);
 245 |     |         }
 246 |     | 
 247 |     |         vm.prank(dmrvManager);
 248 |     |         credit.batchMintCredits(user1, ids, amounts, uris);
 249 |     | 
 250 |     |         // Verify all credits were minted
 251 |     |         for (uint256 i = 0; i < 3; i++) {
 252 |     |             assertEq(credit.balanceOf(user1, uint256(ids[i])), amounts[i]);
 253 |     |             assertEq(credit.uri(uint256(ids[i])), uris[i]);
 254 |     |         }
 255 |     | 
 256 |     |         // STEP 2: User1 approves user2 to manage all tokens
 257 |     |         vm.prank(user1);
 258 |     |         credit.setApprovalForAll(user2, true);
 259 |     | 
 260 |     |         // STEP 3: User2 transfers from user1 to user3 using approval
 261 |     |         vm.startPrank(user2);
 262 |     | 
 263 |     |         // Transfer half of all projects from user1 to user3
 264 |     |         for (uint256 i = 0; i < 3; i++) {
 265 |     |             uint256 transferAmount = amounts[i] / 2;
 266 |     |             credit.safeTransferFrom(user1, user3, uint256(ids[i]), transferAmount, "");
 267 |     |         }
 268 |     | 
 269 |     |         // User2 also retires some credits on behalf of user1
 270 |     |         credit.retire(user1, ids[0], 100);
 271 |     | 
 272 |     |         vm.stopPrank();
 273 |     | 
 274 |     |         // Verify balances after transfers and retirement
 275 |     |         for (uint256 i = 0; i < 3; i++) {
 276 |     |             uint256 expectedUser1Balance = amounts[i] / 2;
 277 |     |             if (i == 0) expectedUser1Balance -= 100; // Account for retirement
 278 |     | 
 279 |     |             assertEq(credit.balanceOf(user1, uint256(ids[i])), expectedUser1Balance);
 280 |     |             assertEq(credit.balanceOf(user3, uint256(ids[i])), amounts[i] / 2);
 281 |     |         }
 282 |     | 
 283 |     |         // STEP 4: User1 revokes approval
 284 |     |         vm.prank(user1);
 285 |     |         credit.setApprovalForAll(user2, false);
 286 |     | 
 287 |     |         // STEP 5: User2 attempts to transfer more tokens (should fail)
 288 |     |         vm.prank(user2);
 289 |     |         vm.expectRevert(
 290 |     |             abi.encodeWithSelector(bytes4(keccak256("ERC1155MissingApprovalForAll(address,address)")), user2, user1)
 291 |     |         );
 292 |     |         credit.safeTransferFrom(user1, user3, uint256(ids[0]), 10, "");
 293 |     |     }
 294 |     | }
 295 |     | 

/home/phantom/Documents/azemora/azemora-contracts/test/dynamicImpactCredit/DynamicImpactCredit.fuzz.t.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | pragma solidity ^0.8.20;
   3 |     | 
   4 |     | import "forge-std/Test.sol";
   5 |     | import "../../src/core/ProjectRegistry.sol";
   6 |     | import "../../src/core/DynamicImpactCredit.sol";
   7 |     | import "@openzeppelin/contracts/proxy/ERC1967/ERC1967Proxy.sol";
   8 |     | 
   9 |     | contract DynamicImpactCreditFuzzTest is Test {
  10 |     |     DynamicImpactCredit credit;
  11 |     |     ProjectRegistry registry;
  12 |     |     address admin = address(0xA11CE);
  13 |     |     address dmrvManager = address(0xB01D);
  14 |     |     address user = address(0xCAFE);
  15 |     |     address verifier = address(0xC1E4);
  16 |     | 
  17 |     |     function setUp() public {
  18 |     |         vm.startPrank(admin);
  19 |     |         // Deploy Registry
  20 |     |         ProjectRegistry registryImpl = new ProjectRegistry();
  21 |     |         registry = ProjectRegistry(
  22 |     |             address(new ERC1967Proxy(address(registryImpl), abi.encodeCall(ProjectRegistry.initialize, ())))
  23 |     |         );
  24 |     |         registry.grantRole(registry.VERIFIER_ROLE(), verifier);
  25 |     | 
  26 |     |         // Deploy Credit Contract
  27 |     |         DynamicImpactCredit impl = new DynamicImpactCredit(address(registry));
  28 |     | 
  29 |     |         bytes memory initData = abi.encodeCall(DynamicImpactCredit.initialize, ("ipfs://contract-metadata.json"));
  30 |     | 
  31 |     |         ERC1967Proxy proxy = new ERC1967Proxy(address(impl), initData);
  32 |     |         credit = DynamicImpactCredit(address(proxy));
  33 |     | 
  34 |     |         credit.grantRole(credit.DMRV_MANAGER_ROLE(), dmrvManager);
  35 |     |         credit.grantRole(credit.METADATA_UPDATER_ROLE(), admin);
  36 |     |         vm.stopPrank();
  37 |     |     }
  38 |     | 
  39 |     |     // Fuzz test: Batch mint with varying array lengths and contents
  40 |     |     function testFuzz_BatchMintArrays(uint8 arraySize, uint64 seed) public {
  41 |     |         // Bound arraySize to avoid extreme values
  42 |     |         arraySize = uint8(bound(arraySize, 1, 20));
  43 |     | 
  44 |     |         // Create arrays of proper length
  45 |     |         bytes32[] memory ids = new bytes32[](arraySize);
  46 |     |         uint256[] memory amounts = new uint256[](arraySize);
  47 |     |         string[] memory uris = new string[](arraySize);
  48 |     | 
  49 |     |         // Generate deterministic but varied data based on seed
  50 |     |         for (uint8 i = 0; i < arraySize; i++) {
  51 |     |             // Ensure unique IDs by using the index
  52 |     |             ids[i] = keccak256(abi.encode(seed, i + 1));
  53 |     |             amounts[i] = uint256(keccak256(abi.encode(seed, "amount", i))) % 1000 + 1;
  54 |     |             uris[i] = string(
  55 |     |                 abi.encodePacked("ipfs://", vm.toString(uint256(keccak256(abi.encode(seed, "uri", i))) % 1000000))
  56 |     |             );
  57 |     |             // Register and activate project
  58 |     |             vm.prank(user);
  59 |     |             registry.registerProject(ids[i], "meta.json");
  60 |     |             vm.prank(verifier);
  61 |     |             registry.setProjectStatus(ids[i], ProjectRegistry.ProjectStatus.Active);
  62 |     |         }
  63 |     | 
  64 |     |         vm.prank(dmrvManager);
  65 |     |         credit.batchMintCredits(user, ids, amounts, uris);
  66 |     | 
  67 |     |         // Verify all tokens were minted with correct amounts and URIs
  68 |     |         for (uint8 i = 0; i < arraySize; i++) {
  69 |     |             assertEq(credit.balanceOf(user, uint256(ids[i])), amounts[i], "Balance mismatch for token ID");
  70 |     |             assertEq(credit.uri(uint256(ids[i])), uris[i], "URI mismatch for token ID");
  71 |     |         }
  72 |     |     }
  73 |     | 
  74 |     |     // Fuzz test: Retirement with random amounts
  75 |     |     function testFuzz_Retire(uint256 seed, uint256 mintAmount, uint256 retireAmount) public {
  76 |     |         bytes32 projectId = keccak256(abi.encode(seed));
  77 |     |         // Constrain values to reasonable ranges
  78 |     |         mintAmount = bound(mintAmount, 1, 1000000);
  79 |     |         retireAmount = bound(retireAmount, 1, mintAmount);
  80 |     | 
  81 |     |         // Register and activate project
  82 |     |         vm.prank(user);
  83 |     |         registry.registerProject(projectId, "meta.json");
  84 |     |         vm.prank(verifier);
  85 |     |         registry.setProjectStatus(projectId, ProjectRegistry.ProjectStatus.Active);
  86 |     | 
  87 |     |         // Mint the tokens
  88 |     |         vm.prank(dmrvManager);
  89 |     |         credit.mintCredits(user, projectId, mintAmount, string(abi.encodePacked("ipfs://token", vm.toString(seed))));
  90 |     | 
  91 |     |         // Retire some tokens
  92 |     |         vm.prank(user);
  93 |     |         credit.retire(user, projectId, retireAmount);
  94 |     | 
  95 |     |         // Verify the remaining balance
  96 |     |         assertEq(credit.balanceOf(user, uint256(projectId)), mintAmount - retireAmount);
  97 |     |     }
  98 |     | 
  99 |     |     // Fuzz test: URI updates with random strings
 100 |     |     function testFuzz_URIUpdates(uint256 seed, string calldata initialURI, string calldata updatedURI) public {
 101 |     |         bytes32 projectId = keccak256(abi.encode(seed));
 102 |     | 
 103 |     |         // Register and activate project
 104 |     |         vm.prank(user);
 105 |     |         registry.registerProject(projectId, "meta.json");
 106 |     |         vm.prank(verifier);
 107 |     |         registry.setProjectStatus(projectId, ProjectRegistry.ProjectStatus.Active);
 108 |     | 
 109 |     |         // Mint with initial URI
 110 |     |         vm.prank(dmrvManager);
 111 |     |         credit.mintCredits(user, projectId, 100, initialURI);
 112 |     | 
 113 |     |         // Update URI
 114 |     |         vm.prank(admin);
 115 |     |         credit.setTokenURI(projectId, updatedURI);
 116 |     | 
 117 |     |         // Verify the URI was updated
 118 |     |         assertEq(credit.uri(uint256(projectId)), updatedURI);
 119 |     | 
 120 |     |         // Verify history
 121 |     |         string[] memory history = credit.getTokenURIHistory(uint256(projectId));
 122 |     |         assertEq(history.length, 2, "History length should be 2");
 123 |     |         assertEq(history[0], initialURI, "Initial URI mismatch in history");
 124 |     |         assertEq(history[1], updatedURI, "Updated URI mismatch in history");
 125 |     |     }
 126 |     | }
 127 |     | 

/home/phantom/Documents/azemora/azemora-contracts/test/dynamicImpactCredit/DynamicImpactCredit.invariant.t.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | pragma solidity ^0.8.20;
   3 |     | 
   4 |     | import "forge-std/Test.sol";
   5 |     | import "./DynamicImpactCredit.t.sol";
   6 |     | import "../../src/core/ProjectRegistry.sol";
   7 |     | import "../../src/core/DynamicImpactCredit.sol";
   8 |     | import "@openzeppelin/contracts/proxy/ERC1967/ERC1967Proxy.sol";
   9 |     | 
  10 |     | /*:.+.*.*:.*..:..*.*:.*..:.+.*.*:*/
  11 |     | /*                       INVARIANT TESTING                      */
  12 |     | 
  13 |     | // Handler contract to perform actions on the credit contract
  14 |     | contract CreditHandler is Test {
  15 |     |     DynamicImpactCredit credit;
  16 |     |     ProjectRegistry registry;
  17 |     |     address admin;
  18 |     |     address dmrvManager;
  19 |     |     address verifier;
  20 |     |     address[] users;
  21 |     |     mapping(address => mapping(bytes32 => uint256)) public userBalances;
  22 |     |     mapping(bytes32 => uint256) public totalSupply;
  23 |     |     mapping(bytes32 => uint256) public retiredAmount;
  24 |     | 
  25 |     |     // Track which token IDs have been minted
  26 |     |     bytes32[] public mintedTokenIds;
  27 |     |     mapping(bytes32 => bool) public tokenIdExists;
  28 |     | 
  29 |     |     constructor(
  30 |     |         DynamicImpactCredit _credit,
  31 |     |         ProjectRegistry _registry,
  32 |     |         address _admin,
  33 |     |         address _dmrvManager,
  34 |     |         address _verifier
  35 |     |     ) {
  36 |     |         credit = _credit;
  37 |     |         registry = _registry;
  38 |     |         admin = _admin;
  39 |     |         dmrvManager = _dmrvManager;
  40 |     |         verifier = _verifier;
  41 |     | 
  42 |     |         // Create a set of test users
  43 |     |         for (uint256 i = 0; i < 5; i++) {
  44 |     |             users.push(address(uint160(0x1000 + i)));
  45 |     |         }
  46 |     |     }
  47 |     | 
  48 |     |     // Add a function to get the length of mintedTokenIds
  49 |     |     function getMintedTokenIdsLength() public view returns (uint256) {
  50 |     |         return mintedTokenIds.length;
  51 |     |     }
  52 |     | 
  53 |     |     // Mint credits to a random user
  54 |     |     function mintCredits(uint256 tokenIdSeed, uint256 amount, string calldata uri) public {
  55 |     |         // Ensure tokenId is a reasonable value and not zero
  56 |     |         bytes32 projectId = keccak256(abi.encodePacked("project", tokenIdSeed % 10));
  57 |     |         amount = bound(amount, 1, 10000);
  58 |     | 
  59 |     |         // Select a random user
  60 |     |         address user = users[tokenIdSeed % users.length];
  61 |     | 
  62 |     |         // Register and approve the project first
  63 |     |         if (!tokenIdExists[projectId]) {
  64 |     |             vm.prank(user); // Project owner registers
  65 |     |             registry.registerProject(projectId, "ipfs://meta.json");
  66 |     |             vm.prank(verifier);
  67 |     |             registry.setProjectStatus(projectId, ProjectRegistry.ProjectStatus.Active);
  68 |     |         }
  69 |     | 
  70 |     |         vm.prank(dmrvManager);
  71 |     |         credit.mintCredits(user, projectId, amount, uri);
  72 |     | 
  73 |     |         // Track state for invariant testing
  74 |     |         userBalances[user][projectId] += amount;
  75 |     |         totalSupply[projectId] += amount;
  76 |     | 
  77 |     |         // Track this token ID
  78 |     |         if (!tokenIdExists[projectId]) {
  79 |     |             mintedTokenIds.push(projectId);
  80 |     |             tokenIdExists[projectId] = true;
  81 |     |         }
  82 |     |     }
  83 |     | 
  84 |     |     // Retire credits for a user
  85 |     |     function retireCredits(uint256 tokenIdSeed, uint256 amountSeed) public {
  86 |     |         if (mintedTokenIds.length == 0) return;
  87 |     | 
  88 |     |         // Select an existing token ID
  89 |     |         uint256 tokenIndex = tokenIdSeed % mintedTokenIds.length;
  90 |     |         bytes32 projectId = mintedTokenIds[tokenIndex];
  91 |     | 
  92 |     |         // Select a user who might have this token
  93 |     |         address user = users[tokenIdSeed % users.length];
  94 |     | 
  95 |     |         // Skip if user has no tokens
  96 |     |         if (userBalances[user][projectId] == 0) return;
  97 |     | 
  98 |     |         // Determine retire amount (cannot exceed balance)
  99 |     |         uint256 retireAmount = (amountSeed % userBalances[user][projectId]) + 1;
 100 |     | 
 101 |     |         vm.prank(user);
 102 |     |         try credit.retire(user, projectId, retireAmount) {
 103 |     |             // Track state changes
 104 |     |             userBalances[user][projectId] -= retireAmount;
 105 |     |             retiredAmount[projectId] += retireAmount;
 106 |     |         } catch {
 107 |     |             // If retire fails, that's okay - we're just testing invariants
 108 |     |         }
 109 |     |     }
 110 |     | 
 111 |     |     // Transfer credits between users
 112 |     |     function transferCredits(uint256 tokenIdSeed, uint256 fromUserSeed, uint256 toUserSeed, uint256 amountSeed)
 113 |     |         public
 114 |     |     {
 115 |     |         if (mintedTokenIds.length == 0) return;
 116 |     | 
 117 |     |         // Select an existing token ID
 118 |     |         uint256 tokenIndex = tokenIdSeed % mintedTokenIds.length;
 119 |     |         bytes32 projectId = mintedTokenIds[tokenIndex];
 120 |     | 
 121 |     |         // Select different from/to users
 122 |     |         address from = users[fromUserSeed % users.length];
 123 |     |         address to = users[(fromUserSeed + toUserSeed + 1) % users.length];
 124 |     |         if (from == to) to = users[(toUserSeed + 2) % users.length];
 125 |     | 
 126 |     |         // Skip if from user has no tokens
 127 |     |         if (userBalances[from][projectId] == 0) return;
 128 |     | 
 129 |     |         // Determine transfer amount (cannot exceed balance)
 130 |     |         uint256 transferAmount = (amountSeed % userBalances[from][projectId]) + 1;
 131 |     | 
 132 |     |         vm.prank(from);
 133 |     |         try credit.safeTransferFrom(from, to, uint256(projectId), transferAmount, "") {
 134 |     |             // Track state changes
 135 |     |             userBalances[from][projectId] -= transferAmount;
 136 |     |             userBalances[to][projectId] += transferAmount;
 137 |     |         } catch {
 138 |     |             // If transfer fails, that's okay - we're just testing invariants
 139 |     |         }
 140 |     |     }
 141 |     | 
 142 |     |     // Update token URI (only used by admin)
 143 |     |     function updateTokenURI(uint256 tokenIdSeed, string calldata newURI) public {
 144 |     |         if (mintedTokenIds.length == 0) return;
 145 |     | 
 146 |     |         // Select an existing token ID
 147 |     |         uint256 tokenIndex = tokenIdSeed % mintedTokenIds.length;
 148 |     |         bytes32 projectId = mintedTokenIds[tokenIndex];
 149 |     | 
 150 |     |         vm.prank(admin);
 151 |     |         credit.setTokenURI(projectId, newURI);
 152 |     |     }
 153 |     | 
 154 |     |     // Helper function to get total minted credits across all users
 155 |     |     function getTotalUserBalance(bytes32 projectId) public view returns (uint256) {
 156 |     |         uint256 total = 0;
 157 |     |         for (uint256 i = 0; i < users.length; i++) {
 158 |     |             total += userBalances[users[i]][projectId];
 159 |     |         }
 160 |     |         return total;
 161 |     |     }
 162 |     | }
 163 |     | 
 164 |     | // Fix: The correct inheritance order is StdInvariant first, then Test
 165 |     | contract DynamicImpactCreditInvariantTest is StdInvariant, Test {
 166 |     |     DynamicImpactCredit credit;
 167 |     |     ProjectRegistry registry;
 168 |     |     CreditHandler handler;
 169 |     |     address admin = address(0xA11CE);
 170 |     |     address dmrvManager = address(0xB01D);
 171 |     |     address verifier = address(0xC1E4);
 172 |     | 
 173 |     |     function setUp() public {
 174 |     |         vm.startPrank(admin);
 175 |     |         // Deploy Registry
 176 |     |         ProjectRegistry registryImpl = new ProjectRegistry();
 177 |     |         registry = ProjectRegistry(
 178 |     |             address(new ERC1967Proxy(address(registryImpl), abi.encodeCall(ProjectRegistry.initialize, ())))
 179 |     |         );
 180 |     |         DynamicImpactCredit impl = new DynamicImpactCredit(address(registry));
 181 |     |         credit = DynamicImpactCredit(
 182 |     |             address(
 183 |     |                 new ERC1967Proxy(
 184 |     |                     address(impl), abi.encodeCall(DynamicImpactCredit.initialize, ("ipfs://contract-metadata.json"))
 185 |     |                 )
 186 |     |             )
 187 |     |         );
 188 |     | 
 189 |     |         // Grant roles
 190 |     |         credit.grantRole(credit.DMRV_MANAGER_ROLE(), dmrvManager);
 191 |     |         credit.grantRole(credit.METADATA_UPDATER_ROLE(), admin);
 192 |     |         registry.grantRole(registry.VERIFIER_ROLE(), verifier);
 193 |     |         vm.stopPrank();
 194 |     | 
 195 |     |         // Create handler and target it for invariant testing
 196 |     |         handler = new CreditHandler(credit, registry, admin, dmrvManager, verifier);
 197 |     |         targetContract(address(handler));
 198 |     |     }
 199 |     | 
 200 |     |     // Invariant: For each token ID, the sum of all user balances should equal total supply minus retired amount
 201 |     |     function invariant_balancesMatchSupply() public view {
 202 |     |         uint256 numTokens = handler.getMintedTokenIdsLength();
 203 |     |         for (uint256 i = 0; i < numTokens; i++) {
 204 |     |             bytes32 projectId = handler.mintedTokenIds(i);
 205 |     |             uint256 onChainTotalBalance = handler.getTotalUserBalance(projectId);
 206 |     | 
 207 |     |             assertEq(
 208 |     |                 onChainTotalBalance + handler.retiredAmount(projectId),
 209 |     |                 handler.totalSupply(projectId),
 210 |     |                 "Total balances + retired should equal total supply"
 211 |     |             );
 212 |     |         }
 213 |     |     }
 214 |     | 
 215 |     |     // Invariant: User balances tracked in the handler should match balances on the contract
 216 |     |     function invariant_handlerBalancesMatchContract() public view {
 217 |     |         address[] memory users = new address[](5);
 218 |     |         for (uint256 i = 0; i < 5; i++) {
 219 |     |             users[i] = address(uint160(0x1000 + i));
 220 |     |         }
 221 |     | 
 222 |     |         uint256 numTokens = handler.getMintedTokenIdsLength();
 223 |     |         for (uint256 i = 0; i < numTokens; i++) {
 224 |     |             bytes32 projectId = handler.mintedTokenIds(i);
 225 |     | 
 226 |     |             for (uint256 j = 0; j < users.length; j++) {
 227 |     |                 address user = users[j];
 228 |     |                 assertEq(
 229 |     |                     handler.userBalances(user, projectId),
 230 |     |                     credit.balanceOf(user, uint256(projectId)),
 231 |     |                     "Handler balances should match contract balances"
 232 |     |                 );
 233 |     |             }
 234 |     |         }
 235 |     |     }
 236 |     | 
 237 |     |     // Invariant: Admin role should never change
 238 |     |     function invariant_adminRoleNeverChanges() public view {
 239 |     |         assertTrue(credit.hasRole(credit.DEFAULT_ADMIN_ROLE(), admin), "Admin should always have admin role");
 240 |     |     }
 241 |     | 
 242 |     |     // Invariant: DMRV Manager role should never change
 243 |     |     function invariant_dmrvManagerRoleNeverChanges() public view {
 244 |     |         assertTrue(credit.hasRole(credit.DMRV_MANAGER_ROLE(), dmrvManager), "DMRV Manager should always have its role");
 245 |     |     }
 246 |     | }
 247 |     | 

/home/phantom/Documents/azemora/azemora-contracts/test/dynamicImpactCredit/DynamicImpactCredit.t.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | pragma solidity ^0.8.20;
   3 |     | 
   4 |     | import "forge-std/Test.sol";
   5 |     | import "../../src/core/ProjectRegistry.sol";
   6 |     | import "../../src/core/dMRVManager.sol";
   7 |     | import "../../src/core/DynamicImpactCredit.sol";
   8 |     | import "@openzeppelin/contracts/proxy/ERC1967/ERC1967Proxy.sol";
   9 |     | import "@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol";
  10 |     | import "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";
  11 |     | 
  12 |     | interface IUUPS {
  13 |     |     function upgradeTo(address newImplementation) external;
  14 |     |     function upgradeToAndCall(address newImplementation, bytes calldata data) external payable;
  15 |     | }
  16 |     | 
  17 |     | contract DynamicImpactCreditTest is Test {
  18 |     |     DynamicImpactCredit creditImpl;
  19 |     |     DynamicImpactCredit credit; // proxy cast
  20 |     |     ProjectRegistry registry;
  21 |     | 
  22 |     |     address admin = address(0xA11CE);
  23 |     |     address dmrvManager = address(0xB01D);
  24 |     |     address user = address(0xCAFE);
  25 |     |     address other = address(0xD00D);
  26 |     |     address verifier = address(0xC1E4);
  27 |     | 
  28 |     |     bytes32 setupProjectId;
  29 |     | 
  30 |     |     /* ---------- set-up ---------- */
  31 |     |     function setUp() public {
  32 |     |         setupProjectId = keccak256("Project-For-Setup");
  33 |     | 
  34 |     |         vm.startPrank(admin);
  35 |     | 
  36 |     |         // Deploy Registry
  37 |     |         ProjectRegistry registryImpl = new ProjectRegistry();
  38 |     |         bytes memory registryInitData = abi.encodeCall(ProjectRegistry.initialize, ());
  39 |     |         ERC1967Proxy registryProxy = new ERC1967Proxy(address(registryImpl), registryInitData);
  40 |     |         registry = ProjectRegistry(address(registryProxy));
  41 |     |         registry.grantRole(registry.VERIFIER_ROLE(), verifier);
  42 |     | 
  43 |     |         // Deploy Credit Contract
  44 |     |         creditImpl = new DynamicImpactCredit(address(registry));
  45 |     | 
  46 |     |         bytes memory creditInitData = abi.encodeCall(DynamicImpactCredit.initialize, ("ipfs://contract-metadata.json"));
  47 |     | 
  48 |     |         ERC1967Proxy creditProxy = new ERC1967Proxy(address(creditImpl), creditInitData);
  49 |     |         credit = DynamicImpactCredit(address(creditProxy));
  50 |     | 
  51 |     |         credit.grantRole(credit.DMRV_MANAGER_ROLE(), dmrvManager);
  52 |     |         credit.grantRole(credit.METADATA_UPDATER_ROLE(), admin);
  53 |     | 
  54 |     |         vm.stopPrank();
  55 |     | 
  56 |     |         // Register the project here so it exists for all tests that need it.
  57 |     |         vm.prank(user);
  58 |     |         registry.registerProject(setupProjectId, "ipfs://project-for-setup.json");
  59 |     |     }
  60 |     | 
  61 |     |     /* ---------- single mint ---------- */
  62 |     |     function testMint() public {
  63 |     |         bytes32 projectId = keccak256("Project-1");
  64 |     |         vm.prank(user);
  65 |     |         registry.registerProject(projectId, "ipfs://project1.json");
  66 |     |         vm.prank(verifier);
  67 |     |         registry.setProjectStatus(projectId, ProjectRegistry.ProjectStatus.Active);
  68 |     | 
  69 |     |         vm.prank(dmrvManager);
  70 |     |         credit.mintCredits(user, projectId, 100, "ipfs://t1.json");
  71 |     | 
  72 |     |         assertEq(credit.balanceOf(user, uint256(projectId)), 100);
  73 |     |         assertEq(credit.uri(uint256(projectId)), "ipfs://t1.json");
  74 |     |     }
  75 |     | 
  76 |     |     /* ---------- batch mint ---------- */
  77 |     |     function testBatchMint() public {
  78 |     |         bytes32[] memory ids = new bytes32[](2);
  79 |     |         uint256[] memory amounts = new uint256[](2);
  80 |     |         string[] memory uris = new string[](2);
  81 |     | 
  82 |     |         ids[0] = keccak256("Project-10");
  83 |     |         ids[1] = keccak256("Project-11");
  84 |     |         amounts[0] = 5;
  85 |     |         amounts[1] = 7;
  86 |     |         uris[0] = "ipfs://a.json";
  87 |     |         uris[1] = "ipfs://b.json";
  88 |     | 
  89 |     |         // Register and activate projects - FIX: separate prank calls for each registration
  90 |     |         vm.prank(user);
  91 |     |         registry.registerProject(ids[0], "p10.json");
  92 |     | 
  93 |     |         vm.prank(user);
  94 |     |         registry.registerProject(ids[1], "p11.json");
  95 |     | 
  96 |     |         vm.startPrank(verifier);
  97 |     |         registry.setProjectStatus(ids[0], ProjectRegistry.ProjectStatus.Active);
  98 |     |         registry.setProjectStatus(ids[1], ProjectRegistry.ProjectStatus.Active);
  99 |     |         vm.stopPrank();
 100 |     | 
 101 |     |         vm.prank(dmrvManager);
 102 |     |         credit.batchMintCredits(user, ids, amounts, uris);
 103 |     | 
 104 |     |         assertEq(credit.balanceOf(user, uint256(ids[0])), 5);
 105 |     |         assertEq(credit.balanceOf(user, uint256(ids[1])), 7);
 106 |     |         assertEq(credit.uri(uint256(ids[1])), "ipfs://b.json");
 107 |     |     }
 108 |     | 
 109 |     |     /* ---------- unauthorized mint revert ---------- */
 110 |     |     function testMintNotMinterReverts() public {
 111 |     |         bytes32 projectId = keccak256("Project-2");
 112 |     |         vm.prank(user);
 113 |     |         registry.registerProject(projectId, "p2.json");
 114 |     |         vm.prank(verifier);
 115 |     |         registry.setProjectStatus(projectId, ProjectRegistry.ProjectStatus.Active);
 116 |     | 
 117 |     |         vm.expectRevert(
 118 |     |             abi.encodeWithSignature(
 119 |     |                 "AccessControlUnauthorizedAccount(address,bytes32)", other, credit.DMRV_MANAGER_ROLE()
 120 |     |             )
 121 |     |         );
 122 |     |         vm.prank(other);
 123 |     |         credit.mintCredits(user, projectId, 1, "ipfs://fail.json");
 124 |     |     }
 125 |     | 
 126 |     |     /* ---------- metadata update ---------- */
 127 |     |     function testSetTokenURI() public {
 128 |     |         bytes32 projectId = keccak256("Project-3");
 129 |     |         vm.prank(user);
 130 |     |         registry.registerProject(projectId, "p3.json");
 131 |     |         vm.prank(verifier);
 132 |     |         registry.setProjectStatus(projectId, ProjectRegistry.ProjectStatus.Active);
 133 |     | 
 134 |     |         string memory oldURI = "ipfs://old.json";
 135 |     |         vm.startPrank(dmrvManager);
 136 |     |         credit.mintCredits(user, projectId, 1, oldURI);
 137 |     |         vm.stopPrank();
 138 |     | 
 139 |     |         vm.prank(admin);
 140 |     |         string memory newURI = "ipfs://new.json";
 141 |     |         credit.setTokenURI(projectId, newURI);
 142 |     |         assertEq(credit.uri(uint256(projectId)), newURI);
 143 |     | 
 144 |     |         string[] memory history = credit.getTokenURIHistory(uint256(projectId));
 145 |     |         assertEq(history.length, 2);
 146 |     |         assertEq(history[0], oldURI);
 147 |     |         assertEq(history[1], newURI);
 148 |     |     }
 149 |     | 
 150 |     |     /* ---------- retire flow ---------- */
 151 |     |     function testRetire() public {
 152 |     |         bytes32 projectId = keccak256("Project-4");
 153 |     |         vm.prank(user);
 154 |     |         registry.registerProject(projectId, "p4.json");
 155 |     |         vm.prank(verifier);
 156 |     |         registry.setProjectStatus(projectId, ProjectRegistry.ProjectStatus.Active);
 157 |     | 
 158 |     |         vm.prank(dmrvManager);
 159 |     |         credit.mintCredits(user, projectId, 10, "ipfs://t.json");
 160 |     | 
 161 |     |         vm.prank(user);
 162 |     |         credit.retire(user, projectId, 6);
 163 |     | 
 164 |     |         assertEq(credit.balanceOf(user, uint256(projectId)), 4);
 165 |     |     }
 166 |     | 
 167 |     |     /* ---------- retire too much reverts ---------- */
 168 |     |     function testRetireTooMuch() public {
 169 |     |         bytes32 projectId = keccak256("Project-5");
 170 |     |         vm.prank(user);
 171 |     |         registry.registerProject(projectId, "p5.json");
 172 |     |         vm.prank(verifier);
 173 |     |         registry.setProjectStatus(projectId, ProjectRegistry.ProjectStatus.Active);
 174 |     | 
 175 |     |         vm.prank(dmrvManager);
 176 |     |         credit.mintCredits(user, projectId, 1, "ipfs://t.json");
 177 |     | 
 178 |     |         vm.prank(user);
 179 |     |         vm.expectRevert();
 180 |     |         credit.retire(user, projectId, 2);
 181 |     |     }
 182 |     | 
 183 |     |     /* ---------- re-initialization blocked ---------- */
 184 |     |     function testCannotReinitialize() public {
 185 |     |         vm.expectRevert(Initializable.InvalidInitialization.selector);
 186 |     |         credit.initialize("ipfs://again");
 187 |     |     }
 188 |     | 
 189 |     |     /* ---------- upgrade keeps state ---------- */
 190 |     |     function testUpgradeKeepsBalance() public {
 191 |     |         bytes32 projectId = keccak256("Project-7");
 192 |     |         vm.prank(user);
 193 |     |         registry.registerProject(projectId, "p7.json");
 194 |     |         vm.prank(verifier);
 195 |     |         registry.setProjectStatus(projectId, ProjectRegistry.ProjectStatus.Active);
 196 |     | 
 197 |     |         vm.prank(dmrvManager);
 198 |     |         credit.mintCredits(user, projectId, 42, "ipfs://state.json");
 199 |     | 
 200 |     |         // deploy V2 with new variable
 201 |     |         DynamicImpactCreditV2 v2 = new DynamicImpactCreditV2(address(registry));
 202 |     | 
 203 |     |         vm.startPrank(admin);
 204 |     |         // Empty bytes for data since we don't need initialization logic
 205 |     |         IUUPS(address(credit)).upgradeToAndCall(address(v2), "");
 206 |     |         vm.stopPrank();
 207 |     | 
 208 |     |         // cast back
 209 |     |         DynamicImpactCreditV2 upgraded = DynamicImpactCreditV2(address(credit));
 210 |     | 
 211 |     |         assertEq(upgraded.balanceOf(user, uint256(projectId)), 42);
 212 |     |         assertEq(upgraded.VERSION(), 2);
 213 |     |     }
 214 |     | 
 215 |     |     function testRoleAssignment() public view {
 216 |     |         console.log("Admin address:", admin);
 217 |     |         console.log("Admin has DEFAULT_ADMIN_ROLE:", credit.hasRole(credit.DEFAULT_ADMIN_ROLE(), admin));
 218 |     |         console.log("Test contract has DEFAULT_ADMIN_ROLE:", credit.hasRole(credit.DEFAULT_ADMIN_ROLE(), address(this)));
 219 |     |     }
 220 |     | 
 221 |     |     /* ---------- Pausable Tests ---------- */
 222 |     | 
 223 |     |     function test_PauseAndUnpause() public {
 224 |     |         bytes32 pauserRole = credit.PAUSER_ROLE();
 225 |     | 
 226 |     |         vm.startPrank(admin);
 227 |     |         // Admin has pauser role by default from setUp
 228 |     |         credit.pause();
 229 |     |         assertTrue(credit.paused());
 230 |     |         credit.unpause();
 231 |     |         assertFalse(credit.paused());
 232 |     |         vm.stopPrank();
 233 |     | 
 234 |     |         // Non-pauser cannot pause
 235 |     |         vm.prank(other);
 236 |     |         vm.expectRevert(
 237 |     |             abi.encodeWithSelector(
 238 |     |                 bytes4(keccak256("AccessControlUnauthorizedAccount(address,bytes32)")), other, pauserRole
 239 |     |             )
 240 |     |         );
 241 |     |         credit.pause();
 242 |     |     }
 243 |     | 
 244 |     |     function test_RevertsWhenPaused() public {
 245 |     |         bytes32 projectId = keccak256("Project-Pausable");
 246 |     |         vm.prank(user);
 247 |     |         registry.registerProject(projectId, "p-pausable.json");
 248 |     |         vm.prank(verifier);
 249 |     |         registry.setProjectStatus(projectId, ProjectRegistry.ProjectStatus.Active);
 250 |     | 
 251 |     |         vm.prank(admin);
 252 |     |         credit.pause();
 253 |     | 
 254 |     |         vm.expectRevert("EnforcedPause()");
 255 |     |         vm.prank(dmrvManager);
 256 |     |         credit.mintCredits(user, projectId, 1, "ipfs://fail-paused.json");
 257 |     |     }
 258 |     | 
 259 |     |     function test_MintCredits_RevertsForNonActiveProject() public {
 260 |     |         // setupProjectId is registered but not activated
 261 |     |         vm.prank(dmrvManager);
 262 |     |         vm.expectRevert(DynamicImpactCredit__ProjectNotActive.selector);
 263 |     |         credit.mintCredits(user, setupProjectId, 100, "ipfs://t1.json");
 264 |     |     }
 265 |     | 
 266 |     |     function test_Retire_RevertsWhenNotAuthorized() public {
 267 |     |         bytes32 projectId = keccak256("Project-To-Retire");
 268 |     |         uint256 tokenId = uint256(projectId);
 269 |     | 
 270 |     |         vm.prank(user);
 271 |     |         registry.registerProject(projectId, "ipfs://retire.json");
 272 |     | 
 273 |     |         vm.prank(verifier);
 274 |     |         registry.setProjectStatus(projectId, ProjectRegistry.ProjectStatus.Active);
 275 |     | 
 276 |     |         vm.prank(dmrvManager);
 277 |     |         credit.mintCredits(user, projectId, 10, "ipfs://t.json");
 278 |     | 
 279 |     |         // 'other' user, who is not the owner and not approved, tries to retire
 280 |     |         vm.prank(other);
 281 |     |         vm.expectRevert(DynamicImpactCredit__NotAuthorized.selector);
 282 |     |         credit.retire(user, projectId, 5);
 283 |     |     }
 284 |     | 
 285 |     |     function test_URI_RevertsForNonExistentToken() public {
 286 |     |         vm.expectRevert(DynamicImpactCredit__URINotSet.selector);
 287 |     |         credit.uri(99999); // A token that has not been minted
 288 |     |     }
 289 |     | 
 290 |     |     function test_BatchMint_RevertsOnMismatchedArrays() public {
 291 |     |         bytes32[] memory ids = new bytes32[](2);
 292 |     |         uint256[] memory amounts = new uint256[](1); // Mismatched length
 293 |     |         string[] memory uris = new string[](2);
 294 |     | 
 295 |     |         ids[0] = keccak256("p1");
 296 |     |         ids[1] = keccak256("p2");
 297 |     |         amounts[0] = 1;
 298 |     |         uris[0] = "u1";
 299 |     |         uris[1] = "u2";
 300 |     | 
 301 |     |         vm.prank(dmrvManager);
 302 |     |         vm.expectRevert(DynamicImpactCredit__LengthMismatch.selector);
 303 |     |         credit.batchMintCredits(user, ids, amounts, uris);
 304 |     |     }
 305 |     | 
 306 |     |     function test_BatchMint_RevertsForNonActiveProject() public {
 307 |     |         bytes32[] memory ids = new bytes32[](2);
 308 |     |         uint256[] memory amounts = new uint256[](2);
 309 |     |         string[] memory uris = new string[](2);
 310 |     | 
 311 |     |         ids[0] = setupProjectId; // This project is not active by default in setUp
 312 |     |         ids[1] = keccak256("another-active-one");
 313 |     |         amounts[0] = 5;
 314 |     |         amounts[1] = 7;
 315 |     |         uris[0] = "ipfs://a.json";
 316 |     |         uris[1] = "ipfs://b.json";
 317 |     | 
 318 |     |         // Activate the second project
 319 |     |         vm.prank(user);
 320 |     |         registry.registerProject(ids[1], "p11.json");
 321 |     |         vm.prank(verifier);
 322 |     |         registry.setProjectStatus(ids[1], ProjectRegistry.ProjectStatus.Active);
 323 |     | 
 324 |     |         vm.prank(dmrvManager);
 325 |     |         vm.expectRevert(DynamicImpactCredit__ProjectNotActive.selector);
 326 |     |         credit.batchMintCredits(user, ids, amounts, uris);
 327 |     |     }
 328 |     | }
 329 |     | 
 330 |     | /* ---------- dummy V2 impl for upgrade test ---------- */
 331 |     | contract DynamicImpactCreditV2 is UUPSUpgradeable, DynamicImpactCredit {
 332 |     |     uint256 public constant VERSION = 2;
 333 |     | 
 334 |     |     constructor(address registryAddress) DynamicImpactCredit(registryAddress) {}
 335 |     | 
 336 |     |     function getVersion() external pure returns (uint256) {
 337 |     |         return VERSION;
 338 |     |     }
 339 |     | 
 340 |     |     function _authorizeUpgrade(address newImplementation) internal override(DynamicImpactCredit, UUPSUpgradeable) {}
 341 |     | }
 342 |     | 

/home/phantom/Documents/azemora/azemora-contracts/test/echidna/Marketplace.echidna.t.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | pragma solidity 0.8.25;
   3 |     | 
   4 |     | import {Test} from "forge-std/Test.sol";
   5 |     | import {Marketplace} from "src/marketplace/Marketplace.sol";
   6 |     | import {DynamicImpactCredit} from "src/core/DynamicImpactCredit.sol";
   7 |     | import {ProjectRegistry} from "src/core/ProjectRegistry.sol";
   8 |     | import {ERC20Mock} from "@openzeppelin/contracts/mocks/token/ERC20Mock.sol";
   9 |     | import {ERC1967Proxy} from "@openzeppelin/contracts/proxy/ERC1967/ERC1967Proxy.sol";
  10 |     | 
  11 |     | 
  12 |     | /// @title Echidna test for the Marketplace contract
  13 |     | /// @notice This contract defines properties (invariants) that should always hold true
  14 |     | /// for the Marketplace, no matter what sequence of functions are called.
  15 |     | /// Echidna will try to break these properties.
  16 | *r  | contract MarketplaceEchidnaTest is Test {
  17 |     |     Marketplace internal marketplace;
  18 |     |     DynamicImpactCredit internal credit;
  19 |     |     ProjectRegistry internal registry;
  20 |     |     ERC20Mock internal paymentToken;
  21 |     | 
  22 |     |     // Echidna will use this to generate random users
  23 |     |     address[] internal users;
  24 |     | 
  25 |     |     // Constants for the test setup
  26 | *   |     uint256 constant NUM_TOKENS = 10;
  27 | *   |     uint256 constant NUM_USERS = 5;
  28 | *   |     uint256 constant INITIAL_MINT_AMOUNT = 1000;
  29 | *   |     uint256 constant INITIAL_PAYMENT_BALANCE = 1_000_000 ether;
  30 |     | 
  31 | *   |     constructor() {
  32 |     |         // --- Deploy Logic & Proxies in correct order ---
  33 |     | 
  34 |     |         // 1. Deploy Registry (logic and proxy)
  35 | *   |         ProjectRegistry registryImpl = new ProjectRegistry();
  36 | *   |         bytes memory registryData = abi.encodeWithSelector(ProjectRegistry.initialize.selector);
  37 | *   |         registry = ProjectRegistry(payable(address(new ERC1967Proxy(address(registryImpl), registryData))));
  38 |     | 
  39 |     |         // 2. Deploy Credit contract logic, passing it the *registry proxy* address
  40 | *   |         DynamicImpactCredit creditImpl = new DynamicImpactCredit(address(registry));
  41 | *   |         bytes memory creditData = abi.encodeWithSelector(creditImpl.initialize.selector, "contract_uri");
  42 | *   |         credit = DynamicImpactCredit(payable(address(new ERC1967Proxy(address(creditImpl), creditData))));
  43 |     | 
  44 |     |         // 3. Deploy Payment Token
  45 | *   |         paymentToken = new ERC20Mock();
  46 |     | 
  47 |     |         // 4. Deploy Marketplace (logic and proxy)
  48 | *   |         Marketplace marketplaceImpl = new Marketplace();
  49 |     |         bytes memory marketplaceData =
  50 | *   |             abi.encodeWithSelector(marketplaceImpl.initialize.selector, address(credit), address(paymentToken));
  51 | *   |         marketplace = Marketplace(payable(address(new ERC1967Proxy(address(marketplaceImpl), marketplaceData))));
  52 |     | 
  53 |     | 
  54 |     |         // --- Grant Roles ---
  55 | *   |         credit.grantRole(credit.DMRV_MANAGER_ROLE(), address(this));
  56 | *   |         registry.grantRole(registry.VERIFIER_ROLE(), address(this));
  57 |     | 
  58 |     |         // --- Create Users and Tokens ---
  59 | *   |         for (uint256 i = 0; i < NUM_USERS; i++) {
  60 | *   |             users.push(address(uint160(i + 1))); // Create non-zero user addresses
  61 |     |         }
  62 |     | 
  63 | *   |         for (uint256 i = 0; i < NUM_TOKENS; i++) {
  64 | *   |             bytes32 projectId = keccak256(abi.encodePacked(i));
  65 | *   |             registry.registerProject(projectId, "uri"); // Step 1: Register
  66 | *   |             registry.setProjectStatus(projectId, ProjectRegistry.ProjectStatus.Active);
  67 | *   |             credit.mintCredits(address(this), projectId, INITIAL_MINT_AMOUNT, "token_uri");
  68 |     |         }
  69 |     | 
  70 |     |         // --- Distribute Assets ---
  71 |     |         // Give this test contract approval to manage its own tokens on the marketplace
  72 | *   |         credit.setApprovalForAll(address(marketplace), true);
  73 |     | 
  74 |     |         // Give all our fake users some payment tokens and approve the marketplace
  75 | *   |         for (uint256 i = 0; i < users.length; i++) {
  76 | *   |             vm.startPrank(users[i]);
  77 | *   |             paymentToken.mint(users[i], INITIAL_PAYMENT_BALANCE);
  78 | *   |             paymentToken.approve(address(marketplace), type(uint256).max);
  79 | *   |             vm.stopPrank();
  80 |     |         }
  81 |     |     }
  82 |     | 
  83 |     |     // =================================================================
  84 |     |     //                           INVARIANTS
  85 |     |     // =================================================================
  86 |     | 
  87 |     |     /// @dev Property: An active listing must always have a price greater than zero.
  88 |     |     function echidna_active_listing_has_price() public view returns (bool) {
  89 |     |         uint256 counter = marketplace.listingIdCounter();
  90 |     |         for (uint256 i = 0; i < counter; i++) {
  91 |     |             (,,, uint256 pricePerUnit,, , bool active) = marketplace.listings(i);
  92 |     |             if (active) {
  93 |     |                 if (pricePerUnit == 0) return false;
  94 |     |             }
  95 |     |         }
  96 |     |         return true;
  97 |     |     }
  98 |     | 
  99 |     |     /// @dev Property: An active listing's seller cannot be the zero address.
 100 | *   |     function echidna_active_listing_has_seller() public view returns (bool) {
 101 |     |         uint256 counter = marketplace.listingIdCounter();
 102 |     |         for (uint256 i = 0; i < counter; i++) {
 103 |     |             (,,,, address seller, , bool active) = marketplace.listings(i);
 104 |     |             if (active) {
 105 |     |                 if (seller == address(0)) return false;
 106 |     |             }
 107 |     |         }
 108 |     |         return true;
 109 |     |     }
 110 |     | 
 111 |     |     /// @dev Property: The marketplace contract's token balance for a given tokenId
 112 |     |     /// should equal the sum of all active listings for that tokenId.
 113 |     |     function echidna_marketplace_holds_listed_tokens() public view returns (bool) {
 114 |     |         uint256 listingCounter = marketplace.listingIdCounter();
 115 |     | 
 116 |     |         // Check this invariant for each token type we created.
 117 |     |         for (uint256 i = 0; i < NUM_TOKENS; i++) {
 118 |     |             bytes32 projectId = keccak256(abi.encodePacked(i));
 119 |     |             uint256 currentTokenId = uint256(projectId);
 120 |     |             uint256 totalListedForToken = 0;
 121 |     | 
 122 |     |             // Sum up all active listings for the current tokenId.
 123 |     |             for (uint256 j = 0; j < listingCounter; j++) {
 124 |     |                 (, uint256 listedTokenId, uint256 amount,, , , bool active) = marketplace.listings(j);
 125 |     |                 if (active && listedTokenId == currentTokenId) {
 126 |     |                     totalListedForToken += amount;
 127 |     |                 }
 128 |     |             }
 129 |     | 
 130 |     |             // The marketplace's balance should match the sum of active listings.
 131 |     |             if (credit.balanceOf(address(marketplace), currentTokenId) != totalListedForToken) {
 132 |     |                 return false;
 133 |     |             }
 134 |     |         }
 135 |     | 
 136 |     |         return true;
 137 |     |     }
 138 |     | 
 139 |     |     // =================================================================
 140 |     |     //                      STATE-CHANGING FUNCTIONS
 141 |     |     // =================================================================
 142 |     |     // These wrappers guide Echidna to call the marketplace functions
 143 |     |     // with valid (or at least semi-valid) parameters.
 144 |     | 
 145 | *   |     function list(uint256 tokenId, uint256 amount, uint256 price, uint256 duration) public {
 146 | *   |         tokenId = constrain(tokenId, 0, NUM_TOKENS - 1);
 147 | *   |         amount = constrain(amount, 1, INITIAL_MINT_AMOUNT); // list at least 1
 148 | *   |         price = constrain(price, 1, 1000 ether); // price must be > 0
 149 | *   |         duration = constrain(duration, 1, 365 days); // duration must be > 0
 150 |     | 
 151 | *   |         bytes32 projectId = keccak256(abi.encodePacked(tokenId));
 152 | *   |         uint256 realTokenId = uint256(projectId);
 153 |     | 
 154 |     |         // Ensure we don't try to list more than we have.
 155 | *   |         uint256 balance = credit.balanceOf(address(this), realTokenId);
 156 | *   |         if (amount > balance) {
 157 | *   |             amount = balance;
 158 |     |         }
 159 | *   |         if (amount == 0) return;
 160 |     | 
 161 | *   |         marketplace.list(realTokenId, amount, price, duration);
 162 |     |     }
 163 |     | 
 164 | *   |     function buy(uint256 listingId, uint256 amountToBuy) public {
 165 | *   |         uint256 counter = marketplace.listingIdCounter();
 166 | *   |         if (counter == 0) return;
 167 |     | 
 168 | *   |         listingId = constrain(listingId, 0, counter - 1);
 169 | *   |         address buyer = users[listingId % NUM_USERS]; // Pick a random user
 170 |     | 
 171 | *   |         (
 172 |     |             , // id
 173 |     |             , // tokenId
 174 |     |             uint256 amount,
 175 |     |             uint256 pricePerUnit,
 176 |     |             address seller,
 177 |     |             uint64 expiryTimestamp,
 178 |     |             bool active
 179 | *   |         ) = marketplace.listings(listingId);
 180 |     | 
 181 | *   |         if (!active || expiryTimestamp < block.timestamp || seller == buyer) return;
 182 |     | 
 183 | *   |         amountToBuy = constrain(amountToBuy, 1, amount);
 184 |     | 
 185 | *   |         uint256 cost = amountToBuy * pricePerUnit;
 186 | *   |         if (paymentToken.balanceOf(buyer) < cost) return;
 187 |     | 
 188 | *   |         vm.prank(buyer);
 189 | *   |         marketplace.buy(listingId, amountToBuy);
 190 |     |     }
 191 |     | 
 192 | *   |     function cancelListing(uint256 listingId) public {
 193 | *   |         uint256 counter = marketplace.listingIdCounter();
 194 | *   |         if (counter == 0) return;
 195 | *   |         listingId = constrain(listingId, 0, counter - 1);
 196 |     | 
 197 | *   |         (,,,, address seller,, bool active) = marketplace.listings(listingId);
 198 | *   |         if (seller != address(this) || !active) return; // Only contract can cancel its own ACTIVE listings
 199 |     | 
 200 | *r  |         marketplace.cancelListing(listingId);
 201 |     |     }
 202 |     | 
 203 |     |     // --- Helper function to constrain Echidna's random inputs ---
 204 | *   |     function constrain(uint256 val, uint256 min, uint256 max) internal pure returns (uint256) {
 205 | *   |         if (min >= max) {
 206 | *   |             return min;
 207 |     |         }
 208 |     |         // Use modulo to wrap the value into the range [min, max]
 209 | *   |         return (val % (max - min + 1)) + min;
 210 |     |     }
 211 |     | 
 212 |     |         // --- Helper function to bound Echidna's random inputs ---
 213 |     |     function bound(
 214 |     |         uint256 val,
 215 |     |         uint256 min,
 216 |     |         uint256 max
 217 |     |     ) internal override pure returns (uint256) {
 218 |     |         return uint256(int256(val) % int256(max - min)) + min;
 219 |     |     }
 220 |     | } 

/home/phantom/Documents/azemora/azemora-contracts/test/governance/Governance.complex.t.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | pragma solidity ^0.8.20;
   3 |     | 
   4 |     | import "forge-std/Test.sol";
   5 |     | import "../../src/token/AzemoraToken.sol";
   6 |     | import "../../src/governance/AzemoraGovernor.sol";
   7 |     | import "../../src/governance/AzemoraTimelockController.sol";
   8 |     | import "@openzeppelin/contracts-upgradeable/governance/GovernorUpgradeable.sol";
   9 |     | import "../../src/governance/Treasury.sol";
  10 |     | import "../../src/marketplace/Marketplace.sol";
  11 |     | import "../../src/core/DynamicImpactCredit.sol";
  12 |     | import "../../src/core/ProjectRegistry.sol";
  13 |     | import "@openzeppelin/contracts/proxy/ERC1967/ERC1967Proxy.sol";
  14 |     | 
  15 |     | // A mock ERC20 is needed for the Marketplace setup.
  16 |     | contract MockERC20ForGovTest {
  17 |     |     function mint(address, uint256) public {}
  18 |     | }
  19 |     | 
  20 |     | contract GovernanceComplexTest is Test {
  21 |     |     // Use addresses instead of contract references to avoid conversion issues
  22 |     |     AzemoraToken token;
  23 |     |     address payable public timelockAddr;
  24 |     |     address payable public governorAddr;
  25 |     |     address payable public treasuryAddr;
  26 |     |     Marketplace marketplace;
  27 |     |     DynamicImpactCredit credit;
  28 |     |     MockERC20ForGovTest paymentToken;
  29 |     | 
  30 |     |     // Users
  31 |     |     address admin;
  32 |     |     address voter = makeAddr("voter");
  33 |     |     address voter2 = makeAddr("voter2");
  34 |     |     address poorVoter = makeAddr("poorVoter");
  35 |     |     address recipient = makeAddr("recipient");
  36 |     | 
  37 |     |     // Governance settings
  38 |     |     uint256 constant VOTING_DELAY = 1; // blocks
  39 |     |     uint256 constant VOTING_PERIOD = 5; // blocks
  40 |     |     uint256 constant MIN_DELAY = 1; // seconds
  41 |     |     uint256 constant PROPOSAL_THRESHOLD = 1000e18;
  42 |     | 
  43 |     |     function setUp() public {
  44 |     |         admin = address(this);
  45 |     | 
  46 |     |         // 1. Deploy Governance Token
  47 |     |         AzemoraToken tokenImpl = new AzemoraToken();
  48 |     |         bytes memory tokenInitData = abi.encodeCall(AzemoraToken.initialize, ());
  49 |     |         ERC1967Proxy tokenProxy = new ERC1967Proxy(address(tokenImpl), tokenInitData);
  50 |     |         token = AzemoraToken(address(tokenProxy));
  51 |     | 
  52 |     |         // 2. Deploy Timelock
  53 |     |         AzemoraTimelockController timelockImpl = new AzemoraTimelockController();
  54 |     |         bytes memory timelockInitData =
  55 |     |             abi.encodeCall(AzemoraTimelockController.initialize, (MIN_DELAY, new address[](0), new address[](0), admin));
  56 |     |         ERC1967Proxy timelockProxy = new ERC1967Proxy(address(timelockImpl), timelockInitData);
  57 |     |         timelockAddr = payable(address(timelockProxy));
  58 |     | 
  59 |     |         // 3. Deploy Governor
  60 |     |         AzemoraGovernor governorImpl = new AzemoraGovernor();
  61 |     |         bytes memory governorInitData = abi.encodeCall(
  62 |     |             AzemoraGovernor.initialize,
  63 |     |             (
  64 |     |                 token,
  65 |     |                 AzemoraTimelockController(timelockAddr),
  66 |     |                 uint48(VOTING_DELAY),
  67 |     |                 uint32(VOTING_PERIOD),
  68 |     |                 PROPOSAL_THRESHOLD
  69 |     |             )
  70 |     |         );
  71 |     |         ERC1967Proxy governorProxy = new ERC1967Proxy(address(governorImpl), governorInitData);
  72 |     |         governorAddr = payable(address(governorProxy));
  73 |     | 
  74 |     |         // 4. Deploy Treasury
  75 |     |         Treasury treasuryImpl = new Treasury();
  76 |     |         bytes memory treasuryInitData = abi.encodeCall(Treasury.initialize, (admin));
  77 |     |         ERC1967Proxy treasuryProxy = new ERC1967Proxy(address(treasuryImpl), treasuryInitData);
  78 |     |         treasuryAddr = payable(address(treasuryProxy));
  79 |     | 
  80 |     |         // 5. Deploy Marketplace and its dependencies
  81 |     |         paymentToken = new MockERC20ForGovTest();
  82 |     | 
  83 |     |         ProjectRegistry registryImpl = new ProjectRegistry();
  84 |     |         bytes memory registryInitData = abi.encodeCall(ProjectRegistry.initialize, ());
  85 |     |         ERC1967Proxy registryProxy = new ERC1967Proxy(address(registryImpl), registryInitData);
  86 |     |         ProjectRegistry registry = ProjectRegistry(address(registryProxy));
  87 |     | 
  88 |     |         DynamicImpactCredit creditImpl = new DynamicImpactCredit(address(registry));
  89 |     |         bytes memory creditInitData = abi.encodeCall(DynamicImpactCredit.initialize, ("uri"));
  90 |     |         credit = DynamicImpactCredit(address(new ERC1967Proxy(address(creditImpl), creditInitData)));
  91 |     | 
  92 |     |         // Roles
  93 |     |         credit.grantRole(credit.DMRV_MANAGER_ROLE(), address(this)); // test contract is minter
  94 |     | 
  95 |     |         Marketplace marketplaceImpl = new Marketplace();
  96 |     |         bytes memory marketplaceInitData =
  97 |     |             abi.encodeCall(Marketplace.initialize, (address(credit), address(paymentToken)));
  98 |     |         ERC1967Proxy marketplaceProxy = new ERC1967Proxy(address(marketplaceImpl), marketplaceInitData);
  99 |     |         marketplace = Marketplace(address(marketplaceProxy));
 100 |     | 
 101 |     |         // 6. Configure Roles & Ownership
 102 |     |         bytes32 proposerRole = AzemoraTimelockController(timelockAddr).PROPOSER_ROLE();
 103 |     |         bytes32 executorRole = AzemoraTimelockController(timelockAddr).EXECUTOR_ROLE();
 104 |     |         // bytes32 timelockAdminRole = AzemoraTimelockController(timelockAddr).DEFAULT_ADMIN_ROLE();
 105 |     | 
 106 |     |         AzemoraTimelockController(timelockAddr).grantRole(proposerRole, governorAddr);
 107 |     |         AzemoraTimelockController(timelockAddr).grantRole(executorRole, address(0)); // Anyone can execute
 108 |     | 
 109 |     |         // Transfer ownership/admin of manageable contracts to the Timelock itself.
 110 |     |         bytes32 marketplaceAdminRole = marketplace.DEFAULT_ADMIN_ROLE();
 111 |     |         marketplace.grantRole(marketplaceAdminRole, timelockAddr);
 112 |     |         marketplace.renounceRole(marketplaceAdminRole, admin);
 113 |     | 
 114 |     |         Treasury(treasuryAddr).transferOwnership(timelockAddr);
 115 |     | 
 116 |     |         // DO NOT RENOUNCE THE ADMIN ROLE. The test will fail if the timelock is headless.
 117 |     |         // This line was the root cause of the silent queue failures.
 118 |     |         // AzemoraTimelockController(timelockAddr).renounceRole(timelockAdminRole, admin);
 119 |     | 
 120 |     |         // 7. Distribute tokens and set up voters
 121 |     |         token.transfer(voter, 50_000_000e18);
 122 |     |         token.transfer(voter2, 60_000_000e18);
 123 |     |         token.transfer(poorVoter, 1e18);
 124 |     | 
 125 |     |         vm.prank(voter);
 126 |     |         token.delegate(voter);
 127 |     | 
 128 |     |         vm.prank(voter2);
 129 |     |         token.delegate(voter2);
 130 |     | 
 131 |     |         vm.prank(poorVoter);
 132 |     |         token.delegate(poorVoter);
 133 |     | 
 134 |     |         vm.deal(treasuryAddr, 10 ether);
 135 |     |         vm.roll(block.number + 1);
 136 |     |     }
 137 |     | 
 138 |     |     /**
 139 |     |      * @dev A complex test to ensure governance can update its own settings.
 140 |     |      */
 141 |     |     function test_Complex_Update_Governor_Settings() public {
 142 |     |         uint48 newVotingDelay = 2;
 143 |     |         uint32 newVotingPeriod = 10;
 144 |     | 
 145 |     |         // Propose changing the governor's settings. This requires two separate calls.
 146 |     |         address[] memory targets = new address[](2);
 147 |     |         targets[0] = governorAddr;
 148 |     |         targets[1] = governorAddr;
 149 |     |         uint256[] memory values = new uint256[](2); // No ETH
 150 |     |         bytes[] memory calldatas = new bytes[](2);
 151 |     |         calldatas[0] = abi.encodeWithSignature("setVotingDelay(uint48)", newVotingDelay);
 152 |     |         calldatas[1] = abi.encodeWithSignature("setVotingPeriod(uint32)", newVotingPeriod);
 153 |     | 
 154 |     |         string memory description = "Update Governor voting settings";
 155 |     |         bytes32 descriptionHash = keccak256(bytes(description));
 156 |     | 
 157 |     |         // Full proposal lifecycle
 158 |     |         vm.prank(voter);
 159 |     |         uint256 proposalId = AzemoraGovernor(governorAddr).propose(targets, values, calldatas, description);
 160 |     |         vm.roll(block.number + VOTING_DELAY + 1);
 161 |     |         vm.prank(voter);
 162 |     |         AzemoraGovernor(governorAddr).castVote(proposalId, 1); // Vote For
 163 |     |         vm.roll(block.number + VOTING_PERIOD + 1);
 164 |     |         AzemoraGovernor(governorAddr).queue(targets, values, calldatas, descriptionHash);
 165 |     |         vm.warp(block.timestamp + MIN_DELAY + 1);
 166 |     |         AzemoraGovernor(governorAddr).execute(targets, values, calldatas, descriptionHash);
 167 |     | 
 168 |     |         // Verify the new settings are active
 169 |     |         assertEq(AzemoraGovernor(governorAddr).votingDelay(), newVotingDelay, "Voting delay should be updated");
 170 |     |         assertEq(AzemoraGovernor(governorAddr).votingPeriod(), newVotingPeriod, "Voting period should be updated");
 171 |     |     }
 172 |     | 
 173 |     |     /**
 174 |     |      * @dev A complex test to ensure a proposal passes when the quorum is met exactly.
 175 |     |      */
 176 |     |     function test_Complex_Quorum_Met_Exactly_At_Boundary() public {
 177 |     |         // The quorum is 4% of 1B tokens = 40M tokens.
 178 |     |         uint256 quorumVotes = 40_000_000e18;
 179 |     |         address quorumVoter = makeAddr("quorumVoter");
 180 |     | 
 181 |     |         // Setup the voter with the exact amount of tokens needed for quorum.
 182 |     |         token.transfer(quorumVoter, quorumVotes);
 183 |     |         vm.prank(quorumVoter);
 184 |     |         token.delegate(quorumVoter);
 185 |     |         vm.roll(block.number + 1); // Let delegation register.
 186 |     | 
 187 |     |         // Propose a simple action.
 188 |     |         address[] memory targets = new address[](1);
 189 |     |         targets[0] = address(marketplace);
 190 |     |         uint256[] memory values = new uint256[](1);
 191 |     |         bytes[] memory calldatas = new bytes[](1);
 192 |     |         calldatas[0] = abi.encodeWithSelector(Marketplace.setFee.selector, 300); // Set fee to 3%
 193 |     |         string memory description = "Proposal to set fee to 3% with exact quorum";
 194 |     |         bytes32 descriptionHash = keccak256(bytes(description));
 195 |     | 
 196 |     |         // Propose the action.
 197 |     |         vm.prank(quorumVoter);
 198 |     |         uint256 proposalId = AzemoraGovernor(governorAddr).propose(targets, values, calldatas, description);
 199 |     | 
 200 |     |         // Vote on the proposal.
 201 |     |         vm.roll(block.number + VOTING_DELAY + 1);
 202 |     |         vm.prank(quorumVoter);
 203 |     |         AzemoraGovernor(governorAddr).castVote(proposalId, 1); // Vote For.
 204 |     | 
 205 |     |         // End the voting period.
 206 |     |         vm.roll(block.number + VOTING_PERIOD + 1);
 207 |     | 
 208 |     |         // Check that the proposal is now in the "Succeeded" state.
 209 |     |         assertEq(uint256(AzemoraGovernor(governorAddr).state(proposalId)), 4, "Proposal should be Succeeded");
 210 |     | 
 211 |     |         // Queue and execute to confirm the whole flow works.
 212 |     |         AzemoraGovernor(governorAddr).queue(targets, values, calldatas, descriptionHash);
 213 |     |         vm.warp(block.timestamp + MIN_DELAY + 1);
 214 |     |         AzemoraGovernor(governorAddr).execute(targets, values, calldatas, descriptionHash);
 215 |     | 
 216 |     |         assertEq(marketplace.feeBps(), 300, "Marketplace fee should be updated");
 217 |     |     }
 218 |     | 
 219 |     |     /**
 220 |     |      * @dev Ensures a proposal cannot be queued or executed again after it has already been executed.
 221 |     |      * This prevents replay attacks.
 222 |     |      */
 223 |     |     function test_ReplayAttack_FailsAfterExecution() public {
 224 |     |         // --- Create and pass a proposal ---
 225 |     |         address[] memory targets = new address[](1);
 226 |     |         targets[0] = address(marketplace);
 227 |     |         uint256[] memory values = new uint256[](1);
 228 |     |         bytes[] memory calldatas = new bytes[](1);
 229 |     |         calldatas[0] = abi.encodeWithSelector(Marketplace.setFee.selector, 600); // Set fee to 6%
 230 |     |         string memory description = "Proposal to set fee to 6%";
 231 |     |         bytes32 descriptionHash = keccak256(bytes(description));
 232 |     | 
 233 |     |         vm.prank(voter);
 234 |     |         uint256 proposalId = AzemoraGovernor(governorAddr).propose(targets, values, calldatas, description);
 235 |     | 
 236 |     |         vm.roll(block.number + VOTING_DELAY + 1);
 237 |     |         vm.prank(voter);
 238 |     |         AzemoraGovernor(governorAddr).castVote(proposalId, 1);
 239 |     |         vm.roll(block.number + VOTING_PERIOD + 1);
 240 |     | 
 241 |     |         // --- Execute the proposal successfully ---
 242 |     |         AzemoraGovernor(governorAddr).queue(targets, values, calldatas, descriptionHash);
 243 |     |         vm.warp(block.timestamp + MIN_DELAY + 1);
 244 |     |         AzemoraGovernor(governorAddr).execute(targets, values, calldatas, descriptionHash);
 245 |     |         assertEq(
 246 |     |             7, // Executed
 247 |     |             uint256(AzemoraGovernor(governorAddr).state(proposalId)),
 248 |     |             "Proposal should be Executed"
 249 |     |         );
 250 |     |         assertEq(marketplace.feeBps(), 600, "Marketplace fee should be updated");
 251 |     | 
 252 |     |         // --- Assert replay attacks fail ---
 253 |     | 
 254 |     |         // 1. Attempting to queue again should fail because the proposal is not in the 'Succeeded' state.
 255 |     |         try AzemoraGovernor(governorAddr).queue(targets, values, calldatas, descriptionHash) {
 256 |     |             fail();
 257 |     |         } catch (bytes memory reason) {
 258 |     |             // This will log the exact revert data to the console.
 259 |     |             console.log("Revert data from queue:");
 260 |     |             console.logBytes(reason);
 261 |     |         }
 262 |     | 
 263 |     |         /*
 264 |     |         // 2. Attempting to execute again should fail because the proposal is not in the 'Queued' state.
 265 |     |         bytes memory expectedRevertDataExecute =
 266 |     |             abi.encodeWithSignature("GovernorUnexpectedProposalState(uint256,uint256)", proposalId, 7); // current state is Executed
 267 |     |         vm.expectRevert(expectedRevertDataExecute);
 268 |     |         AzemoraGovernor(governorAddr).execute(targets, values, calldatas, descriptionHash);
 269 |     |         */
 270 |     |     }
 271 |     | 
 272 |     |     /**
 273 |     |      * @dev Ensures two proposals with identical logic but different salts are treated as unique operations.
 274 |     |      */
 275 |     |     function test_Timelock_HashClash_Succeeds() public {
 276 |     |         // --- Create two proposals with the same execution logic but different descriptions ---
 277 |     |         address[] memory targets = new address[](1);
 278 |     |         targets[0] = address(marketplace);
 279 |     |         uint256[] memory values = new uint256[](1);
 280 |     |         bytes[] memory calldatas = new bytes[](1);
 281 |     |         calldatas[0] = abi.encodeWithSelector(Marketplace.setFee.selector, 800); // Set fee to 8%
 282 |     | 
 283 |     |         string memory description1 = "Set fee to 8% (Monday)";
 284 |     |         bytes32 descriptionHash1 = keccak256(bytes(description1));
 285 |     |         string memory description2 = "Set fee to 8% (Tuesday)";
 286 |     |         bytes32 descriptionHash2 = keccak256(bytes(description2));
 287 |     | 
 288 |     |         // Propose both
 289 |     |         vm.prank(voter);
 290 |     |         uint256 proposalId1 = AzemoraGovernor(governorAddr).propose(targets, values, calldatas, description1);
 291 |     |         vm.prank(voter);
 292 |     |         uint256 proposalId2 = AzemoraGovernor(governorAddr).propose(targets, values, calldatas, description2);
 293 |     | 
 294 |     |         // --- Vote both proposals through ---
 295 |     |         vm.roll(block.number + VOTING_DELAY + 1);
 296 |     |         vm.prank(voter);
 297 |     |         AzemoraGovernor(governorAddr).castVote(proposalId1, 1);
 298 |     |         vm.prank(voter);
 299 |     |         AzemoraGovernor(governorAddr).castVote(proposalId2, 1);
 300 |     | 
 301 |     |         vm.roll(block.number + VOTING_PERIOD + 1);
 302 |     | 
 303 |     |         // --- Queue proposals and check for uniqueness ---
 304 |     |         // As per GovernorTimelockControl, the predecessor is 0 and the salt is a mix of the governor address and description hash.
 305 |     |         bytes32 salt1 = bytes20(address(governorAddr)) ^ descriptionHash1;
 306 |     |         bytes32 salt2 = bytes20(address(governorAddr)) ^ descriptionHash2;
 307 |     | 
 308 |     |         bytes32 opId1 = AzemoraTimelockController(timelockAddr).hashOperationBatch(targets, values, calldatas, 0, salt1);
 309 |     |         bytes32 opId2 = AzemoraTimelockController(timelockAddr).hashOperationBatch(targets, values, calldatas, 0, salt2);
 310 |     | 
 311 |     |         // Queue the first proposal
 312 |     |         AzemoraGovernor(governorAddr).queue(targets, values, calldatas, descriptionHash1);
 313 |     | 
 314 |     |         // Assert first is scheduled and second is NOT
 315 |     |         assertTrue(AzemoraTimelockController(timelockAddr).isOperation(opId1), "Op 1 should be scheduled");
 316 |     |         assertFalse(AzemoraTimelockController(timelockAddr).isOperation(opId2), "Op 2 should NOT be scheduled yet");
 317 |     | 
 318 |     |         // Queue the second proposal
 319 |     |         AzemoraGovernor(governorAddr).queue(targets, values, calldatas, descriptionHash2);
 320 |     |         assertTrue(AzemoraTimelockController(timelockAddr).isOperation(opId2), "Op 2 should now be scheduled");
 321 |     |     }
 322 |     | }
 323 |     | 

/home/phantom/Documents/azemora/azemora-contracts/test/governance/Governance.fuzz.t.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | pragma solidity ^0.8.20;
   3 |     | 
   4 |     | import "forge-std/Test.sol";
   5 |     | import "../../src/token/AzemoraToken.sol";
   6 |     | import "../../src/governance/AzemoraGovernor.sol";
   7 |     | import "../../src/governance/AzemoraTimelockController.sol";
   8 |     | import "../../src/governance/Treasury.sol";
   9 |     | import "../../src/marketplace/Marketplace.sol";
  10 |     | import "../../src/core/DynamicImpactCredit.sol";
  11 |     | import "../../src/core/ProjectRegistry.sol";
  12 |     | import "@openzeppelin/contracts/proxy/ERC1967/ERC1967Proxy.sol";
  13 |     | 
  14 |     | // A mock ERC20 is needed for the Marketplace setup.
  15 |     | contract MockERC20ForGovTest {
  16 |     |     function mint(address, uint256) public {}
  17 |     | }
  18 |     | 
  19 |     | contract GovernanceFuzzTest is Test {
  20 |     |     // Use addresses instead of contract references to avoid conversion issues
  21 |     |     AzemoraToken token;
  22 |     |     address payable public timelockAddr;
  23 |     |     address payable public governorAddr;
  24 |     |     address payable public treasuryAddr;
  25 |     |     Marketplace marketplace;
  26 |     |     DynamicImpactCredit credit;
  27 |     |     MockERC20ForGovTest paymentToken;
  28 |     | 
  29 |     |     // Users
  30 |     |     address admin;
  31 |     |     address voter = makeAddr("voter");
  32 |     |     address voter2 = makeAddr("voter2");
  33 |     |     address poorVoter = makeAddr("poorVoter");
  34 |     |     address recipient = makeAddr("recipient");
  35 |     | 
  36 |     |     // Governance settings
  37 |     |     uint256 constant VOTING_DELAY = 1; // blocks
  38 |     |     uint256 constant VOTING_PERIOD = 5; // blocks
  39 |     |     uint256 constant MIN_DELAY = 1; // seconds
  40 |     |     uint256 constant PROPOSAL_THRESHOLD = 1000e18;
  41 |     | 
  42 |     |     function setUp() public {
  43 |     |         admin = address(this);
  44 |     | 
  45 |     |         // 1. Deploy Governance Token
  46 |     |         AzemoraToken tokenImpl = new AzemoraToken();
  47 |     |         bytes memory tokenInitData = abi.encodeCall(AzemoraToken.initialize, ());
  48 |     |         ERC1967Proxy tokenProxy = new ERC1967Proxy(address(tokenImpl), tokenInitData);
  49 |     |         token = AzemoraToken(address(tokenProxy));
  50 |     | 
  51 |     |         // 2. Deploy Timelock
  52 |     |         AzemoraTimelockController timelockImpl = new AzemoraTimelockController();
  53 |     |         bytes memory timelockInitData =
  54 |     |             abi.encodeCall(AzemoraTimelockController.initialize, (MIN_DELAY, new address[](0), new address[](0), admin));
  55 |     |         ERC1967Proxy timelockProxy = new ERC1967Proxy(address(timelockImpl), timelockInitData);
  56 |     |         timelockAddr = payable(address(timelockProxy));
  57 |     | 
  58 |     |         // 3. Deploy Governor
  59 |     |         AzemoraGovernor governorImpl = new AzemoraGovernor();
  60 |     |         bytes memory governorInitData = abi.encodeCall(
  61 |     |             AzemoraGovernor.initialize,
  62 |     |             (
  63 |     |                 token,
  64 |     |                 AzemoraTimelockController(timelockAddr),
  65 |     |                 uint48(VOTING_DELAY),
  66 |     |                 uint32(VOTING_PERIOD),
  67 |     |                 PROPOSAL_THRESHOLD
  68 |     |             )
  69 |     |         );
  70 |     |         ERC1967Proxy governorProxy = new ERC1967Proxy(address(governorImpl), governorInitData);
  71 |     |         governorAddr = payable(address(governorProxy));
  72 |     | 
  73 |     |         // 4. Deploy Treasury
  74 |     |         Treasury treasuryImpl = new Treasury();
  75 |     |         bytes memory treasuryInitData = abi.encodeCall(Treasury.initialize, (admin));
  76 |     |         ERC1967Proxy treasuryProxy = new ERC1967Proxy(address(treasuryImpl), treasuryInitData);
  77 |     |         treasuryAddr = payable(address(treasuryProxy));
  78 |     | 
  79 |     |         // 5. Deploy Marketplace and its dependencies
  80 |     |         paymentToken = new MockERC20ForGovTest();
  81 |     | 
  82 |     |         ProjectRegistry registryImpl = new ProjectRegistry();
  83 |     |         bytes memory registryInitData = abi.encodeCall(ProjectRegistry.initialize, ());
  84 |     |         ERC1967Proxy registryProxy = new ERC1967Proxy(address(registryImpl), registryInitData);
  85 |     |         ProjectRegistry registry = ProjectRegistry(address(registryProxy));
  86 |     | 
  87 |     |         DynamicImpactCredit creditImpl = new DynamicImpactCredit(address(registry));
  88 |     |         bytes memory creditInitData = abi.encodeCall(DynamicImpactCredit.initialize, ("uri"));
  89 |     |         ERC1967Proxy creditProxy = new ERC1967Proxy(address(creditImpl), creditInitData);
  90 |     |         credit = DynamicImpactCredit(address(creditProxy));
  91 |     | 
  92 |     |         Marketplace marketplaceImpl = new Marketplace();
  93 |     |         bytes memory marketplaceInitData =
  94 |     |             abi.encodeCall(Marketplace.initialize, (address(credit), address(paymentToken)));
  95 |     |         ERC1967Proxy marketplaceProxy = new ERC1967Proxy(address(marketplaceImpl), marketplaceInitData);
  96 |     |         marketplace = Marketplace(address(marketplaceProxy));
  97 |     | 
  98 |     |         // 6. Configure Roles & Ownership
  99 |     |         bytes32 proposerRole = AzemoraTimelockController(timelockAddr).PROPOSER_ROLE();
 100 |     |         bytes32 executorRole = AzemoraTimelockController(timelockAddr).EXECUTOR_ROLE();
 101 |     |         bytes32 timelockAdminRole = AzemoraTimelockController(timelockAddr).DEFAULT_ADMIN_ROLE();
 102 |     | 
 103 |     |         AzemoraTimelockController(timelockAddr).grantRole(proposerRole, governorAddr);
 104 |     |         AzemoraTimelockController(timelockAddr).grantRole(executorRole, address(0)); // Anyone can execute
 105 |     |         AzemoraTimelockController(timelockAddr).renounceRole(timelockAdminRole, admin);
 106 |     | 
 107 |     |         // Transfer ownership of manageable contracts to the Timelock
 108 |     |         bytes32 marketplaceAdminRole = marketplace.DEFAULT_ADMIN_ROLE();
 109 |     |         marketplace.grantRole(marketplaceAdminRole, timelockAddr);
 110 |     |         marketplace.renounceRole(marketplaceAdminRole, admin);
 111 |     | 
 112 |     |         Treasury(treasuryAddr).transferOwnership(timelockAddr);
 113 |     | 
 114 |     |         // 7. Distribute tokens and set up voters
 115 |     |         token.transfer(voter, 50_000_000e18);
 116 |     |         token.transfer(voter2, 60_000_000e18);
 117 |     |         token.transfer(poorVoter, 1e18);
 118 |     | 
 119 |     |         vm.prank(voter);
 120 |     |         token.delegate(voter);
 121 |     | 
 122 |     |         vm.prank(voter2);
 123 |     |         token.delegate(voter2);
 124 |     | 
 125 |     |         vm.prank(poorVoter);
 126 |     |         token.delegate(poorVoter);
 127 |     | 
 128 |     |         vm.deal(treasuryAddr, 10 ether);
 129 |     |         vm.roll(block.number + 1);
 130 |     |     }
 131 |     | 
 132 |     |     /**
 133 |     |      * @dev Fuzz test to ensure vote counting is always correct.
 134 |     |      */
 135 |     |     function test_Fuzz_VoteCounting(uint8 voteType) public {
 136 |     |         // Constrain voteType to the 3 valid options: 0=Against, 1=For, 2=Abstain
 137 |     |         vm.assume(voteType <= 2);
 138 |     | 
 139 |     |         // Propose something simple
 140 |     |         address[] memory targets = new address[](1);
 141 |     |         targets[0] = address(marketplace);
 142 |     |         uint256[] memory values = new uint256[](1);
 143 |     |         bytes[] memory calldatas = new bytes[](1);
 144 |     |         calldatas[0] = abi.encodeWithSelector(Marketplace.setTreasury.selector, treasuryAddr);
 145 |     |         string memory description = "Fuzz test proposal";
 146 |     | 
 147 |     |         vm.prank(voter);
 148 |     |         uint256 proposalId = AzemoraGovernor(governorAddr).propose(targets, values, calldatas, description);
 149 |     | 
 150 |     |         // Vote with the fuzzed vote type
 151 |     |         vm.roll(block.number + VOTING_DELAY + 1);
 152 |     |         vm.prank(voter);
 153 |     |         AzemoraGovernor(governorAddr).castVote(proposalId, voteType);
 154 |     | 
 155 |     |         // Verify the votes were counted correctly
 156 |     |         (uint256 againstVotes, uint256 forVotes, uint256 abstainVotes) =
 157 |     |             AzemoraGovernor(governorAddr).proposalVotes(proposalId);
 158 |     | 
 159 |     |         uint256 voterPower = token.getVotes(voter);
 160 |     | 
 161 |     |         if (voteType == 1) {
 162 |     |             // For
 163 |     |             assertEq(forVotes, voterPower, "For votes should match voter's power");
 164 |     |         } else if (voteType == 0) {
 165 |     |             // Against
 166 |     |             assertEq(againstVotes, voterPower, "Against votes should match voter's power");
 167 |     |         } else {
 168 |     |             // Abstain
 169 |     |             assertEq(abstainVotes, voterPower, "Abstain votes should match voter's power");
 170 |     |         }
 171 |     |     }
 172 |     | }
 173 |     | 

/home/phantom/Documents/azemora/azemora-contracts/test/governance/Governance.invariant.t.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | pragma solidity ^0.8.20;
   3 |     | 
   4 |     | import "forge-std/Test.sol";
   5 |     | import "../../src/token/AzemoraToken.sol";
   6 |     | import "../../src/governance/AzemoraGovernor.sol";
   7 |     | import "../../src/governance/AzemoraTimelockController.sol";
   8 |     | import "../../src/governance/Treasury.sol";
   9 |     | import "../../src/marketplace/Marketplace.sol";
  10 |     | import "../../src/core/DynamicImpactCredit.sol";
  11 |     | import "../../src/core/ProjectRegistry.sol";
  12 |     | import "@openzeppelin/contracts/proxy/ERC1967/ERC1967Proxy.sol";
  13 |     | 
  14 |     | // A mock ERC20 is needed for the Marketplace setup.
  15 |     | contract MockERC20ForGovTest {
  16 |     |     function mint(address, uint256) public {}
  17 |     | }
  18 |     | 
  19 |     | contract GovernanceInvariantTest is Test {
  20 |     |     // Use addresses instead of contract references to avoid conversion issues
  21 |     |     AzemoraToken token;
  22 |     |     address payable public timelockAddr;
  23 |     |     address payable public governorAddr;
  24 |     |     address payable public treasuryAddr;
  25 |     |     Marketplace marketplace;
  26 |     |     DynamicImpactCredit credit;
  27 |     |     MockERC20ForGovTest paymentToken;
  28 |     | 
  29 |     |     // Users
  30 |     |     address admin;
  31 |     |     address voter = makeAddr("voter");
  32 |     |     address voter2 = makeAddr("voter2");
  33 |     |     address poorVoter = makeAddr("poorVoter");
  34 |     |     address recipient = makeAddr("recipient");
  35 |     | 
  36 |     |     // Invariant state
  37 |     |     uint256 public initialTotalSupply;
  38 |     | 
  39 |     |     // Governance settings
  40 |     |     uint256 constant VOTING_DELAY = 1; // blocks
  41 |     |     uint256 constant VOTING_PERIOD = 5; // blocks
  42 |     |     uint256 constant MIN_DELAY = 1; // seconds
  43 |     |     uint256 constant PROPOSAL_THRESHOLD = 1000e18;
  44 |     | 
  45 |     |     function setUp() public {
  46 |     |         admin = address(this);
  47 |     | 
  48 |     |         // 1. Deploy Governance Token
  49 |     |         AzemoraToken tokenImpl = new AzemoraToken();
  50 |     |         bytes memory tokenInitData = abi.encodeCall(AzemoraToken.initialize, ());
  51 |     |         ERC1967Proxy tokenProxy = new ERC1967Proxy(address(tokenImpl), tokenInitData);
  52 |     |         token = AzemoraToken(address(tokenProxy));
  53 |     | 
  54 |     |         // 2. Deploy Timelock
  55 |     |         AzemoraTimelockController timelockImpl = new AzemoraTimelockController();
  56 |     |         bytes memory timelockInitData =
  57 |     |             abi.encodeCall(AzemoraTimelockController.initialize, (MIN_DELAY, new address[](0), new address[](0), admin));
  58 |     |         ERC1967Proxy timelockProxy = new ERC1967Proxy(address(timelockImpl), timelockInitData);
  59 |     |         timelockAddr = payable(address(timelockProxy));
  60 |     | 
  61 |     |         // 3. Deploy Governor
  62 |     |         AzemoraGovernor governorImpl = new AzemoraGovernor();
  63 |     |         bytes memory governorInitData = abi.encodeCall(
  64 |     |             AzemoraGovernor.initialize,
  65 |     |             (
  66 |     |                 token,
  67 |     |                 AzemoraTimelockController(timelockAddr),
  68 |     |                 uint48(VOTING_DELAY),
  69 |     |                 uint32(VOTING_PERIOD),
  70 |     |                 PROPOSAL_THRESHOLD
  71 |     |             )
  72 |     |         );
  73 |     |         ERC1967Proxy governorProxy = new ERC1967Proxy(address(governorImpl), governorInitData);
  74 |     |         governorAddr = payable(address(governorProxy));
  75 |     | 
  76 |     |         // 4. Deploy Treasury
  77 |     |         Treasury treasuryImpl = new Treasury();
  78 |     |         bytes memory treasuryInitData = abi.encodeCall(Treasury.initialize, (admin));
  79 |     |         ERC1967Proxy treasuryProxy = new ERC1967Proxy(address(treasuryImpl), treasuryInitData);
  80 |     |         treasuryAddr = payable(address(treasuryProxy));
  81 |     | 
  82 |     |         // 5. Deploy Marketplace and its dependencies
  83 |     |         paymentToken = new MockERC20ForGovTest();
  84 |     | 
  85 |     |         ProjectRegistry registryImpl = new ProjectRegistry();
  86 |     |         bytes memory registryInitData = abi.encodeCall(ProjectRegistry.initialize, ());
  87 |     |         ERC1967Proxy registryProxy = new ERC1967Proxy(address(registryImpl), registryInitData);
  88 |     |         ProjectRegistry registry = ProjectRegistry(address(registryProxy));
  89 |     | 
  90 |     |         DynamicImpactCredit creditImpl = new DynamicImpactCredit(address(registry));
  91 |     |         bytes memory creditInitData = abi.encodeCall(DynamicImpactCredit.initialize, ("uri"));
  92 |     |         ERC1967Proxy creditProxy = new ERC1967Proxy(address(creditImpl), creditInitData);
  93 |     |         credit = DynamicImpactCredit(address(creditProxy));
  94 |     | 
  95 |     |         Marketplace marketplaceImpl = new Marketplace();
  96 |     |         bytes memory marketplaceInitData =
  97 |     |             abi.encodeCall(Marketplace.initialize, (address(credit), address(paymentToken)));
  98 |     |         ERC1967Proxy marketplaceProxy = new ERC1967Proxy(address(marketplaceImpl), marketplaceInitData);
  99 |     |         marketplace = Marketplace(address(marketplaceProxy));
 100 |     | 
 101 |     |         // 6. Configure Roles & Ownership
 102 |     |         bytes32 proposerRole = AzemoraTimelockController(timelockAddr).PROPOSER_ROLE();
 103 |     |         bytes32 executorRole = AzemoraTimelockController(timelockAddr).EXECUTOR_ROLE();
 104 |     |         bytes32 timelockAdminRole = AzemoraTimelockController(timelockAddr).DEFAULT_ADMIN_ROLE();
 105 |     | 
 106 |     |         AzemoraTimelockController(timelockAddr).grantRole(proposerRole, governorAddr);
 107 |     |         AzemoraTimelockController(timelockAddr).grantRole(executorRole, address(0)); // Anyone can execute
 108 |     |         AzemoraTimelockController(timelockAddr).renounceRole(timelockAdminRole, admin);
 109 |     | 
 110 |     |         // Transfer ownership of manageable contracts to the Timelock
 111 |     |         bytes32 marketplaceAdminRole = marketplace.DEFAULT_ADMIN_ROLE();
 112 |     |         marketplace.grantRole(marketplaceAdminRole, timelockAddr);
 113 |     |         marketplace.renounceRole(marketplaceAdminRole, admin);
 114 |     | 
 115 |     |         Treasury(treasuryAddr).transferOwnership(timelockAddr);
 116 |     | 
 117 |     |         // 7. Distribute tokens and set up voters
 118 |     |         token.transfer(voter, 50_000_000e18);
 119 |     |         token.transfer(voter2, 60_000_000e18);
 120 |     |         token.transfer(poorVoter, 1e18);
 121 |     | 
 122 |     |         vm.prank(voter);
 123 |     |         token.delegate(voter);
 124 |     | 
 125 |     |         vm.prank(voter2);
 126 |     |         token.delegate(voter2);
 127 |     | 
 128 |     |         vm.prank(poorVoter);
 129 |     |         token.delegate(poorVoter);
 130 |     | 
 131 |     |         vm.deal(treasuryAddr, 10 ether);
 132 |     |         vm.roll(block.number + 1);
 133 |     | 
 134 |     |         // Set initial state for invariant testing
 135 |     |         initialTotalSupply = token.totalSupply();
 136 |     |     }
 137 |     | 
 138 |     |     /**
 139 |     |      * @dev Invariant: The total supply of the governance token should remain constant.
 140 |     |      * This ensures no new tokens are minted or burned unexpectedly.
 141 |     |      */
 142 |     |     function invariant_totalSupplyIsConstant() public view {
 143 |     |         assertEq(token.totalSupply(), initialTotalSupply, "The total supply of the governance token must never change.");
 144 |     |     }
 145 |     | }
 146 |     | 

/home/phantom/Documents/azemora/azemora-contracts/test/governance/Governance.t.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | pragma solidity ^0.8.20;
   3 |     | 
   4 |     | import "forge-std/Test.sol";
   5 |     | import "../../src/token/AzemoraToken.sol";
   6 |     | import "../../src/governance/AzemoraGovernor.sol";
   7 |     | import "../../src/governance/AzemoraTimelockController.sol";
   8 |     | import "../../src/governance/Treasury.sol";
   9 |     | import "../../src/marketplace/Marketplace.sol";
  10 |     | import "../../src/core/DynamicImpactCredit.sol";
  11 |     | import "../../src/core/ProjectRegistry.sol";
  12 |     | import "@openzeppelin/contracts/proxy/ERC1967/ERC1967Proxy.sol";
  13 |     | 
  14 |     | // A mock ERC20 is needed for the Marketplace setup.
  15 |     | // We can define it here to keep the test self-contained.
  16 |     | contract MockERC20ForGovTest {
  17 |     |     function mint(address, uint256) public {}
  18 |     | }
  19 |     | 
  20 |     | contract GovernanceTest is Test {
  21 |     |     // Use addresses instead of contract references to avoid conversion issues
  22 |     |     AzemoraToken token;
  23 |     |     address payable public timelockAddr;
  24 |     |     address payable public governorAddr;
  25 |     |     address payable public treasuryAddr;
  26 |     |     Marketplace marketplace;
  27 |     |     DynamicImpactCredit credit;
  28 |     |     MockERC20ForGovTest paymentToken;
  29 |     | 
  30 |     |     // Users
  31 |     |     address admin;
  32 |     |     address voter = makeAddr("voter");
  33 |     |     address voter2 = makeAddr("voter2");
  34 |     |     address poorVoter = makeAddr("poorVoter");
  35 |     |     address recipient = makeAddr("recipient");
  36 |     | 
  37 |     |     // Governance settings
  38 |     |     uint256 constant VOTING_DELAY = 1; // blocks
  39 |     |     uint256 constant VOTING_PERIOD = 5; // blocks
  40 |     |     uint256 constant MIN_DELAY = 1; // seconds
  41 |     |     uint256 constant PROPOSAL_THRESHOLD = 1000e18;
  42 |     | 
  43 |     |     function setUp() public {
  44 |     |         admin = address(this);
  45 |     | 
  46 |     |         // 1. Deploy Governance Token
  47 |     |         AzemoraToken tokenImpl = new AzemoraToken();
  48 |     |         bytes memory tokenInitData = abi.encodeCall(AzemoraToken.initialize, ());
  49 |     |         ERC1967Proxy tokenProxy = new ERC1967Proxy(address(tokenImpl), tokenInitData);
  50 |     |         token = AzemoraToken(address(tokenProxy));
  51 |     | 
  52 |     |         // 2. Deploy Timelock
  53 |     |         AzemoraTimelockController timelockImpl = new AzemoraTimelockController();
  54 |     |         bytes memory timelockInitData =
  55 |     |             abi.encodeCall(AzemoraTimelockController.initialize, (MIN_DELAY, new address[](0), new address[](0), admin));
  56 |     |         ERC1967Proxy timelockProxy = new ERC1967Proxy(address(timelockImpl), timelockInitData);
  57 |     |         timelockAddr = payable(address(timelockProxy));
  58 |     | 
  59 |     |         // 3. Deploy Governor
  60 |     |         AzemoraGovernor governorImpl = new AzemoraGovernor();
  61 |     |         // Use temporary direct casting for initialization only
  62 |     |         bytes memory governorInitData = abi.encodeCall(
  63 |     |             AzemoraGovernor.initialize,
  64 |     |             (
  65 |     |                 token,
  66 |     |                 AzemoraTimelockController(timelockAddr),
  67 |     |                 uint48(VOTING_DELAY),
  68 |     |                 uint32(VOTING_PERIOD),
  69 |     |                 PROPOSAL_THRESHOLD
  70 |     |             )
  71 |     |         );
  72 |     |         ERC1967Proxy governorProxy = new ERC1967Proxy(address(governorImpl), governorInitData);
  73 |     |         governorAddr = payable(address(governorProxy));
  74 |     | 
  75 |     |         // 4. Deploy Treasury
  76 |     |         Treasury treasuryImpl = new Treasury();
  77 |     |         bytes memory treasuryInitData = abi.encodeCall(Treasury.initialize, (admin));
  78 |     |         ERC1967Proxy treasuryProxy = new ERC1967Proxy(address(treasuryImpl), treasuryInitData);
  79 |     |         treasuryAddr = payable(address(treasuryProxy));
  80 |     | 
  81 |     |         // 5. Deploy Marketplace and its dependencies
  82 |     |         paymentToken = new MockERC20ForGovTest();
  83 |     | 
  84 |     |         ProjectRegistry registryImpl = new ProjectRegistry();
  85 |     |         bytes memory registryInitData = abi.encodeCall(ProjectRegistry.initialize, ());
  86 |     |         ERC1967Proxy registryProxy = new ERC1967Proxy(address(registryImpl), registryInitData);
  87 |     |         ProjectRegistry registry = ProjectRegistry(address(registryProxy));
  88 |     | 
  89 |     |         DynamicImpactCredit creditImpl = new DynamicImpactCredit(address(registry));
  90 |     |         bytes memory creditInitData = abi.encodeCall(DynamicImpactCredit.initialize, ("uri"));
  91 |     |         ERC1967Proxy creditProxy = new ERC1967Proxy(address(creditImpl), creditInitData);
  92 |     |         credit = DynamicImpactCredit(address(creditProxy));
  93 |     | 
  94 |     |         Marketplace marketplaceImpl = new Marketplace();
  95 |     |         bytes memory marketplaceInitData =
  96 |     |             abi.encodeCall(Marketplace.initialize, (address(credit), address(paymentToken)));
  97 |     |         ERC1967Proxy marketplaceProxy = new ERC1967Proxy(address(marketplaceImpl), marketplaceInitData);
  98 |     |         marketplace = Marketplace(address(marketplaceProxy));
  99 |     | 
 100 |     |         // 6. Configure Roles & Ownership using direct calls with casts
 101 |     |         // This is safe because we're only temporarily casting for function calls
 102 |     |         bytes32 proposerRole = AzemoraTimelockController(timelockAddr).PROPOSER_ROLE();
 103 |     |         bytes32 executorRole = AzemoraTimelockController(timelockAddr).EXECUTOR_ROLE();
 104 |     |         bytes32 timelockAdminRole = AzemoraTimelockController(timelockAddr).DEFAULT_ADMIN_ROLE();
 105 |     | 
 106 |     |         AzemoraTimelockController(timelockAddr).grantRole(proposerRole, governorAddr);
 107 |     |         AzemoraTimelockController(timelockAddr).grantRole(executorRole, address(0)); // Anyone can execute
 108 |     |         AzemoraTimelockController(timelockAddr).renounceRole(timelockAdminRole, admin);
 109 |     | 
 110 |     |         // Transfer ownership of manageable contracts to the Timelock
 111 |     |         bytes32 marketplaceAdminRole = marketplace.DEFAULT_ADMIN_ROLE();
 112 |     |         marketplace.grantRole(marketplaceAdminRole, timelockAddr);
 113 |     |         marketplace.renounceRole(marketplaceAdminRole, admin);
 114 |     | 
 115 |     |         // Transfer Treasury ownership to timelock
 116 |     |         Treasury(treasuryAddr).transferOwnership(timelockAddr);
 117 |     | 
 118 |     |         // 7. Distribute tokens and set up voters
 119 |     |         // Voter needs >4% of total supply (1B) to meet quorum. 50M = 5%.
 120 |     |         token.transfer(voter, 50_000_000e18); // Give voter 50M tokens (5%)
 121 |     |         token.transfer(voter2, 60_000_000e18); // Give voter2 60M tokens (6%) to have more power
 122 |     |         token.transfer(poorVoter, 1e18); // Give poorVoter 1 token (below proposal threshold)
 123 |     | 
 124 |     |         vm.prank(voter);
 125 |     |         token.delegate(voter); // Voter delegates voting power to themselves
 126 |     | 
 127 |     |         vm.prank(voter2);
 128 |     |         token.delegate(voter2);
 129 |     | 
 130 |     |         vm.prank(poorVoter);
 131 |     |         token.delegate(poorVoter);
 132 |     | 
 133 |     |         // Fund the treasury for the withdrawal test
 134 |     |         vm.deal(treasuryAddr, 10 ether);
 135 |     | 
 136 |     |         // Advance a block to ensure delegations are registered before any proposal is made
 137 |     |         vm.roll(block.number + 1);
 138 |     |     }
 139 |     | 
 140 |     |     function test_Governance_Full_Flow() public {
 141 |     |         // --- 1. Propose ---
 142 |     |         address[] memory targets = new address[](1);
 143 |     |         targets[0] = address(marketplace);
 144 |     |         uint256[] memory values = new uint256[](1); // No ETH being sent
 145 |     |         bytes[] memory calldatas = new bytes[](1);
 146 |     |         calldatas[0] = abi.encodeWithSelector(Marketplace.setTreasury.selector, treasuryAddr);
 147 |     |         string memory description = "Set marketplace fee recipient to Treasury";
 148 |     |         bytes32 descriptionHash = keccak256(bytes(description));
 149 |     | 
 150 |     |         // Propose the action - use temporary casting
 151 |     |         vm.prank(voter);
 152 |     |         uint256 proposalId = AzemoraGovernor(governorAddr).propose(targets, values, calldatas, description);
 153 |     | 
 154 |     |         // --- 2. Vote ---
 155 |     |         vm.roll(block.number + VOTING_DELAY + 1); // Wait for voting delay
 156 |     | 
 157 |     |         // Vote in favor - use temporary casting
 158 |     |         vm.prank(voter);
 159 |     |         AzemoraGovernor(governorAddr).castVote(proposalId, uint8(1)); // 1 = For
 160 |     | 
 161 |     |         // --- 3. Queue ---
 162 |     |         vm.roll(block.number + VOTING_PERIOD + 1); // Wait for voting period to end
 163 |     | 
 164 |     |         // Queue the proposal - use temporary casting
 165 |     |         AzemoraGovernor(governorAddr).queue(targets, values, calldatas, descriptionHash);
 166 |     | 
 167 |     |         // --- 4. Execute ---
 168 |     |         vm.warp(block.timestamp + MIN_DELAY + 1); // Wait for the timelock min delay
 169 |     | 
 170 |     |         // Execute the proposal - use temporary casting
 171 |     |         AzemoraGovernor(governorAddr).execute(targets, values, calldatas, descriptionHash);
 172 |     | 
 173 |     |         // --- 5. Verify ---
 174 |     |         assertEq(marketplace.treasury(), treasuryAddr, "Fee recipient should be the Treasury");
 175 |     |     }
 176 |     | 
 177 |     |     function test_Fail_When_Quorum_Not_Met() public {
 178 |     |         // --- 1. Propose ---
 179 |     |         address[] memory targets = new address[](1);
 180 |     |         targets[0] = address(marketplace);
 181 |     |         uint256[] memory values = new uint256[](1); // No ETH being sent
 182 |     |         bytes[] memory calldatas = new bytes[](1);
 183 |     |         calldatas[0] = abi.encodeWithSelector(Marketplace.setTreasury.selector, treasuryAddr);
 184 |     |         string memory description = "Set marketplace fee recipient to Treasury";
 185 |     | 
 186 |     |         // Propose the action with a valid proposer
 187 |     |         vm.prank(voter);
 188 |     |         uint256 proposalId = AzemoraGovernor(governorAddr).propose(targets, values, calldatas, description);
 189 |     | 
 190 |     |         // --- 2. Vote ---
 191 |     |         vm.roll(block.number + VOTING_DELAY + 1); // Wait for voting delay
 192 |     | 
 193 |     |         // Vote with a user who doesn't have enough tokens to meet quorum
 194 |     |         vm.prank(poorVoter);
 195 |     |         AzemoraGovernor(governorAddr).castVote(proposalId, uint8(1)); // 1 = For
 196 |     | 
 197 |     |         // --- 3. Check State ---
 198 |     |         vm.roll(block.number + VOTING_PERIOD + 1); // Wait for voting period to end
 199 |     | 
 200 |     |         // Proposal should be defeated because quorum was not met
 201 |     |         assertEq(uint256(AzemoraGovernor(governorAddr).state(proposalId)), 3); // 3 = Defeated
 202 |     |     }
 203 |     | 
 204 |     |     function test_Fail_When_Voted_Down() public {
 205 |     |         // --- 1. Propose ---
 206 |     |         address[] memory targets = new address[](1);
 207 |     |         targets[0] = address(marketplace);
 208 |     |         uint256[] memory values = new uint256[](1); // No ETH being sent
 209 |     |         bytes[] memory calldatas = new bytes[](1);
 210 |     |         calldatas[0] = abi.encodeWithSelector(Marketplace.setTreasury.selector, treasuryAddr);
 211 |     |         string memory description = "Set marketplace fee recipient to Treasury";
 212 |     | 
 213 |     |         // voter proposes
 214 |     |         vm.prank(voter);
 215 |     |         uint256 proposalId = AzemoraGovernor(governorAddr).propose(targets, values, calldatas, description);
 216 |     | 
 217 |     |         // --- 2. Vote ---
 218 |     |         vm.roll(block.number + VOTING_DELAY + 1); // Wait for voting delay
 219 |     | 
 220 |     |         // voter votes FOR
 221 |     |         vm.prank(voter);
 222 |     |         AzemoraGovernor(governorAddr).castVote(proposalId, uint8(1)); // 1 = For
 223 |     | 
 224 |     |         // voter2 has more tokens and votes AGAINST
 225 |     |         vm.prank(voter2);
 226 |     |         AzemoraGovernor(governorAddr).castVote(proposalId, uint8(0)); // 0 = Against
 227 |     | 
 228 |     |         // --- 3. Check State ---
 229 |     |         vm.roll(block.number + VOTING_PERIOD + 1); // Wait for voting period to end
 230 |     | 
 231 |     |         // Proposal should be defeated because against votes > for votes
 232 |     |         assertEq(uint256(AzemoraGovernor(governorAddr).state(proposalId)), 3); // 3 = Defeated
 233 |     |     }
 234 |     | 
 235 |     |     function test_Propose_And_Withdraw_From_Treasury() public {
 236 |     |         uint256 startingBalance = recipient.balance;
 237 |     |         uint256 treasuryBalance = address(treasuryAddr).balance;
 238 |     |         uint256 withdrawAmount = 1 ether;
 239 |     | 
 240 |     |         // --- 1. Propose ---
 241 |     |         address[] memory targets = new address[](1);
 242 |     |         targets[0] = treasuryAddr;
 243 |     |         uint256[] memory values = new uint256[](1); // No ETH being sent with the proposal itself
 244 |     |         bytes[] memory calldatas = new bytes[](1);
 245 |     |         calldatas[0] = abi.encodeWithSelector(Treasury.withdrawETH.selector, recipient, withdrawAmount);
 246 |     |         string memory description = "Proposal to withdraw 1 ETH from Treasury";
 247 |     |         bytes32 descriptionHash = keccak256(bytes(description));
 248 |     | 
 249 |     |         // Propose the action
 250 |     |         vm.prank(voter);
 251 |     |         uint256 proposalId = AzemoraGovernor(governorAddr).propose(targets, values, calldatas, description);
 252 |     | 
 253 |     |         // --- 2. Vote ---
 254 |     |         vm.roll(block.number + VOTING_DELAY + 1); // Wait for voting delay
 255 |     | 
 256 |     |         // Vote in favor
 257 |     |         vm.prank(voter);
 258 |     |         AzemoraGovernor(governorAddr).castVote(proposalId, uint8(1)); // 1 = For
 259 |     | 
 260 |     |         // --- 3. Queue ---
 261 |     |         vm.roll(block.number + VOTING_PERIOD + 1); // Wait for voting period to end
 262 |     | 
 263 |     |         // Queue the proposal
 264 |     |         AzemoraGovernor(governorAddr).queue(targets, values, calldatas, descriptionHash);
 265 |     | 
 266 |     |         // --- 4. Execute ---
 267 |     |         vm.warp(block.timestamp + MIN_DELAY + 1); // Wait for the timelock min delay
 268 |     | 
 269 |     |         // Execute the proposal
 270 |     |         AzemoraGovernor(governorAddr).execute(targets, values, calldatas, descriptionHash);
 271 |     | 
 272 |     |         // --- 5. Verify ---
 273 |     |         assertEq(recipient.balance, startingBalance + withdrawAmount, "Recipient should have received ETH");
 274 |     |         assertEq(
 275 |     |             address(treasuryAddr).balance, treasuryBalance - withdrawAmount, "Treasury balance should have decreased"
 276 |     |         );
 277 |     |     }
 278 |     | 
 279 |     |     function test_Fail_If_Proposer_Below_Threshold() public {
 280 |     |         vm.prank(poorVoter);
 281 |     | 
 282 |     |         address[] memory targets = new address[](1);
 283 |     |         targets[0] = address(marketplace);
 284 |     |         uint256[] memory values = new uint256[](1);
 285 |     |         bytes[] memory calldatas = new bytes[](1);
 286 |     |         calldatas[0] = abi.encodeWithSelector(Marketplace.setTreasury.selector, treasuryAddr);
 287 |     |         string memory description = "This proposal should fail";
 288 |     | 
 289 |     |         vm.expectRevert(
 290 |     |             abi.encodeWithSignature(
 291 |     |                 "GovernorInsufficientProposerVotes(address,uint256,uint256)", poorVoter, 1e18, PROPOSAL_THRESHOLD
 292 |     |             )
 293 |     |         );
 294 |     |         AzemoraGovernor(governorAddr).propose(targets, values, calldatas, description);
 295 |     |     }
 296 |     | 
 297 |     |     function test_Proposal_Cancellation_Permissions() public {
 298 |     |         // --- Setup ---
 299 |     |         address[] memory targets = new address[](1);
 300 |     |         targets[0] = address(marketplace);
 301 |     |         uint256[] memory values = new uint256[](1);
 302 |     |         bytes[] memory calldatas = new bytes[](1);
 303 |     |         calldatas[0] = abi.encodeWithSelector(Marketplace.setTreasury.selector, treasuryAddr);
 304 |     | 
 305 |     |         // --- Scenario 1: Proposer CAN cancel ---
 306 |     |         string memory description1 = "Proposal 1";
 307 |     |         bytes32 descriptionHash1 = keccak256(bytes(description1));
 308 |     |         vm.prank(voter);
 309 |     |         uint256 proposalId1 = AzemoraGovernor(governorAddr).propose(targets, values, calldatas, description1);
 310 |     | 
 311 |     |         vm.prank(voter); // The proposer themself cancels
 312 |     |         AzemoraGovernor(governorAddr).cancel(targets, values, calldatas, descriptionHash1);
 313 |     |         assertEq(uint256(AzemoraGovernor(governorAddr).state(proposalId1)), 2, "State should be Canceled by proposer");
 314 |     | 
 315 |     |         // --- Scenario 2: Non-proposer CANNOT cancel ---
 316 |     |         string memory description2 = "Proposal 2";
 317 |     |         bytes32 descriptionHash2 = keccak256(bytes(description2));
 318 |     |         vm.prank(voter); // voter makes a new proposal
 319 |     |         uint256 proposalId2 = AzemoraGovernor(governorAddr).propose(targets, values, calldatas, description2);
 320 |     | 
 321 |     |         vm.prank(voter2); // Non-proposer (voter2) attempts to cancel
 322 |     |         vm.expectRevert(abi.encodeWithSignature("GovernorUnableToCancel(uint256,address)", proposalId2, voter2));
 323 |     |         AzemoraGovernor(governorAddr).cancel(targets, values, calldatas, descriptionHash2);
 324 |     | 
 325 |     |         // Verify state is unchanged after failed cancellation attempt
 326 |     |         assertEq(uint256(AzemoraGovernor(governorAddr).state(proposalId2)), 0, "State should still be Pending");
 327 |     |     }
 328 |     | 
 329 |     |     function test_Execution_Fails_If_Target_Call_Reverts() public {
 330 |     |         uint256 treasuryBalance = address(treasuryAddr).balance; // 10 ether
 331 |     |         uint256 withdrawAmount = treasuryBalance + 1 ether; // Attempt to withdraw more than available
 332 |     | 
 333 |     |         // --- 1. Propose ---
 334 |     |         address[] memory targets = new address[](1);
 335 |     |         targets[0] = treasuryAddr;
 336 |     |         uint256[] memory values = new uint256[](1);
 337 |     |         bytes[] memory calldatas = new bytes[](1);
 338 |     |         calldatas[0] = abi.encodeWithSelector(Treasury.withdrawETH.selector, recipient, withdrawAmount);
 339 |     |         string memory description = "Proposal to withdraw more ETH than available";
 340 |     |         bytes32 descriptionHash = keccak256(bytes(description));
 341 |     | 
 342 |     |         // Propose, vote, and queue successfully
 343 |     |         vm.prank(voter);
 344 |     |         uint256 proposalId = AzemoraGovernor(governorAddr).propose(targets, values, calldatas, description);
 345 |     |         vm.roll(block.number + VOTING_DELAY + 1);
 346 |     |         vm.prank(voter);
 347 |     |         AzemoraGovernor(governorAddr).castVote(proposalId, uint8(1));
 348 |     |         vm.roll(block.number + VOTING_PERIOD + 1);
 349 |     |         AzemoraGovernor(governorAddr).queue(targets, values, calldatas, descriptionHash);
 350 |     | 
 351 |     |         // --- 2. Execute ---
 352 |     |         vm.warp(block.timestamp + MIN_DELAY + 1);
 353 |     | 
 354 |     |         // Expect execution to fail because the treasury withdrawal will revert
 355 |     |         vm.expectRevert("Insufficient ETH balance");
 356 |     |         AzemoraGovernor(governorAddr).execute(targets, values, calldatas, descriptionHash);
 357 |     |     }
 358 |     | }
 359 |     | 

/home/phantom/Documents/azemora/azemora-contracts/test/governance/Treasury.t.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | pragma solidity ^0.8.20;
  3 |     | 
  4 |     | import "forge-std/Test.sol";
  5 |     | import "../../src/governance/Treasury.sol";
  6 |     | import "@openzeppelin/contracts/proxy/ERC1967/ERC1967Proxy.sol";
  7 |     | 
  8 |     | // Minimal mock ERC20 to avoid dependency on forge-std/mocks
  9 |     | contract MockERC20 {
 10 |     |     event Transfer(address indexed from, address indexed to, uint256 value);
 11 |     |     event Approval(address indexed owner, address indexed spender, uint256 value);
 12 |     | 
 13 |     |     mapping(address => uint256) public balanceOf;
 14 |     |     mapping(address => mapping(address => uint256)) public allowance;
 15 |     |     uint256 public totalSupply;
 16 |     |     string public name;
 17 |     |     string public symbol;
 18 |     |     uint8 public decimals;
 19 |     | 
 20 |     |     constructor(string memory name_, string memory symbol_, uint8 decimals_) {
 21 |     |         name = name_;
 22 |     |         symbol = symbol_;
 23 |     |         decimals = decimals_;
 24 |     |     }
 25 |     | 
 26 |     |     function approve(address spender, uint256 amount) public returns (bool) {
 27 |     |         allowance[msg.sender][spender] = amount;
 28 |     |         emit Approval(msg.sender, spender, amount);
 29 |     |         return true;
 30 |     |     }
 31 |     | 
 32 |     |     function transfer(address to, uint256 amount) public returns (bool) {
 33 |     |         balanceOf[msg.sender] -= amount;
 34 |     |         balanceOf[to] += amount;
 35 |     |         emit Transfer(msg.sender, to, amount);
 36 |     |         return true;
 37 |     |     }
 38 |     | 
 39 |     |     function transferFrom(address from, address to, uint256 amount) public returns (bool) {
 40 |     |         require(balanceOf[from] >= amount, "ERC20: insufficient balance");
 41 |     |         require(allowance[from][msg.sender] >= amount, "ERC20: insufficient allowance");
 42 |     |         if (allowance[from][msg.sender] != type(uint256).max) {
 43 |     |             allowance[from][msg.sender] -= amount;
 44 |     |         }
 45 |     |         balanceOf[from] -= amount;
 46 |     |         balanceOf[to] += amount;
 47 |     |         emit Transfer(from, to, amount);
 48 |     |         return true;
 49 |     |     }
 50 |     | 
 51 |     |     function mint(address to, uint256 amount) public {
 52 |     |         balanceOf[to] += amount;
 53 |     |         totalSupply += amount;
 54 |     |         emit Transfer(address(0), to, amount);
 55 |     |     }
 56 |     | }
 57 |     | 
 58 |     | contract TreasuryTest is Test {
 59 |     |     Treasury treasury;
 60 |     |     MockERC20 token;
 61 |     | 
 62 |     |     address admin = address(0xA11CE);
 63 |     |     address anotherUser = address(0xBEEF);
 64 |     | 
 65 |     |     function setUp() public {
 66 |     |         token = new MockERC20("Mock Token", "MOCK", 18);
 67 |     | 
 68 |     |         vm.startPrank(admin);
 69 |     |         Treasury treasuryImpl = new Treasury();
 70 |     |         bytes memory treasuryInitData = abi.encodeCall(Treasury.initialize, (admin));
 71 |     |         ERC1967Proxy treasuryProxy = new ERC1967Proxy(address(treasuryImpl), treasuryInitData);
 72 |     |         treasury = Treasury(payable(address(treasuryProxy)));
 73 |     |         vm.stopPrank();
 74 |     | 
 75 |     |         // Fund treasury with some ETH and ERC20
 76 |     |         vm.deal(address(treasury), 1 ether);
 77 |     |         token.mint(address(treasury), 1000 * 1e18);
 78 |     |     }
 79 |     | 
 80 |     |     function test_WithdrawETH_RevertsOnZeroAddress() public {
 81 |     |         vm.prank(admin);
 82 |     |         vm.expectRevert("Cannot send to zero address");
 83 |     |         treasury.withdrawETH(address(0), 1 ether);
 84 |     |     }
 85 |     | 
 86 |     |     function test_WithdrawETH_RevertsOnInsufficientBalance() public {
 87 |     |         vm.prank(admin);
 88 |     |         vm.expectRevert("Insufficient ETH balance");
 89 |     |         treasury.withdrawETH(anotherUser, 2 ether);
 90 |     |     }
 91 |     | 
 92 |     |     function test_WithdrawERC20_RevertsOnZeroAddress() public {
 93 |     |         vm.prank(admin);
 94 |     |         vm.expectRevert("Cannot send to zero address");
 95 |     |         treasury.withdrawERC20(address(token), address(0), 100 * 1e18);
 96 |     |     }
 97 |     | }
 98 |     | 

/home/phantom/Documents/azemora/azemora-contracts/test/integration/FullFlow.t.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | pragma solidity ^0.8.20;
   3 |     | 
   4 |     | import "forge-std/Test.sol";
   5 |     | import "../../src/token/AzemoraToken.sol";
   6 |     | import "../../src/governance/AzemoraGovernor.sol";
   7 |     | import "../../src/governance/AzemoraTimelockController.sol";
   8 |     | import "../../src/governance/Treasury.sol";
   9 |     | import "../../src/marketplace/Marketplace.sol";
  10 |     | import "../../src/core/DynamicImpactCredit.sol";
  11 |     | import "../../src/core/ProjectRegistry.sol";
  12 |     | import "../../src/core/dMRVManager.sol";
  13 |     | import "@openzeppelin/contracts/proxy/ERC1967/ERC1967Proxy.sol";
  14 |     | 
  15 |     | // Re-using the mock from marketplace tests
  16 |     | contract MockERC20ForFlowTest {
  17 |     |     event Transfer(address indexed from, address indexed to, uint256 value);
  18 |     |     event Approval(address indexed owner, address indexed spender, uint256 value);
  19 |     | 
  20 |     |     mapping(address => uint256) public balanceOf;
  21 |     |     mapping(address => mapping(address => uint256)) public allowance;
  22 |     | 
  23 |     |     function approve(address spender, uint256 amount) public returns (bool) {
  24 |     |         allowance[msg.sender][spender] = amount;
  25 |     |         emit Approval(msg.sender, spender, amount);
  26 |     |         return true;
  27 |     |     }
  28 |     | 
  29 |     |     function transferFrom(address from, address to, uint256 amount) public returns (bool) {
  30 |     |         require(allowance[from][msg.sender] >= amount, "ERC20: insufficient allowance");
  31 |     |         if (allowance[from][msg.sender] != type(uint256).max) {
  32 |     |             allowance[from][msg.sender] -= amount;
  33 |     |         }
  34 |     |         balanceOf[from] -= amount;
  35 |     |         balanceOf[to] += amount;
  36 |     |         emit Transfer(from, to, amount);
  37 |     |         return true;
  38 |     |     }
  39 |     | 
  40 |     |     function transfer(address to, uint256 amount) public returns (bool) {
  41 |     |         // In the context of the treasury withdrawal, msg.sender will be the treasury contract
  42 |     |         require(balanceOf[msg.sender] >= amount, "ERC20: insufficient balance");
  43 |     |         balanceOf[msg.sender] -= amount;
  44 |     |         balanceOf[to] += amount;
  45 |     |         emit Transfer(msg.sender, to, amount);
  46 |     |         return true;
  47 |     |     }
  48 |     | 
  49 |     |     function mint(address to, uint256 amount) public {
  50 |     |         balanceOf[to] += amount;
  51 |     |         emit Transfer(address(0), to, amount);
  52 |     |     }
  53 |     | }
  54 |     | 
  55 |     | contract FullFlowTest is Test {
  56 |     |     // --- Contracts ---
  57 |     |     // Core Logic
  58 |     |     ProjectRegistry registry;
  59 |     |     DMRVManager dmrvManager;
  60 |     |     DynamicImpactCredit credit;
  61 |     |     Marketplace marketplace;
  62 |     |     // Governance
  63 |     |     AzemoraToken govToken;
  64 |     |     AzemoraGovernor governor;
  65 |     |     AzemoraTimelockController timelock;
  66 |     |     Treasury treasury;
  67 |     |     // Mocks
  68 |     |     MockERC20ForFlowTest paymentToken;
  69 |     | 
  70 |     |     // --- Actors ---
  71 |     |     address admin = makeAddr("admin");
  72 |     |     address projectDeveloper = makeAddr("projectDeveloper");
  73 |     |     address verifier = makeAddr("verifier");
  74 |     |     address dmrvOracle = makeAddr("dmrvOracle");
  75 |     |     address buyer = makeAddr("buyer");
  76 |     |     address governanceProposer = makeAddr("governanceProposer");
  77 |     |     address feeRecipient = makeAddr("feeRecipient");
  78 |     | 
  79 |     |     // --- Constants ---
  80 |     |     uint256 constant VOTING_DELAY = 1; // blocks
  81 |     |     uint256 constant VOTING_PERIOD = 5; // blocks
  82 |     |     uint256 constant MIN_DELAY = 1; // seconds
  83 |     | 
  84 |     |     function setUp() public {
  85 |     |         vm.startPrank(admin);
  86 |     | 
  87 |     |         // --- 1. DEPLOY GOVERNANCE & TREASURY ---
  88 |     |         AzemoraToken govTokenImpl = new AzemoraToken();
  89 |     |         govToken =
  90 |     |             AzemoraToken(address(new ERC1967Proxy(address(govTokenImpl), abi.encodeCall(AzemoraToken.initialize, ()))));
  91 |     | 
  92 |     |         AzemoraTimelockController timelockImpl = new AzemoraTimelockController();
  93 |     |         timelock = AzemoraTimelockController(
  94 |     |             payable(
  95 |     |                 address(
  96 |     |                     new ERC1967Proxy(
  97 |     |                         address(timelockImpl),
  98 |     |                         abi.encodeCall(
  99 |     |                             AzemoraTimelockController.initialize, (MIN_DELAY, new address[](0), new address[](0), admin)
 100 |     |                         )
 101 |     |                     )
 102 |     |                 )
 103 |     |             )
 104 |     |         );
 105 |     | 
 106 |     |         AzemoraGovernor governorImpl = new AzemoraGovernor();
 107 |     |         governor = AzemoraGovernor(
 108 |     |             payable(
 109 |     |                 address(
 110 |     |                     new ERC1967Proxy(
 111 |     |                         address(governorImpl),
 112 |     |                         abi.encodeCall(
 113 |     |                             AzemoraGovernor.initialize,
 114 |     |                             (govToken, timelock, uint48(VOTING_DELAY), uint32(VOTING_PERIOD), 0)
 115 |     |                         )
 116 |     |                     )
 117 |     |                 )
 118 |     |             )
 119 |     |         );
 120 |     | 
 121 |     |         Treasury treasuryImpl = new Treasury();
 122 |     |         treasury = Treasury(
 123 |     |             payable(address(new ERC1967Proxy(address(treasuryImpl), abi.encodeCall(Treasury.initialize, (admin)))))
 124 |     |         );
 125 |     |         vm.deal(address(treasury), 10 ether); // Pre-fund treasury for other tests if needed
 126 |     | 
 127 |     |         // --- 2. DEPLOY CORE LOGIC ---
 128 |     |         ProjectRegistry registryImpl = new ProjectRegistry();
 129 |     |         registry = ProjectRegistry(
 130 |     |             address(new ERC1967Proxy(address(registryImpl), abi.encodeCall(ProjectRegistry.initialize, ())))
 131 |     |         );
 132 |     | 
 133 |     |         DynamicImpactCredit creditImpl = new DynamicImpactCredit(address(registry));
 134 |     |         credit = DynamicImpactCredit(
 135 |     |             address(new ERC1967Proxy(address(creditImpl), abi.encodeCall(DynamicImpactCredit.initialize, ("ipfs://"))))
 136 |     |         );
 137 |     | 
 138 |     |         DMRVManager dmrvManagerImpl = new DMRVManager(address(registry), address(credit));
 139 |     |         dmrvManager =
 140 |     |             DMRVManager(address(new ERC1967Proxy(address(dmrvManagerImpl), abi.encodeCall(DMRVManager.initialize, ()))));
 141 |     | 
 142 |     |         // --- 3. DEPLOY MARKETPLACE ---
 143 |     |         paymentToken = new MockERC20ForFlowTest();
 144 |     |         Marketplace marketplaceImpl = new Marketplace();
 145 |     |         marketplace = Marketplace(
 146 |     |             address(
 147 |     |                 new ERC1967Proxy(
 148 |     |                     address(marketplaceImpl),
 149 |     |                     abi.encodeCall(Marketplace.initialize, (address(credit), address(paymentToken)))
 150 |     |                 )
 151 |     |             )
 152 |     |         );
 153 |     | 
 154 |     |         // --- 4. CONFIGURE ROLES & OWNERSHIP ---
 155 |     |         // Grant dMRVManager the right to mint credits
 156 |     |         credit.grantRole(credit.DMRV_MANAGER_ROLE(), address(dmrvManager));
 157 |     |         // Grant verifier role in the registry
 158 |     |         registry.grantRole(registry.VERIFIER_ROLE(), verifier);
 159 |     |         // Grant oracle role in dMRV Manager
 160 |     |         dmrvManager.grantRole(dmrvManager.ORACLE_ROLE(), dmrvOracle);
 161 |     |         // Set marketplace treasury
 162 |     |         marketplace.setTreasury(address(treasury));
 163 |     |         marketplace.setFee(500); // 5% fee
 164 |     | 
 165 |     |         // Configure Governance
 166 |     |         bytes32 proposerRole = timelock.PROPOSER_ROLE();
 167 |     |         bytes32 executorRole = timelock.EXECUTOR_ROLE();
 168 |     |         bytes32 timelockAdminRole = timelock.DEFAULT_ADMIN_ROLE();
 169 |     | 
 170 |     |         timelock.grantRole(proposerRole, address(governor));
 171 |     |         timelock.grantRole(executorRole, address(0)); // Anyone can execute
 172 |     | 
 173 |     |         // Transfer contract ownership to the Timelock/DAO
 174 |     |         treasury.transferOwnership(address(timelock));
 175 |     |         // Note: Other contracts with admin roles would also be transferred here in a real scenario
 176 |     |         // e.g., marketplace.grantRole(marketplace.DEFAULT_ADMIN_ROLE(), address(timelock));
 177 |     | 
 178 |     |         // Renounce initial admin control
 179 |     |         timelock.renounceRole(timelockAdminRole, admin);
 180 |     | 
 181 |     |         // --- 5. SETUP ACTOR STATE ---
 182 |     |         // Fund buyer with payment tokens
 183 |     |         paymentToken.mint(buyer, 1_000_000 * 1e18);
 184 |     |         // Fund proposer with enough governance tokens to pass quorum (4% of 1B)
 185 |     |         govToken.transfer(governanceProposer, 40_000_000e18);
 186 |     | 
 187 |     |         vm.stopPrank(); // End the admin's multi-line prank
 188 |     | 
 189 |     |         vm.prank(governanceProposer); // Start a new single-line prank for the proposer
 190 |     |         govToken.delegate(governanceProposer);
 191 |     | 
 192 |     |         vm.roll(block.number + 1); // Let delegations register
 193 |     |     }
 194 |     | 
 195 |     |     function test_Full_End_To_End_Lifecycle() public {
 196 |     |         // --- STAGE 1: Project Creation & Verification ---
 197 |     |         bytes32 projectId = keccak256("Great Green Wall");
 198 |     |         vm.prank(projectDeveloper);
 199 |     |         registry.registerProject(projectId, "ipfs://great-green-wall");
 200 |     | 
 201 |     |         vm.prank(verifier);
 202 |     |         registry.setProjectStatus(projectId, ProjectRegistry.ProjectStatus.Active);
 203 |     |         assertEq(
 204 |     |             uint256(registry.getProject(projectId).status),
 205 |     |             uint256(ProjectRegistry.ProjectStatus.Active),
 206 |     |             "Project should be active"
 207 |     |         );
 208 |     | 
 209 |     |         // --- STAGE 2: dMRV and Credit Minting ---
 210 |     |         uint256 creditsToMint = 500;
 211 |     |         string memory verificationURI = "ipfs://verification-report-1";
 212 |     | 
 213 |     |         // 2.1 Project developer requests verification
 214 |     |         vm.prank(projectDeveloper);
 215 |     |         bytes32 requestId = dmrvManager.requestVerification(projectId);
 216 |     | 
 217 |     |         // 2.2 Oracle fulfills the verification request
 218 |     |         vm.prank(dmrvOracle);
 219 |     |         bytes memory verificationData = abi.encode(creditsToMint, false, bytes32(0), verificationURI);
 220 |     |         dmrvManager.fulfillVerification(requestId, verificationData);
 221 |     | 
 222 |     |         assertEq(
 223 |     |             credit.balanceOf(projectDeveloper, uint256(projectId)),
 224 |     |             creditsToMint,
 225 |     |             "Developer should have minted credits"
 226 |     |         );
 227 |     | 
 228 |     |         // --- STAGE 3: Marketplace Listing & Purchase ---
 229 |     |         uint256 listAmount = 100;
 230 |     |         uint256 pricePerUnit = 20 * 1e18; // 20 payment tokens per credit
 231 |     |         uint256 listingId;
 232 |     | 
 233 |     |         vm.startPrank(projectDeveloper);
 234 |     |         credit.setApprovalForAll(address(marketplace), true);
 235 |     |         listingId = marketplace.list(uint256(projectId), listAmount, pricePerUnit, 1 days);
 236 |     |         vm.stopPrank();
 237 |     | 
 238 |     |         assertEq(
 239 |     |             credit.balanceOf(address(marketplace), uint256(projectId)),
 240 |     |             listAmount,
 241 |     |             "Marketplace should hold listed credits"
 242 |     |         );
 243 |     | 
 244 |     |         uint256 buyAmount = 50;
 245 |     |         uint256 totalPrice = buyAmount * pricePerUnit;
 246 |     |         uint256 fee = (totalPrice * marketplace.feeBps()) / 10000;
 247 |     | 
 248 |     |         uint256 treasuryInitialBalance = paymentToken.balanceOf(address(treasury));
 249 |     | 
 250 |     |         vm.startPrank(buyer);
 251 |     |         paymentToken.approve(address(marketplace), totalPrice);
 252 |     |         marketplace.buy(listingId, buyAmount);
 253 |     |         vm.stopPrank();
 254 |     | 
 255 |     |         assertEq(credit.balanceOf(buyer, uint256(projectId)), buyAmount, "Buyer should receive purchased credits");
 256 |     |         assertEq(
 257 |     |             paymentToken.balanceOf(address(treasury)), treasuryInitialBalance + fee, "Treasury should receive fees"
 258 |     |         );
 259 |     | 
 260 |     |         // --- STAGE 4: Governance Withdraws Fees ---
 261 |     |         uint256 treasuryBalanceBefore = paymentToken.balanceOf(address(treasury));
 262 |     |         uint256 recipientBalanceBefore = paymentToken.balanceOf(feeRecipient);
 263 |     | 
 264 |     |         // 4.1 Propose
 265 |     |         address[] memory targets = new address[](1);
 266 |     |         targets[0] = address(treasury); // The timelock will call the Treasury contract
 267 |     |         uint256[] memory values = new uint256[](1); // No ETH
 268 |     |         bytes[] memory calldatas = new bytes[](1);
 269 |     |         // The proposal tells the timelock to call 'withdrawERC20' on the treasury
 270 |     |         calldatas[0] = abi.encodeWithSelector(
 271 |     |             Treasury.withdrawERC20.selector, address(paymentToken), feeRecipient, treasuryBalanceBefore
 272 |     |         );
 273 |     | 
 274 |     |         string memory description = "Withdraw collected fees from Treasury";
 275 |     |         bytes32 descriptionHash = keccak256(bytes(description));
 276 |     | 
 277 |     |         vm.prank(governanceProposer);
 278 |     |         uint256 proposalId = governor.propose(targets, values, calldatas, description);
 279 |     | 
 280 |     |         // 4.2 Vote
 281 |     |         vm.roll(block.number + VOTING_DELAY + 1);
 282 |     |         vm.prank(governanceProposer);
 283 |     |         governor.castVote(proposalId, uint8(1)); // Vote FOR
 284 |     | 
 285 |     |         // 4.3 Queue & Execute
 286 |     |         vm.roll(block.number + VOTING_PERIOD + 1);
 287 |     |         governor.queue(targets, values, calldatas, descriptionHash);
 288 |     |         vm.warp(block.timestamp + MIN_DELAY + 1);
 289 |     |         governor.execute(targets, values, calldatas, descriptionHash);
 290 |     | 
 291 |     |         // --- STAGE 5: Final Verification ---
 292 |     |         assertEq(paymentToken.balanceOf(address(treasury)), 0, "Treasury should be empty after withdrawal");
 293 |     |         assertEq(
 294 |     |             paymentToken.balanceOf(feeRecipient),
 295 |     |             recipientBalanceBefore + treasuryBalanceBefore,
 296 |     |             "Fee Recipient should receive funds"
 297 |     |         );
 298 |     |     }
 299 |     | }
 300 |     | 

/home/phantom/Documents/azemora/azemora-contracts/test/invariants/Fee.invariant.t.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | pragma solidity ^0.8.20;
   3 |     | 
   4 |     | import "forge-std/Test.sol";
   5 |     | import "../../src/marketplace/Marketplace.sol";
   6 |     | import "../../src/governance/Treasury.sol";
   7 |     | import "../../src/core/DynamicImpactCredit.sol";
   8 |     | import "../../src/core/ProjectRegistry.sol";
   9 |     | import "@openzeppelin/contracts/proxy/ERC1967/ERC1967Proxy.sol";
  10 |     | import "@openzeppelin/contracts/mocks/token/ERC20Mock.sol";
  11 |     | import "../marketplace/Marketplace.t.sol";
  12 |     | 
  13 |     | // THE FIX: Define an interface to break the circular dependency.
  14 |     | // The handler will call this interface, and the test contract will implement it.
  15 |     | interface IFeeCallback {
  16 |     |     function addFee(uint256 fee) external;
  17 |     | }
  18 |     | 
  19 |     | /*
  20 |     |  * @title FeeInvariantHandler
  21 |     |  * @notice The "fuzzer actor" that performs random actions on the marketplace.
  22 |     |  * @dev Foundry's fuzzer will call the functions on this contract. This handler
  23 |     |  *      is stateful and attempts to perform valid operations. If an operation
  24 |     |  *      succeeds, it notifies the main test contract to update the ghost variable.
  25 |     |  */
  26 |     | // THE FIX: The handler must inherit from `Test` to use `vm` cheatcodes.
  27 |     | contract FeeInvariantHandler is Test {
  28 |     |     IFeeCallback immutable mainTest; // Depends on the simple interface
  29 |     |     Marketplace immutable marketplace;
  30 |     |     ERC20Mock immutable paymentToken;
  31 |     |     address immutable treasury;
  32 |     |     address immutable seller;
  33 |     |     address immutable buyer;
  34 |     |     uint256 immutable tokenId;
  35 |     | 
  36 |     |     // Keep track of listings created by this handler to try and buy from them.
  37 |     |     uint256[] public listingIds;
  38 |     | 
  39 |     |     constructor(
  40 |     |         IFeeCallback _mainTest, // Takes the interface as an argument
  41 |     |         Marketplace _marketplace,
  42 |     |         ERC20Mock _paymentToken,
  43 |     |         address _treasury,
  44 |     |         address _seller,
  45 |     |         address _buyer,
  46 |     |         uint256 _tokenId
  47 |     |     ) {
  48 |     |         mainTest = _mainTest;
  49 |     |         marketplace = _marketplace;
  50 |     |         paymentToken = _paymentToken;
  51 |     |         treasury = _treasury;
  52 |     |         seller = _seller;
  53 |     |         buyer = _buyer;
  54 |     |         tokenId = _tokenId;
  55 |     |     }
  56 |     | 
  57 |     |     /// @notice FUZZ ACTION: List 1 token for 1 ether.
  58 |     |     function list() public {
  59 |     |         vm.prank(seller);
  60 |     |         // We list only 1 token to have more individual listings to interact with.
  61 |     |         // This call can revert if the seller runs out of tokens, which is fine.
  62 |     |         try marketplace.list(tokenId, 1, 1 ether, 1 days) returns (uint256 newListingId) {
  63 |     |             listingIds.push(newListingId);
  64 |     |         } catch {}
  65 |     |     }
  66 |     | 
  67 |     |     /// @notice FUZZ ACTION: Attempt to buy 1 token from a random listing.
  68 |     |     function buy() public {
  69 |     |         if (listingIds.length == 0) return;
  70 |     | 
  71 |     |         // Pick a random listing to attempt to buy from.
  72 |     |         uint256 listingIndex = block.timestamp % listingIds.length;
  73 |     |         uint256 listingId = listingIds[listingIndex];
  74 |     | 
  75 |     |         // Check if the listing is still valid before attempting the buy.
  76 |     |         try marketplace.getListing(listingId) returns (Marketplace.Listing memory listing) {
  77 |     |             if (!listing.active || listing.amount == 0) return;
  78 |     | 
  79 |     |             uint256 amountToBuy = 1;
  80 |     |             uint256 cost = amountToBuy * listing.pricePerUnit;
  81 |     | 
  82 |     |             // Fuzzer needs funds to succeed.
  83 |     |             if (paymentToken.balanceOf(buyer) < cost) return;
  84 |     | 
  85 |     |             uint256 treasuryBalanceBefore = paymentToken.balanceOf(treasury);
  86 |     | 
  87 |     |             vm.prank(buyer);
  88 |     |             try marketplace.buy(listingId, amountToBuy) {
  89 |     |                 // SUCCESS CASE: The buy succeeded. Calculate the fee and update the ghost variable.
  90 |     |                 uint256 treasuryBalanceAfter = paymentToken.balanceOf(treasury);
  91 |     |                 uint256 feeCollected = treasuryBalanceAfter - treasuryBalanceBefore;
  92 |     |                 // This call now works correctly through the interface.
  93 |     |                 mainTest.addFee(feeCollected);
  94 |     |             } catch {}
  95 |     |         } catch {}
  96 |     |     }
  97 |     | 
  98 |     |     /// @notice FUZZ ACTION: Attempt to cancel a random listing.
  99 |     |     function cancel() public {
 100 |     |         if (listingIds.length == 0) return;
 101 |     |         uint256 listingIndex = block.timestamp % listingIds.length;
 102 |     |         uint256 listingId = listingIds[listingIndex];
 103 |     | 
 104 |     |         vm.prank(seller);
 105 |     |         // This may revert if the listing is already inactive, which is fine.
 106 |     |         try marketplace.cancelListing(listingId) {} catch {}
 107 |     |     }
 108 |     | }
 109 |     | 
 110 |     | /*
 111 |     |  * @title FeeInvariantTest
 112 |     |  * @notice An invariant test to ensure marketplace fees are always correctly accounted for.
 113 |     |  * @dev THE FIX: This contract now implements the IFeeCallback interface.
 114 |     |  */
 115 |     | contract FeeInvariantTest is Test, IFeeCallback {
 116 |     |     // Contracts
 117 |     |     Marketplace marketplace;
 118 |     |     Treasury treasury;
 119 |     |     DynamicImpactCredit credit;
 120 |     |     ProjectRegistry registry;
 121 |     |     ERC20Mock paymentToken;
 122 |     | 
 123 |     |     // Users
 124 |     |     address admin = makeAddr("admin");
 125 |     |     address seller = makeAddr("seller");
 126 |     |     address buyer = makeAddr("buyer");
 127 |     | 
 128 |     |     // The GHOST VARIABLE: Tracks the total fees that should have been collected.
 129 |     |     uint256 public totalFeesCalculated;
 130 |     | 
 131 |     |     function setUp() public {
 132 |     |         vm.startPrank(admin);
 133 |     |         // Deploy all contracts
 134 |     |         ProjectRegistry registryImpl = new ProjectRegistry();
 135 |     |         registry = ProjectRegistry(
 136 |     |             address(new ERC1967Proxy(address(registryImpl), abi.encodeCall(ProjectRegistry.initialize, ())))
 137 |     |         );
 138 |     |         treasury = Treasury(payable(address(new ERC1967Proxy(address(new Treasury()), ""))));
 139 |     |         treasury.initialize(admin);
 140 |     |         credit = DynamicImpactCredit(address(new ERC1967Proxy(address(new DynamicImpactCredit(address(registry))), "")));
 141 |     |         credit.initialize("ipfs://");
 142 |     |         paymentToken = new ERC20Mock();
 143 |     |         marketplace = Marketplace(
 144 |     |             address(
 145 |     |                 new ERC1967Proxy(
 146 |     |                     address(new Marketplace()),
 147 |     |                     abi.encodeCall(Marketplace.initialize, (address(credit), address(paymentToken)))
 148 |     |                 )
 149 |     |             )
 150 |     |         );
 151 |     |         marketplace.setTreasury(address(treasury));
 152 |     |         marketplace.setFee(250); // 2.5%
 153 |     | 
 154 |     |         // Setup Project
 155 |     |         bytes32 projectId = keccak256("Test Project");
 156 |     |         uint256 tokenId = uint256(projectId);
 157 |     |         registry.registerProject(projectId, "ipfs://");
 158 |     |         registry.setProjectStatus(projectId, ProjectRegistry.ProjectStatus.Active);
 159 |     |         credit.grantRole(credit.DMRV_MANAGER_ROLE(), seller);
 160 |     | 
 161 |     |         vm.stopPrank();
 162 |     | 
 163 |     |         // --- Fund Users and Set Approvals ---
 164 |     |         // Seller gets 1,000 credits to list
 165 |     |         vm.prank(seller);
 166 |     |         credit.mintCredits(seller, projectId, 1000, "");
 167 |     |         credit.setApprovalForAll(address(marketplace), true);
 168 |     | 
 169 |     |         // Buyer gets 1,000,000 payment tokens and approves marketplace
 170 |     |         paymentToken.mint(buyer, 1_000_000 * 1 ether);
 171 |     |         vm.prank(buyer);
 172 |     |         paymentToken.approve(address(marketplace), type(uint256).max);
 173 |     | 
 174 |     |         // --- Setup Handler ---
 175 |     |         FeeInvariantHandler handler =
 176 |     |             new FeeInvariantHandler(this, marketplace, paymentToken, address(treasury), seller, buyer, tokenId);
 177 |     |         // Tell the fuzzer to call functions on the handler
 178 |     |         targetContract(address(handler));
 179 |     |     }
 180 |     | 
 181 |     |     /// @notice Implementation of the callback function for the handler.
 182 |     |     function addFee(uint256 fee) external override {
 183 |     |         totalFeesCalculated += fee;
 184 |     |     }
 185 |     | 
 186 |     |     /*
 187 |     |      * @notice INVARIANT: The Treasury's balance must always equal the sum of all fees collected.
 188 |     |      * @dev After every random action by the handler, this invariant checks that our off-chain
 189 |     |      *      calculation of fees matches the actual on-chain balance of the Treasury. This proves
 190 |     |      *      that fees are never lost, created from nothing, or sent to the wrong place.
 191 |     |      */
 192 |     |     function invariant_feeAccountingIsCorrect() public view {
 193 |     |         assertEq(
 194 |     |             totalFeesCalculated,
 195 |     |             paymentToken.balanceOf(address(treasury)),
 196 |     |             "Fee Invariant Violated: Treasury balance does not match calculated fees."
 197 |     |         );
 198 |     |     }
 199 |     | }
 200 |     | 

/home/phantom/Documents/azemora/azemora-contracts/test/invariants/Project.invariant.t.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | pragma solidity ^0.8.20;
   3 |     | 
   4 |     | import "forge-std/Test.sol";
   5 |     | import "../../src/core/ProjectRegistry.sol";
   6 |     | import "@openzeppelin/contracts/proxy/ERC1967/ERC1967Proxy.sol";
   7 |     | 
   8 |     | // Interface to break the circular dependency between the test and the handler.
   9 |     | interface IProjectStateCallback {
  10 |     |     function trackProjectCreation(bytes32 projectId) external;
  11 |     |     function trackStateChange(bytes32 projectId, ProjectRegistry.ProjectStatus newStatus) external;
  12 |     | }
  13 |     | 
  14 |     | /**
  15 |     |  * @title ProjectStateHandler
  16 |     |  * @notice The "fuzzer actor" that performs random actions on the ProjectRegistry.
  17 |     |  * @dev Foundry's fuzzer calls this handler's functions. The handler attempts
  18 |     |  *      valid and invalid state transitions. If a transition succeeds, it notifies
  19 |     |  *      the main test contract to update the ghost state variables.
  20 |     |  */
  21 |     | contract ProjectStateHandler is Test {
  22 |     |     IProjectStateCallback immutable mainTest;
  23 |     |     ProjectRegistry immutable registry;
  24 |     |     address immutable projectCreator;
  25 |     |     address immutable verifier;
  26 |     | 
  27 |     |     // Keep track of projects created by this handler to randomly interact with them.
  28 |     |     bytes32[] public projectIds;
  29 |     | 
  30 |     |     constructor(
  31 |     |         IProjectStateCallback _mainTest,
  32 |     |         ProjectRegistry _registry,
  33 |     |         address _projectCreator,
  34 |     |         address _verifier
  35 |     |     ) {
  36 |     |         mainTest = _mainTest;
  37 |     |         registry = _registry;
  38 |     |         projectCreator = _projectCreator;
  39 |     |         verifier = _verifier;
  40 |     |     }
  41 |     | 
  42 |     |     /// @notice FUZZ ACTION: Register a new project.
  43 |     |     function register() public {
  44 |     |         // Create a unique project ID for each registration attempt.
  45 |     |         bytes32 projectId = keccak256(abi.encodePacked("Project ", projectIds.length));
  46 |     |         vm.prank(projectCreator);
  47 |     | 
  48 |     |         // This call is not expected to revert under normal circumstances.
  49 |     |         try registry.registerProject(projectId, "ipfs://") {
  50 |     |             projectIds.push(projectId);
  51 |     |             mainTest.trackProjectCreation(projectId);
  52 |     |         } catch {}
  53 |     |     }
  54 |     | 
  55 |     |     /// @notice FUZZ ACTION: Attempt to change a project's status to a random new state.
  56 |     |     function setStatus(ProjectRegistry.ProjectStatus newStatus) public {
  57 |     |         if (projectIds.length == 0) return;
  58 |     | 
  59 |     |         // Pick a random project to try and change.
  60 |     |         uint256 projectIndex = block.timestamp % projectIds.length;
  61 |     |         bytes32 projectId = projectIds[projectIndex];
  62 |     | 
  63 |     |         // Randomly use the admin (projectCreator) or the verifier to attempt the state change.
  64 |     |         // This is crucial to test the role-based access control of setProjectStatus.
  65 |     |         address actor = (block.timestamp % 2 == 0) ? projectCreator : verifier;
  66 |     |         vm.prank(actor);
  67 |     | 
  68 |     |         // This call is EXPECTED to revert often, as the fuzzer will try invalid state transitions.
  69 |     |         // This is exactly what we want to test.
  70 |     |         try registry.setProjectStatus(projectId, newStatus) {
  71 |     |             // SUCCESS CASE: The state transition was valid. Notify the main test.
  72 |     |             mainTest.trackStateChange(projectId, newStatus);
  73 |     |         } catch {}
  74 |     |     }
  75 |     | }
  76 |     | 
  77 |     | /**
  78 |     |  * @title ProjectInvariantTest
  79 |     |  * @notice An invariant test to ensure the project lifecycle state machine is always respected.
  80 |     |  */
  81 |     | contract ProjectInvariantTest is Test, IProjectStateCallback {
  82 |     |     // Contracts
  83 |     |     ProjectRegistry registry;
  84 |     | 
  85 |     |     // Users
  86 |     |     address admin = makeAddr("admin");
  87 |     |     address projectCreator = makeAddr("projectCreator"); // Also has ADMIN_ROLE for this test
  88 |     |     address verifier = makeAddr("verifier");
  89 |     | 
  90 |     |     // The GHOST STATE: Tracks the current state of all projects created by the fuzzer.
  91 |     |     mapping(bytes32 => ProjectRegistry.ProjectStatus) public projectStates;
  92 |     | 
  93 |     |     function setUp() public {
  94 |     |         vm.startPrank(admin);
  95 |     |         registry = ProjectRegistry(address(new ERC1967Proxy(address(new ProjectRegistry()), "")));
  96 |     |         registry.initialize();
  97 |     |         // Grant the creator the admin role to allow pausing/archiving.
  98 |     |         registry.grantRole(registry.DEFAULT_ADMIN_ROLE(), projectCreator);
  99 |     |         // Grant the verifier role.
 100 |     |         registry.grantRole(registry.VERIFIER_ROLE(), verifier);
 101 |     |         vm.stopPrank();
 102 |     | 
 103 |     |         // --- Setup Handler ---
 104 |     |         ProjectStateHandler handler = new ProjectStateHandler(this, registry, projectCreator, verifier);
 105 |     |         // Tell the fuzzer to call functions on the handler.
 106 |     |         targetContract(address(handler));
 107 |     |     }
 108 |     | 
 109 |     |     // --- Callback Functions (called by handler) ---
 110 |     | 
 111 |     |     function trackProjectCreation(bytes32 projectId) external override {
 112 |     |         // New projects are created in the Pending state.
 113 |     |         projectStates[projectId] = ProjectRegistry.ProjectStatus.Pending;
 114 |     |     }
 115 |     | 
 116 |     |     /*
 117 |     |      * @notice INVARIANT: Asserts the correctness of the project state machine.
 118 |     |      * @dev This callback is invoked by the handler ONLY when a `setProjectStatus` call
 119 |     |      *      succeeds. It then checks if the transition from the old state to the new
 120 |     |      *      state was valid according to our defined state machine rules. If an invalid
 121 |     |      *      transition somehow succeeds on-chain, this assertion will fail, proving a
 122 |     |      *      vulnerability in the contract's state transition logic.
 123 |     |      */
 124 |     |     function trackStateChange(bytes32 projectId, ProjectRegistry.ProjectStatus newStatus) external override {
 125 |     |         ProjectRegistry.ProjectStatus oldStatus = projectStates[projectId];
 126 |     | 
 127 |     |         // State machine logic validation
 128 |     |         if (oldStatus == ProjectRegistry.ProjectStatus.Pending) {
 129 |     |             // From Pending, can only move to Active (verified) or Archived (rejected).
 130 |     |             bool isValid =
 131 |     |                 newStatus == ProjectRegistry.ProjectStatus.Active || newStatus == ProjectRegistry.ProjectStatus.Archived;
 132 |     |             assertTrue(isValid, "INVALID_TRANSITION_FROM_PENDING");
 133 |     |         } else if (oldStatus == ProjectRegistry.ProjectStatus.Active) {
 134 |     |             // From Active, can only move to Paused or Archived.
 135 |     |             bool isValid =
 136 |     |                 newStatus == ProjectRegistry.ProjectStatus.Paused || newStatus == ProjectRegistry.ProjectStatus.Archived;
 137 |     |             assertTrue(isValid, "INVALID_TRANSITION_FROM_ACTIVE");
 138 |     |         } else if (oldStatus == ProjectRegistry.ProjectStatus.Paused) {
 139 |     |             // From Paused, can move back to Active or be Archived.
 140 |     |             bool isValid =
 141 |     |                 newStatus == ProjectRegistry.ProjectStatus.Active || newStatus == ProjectRegistry.ProjectStatus.Archived;
 142 |     |             assertTrue(isValid, "INVALID_TRANSITION_FROM_PAUSED");
 143 |     |         } else if (oldStatus == ProjectRegistry.ProjectStatus.Archived) {
 144 |     |             // Archived is a terminal state. No transitions out should be possible.
 145 |     |             // If the handler successfully makes a state change from Archived and calls this
 146 |     |             // function, this test should fail immediately.
 147 |     |             revert("VIOLATION: Project moved out of Archived state.");
 148 |     |         }
 149 |     | 
 150 |     |         // Update our tracked state.
 151 |     |         projectStates[projectId] = newStatus;
 152 |     |     }
 153 |     | }
 154 |     | 

/home/phantom/Documents/azemora/azemora-contracts/test/invariants/System.invariant.t.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | pragma solidity ^0.8.20;
  3 |     | 
  4 |     | import "forge-std/Test.sol";
  5 |     | import "../../src/marketplace/Marketplace.sol";
  6 |     | import "../../src/core/DynamicImpactCredit.sol";
  7 |     | import "../../src/core/ProjectRegistry.sol";
  8 |     | import "@openzeppelin/contracts/proxy/ERC1967/ERC1967Proxy.sol";
  9 |     | import "@openzeppelin/contracts/mocks/token/ERC20Mock.sol";
 10 |     | 
 11 |     | // @dev A handler contract for the fuzzer. It defines the actions the fuzzer can take.
 12 |     | contract InvariantHandler is Test {
 13 |     |     Marketplace marketplace;
 14 |     |     address admin;
 15 |     | 
 16 |     |     constructor(Marketplace _marketplace, address _admin) {
 17 |     |         marketplace = _marketplace;
 18 |     |         admin = _admin;
 19 |     |     }
 20 |     | 
 21 |     |     // --- Fuzzer Actions ---
 22 |     |     // The fuzzer can call these functions with random inputs.
 23 |     |     // We only expose a subset of non-admin functions for this test.
 24 |     | 
 25 |     |     function list(uint256 tokenId, uint128 amount, uint128 price) public {
 26 |     |         // We don't care if this reverts, the invariant is about admin roles.
 27 |     |         // In a real test, we would add more robust checks.
 28 |     |         // For now, we just want to give the fuzzer some valid functions to call.
 29 |     |     }
 30 |     | 
 31 |     |     function buy(uint256 listingId, uint256 amount) public {
 32 |     |         // Don't care if this reverts
 33 |     |     }
 34 |     | }
 35 |     | 
 36 |     | contract SystemInvariantTest is Test {
 37 |     |     // Contracts
 38 |     |     Marketplace marketplace;
 39 |     |     DynamicImpactCredit credit;
 40 |     |     ProjectRegistry registry;
 41 |     |     ERC20Mock paymentToken;
 42 |     | 
 43 |     |     // Users
 44 |     |     address admin = makeAddr("admin");
 45 |     |     address seller = makeAddr("seller");
 46 |     |     address buyer = makeAddr("buyer");
 47 |     | 
 48 |     |     // Fuzzer target
 49 |     |     InvariantHandler handler;
 50 |     | 
 51 |     |     function setUp() public {
 52 |     |         vm.startPrank(admin);
 53 |     | 
 54 |     |         // Deploy Core Contracts
 55 |     |         ProjectRegistry registryImpl = new ProjectRegistry();
 56 |     |         registry = ProjectRegistry(address(new ERC1967Proxy(address(registryImpl), "")));
 57 |     |         registry.initialize();
 58 |     | 
 59 |     |         DynamicImpactCredit creditImpl = new DynamicImpactCredit(address(registry));
 60 |     |         credit = DynamicImpactCredit(address(new ERC1967Proxy(address(creditImpl), "")));
 61 |     |         credit.initialize("ipfs://");
 62 |     | 
 63 |     |         // Deploy Marketplace
 64 |     |         paymentToken = new ERC20Mock();
 65 |     |         Marketplace marketplaceImpl = new Marketplace();
 66 |     |         marketplace = Marketplace(
 67 |     |             address(
 68 |     |                 new ERC1967Proxy(
 69 |     |                     address(marketplaceImpl),
 70 |     |                     abi.encodeCall(Marketplace.initialize, (address(credit), address(paymentToken)))
 71 |     |                 )
 72 |     |             )
 73 |     |         );
 74 |     | 
 75 |     |         handler = new InvariantHandler(marketplace, admin);
 76 |     |         targetContract(address(handler)); // Tell the fuzzer which contract to call
 77 |     | 
 78 |     |         vm.stopPrank();
 79 |     |     }
 80 |     | 
 81 |     |     /**
 82 |     |      * @dev Invariant: The ADMIN role for the Marketplace should always be held by the Timelock contract.
 83 |     |      * Ensures that no other address can gain administrative control over the marketplace.
 84 |     |      */
 85 |     |     function invariant_MarketplaceAdminRoleIsStable() public view {
 86 |     |         bytes32 adminRole = marketplace.DEFAULT_ADMIN_ROLE();
 87 |     |         assertTrue(
 88 |     |             marketplace.hasRole(adminRole, admin), "Invariant Violated: Marketplace admin role was lost or transferred."
 89 |     |         );
 90 |     |     }
 91 |     | }
 92 |     | 

/home/phantom/Documents/azemora/azemora-contracts/test/invariants/Upgrade.invariant.t.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | pragma solidity ^0.8.20;
   3 |     | 
   4 |     | import "forge-std/Test.sol";
   5 |     | import "../../src/marketplace/Marketplace.sol";
   6 |     | import "../upgrades/MarketplaceV2.sol";
   7 |     | import "../../src/core/DynamicImpactCredit.sol";
   8 |     | import "../../src/core/ProjectRegistry.sol";
   9 |     | import "@openzeppelin/contracts/proxy/ERC1967/ERC1967Proxy.sol";
  10 |     | import "@openzeppelin/contracts/mocks/token/ERC20Mock.sol";
  11 |     | 
  12 |     | /*
  13 |     |  * @title UpgradeInvariantHandler
  14 |     |  * @notice A "handler" contract that tells the Foundry fuzzer which actions it's allowed to take.
  15 |     |  * @dev This is the core of the upgrade invariant test. The fuzzer will call the functions
  16 |     |  *      on this contract in random order with random inputs. We expose normal user actions
  17 |     |  *      (like `list` and `buy`) and, crucially, a one-time `upgradeToV2` function.
  18 |     |  */
  19 |     | contract UpgradeInvariantHandler is Test {
  20 |     |     Marketplace marketplaceProxy;
  21 |     |     MarketplaceV2 marketplaceV2Impl;
  22 |     |     address admin;
  23 |     |     bool hasUpgraded;
  24 |     | 
  25 |     |     constructor(Marketplace _proxy, MarketplaceV2 _v2Impl, address _admin) {
  26 |     |         marketplaceProxy = _proxy;
  27 |     |         marketplaceV2Impl = _v2Impl;
  28 |     |         admin = _admin;
  29 |     |     }
  30 |     | 
  31 |     |     /// @notice A ghost function to give the fuzzer a non-admin action to call.
  32 |     |     function list(uint256 tokenId, uint256 amount, uint256 price) public {
  33 |     |         // We don't care about the logic here or if it reverts. The fuzzer just needs
  34 |     |         // valid functions to call to generate state transitions. The invariant check
  35 |     |         // happens automatically in the main test contract after each call.
  36 |     |     }
  37 |     | 
  38 |     |     /// @notice A ghost function for buying.
  39 |     |     function buy(uint256 listingId, uint256 amount) public {
  40 |     |         // We don't care about the logic.
  41 |     |     }
  42 |     | 
  43 |     |     /// @notice The key fuzzer action: perform a contract upgrade.
  44 |     |     function upgradeToV2() public {
  45 |     |         // Ensure the fuzzer doesn't try to upgrade multiple times.
  46 |     |         if (!hasUpgraded) {
  47 |     |             vm.startPrank(admin);
  48 |     |             marketplaceProxy.upgradeToAndCall(address(marketplaceV2Impl), "");
  49 |     |             vm.stopPrank();
  50 |     |             hasUpgraded = true;
  51 |     |         }
  52 |     |     }
  53 |     | }
  54 |     | 
  55 |     | /*
  56 |     |  * @title UpgradeInvariantTest
  57 |     |  * @notice An invariant test suite to prove that admin roles are stable across
  58 |     |  *         both random user actions and contract upgrades.
  59 |     |  */
  60 |     | contract UpgradeInvariantTest is Test {
  61 |     |     // Contracts
  62 |     |     Marketplace marketplace;
  63 |     |     MarketplaceV2 marketplaceV2Impl; // The V2 implementation, ready to be upgraded to.
  64 |     |     DynamicImpactCredit credit;
  65 |     |     ProjectRegistry registry;
  66 |     |     ERC20Mock paymentToken;
  67 |     | 
  68 |     |     // Users
  69 |     |     address admin = makeAddr("admin");
  70 |     | 
  71 |     |     // Fuzzer Target
  72 |     |     UpgradeInvariantHandler handler;
  73 |     | 
  74 |     |     function setUp() public {
  75 |     |         vm.startPrank(admin);
  76 |     | 
  77 |     |         // --- Deploy all contracts (V1 setup) ---
  78 |     |         ProjectRegistry registryImpl = new ProjectRegistry();
  79 |     |         registry = ProjectRegistry(address(new ERC1967Proxy(address(registryImpl), "")));
  80 |     |         registry.initialize();
  81 |     | 
  82 |     |         DynamicImpactCredit creditImpl = new DynamicImpactCredit(address(registry));
  83 |     |         credit = DynamicImpactCredit(address(new ERC1967Proxy(address(creditImpl), "")));
  84 |     |         credit.initialize("ipfs://");
  85 |     | 
  86 |     |         paymentToken = new ERC20Mock();
  87 |     |         Marketplace marketplaceV1Impl = new Marketplace();
  88 |     |         marketplace = Marketplace(
  89 |     |             address(
  90 |     |                 new ERC1967Proxy(
  91 |     |                     address(marketplaceV1Impl),
  92 |     |                     abi.encodeCall(Marketplace.initialize, (address(credit), address(paymentToken)))
  93 |     |                 )
  94 |     |             )
  95 |     |         );
  96 |     | 
  97 |     |         // --- Deploy the V2 implementation so it's ready for the upgrade ---
  98 |     |         marketplaceV2Impl = new MarketplaceV2();
  99 |     | 
 100 |     |         // --- Setup the handler for the fuzzer ---
 101 |     |         handler = new UpgradeInvariantHandler(marketplace, marketplaceV2Impl, admin);
 102 |     |         targetContract(address(handler)); // Tell the fuzzer to call functions on our handler.
 103 |     | 
 104 |     |         vm.stopPrank();
 105 |     |     }
 106 |     | 
 107 |     |     /**
 108 |     |      * @dev Invariant: Ensures the admin role for all upgradeable contracts remains stable across upgrades.
 109 |     |      * The admin should always be the Timelock contract.
 110 |     |      */
 111 |     |     function invariant_AdminRoleIsStableAcrossUpgrades() public view {
 112 |     |         // Check admin role for Marketplace
 113 |     |         bytes32 marketplaceAdminRole = marketplace.DEFAULT_ADMIN_ROLE();
 114 |     |         assertTrue(
 115 |     |             marketplace.hasRole(marketplaceAdminRole, admin),
 116 |     |             "INVARIANT VIOLATED: Marketplace admin role was lost or transferred!"
 117 |     |         );
 118 |     |     }
 119 |     | }
 120 |     | 

/home/phantom/Documents/azemora/azemora-contracts/test/marketplace/Marketplace.complex.t.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | pragma solidity ^0.8.20;
   3 |     | 
   4 |     | import "forge-std/Test.sol";
   5 |     | import "./Marketplace.t.sol"; // Import the mock ERC20 from the other test file
   6 |     | import "../../src/core/ProjectRegistry.sol";
   7 |     | import "../../src/core/dMRVManager.sol";
   8 |     | import "../../src/core/DynamicImpactCredit.sol";
   9 |     | import "../../src/marketplace/Marketplace.sol";
  10 |     | import "@openzeppelin/contracts/proxy/ERC1967/ERC1967Proxy.sol";
  11 |     | 
  12 |     | contract MarketplaceComplexTest is Test {
  13 |     |     // Core contracts
  14 |     |     ProjectRegistry registry;
  15 |     |     DynamicImpactCredit credit;
  16 |     |     Marketplace marketplace;
  17 |     |     MockERC20 paymentToken;
  18 |     | 
  19 |     |     // Users
  20 |     |     address admin = address(0xA11CE);
  21 |     |     address verifier = address(0xC1E4);
  22 |     |     address dmrvManager = address(0xB01D);
  23 |     |     address treasury = address(0xFE35);
  24 |     |     address seller1 = address(0x5E11E1);
  25 |     |     address seller2 = address(0x5E11E2);
  26 |     |     address buyer1 = address(0xB4BE1);
  27 |     |     address buyer2 = address(0xB4BE2);
  28 |     | 
  29 |     |     // Project and Token IDs
  30 |     |     bytes32 projectId1 = keccak256("Project Alpha");
  31 |     |     bytes32 projectId2 = keccak256("Project Beta");
  32 |     |     uint256 tokenId1;
  33 |     |     uint256 tokenId2;
  34 |     | 
  35 |     |     function setUp() public {
  36 |     |         tokenId1 = uint256(projectId1);
  37 |     |         tokenId2 = uint256(projectId2);
  38 |     | 
  39 |     |         // --- Deploy Infrastructure ---
  40 |     |         paymentToken = new MockERC20("USD Coin", "USDC", 6);
  41 |     |         vm.prank(address(this));
  42 |     |         paymentToken.mint(buyer1, 1_000_000 * 1e6); // 1M USDC
  43 |     |         vm.prank(address(this));
  44 |     |         paymentToken.mint(buyer2, 1_000_000 * 1e6); // 1M USDC
  45 |     | 
  46 |     |         vm.startPrank(admin);
  47 |     | 
  48 |     |         // Deploy Registry, Credit, and Marketplace contracts
  49 |     |         registry = ProjectRegistry(
  50 |     |             address(new ERC1967Proxy(address(new ProjectRegistry()), abi.encodeCall(ProjectRegistry.initialize, ())))
  51 |     |         );
  52 |     |         registry.grantRole(registry.VERIFIER_ROLE(), verifier);
  53 |     | 
  54 |     |         credit = DynamicImpactCredit(
  55 |     |             address(
  56 |     |                 new ERC1967Proxy(
  57 |     |                     address(new DynamicImpactCredit(address(registry))),
  58 |     |                     abi.encodeCall(DynamicImpactCredit.initialize, ("ipfs://meta.json"))
  59 |     |                 )
  60 |     |             )
  61 |     |         );
  62 |     |         credit.grantRole(credit.DMRV_MANAGER_ROLE(), dmrvManager);
  63 |     | 
  64 |     |         marketplace = Marketplace(
  65 |     |             address(
  66 |     |                 new ERC1967Proxy(
  67 |     |                     address(new Marketplace()),
  68 |     |                     abi.encodeCall(Marketplace.initialize, (address(credit), address(paymentToken)))
  69 |     |                 )
  70 |     |             )
  71 |     |         );
  72 |     |         marketplace.setTreasury(treasury);
  73 |     |         marketplace.setFee(250); // Initial 2.5% fee
  74 |     | 
  75 |     |         vm.stopPrank();
  76 |     | 
  77 |     |         // --- Prepare Projects and Credits ---
  78 |     |         // Project 1 for seller1
  79 |     |         vm.prank(seller1);
  80 |     |         registry.registerProject(projectId1, "ipfs://alpha.json");
  81 |     |         vm.prank(verifier);
  82 |     |         registry.setProjectStatus(projectId1, ProjectRegistry.ProjectStatus.Active);
  83 |     |         vm.prank(dmrvManager);
  84 |     |         credit.mintCredits(seller1, projectId1, 500, "ipfs://c-alpha.json");
  85 |     | 
  86 |     |         // Project 2 for seller2
  87 |     |         vm.prank(seller2);
  88 |     |         registry.registerProject(projectId2, "ipfs://beta.json");
  89 |     |         vm.prank(verifier);
  90 |     |         registry.setProjectStatus(projectId2, ProjectRegistry.ProjectStatus.Active);
  91 |     |         vm.prank(dmrvManager);
  92 |     |         credit.mintCredits(seller2, projectId2, 1000, "ipfs://c-beta.json");
  93 |     |     }
  94 |     | 
  95 |     |     function testComplex_MultiUserFlow() public {
  96 |     |         // STEP 1: Both sellers approve the marketplace and list their tokens
  97 |     |         vm.startPrank(seller1);
  98 |     |         credit.setApprovalForAll(address(marketplace), true);
  99 |     |         uint256 listingId1 = marketplace.list(tokenId1, 200, 10 * 1e6, 1 days); // 200 tokens at 10 USDC
 100 |     |         vm.stopPrank();
 101 |     | 
 102 |     |         vm.startPrank(seller2);
 103 |     |         credit.setApprovalForAll(address(marketplace), true);
 104 |     |         uint256 listingId2 = marketplace.list(tokenId2, 500, 15 * 1e6, 1 days); // 500 tokens at 15 USDC
 105 |     |         vm.stopPrank();
 106 |     | 
 107 |     |         assertEq(credit.balanceOf(address(marketplace), tokenId1), 200);
 108 |     |         assertEq(credit.balanceOf(address(marketplace), tokenId2), 500);
 109 |     | 
 110 |     |         // STEP 2: Buyer1 makes a partial purchase from seller1
 111 |     |         uint256 buyAmount1 = 50;
 112 |     |         uint256 totalPrice1 = buyAmount1 * 10 * 1e6;
 113 |     | 
 114 |     |         vm.startPrank(buyer1);
 115 |     |         paymentToken.approve(address(marketplace), totalPrice1);
 116 |     |         marketplace.buy(listingId1, buyAmount1);
 117 |     |         vm.stopPrank();
 118 |     | 
 119 |     |         Marketplace.Listing memory listing1 = marketplace.getListing(listingId1);
 120 |     |         assertEq(listing1.amount, 150); // 200 - 50
 121 |     |         assertEq(credit.balanceOf(buyer1, tokenId1), buyAmount1);
 122 |     |         assertEq(credit.balanceOf(address(marketplace), tokenId1), 150);
 123 |     | 
 124 |     |         // STEP 3: Seller1 decides to update the price of the remaining items
 125 |     |         vm.prank(seller1);
 126 |     |         marketplace.updateListingPrice(listingId1, 12 * 1e6); // New price is 12 USDC
 127 |     | 
 128 |     |         listing1 = marketplace.getListing(listingId1);
 129 |     |         assertEq(listing1.pricePerUnit, 12 * 1e6);
 130 |     | 
 131 |     |         // STEP 4: Buyer2 buys all remaining items from listing 1 at the new price
 132 |     |         uint256 buyAmount2 = 150;
 133 |     |         uint256 totalPrice2 = buyAmount2 * 12 * 1e6; // Use the new price
 134 |     |         uint256 fee2 = (totalPrice2 * 250) / 10000;
 135 |     |         uint256 proceeds2 = totalPrice2 - fee2;
 136 |     |         uint256 seller1InitialPayment = paymentToken.balanceOf(seller1);
 137 |     | 
 138 |     |         vm.startPrank(buyer2);
 139 |     |         paymentToken.approve(address(marketplace), totalPrice2);
 140 |     |         marketplace.buy(listingId1, buyAmount2);
 141 |     |         vm.stopPrank();
 142 |     | 
 143 |     |         listing1 = marketplace.getListing(listingId1);
 144 |     |         assertFalse(listing1.active);
 145 |     |         assertEq(credit.balanceOf(buyer2, tokenId1), buyAmount2);
 146 |     |         assertEq(credit.balanceOf(address(marketplace), tokenId1), 0);
 147 |     |         assertEq(paymentToken.balanceOf(seller1), seller1InitialPayment + proceeds2);
 148 |     | 
 149 |     |         // STEP 5: Buyer1 buys the entire listing from seller2
 150 |     |         uint256 buyAmount3 = 500;
 151 |     |         uint256 totalPrice3 = buyAmount3 * 15 * 1e6;
 152 |     | 
 153 |     |         vm.startPrank(buyer1);
 154 |     |         paymentToken.approve(address(marketplace), totalPrice3);
 155 |     |         marketplace.buy(listingId2, buyAmount3);
 156 |     |         vm.stopPrank();
 157 |     | 
 158 |     |         Marketplace.Listing memory listing2 = marketplace.getListing(listingId2);
 159 |     |         assertFalse(listing2.active);
 160 |     |         assertEq(credit.balanceOf(buyer1, tokenId2), buyAmount3);
 161 |     |         assertEq(credit.balanceOf(address(marketplace), tokenId2), 0);
 162 |     | 
 163 |     |         // STEP 6: Seller2 lists more tokens, then cancels the listing
 164 |     |         vm.startPrank(seller2);
 165 |     |         uint256 listingId3 = marketplace.list(tokenId2, 300, 20 * 1e6, 1 days);
 166 |     |         assertEq(credit.balanceOf(address(marketplace), tokenId2), 300);
 167 |     |         marketplace.cancelListing(listingId3);
 168 |     |         vm.stopPrank();
 169 |     | 
 170 |     |         Marketplace.Listing memory listing3 = marketplace.getListing(listingId3);
 171 |     |         assertFalse(listing3.active);
 172 |     |         assertEq(credit.balanceOf(address(marketplace), tokenId2), 0);
 173 |     |         assertEq(credit.balanceOf(seller2, tokenId2), 500); // 1000 minted - 500 sold
 174 |     | 
 175 |     |         // STEP 7: Admin changes the fee, a new purchase reflects this
 176 |     |         vm.prank(admin);
 177 |     |         marketplace.setFee(500); // 5% fee
 178 |     | 
 179 |     |         // Seller1 lists again
 180 |     |         vm.startPrank(seller1);
 181 |     |         uint256 listingId4 = marketplace.list(tokenId1, 100, 10 * 1e6, 1 days);
 182 |     |         vm.stopPrank();
 183 |     | 
 184 |     |         // Buyer1 buys
 185 |     |         uint256 buyAmount4 = 10;
 186 |     |         uint256 totalPrice4 = buyAmount4 * 10 * 1e6;
 187 |     |         uint256 newFee = (totalPrice4 * 500) / 10000; // 5%
 188 |     |         uint256 treasuryInitialBalance = paymentToken.balanceOf(treasury);
 189 |     | 
 190 |     |         vm.startPrank(buyer1);
 191 |     |         paymentToken.approve(address(marketplace), totalPrice4);
 192 |     |         marketplace.buy(listingId4, buyAmount4);
 193 |     |         vm.stopPrank();
 194 |     | 
 195 |     |         assertEq(paymentToken.balanceOf(treasury), treasuryInitialBalance + newFee);
 196 |     |     }
 197 |     | }
 198 |     | 

/home/phantom/Documents/azemora/azemora-contracts/test/marketplace/Marketplace.fuzz.t.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | pragma solidity ^0.8.20;
   3 |     | 
   4 |     | import "forge-std/Test.sol";
   5 |     | import "./Marketplace.t.sol"; // Re-use mocks
   6 |     | import "../../src/core/ProjectRegistry.sol";
   7 |     | import "../../src/core/dMRVManager.sol";
   8 |     | import "../../src/core/DynamicImpactCredit.sol";
   9 |     | import "../../src/marketplace/Marketplace.sol";
  10 |     | import "@openzeppelin/contracts/proxy/ERC1967/ERC1967Proxy.sol";
  11 |     | 
  12 |     | contract MarketplaceFuzzTest is Test {
  13 |     |     ProjectRegistry registry;
  14 |     |     DynamicImpactCredit credit;
  15 |     |     Marketplace marketplace;
  16 |     |     MockERC20 paymentToken;
  17 |     | 
  18 |     |     address admin = address(0xA11CE);
  19 |     |     address verifier = address(0xC1E4);
  20 |     |     address dmrvManager = address(0xB01D);
  21 |     |     address treasury = address(0xFE35);
  22 |     |     address seller = address(0x5E11E1);
  23 |     |     address buyer = address(0xB4BE1);
  24 |     | 
  25 |     |     function setUp() public {
  26 |     |         // --- Deploy Infrastructure ---
  27 |     |         paymentToken = new MockERC20("USD Coin", "USDC", 6);
  28 |     |         vm.prank(address(this));
  29 |     |         paymentToken.mint(buyer, 1_000_000_000 * 1e6); // 1B USDC for fuzzing
  30 |     | 
  31 |     |         vm.startPrank(admin);
  32 |     | 
  33 |     |         registry = ProjectRegistry(
  34 |     |             address(new ERC1967Proxy(address(new ProjectRegistry()), abi.encodeCall(ProjectRegistry.initialize, ())))
  35 |     |         );
  36 |     |         registry.grantRole(registry.VERIFIER_ROLE(), verifier);
  37 |     | 
  38 |     |         credit = DynamicImpactCredit(
  39 |     |             address(
  40 |     |                 new ERC1967Proxy(
  41 |     |                     address(new DynamicImpactCredit(address(registry))),
  42 |     |                     abi.encodeCall(DynamicImpactCredit.initialize, ("ipfs://meta.json"))
  43 |     |                 )
  44 |     |             )
  45 |     |         );
  46 |     |         credit.grantRole(credit.DMRV_MANAGER_ROLE(), dmrvManager);
  47 |     | 
  48 |     |         marketplace = Marketplace(
  49 |     |             address(
  50 |     |                 new ERC1967Proxy(
  51 |     |                     address(new Marketplace()),
  52 |     |                     abi.encodeCall(Marketplace.initialize, (address(credit), address(paymentToken)))
  53 |     |                 )
  54 |     |             )
  55 |     |         );
  56 |     |         marketplace.setTreasury(treasury);
  57 |     |         marketplace.setFee(250); // 2.5% fee
  58 |     | 
  59 |     |         vm.stopPrank();
  60 |     |     }
  61 |     | 
  62 |     |     function testFuzz_ListAndBuy(uint64 seed, uint256 listAmount, uint256 buyAmount, uint256 price) public {
  63 |     |         bytes32 projectId = keccak256(abi.encodePacked("project", seed));
  64 |     |         uint256 tokenId = uint256(projectId);
  65 |     | 
  66 |     |         // --- Setup State ---
  67 |     |         uint256 mintAmount = 1_000_000;
  68 |     |         // 1. Activate project and mint tokens to seller
  69 |     |         vm.prank(seller);
  70 |     |         registry.registerProject(projectId, "ipfs://fuzz.json");
  71 |     |         vm.prank(verifier);
  72 |     |         registry.setProjectStatus(projectId, ProjectRegistry.ProjectStatus.Active);
  73 |     |         vm.prank(dmrvManager);
  74 |     |         credit.mintCredits(seller, projectId, mintAmount, "ipfs://fuzz-c.json");
  75 |     | 
  76 |     |         // 2. Bound inputs to be reasonable
  77 |     |         listAmount = bound(listAmount, 1, mintAmount);
  78 |     |         buyAmount = bound(buyAmount, 1, listAmount);
  79 |     |         price = bound(price, 1, 1_000_000 * 1e6); // Price up to 1M USDC
  80 |     | 
  81 |     |         // 3. Assume the buyer can afford the purchase to avoid reverts
  82 |     |         uint256 totalPrice = buyAmount * price;
  83 |     |         vm.assume(totalPrice < paymentToken.balanceOf(buyer));
  84 |     | 
  85 |     |         // --- Execute Actions ---
  86 |     |         // 4. Seller lists the item
  87 |     |         vm.startPrank(seller);
  88 |     |         credit.setApprovalForAll(address(marketplace), true);
  89 |     |         uint256 listingId = marketplace.list(tokenId, listAmount, price, 1 days);
  90 |     |         vm.stopPrank();
  91 |     | 
  92 |     |         // 5. Buyer approves payment and buys the item
  93 |     |         uint256 fee = (totalPrice * 250) / 10000;
  94 |     |         uint256 sellerProceeds = totalPrice - fee;
  95 |     | 
  96 |     |         vm.startPrank(buyer);
  97 |     |         paymentToken.approve(address(marketplace), type(uint256).max);
  98 |     |         marketplace.buy(listingId, buyAmount);
  99 |     |         vm.stopPrank();
 100 |     | 
 101 |     |         // --- Assert Final State ---
 102 |     |         // Assert NFT balances
 103 |     |         assertEq(credit.balanceOf(seller, tokenId), mintAmount - listAmount, "Seller NFT balance incorrect");
 104 |     |         assertEq(credit.balanceOf(buyer, tokenId), buyAmount, "Buyer NFT balance incorrect");
 105 |     |         assertEq(
 106 |     |             credit.balanceOf(address(marketplace), tokenId), listAmount - buyAmount, "Marketplace NFT balance incorrect"
 107 |     |         );
 108 |     | 
 109 |     |         // Assert payment token balances
 110 |     |         assertEq(paymentToken.balanceOf(seller), sellerProceeds, "Seller payment balance incorrect");
 111 |     |     }
 112 |     | }
 113 |     | 

/home/phantom/Documents/azemora/azemora-contracts/test/marketplace/Marketplace.griefing.t.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | pragma solidity ^0.8.20;
   3 |     | 
   4 |     | import "forge-std/Test.sol";
   5 |     | import "../../src/marketplace/Marketplace.sol";
   6 |     | import "../../src/core/DynamicImpactCredit.sol";
   7 |     | import "../../src/core/ProjectRegistry.sol";
   8 |     | import "@openzeppelin/contracts/proxy/ERC1967/ERC1967Proxy.sol";
   9 |     | 
  10 |     | // Mock ERC20 for payment
  11 |     | contract MockERC20ForGriefTest {
  12 |     |     event Approval(address indexed owner, address indexed spender, uint256 value);
  13 |     | 
  14 |     |     mapping(address => uint256) public balanceOf;
  15 |     |     mapping(address => mapping(address => uint256)) public allowance;
  16 |     | 
  17 |     |     function mint(address to, uint256 amount) external {
  18 |     |         balanceOf[to] += amount;
  19 |     |     }
  20 |     | 
  21 |     |     function approve(address spender, uint256 amount) public returns (bool) {
  22 |     |         allowance[msg.sender][spender] = amount;
  23 |     |         emit Approval(msg.sender, spender, amount);
  24 |     |         return true;
  25 |     |     }
  26 |     | 
  27 |     |     function transferFrom(address from, address to, uint256 amount) public returns (bool) {
  28 |     |         require(balanceOf[from] >= amount, "MockERC20: insufficient balance");
  29 |     |         require(allowance[from][msg.sender] >= amount, "MockERC20: insufficient allowance");
  30 |     | 
  31 |     |         if (allowance[from][msg.sender] != type(uint256).max) {
  32 |     |             allowance[from][msg.sender] -= amount;
  33 |     |         }
  34 |     |         balanceOf[from] -= amount;
  35 |     |         balanceOf[to] += amount;
  36 |     |         return true;
  37 |     |     }
  38 |     | }
  39 |     | 
  40 |     | contract MarketplaceGriefingTest is Test {
  41 |     |     // Contracts
  42 |     |     Marketplace marketplace;
  43 |     |     DynamicImpactCredit credit;
  44 |     |     MockERC20ForGriefTest paymentToken;
  45 |     |     ProjectRegistry registry;
  46 |     | 
  47 |     |     // Users
  48 |     |     address admin;
  49 |     |     address seller = makeAddr("seller");
  50 |     | 
  51 |     |     // Constants
  52 |     |     uint256 constant BATCH_TOKEN_ID = 1;
  53 |     |     uint256 constant LIST_AMOUNT = 100;
  54 |     |     uint256 constant PRICE_PER_UNIT = 1 ether;
  55 |     | 
  56 |     |     function setUp() public {
  57 |     |         admin = address(this);
  58 |     | 
  59 |     |         // Deploy Project Registry
  60 |     |         ProjectRegistry registryImpl = new ProjectRegistry();
  61 |     |         bytes memory registryInitData = abi.encodeCall(ProjectRegistry.initialize, ());
  62 |     |         ERC1967Proxy registryProxy = new ERC1967Proxy(address(registryImpl), registryInitData);
  63 |     |         registry = ProjectRegistry(address(registryProxy));
  64 |     | 
  65 |     |         // Deploy Dynamic Impact Credit (ERC1155)
  66 |     |         DynamicImpactCredit creditImpl = new DynamicImpactCredit(address(registry));
  67 |     |         bytes memory creditInitData = abi.encodeCall(DynamicImpactCredit.initialize, ("uri"));
  68 |     |         ERC1967Proxy creditProxy = new ERC1967Proxy(address(creditImpl), creditInitData);
  69 |     |         credit = DynamicImpactCredit(address(creditProxy));
  70 |     | 
  71 |     |         // Deploy Mock Payment Token (ERC20)
  72 |     |         paymentToken = new MockERC20ForGriefTest();
  73 |     | 
  74 |     |         // Deploy Marketplace
  75 |     |         Marketplace marketplaceImpl = new Marketplace();
  76 |     |         bytes memory marketplaceInitData =
  77 |     |             abi.encodeCall(Marketplace.initialize, (address(credit), address(paymentToken)));
  78 |     |         ERC1967Proxy marketplaceProxy = new ERC1967Proxy(address(marketplaceImpl), marketplaceInitData);
  79 |     |         marketplace = Marketplace(address(marketplaceProxy));
  80 |     | 
  81 |     |         // Configure roles and mint assets
  82 |     |         marketplace.setTreasury(admin); // Set treasury for fees
  83 |     | 
  84 |     |         // Mint credits to the seller
  85 |     |         vm.prank(admin);
  86 |     |         credit.grantRole(credit.DMRV_MANAGER_ROLE(), admin);
  87 |     |         vm.prank(admin);
  88 |     |         // Mint a large number of tokens to the seller to cover all listings
  89 |     |         // We also need to register a project for these credits
  90 |     |         bytes32 projectId = bytes32(uint256(BATCH_TOKEN_ID));
  91 |     |         registry.registerProject(projectId, "griefing-project");
  92 |     |         registry.setProjectStatus(projectId, ProjectRegistry.ProjectStatus.Active);
  93 |     |         credit.mintCredits(seller, projectId, 1000, "grief-uri");
  94 |     | 
  95 |     |         // Approve marketplace to spend seller's credits
  96 |     |         vm.prank(seller);
  97 |     |         credit.setApprovalForAll(address(marketplace), true);
  98 |     |     }
  99 |     | 
 100 |     |     /**
 101 |     |      * @dev Tests if batch-cancelling many listings can be done within a single block's gas limit.
 102 |     |      * This simulates a potential DoS vector where a user creates many listings and then tries
 103 |     |      * to execute a costly operation on them.
 104 |     |      */
 105 |     |     function test_GasGriefing_BatchCancel_StaysWithinBlockLimit() public {
 106 |     |         uint256 numListings = 1000;
 107 |     |         uint256[] memory listingIds = new uint256[](numListings);
 108 |     | 
 109 |     |         // 1. Create a large number of listings
 110 |     |         vm.startPrank(seller);
 111 |     |         for (uint256 i = 0; i < numListings; i++) {
 112 |     |             listingIds[i] = marketplace.list(BATCH_TOKEN_ID, 1, PRICE_PER_UNIT, 1 weeks);
 113 |     |         }
 114 |     |         vm.stopPrank();
 115 |     | 
 116 |     |         // 2. Attempt to cancel all listings in a single transaction.
 117 |     |         uint256 gasBefore = gasleft();
 118 |     |         vm.prank(seller);
 119 |     |         marketplace.batchCancelListings(listingIds);
 120 |     |         uint256 gasAfter = gasleft();
 121 |     |         uint256 gasUsed = gasBefore - gasAfter;
 122 |     | 
 123 |     |         // 3. Assert gas is under a reasonable limit (e.g., 29M, default block limit is 30M)
 124 |     |         console.log("Gas used for 1000 cancellations:", gasUsed);
 125 |     |         assertLt(gasUsed, 29_000_000, "Gas for 1000 cancellations should be under block limit");
 126 |     |     }
 127 |     | 
 128 |     |     /**
 129 |     |      * @dev Tests if batch-buying many listings can be done within a single block's gas limit.
 130 |     |      */
 131 |     |     function test_GasGriefing_BatchBuy_StaysWithinBlockLimit() public {
 132 |     |         uint256 numListings = 500; // Reduced from 1000 as buy is more expensive
 133 |     |         uint256[] memory listingIds = new uint256[](numListings);
 134 |     |         uint256[] memory amountsToBuy = new uint256[](numListings);
 135 |     |         address buyer = makeAddr("buyer");
 136 |     | 
 137 |     |         // 1. Create a large number of listings
 138 |     |         vm.startPrank(seller);
 139 |     |         for (uint256 i = 0; i < numListings; i++) {
 140 |     |             listingIds[i] = marketplace.list(BATCH_TOKEN_ID, 1, PRICE_PER_UNIT, 1 weeks);
 141 |     |             amountsToBuy[i] = 1;
 142 |     |         }
 143 |     |         vm.stopPrank();
 144 |     | 
 145 |     |         // 2. Fund the buyer and have them approve the marketplace
 146 |     |         uint256 totalCost = numListings * PRICE_PER_UNIT;
 147 |     |         paymentToken.mint(buyer, totalCost);
 148 |     |         vm.prank(buyer);
 149 |     |         paymentToken.approve(address(marketplace), totalCost);
 150 |     | 
 151 |     |         // 3. Attempt to buy all listings in a single transaction.
 152 |     |         uint256 gasBefore = gasleft();
 153 |     |         vm.prank(buyer);
 154 |     |         marketplace.batchBuy(listingIds, amountsToBuy);
 155 |     |         uint256 gasAfter = gasleft();
 156 |     |         uint256 gasUsed = gasBefore - gasAfter;
 157 |     | 
 158 |     |         // 4. Assert gas is under a reasonable limit (e.g., 29M, default block limit is 30M)
 159 |     |         console.log("Gas used for 500 purchases:", gasUsed);
 160 |     |         assertLt(gasUsed, 29_000_000, "Gas for 500 purchases should be under block limit");
 161 |     |     }
 162 |     | 
 163 |     |     /**
 164 |     |      * @dev Tests if cancelling a listing with a very long expiration properly cleans up storage.
 165 |     |      * This prevents a griefing vector where expired/cancelled listings bloat contract storage indefinitely.
 166 |     |      */
 167 |     |     function test_StorageGriefing_LongExpiration_CleanupOnCancel() public {
 168 |     |         uint256 longExpiration = 100 * 365 days; // 100 years
 169 |     | 
 170 |     |         // 1. Create a listing with a very long expiration
 171 |     |         vm.prank(seller);
 172 |     |         uint256 listingId = marketplace.list(BATCH_TOKEN_ID, LIST_AMOUNT, PRICE_PER_UNIT, longExpiration);
 173 |     | 
 174 |     |         // 2. Verify the listing is active and has correct data
 175 |     |         Marketplace.Listing memory listingBefore = marketplace.getListing(listingId);
 176 |     |         assertTrue(listingBefore.active, "Listing should be active before cancellation");
 177 |     |         assertEq(listingBefore.seller, seller, "Seller should be correct");
 178 |     |         assertEq(listingBefore.amount, LIST_AMOUNT, "Amount should be correct");
 179 |     | 
 180 |     |         // 3. Cancel the listing
 181 |     |         vm.prank(seller);
 182 |     |         marketplace.cancelListing(listingId);
 183 |     | 
 184 |     |         // 4. Verify the listing is no longer active.
 185 |     |         // In this implementation, cancellation only flips the `active` flag. A more robust
 186 |     |         // implementation might use `delete` to clear all storage, but that has its own gas implications.
 187 |     |         // We will check that the listing is marked inactive.
 188 |     |         Marketplace.Listing memory listingAfter = marketplace.getListing(listingId);
 189 |     |         assertFalse(listingAfter.active, "Listing should be inactive after cancellation");
 190 |     |     }
 191 |     | }
 192 |     | 

/home/phantom/Documents/azemora/azemora-contracts/test/marketplace/Marketplace.invariant.t.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | pragma solidity ^0.8.20;
   3 |     | 
   4 |     | import "forge-std/Test.sol";
   5 |     | import "./Marketplace.t.sol"; // Re-use mocks
   6 |     | import "../../src/core/ProjectRegistry.sol";
   7 |     | import "../../src/core/dMRVManager.sol";
   8 |     | import "../../src/core/DynamicImpactCredit.sol";
   9 |     | import "../../src/marketplace/Marketplace.sol";
  10 |     | import "@openzeppelin/contracts/proxy/ERC1967/ERC1967Proxy.sol";
  11 |     | 
  12 |     | // Handler contract to perform random actions on the Marketplace
  13 |     | contract MarketplaceHandler is Test {
  14 |     |     ProjectRegistry public registry;
  15 |     |     DynamicImpactCredit public credit;
  16 |     |     Marketplace public marketplace;
  17 |     |     MockERC20 public paymentToken;
  18 |     | 
  19 |     |     // --- State tracking for invariants ---
  20 |     |     // We don't need to track credit balances here, as the credit contract has its own invariants.
  21 |     |     // We will track payment token balances to ensure conservation.
  22 |     |     mapping(address => uint256) public userPaymentTokenBalances;
  23 |     | 
  24 |     |     // --- Actors ---
  25 |     |     address public admin;
  26 |     |     address public verifier;
  27 |     |     address public dmrvManager;
  28 |     |     address public treasury;
  29 |     |     address[] public users; // Sellers and buyers
  30 |     | 
  31 |     |     // --- Available assets ---
  32 |     |     bytes32[] public projectIds;
  33 |     |     mapping(bytes32 => bool) public projectIdExists;
  34 |     |     mapping(bytes32 => uint256) public totalCreditSupply;
  35 |     | 
  36 |     |     function getUsersLength() public view returns (uint256) {
  37 |     |         return users.length;
  38 |     |     }
  39 |     | 
  40 |     |     function getProjectIdsLength() public view returns (uint256) {
  41 |     |         return projectIds.length;
  42 |     |     }
  43 |     | 
  44 |     |     constructor(
  45 |     |         ProjectRegistry _registry,
  46 |     |         DynamicImpactCredit _credit,
  47 |     |         Marketplace _marketplace,
  48 |     |         MockERC20 _paymentToken,
  49 |     |         address _admin,
  50 |     |         address _verifier,
  51 |     |         address _dmrvManager,
  52 |     |         address _treasury
  53 |     |     ) {
  54 |     |         registry = _registry;
  55 |     |         credit = _credit;
  56 |     |         marketplace = _marketplace;
  57 |     |         paymentToken = _paymentToken;
  58 |     |         admin = _admin;
  59 |     |         verifier = _verifier;
  60 |     |         dmrvManager = _dmrvManager;
  61 |     |         treasury = _treasury;
  62 |     | 
  63 |     |         // Create test users
  64 |     |         for (uint256 i = 0; i < 4; i++) {
  65 |     |             users.push(address(uint160(uint256(keccak256(abi.encodePacked("user", i))))));
  66 |     |         }
  67 |     | 
  68 |     |         // Fund users and track initial balances
  69 |     |         for (uint256 i = 0; i < users.length; i++) {
  70 |     |             uint256 initialBalance = 1_000_000 * 1e6;
  71 |     |             paymentToken.mint(users[i], initialBalance);
  72 |     |             userPaymentTokenBalances[users[i]] = initialBalance;
  73 |     |         }
  74 |     |         // Fee recipient starts with 0
  75 |     |         userPaymentTokenBalances[treasury] = 0;
  76 |     | 
  77 |     |         // Target the handler so that fuzz inputs are sent to its public functions
  78 |     |         targetContract(address(this));
  79 |     |     }
  80 |     | 
  81 |     |     /* --- ACTIONS --- */
  82 |     | 
  83 |     |     // Action: A random user lists a random amount of a random credit
  84 |     |     function list(uint256 seed, uint256 listAmount, uint256 price) public {
  85 |     |         // 1. Get a seller
  86 |     |         address seller = users[seed % users.length];
  87 |     | 
  88 |     |         // 2. Ensure seller has something to sell. If not, mint them some credits.
  89 |     |         bytes32 projectId = keccak256(abi.encodePacked("project", seed % 5)); // Limit to 5 projects
  90 |     |         if (!projectIdExists[projectId]) {
  91 |     |             // Create the project and mint initial credits
  92 |     |             uint256 mintAmount = 1_000_000;
  93 |     |             vm.prank(seller);
  94 |     |             registry.registerProject(projectId, "ipfs://fuzz.json");
  95 |     |             vm.prank(verifier);
  96 |     |             registry.setProjectStatus(projectId, ProjectRegistry.ProjectStatus.Active);
  97 |     |             vm.prank(dmrvManager);
  98 |     |             credit.mintCredits(seller, projectId, mintAmount, "uri");
  99 |     | 
 100 |     |             projectIds.push(projectId);
 101 |     |             projectIdExists[projectId] = true;
 102 |     |             totalCreditSupply[projectId] = mintAmount;
 103 |     |         }
 104 |     | 
 105 |     |         // 3. Bound inputs
 106 |     |         uint256 sellerBalance = credit.balanceOf(seller, uint256(projectId));
 107 |     |         if (sellerBalance == 0) return; // Nothing to list
 108 |     |         listAmount = bound(listAmount, 1, sellerBalance);
 109 |     |         price = bound(price, 1, 1_000_000 * 1e6);
 110 |     | 
 111 |     |         // 4. Execute: List the item
 112 |     |         vm.startPrank(seller);
 113 |     |         credit.setApprovalForAll(address(marketplace), true);
 114 |     |         marketplace.list(uint256(projectId), listAmount, price, 1 days);
 115 |     |         vm.stopPrank();
 116 |     |     }
 117 |     | 
 118 |     |     // Action: A random user buys from a random active listing
 119 |     |     function buy(uint256 seed, uint256 listingId, uint256 buyAmount) public {
 120 |     |         uint256 activeListingCount = marketplace.activeListingCount();
 121 |     |         if (activeListingCount == 0) return;
 122 |     | 
 123 |     |         listingId = bound(listingId, 0, marketplace.listingIdCounter() - 1);
 124 |     |         Marketplace.Listing memory l = marketplace.getListing(listingId);
 125 |     | 
 126 |     |         if (!l.active) return; // Can't buy from inactive listing
 127 |     | 
 128 |     |         // 1. Get a buyer (cannot be the seller)
 129 |     |         address buyer;
 130 |     |         uint256 i = 0;
 131 |     |         do {
 132 |     |             buyer = users[(seed + i) % users.length];
 133 |     |             i++;
 134 |     |         } while (buyer == l.seller);
 135 |     | 
 136 |     |         // 2. Bound inputs
 137 |     |         buyAmount = bound(buyAmount, 1, l.amount);
 138 |     | 
 139 |     |         // 3. Ensure buyer can afford it and update tracked balances
 140 |     |         uint256 totalPrice = buyAmount * l.pricePerUnit;
 141 |     |         if (paymentToken.balanceOf(buyer) < totalPrice) return;
 142 |     | 
 143 |     |         uint256 fee = (totalPrice * marketplace.feeBps()) / 10000;
 144 |     |         uint256 sellerProceeds = totalPrice - fee;
 145 |     | 
 146 |     |         userPaymentTokenBalances[buyer] -= totalPrice;
 147 |     |         userPaymentTokenBalances[l.seller] += sellerProceeds;
 148 |     |         userPaymentTokenBalances[treasury] += fee;
 149 |     | 
 150 |     |         // 4. Execute: Buyer approves and buys
 151 |     |         vm.startPrank(buyer);
 152 |     |         paymentToken.approve(address(marketplace), totalPrice);
 153 |     |         marketplace.buy(listingId, buyAmount);
 154 |     |         vm.stopPrank();
 155 |     |     }
 156 |     | 
 157 |     |     // Action: A random seller cancels their listing
 158 |     |     function cancel(uint256 listingId) public {
 159 |     |         uint256 listingCounter = marketplace.listingIdCounter();
 160 |     |         if (listingCounter == 0) return;
 161 |     |         listingId = bound(listingId, 0, listingCounter - 1);
 162 |     | 
 163 |     |         Marketplace.Listing memory l = marketplace.getListing(listingId);
 164 |     |         if (!l.active) return;
 165 |     | 
 166 |     |         vm.prank(l.seller);
 167 |     |         try marketplace.cancelListing(listingId) {
 168 |     |             // success is okay
 169 |     |         } catch {
 170 |     |             // revert is okay
 171 |     |         }
 172 |     |     }
 173 |     | }
 174 |     | 
 175 |     | // The Invariant Test Contract
 176 |     | contract MarketplaceInvariantTest is StdInvariant, Test {
 177 |     |     MarketplaceHandler handler;
 178 |     | 
 179 |     |     function setUp() public {
 180 |     |         // --- Deploy Infrastructure ---
 181 |     |         address admin = address(0xA11CE);
 182 |     |         address verifier = address(0xC1E4);
 183 |     |         address dmrvManager = address(0xB01D);
 184 |     |         address treasury = address(0xFE35);
 185 |     | 
 186 |     |         vm.startPrank(admin);
 187 |     |         ProjectRegistry registry = ProjectRegistry(
 188 |     |             address(new ERC1967Proxy(address(new ProjectRegistry()), abi.encodeCall(ProjectRegistry.initialize, ())))
 189 |     |         );
 190 |     |         registry.grantRole(registry.VERIFIER_ROLE(), verifier);
 191 |     | 
 192 |     |         DynamicImpactCredit credit = DynamicImpactCredit(
 193 |     |             address(
 194 |     |                 new ERC1967Proxy(
 195 |     |                     address(new DynamicImpactCredit(address(registry))),
 196 |     |                     abi.encodeCall(DynamicImpactCredit.initialize, ("uri"))
 197 |     |                 )
 198 |     |             )
 199 |     |         );
 200 |     |         credit.grantRole(credit.DMRV_MANAGER_ROLE(), dmrvManager);
 201 |     | 
 202 |     |         MockERC20 paymentToken = new MockERC20("USD Coin", "USDC", 6);
 203 |     |         Marketplace marketplace = Marketplace(
 204 |     |             address(
 205 |     |                 new ERC1967Proxy(
 206 |     |                     address(new Marketplace()),
 207 |     |                     abi.encodeCall(Marketplace.initialize, (address(credit), address(paymentToken)))
 208 |     |                 )
 209 |     |             )
 210 |     |         );
 211 |     |         marketplace.setTreasury(treasury);
 212 |     |         marketplace.setFee(250); // 2.5% fee
 213 |     |         vm.stopPrank();
 214 |     | 
 215 |     |         // --- Set up Handler ---
 216 |     |         handler =
 217 |     |             new MarketplaceHandler(registry, credit, marketplace, paymentToken, admin, verifier, dmrvManager, treasury);
 218 |     | 
 219 |     |         // Target the handler so that fuzz inputs are sent to its public functions
 220 |     |         targetContract(address(handler));
 221 |     |     }
 222 |     | 
 223 |     |     // INVARIANT 1: Payment tokens are conserved.
 224 |     |     // The total amount of payment tokens across all users and the fee recipient
 225 |     |     // should always equal the sum of their initial balances.
 226 |     |     function invariant_paymentTokenIsConserved() public view {
 227 |     |         uint256 totalTrackedBalance = 0;
 228 |     |         uint256 totalActualBalance = 0;
 229 |     | 
 230 |     |         uint256 usersLength = handler.getUsersLength();
 231 |     |         for (uint256 i = 0; i < usersLength; i++) {
 232 |     |             address user = handler.users(i);
 233 |     |             totalTrackedBalance += handler.userPaymentTokenBalances(user);
 234 |     |             totalActualBalance += handler.paymentToken().balanceOf(user);
 235 |     |         }
 236 |     | 
 237 |     |         address treasury_ = handler.treasury();
 238 |     |         totalTrackedBalance += handler.userPaymentTokenBalances(treasury_);
 239 |     |         totalActualBalance += handler.paymentToken().balanceOf(treasury_);
 240 |     | 
 241 |     |         assertEq(totalTrackedBalance, totalActualBalance, "Payment token conservation broken");
 242 |     |     }
 243 |     | 
 244 |     |     // INVARIANT 2: Marketplace holds no payment tokens.
 245 |     |     // The marketplace contract should only be a conduit for payment tokens, not hold them.
 246 |     |     function invariant_marketplaceHoldsNoPaymentTokens() public view {
 247 |     |         assertEq(
 248 |     |             handler.paymentToken().balanceOf(address(handler.marketplace())), 0, "Marketplace holds payment tokens"
 249 |     |         );
 250 |     |     }
 251 |     | 
 252 |     |     // INVARIANT 3: Credit tokens are conserved.
 253 |     |     // The total number of tokens for each project ID should remain constant across
 254 |     |     // all users and the marketplace itself.
 255 |     |     function invariant_creditTokenIsConserved() public view {
 256 |     |         uint256 projectsLength = handler.getProjectIdsLength();
 257 |     |         for (uint256 i = 0; i < projectsLength; i++) {
 258 |     |             bytes32 projectId = handler.projectIds(i);
 259 |     |             uint256 tokenId = uint256(projectId);
 260 |     | 
 261 |     |             // Get the initial total supply that was minted for this project
 262 |     |             uint256 initialTotalSupply = handler.totalCreditSupply(projectId);
 263 |     | 
 264 |     |             // Calculate the current total supply held by all actors
 265 |     |             uint256 currentTotalSupply = 0;
 266 |     | 
 267 |     |             // Add balances of all users
 268 |     |             uint256 usersLength = handler.getUsersLength();
 269 |     |             for (uint256 j = 0; j < usersLength; j++) {
 270 |     |                 address user = handler.users(j);
 271 |     |                 currentTotalSupply += handler.credit().balanceOf(user, tokenId);
 272 |     |             }
 273 |     | 
 274 |     |             // Add balance held by the marketplace contract
 275 |     |             currentTotalSupply += handler.credit().balanceOf(address(handler.marketplace()), tokenId);
 276 |     | 
 277 |     |             // The current total supply should always equal the initial total supply
 278 |     |             assertEq(currentTotalSupply, initialTotalSupply, "Credit token conservation broken");
 279 |     |         }
 280 |     |     }
 281 |     | }
 282 |     | 

/home/phantom/Documents/azemora/azemora-contracts/test/marketplace/Marketplace.t.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | pragma solidity ^0.8.20;
   3 |     | 
   4 |     | import "forge-std/Test.sol";
   5 |     | import "../../src/marketplace/Marketplace.sol";
   6 |     | import "../../src/core/ProjectRegistry.sol";
   7 |     | import "../../src/core/dMRVManager.sol";
   8 |     | import "../../src/core/DynamicImpactCredit.sol";
   9 |     | import "@openzeppelin/contracts/proxy/ERC1967/ERC1967Proxy.sol";
  10 |     | 
  11 |     | // Minimal mock ERC20 to avoid dependency on forge-std/mocks
  12 |     | contract MockERC20 {
  13 |     |     event Transfer(address indexed from, address indexed to, uint256 value);
  14 |     |     event Approval(address indexed owner, address indexed spender, uint256 value);
  15 |     | 
  16 |     |     mapping(address => uint256) public balanceOf;
  17 |     |     mapping(address => mapping(address => uint256)) public allowance;
  18 |     |     uint256 public totalSupply;
  19 |     |     string public name;
  20 |     |     string public symbol;
  21 |     |     uint8 public decimals;
  22 |     | 
  23 |     |     constructor(string memory name_, string memory symbol_, uint8 decimals_) {
  24 |     |         name = name_;
  25 |     |         symbol = symbol_;
  26 |     |         decimals = decimals_;
  27 |     |     }
  28 |     | 
  29 |     |     function approve(address spender, uint256 amount) public returns (bool) {
  30 |     |         allowance[msg.sender][spender] = amount;
  31 |     |         emit Approval(msg.sender, spender, amount);
  32 |     |         return true;
  33 |     |     }
  34 |     | 
  35 |     |     function transferFrom(address from, address to, uint256 amount) public returns (bool) {
  36 |     |         require(balanceOf[from] >= amount, "ERC20: insufficient balance");
  37 |     |         require(allowance[from][msg.sender] >= amount, "ERC20: insufficient allowance");
  38 |     |         if (allowance[from][msg.sender] != type(uint256).max) {
  39 |     |             allowance[from][msg.sender] -= amount;
  40 |     |         }
  41 |     |         balanceOf[from] -= amount;
  42 |     |         balanceOf[to] += amount;
  43 |     |         emit Transfer(from, to, amount);
  44 |     |         return true;
  45 |     |     }
  46 |     | 
  47 |     |     function mint(address to, uint256 amount) public {
  48 |     |         balanceOf[to] += amount;
  49 |     |         totalSupply += amount;
  50 |     |         emit Transfer(address(0), to, amount);
  51 |     |     }
  52 |     | }
  53 |     | 
  54 |     | contract MarketplaceTest is Test {
  55 |     |     // Core contracts
  56 |     |     ProjectRegistry registry;
  57 |     |     DynamicImpactCredit credit;
  58 |     |     Marketplace marketplace;
  59 |     | 
  60 |     |     // Mock payment token
  61 |     |     MockERC20 paymentToken;
  62 |     | 
  63 |     |     // Users
  64 |     |     address admin = address(0xA11CE);
  65 |     |     address seller = address(0x5E11E);
  66 |     |     address buyer = address(0xB4BE);
  67 |     |     address verifier = address(0xC1E4);
  68 |     |     address dmrvManager = address(0xB01D);
  69 |     |     address treasury = address(0xFE35);
  70 |     | 
  71 |     |     // Project and Token IDs
  72 |     |     bytes32 projectId = keccak256("Test Project");
  73 |     |     uint256 tokenId;
  74 |     | 
  75 |     |     function setUp() public {
  76 |     |         tokenId = uint256(projectId);
  77 |     | 
  78 |     |         // --- Deploy Infrastructure ---
  79 |     |         // Deploy payment token and mint to buyer
  80 |     |         paymentToken = new MockERC20("Mock Payment", "MPAY", 18);
  81 |     |         vm.prank(address(this)); // Mint from test contract itself
  82 |     |         paymentToken.mint(buyer, 1_000_000 * 1e18); // 1M USDC
  83 |     | 
  84 |     |         vm.startPrank(admin);
  85 |     | 
  86 |     |         // 1. Deploy Registry
  87 |     |         ProjectRegistry registryImpl = new ProjectRegistry();
  88 |     |         ERC1967Proxy registryProxy =
  89 |     |             new ERC1967Proxy(address(registryImpl), abi.encodeCall(ProjectRegistry.initialize, ()));
  90 |     |         registry = ProjectRegistry(address(registryProxy));
  91 |     |         registry.grantRole(registry.VERIFIER_ROLE(), verifier);
  92 |     | 
  93 |     |         // 2. Deploy DynamicImpactCredit
  94 |     |         DynamicImpactCredit creditImpl = new DynamicImpactCredit(address(registry));
  95 |     |         credit = DynamicImpactCredit(
  96 |     |             address(
  97 |     |                 new ERC1967Proxy(
  98 |     |                     address(creditImpl),
  99 |     |                     abi.encodeCall(DynamicImpactCredit.initialize, ("ipfs://contract-metadata.json"))
 100 |     |                 )
 101 |     |             )
 102 |     |         );
 103 |     |         credit.grantRole(credit.DMRV_MANAGER_ROLE(), dmrvManager);
 104 |     | 
 105 |     |         // 3. Deploy Marketplace
 106 |     |         Marketplace marketplaceImpl = new Marketplace();
 107 |     |         ERC1967Proxy marketplaceProxy = new ERC1967Proxy(
 108 |     |             address(marketplaceImpl), abi.encodeCall(Marketplace.initialize, (address(credit), address(paymentToken)))
 109 |     |         );
 110 |     |         marketplace = Marketplace(address(marketplaceProxy));
 111 |     |         marketplace.setTreasury(treasury);
 112 |     |         marketplace.setFee(250); // Set a 2.5% fee
 113 |     | 
 114 |     |         vm.stopPrank();
 115 |     | 
 116 |     |         // --- Prepare for tests ---
 117 |     |         // 1. Register and activate project
 118 |     |         vm.prank(seller);
 119 |     |         registry.registerProject(projectId, "ipfs://project.json");
 120 |     |         vm.prank(verifier);
 121 |     |         registry.setProjectStatus(projectId, ProjectRegistry.ProjectStatus.Active);
 122 |     | 
 123 |     |         // 2. Mint some credits to the seller
 124 |     |         vm.prank(dmrvManager);
 125 |     |         credit.mintCredits(seller, projectId, 1000, "ipfs://credit.json");
 126 |     |     }
 127 |     | 
 128 |     |     // Helper to list an item
 129 |     |     function _list() internal returns (uint256 listingId) {
 130 |     |         vm.startPrank(seller);
 131 |     |         credit.setApprovalForAll(address(marketplace), true);
 132 |     |         listingId = marketplace.list(tokenId, 100, 5 * 1e6, 1 days);
 133 |     |         vm.stopPrank();
 134 |     |         return listingId;
 135 |     |     }
 136 |     | 
 137 |     |     // --- Tests ---
 138 |     | 
 139 |     |     function test_List() public {
 140 |     |         vm.startPrank(seller);
 141 |     |         credit.setApprovalForAll(address(marketplace), true);
 142 |     | 
 143 |     |         uint256 initialSellerBalance = credit.balanceOf(seller, tokenId);
 144 |     |         uint256 listingId = marketplace.list(tokenId, 100, 5 * 1e6, 1 days);
 145 |     |         vm.stopPrank();
 146 |     | 
 147 |     |         uint256 finalSellerBalance = credit.balanceOf(seller, tokenId);
 148 |     |         uint256 marketplaceBalance = credit.balanceOf(address(marketplace), tokenId);
 149 |     | 
 150 |     |         assertEq(initialSellerBalance - finalSellerBalance, 100, "Seller should send tokens to marketplace");
 151 |     |         assertEq(marketplaceBalance, 100, "Marketplace should receive tokens");
 152 |     | 
 153 |     |         Marketplace.Listing memory listing = marketplace.getListing(listingId);
 154 |     | 
 155 |     |         assertEq(listing.seller, seller);
 156 |     |         assertEq(listing.tokenId, tokenId);
 157 |     |         assertEq(listing.amount, 100);
 158 |     |         assertEq(listing.pricePerUnit, 5 * 1e6);
 159 |     |         assertTrue(listing.active);
 160 |     |     }
 161 |     | 
 162 |     |     function test_Buy() public {
 163 |     |         uint256 listingId = _list();
 164 |     |         uint256 amountToBuy = 50;
 165 |     |         uint256 pricePerUnit = 5 * 1e6;
 166 |     |         uint256 totalPrice = amountToBuy * pricePerUnit;
 167 |     |         uint256 fee = (totalPrice * 250) / 10000;
 168 |     |         uint256 sellerProceeds = totalPrice - fee;
 169 |     | 
 170 |     |         uint256 sellerInitialPaymentBalance = paymentToken.balanceOf(seller);
 171 |     |         uint256 treasuryInitialBalance = paymentToken.balanceOf(treasury);
 172 |     | 
 173 |     |         vm.prank(buyer);
 174 |     |         paymentToken.approve(address(marketplace), totalPrice);
 175 |     | 
 176 |     |         vm.prank(buyer);
 177 |     |         marketplace.buy(listingId, amountToBuy);
 178 |     | 
 179 |     |         // Check NFT balances
 180 |     |         assertEq(credit.balanceOf(address(marketplace), tokenId), 50);
 181 |     |         assertEq(credit.balanceOf(buyer, tokenId), amountToBuy);
 182 |     | 
 183 |     |         // Check payment balances
 184 |     |         assertEq(paymentToken.balanceOf(seller), sellerInitialPaymentBalance + sellerProceeds);
 185 |     |         assertEq(paymentToken.balanceOf(treasury), treasuryInitialBalance + fee);
 186 |     | 
 187 |     |         // Check listing state
 188 |     |         Marketplace.Listing memory listing = marketplace.getListing(listingId);
 189 |     |         assertEq(listing.amount, 100 - amountToBuy);
 190 |     |         assertTrue(listing.active);
 191 |     |     }
 192 |     | 
 193 |     |     function test_Buy_FullListing() public {
 194 |     |         uint256 listingId = _list();
 195 |     |         uint256 amountToBuy = 100;
 196 |     |         uint256 totalPrice = amountToBuy * 5 * 1e6;
 197 |     | 
 198 |     |         vm.prank(buyer);
 199 |     |         paymentToken.approve(address(marketplace), totalPrice);
 200 |     | 
 201 |     |         vm.prank(buyer);
 202 |     |         marketplace.buy(listingId, amountToBuy);
 203 |     | 
 204 |     |         Marketplace.Listing memory listing = marketplace.getListing(listingId);
 205 |     |         assertFalse(listing.active);
 206 |     |         assertEq(listing.amount, 0);
 207 |     |         assertEq(credit.balanceOf(address(marketplace), tokenId), 0);
 208 |     |     }
 209 |     | 
 210 |     |     function test_Buy_WithZeroFee() public {
 211 |     |         // --- Setup ---
 212 |     |         // Set fee to 0 to test the fee == 0 branch
 213 |     |         vm.prank(admin);
 214 |     |         marketplace.setFee(0);
 215 |     | 
 216 |     |         uint256 listingId = _list();
 217 |     |         uint256 amountToBuy = 50;
 218 |     |         uint256 pricePerUnit = 5 * 1e6;
 219 |     |         uint256 totalPrice = amountToBuy * pricePerUnit;
 220 |     | 
 221 |     |         uint256 sellerInitialPaymentBalance = paymentToken.balanceOf(seller);
 222 |     |         uint256 treasuryInitialBalance = paymentToken.balanceOf(treasury);
 223 |     | 
 224 |     |         // --- Action ---
 225 |     |         vm.prank(buyer);
 226 |     |         paymentToken.approve(address(marketplace), totalPrice);
 227 |     | 
 228 |     |         vm.prank(buyer);
 229 |     |         marketplace.buy(listingId, amountToBuy);
 230 |     | 
 231 |     |         // --- Assertions ---
 232 |     |         // Check NFT balances
 233 |     |         assertEq(credit.balanceOf(buyer, tokenId), amountToBuy, "Buyer should receive the NFTs");
 234 |     | 
 235 |     |         // Check payment balances: Seller gets full amount, treasury gets nothing
 236 |     |         assertEq(
 237 |     |             paymentToken.balanceOf(seller),
 238 |     |             sellerInitialPaymentBalance + totalPrice,
 239 |     |             "Seller should receive full payment when fee is zero"
 240 |     |         );
 241 |     |         assertEq(
 242 |     |             paymentToken.balanceOf(treasury),
 243 |     |             treasuryInitialBalance,
 244 |     |             "Treasury balance should not change when fee is zero"
 245 |     |         );
 246 |     |     }
 247 |     | 
 248 |     |     function test_CancelListing() public {
 249 |     |         uint256 listingId = _list();
 250 |     |         uint256 sellerInitialBalance = credit.balanceOf(seller, tokenId);
 251 |     |         uint256 marketplaceBalance = credit.balanceOf(address(marketplace), tokenId);
 252 |     |         assertEq(marketplaceBalance, 100);
 253 |     | 
 254 |     |         vm.prank(seller);
 255 |     |         marketplace.cancelListing(listingId);
 256 |     | 
 257 |     |         Marketplace.Listing memory listing = marketplace.getListing(listingId);
 258 |     |         assertFalse(listing.active);
 259 |     |         assertEq(credit.balanceOf(seller, tokenId), sellerInitialBalance + 100);
 260 |     |         assertEq(credit.balanceOf(address(marketplace), tokenId), 0);
 261 |     |     }
 262 |     | 
 263 |     |     function test_CancelExpiredListing() public {
 264 |     |         uint256 listingId = _list(); // Lists with 1 day expiry
 265 |     |         uint256 sellerInitialBalance = credit.balanceOf(seller, tokenId);
 266 |     | 
 267 |     |         // Fast-forward time past the expiry
 268 |     |         vm.warp(block.timestamp + 2 days);
 269 |     | 
 270 |     |         // Anyone can cancel an expired listing
 271 |     |         vm.prank(buyer);
 272 |     |         marketplace.cancelExpiredListing(listingId);
 273 |     | 
 274 |     |         // Check listing is inactive and seller got their tokens back
 275 |     |         Marketplace.Listing memory listing = marketplace.getListing(listingId);
 276 |     |         assertFalse(listing.active);
 277 |     |         assertEq(credit.balanceOf(seller, tokenId), sellerInitialBalance + 100);
 278 |     |         assertEq(credit.balanceOf(address(marketplace), tokenId), 0);
 279 |     |     }
 280 |     | 
 281 |     |     function test_Fail_CancelExpiredOnNonExpiredListing() public {
 282 |     |         uint256 listingId = _list(); // Lists with 1 day expiry
 283 |     | 
 284 |     |         // Try to cancel immediately
 285 |     |         vm.prank(buyer);
 286 |     |         vm.expectRevert(Marketplace__ListingNotExpired.selector);
 287 |     |         marketplace.cancelExpiredListing(listingId);
 288 |     |     }
 289 |     | 
 290 |     |     function test_UpdateListingPrice() public {
 291 |     |         uint256 listingId = _list();
 292 |     |         uint256 newPrice = 10 * 1e6;
 293 |     | 
 294 |     |         vm.prank(seller);
 295 |     |         marketplace.updateListingPrice(listingId, newPrice);
 296 |     | 
 297 |     |         Marketplace.Listing memory listing = marketplace.getListing(listingId);
 298 |     |         assertEq(listing.pricePerUnit, newPrice);
 299 |     |     }
 300 |     | 
 301 |     |     function test_Fail_UpdateListingPrice_NotSeller() public {
 302 |     |         uint256 listingId = _list();
 303 |     | 
 304 |     |         vm.prank(buyer); // Use a different user
 305 |     |         vm.expectRevert(Marketplace__NotTheSeller.selector);
 306 |     |         marketplace.updateListingPrice(listingId, 10 * 1e6);
 307 |     |     }
 308 |     | 
 309 |     |     function test_Fail_UpdateListingPrice_InactiveListing() public {
 310 |     |         uint256 listingId = _list();
 311 |     | 
 312 |     |         // Cancel the listing to make it inactive
 313 |     |         vm.prank(seller);
 314 |     |         marketplace.cancelListing(listingId);
 315 |     | 
 316 |     |         // Try to update the price
 317 |     |         vm.prank(seller);
 318 |     |         vm.expectRevert(Marketplace__ListingNotActive.selector);
 319 |     |         marketplace.updateListingPrice(listingId, 10 * 1e6);
 320 |     |     }
 321 |     | 
 322 |     |     function test_Fail_UpdateListingPrice_ZeroPrice() public {
 323 |     |         uint256 listingId = _list();
 324 |     | 
 325 |     |         vm.prank(seller);
 326 |     |         vm.expectRevert(Marketplace__ZeroPrice.selector);
 327 |     |         marketplace.updateListingPrice(listingId, 0);
 328 |     |     }
 329 |     | 
 330 |     |     function test_Fail_SetTreasury_ToZeroAddress() public {
 331 |     |         vm.prank(admin);
 332 |     |         vm.expectRevert(Marketplace__TreasuryAddressZero.selector);
 333 |     |         marketplace.setTreasury(address(0));
 334 |     |     }
 335 |     | 
 336 |     |     function test_Fail_SetFee_AboveCap() public {
 337 |     |         vm.prank(admin);
 338 |     |         vm.expectRevert(Marketplace__FeeTooHigh.selector);
 339 |     |         marketplace.setFee(10001); // 100.01%
 340 |     |     }
 341 |     | 
 342 |     |     function test_Fail_ListWithZeroAmount() public {
 343 |     |         vm.expectRevert(Marketplace__ZeroAmount.selector);
 344 |     |         vm.prank(seller);
 345 |     |         marketplace.list(tokenId, 0, 5 * 1e6, 1 days);
 346 |     |     }
 347 |     | 
 348 |     |     function test_Fail_ListWithZeroPrice() public {
 349 |     |         vm.expectRevert(Marketplace__ZeroPrice.selector);
 350 |     |         vm.prank(seller);
 351 |     |         marketplace.list(tokenId, 100, 0, 1 days);
 352 |     |     }
 353 |     | 
 354 |     |     function test_Fail_ListWithZeroExpiry() public {
 355 |     |         vm.expectRevert(Marketplace__ZeroExpiry.selector);
 356 |     |         vm.prank(seller);
 357 |     |         marketplace.list(tokenId, 100, 5 * 1e6, 0);
 358 |     |     }
 359 |     | 
 360 |     |     function test_Fail_BuyExpiredListing() public {
 361 |     |         uint256 listingId = _list(); // Lists with 1 day expiry
 362 |     | 
 363 |     |         // Fast-forward time past the expiry
 364 |     |         vm.warp(block.timestamp + 2 days);
 365 |     | 
 366 |     |         vm.prank(buyer);
 367 |     |         vm.expectRevert(Marketplace__ListingExpired.selector);
 368 |     |         marketplace.buy(listingId, 10);
 369 |     |     }
 370 |     | 
 371 |     |     function test_Fail_BuyZeroAmount() public {
 372 |     |         uint256 listingId = _list();
 373 |     |         vm.prank(buyer);
 374 |     |         vm.expectRevert(Marketplace__ZeroAmount.selector);
 375 |     |         marketplace.buy(listingId, 0);
 376 |     |     }
 377 |     | 
 378 |     |     function test_Fail_BuyMoreThanListed() public {
 379 |     |         uint256 listingId = _list(); // Lists 100 items
 380 |     |         vm.prank(buyer);
 381 |     |         vm.expectRevert(Marketplace__NotEnoughItemsInListing.selector);
 382 |     |         marketplace.buy(listingId, 101);
 383 |     |     }
 384 |     | 
 385 |     |     /* ---------- Event Tests ---------- */
 386 |     | 
 387 |     |     function test_EmitFeePaidEvent() public {
 388 |     |         uint256 listingId = _list();
 389 |     |         uint256 amountToBuy = 50;
 390 |     |         uint256 totalPrice = amountToBuy * 5 * 1e6;
 391 |     |         uint256 fee = (totalPrice * 250) / 10000;
 392 |     | 
 393 |     |         vm.prank(buyer);
 394 |     |         paymentToken.approve(address(marketplace), totalPrice);
 395 |     | 
 396 |     |         vm.expectEmit(true, true, true, true);
 397 |     |         emit Marketplace.FeePaid(treasury, fee);
 398 |     | 
 399 |     |         vm.prank(buyer);
 400 |     |         marketplace.buy(listingId, amountToBuy);
 401 |     |     }
 402 |     | 
 403 |     |     /* ---------- Access Control & Failure Tests ---------- */
 404 |     | 
 405 |     |     function test_Fail_ListWithoutApproval() public {
 406 |     |         vm.expectRevert(); // ERC1155: insufficient balance for transfer
 407 |     |         vm.startPrank(seller);
 408 |     |         marketplace.list(tokenId, 100, 5 * 1e6, 1 days);
 409 |     |         vm.stopPrank();
 410 |     |     }
 411 |     | 
 412 |     |     function test_Fail_BuyWithInsufficientPayment() public {
 413 |     |         uint256 listingId = _list();
 414 |     | 
 415 |     |         vm.prank(buyer);
 416 |     |         // Approve less than required
 417 |     |         paymentToken.approve(address(marketplace), 10 * 1e6);
 418 |     | 
 419 |     |         vm.prank(buyer);
 420 |     |         vm.expectRevert("ERC20: insufficient allowance");
 421 |     |         marketplace.buy(listingId, 50);
 422 |     |     }
 423 |     | 
 424 |     |     function test_Fail_NonSellerCannotCancel() public {
 425 |     |         uint256 listingId = _list();
 426 |     |         vm.prank(buyer);
 427 |     |         vm.expectRevert(Marketplace__NotTheSeller.selector);
 428 |     |         marketplace.cancelListing(listingId);
 429 |     |     }
 430 |     | 
 431 |     |     function test_Fail_BuyWithInsufficientBalance() public {
 432 |     |         uint256 listingId = _list();
 433 |     |         uint256 amountToBuy = 50;
 434 |     |         uint256 pricePerUnit = 5 * 1e6;
 435 |     |         uint256 totalPrice = amountToBuy * pricePerUnit;
 436 |     | 
 437 |     |         address brokeBuyer = address(0xDEAD);
 438 |     | 
 439 |     |         vm.prank(brokeBuyer);
 440 |     |         paymentToken.approve(address(marketplace), totalPrice);
 441 |     | 
 442 |     |         vm.prank(brokeBuyer);
 443 |     |         // The Marketplace contract has its own balance check that runs before the ERC20 transfer.
 444 |     |         vm.expectRevert(Marketplace__InsufficientBalance.selector);
 445 |     |         marketplace.buy(listingId, amountToBuy);
 446 |     |     }
 447 |     | 
 448 |     |     function test_Fail_GetNonExistentListing() public {
 449 |     |         vm.expectRevert(Marketplace__ListingNotFound.selector);
 450 |     |         marketplace.getListing(999);
 451 |     |     }
 452 |     | 
 453 |     |     /* ---------- Pausable Tests ---------- */
 454 |     | 
 455 |     |     function test_PauseAndUnpause() public {
 456 |     |         bytes32 pauserRole = marketplace.PAUSER_ROLE();
 457 |     | 
 458 |     |         vm.startPrank(admin);
 459 |     |         // Admin can pause and unpause
 460 |     |         marketplace.pause();
 461 |     |         assertTrue(marketplace.paused());
 462 |     |         marketplace.unpause();
 463 |     |         assertFalse(marketplace.paused());
 464 |     |         vm.stopPrank();
 465 |     | 
 466 |     |         // Non-pauser cannot pause
 467 |     |         vm.prank(seller);
 468 |     |         vm.expectRevert(
 469 |     |             abi.encodeWithSelector(
 470 |     |                 bytes4(keccak256("AccessControlUnauthorizedAccount(address,bytes32)")), seller, pauserRole
 471 |     |             )
 472 |     |         );
 473 |     |         marketplace.pause();
 474 |     |     }
 475 |     | 
 476 |     |     function test_RevertsWhenPaused() public {
 477 |     |         uint256 listingId = _list();
 478 |     | 
 479 |     |         vm.startPrank(admin);
 480 |     |         marketplace.pause();
 481 |     |         vm.stopPrank();
 482 |     | 
 483 |     |         // Check key functions revert when paused
 484 |     |         bytes4 expectedRevert = bytes4(keccak256("EnforcedPause()"));
 485 |     | 
 486 |     |         vm.prank(seller);
 487 |     |         vm.expectRevert(expectedRevert);
 488 |     |         marketplace.list(tokenId, 10, 1e6, 1 days);
 489 |     | 
 490 |     |         vm.prank(buyer);
 491 |     |         vm.expectRevert(expectedRevert);
 492 |     |         marketplace.buy(listingId, 1);
 493 |     | 
 494 |     |         vm.prank(seller);
 495 |     |         vm.expectRevert(expectedRevert);
 496 |     |         marketplace.cancelListing(listingId);
 497 |     | 
 498 |     |         vm.prank(seller);
 499 |     |         vm.expectRevert(expectedRevert);
 500 |     |         marketplace.updateListingPrice(listingId, 6e6);
 501 |     |     }
 502 |     | }
 503 |     | 

/home/phantom/Documents/azemora/azemora-contracts/test/projectRegistry/ProjectRegistry.t.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | pragma solidity ^0.8.20;
   3 |     | 
   4 |     | import "forge-std/Test.sol";
   5 |     | import "../../src/core/ProjectRegistry.sol";
   6 |     | import "@openzeppelin/contracts/proxy/ERC1967/ERC1967Proxy.sol";
   7 |     | 
   8 |     | contract ProjectRegistryTest is Test {
   9 |     |     ProjectRegistry registry;
  10 |     | 
  11 |     |     address admin = address(0xA11CE);
  12 |     |     address verifier = address(0xC1E4);
  13 |     |     address projectOwner = address(0x044E);
  14 |     |     address anotherUser = address(0xBEEF);
  15 |     | 
  16 |     |     bytes32 projectId = keccak256("Test Project");
  17 |     | 
  18 |     |     function setUp() public {
  19 |     |         vm.startPrank(admin);
  20 |     |         ProjectRegistry registryImpl = new ProjectRegistry();
  21 |     |         bytes memory registryInitData = abi.encodeCall(ProjectRegistry.initialize, ());
  22 |     |         ERC1967Proxy registryProxy = new ERC1967Proxy(address(registryImpl), registryInitData);
  23 |     |         registry = ProjectRegistry(address(registryProxy));
  24 |     | 
  25 |     |         // Grant verifier role
  26 |     |         registry.grantRole(registry.VERIFIER_ROLE(), verifier);
  27 |     |         vm.stopPrank();
  28 |     | 
  29 |     |         // Register a project for testing state-changing functions
  30 |     |         vm.prank(projectOwner);
  31 |     |         registry.registerProject(projectId, "ipfs://initial.json");
  32 |     |     }
  33 |     | 
  34 |     |     /* ----------------- */
  35 |     |     /*     Registration  */
  36 |     |     /* ----------------- */
  37 |     | 
  38 |     |     function test_Register_WritesStructAndEmitsEvent() public {
  39 |     |         bytes32 newId = keccak256("New Project");
  40 |     |         string memory uri = "ipfs://new.json";
  41 |     | 
  42 |     |         vm.prank(anotherUser);
  43 |     |         vm.expectEmit(true, true, true, true, address(registry));
  44 |     |         emit ProjectRegistry.ProjectRegistered(newId, anotherUser, uri);
  45 |     |         registry.registerProject(newId, uri);
  46 |     | 
  47 |     |         ProjectRegistry.Project memory project = registry.getProject(newId);
  48 |     |         assertEq(project.id, newId);
  49 |     |         assertEq(project.owner, anotherUser);
  50 |     |         assertEq(uint8(project.status), uint8(ProjectRegistry.ProjectStatus.Pending));
  51 |     |         assertEq(project.metaURI, uri);
  52 |     |     }
  53 |     | 
  54 |     |     function test_Register_RevertsOnDuplicateId() public {
  55 |     |         vm.prank(anotherUser);
  56 |     |         vm.expectRevert(ProjectRegistry__IdAlreadyExists.selector);
  57 |     |         registry.registerProject(projectId, "ipfs://duplicate.json");
  58 |     |     }
  59 |     | 
  60 |     |     /* ----------------- */
  61 |     |     /*    Status Changes */
  62 |     |     /* ----------------- */
  63 |     | 
  64 |     |     function test_SetStatus_VerifierCanApprove() public {
  65 |     |         vm.prank(verifier);
  66 |     |         vm.expectEmit(true, true, true, true, address(registry));
  67 |     |         emit ProjectRegistry.ProjectStatusChanged(
  68 |     |             projectId, ProjectRegistry.ProjectStatus.Pending, ProjectRegistry.ProjectStatus.Active
  69 |     |         );
  70 |     |         registry.setProjectStatus(projectId, ProjectRegistry.ProjectStatus.Active);
  71 |     |         assertTrue(registry.isProjectActive(projectId));
  72 |     |     }
  73 |     | 
  74 |     |     function test_SetStatus_AdminCanPauseAndArchive() public {
  75 |     |         // First, activate the project
  76 |     |         vm.prank(verifier);
  77 |     |         registry.setProjectStatus(projectId, ProjectRegistry.ProjectStatus.Active);
  78 |     | 
  79 |     |         // Then, admin can pause it
  80 |     |         vm.startPrank(admin);
  81 |     |         vm.expectEmit(true, true, true, true, address(registry));
  82 |     |         emit ProjectRegistry.ProjectStatusChanged(
  83 |     |             projectId, ProjectRegistry.ProjectStatus.Active, ProjectRegistry.ProjectStatus.Paused
  84 |     |         );
  85 |     |         registry.setProjectStatus(projectId, ProjectRegistry.ProjectStatus.Paused);
  86 |     |         assertEq(uint8(registry.getProject(projectId).status), uint8(ProjectRegistry.ProjectStatus.Paused));
  87 |     | 
  88 |     |         // And admin can archive it
  89 |     |         vm.expectEmit(true, true, true, true, address(registry));
  90 |     |         emit ProjectRegistry.ProjectStatusChanged(
  91 |     |             projectId, ProjectRegistry.ProjectStatus.Paused, ProjectRegistry.ProjectStatus.Archived
  92 |     |         );
  93 |     |         registry.setProjectStatus(projectId, ProjectRegistry.ProjectStatus.Archived);
  94 |     |         vm.stopPrank();
  95 |     | 
  96 |     |         assertEq(uint8(registry.getProject(projectId).status), uint8(ProjectRegistry.ProjectStatus.Archived));
  97 |     |         assertFalse(registry.isProjectActive(projectId));
  98 |     |     }
  99 |     | 
 100 |     |     function test_SetStatus_RevertsForNonVerifier() public {
 101 |     |         vm.prank(anotherUser);
 102 |     |         vm.expectRevert(ProjectRegistry__CallerNotVerifier.selector);
 103 |     |         registry.setProjectStatus(projectId, ProjectRegistry.ProjectStatus.Active);
 104 |     |     }
 105 |     | 
 106 |     |     function test_SetStatus_RevertsForNonAdmin() public {
 107 |     |         vm.prank(anotherUser);
 108 |     |         vm.expectRevert(ProjectRegistry__CallerNotAdmin.selector);
 109 |     |         registry.setProjectStatus(projectId, ProjectRegistry.ProjectStatus.Paused);
 110 |     | 
 111 |     |         vm.expectRevert(ProjectRegistry__CallerNotAdmin.selector);
 112 |     |         registry.setProjectStatus(projectId, ProjectRegistry.ProjectStatus.Archived);
 113 |     |     }
 114 |     | 
 115 |     |     function test_SetStatus_RevertsOnInvalidTransition() public {
 116 |     |         // an already pending project cannot be set to pending again
 117 |     |         vm.prank(admin);
 118 |     |         vm.expectRevert(ProjectRegistry__StatusIsSame.selector);
 119 |     |         registry.setProjectStatus(projectId, ProjectRegistry.ProjectStatus.Pending);
 120 |     |     }
 121 |     | 
 122 |     |     function test_SetStatus_RevertsOnArchivedProject() public {
 123 |     |         // first, archive it
 124 |     |         vm.prank(verifier);
 125 |     |         registry.setProjectStatus(projectId, ProjectRegistry.ProjectStatus.Active);
 126 |     |         vm.prank(admin);
 127 |     |         registry.setProjectStatus(projectId, ProjectRegistry.ProjectStatus.Archived);
 128 |     | 
 129 |     |         // then, try to change it
 130 |     |         vm.prank(admin);
 131 |     |         vm.expectRevert(ProjectRegistry__ArchivedProjectCannotBeModified.selector);
 132 |     |         registry.setProjectStatus(projectId, ProjectRegistry.ProjectStatus.Paused);
 133 |     |     }
 134 |     | 
 135 |     |     function test_SetStatus_RevertsOnNonExistentProject() public {
 136 |     |         vm.prank(verifier);
 137 |     |         vm.expectRevert(ProjectRegistry__ProjectNotFound.selector);
 138 |     |         registry.setProjectStatus(bytes32(uint256(420)), ProjectRegistry.ProjectStatus.Active);
 139 |     |     }
 140 |     | 
 141 |     |     function test_SetStatus_RevertsOnInvalidTransitionToPaused() public {
 142 |     |         // cannot pause from pending
 143 |     |         vm.prank(admin);
 144 |     |         vm.expectRevert(ProjectRegistry__InvalidPauseState.selector);
 145 |     |         registry.setProjectStatus(projectId, ProjectRegistry.ProjectStatus.Paused);
 146 |     |     }
 147 |     | 
 148 |     |     function test_SetStatus_RevertsOnInvalidTransitionToPending() public {
 149 |     |         // cannot transition to pending from any other state
 150 |     |         vm.prank(verifier);
 151 |     |         registry.setProjectStatus(projectId, ProjectRegistry.ProjectStatus.Active);
 152 |     |         vm.prank(admin);
 153 |     |         vm.expectRevert(ProjectRegistry__InvalidStatusTransition.selector);
 154 |     |         registry.setProjectStatus(projectId, ProjectRegistry.ProjectStatus.Pending);
 155 |     |     }
 156 |     | 
 157 |     |     /* ----------------- */
 158 |     |     /*     Ownership     */
 159 |     |     /* ----------------- */
 160 |     | 
 161 |     |     function test_SetProjectMetaURI_OnlyOwnerCanUpdate() public {
 162 |     |         string memory newURI = "ipfs://updated.json";
 163 |     | 
 164 |     |         // Owner should succeed
 165 |     |         vm.prank(projectOwner);
 166 |     |         vm.expectEmit(true, true, true, true, address(registry));
 167 |     |         emit ProjectRegistry.ProjectMetaURIUpdated(projectId, newURI);
 168 |     |         registry.setProjectMetaURI(projectId, newURI);
 169 |     |         assertEq(registry.getProject(projectId).metaURI, newURI);
 170 |     | 
 171 |     |         // Others should fail
 172 |     |         vm.prank(anotherUser);
 173 |     |         vm.expectRevert(ProjectRegistry__NotProjectOwner.selector);
 174 |     |         registry.setProjectMetaURI(projectId, "ipfs://fail.json");
 175 |     |     }
 176 |     | 
 177 |     |     function test_TransferProjectOwnership_OnlyOwnerCanTransfer() public {
 178 |     |         // Owner should succeed
 179 |     |         vm.prank(projectOwner);
 180 |     |         vm.expectEmit(true, true, true, true, address(registry));
 181 |     |         emit ProjectRegistry.ProjectOwnershipTransferred(projectId, projectOwner, anotherUser);
 182 |     |         registry.transferProjectOwnership(projectId, anotherUser);
 183 |     |         assertEq(registry.getProject(projectId).owner, anotherUser);
 184 |     | 
 185 |     |         // Old owner should fail
 186 |     |         vm.prank(projectOwner);
 187 |     |         vm.expectRevert(ProjectRegistry__NotProjectOwner.selector);
 188 |     |         registry.transferProjectOwnership(projectId, admin);
 189 |     |     }
 190 |     | 
 191 |     |     function test_TransferProjectOwnership_RevertsOnZeroAddress() public {
 192 |     |         vm.prank(projectOwner);
 193 |     |         vm.expectRevert(ProjectRegistry__NewOwnerIsZeroAddress.selector);
 194 |     |         registry.transferProjectOwnership(projectId, address(0));
 195 |     |     }
 196 |     | 
 197 |     |     function test_Fuzz_AccessControls(address caller, address newOwner, string calldata uri) public {
 198 |     |         vm.assume(caller != projectOwner);
 199 |     |         vm.assume(caller != admin);
 200 |     |         vm.assume(caller != verifier);
 201 |     | 
 202 |     |         // Test setProjectMetaURI
 203 |     |         vm.prank(caller);
 204 |     |         vm.expectRevert(ProjectRegistry__NotProjectOwner.selector);
 205 |     |         registry.setProjectMetaURI(projectId, uri);
 206 |     | 
 207 |     |         // Test transferProjectOwnership
 208 |     |         vm.prank(caller);
 209 |     |         vm.expectRevert(ProjectRegistry__NotProjectOwner.selector);
 210 |     |         registry.transferProjectOwnership(projectId, newOwner);
 211 |     |     }
 212 |     | 
 213 |     |     /* ----------------- */
 214 |     |     /*      Pausable     */
 215 |     |     /* ----------------- */
 216 |     | 
 217 |     |     function test_PauseAndUnpause() public {
 218 |     |         bytes32 pauserRole = registry.PAUSER_ROLE();
 219 |     | 
 220 |     |         vm.startPrank(admin);
 221 |     |         // Admin has pauser role by default from setUp
 222 |     |         registry.pause();
 223 |     |         assertTrue(registry.paused());
 224 |     |         registry.unpause();
 225 |     |         assertFalse(registry.paused());
 226 |     |         vm.stopPrank();
 227 |     | 
 228 |     |         // Non-pauser cannot pause
 229 |     |         vm.prank(anotherUser);
 230 |     |         vm.expectRevert(
 231 |     |             abi.encodeWithSelector(
 232 |     |                 bytes4(keccak256("AccessControlUnauthorizedAccount(address,bytes32)")), anotherUser, pauserRole
 233 |     |             )
 234 |     |         );
 235 |     |         registry.pause();
 236 |     |     }
 237 |     | 
 238 |     |     function test_RevertsWhenPaused() public {
 239 |     |         vm.prank(admin);
 240 |     |         registry.pause();
 241 |     | 
 242 |     |         // Check key functions revert when paused
 243 |     |         bytes4 expectedRevert = bytes4(keccak256("EnforcedPause()"));
 244 |     | 
 245 |     |         vm.prank(anotherUser);
 246 |     |         vm.expectRevert(expectedRevert);
 247 |     |         registry.registerProject(keccak256("paused project"), "ipfs://paused.json");
 248 |     | 
 249 |     |         vm.prank(verifier);
 250 |     |         vm.expectRevert(expectedRevert);
 251 |     |         registry.setProjectStatus(projectId, ProjectRegistry.ProjectStatus.Active);
 252 |     | 
 253 |     |         vm.prank(projectOwner);
 254 |     |         vm.expectRevert(expectedRevert);
 255 |     |         registry.setProjectMetaURI(projectId, "ipfs://paused.json");
 256 |     | 
 257 |     |         vm.prank(projectOwner);
 258 |     |         vm.expectRevert(expectedRevert);
 259 |     |         registry.transferProjectOwnership(projectId, anotherUser);
 260 |     |     }
 261 |     | 
 262 |     |     /* ----------------- */
 263 |     |     /*      View         */
 264 |     |     /* ----------------- */
 265 |     |     function test_GetProject_RevertsOnNonExistentProject() public {
 266 |     |         vm.expectRevert(ProjectRegistry__ProjectNotFound.selector);
 267 |     |         registry.getProject(keccak256("non existent"));
 268 |     |     }
 269 |     | }
 270 |     | 

/home/phantom/Documents/azemora/azemora-contracts/test/reverts/DynamicImpactCredit.reverts.t.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | pragma solidity ^0.8.20;
   3 |     | 
   4 |     | import "forge-std/Test.sol";
   5 |     | import "../../src/core/ProjectRegistry.sol";
   6 |     | import "../../src/core/DynamicImpactCredit.sol";
   7 |     | import "@openzeppelin/contracts/proxy/ERC1967/ERC1967Proxy.sol";
   8 |     | 
   9 |     | contract DynamicImpactCreditRevertsTest is Test {
  10 |     |     ProjectRegistry registry;
  11 |     |     DynamicImpactCredit credit;
  12 |     | 
  13 |     |     address admin = makeAddr("admin");
  14 |     |     address dmrvManager = makeAddr("dmrvManager");
  15 |     |     address metadataUpdater = makeAddr("metadataUpdater");
  16 |     |     address projectDeveloper = makeAddr("projectDeveloper");
  17 |     |     address otherUser = makeAddr("otherUser");
  18 |     | 
  19 |     |     bytes32 activeProjectId = keccak256("Active Project");
  20 |     |     uint256 activeTokenId = uint256(activeProjectId);
  21 |     |     bytes32 pendingProjectId = keccak256("Pending Project");
  22 |     | 
  23 |     |     function setUp() public {
  24 |     |         vm.startPrank(admin);
  25 |     |         // Deploy Registry
  26 |     |         ProjectRegistry registryImpl = new ProjectRegistry();
  27 |     |         registry = ProjectRegistry(
  28 |     |             address(new ERC1967Proxy(address(registryImpl), abi.encodeCall(ProjectRegistry.initialize, ())))
  29 |     |         );
  30 |     |         // No verifier needed, we control status directly with admin for this test
  31 |     | 
  32 |     |         // Deploy Credits contract
  33 |     |         DynamicImpactCredit creditImpl = new DynamicImpactCredit(address(registry));
  34 |     |         credit = DynamicImpactCredit(
  35 |     |             address(new ERC1967Proxy(address(creditImpl), abi.encodeCall(DynamicImpactCredit.initialize, ("ipfs://"))))
  36 |     |         );
  37 |     | 
  38 |     |         // Grant necessary roles
  39 |     |         credit.grantRole(credit.DMRV_MANAGER_ROLE(), dmrvManager);
  40 |     |         credit.grantRole(credit.METADATA_UPDATER_ROLE(), metadataUpdater);
  41 |     |         vm.stopPrank();
  42 |     | 
  43 |     |         // Setup a pending and an active project
  44 |     |         vm.prank(projectDeveloper);
  45 |     |         registry.registerProject(pendingProjectId, "ipfs://pending");
  46 |     |         vm.prank(projectDeveloper);
  47 |     |         registry.registerProject(activeProjectId, "ipfs://active");
  48 |     |         vm.prank(admin);
  49 |     |         registry.setProjectStatus(activeProjectId, ProjectRegistry.ProjectStatus.Active);
  50 |     |     }
  51 |     | 
  52 |     |     // --- mintCredits ---
  53 |     | 
  54 |     |     function test_revert_mintCredits_notDMRVManager() public {
  55 |     |         bytes4 expectedError = bytes4(keccak256("AccessControlUnauthorizedAccount(address,bytes32)"));
  56 |     |         vm.expectRevert(abi.encodeWithSelector(expectedError, otherUser, credit.DMRV_MANAGER_ROLE()));
  57 |     |         vm.prank(otherUser);
  58 |     |         credit.mintCredits(projectDeveloper, activeProjectId, 100, "ipfs://data");
  59 |     |     }
  60 |     | 
  61 |     |     function test_revert_mintCredits_projectNotActive() public {
  62 |     |         vm.expectRevert(DynamicImpactCredit__ProjectNotActive.selector);
  63 |     |         vm.prank(dmrvManager);
  64 |     |         credit.mintCredits(projectDeveloper, pendingProjectId, 100, "ipfs://data");
  65 |     |     }
  66 |     | 
  67 |     |     // --- setTokenURI ---
  68 |     | 
  69 |     |     function test_revert_setTokenURI_notMetadataUpdater() public {
  70 |     |         // First mint a token so we can try to update its URI
  71 |     |         vm.prank(dmrvManager);
  72 |     |         credit.mintCredits(projectDeveloper, activeProjectId, 1, "ipfs://original");
  73 |     | 
  74 |     |         bytes4 expectedError = bytes4(keccak256("AccessControlUnauthorizedAccount(address,bytes32)"));
  75 |     |         vm.expectRevert(abi.encodeWithSelector(expectedError, otherUser, credit.METADATA_UPDATER_ROLE()));
  76 |     |         vm.prank(otherUser);
  77 |     |         credit.setTokenURI(activeProjectId, "ipfs://new");
  78 |     |     }
  79 |     | 
  80 |     |     // --- uri ---
  81 |     | 
  82 |     |     function test_revert_uri_nonExistentToken() public {
  83 |     |         vm.expectRevert(DynamicImpactCredit__URINotSet.selector);
  84 |     |         credit.uri(uint256(keccak256("non-existent")));
  85 |     |     }
  86 |     | 
  87 |     |     // --- retire ---
  88 |     | 
  89 |     |     function test_revert_retire_notOwnerOrApproved() public {
  90 |     |         // Mint tokens to the project developer
  91 |     |         vm.prank(dmrvManager);
  92 |     |         credit.mintCredits(projectDeveloper, activeProjectId, 100, "ipfs://data");
  93 |     | 
  94 |     |         // Try to retire them from another user's account
  95 |     |         vm.expectRevert(DynamicImpactCredit__NotAuthorized.selector);
  96 |     |         vm.prank(otherUser);
  97 |     |         credit.retire(projectDeveloper, activeProjectId, 50);
  98 |     |     }
  99 |     | 
 100 |     |     // --- Pausable ---
 101 |     | 
 102 |     |     function test_revert_whenPaused_mintCredits() public {
 103 |     |         vm.prank(admin);
 104 |     |         credit.pause();
 105 |     | 
 106 |     |         vm.expectRevert(bytes("EnforcedPause()"));
 107 |     |         vm.prank(dmrvManager);
 108 |     |         credit.mintCredits(projectDeveloper, activeProjectId, 100, "ipfs://data");
 109 |     |     }
 110 |     | }
 111 |     | 

/home/phantom/Documents/azemora/azemora-contracts/test/reverts/Marketplace.reverts.t.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | pragma solidity ^0.8.20;
   3 |     | 
   4 |     | import "forge-std/Test.sol";
   5 |     | import "../../src/marketplace/Marketplace.sol";
   6 |     | import "../../src/core/DynamicImpactCredit.sol";
   7 |     | import "@openzeppelin/contracts/proxy/ERC1967/ERC1967Proxy.sol";
   8 |     | 
   9 |     | // Minimal mock ERC20 for testing reverts
  10 |     | contract MockERC20ForReverts is Test {
  11 |     |     mapping(address => uint256) public balanceOf;
  12 |     |     mapping(address => mapping(address => uint256)) public allowance;
  13 |     | 
  14 |     |     function approve(address spender, uint256 amount) public {
  15 |     |         allowance[msg.sender][spender] = amount;
  16 |     |     }
  17 |     | 
  18 |     |     function transferFrom(address from, address to, uint256 amount) public returns (bool) {
  19 |     |         if (allowance[from][msg.sender] < amount) return false;
  20 |     |         allowance[from][msg.sender] -= amount;
  21 |     |         balanceOf[from] -= amount;
  22 |     |         balanceOf[to] += amount;
  23 |     |         return true;
  24 |     |     }
  25 |     | 
  26 |     |     function mint(address to, uint256 amount) public {
  27 |     |         balanceOf[to] += amount;
  28 |     |     }
  29 |     | }
  30 |     | 
  31 |     | // Minimal mock ERC1155 for testing reverts
  32 |     | contract MockERC1155ForReverts is Test {
  33 |     |     mapping(address => mapping(uint256 => uint256)) public balanceOf;
  34 |     | 
  35 |     |     function safeTransferFrom(address, address to, uint256 id, uint256 amount, bytes memory) public {
  36 |     |         balanceOf[to][id] += amount;
  37 |     |     }
  38 |     | 
  39 |     |     function setApprovalForAll(address, bool) public {}
  40 |     | }
  41 |     | 
  42 |     | contract MarketplaceRevertsTest is Test {
  43 |     |     Marketplace marketplace;
  44 |     |     MockERC1155ForReverts credit;
  45 |     |     MockERC20ForReverts paymentToken;
  46 |     | 
  47 |     |     address admin = makeAddr("admin");
  48 |     |     address seller = makeAddr("seller");
  49 |     |     address buyer = makeAddr("buyer");
  50 |     |     address otherUser = makeAddr("otherUser");
  51 |     | 
  52 |     |     uint256 tokenId = 1;
  53 |     |     uint256 listingId;
  54 |     | 
  55 |     |     function setUp() public {
  56 |     |         credit = new MockERC1155ForReverts();
  57 |     |         paymentToken = new MockERC20ForReverts();
  58 |     | 
  59 |     |         vm.startPrank(admin);
  60 |     |         Marketplace marketplaceImpl = new Marketplace();
  61 |     |         marketplace = Marketplace(
  62 |     |             address(
  63 |     |                 new ERC1967Proxy(
  64 |     |                     address(marketplaceImpl),
  65 |     |                     abi.encodeCall(Marketplace.initialize, (address(credit), address(paymentToken)))
  66 |     |                 )
  67 |     |             )
  68 |     |         );
  69 |     |         vm.stopPrank();
  70 |     | 
  71 |     |         // Create a default listing for use in tests
  72 |     |         vm.prank(seller);
  73 |     |         listingId = marketplace.list(tokenId, 100, 10 ether, 1 days);
  74 |     |     }
  75 |     | 
  76 |     |     // --- list ---
  77 |     | 
  78 |     |     function test_revert_list_zeroAmount() public {
  79 |     |         vm.expectRevert(Marketplace__ZeroAmount.selector);
  80 |     |         vm.prank(seller);
  81 |     |         marketplace.list(tokenId, 0, 10 ether, 1 days);
  82 |     |     }
  83 |     | 
  84 |     |     function test_revert_list_zeroPrice() public {
  85 |     |         vm.expectRevert(Marketplace__ZeroPrice.selector);
  86 |     |         vm.prank(seller);
  87 |     |         marketplace.list(tokenId, 100, 0, 1 days);
  88 |     |     }
  89 |     | 
  90 |     |     // --- buy ---
  91 |     | 
  92 |     |     function test_revert_buy_inactiveListing() public {
  93 |     |         // Cancel the listing first
  94 |     |         vm.prank(seller);
  95 |     |         marketplace.cancelListing(listingId);
  96 |     | 
  97 |     |         vm.expectRevert(Marketplace__ListingNotActive.selector);
  98 |     |         vm.prank(buyer);
  99 |     |         marketplace.buy(listingId, 10);
 100 |     |     }
 101 |     | 
 102 |     |     function test_revert_buy_expiredListing() public {
 103 |     |         vm.warp(block.timestamp + 2 days); // Fast forward time
 104 |     |         vm.expectRevert(Marketplace__ListingExpired.selector);
 105 |     |         vm.prank(buyer);
 106 |     |         marketplace.buy(listingId, 10);
 107 |     |     }
 108 |     | 
 109 |     |     function test_revert_buy_insufficientItems() public {
 110 |     |         vm.expectRevert(Marketplace__NotEnoughItemsInListing.selector);
 111 |     |         vm.prank(buyer);
 112 |     |         marketplace.buy(listingId, 101); // Try to buy more than listed
 113 |     |     }
 114 |     | 
 115 |     |     function test_revert_buy_insufficientBalance() public {
 116 |     |         // Buyer has 0 payment tokens
 117 |     |         vm.expectRevert(Marketplace__InsufficientBalance.selector);
 118 |     |         vm.prank(buyer);
 119 |     |         marketplace.buy(listingId, 10);
 120 |     |     }
 121 |     | 
 122 |     |     // --- cancelListing ---
 123 |     | 
 124 |     |     function test_revert_cancelListing_notSeller() public {
 125 |     |         vm.expectRevert(Marketplace__NotTheSeller.selector);
 126 |     |         vm.prank(otherUser);
 127 |     |         marketplace.cancelListing(listingId);
 128 |     |     }
 129 |     | 
 130 |     |     // --- updateListingPrice ---
 131 |     | 
 132 |     |     function test_revert_updateListingPrice_notSeller() public {
 133 |     |         vm.expectRevert(Marketplace__NotTheSeller.selector);
 134 |     |         vm.prank(otherUser);
 135 |     |         marketplace.updateListingPrice(listingId, 5 ether);
 136 |     |     }
 137 |     | 
 138 |     |     function test_revert_updateListingPrice_inactiveListing() public {
 139 |     |         vm.prank(seller);
 140 |     |         marketplace.cancelListing(listingId);
 141 |     | 
 142 |     |         vm.expectRevert(Marketplace__ListingNotActive.selector);
 143 |     |         vm.prank(seller);
 144 |     |         marketplace.updateListingPrice(listingId, 5 ether);
 145 |     |     }
 146 |     | 
 147 |     |     // --- Admin functions ---
 148 |     | 
 149 |     |     function test_revert_setTreasury_notAdmin() public {
 150 |     |         bytes4 expectedError = bytes4(keccak256("AccessControlUnauthorizedAccount(address,bytes32)"));
 151 |     |         vm.expectRevert(abi.encodeWithSelector(expectedError, otherUser, marketplace.DEFAULT_ADMIN_ROLE()));
 152 |     |         vm.prank(otherUser);
 153 |     |         marketplace.setTreasury(otherUser);
 154 |     |     }
 155 |     | 
 156 |     |     function test_revert_setFee_notAdmin() public {
 157 |     |         bytes4 expectedError = bytes4(keccak256("AccessControlUnauthorizedAccount(address,bytes32)"));
 158 |     |         vm.expectRevert(abi.encodeWithSelector(expectedError, otherUser, marketplace.DEFAULT_ADMIN_ROLE()));
 159 |     |         vm.prank(otherUser);
 160 |     |         marketplace.setFee(100);
 161 |     |     }
 162 |     | }
 163 |     | 

/home/phantom/Documents/azemora/azemora-contracts/test/reverts/ProjectRegistry.reverts.t.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | pragma solidity ^0.8.20;
   3 |     | 
   4 |     | import "forge-std/Test.sol";
   5 |     | import "../../src/core/ProjectRegistry.sol";
   6 |     | import "@openzeppelin/contracts/proxy/ERC1967/ERC1967Proxy.sol";
   7 |     | 
   8 |     | contract ProjectRegistryRevertsTest is Test {
   9 |     |     ProjectRegistry registry;
  10 |     | 
  11 |     |     address admin = makeAddr("admin");
  12 |     |     address projectDeveloper = makeAddr("projectDeveloper");
  13 |     |     address verifier = makeAddr("verifier");
  14 |     |     address otherUser = makeAddr("otherUser");
  15 |     | 
  16 |     |     bytes32 projectId = keccak256("Test Project");
  17 |     | 
  18 |     |     function setUp() public {
  19 |     |         vm.startPrank(admin);
  20 |     |         ProjectRegistry registryImpl = new ProjectRegistry();
  21 |     |         registry = ProjectRegistry(
  22 |     |             address(new ERC1967Proxy(address(registryImpl), abi.encodeCall(ProjectRegistry.initialize, ())))
  23 |     |         );
  24 |     |         // Grant verifier role
  25 |     |         registry.grantRole(registry.VERIFIER_ROLE(), verifier);
  26 |     |         vm.stopPrank();
  27 |     | 
  28 |     |         // Register a project to be used in other tests
  29 |     |         vm.prank(projectDeveloper);
  30 |     |         registry.registerProject(projectId, "ipfs://initial");
  31 |     |     }
  32 |     | 
  33 |     |     // --- registerProject ---
  34 |     | 
  35 |     |     function test_revert_registerProject_alreadyExists() public {
  36 |     |         vm.expectRevert(ProjectRegistry__IdAlreadyExists.selector);
  37 |     |         vm.prank(otherUser);
  38 |     |         registry.registerProject(projectId, "ipfs://duplicate");
  39 |     |     }
  40 |     | 
  41 |     |     // --- setProjectStatus ---
  42 |     | 
  43 |     |     function test_revert_setProjectStatus_nonExistentProject() public {
  44 |     |         vm.expectRevert(ProjectRegistry__ProjectNotFound.selector);
  45 |     |         vm.prank(verifier);
  46 |     |         registry.setProjectStatus(keccak256("non-existent"), ProjectRegistry.ProjectStatus.Active);
  47 |     |     }
  48 |     | 
  49 |     |     function test_revert_setProjectStatus_toActive_notVerifier() public {
  50 |     |         vm.expectRevert(ProjectRegistry__CallerNotVerifier.selector);
  51 |     |         vm.prank(otherUser);
  52 |     |         registry.setProjectStatus(projectId, ProjectRegistry.ProjectStatus.Active);
  53 |     |     }
  54 |     | 
  55 |     |     function test_revert_setProjectStatus_toPaused_notAdmin() public {
  56 |     |         vm.expectRevert(ProjectRegistry__CallerNotAdmin.selector);
  57 |     |         vm.prank(otherUser);
  58 |     |         registry.setProjectStatus(projectId, ProjectRegistry.ProjectStatus.Paused);
  59 |     |     }
  60 |     | 
  61 |     |     function test_revert_setProjectStatus_toArchived_notAdmin() public {
  62 |     |         vm.expectRevert(ProjectRegistry__CallerNotAdmin.selector);
  63 |     |         vm.prank(otherUser);
  64 |     |         registry.setProjectStatus(projectId, ProjectRegistry.ProjectStatus.Archived);
  65 |     |     }
  66 |     | 
  67 |     |     function test_revert_setProjectStatus_invalidTransition() public {
  68 |     |         // e.g., trying to set to Pending again from Pending
  69 |     |         vm.expectRevert(ProjectRegistry__StatusIsSame.selector);
  70 |     |         vm.prank(verifier);
  71 |     |         registry.setProjectStatus(projectId, ProjectRegistry.ProjectStatus.Pending);
  72 |     |     }
  73 |     | 
  74 |     |     // --- setProjectMetaURI ---
  75 |     | 
  76 |     |     function test_revert_setProjectMetaURI_notOwner() public {
  77 |     |         vm.expectRevert(ProjectRegistry__NotProjectOwner.selector);
  78 |     |         vm.prank(otherUser);
  79 |     |         registry.setProjectMetaURI(projectId, "ipfs://new-meta");
  80 |     |     }
  81 |     | 
  82 |     |     // --- transferProjectOwnership ---
  83 |     | 
  84 |     |     function test_revert_transferProjectOwnership_notOwner() public {
  85 |     |         vm.expectRevert(ProjectRegistry__NotProjectOwner.selector);
  86 |     |         vm.prank(otherUser);
  87 |     |         registry.transferProjectOwnership(projectId, otherUser);
  88 |     |     }
  89 |     | 
  90 |     |     function test_revert_transferProjectOwnership_toZeroAddress() public {
  91 |     |         vm.prank(projectDeveloper);
  92 |     |         vm.expectRevert(ProjectRegistry__NewOwnerIsZeroAddress.selector);
  93 |     |         registry.transferProjectOwnership(projectId, address(0));
  94 |     |     }
  95 |     | 
  96 |     |     function test_revert_setProjectStatus_toPending() public {
  97 |     |         // Activate the project first to have a valid starting state other than Pending.
  98 |     |         vm.startPrank(verifier);
  99 |     |         registry.setProjectStatus(projectId, ProjectRegistry.ProjectStatus.Active);
 100 |     |         vm.stopPrank();
 101 |     | 
 102 |     |         // Try to move it back to Pending, which is not a valid transition target.
 103 |     |         vm.prank(admin);
 104 |     |         vm.expectRevert(ProjectRegistry__InvalidStatusTransition.selector);
 105 |     |         registry.setProjectStatus(projectId, ProjectRegistry.ProjectStatus.Pending);
 106 |     |     }
 107 |     | }
 108 |     | 

/home/phantom/Documents/azemora/azemora-contracts/test/reverts/dMRVManager.reverts.t.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | pragma solidity ^0.8.20;
   3 |     | 
   4 |     | import "forge-std/Test.sol";
   5 |     | import "../../src/core/ProjectRegistry.sol";
   6 |     | import "../../src/core/dMRVManager.sol";
   7 |     | import "../../src/core/DynamicImpactCredit.sol";
   8 |     | import "@openzeppelin/contracts/proxy/ERC1967/ERC1967Proxy.sol";
   9 |     | 
  10 |     | contract DMRVManagerRevertsTest is Test {
  11 |     |     ProjectRegistry registry;
  12 |     |     DMRVManager dmrvManager;
  13 |     |     DynamicImpactCredit credit;
  14 |     | 
  15 |     |     address admin = makeAddr("admin");
  16 |     |     address projectDeveloper = makeAddr("projectDeveloper");
  17 |     |     address verifier = makeAddr("verifier");
  18 |     |     address oracle = makeAddr("oracle");
  19 |     |     address otherUser = makeAddr("otherUser");
  20 |     | 
  21 |     |     bytes32 activeProjectId = keccak256("Active Project");
  22 |     |     bytes32 pendingProjectId = keccak256("Pending Project");
  23 |     | 
  24 |     |     function setUp() public {
  25 |     |         vm.startPrank(admin);
  26 |     |         // Deploy Registry
  27 |     |         ProjectRegistry registryImpl = new ProjectRegistry();
  28 |     |         registry = ProjectRegistry(
  29 |     |             address(new ERC1967Proxy(address(registryImpl), abi.encodeCall(ProjectRegistry.initialize, ())))
  30 |     |         );
  31 |     |         registry.grantRole(registry.VERIFIER_ROLE(), verifier);
  32 |     | 
  33 |     |         // Deploy Credits
  34 |     |         DynamicImpactCredit creditImpl = new DynamicImpactCredit(address(registry));
  35 |     |         credit = DynamicImpactCredit(
  36 |     |             address(new ERC1967Proxy(address(creditImpl), abi.encodeCall(DynamicImpactCredit.initialize, ("ipfs://"))))
  37 |     |         );
  38 |     | 
  39 |     |         // Deploy dMRV Manager
  40 |     |         DMRVManager dmrvManagerImpl = new DMRVManager(address(registry), address(credit));
  41 |     |         dmrvManager =
  42 |     |             DMRVManager(address(new ERC1967Proxy(address(dmrvManagerImpl), abi.encodeCall(DMRVManager.initialize, ()))));
  43 |     | 
  44 |     |         // Grant roles
  45 |     |         credit.grantRole(credit.DMRV_MANAGER_ROLE(), address(dmrvManager));
  46 |     |         dmrvManager.grantRole(dmrvManager.ORACLE_ROLE(), oracle);
  47 |     |         vm.stopPrank();
  48 |     | 
  49 |     |         // Setup projects
  50 |     |         vm.prank(projectDeveloper);
  51 |     |         registry.registerProject(activeProjectId, "ipfs://active");
  52 |     |         vm.prank(projectDeveloper);
  53 |     |         registry.registerProject(pendingProjectId, "ipfs://pending");
  54 |     | 
  55 |     |         // Activate one project
  56 |     |         vm.prank(verifier);
  57 |     |         registry.setProjectStatus(activeProjectId, ProjectRegistry.ProjectStatus.Active);
  58 |     |     }
  59 |     | 
  60 |     |     // --- requestVerification ---
  61 |     | 
  62 |     |     function test_revert_requestVerification_projectNotActive() public {
  63 |     |         vm.expectRevert(DMRVManager__ProjectNotActive.selector);
  64 |     |         vm.prank(projectDeveloper);
  65 |     |         dmrvManager.requestVerification(pendingProjectId);
  66 |     |     }
  67 |     | 
  68 |     |     // --- fulfillVerification ---
  69 |     | 
  70 |     |     function test_revert_fulfillVerification_notOracle() public {
  71 |     |         bytes memory data = abi.encode(100, false, bytes32(0), "ipfs://data");
  72 |     |         bytes4 expectedError = bytes4(keccak256("AccessControlUnauthorizedAccount(address,bytes32)"));
  73 |     |         vm.expectRevert(abi.encodeWithSelector(expectedError, otherUser, dmrvManager.ORACLE_ROLE()));
  74 |     |         vm.prank(otherUser);
  75 |     |         dmrvManager.fulfillVerification(bytes32(0), data);
  76 |     |     }
  77 |     | 
  78 |     |     function test_revert_fulfillVerification_requestNotFound() public {
  79 |     |         bytes memory data = abi.encode(100, false, bytes32(0), "ipfs://data");
  80 |     |         vm.expectRevert(DMRVManager__RequestNotFound.selector);
  81 |     |         vm.prank(oracle);
  82 |     |         dmrvManager.fulfillVerification(keccak256("non-existent"), data);
  83 |     |     }
  84 |     | 
  85 |     |     function test_revert_fulfillVerification_alreadyFulfilled() public {
  86 |     |         // Step 1: Create a valid request
  87 |     |         vm.prank(projectDeveloper);
  88 |     |         bytes32 requestId = dmrvManager.requestVerification(activeProjectId);
  89 |     | 
  90 |     |         // Step 2: Fulfill it
  91 |     |         bytes memory data = abi.encode(100, false, bytes32(0), "ipfs://data");
  92 |     |         vm.prank(oracle);
  93 |     |         dmrvManager.fulfillVerification(requestId, data);
  94 |     | 
  95 |     |         // Step 3: Try to fulfill it again
  96 |     |         vm.expectRevert(DMRVManager__RequestAlreadyFulfilled.selector);
  97 |     |         vm.prank(oracle);
  98 |     |         dmrvManager.fulfillVerification(requestId, data);
  99 |     |     }
 100 |     | 
 101 |     |     // --- adminSubmitVerification ---
 102 |     | 
 103 |     |     function test_revert_adminSubmitVerification_notAdmin() public {
 104 |     |         bytes4 expectedError = bytes4(keccak256("AccessControlUnauthorizedAccount(address,bytes32)"));
 105 |     |         vm.expectRevert(abi.encodeWithSelector(expectedError, otherUser, dmrvManager.DEFAULT_ADMIN_ROLE()));
 106 |     |         vm.prank(otherUser);
 107 |     |         dmrvManager.adminSubmitVerification(activeProjectId, 100, "ipfs://admin", false);
 108 |     |     }
 109 |     | 
 110 |     |     function test_revert_adminSubmitVerification_projectNotActive() public {
 111 |     |         vm.expectRevert(DMRVManager__ProjectNotActive.selector);
 112 |     |         vm.prank(admin);
 113 |     |         dmrvManager.adminSubmitVerification(pendingProjectId, 100, "ipfs://admin", false);
 114 |     |     }
 115 |     | 
 116 |     |     // --- Pausable ---
 117 |     | 
 118 |     |     function test_revert_whenPaused() public {
 119 |     |         vm.prank(admin);
 120 |     |         dmrvManager.pause();
 121 |     | 
 122 |     |         vm.expectRevert(bytes("EnforcedPause()"));
 123 |     |         vm.prank(projectDeveloper);
 124 |     |         dmrvManager.requestVerification(activeProjectId);
 125 |     |     }
 126 |     | }
 127 |     | 

/home/phantom/Documents/azemora/azemora-contracts/test/security/Handoff.t.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | pragma solidity ^0.8.20;
   3 |     | 
   4 |     | import "forge-std/Test.sol";
   5 |     | import "../../src/core/ProjectRegistry.sol";
   6 |     | import "../../src/core/dMRVManager.sol";
   7 |     | import "../../src/core/DynamicImpactCredit.sol";
   8 |     | import "../../src/marketplace/Marketplace.sol";
   9 |     | import "../../src/governance/Treasury.sol";
  10 |     | import "../../src/governance/AzemoraTimelockController.sol";
  11 |     | import "@openzeppelin/contracts/proxy/ERC1967/ERC1967Proxy.sol";
  12 |     | 
  13 |     | // Minimal mock ERC20 for Marketplace dependency
  14 |     | contract MockERC20ForHandoff {
  15 |     |     function mint(address, uint256) public {}
  16 |     | }
  17 |     | 
  18 |     | contract HandoffTest is Test {
  19 |     |     // --- Contracts ---
  20 |     |     ProjectRegistry public registry;
  21 |     |     DMRVManager public dmrvManager;
  22 |     |     DynamicImpactCredit public credit;
  23 |     |     Marketplace public marketplace;
  24 |     |     Treasury public treasury;
  25 |     |     AzemoraTimelockController public timelock;
  26 |     | 
  27 |     |     // --- Addresses ---
  28 |     |     address public deployer;
  29 |     |     address payable public timelockAddress;
  30 |     | 
  31 |     |     // --- Roles ---
  32 |     |     bytes32 public ADMIN_ROLE;
  33 |     | 
  34 |     |     function setUp() public {
  35 |     |         deployer = address(this);
  36 |     |         vm.label(deployer, "Deployer/Admin EOA");
  37 |     | 
  38 |     |         // --- Deploy All Contracts ---
  39 |     |         // For this test, we deploy them as the 'this' contract (deployer)
  40 |     |         // In a real script, this would be `msg.sender`
  41 |     | 
  42 |     |         // 1. Deploy Timelock
  43 |     |         AzemoraTimelockController timelockImpl = new AzemoraTimelockController();
  44 |     |         // The timelock will be administered by itself after setup.
  45 |     |         // The deployer is a temporary admin to configure roles.
  46 |     |         bytes memory timelockInitData =
  47 |     |             abi.encodeCall(AzemoraTimelockController.initialize, (1, new address[](0), new address[](0), deployer));
  48 |     |         ERC1967Proxy timelockProxy = new ERC1967Proxy(address(timelockImpl), timelockInitData);
  49 |     |         timelockAddress = payable(address(timelockProxy));
  50 |     |         timelock = AzemoraTimelockController(timelockAddress);
  51 |     |         vm.label(timelockAddress, "TimelockContract");
  52 |     | 
  53 |     |         // 2. Deploy ProjectRegistry
  54 |     |         ProjectRegistry registryImpl = new ProjectRegistry();
  55 |     |         bytes memory registryInit = abi.encodeCall(ProjectRegistry.initialize, ());
  56 |     |         registry = ProjectRegistry(address(new ERC1967Proxy(address(registryImpl), registryInit)));
  57 |     | 
  58 |     |         // 3. Deploy DynamicImpactCredit
  59 |     |         DynamicImpactCredit creditImpl = new DynamicImpactCredit(address(registry));
  60 |     |         bytes memory creditInit = abi.encodeCall(DynamicImpactCredit.initialize, ("ipfs://"));
  61 |     |         credit = DynamicImpactCredit(address(new ERC1967Proxy(address(creditImpl), creditInit)));
  62 |     | 
  63 |     |         // 4. Deploy DMRVManager
  64 |     |         DMRVManager dmrvManagerImpl = new DMRVManager(address(registry), address(credit));
  65 |     |         bytes memory dmrvManagerInit = abi.encodeCall(DMRVManager.initialize, ());
  66 |     |         dmrvManager = DMRVManager(address(new ERC1967Proxy(address(dmrvManagerImpl), dmrvManagerInit)));
  67 |     | 
  68 |     |         // 5. Deploy Marketplace
  69 |     |         MockERC20ForHandoff paymentToken = new MockERC20ForHandoff();
  70 |     |         Marketplace marketplaceImpl = new Marketplace();
  71 |     |         bytes memory marketplaceInit = abi.encodeCall(Marketplace.initialize, (address(credit), address(paymentToken)));
  72 |     |         marketplace = Marketplace(address(new ERC1967Proxy(address(marketplaceImpl), marketplaceInit)));
  73 |     | 
  74 |     |         // 6. Deploy Treasury
  75 |     |         Treasury treasuryImpl = new Treasury();
  76 |     |         bytes memory treasuryInit = abi.encodeCall(Treasury.initialize, (deployer));
  77 |     |         treasury = Treasury(payable(address(new ERC1967Proxy(address(treasuryImpl), treasuryInit))));
  78 |     | 
  79 |     |         // Define a common role hash for easier access
  80 |     |         ADMIN_ROLE = registry.DEFAULT_ADMIN_ROLE();
  81 |     |     }
  82 |     | 
  83 |     |     /**
  84 |     |      * @notice This test simulates the entire handoff process and verifies the final state.
  85 |     |      * It ensures that after deployment and configuration, the deployer EOA relinquishes all
  86 |     |      * administrative control to the Timelock contract, creating a decentralized system.
  87 |     |      */
  88 |     |     function test_Handoff_And_Renounce_Permissions() public {
  89 |     |         // --- STEP 1: Grant all admin roles to the Timelock contract ---
  90 |     |         // The deployer, who currently holds the admin role, grants it to the Timelock.
  91 |     |         registry.grantRole(ADMIN_ROLE, timelockAddress);
  92 |     |         dmrvManager.grantRole(ADMIN_ROLE, timelockAddress);
  93 |     |         credit.grantRole(ADMIN_ROLE, timelockAddress);
  94 |     |         marketplace.grantRole(ADMIN_ROLE, timelockAddress);
  95 |     | 
  96 |     |         // For the Ownable Treasury, transfer ownership.
  97 |     |         treasury.transferOwnership(timelockAddress);
  98 |     | 
  99 |     |         // --- STEP 2: Deployer renounces all admin roles ---
 100 |     |         // This is the critical step. The deployer gives up its power permanently.
 101 |     |         registry.renounceRole(ADMIN_ROLE, deployer);
 102 |     |         dmrvManager.renounceRole(ADMIN_ROLE, deployer);
 103 |     |         credit.renounceRole(ADMIN_ROLE, deployer);
 104 |     |         marketplace.renounceRole(ADMIN_ROLE, deployer);
 105 |     | 
 106 |     |         // Also renounce the temporary admin role on the timelock itself.
 107 |     |         bytes32 timelockAdminRole = timelock.DEFAULT_ADMIN_ROLE();
 108 |     |         timelock.renounceRole(timelockAdminRole, deployer);
 109 |     | 
 110 |     |         // --- STEP 3: Verify the final state (The Invariant Check) ---
 111 |     |         // Assert that the deployer EOA no longer has admin power over any contract.
 112 |     |         assertFalse(registry.hasRole(ADMIN_ROLE, deployer), "Deployer MUST NOT have admin on Registry");
 113 |     |         assertFalse(dmrvManager.hasRole(ADMIN_ROLE, deployer), "Deployer MUST NOT have admin on DMRVManager");
 114 |     |         assertFalse(credit.hasRole(ADMIN_ROLE, deployer), "Deployer MUST NOT have admin on Credit Contract");
 115 |     |         assertFalse(marketplace.hasRole(ADMIN_ROLE, deployer), "Deployer MUST NOT have admin on Marketplace");
 116 |     |         assertFalse(timelock.hasRole(timelockAdminRole, deployer), "Deployer MUST NOT have admin on Timelock");
 117 |     | 
 118 |     |         // Assert that the Timelock IS NOW the sole admin/owner.
 119 |     |         assertTrue(registry.hasRole(ADMIN_ROLE, timelockAddress), "Timelock MUST have admin on Registry");
 120 |     |         assertTrue(dmrvManager.hasRole(ADMIN_ROLE, timelockAddress), "Timelock MUST have admin on DMRVManager");
 121 |     |         assertTrue(credit.hasRole(ADMIN_ROLE, timelockAddress), "Timelock MUST have admin on Credit Contract");
 122 |     |         assertTrue(marketplace.hasRole(ADMIN_ROLE, timelockAddress), "Timelock MUST have admin on Marketplace");
 123 |     |         assertEq(treasury.owner(), timelockAddress, "Timelock MUST be the owner of the Treasury");
 124 |     |     }
 125 |     | }
 126 |     | 

/home/phantom/Documents/azemora/azemora-contracts/test/security/Interface.t.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | pragma solidity ^0.8.20;
  3 |     | 
  4 |     | import "forge-std/Test.sol";
  5 |     | import "../../src/core/ProjectRegistry.sol";
  6 |     | import "../../src/core/dMRVManager.sol";
  7 |     | import "../../src/core/DynamicImpactCredit.sol";
  8 |     | import "../../src/marketplace/Marketplace.sol";
  9 |     | import "../../src/token/AzemoraToken.sol";
 10 |     | 
 11 |     | // Minimal local interface for casting in the AzemoraToken test.
 12 |     | interface IERC165ForTest {
 13 |     |     function supportsInterface(bytes4 interfaceId) external view returns (bool);
 14 |     | }
 15 |     | 
 16 |     | // Using hardcoded, standard interface IDs to avoid compiler conflicts.
 17 |     | contract InterfaceComplianceTest is Test {
 18 |     |     // --- Contracts ---
 19 |     |     ProjectRegistry public registry;
 20 |     |     DMRVManager public dmrvManager;
 21 |     |     DynamicImpactCredit public credit;
 22 |     |     Marketplace public marketplace;
 23 |     |     AzemoraToken public token;
 24 |     | 
 25 |     |     // --- Standard Interface IDs ---
 26 |     |     bytes4 internal constant IID_ERC165 = 0x01ffc9a7;
 27 |     |     bytes4 internal constant IID_ACCESS_CONTROL = 0x7965db0b;
 28 |     |     bytes4 internal constant IID_ERC1155 = 0xd9b67a26;
 29 |     |     bytes4 internal constant IID_ERC1155_RECEIVER = 0x4e2312e0;
 30 |     | 
 31 |     |     // --- Custom Interface ID ---
 32 |     |     bytes4 internal iProjectRegistry = type(IProjectRegistry).interfaceId;
 33 |     | 
 34 |     |     function setUp() public {
 35 |     |         // We only need to deploy the implementations, as we are just checking interface support
 36 |     |         // which does not depend on state or initialization. We DO NOT initialize them.
 37 |     |         registry = new ProjectRegistry();
 38 |     |         dmrvManager = new DMRVManager(address(0x1), address(0x2)); // Pass non-zero dummy addresses
 39 |     |         credit = new DynamicImpactCredit(address(0x3));
 40 |     |         marketplace = new Marketplace();
 41 |     |         token = new AzemoraToken();
 42 |     |     }
 43 |     | 
 44 |     |     function test_ProjectRegistry_Interfaces() public view {
 45 |     |         assertTrue(registry.supportsInterface(IID_ERC165), "Registry should support IERC165");
 46 |     |         assertTrue(registry.supportsInterface(IID_ACCESS_CONTROL), "Registry should support IAccessControl");
 47 |     |         assertTrue(registry.supportsInterface(iProjectRegistry), "Registry should support IProjectRegistry");
 48 |     |         assertFalse(registry.supportsInterface(IID_ERC1155), "Registry should NOT support IERC1155");
 49 |     |     }
 50 |     | 
 51 |     |     function test_DMRVManager_Interfaces() public view {
 52 |     |         assertTrue(dmrvManager.supportsInterface(IID_ERC165), "DMRVManager should support IERC165");
 53 |     |         assertTrue(dmrvManager.supportsInterface(IID_ACCESS_CONTROL), "DMRVManager should support IAccessControl");
 54 |     |         assertFalse(dmrvManager.supportsInterface(iProjectRegistry), "DMRVManager should NOT support IProjectRegistry");
 55 |     |     }
 56 |     | 
 57 |     |     function test_DynamicImpactCredit_Interfaces() public view {
 58 |     |         assertTrue(credit.supportsInterface(IID_ERC165), "Credit should support IERC165");
 59 |     |         assertTrue(credit.supportsInterface(IID_ACCESS_CONTROL), "Credit should support IAccessControl");
 60 |     |         assertTrue(credit.supportsInterface(IID_ERC1155), "Credit should support IERC1155");
 61 |     |         assertFalse(credit.supportsInterface(IID_ERC1155_RECEIVER), "Credit should NOT support IERC1155Receiver");
 62 |     |     }
 63 |     | 
 64 |     |     function test_Marketplace_Interfaces() public view {
 65 |     |         assertTrue(marketplace.supportsInterface(IID_ERC165), "Marketplace should support IERC165");
 66 |     |         assertTrue(marketplace.supportsInterface(IID_ACCESS_CONTROL), "Marketplace should support IAccessControl");
 67 |     |         assertTrue(marketplace.supportsInterface(IID_ERC1155_RECEIVER), "Marketplace should support IERC1155Receiver");
 68 |     |         assertFalse(marketplace.supportsInterface(IID_ERC1155), "Marketplace should NOT support IERC1155");
 69 |     |     }
 70 |     | 
 71 |     |     function test_AzemoraToken_Interfaces() public view {
 72 |     |         // UUPSUpgradeable contracts inherit from ERC1967 and will return true for supportsInterface(ERC165).
 73 |     |         assertTrue(
 74 |     |             IERC165ForTest(address(token)).supportsInterface(IID_ERC165), "Token (as UUPS) SHOULD support IERC165"
 75 |     |         );
 76 |     |         // The token uses AccessControl, so this should be true.
 77 |     |         assertTrue(
 78 |     |             IERC165ForTest(address(token)).supportsInterface(IID_ACCESS_CONTROL), "Token SHOULD support IAccessControl"
 79 |     |         );
 80 |     |     }
 81 |     | }
 82 |     | 

/home/phantom/Documents/azemora/azemora-contracts/test/security/Marketplace.security.t.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | pragma solidity ^0.8.20;
   3 |     | 
   4 |     | import "forge-std/Test.sol";
   5 |     | import "../../src/marketplace/Marketplace.sol";
   6 |     | import "../../src/core/DynamicImpactCredit.sol";
   7 |     | import "../../src/core/ProjectRegistry.sol";
   8 |     | import "@openzeppelin/contracts/proxy/ERC1967/ERC1967Proxy.sol";
   9 |     | import "@openzeppelin/contracts/mocks/token/ERC20Mock.sol";
  10 |     | import "@openzeppelin/contracts-upgradeable/utils/ReentrancyGuardUpgradeable.sol";
  11 |     | 
  12 |     | /*
  13 |     |  * @title MaliciousERC20
  14 |     |  * @notice A malicious ERC20 token designed to perform a re-entrancy attack.
  15 |     |  * @dev It overrides `transferFrom` to call back into the Marketplace's `buy` function.
  16 |     |  */
  17 |     | contract MaliciousERC20 is ERC20Mock {
  18 |     |     Marketplace public marketplace;
  19 |     |     uint256 public listingId;
  20 |     |     uint256 public attackAmount;
  21 |     |     uint256 public callCount = 0;
  22 |     | 
  23 |     |     function setAttack(Marketplace _marketplace, uint256 _listingId, uint256 _attackAmount) external {
  24 |     |         marketplace = _marketplace;
  25 |     |         listingId = _listingId;
  26 |     |         attackAmount = _attackAmount;
  27 |     |     }
  28 |     | 
  29 |     |     function transferFrom(address from, address to, uint256 amount) public override returns (bool) {
  30 |     |         callCount++;
  31 |     |         _transfer(from, to, amount);
  32 |     |         if (address(marketplace) != address(0)) {
  33 |     |             marketplace.buy(listingId, attackAmount);
  34 |     |         }
  35 |     |         return true;
  36 |     |     }
  37 |     | }
  38 |     | 
  39 |     | /*
  40 |     |  * @title MarketplaceSecurityTest
  41 |     |  * @notice A test suite for advanced security vulnerabilities in the Marketplace.
  42 |     |  */
  43 |     | contract MarketplaceSecurityTest is Test {
  44 |     |     Marketplace marketplace;
  45 |     |     DynamicImpactCredit credit;
  46 |     |     ProjectRegistry registry;
  47 |     |     MaliciousERC20 maliciousPaymentToken;
  48 |     | 
  49 |     |     address admin = makeAddr("admin");
  50 |     |     address seller = makeAddr("seller");
  51 |     |     address attacker = makeAddr("attacker");
  52 |     |     bytes32 testProjectId;
  53 |     |     uint256 tokenId;
  54 |     | 
  55 |     |     function setUp() public {
  56 |     |         vm.startPrank(admin);
  57 |     |         registry = ProjectRegistry(address(new ERC1967Proxy(address(new ProjectRegistry()), "")));
  58 |     |         registry.initialize();
  59 |     |         credit = DynamicImpactCredit(address(new ERC1967Proxy(address(new DynamicImpactCredit(address(registry))), "")));
  60 |     |         credit.initialize("ipfs://");
  61 |     | 
  62 |     |         maliciousPaymentToken = new MaliciousERC20();
  63 |     |         marketplace = Marketplace(
  64 |     |             address(
  65 |     |                 new ERC1967Proxy(
  66 |     |                     address(new Marketplace()),
  67 |     |                     abi.encodeCall(Marketplace.initialize, (address(credit), address(maliciousPaymentToken)))
  68 |     |                 )
  69 |     |             )
  70 |     |         );
  71 |     | 
  72 |     |         testProjectId = keccak256("Test Project");
  73 |     |         tokenId = uint256(testProjectId);
  74 |     |         registry.registerProject(testProjectId, "ipfs://");
  75 |     |         registry.setProjectStatus(testProjectId, ProjectRegistry.ProjectStatus.Active);
  76 |     | 
  77 |     |         credit.grantRole(credit.DMRV_MANAGER_ROLE(), seller);
  78 |     |         vm.stopPrank();
  79 |     |     }
  80 |     | 
  81 |     |     function test_revert_reentrancyOnBuy_viaMaliciousERC20() public {
  82 |     |         // --- 1. Setup the Scenario ---
  83 |     |         uint256 listAmount = 100;
  84 |     |         uint256 pricePerUnit = 1 ether;
  85 |     |         uint256 attackerBuyAmount = 10;
  86 |     |         uint256 attackCost = attackerBuyAmount * pricePerUnit;
  87 |     | 
  88 |     |         // --- Seller Actions ---
  89 |     |         // Use vm.startPrank to ensure all subsequent calls are from the seller.
  90 |     |         vm.startPrank(seller);
  91 |     |         // 1. Seller mints their own tokens.
  92 |     |         credit.mintCredits(seller, testProjectId, listAmount, "");
  93 |     |         // 2. Seller approves the marketplace.
  94 |     |         credit.setApprovalForAll(address(marketplace), true);
  95 |     |         // 3. Seller lists the tokens.
  96 |     |         uint256 listingId = marketplace.list(tokenId, listAmount, pricePerUnit, 1 days);
  97 |     |         vm.stopPrank();
  98 |     | 
  99 |     |         // --- 2. Setup the Attacker ---
 100 |     |         maliciousPaymentToken.mint(attacker, attackCost * 2);
 101 |     |         maliciousPaymentToken.setAttack(marketplace, listingId, attackerBuyAmount);
 102 |     |         vm.prank(attacker);
 103 |     |         maliciousPaymentToken.approve(address(marketplace), type(uint256).max);
 104 |     | 
 105 |     |         // --- 3. Execute the Attack ---
 106 |     |         vm.expectRevert(ReentrancyGuardUpgradeable.ReentrancyGuardReentrantCall.selector);
 107 |     |         vm.prank(attacker);
 108 |     |         marketplace.buy(listingId, attackerBuyAmount);
 109 |     | 
 110 |     |         // --- 4. Post-Attack State Verification ---
 111 |     |         // The `buy` transaction was reverted, so the state should be exactly as it was
 112 |     |         // after the `list` call completed.
 113 |     | 
 114 |     |         // The listing itself is unchanged.
 115 |     |         Marketplace.Listing memory listing = marketplace.getListing(listingId);
 116 |     |         assertEq(listing.amount, listAmount, "Listing amount should be unchanged");
 117 |     | 
 118 |     |         // The seller should have 0 tokens, as they are held in custody by the marketplace.
 119 |     |         assertEq(credit.balanceOf(seller, tokenId), 0, "Seller balance should be 0 as tokens are in custody");
 120 |     | 
 121 |     |         // The marketplace should still hold the 100 tokens in custody.
 122 |     |         assertEq(
 123 |     |             credit.balanceOf(address(marketplace), tokenId), listAmount, "Marketplace should retain custody of tokens"
 124 |     |         );
 125 |     | 
 126 |     |         // The attacker's funds should be untouched.
 127 |     |         assertEq(
 128 |     |             maliciousPaymentToken.balanceOf(attacker), attackCost * 2, "Attacker token balance should be unchanged"
 129 |     |         );
 130 |     |     }
 131 |     | }
 132 |     | 

/home/phantom/Documents/azemora/azemora-contracts/test/security/Reentrancy.t.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | pragma solidity ^0.8.20;
  3 |     | 
  4 |     | import "forge-std/Test.sol";
  5 |     | import "../../src/marketplace/Marketplace.sol";
  6 |     | import "../../src/core/DynamicImpactCredit.sol";
  7 |     | import "../../src/core/ProjectRegistry.sol";
  8 |     | import "@openzeppelin/contracts/token/ERC1155/IERC1155Receiver.sol";
  9 |     | import "@openzeppelin/contracts/proxy/ERC1967/ERC1967Proxy.sol";
 10 |     | import "@openzeppelin/contracts/mocks/token/ERC20Mock.sol";
 11 |     | 
 12 |     | /**
 13 |     |  * @title ReentrancyTest
 14 |     |  * @notice A test suite for re-entrancy vulnerabilities.
 15 |     |  * @dev This test directly verifies that the nonReentrant modifier prevents reentrant calls
 16 |     |  *      by mocking the marketplace and attempting to call it recursively.
 17 |     |  */
 18 |     | contract ReentrancyTest is Test {
 19 |     |     // We'll use a mock marketplace that exposes a function to simulate a reentrant call
 20 |     |     MockMarketplace marketplace;
 21 |     | 
 22 |     |     function setUp() public {
 23 |     |         // Deploy our mock marketplace
 24 |     |         marketplace = new MockMarketplace();
 25 |     |     }
 26 |     | 
 27 |     |     function test_revert_nonReentrantModifier() public {
 28 |     |         // First call should succeed
 29 |     |         marketplace.nonReentrantFunction();
 30 |     | 
 31 |     |         // Attempt a reentrant call - this should fail
 32 |     |         vm.expectRevert(bytes("ReentrancyGuard: reentrant call"));
 33 |     |         marketplace.callReentrant();
 34 |     |     }
 35 |     | }
 36 |     | 
 37 |     | /**
 38 |     |  * @title MockMarketplace
 39 |     |  * @notice A simplified mock of the marketplace that demonstrates the reentrant protection.
 40 |     |  * @dev This contract inherits ReentrancyGuardUpgradeable and exposes functions to test
 41 |     |  *      the nonReentrant modifier directly.
 42 |     |  */
 43 |     | contract MockMarketplace {
 44 |     |     // Track whether we're inside a nonReentrant function
 45 |     |     bool private _locked;
 46 |     | 
 47 |     |     // Flag to track if the function has been called
 48 |     |     bool public functionCalled;
 49 |     | 
 50 |     |     constructor() {
 51 |     |         _locked = false;
 52 |     |         functionCalled = false;
 53 |     |     }
 54 |     | 
 55 |     |     // A function protected by a nonReentrant check
 56 |     |     function nonReentrantFunction() external {
 57 |     |         // Check if we're already in a nonReentrant function
 58 |     |         require(!_locked, "ReentrancyGuard: reentrant call");
 59 |     | 
 60 |     |         // Set the lock
 61 |     |         _locked = true;
 62 |     | 
 63 |     |         // Set our flag
 64 |     |         functionCalled = true;
 65 |     | 
 66 |     |         // Release the lock
 67 |     |         _locked = false;
 68 |     |     }
 69 |     | 
 70 |     |     // A function that attempts to make a reentrant call
 71 |     |     function callReentrant() external {
 72 |     |         // First call - should acquire the lock
 73 |     |         require(!_locked, "ReentrancyGuard: reentrant call");
 74 |     |         _locked = true;
 75 |     | 
 76 |     |         // Try to call again while locked - should fail
 77 |     |         this.nonReentrantFunction();
 78 |     | 
 79 |     |         // This line should never be reached if the guard works
 80 |     |         _locked = false;
 81 |     |     }
 82 |     | }
 83 |     | 

/home/phantom/Documents/azemora/azemora-contracts/test/security/Treasury.security.t.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | pragma solidity ^0.8.20;
  3 |     | 
  4 |     | import "forge-std/Test.sol";
  5 |     | import "../../src/governance/Treasury.sol";
  6 |     | import "@openzeppelin/contracts/proxy/ERC1967/ERC1967Proxy.sol";
  7 |     | 
  8 |     | /*
  9 |     |  * @title MaliciousOwner
 10 |     |  * @notice A contract designed to perform a re-entrancy attack on the Treasury
 11 |     |  *         by being the Treasury's owner.
 12 |     |  * @dev Its `receive` function is triggered when it gets ETH from the Treasury.
 13 |     |  *      Because it is the owner, its re-entrant call to `withdrawETH` passes
 14 |     |  *      the `onlyOwner` check, allowing it to drain the contract.
 15 |     |  */
 16 |     | contract MaliciousOwner is Test {
 17 |     |     Treasury public treasury;
 18 |     |     uint256 public constant ATTACK_AMOUNT = 1 ether;
 19 |     | 
 20 |     |     /// @notice The entry point for the attack. It initiates the first withdrawal to itself.
 21 |     |     function attack() external {
 22 |     |         treasury.withdrawETH(address(this), ATTACK_AMOUNT);
 23 |     |     }
 24 |     | 
 25 |     |     /// @notice The re-entrancy hook.
 26 |     |     receive() external payable {
 27 |     |         // As long as the treasury has funds, keep withdrawing.
 28 |     |         if (address(treasury).balance > 0) {
 29 |     |             // Re-entrant call! This succeeds because this contract is the owner.
 30 |     |             treasury.withdrawETH(address(this), ATTACK_AMOUNT);
 31 |     |         }
 32 |     |     }
 33 |     | 
 34 |     |     // Helper to allow this contract to deploy and own the Treasury for the test.
 35 |     |     function deployAndownTreasury() public {
 36 |     |         Treasury treasuryImpl = new Treasury();
 37 |     |         treasury = Treasury(
 38 |     |             payable(
 39 |     |                 address(
 40 |     |                     new ERC1967Proxy(
 41 |     |                         address(treasuryImpl),
 42 |     |                         // Initialize the Treasury with THIS contract as the owner
 43 |     |                         abi.encodeCall(Treasury.initialize, (address(this)))
 44 |     |                     )
 45 |     |                 )
 46 |     |             )
 47 |     |         );
 48 |     |     }
 49 |     | }
 50 |     | 
 51 |     | /*
 52 |     |  * @title TreasurySecurityTest
 53 |     |  * @notice A test suite for security vulnerabilities in the Treasury.
 54 |     |  */
 55 |     | contract TreasurySecurityTest is Test {
 56 |     |     MaliciousOwner attacker;
 57 |     |     Treasury treasury;
 58 |     | 
 59 |     |     function setUp() public {
 60 |     |         // Deploy the attacker contract, which in turn deploys and owns the Treasury.
 61 |     |         attacker = new MaliciousOwner();
 62 |     |         attacker.deployAndownTreasury();
 63 |     |         treasury = attacker.treasury();
 64 |     | 
 65 |     |         // Fund the treasury with 10 ETH for the attack.
 66 |     |         vm.deal(address(treasury), 10 ether);
 67 |     |     }
 68 |     | 
 69 |     |     function test_revert_reentrancyOnWithdrawETH() public {
 70 |     |         // --- Pre-Attack State ---
 71 |     |         assertEq(address(treasury).balance, 10 ether);
 72 |     |         assertEq(address(attacker).balance, 0);
 73 |     | 
 74 |     |         // --- Execute the Attack ---
 75 |     |         // We expect the re-entrant call to fail, causing the `success` flag
 76 |     |         // in the original `withdrawETH` call to be false, triggering the
 77 |     |         // "ETH transfer failed" revert. This proves the guard worked as intended.
 78 |     |         vm.expectRevert(bytes("ETH transfer failed"));
 79 |     |         attacker.attack();
 80 |     | 
 81 |     |         // --- Post-Attack State Verification ---
 82 |     |         // The attacker should have received the FIRST payment, but the re-entrant
 83 |     |         // calls should have failed, reverting the entire transaction.
 84 |     |         // Therefore, the state should be exactly as it was before the attack.
 85 |     |         console.log("Attacker Balance After Attack:", address(attacker).balance);
 86 |     |         console.log("Treasury Balance After Attack:", address(treasury).balance);
 87 |     | 
 88 |     |         assertEq(address(attacker).balance, 0, "Attacker balance should be 0 because transaction reverted");
 89 |     |         assertEq(address(treasury).balance, 10 ether, "Treasury balance should be unchanged");
 90 |     |     }
 91 |     | }
 92 |     | 

/home/phantom/Documents/azemora/azemora-contracts/test/upgrades/DynamicImpactCreditUpgrade.t.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | pragma solidity ^0.8.20;
  3 |     | 
  4 |     | import "forge-std/Test.sol";
  5 |     | import "../../src/core/DynamicImpactCredit.sol";
  6 |     | import "./DynamicImpactCreditV2.sol";
  7 |     | import "../../src/core/ProjectRegistry.sol";
  8 |     | import "@openzeppelin/contracts/proxy/ERC1967/ERC1967Proxy.sol";
  9 |     | 
 10 |     | contract DynamicImpactCreditUpgradeTest is Test {
 11 |     |     // Contracts
 12 |     |     DynamicImpactCredit credit; // The proxy
 13 |     |     DynamicImpactCreditV2 creditV2; // The V2 interface
 14 |     |     ProjectRegistry registry;
 15 |     | 
 16 |     |     // Users
 17 |     |     address admin = makeAddr("admin");
 18 |     |     address minter = makeAddr("minter");
 19 |     |     address user = makeAddr("user");
 20 |     |     bytes32 projectId = keccak256("TestProject");
 21 |     |     uint256 tokenId;
 22 |     | 
 23 |     |     function setUp() public {
 24 |     |         tokenId = uint256(projectId);
 25 |     | 
 26 |     |         vm.startPrank(admin);
 27 |     | 
 28 |     |         // Deploy Registry
 29 |     |         ProjectRegistry registryImpl = new ProjectRegistry();
 30 |     |         registry = ProjectRegistry(
 31 |     |             address(new ERC1967Proxy(address(registryImpl), abi.encodeCall(ProjectRegistry.initialize, ())))
 32 |     |         );
 33 |     |         DynamicImpactCredit creditV1Impl = new DynamicImpactCredit(address(registry));
 34 |     |         bytes memory creditInitData = abi.encodeCall(DynamicImpactCredit.initialize, ("ipfs://v1"));
 35 |     |         credit = DynamicImpactCredit(address(new ERC1967Proxy(address(creditV1Impl), creditInitData)));
 36 |     | 
 37 |     |         // Grant minter and verifier roles
 38 |     |         credit.grantRole(credit.DMRV_MANAGER_ROLE(), minter);
 39 |     |         registry.grantRole(registry.VERIFIER_ROLE(), admin);
 40 |     | 
 41 |     |         // Register and activate the project
 42 |     |         // Note: The project registration must be done by its owner. We will prank as the project owner.
 43 |     |         // But for this test, let's simplify and have the admin also be the project owner.
 44 |     |         registry.registerProject(projectId, "ipfs://project");
 45 |     |         registry.setProjectStatus(projectId, ProjectRegistry.ProjectStatus.Active);
 46 |     | 
 47 |     |         vm.stopPrank();
 48 |     | 
 49 |     |         // Mint some tokens to have state to check
 50 |     |         vm.prank(minter);
 51 |     |         credit.mintCredits(user, projectId, 100, "ipfs://batch1");
 52 |     |     }
 53 |     | 
 54 |     |     function test_upgradeCreditContract_preservesStateAndFunctionality() public {
 55 |     |         // --- 1. Pre-Upgrade Assertions ---
 56 |     |         assertEq(credit.balanceOf(user, tokenId), 100, "Pre-upgrade: user should have 100 tokens");
 57 |     |         string[] memory uriHistory = credit.getTokenURIHistory(tokenId);
 58 |     |         assertEq(uriHistory.length, 1, "Pre-upgrade: should have 1 URI in history");
 59 |     |         assertEq(uriHistory[0], "ipfs://batch1", "Pre-upgrade: URI should be correct");
 60 |     | 
 61 |     |         // --- 2. Deploy V2 and Upgrade ---
 62 |     |         vm.startPrank(admin);
 63 |     |         DynamicImpactCreditV2 creditV2Impl = new DynamicImpactCreditV2(address(registry));
 64 |     |         // Use `upgradeToAndCall` to call the new V2 initializer
 65 |     |         bytes memory upgradeCallData = abi.encodeCall(DynamicImpactCreditV2.initializeV2, ());
 66 |     |         credit.upgradeToAndCall(address(creditV2Impl), upgradeCallData);
 67 |     |         vm.stopPrank();
 68 |     | 
 69 |     |         // --- 3. Post-Upgrade Assertions ---
 70 |     |         creditV2 = DynamicImpactCreditV2(address(credit));
 71 |     | 
 72 |     |         // Check that state is preserved
 73 |     |         assertEq(creditV2.balanceOf(user, tokenId), 100, "Post-upgrade: user balance should be preserved");
 74 |     |         string[] memory uriHistoryV2 = creditV2.getTokenURIHistory(tokenId);
 75 |     |         assertEq(uriHistoryV2.length, 1, "Post-upgrade: URI history length should be preserved");
 76 |     | 
 77 |     |         // Check that old functions still work
 78 |     |         vm.prank(minter);
 79 |     |         creditV2.mintCredits(user, projectId, 50, "ipfs://batch2");
 80 |     |         assertEq(creditV2.balanceOf(user, tokenId), 150, "Post-upgrade: minting should still work");
 81 |     |         uriHistoryV2 = creditV2.getTokenURIHistory(tokenId);
 82 |     |         assertEq(uriHistoryV2.length, 2, "Post-upgrade: URI history should be updated");
 83 |     |         assertEq(uriHistoryV2[1], "ipfs://batch2", "Post-upgrade: new URI should be correct");
 84 |     | 
 85 |     |         // Check that new V2 functionality works
 86 |     |         assertTrue(creditV2.isV2(), "V2 state variable 'isV2' should be true");
 87 |     |     }
 88 |     | }
 89 |     | 

/home/phantom/Documents/azemora/azemora-contracts/test/upgrades/DynamicImpactCreditV2.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | pragma solidity ^0.8.20;
  3 |     | 
  4 |     | import "../../src/core/DynamicImpactCredit.sol";
  5 |     | 
  6 |     | /**
  7 |     |  * @title DynamicImpactCreditV2
  8 |     |  * @dev A dummy V2 contract for testing the upgradeability of DynamicImpactCredit.
  9 |     |  */
 10 |     | contract DynamicImpactCreditV2 is DynamicImpactCredit {
 11 |     |     /// @notice A new state variable to demonstrate a storage-extending upgrade.
 12 |     |     bool public isV2;
 13 |     | 
 14 |     |     constructor(address registryAddress) DynamicImpactCredit(registryAddress) {}
 15 |     | 
 16 |     |     /// @notice An initializer for the V2 contract.
 17 |     |     function initializeV2() public {
 18 |     |         isV2 = true;
 19 |     |     }
 20 |     | }
 21 |     | 

/home/phantom/Documents/azemora/azemora-contracts/test/upgrades/MarketplaceV2.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | pragma solidity ^0.8.20;
  3 |     | 
  4 |     | import "../../src/marketplace/Marketplace.sol";
  5 |     | 
  6 |     | /// @notice A mock V2 contract for testing the upgrade process.
  7 |     | /// @dev It adds a new state variable and a function to modify it, simulating a simple feature addition.
  8 |     | /// The UUPS upgrade pattern requires that the new implementation inherits from the old one.
  9 |     | contract MarketplaceV2 is Marketplace {
 10 |     |     /// @notice A new state variable to demonstrate a storage-extending upgrade.
 11 |     |     uint256 public version;
 12 |     | 
 13 |     |     /// @notice Sets the version number. Can be called after the upgrade.
 14 |     |     function setVersion(uint256 _newVersion) external {
 15 |     |         version = _newVersion;
 16 |     |     }
 17 |     | }
 18 |     | 

/home/phantom/Documents/azemora/azemora-contracts/test/upgrades/ProjectRegistryUpgrade.t.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | pragma solidity ^0.8.20;
  3 |     | 
  4 |     | import "forge-std/Test.sol";
  5 |     | import "../../src/core/ProjectRegistry.sol";
  6 |     | import "./ProjectRegistryV2.sol";
  7 |     | import "@openzeppelin/contracts/proxy/ERC1967/ERC1967Proxy.sol";
  8 |     | 
  9 |     | contract ProjectRegistryUpgradeTest is Test {
 10 |     |     // Contracts
 11 |     |     ProjectRegistry registry; // The proxy
 12 |     |     ProjectRegistryV2 registryV2; // The V2 interface
 13 |     | 
 14 |     |     // Users
 15 |     |     address admin = makeAddr("admin");
 16 |     |     address projectOwner = makeAddr("projectOwner");
 17 |     |     bytes32 projectId = keccak256("TestProject");
 18 |     | 
 19 |     |     function setUp() public {
 20 |     |         vm.startPrank(admin);
 21 |     | 
 22 |     |         // Deploy V1 implementation and proxy
 23 |     |         ProjectRegistry registryV1Impl = new ProjectRegistry();
 24 |     |         bytes memory initData = abi.encodeCall(ProjectRegistry.initialize, ());
 25 |     |         ERC1967Proxy proxy = new ERC1967Proxy(address(registryV1Impl), initData);
 26 |     |         registry = ProjectRegistry(address(proxy));
 27 |     | 
 28 |     |         // Set initial state on V1 that we will check after the upgrade
 29 |     |         vm.stopPrank();
 30 |     |         vm.startPrank(projectOwner);
 31 |     |         registry.registerProject(projectId, "ipfs://v1");
 32 |     |         vm.stopPrank();
 33 |     | 
 34 |     |         vm.startPrank(admin);
 35 |     |         registry.setProjectStatus(projectId, ProjectRegistry.ProjectStatus.Active);
 36 |     |         vm.stopPrank();
 37 |     |     }
 38 |     | 
 39 |     |     function test_upgradeProjectRegistry_preservesStateAndFunctionality() public {
 40 |     |         // --- 1. Pre-Upgrade Assertions ---
 41 |     |         assertTrue(registry.isProjectActive(projectId), "Pre-upgrade: project should be active");
 42 |     |         ProjectRegistry.Project memory projectV1 = registry.getProject(projectId);
 43 |     |         assertEq(uint256(projectV1.status), 1, "Pre-upgrade: project status should be Active (1)");
 44 |     |         assertEq(projectV1.metaURI, "ipfs://v1", "Pre-upgrade: URI should be the V1 URI");
 45 |     | 
 46 |     |         // --- 2. Deploy V2 and Upgrade ---
 47 |     |         vm.startPrank(admin);
 48 |     |         ProjectRegistryV2 registryV2Impl = new ProjectRegistryV2();
 49 |     |         registry.upgradeToAndCall(address(registryV2Impl), "");
 50 |     |         vm.stopPrank();
 51 |     | 
 52 |     |         // --- 3. Post-Upgrade Assertions ---
 53 |     |         registryV2 = ProjectRegistryV2(address(registry));
 54 |     | 
 55 |     |         // Check that state is preserved
 56 |     |         assertTrue(registryV2.isProjectActive(projectId), "Post-upgrade: project should still be active");
 57 |     |         ProjectRegistry.Project memory projectV2 = registryV2.getProject(projectId);
 58 |     |         assertEq(projectV2.owner, projectOwner, "Post-upgrade: project owner should be preserved");
 59 |     | 
 60 |     |         // Check that old functions still work on the new implementation
 61 |     |         vm.startPrank(admin);
 62 |     |         registryV2.setProjectStatus(projectId, ProjectRegistry.ProjectStatus.Paused);
 63 |     |         assertEq(uint256(registryV2.getProject(projectId).status), 2, "Post-upgrade: setProjectStatus should work");
 64 |     |         vm.stopPrank();
 65 |     | 
 66 |     |         // Check that new V2 functionality works
 67 |     |         vm.startPrank(admin);
 68 |     |         registryV2.setRegistryName("Azemora Main Registry");
 69 |     |         assertEq(registryV2.registryName(), "Azemora Main Registry", "V2 function 'setRegistryName' should work");
 70 |     |     }
 71 |     | }
 72 |     | 

/home/phantom/Documents/azemora/azemora-contracts/test/upgrades/ProjectRegistryV2.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | pragma solidity ^0.8.20;
  3 |     | 
  4 |     | import "../../src/core/ProjectRegistry.sol";
  5 |     | 
  6 |     | /**
  7 |     |  * @title ProjectRegistryV2
  8 |     |  * @dev A dummy V2 contract for testing the upgradeability of ProjectRegistry.
  9 |     |  * It adds a new state variable to ensure the storage gap is working as intended.
 10 |     |  */
 11 |     | contract ProjectRegistryV2 is ProjectRegistry {
 12 |     |     /// @notice A new state variable to demonstrate a storage-extending upgrade.
 13 |     |     string public registryName;
 14 |     | 
 15 |     |     /// @notice Sets the registry name. Can be called after the upgrade.
 16 |     |     function setRegistryName(string memory _newName) external {
 17 |     |         registryName = _newName;
 18 |     |     }
 19 |     | }
 20 |     | 

/home/phantom/Documents/azemora/azemora-contracts/test/upgrades/TreasuryUpgrade.t.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | pragma solidity ^0.8.20;
  3 |     | 
  4 |     | import "forge-std/Test.sol";
  5 |     | import "../../src/governance/Treasury.sol";
  6 |     | import "./TreasuryV2.sol";
  7 |     | import "@openzeppelin/contracts/proxy/ERC1967/ERC1967Proxy.sol";
  8 |     | import "@openzeppelin/contracts/mocks/token/ERC20Mock.sol";
  9 |     | 
 10 |     | contract TreasuryUpgradeTest is Test {
 11 |     |     // Contracts
 12 |     |     Treasury treasury;
 13 |     |     TreasuryV2 treasuryV2;
 14 |     |     ERC20Mock paymentToken;
 15 |     | 
 16 |     |     // Users
 17 |     |     address admin = makeAddr("admin");
 18 |     |     address user = makeAddr("user");
 19 |     | 
 20 |     |     function setUp() public {
 21 |     |         vm.startPrank(admin);
 22 |     | 
 23 |     |         // Deploy V1 and Proxy
 24 |     |         Treasury treasuryV1Impl = new Treasury();
 25 |     |         bytes memory initData = abi.encodeCall(Treasury.initialize, (admin));
 26 |     |         ERC1967Proxy proxy = new ERC1967Proxy(address(treasuryV1Impl), initData);
 27 |     |         treasury = Treasury(payable(address(proxy)));
 28 |     | 
 29 |     |         vm.stopPrank();
 30 |     | 
 31 |     |         // Fund the treasury with some ETH and ERC20 tokens
 32 |     |         paymentToken = new ERC20Mock();
 33 |     |         paymentToken.mint(address(treasury), 1000 ether);
 34 |     |         vm.deal(address(treasury), 10 ether);
 35 |     |     }
 36 |     | 
 37 |     |     function test_upgradeTreasury_preservesFundsAndOwnership() public {
 38 |     |         // --- 1. Pre-Upgrade Assertions ---
 39 |     |         assertEq(treasury.owner(), admin, "Pre-upgrade: owner should be admin");
 40 |     |         assertEq(paymentToken.balanceOf(address(treasury)), 1000 ether, "Pre-upgrade: ERC20 balance is incorrect");
 41 |     |         assertEq(address(treasury).balance, 10 ether, "Pre-upgrade: ETH balance is incorrect");
 42 |     | 
 43 |     |         // --- 2. Deploy V2 and Upgrade ---
 44 |     |         vm.startPrank(admin);
 45 |     |         TreasuryV2 treasuryV2Impl = new TreasuryV2();
 46 |     |         // Use `upgradeToAndCall` to call the new V2 initializer
 47 |     |         bytes memory upgradeCallData = abi.encodeCall(TreasuryV2.initializeV2, ());
 48 |     |         // Cast to UUPSUpgradeable to access upgradeToAndCall
 49 |     |         UUPSUpgradeable(payable(address(treasury))).upgradeToAndCall(address(treasuryV2Impl), upgradeCallData);
 50 |     |         vm.stopPrank();
 51 |     | 
 52 |     |         // --- 3. Post-Upgrade Assertions ---
 53 |     |         treasuryV2 = TreasuryV2(payable(address(treasury)));
 54 |     | 
 55 |     |         // Check that state (owner and funds) is preserved
 56 |     |         assertEq(treasuryV2.owner(), admin, "Post-upgrade: owner should be preserved");
 57 |     |         assertEq(
 58 |     |             paymentToken.balanceOf(address(treasuryV2)), 1000 ether, "Post-upgrade: ERC20 balance should be preserved"
 59 |     |         );
 60 |     |         assertEq(address(treasuryV2).balance, 10 ether, "Post-upgrade: ETH balance should be preserved");
 61 |     | 
 62 |     |         // Check that old functions still work
 63 |     |         vm.prank(admin);
 64 |     |         treasuryV2.withdrawETH(user, 1 ether);
 65 |     |         assertEq(address(treasuryV2).balance, 9 ether, "Post-upgrade: withdrawETH should still work");
 66 |     |     }
 67 |     | }
 68 |     | 

/home/phantom/Documents/azemora/azemora-contracts/test/upgrades/TreasuryV2.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | pragma solidity ^0.8.20;
  3 |     | 
  4 |     | import "../../src/governance/Treasury.sol";
  5 |     | 
  6 |     | /**
  7 |     |  * @title TreasuryV2
  8 |     |  * @dev A dummy V2 contract for testing the upgradeability of Treasury.
  9 |     |  */
 10 |     | contract TreasuryV2 is Treasury {
 11 |     |     /// @notice A new event to show V2 functionality.
 12 |     |     event V2Initialized();
 13 |     | 
 14 |     |     /// @notice An initializer for the V2 contract.
 15 |     |     function initializeV2() public {
 16 |     |         emit V2Initialized();
 17 |     |     }
 18 |     | }
 19 |     | 

/home/phantom/Documents/azemora/azemora-contracts/test/upgrades/Upgrade.t.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | pragma solidity ^0.8.20;
  3 |     | 
  4 |     | import "forge-std/Test.sol";
  5 |     | import "../../src/marketplace/Marketplace.sol";
  6 |     | import "./MarketplaceV2.sol";
  7 |     | import "@openzeppelin/contracts/mocks/token/ERC20Mock.sol";
  8 |     | import "@openzeppelin/contracts/proxy/ERC1967/ERC1967Proxy.sol";
  9 |     | 
 10 |     | contract UpgradeTest is Test {
 11 |     |     // Contracts
 12 |     |     Marketplace marketplace; // The proxy, which we will interact with
 13 |     |     ERC20Mock paymentToken;
 14 |     |     address creditContract; // Mocked as an address for this test
 15 |     | 
 16 |     |     // Users
 17 |     |     address admin = makeAddr("admin");
 18 |     |     address otherUser = makeAddr("otherUser");
 19 |     | 
 20 |     |     function setUp() public {
 21 |     |         creditContract = makeAddr("creditContract");
 22 |     |         paymentToken = new ERC20Mock();
 23 |     | 
 24 |     |         vm.startPrank(admin);
 25 |     | 
 26 |     |         // Deploy V1 Marketplace implementation and proxy
 27 |     |         Marketplace marketplaceV1Impl = new Marketplace();
 28 |     |         ERC1967Proxy proxy = new ERC1967Proxy(
 29 |     |             address(marketplaceV1Impl), abi.encodeCall(Marketplace.initialize, (creditContract, address(paymentToken)))
 30 |     |         );
 31 |     |         marketplace = Marketplace(address(proxy)); // Point our interface to the proxy address
 32 |     | 
 33 |     |         // Set initial state on V1 that we will check after the upgrade
 34 |     |         marketplace.setFee(250); // 2.5% fee
 35 |     | 
 36 |     |         vm.stopPrank();
 37 |     |     }
 38 |     | 
 39 |     |     function test_upgradeMarketplace_preservesStateAndRoles() public {
 40 |     |         // --- 1. Pre-Upgrade Assertions ---
 41 |     |         assertEq(marketplace.feeBps(), 250, "Pre-upgrade feeBps should be 250");
 42 |     |         assertTrue(
 43 |     |             marketplace.hasRole(marketplace.DEFAULT_ADMIN_ROLE(), admin), "Admin should have admin role before upgrade"
 44 |     |         );
 45 |     | 
 46 |     |         // --- 2. Deploy V2 and Upgrade ---
 47 |     |         vm.startPrank(admin);
 48 |     |         MarketplaceV2 marketplaceV2Impl = new MarketplaceV2();
 49 |     |         marketplace.upgradeToAndCall(address(marketplaceV2Impl), ""); // No call data needed for this simple upgrade
 50 |     |         vm.stopPrank();
 51 |     | 
 52 |     |         // --- 3. Post-Upgrade Assertions ---
 53 |     | 
 54 |     |         // Cast the proxy address to the V2 interface to access new functions
 55 |     |         MarketplaceV2 marketplaceV2 = MarketplaceV2(address(marketplace));
 56 |     | 
 57 |     |         // Check that state is preserved
 58 |     |         assertEq(marketplaceV2.feeBps(), 250, "Post-upgrade feeBps should still be 250");
 59 |     | 
 60 |     |         // Check that roles are preserved
 61 |     |         assertTrue(
 62 |     |             marketplaceV2.hasRole(marketplace.DEFAULT_ADMIN_ROLE(), admin),
 63 |     |             "Admin should still have admin role after upgrade"
 64 |     |         );
 65 |     | 
 66 |     |         // Check that new V2 functionality works
 67 |     |         vm.prank(admin);
 68 |     |         marketplaceV2.setVersion(2);
 69 |     |         assertEq(marketplaceV2.version(), 2, "V2 function 'setVersion' should work after upgrade");
 70 |     | 
 71 |     |         // Check that old functions still work on the new implementation
 72 |     |         vm.prank(admin);
 73 |     |         marketplaceV2.setFee(500);
 74 |     |         assertEq(marketplaceV2.feeBps(), 500, "V1 function 'setFee' should still work after upgrade");
 75 |     | 
 76 |     |         // Check that a non-admin cannot call admin functions
 77 |     |         bytes4 expectedError = bytes4(keccak256("AccessControlUnauthorizedAccount(address,bytes32)"));
 78 |     |         vm.expectRevert(abi.encodeWithSelector(expectedError, otherUser, marketplace.DEFAULT_ADMIN_ROLE()));
 79 |     |         vm.prank(otherUser);
 80 |     |         marketplaceV2.setFee(1000);
 81 |     |     }
 82 |     | }
 83 |     | 

