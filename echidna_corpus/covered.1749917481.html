<style> code { white-space: pre-wrap; display: block; background-color: #eee; }.executed { background-color: #afa; }.reverted { background-color: #ffa; }.unexecuted { background-color: #faa; }.neutral { background-color: #eee; }</style><b>/home/phantom/Documents/azemora/azemora-contracts/lib/forge-std/src/Base.sol</b>
<code>
  1 |     | <span class='unexecuted'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>pragma solidity &gt;=0.6.2 &lt;0.9.0;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>import {StdStorage} from &quot;./StdStorage.sol&quot;;</span>
  5 |     | <span class='neutral'>import {Vm, VmSafe} from &quot;./Vm.sol&quot;;</span>
  6 |     | <span class='neutral'></span>
  7 |     | <span class='neutral'>abstract contract CommonBase {</span>
  8 |     | <span class='neutral'>    /// @dev Cheat code address.</span>
  9 |     | <span class='neutral'>    /// Calculated as `address(uint160(uint256(keccak256(&quot;hevm cheat code&quot;))))`.</span>
 10 | *   | <span class='executed'>    address internal constant VM_ADDRESS = 0x7109709ECfa91a80626fF3989D68f67F5b1DD12D;</span>
 11 |     | <span class='neutral'>    /// @dev console.sol and console2.sol work by executing a staticcall to this address.</span>
 12 |     | <span class='neutral'>    /// Calculated as `address(uint160(uint88(bytes11(&quot;console.log&quot;))))`.</span>
 13 |     | <span class='neutral'>    address internal constant CONSOLE = 0x000000000000000000636F6e736F6c652e6c6f67;</span>
 14 |     | <span class='neutral'>    /// @dev Used when deploying with create2.</span>
 15 |     | <span class='neutral'>    /// Taken from https://github.com/Arachnid/deterministic-deployment-proxy.</span>
 16 |     | <span class='neutral'>    address internal constant CREATE2_FACTORY = 0x4e59b44847b379578588920cA78FbF26c0B4956C;</span>
 17 |     | <span class='neutral'>    /// @dev The default address for tx.origin and msg.sender.</span>
 18 |     | <span class='neutral'>    /// Calculated as `address(uint160(uint256(keccak256(&quot;foundry default caller&quot;))))`.</span>
 19 |     | <span class='neutral'>    address internal constant DEFAULT_SENDER = 0x1804c8AB1F12E6bbf3894d4083f33e07309d1f38;</span>
 20 |     | <span class='neutral'>    /// @dev The address of the first contract `CREATE`d by a running test contract.</span>
 21 |     | <span class='neutral'>    /// When running tests, each test contract is `CREATE`d by `DEFAULT_SENDER` with nonce 1.</span>
 22 |     | <span class='neutral'>    /// Calculated as `VM.computeCreateAddress(VM.computeCreateAddress(DEFAULT_SENDER, 1), 1)`.</span>
 23 |     | <span class='neutral'>    address internal constant DEFAULT_TEST_CONTRACT = 0x5615dEB798BB3E4dFa0139dFa1b3D433Cc23b72f;</span>
 24 |     | <span class='neutral'>    /// @dev Deterministic deployment address of the Multicall3 contract.</span>
 25 |     | <span class='neutral'>    /// Taken from https://www.multicall3.com.</span>
 26 |     | <span class='neutral'>    address internal constant MULTICALL3_ADDRESS = 0xcA11bde05977b3631167028862bE2a173976CA11;</span>
 27 |     | <span class='neutral'>    /// @dev The order of the secp256k1 curve.</span>
 28 |     | <span class='neutral'>    uint256 internal constant SECP256K1_ORDER =</span>
 29 |     | <span class='neutral'>        115792089237316195423570985008687907852837564279074904382605163141518161494337;</span>
 30 |     | <span class='neutral'></span>
 31 |     | <span class='neutral'>    uint256 internal constant UINT256_MAX =</span>
 32 |     | <span class='neutral'>        115792089237316195423570985008687907853269984665640564039457584007913129639935;</span>
 33 |     | <span class='neutral'></span>
 34 |     | <span class='neutral'>    Vm internal constant vm = Vm(VM_ADDRESS);</span>
 35 |     | <span class='neutral'>    StdStorage internal stdstore;</span>
 36 |     | <span class='neutral'>}</span>
 37 |     | <span class='neutral'></span>
 38 |     | <span class='neutral'>abstract contract TestBase is CommonBase {}</span>
 39 |     | <span class='neutral'></span>
 40 |     | <span class='neutral'>abstract contract ScriptBase is CommonBase {</span>
 41 |     | <span class='neutral'>    VmSafe internal constant vmSafe = VmSafe(VM_ADDRESS);</span>
 42 |     | <span class='neutral'>}</span>
 43 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/phantom/Documents/azemora/azemora-contracts/lib/forge-std/src/StdAssertions.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'>pragma solidity &gt;=0.6.2 &lt;0.9.0;</span>
   3 |     | <span class='neutral'>pragma experimental ABIEncoderV2;</span>
   4 |     | <span class='neutral'></span>
   5 |     | <span class='neutral'>import {Vm} from &quot;./Vm.sol&quot;;</span>
   6 |     | <span class='neutral'></span>
   7 |     | <span class='neutral'>abstract contract StdAssertions {</span>
   8 |     | <span class='neutral'>    Vm private constant vm = Vm(address(uint160(uint256(keccak256(&quot;hevm cheat code&quot;)))));</span>
   9 |     | <span class='neutral'></span>
  10 |     | <span class='neutral'>    event log(string);</span>
  11 |     | <span class='neutral'>    event logs(bytes);</span>
  12 |     | <span class='neutral'></span>
  13 |     | <span class='neutral'>    event log_address(address);</span>
  14 |     | <span class='neutral'>    event log_bytes32(bytes32);</span>
  15 |     | <span class='neutral'>    event log_int(int256);</span>
  16 |     | <span class='neutral'>    event log_uint(uint256);</span>
  17 |     | <span class='neutral'>    event log_bytes(bytes);</span>
  18 |     | <span class='neutral'>    event log_string(string);</span>
  19 |     | <span class='neutral'></span>
  20 |     | <span class='neutral'>    event log_named_address(string key, address val);</span>
  21 |     | <span class='neutral'>    event log_named_bytes32(string key, bytes32 val);</span>
  22 |     | <span class='neutral'>    event log_named_decimal_int(string key, int256 val, uint256 decimals);</span>
  23 |     | <span class='neutral'>    event log_named_decimal_uint(string key, uint256 val, uint256 decimals);</span>
  24 |     | <span class='neutral'>    event log_named_int(string key, int256 val);</span>
  25 |     | <span class='neutral'>    event log_named_uint(string key, uint256 val);</span>
  26 |     | <span class='neutral'>    event log_named_bytes(string key, bytes val);</span>
  27 |     | <span class='neutral'>    event log_named_string(string key, string val);</span>
  28 |     | <span class='neutral'></span>
  29 |     | <span class='neutral'>    event log_array(uint256[] val);</span>
  30 |     | <span class='neutral'>    event log_array(int256[] val);</span>
  31 |     | <span class='neutral'>    event log_array(address[] val);</span>
  32 |     | <span class='neutral'>    event log_named_array(string key, uint256[] val);</span>
  33 |     | <span class='neutral'>    event log_named_array(string key, int256[] val);</span>
  34 |     | <span class='neutral'>    event log_named_array(string key, address[] val);</span>
  35 |     | <span class='neutral'></span>
  36 |     | <span class='neutral'>    bool private _failed;</span>
  37 |     | <span class='neutral'></span>
  38 | *   | <span class='executed'>    function failed() public view returns (bool) {</span>
  39 | *   | <span class='executed'>        if (_failed) {</span>
  40 |     | <span class='unexecuted'>            return _failed;</span>
  41 |     | <span class='neutral'>        } else {</span>
  42 | *   | <span class='executed'>            return vm.load(address(vm), bytes32(&quot;failed&quot;)) != bytes32(0);</span>
  43 |     | <span class='neutral'>        }</span>
  44 |     | <span class='neutral'>    }</span>
  45 |     | <span class='neutral'></span>
  46 |     | <span class='unexecuted'>    function fail() internal virtual {</span>
  47 |     | <span class='unexecuted'>        vm.store(address(vm), bytes32(&quot;failed&quot;), bytes32(uint256(1)));</span>
  48 |     | <span class='unexecuted'>        _failed = true;</span>
  49 |     | <span class='neutral'>    }</span>
  50 |     | <span class='neutral'></span>
  51 |     | <span class='unexecuted'>    function assertTrue(bool data) internal pure virtual {</span>
  52 |     | <span class='unexecuted'>        vm.assertTrue(data);</span>
  53 |     | <span class='neutral'>    }</span>
  54 |     | <span class='neutral'></span>
  55 |     | <span class='unexecuted'>    function assertTrue(bool data, string memory err) internal pure virtual {</span>
  56 |     | <span class='unexecuted'>        vm.assertTrue(data, err);</span>
  57 |     | <span class='neutral'>    }</span>
  58 |     | <span class='neutral'></span>
  59 |     | <span class='unexecuted'>    function assertFalse(bool data) internal pure virtual {</span>
  60 |     | <span class='unexecuted'>        vm.assertFalse(data);</span>
  61 |     | <span class='neutral'>    }</span>
  62 |     | <span class='neutral'></span>
  63 |     | <span class='unexecuted'>    function assertFalse(bool data, string memory err) internal pure virtual {</span>
  64 |     | <span class='unexecuted'>        vm.assertFalse(data, err);</span>
  65 |     | <span class='neutral'>    }</span>
  66 |     | <span class='neutral'></span>
  67 |     | <span class='neutral'>    function assertEq(bool left, bool right) internal pure virtual {</span>
  68 |     | <span class='neutral'>        vm.assertEq(left, right);</span>
  69 |     | <span class='neutral'>    }</span>
  70 |     | <span class='neutral'></span>
  71 |     | <span class='neutral'>    function assertEq(bool left, bool right, string memory err) internal pure virtual {</span>
  72 |     | <span class='neutral'>        vm.assertEq(left, right, err);</span>
  73 |     | <span class='neutral'>    }</span>
  74 |     | <span class='neutral'></span>
  75 |     | <span class='unexecuted'>    function assertEq(uint256 left, uint256 right) internal pure virtual {</span>
  76 |     | <span class='unexecuted'>        vm.assertEq(left, right);</span>
  77 |     | <span class='neutral'>    }</span>
  78 |     | <span class='neutral'></span>
  79 |     | <span class='unexecuted'>    function assertEq(uint256 left, uint256 right, string memory err) internal pure virtual {</span>
  80 |     | <span class='unexecuted'>        vm.assertEq(left, right, err);</span>
  81 |     | <span class='neutral'>    }</span>
  82 |     | <span class='neutral'></span>
  83 |     | <span class='neutral'>    function assertEqDecimal(uint256 left, uint256 right, uint256 decimals) internal pure virtual {</span>
  84 |     | <span class='neutral'>        vm.assertEqDecimal(left, right, decimals);</span>
  85 |     | <span class='neutral'>    }</span>
  86 |     | <span class='neutral'></span>
  87 |     | <span class='neutral'>    function assertEqDecimal(uint256 left, uint256 right, uint256 decimals, string memory err) internal pure virtual {</span>
  88 |     | <span class='neutral'>        vm.assertEqDecimal(left, right, decimals, err);</span>
  89 |     | <span class='neutral'>    }</span>
  90 |     | <span class='neutral'></span>
  91 |     | <span class='neutral'>    function assertEq(int256 left, int256 right) internal pure virtual {</span>
  92 |     | <span class='neutral'>        vm.assertEq(left, right);</span>
  93 |     | <span class='neutral'>    }</span>
  94 |     | <span class='neutral'></span>
  95 |     | <span class='neutral'>    function assertEq(int256 left, int256 right, string memory err) internal pure virtual {</span>
  96 |     | <span class='neutral'>        vm.assertEq(left, right, err);</span>
  97 |     | <span class='neutral'>    }</span>
  98 |     | <span class='neutral'></span>
  99 |     | <span class='neutral'>    function assertEqDecimal(int256 left, int256 right, uint256 decimals) internal pure virtual {</span>
 100 |     | <span class='neutral'>        vm.assertEqDecimal(left, right, decimals);</span>
 101 |     | <span class='neutral'>    }</span>
 102 |     | <span class='neutral'></span>
 103 |     | <span class='neutral'>    function assertEqDecimal(int256 left, int256 right, uint256 decimals, string memory err) internal pure virtual {</span>
 104 |     | <span class='neutral'>        vm.assertEqDecimal(left, right, decimals, err);</span>
 105 |     | <span class='neutral'>    }</span>
 106 |     | <span class='neutral'></span>
 107 |     | <span class='unexecuted'>    function assertEq(address left, address right) internal pure virtual {</span>
 108 |     | <span class='unexecuted'>        vm.assertEq(left, right);</span>
 109 |     | <span class='neutral'>    }</span>
 110 |     | <span class='neutral'></span>
 111 |     | <span class='unexecuted'>    function assertEq(address left, address right, string memory err) internal pure virtual {</span>
 112 |     | <span class='unexecuted'>        vm.assertEq(left, right, err);</span>
 113 |     | <span class='neutral'>    }</span>
 114 |     | <span class='neutral'></span>
 115 |     | <span class='unexecuted'>    function assertEq(bytes32 left, bytes32 right) internal pure virtual {</span>
 116 |     | <span class='unexecuted'>        vm.assertEq(left, right);</span>
 117 |     | <span class='neutral'>    }</span>
 118 |     | <span class='neutral'></span>
 119 |     | <span class='neutral'>    function assertEq(bytes32 left, bytes32 right, string memory err) internal pure virtual {</span>
 120 |     | <span class='neutral'>        vm.assertEq(left, right, err);</span>
 121 |     | <span class='neutral'>    }</span>
 122 |     | <span class='neutral'></span>
 123 |     | <span class='neutral'>    function assertEq32(bytes32 left, bytes32 right) internal pure virtual {</span>
 124 |     | <span class='neutral'>        assertEq(left, right);</span>
 125 |     | <span class='neutral'>    }</span>
 126 |     | <span class='neutral'></span>
 127 |     | <span class='neutral'>    function assertEq32(bytes32 left, bytes32 right, string memory err) internal pure virtual {</span>
 128 |     | <span class='neutral'>        assertEq(left, right, err);</span>
 129 |     | <span class='neutral'>    }</span>
 130 |     | <span class='neutral'></span>
 131 |     | <span class='unexecuted'>    function assertEq(string memory left, string memory right) internal pure virtual {</span>
 132 |     | <span class='unexecuted'>        vm.assertEq(left, right);</span>
 133 |     | <span class='neutral'>    }</span>
 134 |     | <span class='neutral'></span>
 135 |     | <span class='unexecuted'>    function assertEq(string memory left, string memory right, string memory err) internal pure virtual {</span>
 136 |     | <span class='unexecuted'>        vm.assertEq(left, right, err);</span>
 137 |     | <span class='neutral'>    }</span>
 138 |     | <span class='neutral'></span>
 139 |     | <span class='neutral'>    function assertEq(bytes memory left, bytes memory right) internal pure virtual {</span>
 140 |     | <span class='neutral'>        vm.assertEq(left, right);</span>
 141 |     | <span class='neutral'>    }</span>
 142 |     | <span class='neutral'></span>
 143 |     | <span class='neutral'>    function assertEq(bytes memory left, bytes memory right, string memory err) internal pure virtual {</span>
 144 |     | <span class='neutral'>        vm.assertEq(left, right, err);</span>
 145 |     | <span class='neutral'>    }</span>
 146 |     | <span class='neutral'></span>
 147 |     | <span class='neutral'>    function assertEq(bool[] memory left, bool[] memory right) internal pure virtual {</span>
 148 |     | <span class='neutral'>        vm.assertEq(left, right);</span>
 149 |     | <span class='neutral'>    }</span>
 150 |     | <span class='neutral'></span>
 151 |     | <span class='neutral'>    function assertEq(bool[] memory left, bool[] memory right, string memory err) internal pure virtual {</span>
 152 |     | <span class='neutral'>        vm.assertEq(left, right, err);</span>
 153 |     | <span class='neutral'>    }</span>
 154 |     | <span class='neutral'></span>
 155 |     | <span class='neutral'>    function assertEq(uint256[] memory left, uint256[] memory right) internal pure virtual {</span>
 156 |     | <span class='neutral'>        vm.assertEq(left, right);</span>
 157 |     | <span class='neutral'>    }</span>
 158 |     | <span class='neutral'></span>
 159 |     | <span class='neutral'>    function assertEq(uint256[] memory left, uint256[] memory right, string memory err) internal pure virtual {</span>
 160 |     | <span class='neutral'>        vm.assertEq(left, right, err);</span>
 161 |     | <span class='neutral'>    }</span>
 162 |     | <span class='neutral'></span>
 163 |     | <span class='neutral'>    function assertEq(int256[] memory left, int256[] memory right) internal pure virtual {</span>
 164 |     | <span class='neutral'>        vm.assertEq(left, right);</span>
 165 |     | <span class='neutral'>    }</span>
 166 |     | <span class='neutral'></span>
 167 |     | <span class='neutral'>    function assertEq(int256[] memory left, int256[] memory right, string memory err) internal pure virtual {</span>
 168 |     | <span class='neutral'>        vm.assertEq(left, right, err);</span>
 169 |     | <span class='neutral'>    }</span>
 170 |     | <span class='neutral'></span>
 171 |     | <span class='neutral'>    function assertEq(address[] memory left, address[] memory right) internal pure virtual {</span>
 172 |     | <span class='neutral'>        vm.assertEq(left, right);</span>
 173 |     | <span class='neutral'>    }</span>
 174 |     | <span class='neutral'></span>
 175 |     | <span class='neutral'>    function assertEq(address[] memory left, address[] memory right, string memory err) internal pure virtual {</span>
 176 |     | <span class='neutral'>        vm.assertEq(left, right, err);</span>
 177 |     | <span class='neutral'>    }</span>
 178 |     | <span class='neutral'></span>
 179 |     | <span class='neutral'>    function assertEq(bytes32[] memory left, bytes32[] memory right) internal pure virtual {</span>
 180 |     | <span class='neutral'>        vm.assertEq(left, right);</span>
 181 |     | <span class='neutral'>    }</span>
 182 |     | <span class='neutral'></span>
 183 |     | <span class='neutral'>    function assertEq(bytes32[] memory left, bytes32[] memory right, string memory err) internal pure virtual {</span>
 184 |     | <span class='neutral'>        vm.assertEq(left, right, err);</span>
 185 |     | <span class='neutral'>    }</span>
 186 |     | <span class='neutral'></span>
 187 |     | <span class='neutral'>    function assertEq(string[] memory left, string[] memory right) internal pure virtual {</span>
 188 |     | <span class='neutral'>        vm.assertEq(left, right);</span>
 189 |     | <span class='neutral'>    }</span>
 190 |     | <span class='neutral'></span>
 191 |     | <span class='neutral'>    function assertEq(string[] memory left, string[] memory right, string memory err) internal pure virtual {</span>
 192 |     | <span class='neutral'>        vm.assertEq(left, right, err);</span>
 193 |     | <span class='neutral'>    }</span>
 194 |     | <span class='neutral'></span>
 195 |     | <span class='neutral'>    function assertEq(bytes[] memory left, bytes[] memory right) internal pure virtual {</span>
 196 |     | <span class='neutral'>        vm.assertEq(left, right);</span>
 197 |     | <span class='neutral'>    }</span>
 198 |     | <span class='neutral'></span>
 199 |     | <span class='neutral'>    function assertEq(bytes[] memory left, bytes[] memory right, string memory err) internal pure virtual {</span>
 200 |     | <span class='neutral'>        vm.assertEq(left, right, err);</span>
 201 |     | <span class='neutral'>    }</span>
 202 |     | <span class='neutral'></span>
 203 |     | <span class='neutral'>    // Legacy helper</span>
 204 |     | <span class='neutral'>    function assertEqUint(uint256 left, uint256 right) internal pure virtual {</span>
 205 |     | <span class='neutral'>        assertEq(left, right);</span>
 206 |     | <span class='neutral'>    }</span>
 207 |     | <span class='neutral'></span>
 208 |     | <span class='neutral'>    function assertNotEq(bool left, bool right) internal pure virtual {</span>
 209 |     | <span class='neutral'>        vm.assertNotEq(left, right);</span>
 210 |     | <span class='neutral'>    }</span>
 211 |     | <span class='neutral'></span>
 212 |     | <span class='neutral'>    function assertNotEq(bool left, bool right, string memory err) internal pure virtual {</span>
 213 |     | <span class='neutral'>        vm.assertNotEq(left, right, err);</span>
 214 |     | <span class='neutral'>    }</span>
 215 |     | <span class='neutral'></span>
 216 |     | <span class='neutral'>    function assertNotEq(uint256 left, uint256 right) internal pure virtual {</span>
 217 |     | <span class='neutral'>        vm.assertNotEq(left, right);</span>
 218 |     | <span class='neutral'>    }</span>
 219 |     | <span class='neutral'></span>
 220 |     | <span class='neutral'>    function assertNotEq(uint256 left, uint256 right, string memory err) internal pure virtual {</span>
 221 |     | <span class='neutral'>        vm.assertNotEq(left, right, err);</span>
 222 |     | <span class='neutral'>    }</span>
 223 |     | <span class='neutral'></span>
 224 |     | <span class='neutral'>    function assertNotEqDecimal(uint256 left, uint256 right, uint256 decimals) internal pure virtual {</span>
 225 |     | <span class='neutral'>        vm.assertNotEqDecimal(left, right, decimals);</span>
 226 |     | <span class='neutral'>    }</span>
 227 |     | <span class='neutral'></span>
 228 |     | <span class='neutral'>    function assertNotEqDecimal(uint256 left, uint256 right, uint256 decimals, string memory err)</span>
 229 |     | <span class='neutral'>        internal</span>
 230 |     | <span class='neutral'>        pure</span>
 231 |     | <span class='neutral'>        virtual</span>
 232 |     | <span class='neutral'>    {</span>
 233 |     | <span class='neutral'>        vm.assertNotEqDecimal(left, right, decimals, err);</span>
 234 |     | <span class='neutral'>    }</span>
 235 |     | <span class='neutral'></span>
 236 |     | <span class='neutral'>    function assertNotEq(int256 left, int256 right) internal pure virtual {</span>
 237 |     | <span class='neutral'>        vm.assertNotEq(left, right);</span>
 238 |     | <span class='neutral'>    }</span>
 239 |     | <span class='neutral'></span>
 240 |     | <span class='neutral'>    function assertNotEq(int256 left, int256 right, string memory err) internal pure virtual {</span>
 241 |     | <span class='neutral'>        vm.assertNotEq(left, right, err);</span>
 242 |     | <span class='neutral'>    }</span>
 243 |     | <span class='neutral'></span>
 244 |     | <span class='neutral'>    function assertNotEqDecimal(int256 left, int256 right, uint256 decimals) internal pure virtual {</span>
 245 |     | <span class='neutral'>        vm.assertNotEqDecimal(left, right, decimals);</span>
 246 |     | <span class='neutral'>    }</span>
 247 |     | <span class='neutral'></span>
 248 |     | <span class='neutral'>    function assertNotEqDecimal(int256 left, int256 right, uint256 decimals, string memory err) internal pure virtual {</span>
 249 |     | <span class='neutral'>        vm.assertNotEqDecimal(left, right, decimals, err);</span>
 250 |     | <span class='neutral'>    }</span>
 251 |     | <span class='neutral'></span>
 252 |     | <span class='neutral'>    function assertNotEq(address left, address right) internal pure virtual {</span>
 253 |     | <span class='neutral'>        vm.assertNotEq(left, right);</span>
 254 |     | <span class='neutral'>    }</span>
 255 |     | <span class='neutral'></span>
 256 |     | <span class='neutral'>    function assertNotEq(address left, address right, string memory err) internal pure virtual {</span>
 257 |     | <span class='neutral'>        vm.assertNotEq(left, right, err);</span>
 258 |     | <span class='neutral'>    }</span>
 259 |     | <span class='neutral'></span>
 260 |     | <span class='neutral'>    function assertNotEq(bytes32 left, bytes32 right) internal pure virtual {</span>
 261 |     | <span class='neutral'>        vm.assertNotEq(left, right);</span>
 262 |     | <span class='neutral'>    }</span>
 263 |     | <span class='neutral'></span>
 264 |     | <span class='neutral'>    function assertNotEq(bytes32 left, bytes32 right, string memory err) internal pure virtual {</span>
 265 |     | <span class='neutral'>        vm.assertNotEq(left, right, err);</span>
 266 |     | <span class='neutral'>    }</span>
 267 |     | <span class='neutral'></span>
 268 |     | <span class='neutral'>    function assertNotEq32(bytes32 left, bytes32 right) internal pure virtual {</span>
 269 |     | <span class='neutral'>        assertNotEq(left, right);</span>
 270 |     | <span class='neutral'>    }</span>
 271 |     | <span class='neutral'></span>
 272 |     | <span class='neutral'>    function assertNotEq32(bytes32 left, bytes32 right, string memory err) internal pure virtual {</span>
 273 |     | <span class='neutral'>        assertNotEq(left, right, err);</span>
 274 |     | <span class='neutral'>    }</span>
 275 |     | <span class='neutral'></span>
 276 |     | <span class='neutral'>    function assertNotEq(string memory left, string memory right) internal pure virtual {</span>
 277 |     | <span class='neutral'>        vm.assertNotEq(left, right);</span>
 278 |     | <span class='neutral'>    }</span>
 279 |     | <span class='neutral'></span>
 280 |     | <span class='neutral'>    function assertNotEq(string memory left, string memory right, string memory err) internal pure virtual {</span>
 281 |     | <span class='neutral'>        vm.assertNotEq(left, right, err);</span>
 282 |     | <span class='neutral'>    }</span>
 283 |     | <span class='neutral'></span>
 284 |     | <span class='neutral'>    function assertNotEq(bytes memory left, bytes memory right) internal pure virtual {</span>
 285 |     | <span class='neutral'>        vm.assertNotEq(left, right);</span>
 286 |     | <span class='neutral'>    }</span>
 287 |     | <span class='neutral'></span>
 288 |     | <span class='neutral'>    function assertNotEq(bytes memory left, bytes memory right, string memory err) internal pure virtual {</span>
 289 |     | <span class='neutral'>        vm.assertNotEq(left, right, err);</span>
 290 |     | <span class='neutral'>    }</span>
 291 |     | <span class='neutral'></span>
 292 |     | <span class='neutral'>    function assertNotEq(bool[] memory left, bool[] memory right) internal pure virtual {</span>
 293 |     | <span class='neutral'>        vm.assertNotEq(left, right);</span>
 294 |     | <span class='neutral'>    }</span>
 295 |     | <span class='neutral'></span>
 296 |     | <span class='neutral'>    function assertNotEq(bool[] memory left, bool[] memory right, string memory err) internal pure virtual {</span>
 297 |     | <span class='neutral'>        vm.assertNotEq(left, right, err);</span>
 298 |     | <span class='neutral'>    }</span>
 299 |     | <span class='neutral'></span>
 300 |     | <span class='neutral'>    function assertNotEq(uint256[] memory left, uint256[] memory right) internal pure virtual {</span>
 301 |     | <span class='neutral'>        vm.assertNotEq(left, right);</span>
 302 |     | <span class='neutral'>    }</span>
 303 |     | <span class='neutral'></span>
 304 |     | <span class='neutral'>    function assertNotEq(uint256[] memory left, uint256[] memory right, string memory err) internal pure virtual {</span>
 305 |     | <span class='neutral'>        vm.assertNotEq(left, right, err);</span>
 306 |     | <span class='neutral'>    }</span>
 307 |     | <span class='neutral'></span>
 308 |     | <span class='neutral'>    function assertNotEq(int256[] memory left, int256[] memory right) internal pure virtual {</span>
 309 |     | <span class='neutral'>        vm.assertNotEq(left, right);</span>
 310 |     | <span class='neutral'>    }</span>
 311 |     | <span class='neutral'></span>
 312 |     | <span class='neutral'>    function assertNotEq(int256[] memory left, int256[] memory right, string memory err) internal pure virtual {</span>
 313 |     | <span class='neutral'>        vm.assertNotEq(left, right, err);</span>
 314 |     | <span class='neutral'>    }</span>
 315 |     | <span class='neutral'></span>
 316 |     | <span class='neutral'>    function assertNotEq(address[] memory left, address[] memory right) internal pure virtual {</span>
 317 |     | <span class='neutral'>        vm.assertNotEq(left, right);</span>
 318 |     | <span class='neutral'>    }</span>
 319 |     | <span class='neutral'></span>
 320 |     | <span class='neutral'>    function assertNotEq(address[] memory left, address[] memory right, string memory err) internal pure virtual {</span>
 321 |     | <span class='neutral'>        vm.assertNotEq(left, right, err);</span>
 322 |     | <span class='neutral'>    }</span>
 323 |     | <span class='neutral'></span>
 324 |     | <span class='neutral'>    function assertNotEq(bytes32[] memory left, bytes32[] memory right) internal pure virtual {</span>
 325 |     | <span class='neutral'>        vm.assertNotEq(left, right);</span>
 326 |     | <span class='neutral'>    }</span>
 327 |     | <span class='neutral'></span>
 328 |     | <span class='neutral'>    function assertNotEq(bytes32[] memory left, bytes32[] memory right, string memory err) internal pure virtual {</span>
 329 |     | <span class='neutral'>        vm.assertNotEq(left, right, err);</span>
 330 |     | <span class='neutral'>    }</span>
 331 |     | <span class='neutral'></span>
 332 |     | <span class='neutral'>    function assertNotEq(string[] memory left, string[] memory right) internal pure virtual {</span>
 333 |     | <span class='neutral'>        vm.assertNotEq(left, right);</span>
 334 |     | <span class='neutral'>    }</span>
 335 |     | <span class='neutral'></span>
 336 |     | <span class='neutral'>    function assertNotEq(string[] memory left, string[] memory right, string memory err) internal pure virtual {</span>
 337 |     | <span class='neutral'>        vm.assertNotEq(left, right, err);</span>
 338 |     | <span class='neutral'>    }</span>
 339 |     | <span class='neutral'></span>
 340 |     | <span class='neutral'>    function assertNotEq(bytes[] memory left, bytes[] memory right) internal pure virtual {</span>
 341 |     | <span class='neutral'>        vm.assertNotEq(left, right);</span>
 342 |     | <span class='neutral'>    }</span>
 343 |     | <span class='neutral'></span>
 344 |     | <span class='neutral'>    function assertNotEq(bytes[] memory left, bytes[] memory right, string memory err) internal pure virtual {</span>
 345 |     | <span class='neutral'>        vm.assertNotEq(left, right, err);</span>
 346 |     | <span class='neutral'>    }</span>
 347 |     | <span class='neutral'></span>
 348 |     | <span class='neutral'>    function assertLt(uint256 left, uint256 right) internal pure virtual {</span>
 349 |     | <span class='neutral'>        vm.assertLt(left, right);</span>
 350 |     | <span class='neutral'>    }</span>
 351 |     | <span class='neutral'></span>
 352 |     | <span class='unexecuted'>    function assertLt(uint256 left, uint256 right, string memory err) internal pure virtual {</span>
 353 |     | <span class='unexecuted'>        vm.assertLt(left, right, err);</span>
 354 |     | <span class='neutral'>    }</span>
 355 |     | <span class='neutral'></span>
 356 |     | <span class='neutral'>    function assertLtDecimal(uint256 left, uint256 right, uint256 decimals) internal pure virtual {</span>
 357 |     | <span class='neutral'>        vm.assertLtDecimal(left, right, decimals);</span>
 358 |     | <span class='neutral'>    }</span>
 359 |     | <span class='neutral'></span>
 360 |     | <span class='neutral'>    function assertLtDecimal(uint256 left, uint256 right, uint256 decimals, string memory err) internal pure virtual {</span>
 361 |     | <span class='neutral'>        vm.assertLtDecimal(left, right, decimals, err);</span>
 362 |     | <span class='neutral'>    }</span>
 363 |     | <span class='neutral'></span>
 364 |     | <span class='neutral'>    function assertLt(int256 left, int256 right) internal pure virtual {</span>
 365 |     | <span class='neutral'>        vm.assertLt(left, right);</span>
 366 |     | <span class='neutral'>    }</span>
 367 |     | <span class='neutral'></span>
 368 |     | <span class='neutral'>    function assertLt(int256 left, int256 right, string memory err) internal pure virtual {</span>
 369 |     | <span class='neutral'>        vm.assertLt(left, right, err);</span>
 370 |     | <span class='neutral'>    }</span>
 371 |     | <span class='neutral'></span>
 372 |     | <span class='neutral'>    function assertLtDecimal(int256 left, int256 right, uint256 decimals) internal pure virtual {</span>
 373 |     | <span class='neutral'>        vm.assertLtDecimal(left, right, decimals);</span>
 374 |     | <span class='neutral'>    }</span>
 375 |     | <span class='neutral'></span>
 376 |     | <span class='neutral'>    function assertLtDecimal(int256 left, int256 right, uint256 decimals, string memory err) internal pure virtual {</span>
 377 |     | <span class='neutral'>        vm.assertLtDecimal(left, right, decimals, err);</span>
 378 |     | <span class='neutral'>    }</span>
 379 |     | <span class='neutral'></span>
 380 |     | <span class='neutral'>    function assertGt(uint256 left, uint256 right) internal pure virtual {</span>
 381 |     | <span class='neutral'>        vm.assertGt(left, right);</span>
 382 |     | <span class='neutral'>    }</span>
 383 |     | <span class='neutral'></span>
 384 |     | <span class='neutral'>    function assertGt(uint256 left, uint256 right, string memory err) internal pure virtual {</span>
 385 |     | <span class='neutral'>        vm.assertGt(left, right, err);</span>
 386 |     | <span class='neutral'>    }</span>
 387 |     | <span class='neutral'></span>
 388 |     | <span class='neutral'>    function assertGtDecimal(uint256 left, uint256 right, uint256 decimals) internal pure virtual {</span>
 389 |     | <span class='neutral'>        vm.assertGtDecimal(left, right, decimals);</span>
 390 |     | <span class='neutral'>    }</span>
 391 |     | <span class='neutral'></span>
 392 |     | <span class='neutral'>    function assertGtDecimal(uint256 left, uint256 right, uint256 decimals, string memory err) internal pure virtual {</span>
 393 |     | <span class='neutral'>        vm.assertGtDecimal(left, right, decimals, err);</span>
 394 |     | <span class='neutral'>    }</span>
 395 |     | <span class='neutral'></span>
 396 |     | <span class='neutral'>    function assertGt(int256 left, int256 right) internal pure virtual {</span>
 397 |     | <span class='neutral'>        vm.assertGt(left, right);</span>
 398 |     | <span class='neutral'>    }</span>
 399 |     | <span class='neutral'></span>
 400 |     | <span class='neutral'>    function assertGt(int256 left, int256 right, string memory err) internal pure virtual {</span>
 401 |     | <span class='neutral'>        vm.assertGt(left, right, err);</span>
 402 |     | <span class='neutral'>    }</span>
 403 |     | <span class='neutral'></span>
 404 |     | <span class='neutral'>    function assertGtDecimal(int256 left, int256 right, uint256 decimals) internal pure virtual {</span>
 405 |     | <span class='neutral'>        vm.assertGtDecimal(left, right, decimals);</span>
 406 |     | <span class='neutral'>    }</span>
 407 |     | <span class='neutral'></span>
 408 |     | <span class='neutral'>    function assertGtDecimal(int256 left, int256 right, uint256 decimals, string memory err) internal pure virtual {</span>
 409 |     | <span class='neutral'>        vm.assertGtDecimal(left, right, decimals, err);</span>
 410 |     | <span class='neutral'>    }</span>
 411 |     | <span class='neutral'></span>
 412 |     | <span class='neutral'>    function assertLe(uint256 left, uint256 right) internal pure virtual {</span>
 413 |     | <span class='neutral'>        vm.assertLe(left, right);</span>
 414 |     | <span class='neutral'>    }</span>
 415 |     | <span class='neutral'></span>
 416 |     | <span class='neutral'>    function assertLe(uint256 left, uint256 right, string memory err) internal pure virtual {</span>
 417 |     | <span class='neutral'>        vm.assertLe(left, right, err);</span>
 418 |     | <span class='neutral'>    }</span>
 419 |     | <span class='neutral'></span>
 420 |     | <span class='neutral'>    function assertLeDecimal(uint256 left, uint256 right, uint256 decimals) internal pure virtual {</span>
 421 |     | <span class='neutral'>        vm.assertLeDecimal(left, right, decimals);</span>
 422 |     | <span class='neutral'>    }</span>
 423 |     | <span class='neutral'></span>
 424 |     | <span class='neutral'>    function assertLeDecimal(uint256 left, uint256 right, uint256 decimals, string memory err) internal pure virtual {</span>
 425 |     | <span class='neutral'>        vm.assertLeDecimal(left, right, decimals, err);</span>
 426 |     | <span class='neutral'>    }</span>
 427 |     | <span class='neutral'></span>
 428 |     | <span class='neutral'>    function assertLe(int256 left, int256 right) internal pure virtual {</span>
 429 |     | <span class='neutral'>        vm.assertLe(left, right);</span>
 430 |     | <span class='neutral'>    }</span>
 431 |     | <span class='neutral'></span>
 432 |     | <span class='neutral'>    function assertLe(int256 left, int256 right, string memory err) internal pure virtual {</span>
 433 |     | <span class='neutral'>        vm.assertLe(left, right, err);</span>
 434 |     | <span class='neutral'>    }</span>
 435 |     | <span class='neutral'></span>
 436 |     | <span class='neutral'>    function assertLeDecimal(int256 left, int256 right, uint256 decimals) internal pure virtual {</span>
 437 |     | <span class='neutral'>        vm.assertLeDecimal(left, right, decimals);</span>
 438 |     | <span class='neutral'>    }</span>
 439 |     | <span class='neutral'></span>
 440 |     | <span class='neutral'>    function assertLeDecimal(int256 left, int256 right, uint256 decimals, string memory err) internal pure virtual {</span>
 441 |     | <span class='neutral'>        vm.assertLeDecimal(left, right, decimals, err);</span>
 442 |     | <span class='neutral'>    }</span>
 443 |     | <span class='neutral'></span>
 444 |     | <span class='neutral'>    function assertGe(uint256 left, uint256 right) internal pure virtual {</span>
 445 |     | <span class='neutral'>        vm.assertGe(left, right);</span>
 446 |     | <span class='neutral'>    }</span>
 447 |     | <span class='neutral'></span>
 448 |     | <span class='neutral'>    function assertGe(uint256 left, uint256 right, string memory err) internal pure virtual {</span>
 449 |     | <span class='neutral'>        vm.assertGe(left, right, err);</span>
 450 |     | <span class='neutral'>    }</span>
 451 |     | <span class='neutral'></span>
 452 |     | <span class='neutral'>    function assertGeDecimal(uint256 left, uint256 right, uint256 decimals) internal pure virtual {</span>
 453 |     | <span class='neutral'>        vm.assertGeDecimal(left, right, decimals);</span>
 454 |     | <span class='neutral'>    }</span>
 455 |     | <span class='neutral'></span>
 456 |     | <span class='neutral'>    function assertGeDecimal(uint256 left, uint256 right, uint256 decimals, string memory err) internal pure virtual {</span>
 457 |     | <span class='neutral'>        vm.assertGeDecimal(left, right, decimals, err);</span>
 458 |     | <span class='neutral'>    }</span>
 459 |     | <span class='neutral'></span>
 460 |     | <span class='neutral'>    function assertGe(int256 left, int256 right) internal pure virtual {</span>
 461 |     | <span class='neutral'>        vm.assertGe(left, right);</span>
 462 |     | <span class='neutral'>    }</span>
 463 |     | <span class='neutral'></span>
 464 |     | <span class='neutral'>    function assertGe(int256 left, int256 right, string memory err) internal pure virtual {</span>
 465 |     | <span class='neutral'>        vm.assertGe(left, right, err);</span>
 466 |     | <span class='neutral'>    }</span>
 467 |     | <span class='neutral'></span>
 468 |     | <span class='neutral'>    function assertGeDecimal(int256 left, int256 right, uint256 decimals) internal pure virtual {</span>
 469 |     | <span class='neutral'>        vm.assertGeDecimal(left, right, decimals);</span>
 470 |     | <span class='neutral'>    }</span>
 471 |     | <span class='neutral'></span>
 472 |     | <span class='neutral'>    function assertGeDecimal(int256 left, int256 right, uint256 decimals, string memory err) internal pure virtual {</span>
 473 |     | <span class='neutral'>        vm.assertGeDecimal(left, right, decimals, err);</span>
 474 |     | <span class='neutral'>    }</span>
 475 |     | <span class='neutral'></span>
 476 |     | <span class='neutral'>    function assertApproxEqAbs(uint256 left, uint256 right, uint256 maxDelta) internal pure virtual {</span>
 477 |     | <span class='neutral'>        vm.assertApproxEqAbs(left, right, maxDelta);</span>
 478 |     | <span class='neutral'>    }</span>
 479 |     | <span class='neutral'></span>
 480 |     | <span class='neutral'>    function assertApproxEqAbs(uint256 left, uint256 right, uint256 maxDelta, string memory err)</span>
 481 |     | <span class='neutral'>        internal</span>
 482 |     | <span class='neutral'>        pure</span>
 483 |     | <span class='neutral'>        virtual</span>
 484 |     | <span class='neutral'>    {</span>
 485 |     | <span class='neutral'>        vm.assertApproxEqAbs(left, right, maxDelta, err);</span>
 486 |     | <span class='neutral'>    }</span>
 487 |     | <span class='neutral'></span>
 488 |     | <span class='neutral'>    function assertApproxEqAbsDecimal(uint256 left, uint256 right, uint256 maxDelta, uint256 decimals)</span>
 489 |     | <span class='neutral'>        internal</span>
 490 |     | <span class='neutral'>        pure</span>
 491 |     | <span class='neutral'>        virtual</span>
 492 |     | <span class='neutral'>    {</span>
 493 |     | <span class='neutral'>        vm.assertApproxEqAbsDecimal(left, right, maxDelta, decimals);</span>
 494 |     | <span class='neutral'>    }</span>
 495 |     | <span class='neutral'></span>
 496 |     | <span class='neutral'>    function assertApproxEqAbsDecimal(</span>
 497 |     | <span class='neutral'>        uint256 left,</span>
 498 |     | <span class='neutral'>        uint256 right,</span>
 499 |     | <span class='neutral'>        uint256 maxDelta,</span>
 500 |     | <span class='neutral'>        uint256 decimals,</span>
 501 |     | <span class='neutral'>        string memory err</span>
 502 |     | <span class='neutral'>    ) internal pure virtual {</span>
 503 |     | <span class='neutral'>        vm.assertApproxEqAbsDecimal(left, right, maxDelta, decimals, err);</span>
 504 |     | <span class='neutral'>    }</span>
 505 |     | <span class='neutral'></span>
 506 |     | <span class='neutral'>    function assertApproxEqAbs(int256 left, int256 right, uint256 maxDelta) internal pure virtual {</span>
 507 |     | <span class='neutral'>        vm.assertApproxEqAbs(left, right, maxDelta);</span>
 508 |     | <span class='neutral'>    }</span>
 509 |     | <span class='neutral'></span>
 510 |     | <span class='neutral'>    function assertApproxEqAbs(int256 left, int256 right, uint256 maxDelta, string memory err) internal pure virtual {</span>
 511 |     | <span class='neutral'>        vm.assertApproxEqAbs(left, right, maxDelta, err);</span>
 512 |     | <span class='neutral'>    }</span>
 513 |     | <span class='neutral'></span>
 514 |     | <span class='neutral'>    function assertApproxEqAbsDecimal(int256 left, int256 right, uint256 maxDelta, uint256 decimals)</span>
 515 |     | <span class='neutral'>        internal</span>
 516 |     | <span class='neutral'>        pure</span>
 517 |     | <span class='neutral'>        virtual</span>
 518 |     | <span class='neutral'>    {</span>
 519 |     | <span class='neutral'>        vm.assertApproxEqAbsDecimal(left, right, maxDelta, decimals);</span>
 520 |     | <span class='neutral'>    }</span>
 521 |     | <span class='neutral'></span>
 522 |     | <span class='neutral'>    function assertApproxEqAbsDecimal(int256 left, int256 right, uint256 maxDelta, uint256 decimals, string memory err)</span>
 523 |     | <span class='neutral'>        internal</span>
 524 |     | <span class='neutral'>        pure</span>
 525 |     | <span class='neutral'>        virtual</span>
 526 |     | <span class='neutral'>    {</span>
 527 |     | <span class='neutral'>        vm.assertApproxEqAbsDecimal(left, right, maxDelta, decimals, err);</span>
 528 |     | <span class='neutral'>    }</span>
 529 |     | <span class='neutral'></span>
 530 |     | <span class='neutral'>    function assertApproxEqRel(</span>
 531 |     | <span class='neutral'>        uint256 left,</span>
 532 |     | <span class='neutral'>        uint256 right,</span>
 533 |     | <span class='neutral'>        uint256 maxPercentDelta // An 18 decimal fixed point number, where 1e18 == 100%</span>
 534 |     | <span class='neutral'>    ) internal pure virtual {</span>
 535 |     | <span class='neutral'>        vm.assertApproxEqRel(left, right, maxPercentDelta);</span>
 536 |     | <span class='neutral'>    }</span>
 537 |     | <span class='neutral'></span>
 538 |     | <span class='neutral'>    function assertApproxEqRel(</span>
 539 |     | <span class='neutral'>        uint256 left,</span>
 540 |     | <span class='neutral'>        uint256 right,</span>
 541 |     | <span class='neutral'>        uint256 maxPercentDelta, // An 18 decimal fixed point number, where 1e18 == 100%</span>
 542 |     | <span class='neutral'>        string memory err</span>
 543 |     | <span class='neutral'>    ) internal pure virtual {</span>
 544 |     | <span class='neutral'>        vm.assertApproxEqRel(left, right, maxPercentDelta, err);</span>
 545 |     | <span class='neutral'>    }</span>
 546 |     | <span class='neutral'></span>
 547 |     | <span class='neutral'>    function assertApproxEqRelDecimal(</span>
 548 |     | <span class='neutral'>        uint256 left,</span>
 549 |     | <span class='neutral'>        uint256 right,</span>
 550 |     | <span class='neutral'>        uint256 maxPercentDelta, // An 18 decimal fixed point number, where 1e18 == 100%</span>
 551 |     | <span class='neutral'>        uint256 decimals</span>
 552 |     | <span class='neutral'>    ) internal pure virtual {</span>
 553 |     | <span class='neutral'>        vm.assertApproxEqRelDecimal(left, right, maxPercentDelta, decimals);</span>
 554 |     | <span class='neutral'>    }</span>
 555 |     | <span class='neutral'></span>
 556 |     | <span class='neutral'>    function assertApproxEqRelDecimal(</span>
 557 |     | <span class='neutral'>        uint256 left,</span>
 558 |     | <span class='neutral'>        uint256 right,</span>
 559 |     | <span class='neutral'>        uint256 maxPercentDelta, // An 18 decimal fixed point number, where 1e18 == 100%</span>
 560 |     | <span class='neutral'>        uint256 decimals,</span>
 561 |     | <span class='neutral'>        string memory err</span>
 562 |     | <span class='neutral'>    ) internal pure virtual {</span>
 563 |     | <span class='neutral'>        vm.assertApproxEqRelDecimal(left, right, maxPercentDelta, decimals, err);</span>
 564 |     | <span class='neutral'>    }</span>
 565 |     | <span class='neutral'></span>
 566 |     | <span class='neutral'>    function assertApproxEqRel(int256 left, int256 right, uint256 maxPercentDelta) internal pure virtual {</span>
 567 |     | <span class='neutral'>        vm.assertApproxEqRel(left, right, maxPercentDelta);</span>
 568 |     | <span class='neutral'>    }</span>
 569 |     | <span class='neutral'></span>
 570 |     | <span class='neutral'>    function assertApproxEqRel(</span>
 571 |     | <span class='neutral'>        int256 left,</span>
 572 |     | <span class='neutral'>        int256 right,</span>
 573 |     | <span class='neutral'>        uint256 maxPercentDelta, // An 18 decimal fixed point number, where 1e18 == 100%</span>
 574 |     | <span class='neutral'>        string memory err</span>
 575 |     | <span class='neutral'>    ) internal pure virtual {</span>
 576 |     | <span class='neutral'>        vm.assertApproxEqRel(left, right, maxPercentDelta, err);</span>
 577 |     | <span class='neutral'>    }</span>
 578 |     | <span class='neutral'></span>
 579 |     | <span class='neutral'>    function assertApproxEqRelDecimal(</span>
 580 |     | <span class='neutral'>        int256 left,</span>
 581 |     | <span class='neutral'>        int256 right,</span>
 582 |     | <span class='neutral'>        uint256 maxPercentDelta, // An 18 decimal fixed point number, where 1e18 == 100%</span>
 583 |     | <span class='neutral'>        uint256 decimals</span>
 584 |     | <span class='neutral'>    ) internal pure virtual {</span>
 585 |     | <span class='neutral'>        vm.assertApproxEqRelDecimal(left, right, maxPercentDelta, decimals);</span>
 586 |     | <span class='neutral'>    }</span>
 587 |     | <span class='neutral'></span>
 588 |     | <span class='neutral'>    function assertApproxEqRelDecimal(</span>
 589 |     | <span class='neutral'>        int256 left,</span>
 590 |     | <span class='neutral'>        int256 right,</span>
 591 |     | <span class='neutral'>        uint256 maxPercentDelta, // An 18 decimal fixed point number, where 1e18 == 100%</span>
 592 |     | <span class='neutral'>        uint256 decimals,</span>
 593 |     | <span class='neutral'>        string memory err</span>
 594 |     | <span class='neutral'>    ) internal pure virtual {</span>
 595 |     | <span class='neutral'>        vm.assertApproxEqRelDecimal(left, right, maxPercentDelta, decimals, err);</span>
 596 |     | <span class='neutral'>    }</span>
 597 |     | <span class='neutral'></span>
 598 |     | <span class='neutral'>    // Inherited from DSTest, not used but kept for backwards-compatibility</span>
 599 |     | <span class='neutral'>    function checkEq0(bytes memory left, bytes memory right) internal pure returns (bool) {</span>
 600 |     | <span class='neutral'>        return keccak256(left) == keccak256(right);</span>
 601 |     | <span class='neutral'>    }</span>
 602 |     | <span class='neutral'></span>
 603 |     | <span class='neutral'>    function assertEq0(bytes memory left, bytes memory right) internal pure virtual {</span>
 604 |     | <span class='neutral'>        assertEq(left, right);</span>
 605 |     | <span class='neutral'>    }</span>
 606 |     | <span class='neutral'></span>
 607 |     | <span class='neutral'>    function assertEq0(bytes memory left, bytes memory right, string memory err) internal pure virtual {</span>
 608 |     | <span class='neutral'>        assertEq(left, right, err);</span>
 609 |     | <span class='neutral'>    }</span>
 610 |     | <span class='neutral'></span>
 611 |     | <span class='neutral'>    function assertNotEq0(bytes memory left, bytes memory right) internal pure virtual {</span>
 612 |     | <span class='neutral'>        assertNotEq(left, right);</span>
 613 |     | <span class='neutral'>    }</span>
 614 |     | <span class='neutral'></span>
 615 |     | <span class='neutral'>    function assertNotEq0(bytes memory left, bytes memory right, string memory err) internal pure virtual {</span>
 616 |     | <span class='neutral'>        assertNotEq(left, right, err);</span>
 617 |     | <span class='neutral'>    }</span>
 618 |     | <span class='neutral'></span>
 619 |     | <span class='neutral'>    function assertEqCall(address target, bytes memory callDataA, bytes memory callDataB) internal virtual {</span>
 620 |     | <span class='neutral'>        assertEqCall(target, callDataA, target, callDataB, true);</span>
 621 |     | <span class='neutral'>    }</span>
 622 |     | <span class='neutral'></span>
 623 |     | <span class='neutral'>    function assertEqCall(address targetA, bytes memory callDataA, address targetB, bytes memory callDataB)</span>
 624 |     | <span class='neutral'>        internal</span>
 625 |     | <span class='neutral'>        virtual</span>
 626 |     | <span class='neutral'>    {</span>
 627 |     | <span class='neutral'>        assertEqCall(targetA, callDataA, targetB, callDataB, true);</span>
 628 |     | <span class='neutral'>    }</span>
 629 |     | <span class='neutral'></span>
 630 |     | <span class='neutral'>    function assertEqCall(address target, bytes memory callDataA, bytes memory callDataB, bool strictRevertData)</span>
 631 |     | <span class='neutral'>        internal</span>
 632 |     | <span class='neutral'>        virtual</span>
 633 |     | <span class='neutral'>    {</span>
 634 |     | <span class='neutral'>        assertEqCall(target, callDataA, target, callDataB, strictRevertData);</span>
 635 |     | <span class='neutral'>    }</span>
 636 |     | <span class='neutral'></span>
 637 |     | <span class='neutral'>    function assertEqCall(</span>
 638 |     | <span class='neutral'>        address targetA,</span>
 639 |     | <span class='neutral'>        bytes memory callDataA,</span>
 640 |     | <span class='neutral'>        address targetB,</span>
 641 |     | <span class='neutral'>        bytes memory callDataB,</span>
 642 |     | <span class='neutral'>        bool strictRevertData</span>
 643 |     | <span class='neutral'>    ) internal virtual {</span>
 644 |     | <span class='neutral'>        (bool successA, bytes memory returnDataA) = address(targetA).call(callDataA);</span>
 645 |     | <span class='neutral'>        (bool successB, bytes memory returnDataB) = address(targetB).call(callDataB);</span>
 646 |     | <span class='neutral'></span>
 647 |     | <span class='neutral'>        if (successA &amp;&amp; successB) {</span>
 648 |     | <span class='neutral'>            assertEq(returnDataA, returnDataB, &quot;Call return data does not match&quot;);</span>
 649 |     | <span class='neutral'>        }</span>
 650 |     | <span class='neutral'></span>
 651 |     | <span class='neutral'>        if (!successA &amp;&amp; !successB &amp;&amp; strictRevertData) {</span>
 652 |     | <span class='neutral'>            assertEq(returnDataA, returnDataB, &quot;Call revert data does not match&quot;);</span>
 653 |     | <span class='neutral'>        }</span>
 654 |     | <span class='neutral'></span>
 655 |     | <span class='neutral'>        if (!successA &amp;&amp; successB) {</span>
 656 |     | <span class='neutral'>            emit log(&quot;Error: Calls were not equal&quot;);</span>
 657 |     | <span class='neutral'>            emit log_named_bytes(&quot;  Left call revert data&quot;, returnDataA);</span>
 658 |     | <span class='neutral'>            emit log_named_bytes(&quot; Right call return data&quot;, returnDataB);</span>
 659 |     | <span class='neutral'>            revert(&quot;assertion failed&quot;);</span>
 660 |     | <span class='neutral'>        }</span>
 661 |     | <span class='neutral'></span>
 662 |     | <span class='neutral'>        if (successA &amp;&amp; !successB) {</span>
 663 |     | <span class='neutral'>            emit log(&quot;Error: Calls were not equal&quot;);</span>
 664 |     | <span class='neutral'>            emit log_named_bytes(&quot;  Left call return data&quot;, returnDataA);</span>
 665 |     | <span class='neutral'>            emit log_named_bytes(&quot; Right call revert data&quot;, returnDataB);</span>
 666 |     | <span class='neutral'>            revert(&quot;assertion failed&quot;);</span>
 667 |     | <span class='neutral'>        }</span>
 668 |     | <span class='neutral'>    }</span>
 669 |     | <span class='neutral'>}</span>
 670 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/phantom/Documents/azemora/azemora-contracts/lib/forge-std/src/StdChains.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'>pragma solidity &gt;=0.6.2 &lt;0.9.0;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>import {VmSafe} from &quot;./Vm.sol&quot;;</span>
   5 |     | <span class='neutral'></span>
   6 |     | <span class='neutral'>/**</span>
   7 |     | <span class='neutral'> * StdChains provides information about EVM compatible chains that can be used in scripts/tests.</span>
   8 |     | <span class='neutral'> * For each chain, the chain&#39;s name, chain ID, and a default RPC URL are provided. Chains are</span>
   9 |     | <span class='neutral'> * identified by their alias, which is the same as the alias in the `[rpc_endpoints]` section of</span>
  10 |     | <span class='neutral'> * the `foundry.toml` file. For best UX, ensure the alias in the `foundry.toml` file match the</span>
  11 |     | <span class='neutral'> * alias used in this contract, which can be found as the first argument to the</span>
  12 |     | <span class='neutral'> * `setChainWithDefaultRpcUrl` call in the `initializeStdChains` function.</span>
  13 |     | <span class='neutral'> *</span>
  14 |     | <span class='neutral'> * There are two main ways to use this contract:</span>
  15 |     | <span class='neutral'> *   1. Set a chain with `setChain(string memory chainAlias, ChainData memory chain)` or</span>
  16 |     | <span class='neutral'> *      `setChain(string memory chainAlias, Chain memory chain)`</span>
  17 |     | <span class='neutral'> *   2. Get a chain with `getChain(string memory chainAlias)` or `getChain(uint256 chainId)`.</span>
  18 |     | <span class='neutral'> *</span>
  19 |     | <span class='neutral'> * The first time either of those are used, chains are initialized with the default set of RPC URLs.</span>
  20 |     | <span class='neutral'> * This is done in `initializeStdChains`, which uses `setChainWithDefaultRpcUrl`. Defaults are recorded in</span>
  21 |     | <span class='neutral'> * `defaultRpcUrls`.</span>
  22 |     | <span class='neutral'> *</span>
  23 |     | <span class='neutral'> * The `setChain` function is straightforward, and it simply saves off the given chain data.</span>
  24 |     | <span class='neutral'> *</span>
  25 |     | <span class='neutral'> * The `getChain` methods use `getChainWithUpdatedRpcUrl` to return a chain. For example, let&#39;s say</span>
  26 |     | <span class='neutral'> * we want to retrieve the RPC URL for `mainnet`:</span>
  27 |     | <span class='neutral'> *   - If you have specified data with `setChain`, it will return that.</span>
  28 |     | <span class='neutral'> *   - If you have configured a mainnet RPC URL in `foundry.toml`, it will return the URL, provided it</span>
  29 |     | <span class='neutral'> *     is valid (e.g. a URL is specified, or an environment variable is given and exists).</span>
  30 |     | <span class='neutral'> *   - If neither of the above conditions is met, the default data is returned.</span>
  31 |     | <span class='neutral'> *</span>
  32 |     | <span class='neutral'> * Summarizing the above, the prioritization hierarchy is `setChain` -&gt; `foundry.toml` -&gt; environment variable -&gt; defaults.</span>
  33 |     | <span class='neutral'> */</span>
  34 |     | <span class='neutral'>abstract contract StdChains {</span>
  35 |     | <span class='neutral'>    VmSafe private constant vm = VmSafe(address(uint160(uint256(keccak256(&quot;hevm cheat code&quot;)))));</span>
  36 |     | <span class='neutral'></span>
  37 |     | <span class='neutral'>    bool private stdChainsInitialized;</span>
  38 |     | <span class='neutral'></span>
  39 |     | <span class='neutral'>    struct ChainData {</span>
  40 |     | <span class='neutral'>        string name;</span>
  41 |     | <span class='neutral'>        uint256 chainId;</span>
  42 |     | <span class='neutral'>        string rpcUrl;</span>
  43 |     | <span class='neutral'>    }</span>
  44 |     | <span class='neutral'></span>
  45 |     | <span class='neutral'>    struct Chain {</span>
  46 |     | <span class='neutral'>        // The chain name.</span>
  47 |     | <span class='neutral'>        string name;</span>
  48 |     | <span class='neutral'>        // The chain&#39;s Chain ID.</span>
  49 |     | <span class='neutral'>        uint256 chainId;</span>
  50 |     | <span class='neutral'>        // The chain&#39;s alias. (i.e. what gets specified in `foundry.toml`).</span>
  51 |     | <span class='neutral'>        string chainAlias;</span>
  52 |     | <span class='neutral'>        // A default RPC endpoint for this chain.</span>
  53 |     | <span class='neutral'>        // NOTE: This default RPC URL is included for convenience to facilitate quick tests and</span>
  54 |     | <span class='neutral'>        // experimentation. Do not use this RPC URL for production test suites, CI, or other heavy</span>
  55 |     | <span class='neutral'>        // usage as you will be throttled and this is a disservice to others who need this endpoint.</span>
  56 |     | <span class='neutral'>        string rpcUrl;</span>
  57 |     | <span class='neutral'>    }</span>
  58 |     | <span class='neutral'></span>
  59 |     | <span class='neutral'>    // Maps from the chain&#39;s alias (matching the alias in the `foundry.toml` file) to chain data.</span>
  60 |     | <span class='neutral'>    mapping(string =&gt; Chain) private chains;</span>
  61 |     | <span class='neutral'>    // Maps from the chain&#39;s alias to it&#39;s default RPC URL.</span>
  62 |     | <span class='neutral'>    mapping(string =&gt; string) private defaultRpcUrls;</span>
  63 |     | <span class='neutral'>    // Maps from a chain ID to it&#39;s alias.</span>
  64 |     | <span class='neutral'>    mapping(uint256 =&gt; string) private idToAlias;</span>
  65 |     | <span class='neutral'></span>
  66 | *   | <span class='executed'>    bool private fallbackToDefaultRpcUrls = true;</span>
  67 |     | <span class='neutral'></span>
  68 |     | <span class='neutral'>    // The RPC URL will be fetched from config or defaultRpcUrls if possible.</span>
  69 |     | <span class='neutral'>    function getChain(string memory chainAlias) internal virtual returns (Chain memory chain) {</span>
  70 |     | <span class='neutral'>        require(bytes(chainAlias).length != 0, &quot;StdChains getChain(string): Chain alias cannot be the empty string.&quot;);</span>
  71 |     | <span class='neutral'></span>
  72 |     | <span class='neutral'>        initializeStdChains();</span>
  73 |     | <span class='neutral'>        chain = chains[chainAlias];</span>
  74 |     | <span class='neutral'>        require(</span>
  75 |     | <span class='neutral'>            chain.chainId != 0,</span>
  76 |     | <span class='neutral'>            string(abi.encodePacked(&quot;StdChains getChain(string): Chain with alias \&quot;&quot;, chainAlias, &quot;\&quot; not found.&quot;))</span>
  77 |     | <span class='neutral'>        );</span>
  78 |     | <span class='neutral'></span>
  79 |     | <span class='neutral'>        chain = getChainWithUpdatedRpcUrl(chainAlias, chain);</span>
  80 |     | <span class='neutral'>    }</span>
  81 |     | <span class='neutral'></span>
  82 |     | <span class='neutral'>    function getChain(uint256 chainId) internal virtual returns (Chain memory chain) {</span>
  83 |     | <span class='neutral'>        require(chainId != 0, &quot;StdChains getChain(uint256): Chain ID cannot be 0.&quot;);</span>
  84 |     | <span class='neutral'>        initializeStdChains();</span>
  85 |     | <span class='neutral'>        string memory chainAlias = idToAlias[chainId];</span>
  86 |     | <span class='neutral'></span>
  87 |     | <span class='neutral'>        chain = chains[chainAlias];</span>
  88 |     | <span class='neutral'></span>
  89 |     | <span class='neutral'>        require(</span>
  90 |     | <span class='neutral'>            chain.chainId != 0,</span>
  91 |     | <span class='neutral'>            string(abi.encodePacked(&quot;StdChains getChain(uint256): Chain with ID &quot;, vm.toString(chainId), &quot; not found.&quot;))</span>
  92 |     | <span class='neutral'>        );</span>
  93 |     | <span class='neutral'></span>
  94 |     | <span class='neutral'>        chain = getChainWithUpdatedRpcUrl(chainAlias, chain);</span>
  95 |     | <span class='neutral'>    }</span>
  96 |     | <span class='neutral'></span>
  97 |     | <span class='neutral'>    // set chain info, with priority to argument&#39;s rpcUrl field.</span>
  98 |     | <span class='neutral'>    function setChain(string memory chainAlias, ChainData memory chain) internal virtual {</span>
  99 |     | <span class='neutral'>        require(</span>
 100 |     | <span class='neutral'>            bytes(chainAlias).length != 0,</span>
 101 |     | <span class='neutral'>            &quot;StdChains setChain(string,ChainData): Chain alias cannot be the empty string.&quot;</span>
 102 |     | <span class='neutral'>        );</span>
 103 |     | <span class='neutral'></span>
 104 |     | <span class='neutral'>        require(chain.chainId != 0, &quot;StdChains setChain(string,ChainData): Chain ID cannot be 0.&quot;);</span>
 105 |     | <span class='neutral'></span>
 106 |     | <span class='neutral'>        initializeStdChains();</span>
 107 |     | <span class='neutral'>        string memory foundAlias = idToAlias[chain.chainId];</span>
 108 |     | <span class='neutral'></span>
 109 |     | <span class='neutral'>        require(</span>
 110 |     | <span class='neutral'>            bytes(foundAlias).length == 0 || keccak256(bytes(foundAlias)) == keccak256(bytes(chainAlias)),</span>
 111 |     | <span class='neutral'>            string(</span>
 112 |     | <span class='neutral'>                abi.encodePacked(</span>
 113 |     | <span class='neutral'>                    &quot;StdChains setChain(string,ChainData): Chain ID &quot;,</span>
 114 |     | <span class='neutral'>                    vm.toString(chain.chainId),</span>
 115 |     | <span class='neutral'>                    &quot; already used by \&quot;&quot;,</span>
 116 |     | <span class='neutral'>                    foundAlias,</span>
 117 |     | <span class='neutral'>                    &quot;\&quot;.&quot;</span>
 118 |     | <span class='neutral'>                )</span>
 119 |     | <span class='neutral'>            )</span>
 120 |     | <span class='neutral'>        );</span>
 121 |     | <span class='neutral'></span>
 122 |     | <span class='neutral'>        uint256 oldChainId = chains[chainAlias].chainId;</span>
 123 |     | <span class='neutral'>        delete idToAlias[oldChainId];</span>
 124 |     | <span class='neutral'></span>
 125 |     | <span class='neutral'>        chains[chainAlias] =</span>
 126 |     | <span class='neutral'>            Chain({name: chain.name, chainId: chain.chainId, chainAlias: chainAlias, rpcUrl: chain.rpcUrl});</span>
 127 |     | <span class='neutral'>        idToAlias[chain.chainId] = chainAlias;</span>
 128 |     | <span class='neutral'>    }</span>
 129 |     | <span class='neutral'></span>
 130 |     | <span class='neutral'>    // set chain info, with priority to argument&#39;s rpcUrl field.</span>
 131 |     | <span class='neutral'>    function setChain(string memory chainAlias, Chain memory chain) internal virtual {</span>
 132 |     | <span class='neutral'>        setChain(chainAlias, ChainData({name: chain.name, chainId: chain.chainId, rpcUrl: chain.rpcUrl}));</span>
 133 |     | <span class='neutral'>    }</span>
 134 |     | <span class='neutral'></span>
 135 |     | <span class='neutral'>    function _toUpper(string memory str) private pure returns (string memory) {</span>
 136 |     | <span class='neutral'>        bytes memory strb = bytes(str);</span>
 137 |     | <span class='neutral'>        bytes memory copy = new bytes(strb.length);</span>
 138 |     | <span class='neutral'>        for (uint256 i = 0; i &lt; strb.length; i++) {</span>
 139 |     | <span class='neutral'>            bytes1 b = strb[i];</span>
 140 |     | <span class='neutral'>            if (b &gt;= 0x61 &amp;&amp; b &lt;= 0x7A) {</span>
 141 |     | <span class='neutral'>                copy[i] = bytes1(uint8(b) - 32);</span>
 142 |     | <span class='neutral'>            } else {</span>
 143 |     | <span class='neutral'>                copy[i] = b;</span>
 144 |     | <span class='neutral'>            }</span>
 145 |     | <span class='neutral'>        }</span>
 146 |     | <span class='neutral'>        return string(copy);</span>
 147 |     | <span class='neutral'>    }</span>
 148 |     | <span class='neutral'></span>
 149 |     | <span class='neutral'>    // lookup rpcUrl, in descending order of priority:</span>
 150 |     | <span class='neutral'>    // current -&gt; config (foundry.toml) -&gt; environment variable -&gt; default</span>
 151 |     | <span class='neutral'>    function getChainWithUpdatedRpcUrl(string memory chainAlias, Chain memory chain)</span>
 152 |     | <span class='neutral'>        private</span>
 153 |     | <span class='neutral'>        view</span>
 154 |     | <span class='neutral'>        returns (Chain memory)</span>
 155 |     | <span class='neutral'>    {</span>
 156 |     | <span class='neutral'>        if (bytes(chain.rpcUrl).length == 0) {</span>
 157 |     | <span class='neutral'>            try vm.rpcUrl(chainAlias) returns (string memory configRpcUrl) {</span>
 158 |     | <span class='neutral'>                chain.rpcUrl = configRpcUrl;</span>
 159 |     | <span class='neutral'>            } catch (bytes memory err) {</span>
 160 |     | <span class='neutral'>                string memory envName = string(abi.encodePacked(_toUpper(chainAlias), &quot;_RPC_URL&quot;));</span>
 161 |     | <span class='neutral'>                if (fallbackToDefaultRpcUrls) {</span>
 162 |     | <span class='neutral'>                    chain.rpcUrl = vm.envOr(envName, defaultRpcUrls[chainAlias]);</span>
 163 |     | <span class='neutral'>                } else {</span>
 164 |     | <span class='neutral'>                    chain.rpcUrl = vm.envString(envName);</span>
 165 |     | <span class='neutral'>                }</span>
 166 |     | <span class='neutral'>                // Distinguish &#39;not found&#39; from &#39;cannot read&#39;</span>
 167 |     | <span class='neutral'>                // The upstream error thrown by forge for failing cheats changed so we check both the old and new versions</span>
 168 |     | <span class='neutral'>                bytes memory oldNotFoundError =</span>
 169 |     | <span class='neutral'>                    abi.encodeWithSignature(&quot;CheatCodeError&quot;, string(abi.encodePacked(&quot;invalid rpc url &quot;, chainAlias)));</span>
 170 |     | <span class='neutral'>                bytes memory newNotFoundError = abi.encodeWithSignature(</span>
 171 |     | <span class='neutral'>                    &quot;CheatcodeError(string)&quot;, string(abi.encodePacked(&quot;invalid rpc url: &quot;, chainAlias))</span>
 172 |     | <span class='neutral'>                );</span>
 173 |     | <span class='neutral'>                bytes32 errHash = keccak256(err);</span>
 174 |     | <span class='neutral'>                if (</span>
 175 |     | <span class='neutral'>                    (errHash != keccak256(oldNotFoundError) &amp;&amp; errHash != keccak256(newNotFoundError))</span>
 176 |     | <span class='neutral'>                        || bytes(chain.rpcUrl).length == 0</span>
 177 |     | <span class='neutral'>                ) {</span>
 178 |     | <span class='neutral'>                    /// @solidity memory-safe-assembly</span>
 179 |     | <span class='neutral'>                    assembly {</span>
 180 |     | <span class='neutral'>                        revert(add(32, err), mload(err))</span>
 181 |     | <span class='neutral'>                    }</span>
 182 |     | <span class='neutral'>                }</span>
 183 |     | <span class='neutral'>            }</span>
 184 |     | <span class='neutral'>        }</span>
 185 |     | <span class='neutral'>        return chain;</span>
 186 |     | <span class='neutral'>    }</span>
 187 |     | <span class='neutral'></span>
 188 |     | <span class='neutral'>    function setFallbackToDefaultRpcUrls(bool useDefault) internal {</span>
 189 |     | <span class='neutral'>        fallbackToDefaultRpcUrls = useDefault;</span>
 190 |     | <span class='neutral'>    }</span>
 191 |     | <span class='neutral'></span>
 192 |     | <span class='neutral'>    function initializeStdChains() private {</span>
 193 |     | <span class='neutral'>        if (stdChainsInitialized) return;</span>
 194 |     | <span class='neutral'></span>
 195 |     | <span class='neutral'>        stdChainsInitialized = true;</span>
 196 |     | <span class='neutral'></span>
 197 |     | <span class='neutral'>        // If adding an RPC here, make sure to test the default RPC URL in `test_Rpcs` in `StdChains.t.sol`</span>
 198 |     | <span class='neutral'>        setChainWithDefaultRpcUrl(&quot;anvil&quot;, ChainData(&quot;Anvil&quot;, 31337, &quot;http://127.0.0.1:8545&quot;));</span>
 199 |     | <span class='neutral'>        setChainWithDefaultRpcUrl(&quot;mainnet&quot;, ChainData(&quot;Mainnet&quot;, 1, &quot;https://eth.llamarpc.com&quot;));</span>
 200 |     | <span class='neutral'>        setChainWithDefaultRpcUrl(</span>
 201 |     | <span class='neutral'>            &quot;sepolia&quot;, ChainData(&quot;Sepolia&quot;, 11155111, &quot;https://sepolia.infura.io/v3/b9794ad1ddf84dfb8c34d6bb5dca2001&quot;)</span>
 202 |     | <span class='neutral'>        );</span>
 203 |     | <span class='neutral'>        setChainWithDefaultRpcUrl(&quot;holesky&quot;, ChainData(&quot;Holesky&quot;, 17000, &quot;https://rpc.holesky.ethpandaops.io&quot;));</span>
 204 |     | <span class='neutral'>        setChainWithDefaultRpcUrl(&quot;hoodi&quot;, ChainData(&quot;Hoodi&quot;, 560048, &quot;https://rpc.hoodi.ethpandaops.io&quot;));</span>
 205 |     | <span class='neutral'>        setChainWithDefaultRpcUrl(&quot;optimism&quot;, ChainData(&quot;Optimism&quot;, 10, &quot;https://mainnet.optimism.io&quot;));</span>
 206 |     | <span class='neutral'>        setChainWithDefaultRpcUrl(</span>
 207 |     | <span class='neutral'>            &quot;optimism_sepolia&quot;, ChainData(&quot;Optimism Sepolia&quot;, 11155420, &quot;https://sepolia.optimism.io&quot;)</span>
 208 |     | <span class='neutral'>        );</span>
 209 |     | <span class='neutral'>        setChainWithDefaultRpcUrl(&quot;arbitrum_one&quot;, ChainData(&quot;Arbitrum One&quot;, 42161, &quot;https://arb1.arbitrum.io/rpc&quot;));</span>
 210 |     | <span class='neutral'>        setChainWithDefaultRpcUrl(</span>
 211 |     | <span class='neutral'>            &quot;arbitrum_one_sepolia&quot;, ChainData(&quot;Arbitrum One Sepolia&quot;, 421614, &quot;https://sepolia-rollup.arbitrum.io/rpc&quot;)</span>
 212 |     | <span class='neutral'>        );</span>
 213 |     | <span class='neutral'>        setChainWithDefaultRpcUrl(&quot;arbitrum_nova&quot;, ChainData(&quot;Arbitrum Nova&quot;, 42170, &quot;https://nova.arbitrum.io/rpc&quot;));</span>
 214 |     | <span class='neutral'>        setChainWithDefaultRpcUrl(&quot;polygon&quot;, ChainData(&quot;Polygon&quot;, 137, &quot;https://polygon-rpc.com&quot;));</span>
 215 |     | <span class='neutral'>        setChainWithDefaultRpcUrl(</span>
 216 |     | <span class='neutral'>            &quot;polygon_amoy&quot;, ChainData(&quot;Polygon Amoy&quot;, 80002, &quot;https://rpc-amoy.polygon.technology&quot;)</span>
 217 |     | <span class='neutral'>        );</span>
 218 |     | <span class='neutral'>        setChainWithDefaultRpcUrl(&quot;avalanche&quot;, ChainData(&quot;Avalanche&quot;, 43114, &quot;https://api.avax.network/ext/bc/C/rpc&quot;));</span>
 219 |     | <span class='neutral'>        setChainWithDefaultRpcUrl(</span>
 220 |     | <span class='neutral'>            &quot;avalanche_fuji&quot;, ChainData(&quot;Avalanche Fuji&quot;, 43113, &quot;https://api.avax-test.network/ext/bc/C/rpc&quot;)</span>
 221 |     | <span class='neutral'>        );</span>
 222 |     | <span class='neutral'>        setChainWithDefaultRpcUrl(</span>
 223 |     | <span class='neutral'>            &quot;bnb_smart_chain&quot;, ChainData(&quot;BNB Smart Chain&quot;, 56, &quot;https://bsc-dataseed1.binance.org&quot;)</span>
 224 |     | <span class='neutral'>        );</span>
 225 |     | <span class='neutral'>        setChainWithDefaultRpcUrl(</span>
 226 |     | <span class='neutral'>            &quot;bnb_smart_chain_testnet&quot;,</span>
 227 |     | <span class='neutral'>            ChainData(&quot;BNB Smart Chain Testnet&quot;, 97, &quot;https://rpc.ankr.com/bsc_testnet_chapel&quot;)</span>
 228 |     | <span class='neutral'>        );</span>
 229 |     | <span class='neutral'>        setChainWithDefaultRpcUrl(&quot;gnosis_chain&quot;, ChainData(&quot;Gnosis Chain&quot;, 100, &quot;https://rpc.gnosischain.com&quot;));</span>
 230 |     | <span class='neutral'>        setChainWithDefaultRpcUrl(&quot;moonbeam&quot;, ChainData(&quot;Moonbeam&quot;, 1284, &quot;https://rpc.api.moonbeam.network&quot;));</span>
 231 |     | <span class='neutral'>        setChainWithDefaultRpcUrl(</span>
 232 |     | <span class='neutral'>            &quot;moonriver&quot;, ChainData(&quot;Moonriver&quot;, 1285, &quot;https://rpc.api.moonriver.moonbeam.network&quot;)</span>
 233 |     | <span class='neutral'>        );</span>
 234 |     | <span class='neutral'>        setChainWithDefaultRpcUrl(&quot;moonbase&quot;, ChainData(&quot;Moonbase&quot;, 1287, &quot;https://rpc.testnet.moonbeam.network&quot;));</span>
 235 |     | <span class='neutral'>        setChainWithDefaultRpcUrl(&quot;base_sepolia&quot;, ChainData(&quot;Base Sepolia&quot;, 84532, &quot;https://sepolia.base.org&quot;));</span>
 236 |     | <span class='neutral'>        setChainWithDefaultRpcUrl(&quot;base&quot;, ChainData(&quot;Base&quot;, 8453, &quot;https://mainnet.base.org&quot;));</span>
 237 |     | <span class='neutral'>        setChainWithDefaultRpcUrl(&quot;blast_sepolia&quot;, ChainData(&quot;Blast Sepolia&quot;, 168587773, &quot;https://sepolia.blast.io&quot;));</span>
 238 |     | <span class='neutral'>        setChainWithDefaultRpcUrl(&quot;blast&quot;, ChainData(&quot;Blast&quot;, 81457, &quot;https://rpc.blast.io&quot;));</span>
 239 |     | <span class='neutral'>        setChainWithDefaultRpcUrl(&quot;fantom_opera&quot;, ChainData(&quot;Fantom Opera&quot;, 250, &quot;https://rpc.ankr.com/fantom/&quot;));</span>
 240 |     | <span class='neutral'>        setChainWithDefaultRpcUrl(</span>
 241 |     | <span class='neutral'>            &quot;fantom_opera_testnet&quot;, ChainData(&quot;Fantom Opera Testnet&quot;, 4002, &quot;https://rpc.ankr.com/fantom_testnet/&quot;)</span>
 242 |     | <span class='neutral'>        );</span>
 243 |     | <span class='neutral'>        setChainWithDefaultRpcUrl(&quot;fraxtal&quot;, ChainData(&quot;Fraxtal&quot;, 252, &quot;https://rpc.frax.com&quot;));</span>
 244 |     | <span class='neutral'>        setChainWithDefaultRpcUrl(&quot;fraxtal_testnet&quot;, ChainData(&quot;Fraxtal Testnet&quot;, 2522, &quot;https://rpc.testnet.frax.com&quot;));</span>
 245 |     | <span class='neutral'>        setChainWithDefaultRpcUrl(</span>
 246 |     | <span class='neutral'>            &quot;berachain_bartio_testnet&quot;, ChainData(&quot;Berachain bArtio Testnet&quot;, 80084, &quot;https://bartio.rpc.berachain.com&quot;)</span>
 247 |     | <span class='neutral'>        );</span>
 248 |     | <span class='neutral'>        setChainWithDefaultRpcUrl(&quot;flare&quot;, ChainData(&quot;Flare&quot;, 14, &quot;https://flare-api.flare.network/ext/C/rpc&quot;));</span>
 249 |     | <span class='neutral'>        setChainWithDefaultRpcUrl(</span>
 250 |     | <span class='neutral'>            &quot;flare_coston2&quot;, ChainData(&quot;Flare Coston2&quot;, 114, &quot;https://coston2-api.flare.network/ext/C/rpc&quot;)</span>
 251 |     | <span class='neutral'>        );</span>
 252 |     | <span class='neutral'></span>
 253 |     | <span class='neutral'>        setChainWithDefaultRpcUrl(&quot;mode&quot;, ChainData(&quot;Mode&quot;, 34443, &quot;https://mode.drpc.org&quot;));</span>
 254 |     | <span class='neutral'>        setChainWithDefaultRpcUrl(&quot;mode_sepolia&quot;, ChainData(&quot;Mode Sepolia&quot;, 919, &quot;https://sepolia.mode.network&quot;));</span>
 255 |     | <span class='neutral'></span>
 256 |     | <span class='neutral'>        setChainWithDefaultRpcUrl(&quot;zora&quot;, ChainData(&quot;Zora&quot;, 7777777, &quot;https://zora.drpc.org&quot;));</span>
 257 |     | <span class='neutral'>        setChainWithDefaultRpcUrl(</span>
 258 |     | <span class='neutral'>            &quot;zora_sepolia&quot;, ChainData(&quot;Zora Sepolia&quot;, 999999999, &quot;https://sepolia.rpc.zora.energy&quot;)</span>
 259 |     | <span class='neutral'>        );</span>
 260 |     | <span class='neutral'></span>
 261 |     | <span class='neutral'>        setChainWithDefaultRpcUrl(&quot;race&quot;, ChainData(&quot;Race&quot;, 6805, &quot;https://racemainnet.io&quot;));</span>
 262 |     | <span class='neutral'>        setChainWithDefaultRpcUrl(&quot;race_sepolia&quot;, ChainData(&quot;Race Sepolia&quot;, 6806, &quot;https://racemainnet.io&quot;));</span>
 263 |     | <span class='neutral'></span>
 264 |     | <span class='neutral'>        setChainWithDefaultRpcUrl(&quot;metal&quot;, ChainData(&quot;Metal&quot;, 1750, &quot;https://metall2.drpc.org&quot;));</span>
 265 |     | <span class='neutral'>        setChainWithDefaultRpcUrl(&quot;metal_sepolia&quot;, ChainData(&quot;Metal Sepolia&quot;, 1740, &quot;https://testnet.rpc.metall2.com&quot;));</span>
 266 |     | <span class='neutral'></span>
 267 |     | <span class='neutral'>        setChainWithDefaultRpcUrl(&quot;binary&quot;, ChainData(&quot;Binary&quot;, 624, &quot;https://rpc.zero.thebinaryholdings.com&quot;));</span>
 268 |     | <span class='neutral'>        setChainWithDefaultRpcUrl(</span>
 269 |     | <span class='neutral'>            &quot;binary_sepolia&quot;, ChainData(&quot;Binary Sepolia&quot;, 625, &quot;https://rpc.zero.thebinaryholdings.com&quot;)</span>
 270 |     | <span class='neutral'>        );</span>
 271 |     | <span class='neutral'></span>
 272 |     | <span class='neutral'>        setChainWithDefaultRpcUrl(&quot;orderly&quot;, ChainData(&quot;Orderly&quot;, 291, &quot;https://rpc.orderly.network&quot;));</span>
 273 |     | <span class='neutral'>        setChainWithDefaultRpcUrl(</span>
 274 |     | <span class='neutral'>            &quot;orderly_sepolia&quot;, ChainData(&quot;Orderly Sepolia&quot;, 4460, &quot;https://testnet-rpc.orderly.org&quot;)</span>
 275 |     | <span class='neutral'>        );</span>
 276 |     | <span class='neutral'>    }</span>
 277 |     | <span class='neutral'></span>
 278 |     | <span class='neutral'>    // set chain info, with priority to chainAlias&#39; rpc url in foundry.toml</span>
 279 |     | <span class='neutral'>    function setChainWithDefaultRpcUrl(string memory chainAlias, ChainData memory chain) private {</span>
 280 |     | <span class='neutral'>        string memory rpcUrl = chain.rpcUrl;</span>
 281 |     | <span class='neutral'>        defaultRpcUrls[chainAlias] = rpcUrl;</span>
 282 |     | <span class='neutral'>        chain.rpcUrl = &quot;&quot;;</span>
 283 |     | <span class='neutral'>        setChain(chainAlias, chain);</span>
 284 |     | <span class='neutral'>        chain.rpcUrl = rpcUrl; // restore argument</span>
 285 |     | <span class='neutral'>    }</span>
 286 |     | <span class='neutral'>}</span>
 287 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/phantom/Documents/azemora/azemora-contracts/lib/forge-std/src/StdCheats.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'>pragma solidity &gt;=0.6.2 &lt;0.9.0;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>pragma experimental ABIEncoderV2;</span>
   5 |     | <span class='neutral'></span>
   6 |     | <span class='neutral'>import {StdStorage, stdStorage} from &quot;./StdStorage.sol&quot;;</span>
   7 |     | <span class='neutral'>import {console2} from &quot;./console2.sol&quot;;</span>
   8 |     | <span class='neutral'>import {Vm} from &quot;./Vm.sol&quot;;</span>
   9 |     | <span class='neutral'></span>
  10 |     | <span class='neutral'>abstract contract StdCheatsSafe {</span>
  11 |     | <span class='neutral'>    Vm private constant vm = Vm(address(uint160(uint256(keccak256(&quot;hevm cheat code&quot;)))));</span>
  12 |     | <span class='neutral'></span>
  13 |     | <span class='neutral'>    uint256 private constant UINT256_MAX =</span>
  14 |     | <span class='neutral'>        115792089237316195423570985008687907853269984665640564039457584007913129639935;</span>
  15 |     | <span class='neutral'></span>
  16 |     | <span class='neutral'>    bool private gasMeteringOff;</span>
  17 |     | <span class='neutral'></span>
  18 |     | <span class='neutral'>    // Data structures to parse Transaction objects from the broadcast artifact</span>
  19 |     | <span class='neutral'>    // that conform to EIP1559. The Raw structs is what is parsed from the JSON</span>
  20 |     | <span class='neutral'>    // and then converted to the one that is used by the user for better UX.</span>
  21 |     | <span class='neutral'></span>
  22 |     | <span class='neutral'>    struct RawTx1559 {</span>
  23 |     | <span class='neutral'>        string[] arguments;</span>
  24 |     | <span class='neutral'>        address contractAddress;</span>
  25 |     | <span class='neutral'>        string contractName;</span>
  26 |     | <span class='neutral'>        // json value name = function</span>
  27 |     | <span class='neutral'>        string functionSig;</span>
  28 |     | <span class='neutral'>        bytes32 hash;</span>
  29 |     | <span class='neutral'>        // json value name = tx</span>
  30 |     | <span class='neutral'>        RawTx1559Detail txDetail;</span>
  31 |     | <span class='neutral'>        // json value name = type</span>
  32 |     | <span class='neutral'>        string opcode;</span>
  33 |     | <span class='neutral'>    }</span>
  34 |     | <span class='neutral'></span>
  35 |     | <span class='neutral'>    struct RawTx1559Detail {</span>
  36 |     | <span class='neutral'>        AccessList[] accessList;</span>
  37 |     | <span class='neutral'>        bytes data;</span>
  38 |     | <span class='neutral'>        address from;</span>
  39 |     | <span class='neutral'>        bytes gas;</span>
  40 |     | <span class='neutral'>        bytes nonce;</span>
  41 |     | <span class='neutral'>        address to;</span>
  42 |     | <span class='neutral'>        bytes txType;</span>
  43 |     | <span class='neutral'>        bytes value;</span>
  44 |     | <span class='neutral'>    }</span>
  45 |     | <span class='neutral'></span>
  46 |     | <span class='neutral'>    struct Tx1559 {</span>
  47 |     | <span class='neutral'>        string[] arguments;</span>
  48 |     | <span class='neutral'>        address contractAddress;</span>
  49 |     | <span class='neutral'>        string contractName;</span>
  50 |     | <span class='neutral'>        string functionSig;</span>
  51 |     | <span class='neutral'>        bytes32 hash;</span>
  52 |     | <span class='neutral'>        Tx1559Detail txDetail;</span>
  53 |     | <span class='neutral'>        string opcode;</span>
  54 |     | <span class='neutral'>    }</span>
  55 |     | <span class='neutral'></span>
  56 |     | <span class='neutral'>    struct Tx1559Detail {</span>
  57 |     | <span class='neutral'>        AccessList[] accessList;</span>
  58 |     | <span class='neutral'>        bytes data;</span>
  59 |     | <span class='neutral'>        address from;</span>
  60 |     | <span class='neutral'>        uint256 gas;</span>
  61 |     | <span class='neutral'>        uint256 nonce;</span>
  62 |     | <span class='neutral'>        address to;</span>
  63 |     | <span class='neutral'>        uint256 txType;</span>
  64 |     | <span class='neutral'>        uint256 value;</span>
  65 |     | <span class='neutral'>    }</span>
  66 |     | <span class='neutral'></span>
  67 |     | <span class='neutral'>    // Data structures to parse Transaction objects from the broadcast artifact</span>
  68 |     | <span class='neutral'>    // that DO NOT conform to EIP1559. The Raw structs is what is parsed from the JSON</span>
  69 |     | <span class='neutral'>    // and then converted to the one that is used by the user for better UX.</span>
  70 |     | <span class='neutral'></span>
  71 |     | <span class='neutral'>    struct TxLegacy {</span>
  72 |     | <span class='neutral'>        string[] arguments;</span>
  73 |     | <span class='neutral'>        address contractAddress;</span>
  74 |     | <span class='neutral'>        string contractName;</span>
  75 |     | <span class='neutral'>        string functionSig;</span>
  76 |     | <span class='neutral'>        string hash;</span>
  77 |     | <span class='neutral'>        string opcode;</span>
  78 |     | <span class='neutral'>        TxDetailLegacy transaction;</span>
  79 |     | <span class='neutral'>    }</span>
  80 |     | <span class='neutral'></span>
  81 |     | <span class='neutral'>    struct TxDetailLegacy {</span>
  82 |     | <span class='neutral'>        AccessList[] accessList;</span>
  83 |     | <span class='neutral'>        uint256 chainId;</span>
  84 |     | <span class='neutral'>        bytes data;</span>
  85 |     | <span class='neutral'>        address from;</span>
  86 |     | <span class='neutral'>        uint256 gas;</span>
  87 |     | <span class='neutral'>        uint256 gasPrice;</span>
  88 |     | <span class='neutral'>        bytes32 hash;</span>
  89 |     | <span class='neutral'>        uint256 nonce;</span>
  90 |     | <span class='neutral'>        bytes1 opcode;</span>
  91 |     | <span class='neutral'>        bytes32 r;</span>
  92 |     | <span class='neutral'>        bytes32 s;</span>
  93 |     | <span class='neutral'>        uint256 txType;</span>
  94 |     | <span class='neutral'>        address to;</span>
  95 |     | <span class='neutral'>        uint8 v;</span>
  96 |     | <span class='neutral'>        uint256 value;</span>
  97 |     | <span class='neutral'>    }</span>
  98 |     | <span class='neutral'></span>
  99 |     | <span class='neutral'>    struct AccessList {</span>
 100 |     | <span class='neutral'>        address accessAddress;</span>
 101 |     | <span class='neutral'>        bytes32[] storageKeys;</span>
 102 |     | <span class='neutral'>    }</span>
 103 |     | <span class='neutral'></span>
 104 |     | <span class='neutral'>    // Data structures to parse Receipt objects from the broadcast artifact.</span>
 105 |     | <span class='neutral'>    // The Raw structs is what is parsed from the JSON</span>
 106 |     | <span class='neutral'>    // and then converted to the one that is used by the user for better UX.</span>
 107 |     | <span class='neutral'></span>
 108 |     | <span class='neutral'>    struct RawReceipt {</span>
 109 |     | <span class='neutral'>        bytes32 blockHash;</span>
 110 |     | <span class='neutral'>        bytes blockNumber;</span>
 111 |     | <span class='neutral'>        address contractAddress;</span>
 112 |     | <span class='neutral'>        bytes cumulativeGasUsed;</span>
 113 |     | <span class='neutral'>        bytes effectiveGasPrice;</span>
 114 |     | <span class='neutral'>        address from;</span>
 115 |     | <span class='neutral'>        bytes gasUsed;</span>
 116 |     | <span class='neutral'>        RawReceiptLog[] logs;</span>
 117 |     | <span class='neutral'>        bytes logsBloom;</span>
 118 |     | <span class='neutral'>        bytes status;</span>
 119 |     | <span class='neutral'>        address to;</span>
 120 |     | <span class='neutral'>        bytes32 transactionHash;</span>
 121 |     | <span class='neutral'>        bytes transactionIndex;</span>
 122 |     | <span class='neutral'>    }</span>
 123 |     | <span class='neutral'></span>
 124 |     | <span class='neutral'>    struct Receipt {</span>
 125 |     | <span class='neutral'>        bytes32 blockHash;</span>
 126 |     | <span class='neutral'>        uint256 blockNumber;</span>
 127 |     | <span class='neutral'>        address contractAddress;</span>
 128 |     | <span class='neutral'>        uint256 cumulativeGasUsed;</span>
 129 |     | <span class='neutral'>        uint256 effectiveGasPrice;</span>
 130 |     | <span class='neutral'>        address from;</span>
 131 |     | <span class='neutral'>        uint256 gasUsed;</span>
 132 |     | <span class='neutral'>        ReceiptLog[] logs;</span>
 133 |     | <span class='neutral'>        bytes logsBloom;</span>
 134 |     | <span class='neutral'>        uint256 status;</span>
 135 |     | <span class='neutral'>        address to;</span>
 136 |     | <span class='neutral'>        bytes32 transactionHash;</span>
 137 |     | <span class='neutral'>        uint256 transactionIndex;</span>
 138 |     | <span class='neutral'>    }</span>
 139 |     | <span class='neutral'></span>
 140 |     | <span class='neutral'>    // Data structures to parse the entire broadcast artifact, assuming the</span>
 141 |     | <span class='neutral'>    // transactions conform to EIP1559.</span>
 142 |     | <span class='neutral'></span>
 143 |     | <span class='neutral'>    struct EIP1559ScriptArtifact {</span>
 144 |     | <span class='neutral'>        string[] libraries;</span>
 145 |     | <span class='neutral'>        string path;</span>
 146 |     | <span class='neutral'>        string[] pending;</span>
 147 |     | <span class='neutral'>        Receipt[] receipts;</span>
 148 |     | <span class='neutral'>        uint256 timestamp;</span>
 149 |     | <span class='neutral'>        Tx1559[] transactions;</span>
 150 |     | <span class='neutral'>        TxReturn[] txReturns;</span>
 151 |     | <span class='neutral'>    }</span>
 152 |     | <span class='neutral'></span>
 153 |     | <span class='neutral'>    struct RawEIP1559ScriptArtifact {</span>
 154 |     | <span class='neutral'>        string[] libraries;</span>
 155 |     | <span class='neutral'>        string path;</span>
 156 |     | <span class='neutral'>        string[] pending;</span>
 157 |     | <span class='neutral'>        RawReceipt[] receipts;</span>
 158 |     | <span class='neutral'>        TxReturn[] txReturns;</span>
 159 |     | <span class='neutral'>        uint256 timestamp;</span>
 160 |     | <span class='neutral'>        RawTx1559[] transactions;</span>
 161 |     | <span class='neutral'>    }</span>
 162 |     | <span class='neutral'></span>
 163 |     | <span class='neutral'>    struct RawReceiptLog {</span>
 164 |     | <span class='neutral'>        // json value = address</span>
 165 |     | <span class='neutral'>        address logAddress;</span>
 166 |     | <span class='neutral'>        bytes32 blockHash;</span>
 167 |     | <span class='neutral'>        bytes blockNumber;</span>
 168 |     | <span class='neutral'>        bytes data;</span>
 169 |     | <span class='neutral'>        bytes logIndex;</span>
 170 |     | <span class='neutral'>        bool removed;</span>
 171 |     | <span class='neutral'>        bytes32[] topics;</span>
 172 |     | <span class='neutral'>        bytes32 transactionHash;</span>
 173 |     | <span class='neutral'>        bytes transactionIndex;</span>
 174 |     | <span class='neutral'>        bytes transactionLogIndex;</span>
 175 |     | <span class='neutral'>    }</span>
 176 |     | <span class='neutral'></span>
 177 |     | <span class='neutral'>    struct ReceiptLog {</span>
 178 |     | <span class='neutral'>        // json value = address</span>
 179 |     | <span class='neutral'>        address logAddress;</span>
 180 |     | <span class='neutral'>        bytes32 blockHash;</span>
 181 |     | <span class='neutral'>        uint256 blockNumber;</span>
 182 |     | <span class='neutral'>        bytes data;</span>
 183 |     | <span class='neutral'>        uint256 logIndex;</span>
 184 |     | <span class='neutral'>        bytes32[] topics;</span>
 185 |     | <span class='neutral'>        uint256 transactionIndex;</span>
 186 |     | <span class='neutral'>        uint256 transactionLogIndex;</span>
 187 |     | <span class='neutral'>        bool removed;</span>
 188 |     | <span class='neutral'>    }</span>
 189 |     | <span class='neutral'></span>
 190 |     | <span class='neutral'>    struct TxReturn {</span>
 191 |     | <span class='neutral'>        string internalType;</span>
 192 |     | <span class='neutral'>        string value;</span>
 193 |     | <span class='neutral'>    }</span>
 194 |     | <span class='neutral'></span>
 195 |     | <span class='neutral'>    struct Account {</span>
 196 |     | <span class='neutral'>        address addr;</span>
 197 |     | <span class='neutral'>        uint256 key;</span>
 198 |     | <span class='neutral'>    }</span>
 199 |     | <span class='neutral'></span>
 200 |     | <span class='neutral'>    enum AddressType {</span>
 201 |     | <span class='neutral'>        Payable,</span>
 202 |     | <span class='neutral'>        NonPayable,</span>
 203 |     | <span class='neutral'>        ZeroAddress,</span>
 204 |     | <span class='neutral'>        Precompile,</span>
 205 |     | <span class='neutral'>        ForgeAddress</span>
 206 |     | <span class='neutral'>    }</span>
 207 |     | <span class='neutral'></span>
 208 |     | <span class='neutral'>    // Checks that `addr` is not blacklisted by token contracts that have a blacklist.</span>
 209 |     | <span class='neutral'>    function assumeNotBlacklisted(address token, address addr) internal view virtual {</span>
 210 |     | <span class='neutral'>        // Nothing to check if `token` is not a contract.</span>
 211 |     | <span class='neutral'>        uint256 tokenCodeSize;</span>
 212 |     | <span class='neutral'>        assembly {</span>
 213 |     | <span class='neutral'>            tokenCodeSize := extcodesize(token)</span>
 214 |     | <span class='neutral'>        }</span>
 215 |     | <span class='neutral'>        require(tokenCodeSize &gt; 0, &quot;StdCheats assumeNotBlacklisted(address,address): Token address is not a contract.&quot;);</span>
 216 |     | <span class='neutral'></span>
 217 |     | <span class='neutral'>        bool success;</span>
 218 |     | <span class='neutral'>        bytes memory returnData;</span>
 219 |     | <span class='neutral'></span>
 220 |     | <span class='neutral'>        // 4-byte selector for `isBlacklisted(address)`, used by USDC.</span>
 221 |     | <span class='neutral'>        (success, returnData) = token.staticcall(abi.encodeWithSelector(0xfe575a87, addr));</span>
 222 |     | <span class='neutral'>        vm.assume(!success || abi.decode(returnData, (bool)) == false);</span>
 223 |     | <span class='neutral'></span>
 224 |     | <span class='neutral'>        // 4-byte selector for `isBlackListed(address)`, used by USDT.</span>
 225 |     | <span class='neutral'>        (success, returnData) = token.staticcall(abi.encodeWithSelector(0xe47d6060, addr));</span>
 226 |     | <span class='neutral'>        vm.assume(!success || abi.decode(returnData, (bool)) == false);</span>
 227 |     | <span class='neutral'>    }</span>
 228 |     | <span class='neutral'></span>
 229 |     | <span class='neutral'>    // Checks that `addr` is not blacklisted by token contracts that have a blacklist.</span>
 230 |     | <span class='neutral'>    // This is identical to `assumeNotBlacklisted(address,address)` but with a different name, for</span>
 231 |     | <span class='neutral'>    // backwards compatibility, since this name was used in the original PR which already has</span>
 232 |     | <span class='neutral'>    // a release. This function can be removed in a future release once we want a breaking change.</span>
 233 |     | <span class='neutral'>    function assumeNoBlacklisted(address token, address addr) internal view virtual {</span>
 234 |     | <span class='neutral'>        assumeNotBlacklisted(token, addr);</span>
 235 |     | <span class='neutral'>    }</span>
 236 |     | <span class='neutral'></span>
 237 |     | <span class='neutral'>    function assumeAddressIsNot(address addr, AddressType addressType) internal virtual {</span>
 238 |     | <span class='neutral'>        if (addressType == AddressType.Payable) {</span>
 239 |     | <span class='neutral'>            assumeNotPayable(addr);</span>
 240 |     | <span class='neutral'>        } else if (addressType == AddressType.NonPayable) {</span>
 241 |     | <span class='neutral'>            assumePayable(addr);</span>
 242 |     | <span class='neutral'>        } else if (addressType == AddressType.ZeroAddress) {</span>
 243 |     | <span class='neutral'>            assumeNotZeroAddress(addr);</span>
 244 |     | <span class='neutral'>        } else if (addressType == AddressType.Precompile) {</span>
 245 |     | <span class='neutral'>            assumeNotPrecompile(addr);</span>
 246 |     | <span class='neutral'>        } else if (addressType == AddressType.ForgeAddress) {</span>
 247 |     | <span class='neutral'>            assumeNotForgeAddress(addr);</span>
 248 |     | <span class='neutral'>        }</span>
 249 |     | <span class='neutral'>    }</span>
 250 |     | <span class='neutral'></span>
 251 |     | <span class='neutral'>    function assumeAddressIsNot(address addr, AddressType addressType1, AddressType addressType2) internal virtual {</span>
 252 |     | <span class='neutral'>        assumeAddressIsNot(addr, addressType1);</span>
 253 |     | <span class='neutral'>        assumeAddressIsNot(addr, addressType2);</span>
 254 |     | <span class='neutral'>    }</span>
 255 |     | <span class='neutral'></span>
 256 |     | <span class='neutral'>    function assumeAddressIsNot(</span>
 257 |     | <span class='neutral'>        address addr,</span>
 258 |     | <span class='neutral'>        AddressType addressType1,</span>
 259 |     | <span class='neutral'>        AddressType addressType2,</span>
 260 |     | <span class='neutral'>        AddressType addressType3</span>
 261 |     | <span class='neutral'>    ) internal virtual {</span>
 262 |     | <span class='neutral'>        assumeAddressIsNot(addr, addressType1);</span>
 263 |     | <span class='neutral'>        assumeAddressIsNot(addr, addressType2);</span>
 264 |     | <span class='neutral'>        assumeAddressIsNot(addr, addressType3);</span>
 265 |     | <span class='neutral'>    }</span>
 266 |     | <span class='neutral'></span>
 267 |     | <span class='neutral'>    function assumeAddressIsNot(</span>
 268 |     | <span class='neutral'>        address addr,</span>
 269 |     | <span class='neutral'>        AddressType addressType1,</span>
 270 |     | <span class='neutral'>        AddressType addressType2,</span>
 271 |     | <span class='neutral'>        AddressType addressType3,</span>
 272 |     | <span class='neutral'>        AddressType addressType4</span>
 273 |     | <span class='neutral'>    ) internal virtual {</span>
 274 |     | <span class='neutral'>        assumeAddressIsNot(addr, addressType1);</span>
 275 |     | <span class='neutral'>        assumeAddressIsNot(addr, addressType2);</span>
 276 |     | <span class='neutral'>        assumeAddressIsNot(addr, addressType3);</span>
 277 |     | <span class='neutral'>        assumeAddressIsNot(addr, addressType4);</span>
 278 |     | <span class='neutral'>    }</span>
 279 |     | <span class='neutral'></span>
 280 |     | <span class='neutral'>    // This function checks whether an address, `addr`, is payable. It works by sending 1 wei to</span>
 281 |     | <span class='neutral'>    // `addr` and checking the `success` return value.</span>
 282 |     | <span class='neutral'>    // NOTE: This function may result in state changes depending on the fallback/receive logic</span>
 283 |     | <span class='neutral'>    // implemented by `addr`, which should be taken into account when this function is used.</span>
 284 |     | <span class='neutral'>    function _isPayable(address addr) private returns (bool) {</span>
 285 |     | <span class='neutral'>        require(</span>
 286 |     | <span class='neutral'>            addr.balance &lt; UINT256_MAX,</span>
 287 |     | <span class='neutral'>            &quot;StdCheats _isPayable(address): Balance equals max uint256, so it cannot receive any more funds&quot;</span>
 288 |     | <span class='neutral'>        );</span>
 289 |     | <span class='neutral'>        uint256 origBalanceTest = address(this).balance;</span>
 290 |     | <span class='neutral'>        uint256 origBalanceAddr = address(addr).balance;</span>
 291 |     | <span class='neutral'></span>
 292 |     | <span class='neutral'>        vm.deal(address(this), 1);</span>
 293 |     | <span class='neutral'>        (bool success,) = payable(addr).call{value: 1}(&quot;&quot;);</span>
 294 |     | <span class='neutral'></span>
 295 |     | <span class='neutral'>        // reset balances</span>
 296 |     | <span class='neutral'>        vm.deal(address(this), origBalanceTest);</span>
 297 |     | <span class='neutral'>        vm.deal(addr, origBalanceAddr);</span>
 298 |     | <span class='neutral'></span>
 299 |     | <span class='neutral'>        return success;</span>
 300 |     | <span class='neutral'>    }</span>
 301 |     | <span class='neutral'></span>
 302 |     | <span class='neutral'>    // NOTE: This function may result in state changes depending on the fallback/receive logic</span>
 303 |     | <span class='neutral'>    // implemented by `addr`, which should be taken into account when this function is used. See the</span>
 304 |     | <span class='neutral'>    // `_isPayable` method for more information.</span>
 305 |     | <span class='neutral'>    function assumePayable(address addr) internal virtual {</span>
 306 |     | <span class='neutral'>        vm.assume(_isPayable(addr));</span>
 307 |     | <span class='neutral'>    }</span>
 308 |     | <span class='neutral'></span>
 309 |     | <span class='neutral'>    function assumeNotPayable(address addr) internal virtual {</span>
 310 |     | <span class='neutral'>        vm.assume(!_isPayable(addr));</span>
 311 |     | <span class='neutral'>    }</span>
 312 |     | <span class='neutral'></span>
 313 |     | <span class='neutral'>    function assumeNotZeroAddress(address addr) internal pure virtual {</span>
 314 |     | <span class='neutral'>        vm.assume(addr != address(0));</span>
 315 |     | <span class='neutral'>    }</span>
 316 |     | <span class='neutral'></span>
 317 |     | <span class='neutral'>    function assumeNotPrecompile(address addr) internal pure virtual {</span>
 318 |     | <span class='neutral'>        assumeNotPrecompile(addr, _pureChainId());</span>
 319 |     | <span class='neutral'>    }</span>
 320 |     | <span class='neutral'></span>
 321 |     | <span class='neutral'>    function assumeNotPrecompile(address addr, uint256 chainId) internal pure virtual {</span>
 322 |     | <span class='neutral'>        // Note: For some chains like Optimism these are technically predeploys (i.e. bytecode placed at a specific</span>
 323 |     | <span class='neutral'>        // address), but the same rationale for excluding them applies so we include those too.</span>
 324 |     | <span class='neutral'></span>
 325 |     | <span class='neutral'>        // These are reserved by Ethereum and may be on all EVM-compatible chains.</span>
 326 |     | <span class='neutral'>        vm.assume(addr &lt; address(0x1) || addr &gt; address(0xff));</span>
 327 |     | <span class='neutral'></span>
 328 |     | <span class='neutral'>        // forgefmt: disable-start</span>
 329 |     | <span class='neutral'>        if (chainId == 10 || chainId == 420) {</span>
 330 |     | <span class='neutral'>            // https://github.com/ethereum-optimism/optimism/blob/eaa371a0184b56b7ca6d9eb9cb0a2b78b2ccd864/op-bindings/predeploys/addresses.go#L6-L21</span>
 331 |     | <span class='neutral'>            vm.assume(addr &lt; address(0x4200000000000000000000000000000000000000) || addr &gt; address(0x4200000000000000000000000000000000000800));</span>
 332 |     | <span class='neutral'>        } else if (chainId == 42161 || chainId == 421613) {</span>
 333 |     | <span class='neutral'>            // https://developer.arbitrum.io/useful-addresses#arbitrum-precompiles-l2-same-on-all-arb-chains</span>
 334 |     | <span class='neutral'>            vm.assume(addr &lt; address(0x0000000000000000000000000000000000000064) || addr &gt; address(0x0000000000000000000000000000000000000068));</span>
 335 |     | <span class='neutral'>        } else if (chainId == 43114 || chainId == 43113) {</span>
 336 |     | <span class='neutral'>            // https://github.com/ava-labs/subnet-evm/blob/47c03fd007ecaa6de2c52ea081596e0a88401f58/precompile/params.go#L18-L59</span>
 337 |     | <span class='neutral'>            vm.assume(addr &lt; address(0x0100000000000000000000000000000000000000) || addr &gt; address(0x01000000000000000000000000000000000000ff));</span>
 338 |     | <span class='neutral'>            vm.assume(addr &lt; address(0x0200000000000000000000000000000000000000) || addr &gt; address(0x02000000000000000000000000000000000000FF));</span>
 339 |     | <span class='neutral'>            vm.assume(addr &lt; address(0x0300000000000000000000000000000000000000) || addr &gt; address(0x03000000000000000000000000000000000000Ff));</span>
 340 |     | <span class='neutral'>        }</span>
 341 |     | <span class='neutral'>        // forgefmt: disable-end</span>
 342 |     | <span class='neutral'>    }</span>
 343 |     | <span class='neutral'></span>
 344 |     | <span class='neutral'>    function assumeNotForgeAddress(address addr) internal pure virtual {</span>
 345 |     | <span class='neutral'>        // vm, console, and Create2Deployer addresses</span>
 346 |     | <span class='neutral'>        vm.assume(</span>
 347 |     | <span class='neutral'>            addr != address(vm) &amp;&amp; addr != 0x000000000000000000636F6e736F6c652e6c6f67</span>
 348 |     | <span class='neutral'>                &amp;&amp; addr != 0x4e59b44847b379578588920cA78FbF26c0B4956C</span>
 349 |     | <span class='neutral'>        );</span>
 350 |     | <span class='neutral'>    }</span>
 351 |     | <span class='neutral'></span>
 352 |     | <span class='neutral'>    function assumeUnusedAddress(address addr) internal view virtual {</span>
 353 |     | <span class='neutral'>        uint256 size;</span>
 354 |     | <span class='neutral'>        assembly {</span>
 355 |     | <span class='neutral'>            size := extcodesize(addr)</span>
 356 |     | <span class='neutral'>        }</span>
 357 |     | <span class='neutral'>        vm.assume(size == 0);</span>
 358 |     | <span class='neutral'></span>
 359 |     | <span class='neutral'>        assumeNotPrecompile(addr);</span>
 360 |     | <span class='neutral'>        assumeNotZeroAddress(addr);</span>
 361 |     | <span class='neutral'>        assumeNotForgeAddress(addr);</span>
 362 |     | <span class='neutral'>    }</span>
 363 |     | <span class='neutral'></span>
 364 |     | <span class='neutral'>    function readEIP1559ScriptArtifact(string memory path)</span>
 365 |     | <span class='neutral'>        internal</span>
 366 |     | <span class='neutral'>        view</span>
 367 |     | <span class='neutral'>        virtual</span>
 368 |     | <span class='neutral'>        returns (EIP1559ScriptArtifact memory)</span>
 369 |     | <span class='neutral'>    {</span>
 370 |     | <span class='neutral'>        string memory data = vm.readFile(path);</span>
 371 |     | <span class='neutral'>        bytes memory parsedData = vm.parseJson(data);</span>
 372 |     | <span class='neutral'>        RawEIP1559ScriptArtifact memory rawArtifact = abi.decode(parsedData, (RawEIP1559ScriptArtifact));</span>
 373 |     | <span class='neutral'>        EIP1559ScriptArtifact memory artifact;</span>
 374 |     | <span class='neutral'>        artifact.libraries = rawArtifact.libraries;</span>
 375 |     | <span class='neutral'>        artifact.path = rawArtifact.path;</span>
 376 |     | <span class='neutral'>        artifact.timestamp = rawArtifact.timestamp;</span>
 377 |     | <span class='neutral'>        artifact.pending = rawArtifact.pending;</span>
 378 |     | <span class='neutral'>        artifact.txReturns = rawArtifact.txReturns;</span>
 379 |     | <span class='neutral'>        artifact.receipts = rawToConvertedReceipts(rawArtifact.receipts);</span>
 380 |     | <span class='neutral'>        artifact.transactions = rawToConvertedEIPTx1559s(rawArtifact.transactions);</span>
 381 |     | <span class='neutral'>        return artifact;</span>
 382 |     | <span class='neutral'>    }</span>
 383 |     | <span class='neutral'></span>
 384 |     | <span class='neutral'>    function rawToConvertedEIPTx1559s(RawTx1559[] memory rawTxs) internal pure virtual returns (Tx1559[] memory) {</span>
 385 |     | <span class='neutral'>        Tx1559[] memory txs = new Tx1559[](rawTxs.length);</span>
 386 |     | <span class='neutral'>        for (uint256 i; i &lt; rawTxs.length; i++) {</span>
 387 |     | <span class='neutral'>            txs[i] = rawToConvertedEIPTx1559(rawTxs[i]);</span>
 388 |     | <span class='neutral'>        }</span>
 389 |     | <span class='neutral'>        return txs;</span>
 390 |     | <span class='neutral'>    }</span>
 391 |     | <span class='neutral'></span>
 392 |     | <span class='neutral'>    function rawToConvertedEIPTx1559(RawTx1559 memory rawTx) internal pure virtual returns (Tx1559 memory) {</span>
 393 |     | <span class='neutral'>        Tx1559 memory transaction;</span>
 394 |     | <span class='neutral'>        transaction.arguments = rawTx.arguments;</span>
 395 |     | <span class='neutral'>        transaction.contractName = rawTx.contractName;</span>
 396 |     | <span class='neutral'>        transaction.functionSig = rawTx.functionSig;</span>
 397 |     | <span class='neutral'>        transaction.hash = rawTx.hash;</span>
 398 |     | <span class='neutral'>        transaction.txDetail = rawToConvertedEIP1559Detail(rawTx.txDetail);</span>
 399 |     | <span class='neutral'>        transaction.opcode = rawTx.opcode;</span>
 400 |     | <span class='neutral'>        return transaction;</span>
 401 |     | <span class='neutral'>    }</span>
 402 |     | <span class='neutral'></span>
 403 |     | <span class='neutral'>    function rawToConvertedEIP1559Detail(RawTx1559Detail memory rawDetail)</span>
 404 |     | <span class='neutral'>        internal</span>
 405 |     | <span class='neutral'>        pure</span>
 406 |     | <span class='neutral'>        virtual</span>
 407 |     | <span class='neutral'>        returns (Tx1559Detail memory)</span>
 408 |     | <span class='neutral'>    {</span>
 409 |     | <span class='neutral'>        Tx1559Detail memory txDetail;</span>
 410 |     | <span class='neutral'>        txDetail.data = rawDetail.data;</span>
 411 |     | <span class='neutral'>        txDetail.from = rawDetail.from;</span>
 412 |     | <span class='neutral'>        txDetail.to = rawDetail.to;</span>
 413 |     | <span class='neutral'>        txDetail.nonce = _bytesToUint(rawDetail.nonce);</span>
 414 |     | <span class='neutral'>        txDetail.txType = _bytesToUint(rawDetail.txType);</span>
 415 |     | <span class='neutral'>        txDetail.value = _bytesToUint(rawDetail.value);</span>
 416 |     | <span class='neutral'>        txDetail.gas = _bytesToUint(rawDetail.gas);</span>
 417 |     | <span class='neutral'>        txDetail.accessList = rawDetail.accessList;</span>
 418 |     | <span class='neutral'>        return txDetail;</span>
 419 |     | <span class='neutral'>    }</span>
 420 |     | <span class='neutral'></span>
 421 |     | <span class='neutral'>    function readTx1559s(string memory path) internal view virtual returns (Tx1559[] memory) {</span>
 422 |     | <span class='neutral'>        string memory deployData = vm.readFile(path);</span>
 423 |     | <span class='neutral'>        bytes memory parsedDeployData = vm.parseJson(deployData, &quot;.transactions&quot;);</span>
 424 |     | <span class='neutral'>        RawTx1559[] memory rawTxs = abi.decode(parsedDeployData, (RawTx1559[]));</span>
 425 |     | <span class='neutral'>        return rawToConvertedEIPTx1559s(rawTxs);</span>
 426 |     | <span class='neutral'>    }</span>
 427 |     | <span class='neutral'></span>
 428 |     | <span class='neutral'>    function readTx1559(string memory path, uint256 index) internal view virtual returns (Tx1559 memory) {</span>
 429 |     | <span class='neutral'>        string memory deployData = vm.readFile(path);</span>
 430 |     | <span class='neutral'>        string memory key = string(abi.encodePacked(&quot;.transactions[&quot;, vm.toString(index), &quot;]&quot;));</span>
 431 |     | <span class='neutral'>        bytes memory parsedDeployData = vm.parseJson(deployData, key);</span>
 432 |     | <span class='neutral'>        RawTx1559 memory rawTx = abi.decode(parsedDeployData, (RawTx1559));</span>
 433 |     | <span class='neutral'>        return rawToConvertedEIPTx1559(rawTx);</span>
 434 |     | <span class='neutral'>    }</span>
 435 |     | <span class='neutral'></span>
 436 |     | <span class='neutral'>    // Analogous to readTransactions, but for receipts.</span>
 437 |     | <span class='neutral'>    function readReceipts(string memory path) internal view virtual returns (Receipt[] memory) {</span>
 438 |     | <span class='neutral'>        string memory deployData = vm.readFile(path);</span>
 439 |     | <span class='neutral'>        bytes memory parsedDeployData = vm.parseJson(deployData, &quot;.receipts&quot;);</span>
 440 |     | <span class='neutral'>        RawReceipt[] memory rawReceipts = abi.decode(parsedDeployData, (RawReceipt[]));</span>
 441 |     | <span class='neutral'>        return rawToConvertedReceipts(rawReceipts);</span>
 442 |     | <span class='neutral'>    }</span>
 443 |     | <span class='neutral'></span>
 444 |     | <span class='neutral'>    function readReceipt(string memory path, uint256 index) internal view virtual returns (Receipt memory) {</span>
 445 |     | <span class='neutral'>        string memory deployData = vm.readFile(path);</span>
 446 |     | <span class='neutral'>        string memory key = string(abi.encodePacked(&quot;.receipts[&quot;, vm.toString(index), &quot;]&quot;));</span>
 447 |     | <span class='neutral'>        bytes memory parsedDeployData = vm.parseJson(deployData, key);</span>
 448 |     | <span class='neutral'>        RawReceipt memory rawReceipt = abi.decode(parsedDeployData, (RawReceipt));</span>
 449 |     | <span class='neutral'>        return rawToConvertedReceipt(rawReceipt);</span>
 450 |     | <span class='neutral'>    }</span>
 451 |     | <span class='neutral'></span>
 452 |     | <span class='neutral'>    function rawToConvertedReceipts(RawReceipt[] memory rawReceipts) internal pure virtual returns (Receipt[] memory) {</span>
 453 |     | <span class='neutral'>        Receipt[] memory receipts = new Receipt[](rawReceipts.length);</span>
 454 |     | <span class='neutral'>        for (uint256 i; i &lt; rawReceipts.length; i++) {</span>
 455 |     | <span class='neutral'>            receipts[i] = rawToConvertedReceipt(rawReceipts[i]);</span>
 456 |     | <span class='neutral'>        }</span>
 457 |     | <span class='neutral'>        return receipts;</span>
 458 |     | <span class='neutral'>    }</span>
 459 |     | <span class='neutral'></span>
 460 |     | <span class='neutral'>    function rawToConvertedReceipt(RawReceipt memory rawReceipt) internal pure virtual returns (Receipt memory) {</span>
 461 |     | <span class='neutral'>        Receipt memory receipt;</span>
 462 |     | <span class='neutral'>        receipt.blockHash = rawReceipt.blockHash;</span>
 463 |     | <span class='neutral'>        receipt.to = rawReceipt.to;</span>
 464 |     | <span class='neutral'>        receipt.from = rawReceipt.from;</span>
 465 |     | <span class='neutral'>        receipt.contractAddress = rawReceipt.contractAddress;</span>
 466 |     | <span class='neutral'>        receipt.effectiveGasPrice = _bytesToUint(rawReceipt.effectiveGasPrice);</span>
 467 |     | <span class='neutral'>        receipt.cumulativeGasUsed = _bytesToUint(rawReceipt.cumulativeGasUsed);</span>
 468 |     | <span class='neutral'>        receipt.gasUsed = _bytesToUint(rawReceipt.gasUsed);</span>
 469 |     | <span class='neutral'>        receipt.status = _bytesToUint(rawReceipt.status);</span>
 470 |     | <span class='neutral'>        receipt.transactionIndex = _bytesToUint(rawReceipt.transactionIndex);</span>
 471 |     | <span class='neutral'>        receipt.blockNumber = _bytesToUint(rawReceipt.blockNumber);</span>
 472 |     | <span class='neutral'>        receipt.logs = rawToConvertedReceiptLogs(rawReceipt.logs);</span>
 473 |     | <span class='neutral'>        receipt.logsBloom = rawReceipt.logsBloom;</span>
 474 |     | <span class='neutral'>        receipt.transactionHash = rawReceipt.transactionHash;</span>
 475 |     | <span class='neutral'>        return receipt;</span>
 476 |     | <span class='neutral'>    }</span>
 477 |     | <span class='neutral'></span>
 478 |     | <span class='neutral'>    function rawToConvertedReceiptLogs(RawReceiptLog[] memory rawLogs)</span>
 479 |     | <span class='neutral'>        internal</span>
 480 |     | <span class='neutral'>        pure</span>
 481 |     | <span class='neutral'>        virtual</span>
 482 |     | <span class='neutral'>        returns (ReceiptLog[] memory)</span>
 483 |     | <span class='neutral'>    {</span>
 484 |     | <span class='neutral'>        ReceiptLog[] memory logs = new ReceiptLog[](rawLogs.length);</span>
 485 |     | <span class='neutral'>        for (uint256 i; i &lt; rawLogs.length; i++) {</span>
 486 |     | <span class='neutral'>            logs[i].logAddress = rawLogs[i].logAddress;</span>
 487 |     | <span class='neutral'>            logs[i].blockHash = rawLogs[i].blockHash;</span>
 488 |     | <span class='neutral'>            logs[i].blockNumber = _bytesToUint(rawLogs[i].blockNumber);</span>
 489 |     | <span class='neutral'>            logs[i].data = rawLogs[i].data;</span>
 490 |     | <span class='neutral'>            logs[i].logIndex = _bytesToUint(rawLogs[i].logIndex);</span>
 491 |     | <span class='neutral'>            logs[i].topics = rawLogs[i].topics;</span>
 492 |     | <span class='neutral'>            logs[i].transactionIndex = _bytesToUint(rawLogs[i].transactionIndex);</span>
 493 |     | <span class='neutral'>            logs[i].transactionLogIndex = _bytesToUint(rawLogs[i].transactionLogIndex);</span>
 494 |     | <span class='neutral'>            logs[i].removed = rawLogs[i].removed;</span>
 495 |     | <span class='neutral'>        }</span>
 496 |     | <span class='neutral'>        return logs;</span>
 497 |     | <span class='neutral'>    }</span>
 498 |     | <span class='neutral'></span>
 499 |     | <span class='neutral'>    // Deploy a contract by fetching the contract bytecode from</span>
 500 |     | <span class='neutral'>    // the artifacts directory</span>
 501 |     | <span class='neutral'>    // e.g. `deployCode(code, abi.encode(arg1,arg2,arg3))`</span>
 502 |     | <span class='neutral'>    function deployCode(string memory what, bytes memory args) internal virtual returns (address addr) {</span>
 503 |     | <span class='neutral'>        bytes memory bytecode = abi.encodePacked(vm.getCode(what), args);</span>
 504 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 505 |     | <span class='neutral'>        assembly {</span>
 506 |     | <span class='neutral'>            addr := create(0, add(bytecode, 0x20), mload(bytecode))</span>
 507 |     | <span class='neutral'>        }</span>
 508 |     | <span class='neutral'></span>
 509 |     | <span class='neutral'>        require(addr != address(0), &quot;StdCheats deployCode(string,bytes): Deployment failed.&quot;);</span>
 510 |     | <span class='neutral'>    }</span>
 511 |     | <span class='neutral'></span>
 512 |     | <span class='neutral'>    function deployCode(string memory what) internal virtual returns (address addr) {</span>
 513 |     | <span class='neutral'>        bytes memory bytecode = vm.getCode(what);</span>
 514 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 515 |     | <span class='neutral'>        assembly {</span>
 516 |     | <span class='neutral'>            addr := create(0, add(bytecode, 0x20), mload(bytecode))</span>
 517 |     | <span class='neutral'>        }</span>
 518 |     | <span class='neutral'></span>
 519 |     | <span class='neutral'>        require(addr != address(0), &quot;StdCheats deployCode(string): Deployment failed.&quot;);</span>
 520 |     | <span class='neutral'>    }</span>
 521 |     | <span class='neutral'></span>
 522 |     | <span class='neutral'>    /// @dev deploy contract with value on construction</span>
 523 |     | <span class='neutral'>    function deployCode(string memory what, bytes memory args, uint256 val) internal virtual returns (address addr) {</span>
 524 |     | <span class='neutral'>        bytes memory bytecode = abi.encodePacked(vm.getCode(what), args);</span>
 525 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 526 |     | <span class='neutral'>        assembly {</span>
 527 |     | <span class='neutral'>            addr := create(val, add(bytecode, 0x20), mload(bytecode))</span>
 528 |     | <span class='neutral'>        }</span>
 529 |     | <span class='neutral'></span>
 530 |     | <span class='neutral'>        require(addr != address(0), &quot;StdCheats deployCode(string,bytes,uint256): Deployment failed.&quot;);</span>
 531 |     | <span class='neutral'>    }</span>
 532 |     | <span class='neutral'></span>
 533 |     | <span class='neutral'>    function deployCode(string memory what, uint256 val) internal virtual returns (address addr) {</span>
 534 |     | <span class='neutral'>        bytes memory bytecode = vm.getCode(what);</span>
 535 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 536 |     | <span class='neutral'>        assembly {</span>
 537 |     | <span class='neutral'>            addr := create(val, add(bytecode, 0x20), mload(bytecode))</span>
 538 |     | <span class='neutral'>        }</span>
 539 |     | <span class='neutral'></span>
 540 |     | <span class='neutral'>        require(addr != address(0), &quot;StdCheats deployCode(string,uint256): Deployment failed.&quot;);</span>
 541 |     | <span class='neutral'>    }</span>
 542 |     | <span class='neutral'></span>
 543 |     | <span class='neutral'>    // creates a labeled address and the corresponding private key</span>
 544 |     | <span class='unexecuted'>    function makeAddrAndKey(string memory name) internal virtual returns (address addr, uint256 privateKey) {</span>
 545 |     | <span class='unexecuted'>        privateKey = uint256(keccak256(abi.encodePacked(name)));</span>
 546 |     | <span class='unexecuted'>        addr = vm.addr(privateKey);</span>
 547 |     | <span class='unexecuted'>        vm.label(addr, name);</span>
 548 |     | <span class='neutral'>    }</span>
 549 |     | <span class='neutral'></span>
 550 |     | <span class='neutral'>    // creates a labeled address</span>
 551 |     | <span class='unexecuted'>    function makeAddr(string memory name) internal virtual returns (address addr) {</span>
 552 |     | <span class='unexecuted'>        (addr,) = makeAddrAndKey(name);</span>
 553 |     | <span class='neutral'>    }</span>
 554 |     | <span class='neutral'></span>
 555 |     | <span class='neutral'>    // Destroys an account immediately, sending the balance to beneficiary.</span>
 556 |     | <span class='neutral'>    // Destroying means: balance will be zero, code will be empty, and nonce will be 0</span>
 557 |     | <span class='neutral'>    // This is similar to selfdestruct but not identical: selfdestruct destroys code and nonce</span>
 558 |     | <span class='neutral'>    // only after tx ends, this will run immediately.</span>
 559 |     | <span class='neutral'>    function destroyAccount(address who, address beneficiary) internal virtual {</span>
 560 |     | <span class='neutral'>        uint256 currBalance = who.balance;</span>
 561 |     | <span class='neutral'>        vm.etch(who, abi.encode());</span>
 562 |     | <span class='neutral'>        vm.deal(who, 0);</span>
 563 |     | <span class='neutral'>        vm.resetNonce(who);</span>
 564 |     | <span class='neutral'></span>
 565 |     | <span class='neutral'>        uint256 beneficiaryBalance = beneficiary.balance;</span>
 566 |     | <span class='neutral'>        vm.deal(beneficiary, currBalance + beneficiaryBalance);</span>
 567 |     | <span class='neutral'>    }</span>
 568 |     | <span class='neutral'></span>
 569 |     | <span class='neutral'>    // creates a struct containing both a labeled address and the corresponding private key</span>
 570 |     | <span class='neutral'>    function makeAccount(string memory name) internal virtual returns (Account memory account) {</span>
 571 |     | <span class='neutral'>        (account.addr, account.key) = makeAddrAndKey(name);</span>
 572 |     | <span class='neutral'>    }</span>
 573 |     | <span class='neutral'></span>
 574 |     | <span class='neutral'>    function deriveRememberKey(string memory mnemonic, uint32 index)</span>
 575 |     | <span class='neutral'>        internal</span>
 576 |     | <span class='neutral'>        virtual</span>
 577 |     | <span class='neutral'>        returns (address who, uint256 privateKey)</span>
 578 |     | <span class='neutral'>    {</span>
 579 |     | <span class='neutral'>        privateKey = vm.deriveKey(mnemonic, index);</span>
 580 |     | <span class='neutral'>        who = vm.rememberKey(privateKey);</span>
 581 |     | <span class='neutral'>    }</span>
 582 |     | <span class='neutral'></span>
 583 |     | <span class='neutral'>    function _bytesToUint(bytes memory b) private pure returns (uint256) {</span>
 584 |     | <span class='neutral'>        require(b.length &lt;= 32, &quot;StdCheats _bytesToUint(bytes): Bytes length exceeds 32.&quot;);</span>
 585 |     | <span class='neutral'>        return abi.decode(abi.encodePacked(new bytes(32 - b.length), b), (uint256));</span>
 586 |     | <span class='neutral'>    }</span>
 587 |     | <span class='neutral'></span>
 588 |     | <span class='neutral'>    function isFork() internal view virtual returns (bool status) {</span>
 589 |     | <span class='neutral'>        try vm.activeFork() {</span>
 590 |     | <span class='neutral'>            status = true;</span>
 591 |     | <span class='neutral'>        } catch (bytes memory) {}</span>
 592 |     | <span class='neutral'>    }</span>
 593 |     | <span class='neutral'></span>
 594 |     | <span class='neutral'>    modifier skipWhenForking() {</span>
 595 |     | <span class='neutral'>        if (!isFork()) {</span>
 596 |     | <span class='neutral'>            _;</span>
 597 |     | <span class='neutral'>        }</span>
 598 |     | <span class='neutral'>    }</span>
 599 |     | <span class='neutral'></span>
 600 |     | <span class='neutral'>    modifier skipWhenNotForking() {</span>
 601 |     | <span class='neutral'>        if (isFork()) {</span>
 602 |     | <span class='neutral'>            _;</span>
 603 |     | <span class='neutral'>        }</span>
 604 |     | <span class='neutral'>    }</span>
 605 |     | <span class='neutral'></span>
 606 |     | <span class='neutral'>    modifier noGasMetering() {</span>
 607 |     | <span class='neutral'>        vm.pauseGasMetering();</span>
 608 |     | <span class='neutral'>        // To prevent turning gas monitoring back on with nested functions that use this modifier,</span>
 609 |     | <span class='neutral'>        // we check if gasMetering started in the off position. If it did, we don&#39;t want to turn</span>
 610 |     | <span class='neutral'>        // it back on until we exit the top level function that used the modifier</span>
 611 |     | <span class='neutral'>        //</span>
 612 |     | <span class='neutral'>        // i.e. funcA() noGasMetering { funcB() }, where funcB has noGasMetering as well.</span>
 613 |     | <span class='neutral'>        // funcA will have `gasStartedOff` as false, funcB will have it as true,</span>
 614 |     | <span class='neutral'>        // so we only turn metering back on at the end of the funcA</span>
 615 |     | <span class='neutral'>        bool gasStartedOff = gasMeteringOff;</span>
 616 |     | <span class='neutral'>        gasMeteringOff = true;</span>
 617 |     | <span class='neutral'></span>
 618 |     | <span class='neutral'>        _;</span>
 619 |     | <span class='neutral'></span>
 620 |     | <span class='neutral'>        // if gas metering was on when this modifier was called, turn it back on at the end</span>
 621 |     | <span class='neutral'>        if (!gasStartedOff) {</span>
 622 |     | <span class='neutral'>            gasMeteringOff = false;</span>
 623 |     | <span class='neutral'>            vm.resumeGasMetering();</span>
 624 |     | <span class='neutral'>        }</span>
 625 |     | <span class='neutral'>    }</span>
 626 |     | <span class='neutral'></span>
 627 |     | <span class='neutral'>    // We use this complex approach of `_viewChainId` and `_pureChainId` to ensure there are no</span>
 628 |     | <span class='neutral'>    // compiler warnings when accessing chain ID in any solidity version supported by forge-std. We</span>
 629 |     | <span class='neutral'>    // can&#39;t simply access the chain ID in a normal view or pure function because the solc View Pure</span>
 630 |     | <span class='neutral'>    // Checker changed `chainid` from pure to view in 0.8.0.</span>
 631 |     | <span class='neutral'>    function _viewChainId() private view returns (uint256 chainId) {</span>
 632 |     | <span class='neutral'>        // Assembly required since `block.chainid` was introduced in 0.8.0.</span>
 633 |     | <span class='neutral'>        assembly {</span>
 634 |     | <span class='neutral'>            chainId := chainid()</span>
 635 |     | <span class='neutral'>        }</span>
 636 |     | <span class='neutral'></span>
 637 |     | <span class='neutral'>        address(this); // Silence warnings in older Solc versions.</span>
 638 |     | <span class='neutral'>    }</span>
 639 |     | <span class='neutral'></span>
 640 |     | <span class='neutral'>    function _pureChainId() private pure returns (uint256 chainId) {</span>
 641 |     | <span class='neutral'>        function() internal view returns (uint256) fnIn = _viewChainId;</span>
 642 |     | <span class='neutral'>        function() internal pure returns (uint256) pureChainId;</span>
 643 |     | <span class='neutral'>        assembly {</span>
 644 |     | <span class='neutral'>            pureChainId := fnIn</span>
 645 |     | <span class='neutral'>        }</span>
 646 |     | <span class='neutral'>        chainId = pureChainId();</span>
 647 |     | <span class='neutral'>    }</span>
 648 |     | <span class='neutral'>}</span>
 649 |     | <span class='neutral'></span>
 650 |     | <span class='neutral'>// Wrappers around cheatcodes to avoid footguns</span>
 651 |     | <span class='neutral'>abstract contract StdCheats is StdCheatsSafe {</span>
 652 |     | <span class='neutral'>    using stdStorage for StdStorage;</span>
 653 |     | <span class='neutral'></span>
 654 |     | <span class='neutral'>    StdStorage private stdstore;</span>
 655 |     | <span class='neutral'>    Vm private constant vm = Vm(address(uint160(uint256(keccak256(&quot;hevm cheat code&quot;)))));</span>
 656 |     | <span class='neutral'>    address private constant CONSOLE2_ADDRESS = 0x000000000000000000636F6e736F6c652e6c6f67;</span>
 657 |     | <span class='neutral'></span>
 658 |     | <span class='neutral'>    // Skip forward or rewind time by the specified number of seconds</span>
 659 |     | <span class='neutral'>    function skip(uint256 time) internal virtual {</span>
 660 |     | <span class='neutral'>        vm.warp(vm.getBlockTimestamp() + time);</span>
 661 |     | <span class='neutral'>    }</span>
 662 |     | <span class='neutral'></span>
 663 |     | <span class='neutral'>    function rewind(uint256 time) internal virtual {</span>
 664 |     | <span class='neutral'>        vm.warp(vm.getBlockTimestamp() - time);</span>
 665 |     | <span class='neutral'>    }</span>
 666 |     | <span class='neutral'></span>
 667 |     | <span class='neutral'>    // Setup a prank from an address that has some ether</span>
 668 |     | <span class='neutral'>    function hoax(address msgSender) internal virtual {</span>
 669 |     | <span class='neutral'>        vm.deal(msgSender, 1 &lt;&lt; 128);</span>
 670 |     | <span class='neutral'>        vm.prank(msgSender);</span>
 671 |     | <span class='neutral'>    }</span>
 672 |     | <span class='neutral'></span>
 673 |     | <span class='neutral'>    function hoax(address msgSender, uint256 give) internal virtual {</span>
 674 |     | <span class='neutral'>        vm.deal(msgSender, give);</span>
 675 |     | <span class='neutral'>        vm.prank(msgSender);</span>
 676 |     | <span class='neutral'>    }</span>
 677 |     | <span class='neutral'></span>
 678 |     | <span class='neutral'>    function hoax(address msgSender, address origin) internal virtual {</span>
 679 |     | <span class='neutral'>        vm.deal(msgSender, 1 &lt;&lt; 128);</span>
 680 |     | <span class='neutral'>        vm.prank(msgSender, origin);</span>
 681 |     | <span class='neutral'>    }</span>
 682 |     | <span class='neutral'></span>
 683 |     | <span class='neutral'>    function hoax(address msgSender, address origin, uint256 give) internal virtual {</span>
 684 |     | <span class='neutral'>        vm.deal(msgSender, give);</span>
 685 |     | <span class='neutral'>        vm.prank(msgSender, origin);</span>
 686 |     | <span class='neutral'>    }</span>
 687 |     | <span class='neutral'></span>
 688 |     | <span class='neutral'>    // Start perpetual prank from an address that has some ether</span>
 689 |     | <span class='neutral'>    function startHoax(address msgSender) internal virtual {</span>
 690 |     | <span class='neutral'>        vm.deal(msgSender, 1 &lt;&lt; 128);</span>
 691 |     | <span class='neutral'>        vm.startPrank(msgSender);</span>
 692 |     | <span class='neutral'>    }</span>
 693 |     | <span class='neutral'></span>
 694 |     | <span class='neutral'>    function startHoax(address msgSender, uint256 give) internal virtual {</span>
 695 |     | <span class='neutral'>        vm.deal(msgSender, give);</span>
 696 |     | <span class='neutral'>        vm.startPrank(msgSender);</span>
 697 |     | <span class='neutral'>    }</span>
 698 |     | <span class='neutral'></span>
 699 |     | <span class='neutral'>    // Start perpetual prank from an address that has some ether</span>
 700 |     | <span class='neutral'>    // tx.origin is set to the origin parameter</span>
 701 |     | <span class='neutral'>    function startHoax(address msgSender, address origin) internal virtual {</span>
 702 |     | <span class='neutral'>        vm.deal(msgSender, 1 &lt;&lt; 128);</span>
 703 |     | <span class='neutral'>        vm.startPrank(msgSender, origin);</span>
 704 |     | <span class='neutral'>    }</span>
 705 |     | <span class='neutral'></span>
 706 |     | <span class='neutral'>    function startHoax(address msgSender, address origin, uint256 give) internal virtual {</span>
 707 |     | <span class='neutral'>        vm.deal(msgSender, give);</span>
 708 |     | <span class='neutral'>        vm.startPrank(msgSender, origin);</span>
 709 |     | <span class='neutral'>    }</span>
 710 |     | <span class='neutral'></span>
 711 |     | <span class='neutral'>    function changePrank(address msgSender) internal virtual {</span>
 712 |     | <span class='neutral'>        console2_log_StdCheats(&quot;changePrank is deprecated. Please use vm.startPrank instead.&quot;);</span>
 713 |     | <span class='neutral'>        vm.stopPrank();</span>
 714 |     | <span class='neutral'>        vm.startPrank(msgSender);</span>
 715 |     | <span class='neutral'>    }</span>
 716 |     | <span class='neutral'></span>
 717 |     | <span class='neutral'>    function changePrank(address msgSender, address txOrigin) internal virtual {</span>
 718 |     | <span class='neutral'>        vm.stopPrank();</span>
 719 |     | <span class='neutral'>        vm.startPrank(msgSender, txOrigin);</span>
 720 |     | <span class='neutral'>    }</span>
 721 |     | <span class='neutral'></span>
 722 |     | <span class='neutral'>    // The same as Vm&#39;s `deal`</span>
 723 |     | <span class='neutral'>    // Use the alternative signature for ERC20 tokens</span>
 724 |     | <span class='neutral'>    function deal(address to, uint256 give) internal virtual {</span>
 725 |     | <span class='neutral'>        vm.deal(to, give);</span>
 726 |     | <span class='neutral'>    }</span>
 727 |     | <span class='neutral'></span>
 728 |     | <span class='neutral'>    // Set the balance of an account for any ERC20 token</span>
 729 |     | <span class='neutral'>    // Use the alternative signature to update `totalSupply`</span>
 730 |     | <span class='neutral'>    function deal(address token, address to, uint256 give) internal virtual {</span>
 731 |     | <span class='neutral'>        deal(token, to, give, false);</span>
 732 |     | <span class='neutral'>    }</span>
 733 |     | <span class='neutral'></span>
 734 |     | <span class='neutral'>    // Set the balance of an account for any ERC1155 token</span>
 735 |     | <span class='neutral'>    // Use the alternative signature to update `totalSupply`</span>
 736 |     | <span class='neutral'>    function dealERC1155(address token, address to, uint256 id, uint256 give) internal virtual {</span>
 737 |     | <span class='neutral'>        dealERC1155(token, to, id, give, false);</span>
 738 |     | <span class='neutral'>    }</span>
 739 |     | <span class='neutral'></span>
 740 |     | <span class='neutral'>    function deal(address token, address to, uint256 give, bool adjust) internal virtual {</span>
 741 |     | <span class='neutral'>        // get current balance</span>
 742 |     | <span class='neutral'>        (, bytes memory balData) = token.staticcall(abi.encodeWithSelector(0x70a08231, to));</span>
 743 |     | <span class='neutral'>        uint256 prevBal = abi.decode(balData, (uint256));</span>
 744 |     | <span class='neutral'></span>
 745 |     | <span class='neutral'>        // update balance</span>
 746 |     | <span class='neutral'>        stdstore.target(token).sig(0x70a08231).with_key(to).checked_write(give);</span>
 747 |     | <span class='neutral'></span>
 748 |     | <span class='neutral'>        // update total supply</span>
 749 |     | <span class='neutral'>        if (adjust) {</span>
 750 |     | <span class='neutral'>            (, bytes memory totSupData) = token.staticcall(abi.encodeWithSelector(0x18160ddd));</span>
 751 |     | <span class='neutral'>            uint256 totSup = abi.decode(totSupData, (uint256));</span>
 752 |     | <span class='neutral'>            if (give &lt; prevBal) {</span>
 753 |     | <span class='neutral'>                totSup -= (prevBal - give);</span>
 754 |     | <span class='neutral'>            } else {</span>
 755 |     | <span class='neutral'>                totSup += (give - prevBal);</span>
 756 |     | <span class='neutral'>            }</span>
 757 |     | <span class='neutral'>            stdstore.target(token).sig(0x18160ddd).checked_write(totSup);</span>
 758 |     | <span class='neutral'>        }</span>
 759 |     | <span class='neutral'>    }</span>
 760 |     | <span class='neutral'></span>
 761 |     | <span class='neutral'>    function dealERC1155(address token, address to, uint256 id, uint256 give, bool adjust) internal virtual {</span>
 762 |     | <span class='neutral'>        // get current balance</span>
 763 |     | <span class='neutral'>        (, bytes memory balData) = token.staticcall(abi.encodeWithSelector(0x00fdd58e, to, id));</span>
 764 |     | <span class='neutral'>        uint256 prevBal = abi.decode(balData, (uint256));</span>
 765 |     | <span class='neutral'></span>
 766 |     | <span class='neutral'>        // update balance</span>
 767 |     | <span class='neutral'>        stdstore.target(token).sig(0x00fdd58e).with_key(to).with_key(id).checked_write(give);</span>
 768 |     | <span class='neutral'></span>
 769 |     | <span class='neutral'>        // update total supply</span>
 770 |     | <span class='neutral'>        if (adjust) {</span>
 771 |     | <span class='neutral'>            (, bytes memory totSupData) = token.staticcall(abi.encodeWithSelector(0xbd85b039, id));</span>
 772 |     | <span class='neutral'>            require(</span>
 773 |     | <span class='neutral'>                totSupData.length != 0,</span>
 774 |     | <span class='neutral'>                &quot;StdCheats deal(address,address,uint,uint,bool): target contract is not ERC1155Supply.&quot;</span>
 775 |     | <span class='neutral'>            );</span>
 776 |     | <span class='neutral'>            uint256 totSup = abi.decode(totSupData, (uint256));</span>
 777 |     | <span class='neutral'>            if (give &lt; prevBal) {</span>
 778 |     | <span class='neutral'>                totSup -= (prevBal - give);</span>
 779 |     | <span class='neutral'>            } else {</span>
 780 |     | <span class='neutral'>                totSup += (give - prevBal);</span>
 781 |     | <span class='neutral'>            }</span>
 782 |     | <span class='neutral'>            stdstore.target(token).sig(0xbd85b039).with_key(id).checked_write(totSup);</span>
 783 |     | <span class='neutral'>        }</span>
 784 |     | <span class='neutral'>    }</span>
 785 |     | <span class='neutral'></span>
 786 |     | <span class='neutral'>    function dealERC721(address token, address to, uint256 id) internal virtual {</span>
 787 |     | <span class='neutral'>        // check if token id is already minted and the actual owner.</span>
 788 |     | <span class='neutral'>        (bool successMinted, bytes memory ownerData) = token.staticcall(abi.encodeWithSelector(0x6352211e, id));</span>
 789 |     | <span class='neutral'>        require(successMinted, &quot;StdCheats deal(address,address,uint,bool): id not minted.&quot;);</span>
 790 |     | <span class='neutral'></span>
 791 |     | <span class='neutral'>        // get owner current balance</span>
 792 |     | <span class='neutral'>        (, bytes memory fromBalData) =</span>
 793 |     | <span class='neutral'>            token.staticcall(abi.encodeWithSelector(0x70a08231, abi.decode(ownerData, (address))));</span>
 794 |     | <span class='neutral'>        uint256 fromPrevBal = abi.decode(fromBalData, (uint256));</span>
 795 |     | <span class='neutral'></span>
 796 |     | <span class='neutral'>        // get new user current balance</span>
 797 |     | <span class='neutral'>        (, bytes memory toBalData) = token.staticcall(abi.encodeWithSelector(0x70a08231, to));</span>
 798 |     | <span class='neutral'>        uint256 toPrevBal = abi.decode(toBalData, (uint256));</span>
 799 |     | <span class='neutral'></span>
 800 |     | <span class='neutral'>        // update balances</span>
 801 |     | <span class='neutral'>        stdstore.target(token).sig(0x70a08231).with_key(abi.decode(ownerData, (address))).checked_write(--fromPrevBal);</span>
 802 |     | <span class='neutral'>        stdstore.target(token).sig(0x70a08231).with_key(to).checked_write(++toPrevBal);</span>
 803 |     | <span class='neutral'></span>
 804 |     | <span class='neutral'>        // update owner</span>
 805 |     | <span class='neutral'>        stdstore.target(token).sig(0x6352211e).with_key(id).checked_write(to);</span>
 806 |     | <span class='neutral'>    }</span>
 807 |     | <span class='neutral'></span>
 808 |     | <span class='neutral'>    function deployCodeTo(string memory what, address where) internal virtual {</span>
 809 |     | <span class='neutral'>        deployCodeTo(what, &quot;&quot;, 0, where);</span>
 810 |     | <span class='neutral'>    }</span>
 811 |     | <span class='neutral'></span>
 812 |     | <span class='neutral'>    function deployCodeTo(string memory what, bytes memory args, address where) internal virtual {</span>
 813 |     | <span class='neutral'>        deployCodeTo(what, args, 0, where);</span>
 814 |     | <span class='neutral'>    }</span>
 815 |     | <span class='neutral'></span>
 816 |     | <span class='neutral'>    function deployCodeTo(string memory what, bytes memory args, uint256 value, address where) internal virtual {</span>
 817 |     | <span class='neutral'>        bytes memory creationCode = vm.getCode(what);</span>
 818 |     | <span class='neutral'>        vm.etch(where, abi.encodePacked(creationCode, args));</span>
 819 |     | <span class='neutral'>        (bool success, bytes memory runtimeBytecode) = where.call{value: value}(&quot;&quot;);</span>
 820 |     | <span class='neutral'>        require(success, &quot;StdCheats deployCodeTo(string,bytes,uint256,address): Failed to create runtime bytecode.&quot;);</span>
 821 |     | <span class='neutral'>        vm.etch(where, runtimeBytecode);</span>
 822 |     | <span class='neutral'>    }</span>
 823 |     | <span class='neutral'></span>
 824 |     | <span class='neutral'>    // Used to prevent the compilation of console, which shortens the compilation time when console is not used elsewhere.</span>
 825 |     | <span class='neutral'>    function console2_log_StdCheats(string memory p0) private view {</span>
 826 |     | <span class='neutral'>        (bool status,) = address(CONSOLE2_ADDRESS).staticcall(abi.encodeWithSignature(&quot;log(string)&quot;, p0));</span>
 827 |     | <span class='neutral'>        status;</span>
 828 |     | <span class='neutral'>    }</span>
 829 |     | <span class='neutral'>}</span>
 830 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/phantom/Documents/azemora/azemora-contracts/lib/forge-std/src/StdConstants.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>pragma solidity &gt;=0.6.2 &lt;0.9.0;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>import {IMulticall3} from &quot;./interfaces/IMulticall3.sol&quot;;</span>
  5 |     | <span class='neutral'>import {Vm} from &quot;./Vm.sol&quot;;</span>
  6 |     | <span class='neutral'></span>
  7 |     | <span class='unexecuted'>library StdConstants {</span>
  8 |     | <span class='neutral'>    /// @dev Cheat code address.</span>
  9 |     | <span class='neutral'>    /// Calculated as `address(uint160(uint256(keccak256(&quot;hevm cheat code&quot;))))`.</span>
 10 |     | <span class='neutral'>    Vm internal constant VM = Vm(0x7109709ECfa91a80626fF3989D68f67F5b1DD12D);</span>
 11 |     | <span class='neutral'>    /// @dev console.sol and console2.sol work by executing a staticcall to this address.</span>
 12 |     | <span class='neutral'>    /// Calculated as `address(uint160(uint88(bytes11(&quot;console.log&quot;))))`.</span>
 13 |     | <span class='neutral'>    address internal constant CONSOLE = 0x000000000000000000636F6e736F6c652e6c6f67;</span>
 14 |     | <span class='neutral'>    /// @dev Used when deploying with create2.</span>
 15 |     | <span class='neutral'>    /// Taken from https://github.com/Arachnid/deterministic-deployment-proxy.</span>
 16 |     | <span class='neutral'>    address internal constant CREATE2_FACTORY = 0x4e59b44847b379578588920cA78FbF26c0B4956C;</span>
 17 |     | <span class='neutral'>    /// @dev The default address for tx.origin and msg.sender.</span>
 18 |     | <span class='neutral'>    /// Calculated as `address(uint160(uint256(keccak256(&quot;foundry default caller&quot;))))`.</span>
 19 |     | <span class='neutral'>    address internal constant DEFAULT_SENDER = 0x1804c8AB1F12E6bbf3894d4083f33e07309d1f38;</span>
 20 |     | <span class='neutral'>    /// @dev The address of the first contract `CREATE`d by a running test contract.</span>
 21 |     | <span class='neutral'>    /// When running tests, each test contract is `CREATE`d by `DEFAULT_SENDER` with nonce 1.</span>
 22 |     | <span class='neutral'>    /// Calculated as `VM.computeCreateAddress(VM.computeCreateAddress(DEFAULT_SENDER, 1), 1)`.</span>
 23 |     | <span class='neutral'>    address internal constant DEFAULT_TEST_CONTRACT = 0x5615dEB798BB3E4dFa0139dFa1b3D433Cc23b72f;</span>
 24 |     | <span class='neutral'>    /// @dev Deterministic deployment address of the Multicall3 contract.</span>
 25 |     | <span class='neutral'>    /// Taken from https://www.multicall3.com.</span>
 26 |     | <span class='neutral'>    IMulticall3 internal constant MULTICALL3_ADDRESS = IMulticall3(0xcA11bde05977b3631167028862bE2a173976CA11);</span>
 27 |     | <span class='neutral'>    /// @dev The order of the secp256k1 curve.</span>
 28 |     | <span class='neutral'>    uint256 internal constant SECP256K1_ORDER =</span>
 29 |     | <span class='neutral'>        115792089237316195423570985008687907852837564279074904382605163141518161494337;</span>
 30 |     | <span class='neutral'>}</span>
 31 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/phantom/Documents/azemora/azemora-contracts/lib/forge-std/src/StdError.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>// Panics work for versions &gt;=0.8.0, but we lowered the pragma to make this compatible with Test</span>
  3 |     | <span class='neutral'>pragma solidity &gt;=0.6.2 &lt;0.9.0;</span>
  4 |     | <span class='neutral'></span>
  5 |     | <span class='unexecuted'>library stdError {</span>
  6 |     | <span class='unexecuted'>    bytes public constant assertionError = abi.encodeWithSignature(&quot;Panic(uint256)&quot;, 0x01);</span>
  7 |     | <span class='unexecuted'>    bytes public constant arithmeticError = abi.encodeWithSignature(&quot;Panic(uint256)&quot;, 0x11);</span>
  8 |     | <span class='unexecuted'>    bytes public constant divisionError = abi.encodeWithSignature(&quot;Panic(uint256)&quot;, 0x12);</span>
  9 |     | <span class='unexecuted'>    bytes public constant enumConversionError = abi.encodeWithSignature(&quot;Panic(uint256)&quot;, 0x21);</span>
 10 |     | <span class='unexecuted'>    bytes public constant encodeStorageError = abi.encodeWithSignature(&quot;Panic(uint256)&quot;, 0x22);</span>
 11 |     | <span class='unexecuted'>    bytes public constant popError = abi.encodeWithSignature(&quot;Panic(uint256)&quot;, 0x31);</span>
 12 |     | <span class='unexecuted'>    bytes public constant indexOOBError = abi.encodeWithSignature(&quot;Panic(uint256)&quot;, 0x32);</span>
 13 |     | <span class='unexecuted'>    bytes public constant memOverflowError = abi.encodeWithSignature(&quot;Panic(uint256)&quot;, 0x41);</span>
 14 |     | <span class='unexecuted'>    bytes public constant zeroVarError = abi.encodeWithSignature(&quot;Panic(uint256)&quot;, 0x51);</span>
 15 |     | <span class='neutral'>}</span>
 16 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/phantom/Documents/azemora/azemora-contracts/lib/forge-std/src/StdInvariant.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'>pragma solidity &gt;=0.6.2 &lt;0.9.0;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>pragma experimental ABIEncoderV2;</span>
   5 |     | <span class='neutral'></span>
   6 |     | <span class='neutral'>abstract contract StdInvariant {</span>
   7 |     | <span class='neutral'>    struct FuzzSelector {</span>
   8 |     | <span class='neutral'>        address addr;</span>
   9 |     | <span class='neutral'>        bytes4[] selectors;</span>
  10 |     | <span class='neutral'>    }</span>
  11 |     | <span class='neutral'></span>
  12 |     | <span class='neutral'>    struct FuzzArtifactSelector {</span>
  13 |     | <span class='neutral'>        string artifact;</span>
  14 |     | <span class='neutral'>        bytes4[] selectors;</span>
  15 |     | <span class='neutral'>    }</span>
  16 |     | <span class='neutral'></span>
  17 |     | <span class='neutral'>    struct FuzzInterface {</span>
  18 |     | <span class='neutral'>        address addr;</span>
  19 |     | <span class='neutral'>        string[] artifacts;</span>
  20 |     | <span class='neutral'>    }</span>
  21 |     | <span class='neutral'></span>
  22 |     | <span class='neutral'>    address[] private _excludedContracts;</span>
  23 |     | <span class='neutral'>    address[] private _excludedSenders;</span>
  24 |     | <span class='neutral'>    address[] private _targetedContracts;</span>
  25 |     | <span class='neutral'>    address[] private _targetedSenders;</span>
  26 |     | <span class='neutral'></span>
  27 |     | <span class='neutral'>    string[] private _excludedArtifacts;</span>
  28 |     | <span class='neutral'>    string[] private _targetedArtifacts;</span>
  29 |     | <span class='neutral'></span>
  30 |     | <span class='neutral'>    FuzzArtifactSelector[] private _targetedArtifactSelectors;</span>
  31 |     | <span class='neutral'></span>
  32 |     | <span class='neutral'>    FuzzSelector[] private _excludedSelectors;</span>
  33 |     | <span class='neutral'>    FuzzSelector[] private _targetedSelectors;</span>
  34 |     | <span class='neutral'></span>
  35 |     | <span class='neutral'>    FuzzInterface[] private _targetedInterfaces;</span>
  36 |     | <span class='neutral'></span>
  37 |     | <span class='neutral'>    // Functions for users:</span>
  38 |     | <span class='neutral'>    // These are intended to be called in tests.</span>
  39 |     | <span class='neutral'></span>
  40 |     | <span class='neutral'>    function excludeContract(address newExcludedContract_) internal {</span>
  41 |     | <span class='neutral'>        _excludedContracts.push(newExcludedContract_);</span>
  42 |     | <span class='neutral'>    }</span>
  43 |     | <span class='neutral'></span>
  44 |     | <span class='neutral'>    function excludeSelector(FuzzSelector memory newExcludedSelector_) internal {</span>
  45 |     | <span class='neutral'>        _excludedSelectors.push(newExcludedSelector_);</span>
  46 |     | <span class='neutral'>    }</span>
  47 |     | <span class='neutral'></span>
  48 |     | <span class='neutral'>    function excludeSender(address newExcludedSender_) internal {</span>
  49 |     | <span class='neutral'>        _excludedSenders.push(newExcludedSender_);</span>
  50 |     | <span class='neutral'>    }</span>
  51 |     | <span class='neutral'></span>
  52 |     | <span class='neutral'>    function excludeArtifact(string memory newExcludedArtifact_) internal {</span>
  53 |     | <span class='neutral'>        _excludedArtifacts.push(newExcludedArtifact_);</span>
  54 |     | <span class='neutral'>    }</span>
  55 |     | <span class='neutral'></span>
  56 |     | <span class='neutral'>    function targetArtifact(string memory newTargetedArtifact_) internal {</span>
  57 |     | <span class='neutral'>        _targetedArtifacts.push(newTargetedArtifact_);</span>
  58 |     | <span class='neutral'>    }</span>
  59 |     | <span class='neutral'></span>
  60 |     | <span class='neutral'>    function targetArtifactSelector(FuzzArtifactSelector memory newTargetedArtifactSelector_) internal {</span>
  61 |     | <span class='neutral'>        _targetedArtifactSelectors.push(newTargetedArtifactSelector_);</span>
  62 |     | <span class='neutral'>    }</span>
  63 |     | <span class='neutral'></span>
  64 |     | <span class='neutral'>    function targetContract(address newTargetedContract_) internal {</span>
  65 |     | <span class='unexecuted'>        _targetedContracts.push(newTargetedContract_);</span>
  66 |     | <span class='neutral'>    }</span>
  67 |     | <span class='neutral'></span>
  68 |     | <span class='neutral'>    function targetSelector(FuzzSelector memory newTargetedSelector_) internal {</span>
  69 |     | <span class='neutral'>        _targetedSelectors.push(newTargetedSelector_);</span>
  70 |     | <span class='neutral'>    }</span>
  71 |     | <span class='neutral'></span>
  72 |     | <span class='neutral'>    function targetSender(address newTargetedSender_) internal {</span>
  73 |     | <span class='neutral'>        _targetedSenders.push(newTargetedSender_);</span>
  74 |     | <span class='neutral'>    }</span>
  75 |     | <span class='neutral'></span>
  76 |     | <span class='neutral'>    function targetInterface(FuzzInterface memory newTargetedInterface_) internal {</span>
  77 |     | <span class='neutral'>        _targetedInterfaces.push(newTargetedInterface_);</span>
  78 |     | <span class='neutral'>    }</span>
  79 |     | <span class='neutral'></span>
  80 |     | <span class='neutral'>    // Functions for forge:</span>
  81 |     | <span class='neutral'>    // These are called by forge to run invariant tests and don&#39;t need to be called in tests.</span>
  82 |     | <span class='neutral'></span>
  83 |     | <span class='unexecuted'>    function excludeArtifacts() public view returns (string[] memory excludedArtifacts_) {</span>
  84 |     | <span class='unexecuted'>        excludedArtifacts_ = _excludedArtifacts;</span>
  85 |     | <span class='neutral'>    }</span>
  86 |     | <span class='neutral'></span>
  87 | *   | <span class='executed'>    function excludeContracts() public view returns (address[] memory excludedContracts_) {</span>
  88 | *   | <span class='executed'>        excludedContracts_ = _excludedContracts;</span>
  89 |     | <span class='neutral'>    }</span>
  90 |     | <span class='neutral'></span>
  91 | *   | <span class='executed'>    function excludeSelectors() public view returns (FuzzSelector[] memory excludedSelectors_) {</span>
  92 | *   | <span class='executed'>        excludedSelectors_ = _excludedSelectors;</span>
  93 |     | <span class='neutral'>    }</span>
  94 |     | <span class='neutral'></span>
  95 | *   | <span class='executed'>    function excludeSenders() public view returns (address[] memory excludedSenders_) {</span>
  96 | *   | <span class='executed'>        excludedSenders_ = _excludedSenders;</span>
  97 |     | <span class='neutral'>    }</span>
  98 |     | <span class='neutral'></span>
  99 | *   | <span class='executed'>    function targetArtifacts() public view returns (string[] memory targetedArtifacts_) {</span>
 100 | *   | <span class='executed'>        targetedArtifacts_ = _targetedArtifacts;</span>
 101 |     | <span class='neutral'>    }</span>
 102 |     | <span class='neutral'></span>
 103 | *   | <span class='executed'>    function targetArtifactSelectors() public view returns (FuzzArtifactSelector[] memory targetedArtifactSelectors_) {</span>
 104 | *   | <span class='executed'>        targetedArtifactSelectors_ = _targetedArtifactSelectors;</span>
 105 |     | <span class='neutral'>    }</span>
 106 |     | <span class='neutral'></span>
 107 | *   | <span class='executed'>    function targetContracts() public view returns (address[] memory targetedContracts_) {</span>
 108 | *   | <span class='executed'>        targetedContracts_ = _targetedContracts;</span>
 109 |     | <span class='neutral'>    }</span>
 110 |     | <span class='neutral'></span>
 111 | *   | <span class='executed'>    function targetSelectors() public view returns (FuzzSelector[] memory targetedSelectors_) {</span>
 112 | *   | <span class='executed'>        targetedSelectors_ = _targetedSelectors;</span>
 113 |     | <span class='neutral'>    }</span>
 114 |     | <span class='neutral'></span>
 115 | *   | <span class='executed'>    function targetSenders() public view returns (address[] memory targetedSenders_) {</span>
 116 | *   | <span class='executed'>        targetedSenders_ = _targetedSenders;</span>
 117 |     | <span class='neutral'>    }</span>
 118 |     | <span class='neutral'></span>
 119 | *   | <span class='executed'>    function targetInterfaces() public view returns (FuzzInterface[] memory targetedInterfaces_) {</span>
 120 | *   | <span class='executed'>        targetedInterfaces_ = _targetedInterfaces;</span>
 121 |     | <span class='neutral'>    }</span>
 122 |     | <span class='neutral'>}</span>
 123 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/phantom/Documents/azemora/azemora-contracts/lib/forge-std/src/StdJson.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'>pragma solidity &gt;=0.6.0 &lt;0.9.0;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>pragma experimental ABIEncoderV2;</span>
   5 |     | <span class='neutral'></span>
   6 |     | <span class='neutral'>import {VmSafe} from &quot;./Vm.sol&quot;;</span>
   7 |     | <span class='neutral'></span>
   8 |     | <span class='neutral'>// Helpers for parsing and writing JSON files</span>
   9 |     | <span class='neutral'>// To parse:</span>
  10 |     | <span class='neutral'>// ```</span>
  11 |     | <span class='neutral'>// using stdJson for string;</span>
  12 |     | <span class='neutral'>// string memory json = vm.readFile(&quot;&lt;some_path&gt;&quot;);</span>
  13 |     | <span class='neutral'>// json.readUint(&quot;&lt;json_path&gt;&quot;);</span>
  14 |     | <span class='neutral'>// ```</span>
  15 |     | <span class='neutral'>// To write:</span>
  16 |     | <span class='neutral'>// ```</span>
  17 |     | <span class='neutral'>// using stdJson for string;</span>
  18 |     | <span class='neutral'>// string memory json = &quot;json&quot;;</span>
  19 |     | <span class='neutral'>// json.serialize(&quot;a&quot;, uint256(123));</span>
  20 |     | <span class='neutral'>// string memory semiFinal = json.serialize(&quot;b&quot;, string(&quot;test&quot;));</span>
  21 |     | <span class='neutral'>// string memory finalJson = json.serialize(&quot;c&quot;, semiFinal);</span>
  22 |     | <span class='neutral'>// finalJson.write(&quot;&lt;some_path&gt;&quot;);</span>
  23 |     | <span class='neutral'>// ```</span>
  24 |     | <span class='neutral'></span>
  25 |     | <span class='unexecuted'>library stdJson {</span>
  26 |     | <span class='neutral'>    VmSafe private constant vm = VmSafe(address(uint160(uint256(keccak256(&quot;hevm cheat code&quot;)))));</span>
  27 |     | <span class='neutral'></span>
  28 |     | <span class='neutral'>    function keyExists(string memory json, string memory key) internal view returns (bool) {</span>
  29 |     | <span class='neutral'>        return vm.keyExistsJson(json, key);</span>
  30 |     | <span class='neutral'>    }</span>
  31 |     | <span class='neutral'></span>
  32 |     | <span class='neutral'>    function parseRaw(string memory json, string memory key) internal pure returns (bytes memory) {</span>
  33 |     | <span class='neutral'>        return vm.parseJson(json, key);</span>
  34 |     | <span class='neutral'>    }</span>
  35 |     | <span class='neutral'></span>
  36 |     | <span class='neutral'>    function readUint(string memory json, string memory key) internal pure returns (uint256) {</span>
  37 |     | <span class='neutral'>        return vm.parseJsonUint(json, key);</span>
  38 |     | <span class='neutral'>    }</span>
  39 |     | <span class='neutral'></span>
  40 |     | <span class='neutral'>    function readUintArray(string memory json, string memory key) internal pure returns (uint256[] memory) {</span>
  41 |     | <span class='neutral'>        return vm.parseJsonUintArray(json, key);</span>
  42 |     | <span class='neutral'>    }</span>
  43 |     | <span class='neutral'></span>
  44 |     | <span class='neutral'>    function readInt(string memory json, string memory key) internal pure returns (int256) {</span>
  45 |     | <span class='neutral'>        return vm.parseJsonInt(json, key);</span>
  46 |     | <span class='neutral'>    }</span>
  47 |     | <span class='neutral'></span>
  48 |     | <span class='neutral'>    function readIntArray(string memory json, string memory key) internal pure returns (int256[] memory) {</span>
  49 |     | <span class='neutral'>        return vm.parseJsonIntArray(json, key);</span>
  50 |     | <span class='neutral'>    }</span>
  51 |     | <span class='neutral'></span>
  52 |     | <span class='neutral'>    function readBytes32(string memory json, string memory key) internal pure returns (bytes32) {</span>
  53 |     | <span class='neutral'>        return vm.parseJsonBytes32(json, key);</span>
  54 |     | <span class='neutral'>    }</span>
  55 |     | <span class='neutral'></span>
  56 |     | <span class='neutral'>    function readBytes32Array(string memory json, string memory key) internal pure returns (bytes32[] memory) {</span>
  57 |     | <span class='neutral'>        return vm.parseJsonBytes32Array(json, key);</span>
  58 |     | <span class='neutral'>    }</span>
  59 |     | <span class='neutral'></span>
  60 |     | <span class='neutral'>    function readString(string memory json, string memory key) internal pure returns (string memory) {</span>
  61 |     | <span class='neutral'>        return vm.parseJsonString(json, key);</span>
  62 |     | <span class='neutral'>    }</span>
  63 |     | <span class='neutral'></span>
  64 |     | <span class='neutral'>    function readStringArray(string memory json, string memory key) internal pure returns (string[] memory) {</span>
  65 |     | <span class='neutral'>        return vm.parseJsonStringArray(json, key);</span>
  66 |     | <span class='neutral'>    }</span>
  67 |     | <span class='neutral'></span>
  68 |     | <span class='neutral'>    function readAddress(string memory json, string memory key) internal pure returns (address) {</span>
  69 |     | <span class='neutral'>        return vm.parseJsonAddress(json, key);</span>
  70 |     | <span class='neutral'>    }</span>
  71 |     | <span class='neutral'></span>
  72 |     | <span class='neutral'>    function readAddressArray(string memory json, string memory key) internal pure returns (address[] memory) {</span>
  73 |     | <span class='neutral'>        return vm.parseJsonAddressArray(json, key);</span>
  74 |     | <span class='neutral'>    }</span>
  75 |     | <span class='neutral'></span>
  76 |     | <span class='neutral'>    function readBool(string memory json, string memory key) internal pure returns (bool) {</span>
  77 |     | <span class='neutral'>        return vm.parseJsonBool(json, key);</span>
  78 |     | <span class='neutral'>    }</span>
  79 |     | <span class='neutral'></span>
  80 |     | <span class='neutral'>    function readBoolArray(string memory json, string memory key) internal pure returns (bool[] memory) {</span>
  81 |     | <span class='neutral'>        return vm.parseJsonBoolArray(json, key);</span>
  82 |     | <span class='neutral'>    }</span>
  83 |     | <span class='neutral'></span>
  84 |     | <span class='neutral'>    function readBytes(string memory json, string memory key) internal pure returns (bytes memory) {</span>
  85 |     | <span class='neutral'>        return vm.parseJsonBytes(json, key);</span>
  86 |     | <span class='neutral'>    }</span>
  87 |     | <span class='neutral'></span>
  88 |     | <span class='neutral'>    function readBytesArray(string memory json, string memory key) internal pure returns (bytes[] memory) {</span>
  89 |     | <span class='neutral'>        return vm.parseJsonBytesArray(json, key);</span>
  90 |     | <span class='neutral'>    }</span>
  91 |     | <span class='neutral'></span>
  92 |     | <span class='neutral'>    function readUintOr(string memory json, string memory key, uint256 defaultValue) internal view returns (uint256) {</span>
  93 |     | <span class='neutral'>        return keyExists(json, key) ? readUint(json, key) : defaultValue;</span>
  94 |     | <span class='neutral'>    }</span>
  95 |     | <span class='neutral'></span>
  96 |     | <span class='neutral'>    function readUintArrayOr(string memory json, string memory key, uint256[] memory defaultValue)</span>
  97 |     | <span class='neutral'>        internal</span>
  98 |     | <span class='neutral'>        view</span>
  99 |     | <span class='neutral'>        returns (uint256[] memory)</span>
 100 |     | <span class='neutral'>    {</span>
 101 |     | <span class='neutral'>        return keyExists(json, key) ? readUintArray(json, key) : defaultValue;</span>
 102 |     | <span class='neutral'>    }</span>
 103 |     | <span class='neutral'></span>
 104 |     | <span class='neutral'>    function readIntOr(string memory json, string memory key, int256 defaultValue) internal view returns (int256) {</span>
 105 |     | <span class='neutral'>        return keyExists(json, key) ? readInt(json, key) : defaultValue;</span>
 106 |     | <span class='neutral'>    }</span>
 107 |     | <span class='neutral'></span>
 108 |     | <span class='neutral'>    function readIntArrayOr(string memory json, string memory key, int256[] memory defaultValue)</span>
 109 |     | <span class='neutral'>        internal</span>
 110 |     | <span class='neutral'>        view</span>
 111 |     | <span class='neutral'>        returns (int256[] memory)</span>
 112 |     | <span class='neutral'>    {</span>
 113 |     | <span class='neutral'>        return keyExists(json, key) ? readIntArray(json, key) : defaultValue;</span>
 114 |     | <span class='neutral'>    }</span>
 115 |     | <span class='neutral'></span>
 116 |     | <span class='neutral'>    function readBytes32Or(string memory json, string memory key, bytes32 defaultValue)</span>
 117 |     | <span class='neutral'>        internal</span>
 118 |     | <span class='neutral'>        view</span>
 119 |     | <span class='neutral'>        returns (bytes32)</span>
 120 |     | <span class='neutral'>    {</span>
 121 |     | <span class='neutral'>        return keyExists(json, key) ? readBytes32(json, key) : defaultValue;</span>
 122 |     | <span class='neutral'>    }</span>
 123 |     | <span class='neutral'></span>
 124 |     | <span class='neutral'>    function readBytes32ArrayOr(string memory json, string memory key, bytes32[] memory defaultValue)</span>
 125 |     | <span class='neutral'>        internal</span>
 126 |     | <span class='neutral'>        view</span>
 127 |     | <span class='neutral'>        returns (bytes32[] memory)</span>
 128 |     | <span class='neutral'>    {</span>
 129 |     | <span class='neutral'>        return keyExists(json, key) ? readBytes32Array(json, key) : defaultValue;</span>
 130 |     | <span class='neutral'>    }</span>
 131 |     | <span class='neutral'></span>
 132 |     | <span class='neutral'>    function readStringOr(string memory json, string memory key, string memory defaultValue)</span>
 133 |     | <span class='neutral'>        internal</span>
 134 |     | <span class='neutral'>        view</span>
 135 |     | <span class='neutral'>        returns (string memory)</span>
 136 |     | <span class='neutral'>    {</span>
 137 |     | <span class='neutral'>        return keyExists(json, key) ? readString(json, key) : defaultValue;</span>
 138 |     | <span class='neutral'>    }</span>
 139 |     | <span class='neutral'></span>
 140 |     | <span class='neutral'>    function readStringArrayOr(string memory json, string memory key, string[] memory defaultValue)</span>
 141 |     | <span class='neutral'>        internal</span>
 142 |     | <span class='neutral'>        view</span>
 143 |     | <span class='neutral'>        returns (string[] memory)</span>
 144 |     | <span class='neutral'>    {</span>
 145 |     | <span class='neutral'>        return keyExists(json, key) ? readStringArray(json, key) : defaultValue;</span>
 146 |     | <span class='neutral'>    }</span>
 147 |     | <span class='neutral'></span>
 148 |     | <span class='neutral'>    function readAddressOr(string memory json, string memory key, address defaultValue)</span>
 149 |     | <span class='neutral'>        internal</span>
 150 |     | <span class='neutral'>        view</span>
 151 |     | <span class='neutral'>        returns (address)</span>
 152 |     | <span class='neutral'>    {</span>
 153 |     | <span class='neutral'>        return keyExists(json, key) ? readAddress(json, key) : defaultValue;</span>
 154 |     | <span class='neutral'>    }</span>
 155 |     | <span class='neutral'></span>
 156 |     | <span class='neutral'>    function readAddressArrayOr(string memory json, string memory key, address[] memory defaultValue)</span>
 157 |     | <span class='neutral'>        internal</span>
 158 |     | <span class='neutral'>        view</span>
 159 |     | <span class='neutral'>        returns (address[] memory)</span>
 160 |     | <span class='neutral'>    {</span>
 161 |     | <span class='neutral'>        return keyExists(json, key) ? readAddressArray(json, key) : defaultValue;</span>
 162 |     | <span class='neutral'>    }</span>
 163 |     | <span class='neutral'></span>
 164 |     | <span class='neutral'>    function readBoolOr(string memory json, string memory key, bool defaultValue) internal view returns (bool) {</span>
 165 |     | <span class='neutral'>        return keyExists(json, key) ? readBool(json, key) : defaultValue;</span>
 166 |     | <span class='neutral'>    }</span>
 167 |     | <span class='neutral'></span>
 168 |     | <span class='neutral'>    function readBoolArrayOr(string memory json, string memory key, bool[] memory defaultValue)</span>
 169 |     | <span class='neutral'>        internal</span>
 170 |     | <span class='neutral'>        view</span>
 171 |     | <span class='neutral'>        returns (bool[] memory)</span>
 172 |     | <span class='neutral'>    {</span>
 173 |     | <span class='neutral'>        return keyExists(json, key) ? readBoolArray(json, key) : defaultValue;</span>
 174 |     | <span class='neutral'>    }</span>
 175 |     | <span class='neutral'></span>
 176 |     | <span class='neutral'>    function readBytesOr(string memory json, string memory key, bytes memory defaultValue)</span>
 177 |     | <span class='neutral'>        internal</span>
 178 |     | <span class='neutral'>        view</span>
 179 |     | <span class='neutral'>        returns (bytes memory)</span>
 180 |     | <span class='neutral'>    {</span>
 181 |     | <span class='neutral'>        return keyExists(json, key) ? readBytes(json, key) : defaultValue;</span>
 182 |     | <span class='neutral'>    }</span>
 183 |     | <span class='neutral'></span>
 184 |     | <span class='neutral'>    function readBytesArrayOr(string memory json, string memory key, bytes[] memory defaultValue)</span>
 185 |     | <span class='neutral'>        internal</span>
 186 |     | <span class='neutral'>        view</span>
 187 |     | <span class='neutral'>        returns (bytes[] memory)</span>
 188 |     | <span class='neutral'>    {</span>
 189 |     | <span class='neutral'>        return keyExists(json, key) ? readBytesArray(json, key) : defaultValue;</span>
 190 |     | <span class='neutral'>    }</span>
 191 |     | <span class='neutral'></span>
 192 |     | <span class='neutral'>    function serialize(string memory jsonKey, string memory rootObject) internal returns (string memory) {</span>
 193 |     | <span class='neutral'>        return vm.serializeJson(jsonKey, rootObject);</span>
 194 |     | <span class='neutral'>    }</span>
 195 |     | <span class='neutral'></span>
 196 |     | <span class='neutral'>    function serialize(string memory jsonKey, string memory key, bool value) internal returns (string memory) {</span>
 197 |     | <span class='neutral'>        return vm.serializeBool(jsonKey, key, value);</span>
 198 |     | <span class='neutral'>    }</span>
 199 |     | <span class='neutral'></span>
 200 |     | <span class='neutral'>    function serialize(string memory jsonKey, string memory key, bool[] memory value)</span>
 201 |     | <span class='neutral'>        internal</span>
 202 |     | <span class='neutral'>        returns (string memory)</span>
 203 |     | <span class='neutral'>    {</span>
 204 |     | <span class='neutral'>        return vm.serializeBool(jsonKey, key, value);</span>
 205 |     | <span class='neutral'>    }</span>
 206 |     | <span class='neutral'></span>
 207 |     | <span class='neutral'>    function serialize(string memory jsonKey, string memory key, uint256 value) internal returns (string memory) {</span>
 208 |     | <span class='neutral'>        return vm.serializeUint(jsonKey, key, value);</span>
 209 |     | <span class='neutral'>    }</span>
 210 |     | <span class='neutral'></span>
 211 |     | <span class='neutral'>    function serialize(string memory jsonKey, string memory key, uint256[] memory value)</span>
 212 |     | <span class='neutral'>        internal</span>
 213 |     | <span class='neutral'>        returns (string memory)</span>
 214 |     | <span class='neutral'>    {</span>
 215 |     | <span class='neutral'>        return vm.serializeUint(jsonKey, key, value);</span>
 216 |     | <span class='neutral'>    }</span>
 217 |     | <span class='neutral'></span>
 218 |     | <span class='neutral'>    function serialize(string memory jsonKey, string memory key, int256 value) internal returns (string memory) {</span>
 219 |     | <span class='neutral'>        return vm.serializeInt(jsonKey, key, value);</span>
 220 |     | <span class='neutral'>    }</span>
 221 |     | <span class='neutral'></span>
 222 |     | <span class='neutral'>    function serialize(string memory jsonKey, string memory key, int256[] memory value)</span>
 223 |     | <span class='neutral'>        internal</span>
 224 |     | <span class='neutral'>        returns (string memory)</span>
 225 |     | <span class='neutral'>    {</span>
 226 |     | <span class='neutral'>        return vm.serializeInt(jsonKey, key, value);</span>
 227 |     | <span class='neutral'>    }</span>
 228 |     | <span class='neutral'></span>
 229 |     | <span class='neutral'>    function serialize(string memory jsonKey, string memory key, address value) internal returns (string memory) {</span>
 230 |     | <span class='neutral'>        return vm.serializeAddress(jsonKey, key, value);</span>
 231 |     | <span class='neutral'>    }</span>
 232 |     | <span class='neutral'></span>
 233 |     | <span class='neutral'>    function serialize(string memory jsonKey, string memory key, address[] memory value)</span>
 234 |     | <span class='neutral'>        internal</span>
 235 |     | <span class='neutral'>        returns (string memory)</span>
 236 |     | <span class='neutral'>    {</span>
 237 |     | <span class='neutral'>        return vm.serializeAddress(jsonKey, key, value);</span>
 238 |     | <span class='neutral'>    }</span>
 239 |     | <span class='neutral'></span>
 240 |     | <span class='neutral'>    function serialize(string memory jsonKey, string memory key, bytes32 value) internal returns (string memory) {</span>
 241 |     | <span class='neutral'>        return vm.serializeBytes32(jsonKey, key, value);</span>
 242 |     | <span class='neutral'>    }</span>
 243 |     | <span class='neutral'></span>
 244 |     | <span class='neutral'>    function serialize(string memory jsonKey, string memory key, bytes32[] memory value)</span>
 245 |     | <span class='neutral'>        internal</span>
 246 |     | <span class='neutral'>        returns (string memory)</span>
 247 |     | <span class='neutral'>    {</span>
 248 |     | <span class='neutral'>        return vm.serializeBytes32(jsonKey, key, value);</span>
 249 |     | <span class='neutral'>    }</span>
 250 |     | <span class='neutral'></span>
 251 |     | <span class='neutral'>    function serialize(string memory jsonKey, string memory key, bytes memory value) internal returns (string memory) {</span>
 252 |     | <span class='neutral'>        return vm.serializeBytes(jsonKey, key, value);</span>
 253 |     | <span class='neutral'>    }</span>
 254 |     | <span class='neutral'></span>
 255 |     | <span class='neutral'>    function serialize(string memory jsonKey, string memory key, bytes[] memory value)</span>
 256 |     | <span class='neutral'>        internal</span>
 257 |     | <span class='neutral'>        returns (string memory)</span>
 258 |     | <span class='neutral'>    {</span>
 259 |     | <span class='neutral'>        return vm.serializeBytes(jsonKey, key, value);</span>
 260 |     | <span class='neutral'>    }</span>
 261 |     | <span class='neutral'></span>
 262 |     | <span class='neutral'>    function serialize(string memory jsonKey, string memory key, string memory value)</span>
 263 |     | <span class='neutral'>        internal</span>
 264 |     | <span class='neutral'>        returns (string memory)</span>
 265 |     | <span class='neutral'>    {</span>
 266 |     | <span class='neutral'>        return vm.serializeString(jsonKey, key, value);</span>
 267 |     | <span class='neutral'>    }</span>
 268 |     | <span class='neutral'></span>
 269 |     | <span class='neutral'>    function serialize(string memory jsonKey, string memory key, string[] memory value)</span>
 270 |     | <span class='neutral'>        internal</span>
 271 |     | <span class='neutral'>        returns (string memory)</span>
 272 |     | <span class='neutral'>    {</span>
 273 |     | <span class='neutral'>        return vm.serializeString(jsonKey, key, value);</span>
 274 |     | <span class='neutral'>    }</span>
 275 |     | <span class='neutral'></span>
 276 |     | <span class='neutral'>    function write(string memory jsonKey, string memory path) internal {</span>
 277 |     | <span class='neutral'>        vm.writeJson(jsonKey, path);</span>
 278 |     | <span class='neutral'>    }</span>
 279 |     | <span class='neutral'></span>
 280 |     | <span class='neutral'>    function write(string memory jsonKey, string memory path, string memory valueKey) internal {</span>
 281 |     | <span class='neutral'>        vm.writeJson(jsonKey, path, valueKey);</span>
 282 |     | <span class='neutral'>    }</span>
 283 |     | <span class='neutral'>}</span>
 284 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/phantom/Documents/azemora/azemora-contracts/lib/forge-std/src/StdMath.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>pragma solidity &gt;=0.6.2 &lt;0.9.0;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='unexecuted'>library stdMath {</span>
  5 |     | <span class='neutral'>    int256 private constant INT256_MIN = -57896044618658097711785492504343953926634992332820282019728792003956564819968;</span>
  6 |     | <span class='neutral'></span>
  7 |     | <span class='neutral'>    function abs(int256 a) internal pure returns (uint256) {</span>
  8 |     | <span class='neutral'>        // Required or it will fail when `a = type(int256).min`</span>
  9 |     | <span class='neutral'>        if (a == INT256_MIN) {</span>
 10 |     | <span class='neutral'>            return 57896044618658097711785492504343953926634992332820282019728792003956564819968;</span>
 11 |     | <span class='neutral'>        }</span>
 12 |     | <span class='neutral'></span>
 13 |     | <span class='neutral'>        return uint256(a &gt; 0 ? a : -a);</span>
 14 |     | <span class='neutral'>    }</span>
 15 |     | <span class='neutral'></span>
 16 |     | <span class='neutral'>    function delta(uint256 a, uint256 b) internal pure returns (uint256) {</span>
 17 |     | <span class='neutral'>        return a &gt; b ? a - b : b - a;</span>
 18 |     | <span class='neutral'>    }</span>
 19 |     | <span class='neutral'></span>
 20 |     | <span class='neutral'>    function delta(int256 a, int256 b) internal pure returns (uint256) {</span>
 21 |     | <span class='neutral'>        // a and b are of the same sign</span>
 22 |     | <span class='neutral'>        // this works thanks to two&#39;s complement, the left-most bit is the sign bit</span>
 23 |     | <span class='neutral'>        if ((a ^ b) &gt; -1) {</span>
 24 |     | <span class='neutral'>            return delta(abs(a), abs(b));</span>
 25 |     | <span class='neutral'>        }</span>
 26 |     | <span class='neutral'></span>
 27 |     | <span class='neutral'>        // a and b are of opposite signs</span>
 28 |     | <span class='neutral'>        return abs(a) + abs(b);</span>
 29 |     | <span class='neutral'>    }</span>
 30 |     | <span class='neutral'></span>
 31 |     | <span class='neutral'>    function percentDelta(uint256 a, uint256 b) internal pure returns (uint256) {</span>
 32 |     | <span class='neutral'>        uint256 absDelta = delta(a, b);</span>
 33 |     | <span class='neutral'></span>
 34 |     | <span class='neutral'>        return absDelta * 1e18 / b;</span>
 35 |     | <span class='neutral'>    }</span>
 36 |     | <span class='neutral'></span>
 37 |     | <span class='neutral'>    function percentDelta(int256 a, int256 b) internal pure returns (uint256) {</span>
 38 |     | <span class='neutral'>        uint256 absDelta = delta(a, b);</span>
 39 |     | <span class='neutral'>        uint256 absB = abs(b);</span>
 40 |     | <span class='neutral'></span>
 41 |     | <span class='neutral'>        return absDelta * 1e18 / absB;</span>
 42 |     | <span class='neutral'>    }</span>
 43 |     | <span class='neutral'>}</span>
 44 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/phantom/Documents/azemora/azemora-contracts/lib/forge-std/src/StdStorage.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'>pragma solidity &gt;=0.6.2 &lt;0.9.0;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>import {Vm} from &quot;./Vm.sol&quot;;</span>
   5 |     | <span class='neutral'></span>
   6 |     | <span class='neutral'>struct FindData {</span>
   7 |     | <span class='neutral'>    uint256 slot;</span>
   8 |     | <span class='neutral'>    uint256 offsetLeft;</span>
   9 |     | <span class='neutral'>    uint256 offsetRight;</span>
  10 |     | <span class='neutral'>    bool found;</span>
  11 |     | <span class='neutral'>}</span>
  12 |     | <span class='neutral'></span>
  13 |     | <span class='neutral'>struct StdStorage {</span>
  14 |     | <span class='neutral'>    mapping(address =&gt; mapping(bytes4 =&gt; mapping(bytes32 =&gt; FindData))) finds;</span>
  15 |     | <span class='neutral'>    bytes32[] _keys;</span>
  16 |     | <span class='neutral'>    bytes4 _sig;</span>
  17 |     | <span class='neutral'>    uint256 _depth;</span>
  18 |     | <span class='neutral'>    address _target;</span>
  19 |     | <span class='neutral'>    bytes32 _set;</span>
  20 |     | <span class='neutral'>    bool _enable_packed_slots;</span>
  21 |     | <span class='neutral'>    bytes _calldata;</span>
  22 |     | <span class='neutral'>}</span>
  23 |     | <span class='neutral'></span>
  24 |     | <span class='unexecuted'>library stdStorageSafe {</span>
  25 |     | <span class='neutral'>    event SlotFound(address who, bytes4 fsig, bytes32 keysHash, uint256 slot);</span>
  26 |     | <span class='neutral'>    event WARNING_UninitedSlot(address who, uint256 slot);</span>
  27 |     | <span class='neutral'></span>
  28 |     | <span class='neutral'>    Vm private constant vm = Vm(address(uint160(uint256(keccak256(&quot;hevm cheat code&quot;)))));</span>
  29 |     | <span class='neutral'>    uint256 constant UINT256_MAX = 115792089237316195423570985008687907853269984665640564039457584007913129639935;</span>
  30 |     | <span class='neutral'></span>
  31 |     | <span class='neutral'>    function sigs(string memory sigStr) internal pure returns (bytes4) {</span>
  32 |     | <span class='neutral'>        return bytes4(keccak256(bytes(sigStr)));</span>
  33 |     | <span class='neutral'>    }</span>
  34 |     | <span class='neutral'></span>
  35 |     | <span class='neutral'>    function getCallParams(StdStorage storage self) internal view returns (bytes memory) {</span>
  36 |     | <span class='neutral'>        if (self._calldata.length == 0) {</span>
  37 |     | <span class='neutral'>            return flatten(self._keys);</span>
  38 |     | <span class='neutral'>        } else {</span>
  39 |     | <span class='neutral'>            return self._calldata;</span>
  40 |     | <span class='neutral'>        }</span>
  41 |     | <span class='neutral'>    }</span>
  42 |     | <span class='neutral'></span>
  43 |     | <span class='neutral'>    // Calls target contract with configured parameters</span>
  44 |     | <span class='neutral'>    function callTarget(StdStorage storage self) internal view returns (bool, bytes32) {</span>
  45 |     | <span class='neutral'>        bytes memory cald = abi.encodePacked(self._sig, getCallParams(self));</span>
  46 |     | <span class='neutral'>        (bool success, bytes memory rdat) = self._target.staticcall(cald);</span>
  47 |     | <span class='neutral'>        bytes32 result = bytesToBytes32(rdat, 32 * self._depth);</span>
  48 |     | <span class='neutral'></span>
  49 |     | <span class='neutral'>        return (success, result);</span>
  50 |     | <span class='neutral'>    }</span>
  51 |     | <span class='neutral'></span>
  52 |     | <span class='neutral'>    // Tries mutating slot value to determine if the targeted value is stored in it.</span>
  53 |     | <span class='neutral'>    // If current value is 0, then we are setting slot value to type(uint256).max</span>
  54 |     | <span class='neutral'>    // Otherwise, we set it to 0. That way, return value should always be affected.</span>
  55 |     | <span class='neutral'>    function checkSlotMutatesCall(StdStorage storage self, bytes32 slot) internal returns (bool) {</span>
  56 |     | <span class='neutral'>        bytes32 prevSlotValue = vm.load(self._target, slot);</span>
  57 |     | <span class='neutral'>        (bool success, bytes32 prevReturnValue) = callTarget(self);</span>
  58 |     | <span class='neutral'></span>
  59 |     | <span class='neutral'>        bytes32 testVal = prevReturnValue == bytes32(0) ? bytes32(UINT256_MAX) : bytes32(0);</span>
  60 |     | <span class='neutral'>        vm.store(self._target, slot, testVal);</span>
  61 |     | <span class='neutral'></span>
  62 |     | <span class='neutral'>        (, bytes32 newReturnValue) = callTarget(self);</span>
  63 |     | <span class='neutral'></span>
  64 |     | <span class='neutral'>        vm.store(self._target, slot, prevSlotValue);</span>
  65 |     | <span class='neutral'></span>
  66 |     | <span class='neutral'>        return (success &amp;&amp; (prevReturnValue != newReturnValue));</span>
  67 |     | <span class='neutral'>    }</span>
  68 |     | <span class='neutral'></span>
  69 |     | <span class='neutral'>    // Tries setting one of the bits in slot to 1 until return value changes.</span>
  70 |     | <span class='neutral'>    // Index of resulted bit is an offset packed slot has from left/right side</span>
  71 |     | <span class='neutral'>    function findOffset(StdStorage storage self, bytes32 slot, bool left) internal returns (bool, uint256) {</span>
  72 |     | <span class='neutral'>        for (uint256 offset = 0; offset &lt; 256; offset++) {</span>
  73 |     | <span class='neutral'>            uint256 valueToPut = left ? (1 &lt;&lt; (255 - offset)) : (1 &lt;&lt; offset);</span>
  74 |     | <span class='neutral'>            vm.store(self._target, slot, bytes32(valueToPut));</span>
  75 |     | <span class='neutral'></span>
  76 |     | <span class='neutral'>            (bool success, bytes32 data) = callTarget(self);</span>
  77 |     | <span class='neutral'></span>
  78 |     | <span class='neutral'>            if (success &amp;&amp; (uint256(data) &gt; 0)) {</span>
  79 |     | <span class='neutral'>                return (true, offset);</span>
  80 |     | <span class='neutral'>            }</span>
  81 |     | <span class='neutral'>        }</span>
  82 |     | <span class='neutral'>        return (false, 0);</span>
  83 |     | <span class='neutral'>    }</span>
  84 |     | <span class='neutral'></span>
  85 |     | <span class='neutral'>    function findOffsets(StdStorage storage self, bytes32 slot) internal returns (bool, uint256, uint256) {</span>
  86 |     | <span class='neutral'>        bytes32 prevSlotValue = vm.load(self._target, slot);</span>
  87 |     | <span class='neutral'></span>
  88 |     | <span class='neutral'>        (bool foundLeft, uint256 offsetLeft) = findOffset(self, slot, true);</span>
  89 |     | <span class='neutral'>        (bool foundRight, uint256 offsetRight) = findOffset(self, slot, false);</span>
  90 |     | <span class='neutral'></span>
  91 |     | <span class='neutral'>        // `findOffset` may mutate slot value, so we are setting it to initial value</span>
  92 |     | <span class='neutral'>        vm.store(self._target, slot, prevSlotValue);</span>
  93 |     | <span class='neutral'>        return (foundLeft &amp;&amp; foundRight, offsetLeft, offsetRight);</span>
  94 |     | <span class='neutral'>    }</span>
  95 |     | <span class='neutral'></span>
  96 |     | <span class='neutral'>    function find(StdStorage storage self) internal returns (FindData storage) {</span>
  97 |     | <span class='neutral'>        return find(self, true);</span>
  98 |     | <span class='neutral'>    }</span>
  99 |     | <span class='neutral'></span>
 100 |     | <span class='neutral'>    /// @notice find an arbitrary storage slot given a function sig, input data, address of the contract and a value to check against</span>
 101 |     | <span class='neutral'>    // slot complexity:</span>
 102 |     | <span class='neutral'>    //  if flat, will be bytes32(uint256(uint));</span>
 103 |     | <span class='neutral'>    //  if map, will be keccak256(abi.encode(key, uint(slot)));</span>
 104 |     | <span class='neutral'>    //  if deep map, will be keccak256(abi.encode(key1, keccak256(abi.encode(key0, uint(slot)))));</span>
 105 |     | <span class='neutral'>    //  if map struct, will be bytes32(uint256(keccak256(abi.encode(key1, keccak256(abi.encode(key0, uint(slot)))))) + structFieldDepth);</span>
 106 |     | <span class='neutral'>    function find(StdStorage storage self, bool _clear) internal returns (FindData storage) {</span>
 107 |     | <span class='neutral'>        address who = self._target;</span>
 108 |     | <span class='neutral'>        bytes4 fsig = self._sig;</span>
 109 |     | <span class='neutral'>        uint256 field_depth = self._depth;</span>
 110 |     | <span class='neutral'>        bytes memory params = getCallParams(self);</span>
 111 |     | <span class='neutral'></span>
 112 |     | <span class='neutral'>        // calldata to test against</span>
 113 |     | <span class='neutral'>        if (self.finds[who][fsig][keccak256(abi.encodePacked(params, field_depth))].found) {</span>
 114 |     | <span class='neutral'>            if (_clear) {</span>
 115 |     | <span class='neutral'>                clear(self);</span>
 116 |     | <span class='neutral'>            }</span>
 117 |     | <span class='neutral'>            return self.finds[who][fsig][keccak256(abi.encodePacked(params, field_depth))];</span>
 118 |     | <span class='neutral'>        }</span>
 119 |     | <span class='neutral'>        vm.record();</span>
 120 |     | <span class='neutral'>        (, bytes32 callResult) = callTarget(self);</span>
 121 |     | <span class='neutral'>        (bytes32[] memory reads,) = vm.accesses(address(who));</span>
 122 |     | <span class='neutral'></span>
 123 |     | <span class='neutral'>        if (reads.length == 0) {</span>
 124 |     | <span class='neutral'>            revert(&quot;stdStorage find(StdStorage): No storage use detected for target.&quot;);</span>
 125 |     | <span class='neutral'>        } else {</span>
 126 |     | <span class='neutral'>            for (uint256 i = reads.length; --i &gt;= 0;) {</span>
 127 |     | <span class='neutral'>                bytes32 prev = vm.load(who, reads[i]);</span>
 128 |     | <span class='neutral'>                if (prev == bytes32(0)) {</span>
 129 |     | <span class='neutral'>                    emit WARNING_UninitedSlot(who, uint256(reads[i]));</span>
 130 |     | <span class='neutral'>                }</span>
 131 |     | <span class='neutral'></span>
 132 |     | <span class='neutral'>                if (!checkSlotMutatesCall(self, reads[i])) {</span>
 133 |     | <span class='neutral'>                    continue;</span>
 134 |     | <span class='neutral'>                }</span>
 135 |     | <span class='neutral'></span>
 136 |     | <span class='neutral'>                (uint256 offsetLeft, uint256 offsetRight) = (0, 0);</span>
 137 |     | <span class='neutral'></span>
 138 |     | <span class='neutral'>                if (self._enable_packed_slots) {</span>
 139 |     | <span class='neutral'>                    bool found;</span>
 140 |     | <span class='neutral'>                    (found, offsetLeft, offsetRight) = findOffsets(self, reads[i]);</span>
 141 |     | <span class='neutral'>                    if (!found) {</span>
 142 |     | <span class='neutral'>                        continue;</span>
 143 |     | <span class='neutral'>                    }</span>
 144 |     | <span class='neutral'>                }</span>
 145 |     | <span class='neutral'></span>
 146 |     | <span class='neutral'>                // Check that value between found offsets is equal to the current call result</span>
 147 |     | <span class='neutral'>                uint256 curVal = (uint256(prev) &amp; getMaskByOffsets(offsetLeft, offsetRight)) &gt;&gt; offsetRight;</span>
 148 |     | <span class='neutral'></span>
 149 |     | <span class='neutral'>                if (uint256(callResult) != curVal) {</span>
 150 |     | <span class='neutral'>                    continue;</span>
 151 |     | <span class='neutral'>                }</span>
 152 |     | <span class='neutral'></span>
 153 |     | <span class='neutral'>                emit SlotFound(who, fsig, keccak256(abi.encodePacked(params, field_depth)), uint256(reads[i]));</span>
 154 |     | <span class='neutral'>                self.finds[who][fsig][keccak256(abi.encodePacked(params, field_depth))] =</span>
 155 |     | <span class='neutral'>                    FindData(uint256(reads[i]), offsetLeft, offsetRight, true);</span>
 156 |     | <span class='neutral'>                break;</span>
 157 |     | <span class='neutral'>            }</span>
 158 |     | <span class='neutral'>        }</span>
 159 |     | <span class='neutral'></span>
 160 |     | <span class='neutral'>        require(</span>
 161 |     | <span class='neutral'>            self.finds[who][fsig][keccak256(abi.encodePacked(params, field_depth))].found,</span>
 162 |     | <span class='neutral'>            &quot;stdStorage find(StdStorage): Slot(s) not found.&quot;</span>
 163 |     | <span class='neutral'>        );</span>
 164 |     | <span class='neutral'></span>
 165 |     | <span class='neutral'>        if (_clear) {</span>
 166 |     | <span class='neutral'>            clear(self);</span>
 167 |     | <span class='neutral'>        }</span>
 168 |     | <span class='neutral'>        return self.finds[who][fsig][keccak256(abi.encodePacked(params, field_depth))];</span>
 169 |     | <span class='neutral'>    }</span>
 170 |     | <span class='neutral'></span>
 171 |     | <span class='neutral'>    function target(StdStorage storage self, address _target) internal returns (StdStorage storage) {</span>
 172 |     | <span class='neutral'>        self._target = _target;</span>
 173 |     | <span class='neutral'>        return self;</span>
 174 |     | <span class='neutral'>    }</span>
 175 |     | <span class='neutral'></span>
 176 |     | <span class='neutral'>    function sig(StdStorage storage self, bytes4 _sig) internal returns (StdStorage storage) {</span>
 177 |     | <span class='neutral'>        self._sig = _sig;</span>
 178 |     | <span class='neutral'>        return self;</span>
 179 |     | <span class='neutral'>    }</span>
 180 |     | <span class='neutral'></span>
 181 |     | <span class='neutral'>    function sig(StdStorage storage self, string memory _sig) internal returns (StdStorage storage) {</span>
 182 |     | <span class='neutral'>        self._sig = sigs(_sig);</span>
 183 |     | <span class='neutral'>        return self;</span>
 184 |     | <span class='neutral'>    }</span>
 185 |     | <span class='neutral'></span>
 186 |     | <span class='neutral'>    function with_calldata(StdStorage storage self, bytes memory _calldata) internal returns (StdStorage storage) {</span>
 187 |     | <span class='neutral'>        self._calldata = _calldata;</span>
 188 |     | <span class='neutral'>        return self;</span>
 189 |     | <span class='neutral'>    }</span>
 190 |     | <span class='neutral'></span>
 191 |     | <span class='neutral'>    function with_key(StdStorage storage self, address who) internal returns (StdStorage storage) {</span>
 192 |     | <span class='neutral'>        self._keys.push(bytes32(uint256(uint160(who))));</span>
 193 |     | <span class='neutral'>        return self;</span>
 194 |     | <span class='neutral'>    }</span>
 195 |     | <span class='neutral'></span>
 196 |     | <span class='neutral'>    function with_key(StdStorage storage self, uint256 amt) internal returns (StdStorage storage) {</span>
 197 |     | <span class='neutral'>        self._keys.push(bytes32(amt));</span>
 198 |     | <span class='neutral'>        return self;</span>
 199 |     | <span class='neutral'>    }</span>
 200 |     | <span class='neutral'></span>
 201 |     | <span class='neutral'>    function with_key(StdStorage storage self, bytes32 key) internal returns (StdStorage storage) {</span>
 202 |     | <span class='neutral'>        self._keys.push(key);</span>
 203 |     | <span class='neutral'>        return self;</span>
 204 |     | <span class='neutral'>    }</span>
 205 |     | <span class='neutral'></span>
 206 |     | <span class='neutral'>    function enable_packed_slots(StdStorage storage self) internal returns (StdStorage storage) {</span>
 207 |     | <span class='neutral'>        self._enable_packed_slots = true;</span>
 208 |     | <span class='neutral'>        return self;</span>
 209 |     | <span class='neutral'>    }</span>
 210 |     | <span class='neutral'></span>
 211 |     | <span class='neutral'>    function depth(StdStorage storage self, uint256 _depth) internal returns (StdStorage storage) {</span>
 212 |     | <span class='neutral'>        self._depth = _depth;</span>
 213 |     | <span class='neutral'>        return self;</span>
 214 |     | <span class='neutral'>    }</span>
 215 |     | <span class='neutral'></span>
 216 |     | <span class='neutral'>    function read(StdStorage storage self) private returns (bytes memory) {</span>
 217 |     | <span class='neutral'>        FindData storage data = find(self, false);</span>
 218 |     | <span class='neutral'>        uint256 mask = getMaskByOffsets(data.offsetLeft, data.offsetRight);</span>
 219 |     | <span class='neutral'>        uint256 value = (uint256(vm.load(self._target, bytes32(data.slot))) &amp; mask) &gt;&gt; data.offsetRight;</span>
 220 |     | <span class='neutral'>        clear(self);</span>
 221 |     | <span class='neutral'>        return abi.encode(value);</span>
 222 |     | <span class='neutral'>    }</span>
 223 |     | <span class='neutral'></span>
 224 |     | <span class='neutral'>    function read_bytes32(StdStorage storage self) internal returns (bytes32) {</span>
 225 |     | <span class='neutral'>        return abi.decode(read(self), (bytes32));</span>
 226 |     | <span class='neutral'>    }</span>
 227 |     | <span class='neutral'></span>
 228 |     | <span class='neutral'>    function read_bool(StdStorage storage self) internal returns (bool) {</span>
 229 |     | <span class='neutral'>        int256 v = read_int(self);</span>
 230 |     | <span class='neutral'>        if (v == 0) return false;</span>
 231 |     | <span class='neutral'>        if (v == 1) return true;</span>
 232 |     | <span class='neutral'>        revert(&quot;stdStorage read_bool(StdStorage): Cannot decode. Make sure you are reading a bool.&quot;);</span>
 233 |     | <span class='neutral'>    }</span>
 234 |     | <span class='neutral'></span>
 235 |     | <span class='neutral'>    function read_address(StdStorage storage self) internal returns (address) {</span>
 236 |     | <span class='neutral'>        return abi.decode(read(self), (address));</span>
 237 |     | <span class='neutral'>    }</span>
 238 |     | <span class='neutral'></span>
 239 |     | <span class='neutral'>    function read_uint(StdStorage storage self) internal returns (uint256) {</span>
 240 |     | <span class='neutral'>        return abi.decode(read(self), (uint256));</span>
 241 |     | <span class='neutral'>    }</span>
 242 |     | <span class='neutral'></span>
 243 |     | <span class='neutral'>    function read_int(StdStorage storage self) internal returns (int256) {</span>
 244 |     | <span class='neutral'>        return abi.decode(read(self), (int256));</span>
 245 |     | <span class='neutral'>    }</span>
 246 |     | <span class='neutral'></span>
 247 |     | <span class='neutral'>    function parent(StdStorage storage self) internal returns (uint256, bytes32) {</span>
 248 |     | <span class='neutral'>        address who = self._target;</span>
 249 |     | <span class='neutral'>        uint256 field_depth = self._depth;</span>
 250 |     | <span class='neutral'>        vm.startMappingRecording();</span>
 251 |     | <span class='neutral'>        uint256 child = find(self, true).slot - field_depth;</span>
 252 |     | <span class='neutral'>        (bool found, bytes32 key, bytes32 parent_slot) = vm.getMappingKeyAndParentOf(who, bytes32(child));</span>
 253 |     | <span class='neutral'>        if (!found) {</span>
 254 |     | <span class='neutral'>            revert(</span>
 255 |     | <span class='neutral'>                &quot;stdStorage read_bool(StdStorage): Cannot find parent. Make sure you give a slot and startMappingRecording() has been called.&quot;</span>
 256 |     | <span class='neutral'>            );</span>
 257 |     | <span class='neutral'>        }</span>
 258 |     | <span class='neutral'>        return (uint256(parent_slot), key);</span>
 259 |     | <span class='neutral'>    }</span>
 260 |     | <span class='neutral'></span>
 261 |     | <span class='neutral'>    function root(StdStorage storage self) internal returns (uint256) {</span>
 262 |     | <span class='neutral'>        address who = self._target;</span>
 263 |     | <span class='neutral'>        uint256 field_depth = self._depth;</span>
 264 |     | <span class='neutral'>        vm.startMappingRecording();</span>
 265 |     | <span class='neutral'>        uint256 child = find(self, true).slot - field_depth;</span>
 266 |     | <span class='neutral'>        bool found;</span>
 267 |     | <span class='neutral'>        bytes32 root_slot;</span>
 268 |     | <span class='neutral'>        bytes32 parent_slot;</span>
 269 |     | <span class='neutral'>        (found,, parent_slot) = vm.getMappingKeyAndParentOf(who, bytes32(child));</span>
 270 |     | <span class='neutral'>        if (!found) {</span>
 271 |     | <span class='neutral'>            revert(</span>
 272 |     | <span class='neutral'>                &quot;stdStorage read_bool(StdStorage): Cannot find parent. Make sure you give a slot and startMappingRecording() has been called.&quot;</span>
 273 |     | <span class='neutral'>            );</span>
 274 |     | <span class='neutral'>        }</span>
 275 |     | <span class='neutral'>        while (found) {</span>
 276 |     | <span class='neutral'>            root_slot = parent_slot;</span>
 277 |     | <span class='neutral'>            (found,, parent_slot) = vm.getMappingKeyAndParentOf(who, bytes32(root_slot));</span>
 278 |     | <span class='neutral'>        }</span>
 279 |     | <span class='neutral'>        return uint256(root_slot);</span>
 280 |     | <span class='neutral'>    }</span>
 281 |     | <span class='neutral'></span>
 282 |     | <span class='neutral'>    function bytesToBytes32(bytes memory b, uint256 offset) private pure returns (bytes32) {</span>
 283 |     | <span class='neutral'>        bytes32 out;</span>
 284 |     | <span class='neutral'></span>
 285 |     | <span class='neutral'>        uint256 max = b.length &gt; 32 ? 32 : b.length;</span>
 286 |     | <span class='neutral'>        for (uint256 i = 0; i &lt; max; i++) {</span>
 287 |     | <span class='neutral'>            out |= bytes32(b[offset + i] &amp; 0xFF) &gt;&gt; (i * 8);</span>
 288 |     | <span class='neutral'>        }</span>
 289 |     | <span class='neutral'>        return out;</span>
 290 |     | <span class='neutral'>    }</span>
 291 |     | <span class='neutral'></span>
 292 |     | <span class='neutral'>    function flatten(bytes32[] memory b) private pure returns (bytes memory) {</span>
 293 |     | <span class='neutral'>        bytes memory result = new bytes(b.length * 32);</span>
 294 |     | <span class='neutral'>        for (uint256 i = 0; i &lt; b.length; i++) {</span>
 295 |     | <span class='neutral'>            bytes32 k = b[i];</span>
 296 |     | <span class='neutral'>            /// @solidity memory-safe-assembly</span>
 297 |     | <span class='neutral'>            assembly {</span>
 298 |     | <span class='neutral'>                mstore(add(result, add(32, mul(32, i))), k)</span>
 299 |     | <span class='neutral'>            }</span>
 300 |     | <span class='neutral'>        }</span>
 301 |     | <span class='neutral'></span>
 302 |     | <span class='neutral'>        return result;</span>
 303 |     | <span class='neutral'>    }</span>
 304 |     | <span class='neutral'></span>
 305 |     | <span class='neutral'>    function clear(StdStorage storage self) internal {</span>
 306 |     | <span class='neutral'>        delete self._target;</span>
 307 |     | <span class='neutral'>        delete self._sig;</span>
 308 |     | <span class='neutral'>        delete self._keys;</span>
 309 |     | <span class='neutral'>        delete self._depth;</span>
 310 |     | <span class='neutral'>        delete self._enable_packed_slots;</span>
 311 |     | <span class='neutral'>        delete self._calldata;</span>
 312 |     | <span class='neutral'>    }</span>
 313 |     | <span class='neutral'></span>
 314 |     | <span class='neutral'>    // Returns mask which contains non-zero bits for values between `offsetLeft` and `offsetRight`</span>
 315 |     | <span class='neutral'>    // (slotValue &amp; mask) &gt;&gt; offsetRight will be the value of the given packed variable</span>
 316 |     | <span class='neutral'>    function getMaskByOffsets(uint256 offsetLeft, uint256 offsetRight) internal pure returns (uint256 mask) {</span>
 317 |     | <span class='neutral'>        // mask = ((1 &lt;&lt; (256 - (offsetRight + offsetLeft))) - 1) &lt;&lt; offsetRight;</span>
 318 |     | <span class='neutral'>        // using assembly because (1 &lt;&lt; 256) causes overflow</span>
 319 |     | <span class='neutral'>        assembly {</span>
 320 |     | <span class='neutral'>            mask := shl(offsetRight, sub(shl(sub(256, add(offsetRight, offsetLeft)), 1), 1))</span>
 321 |     | <span class='neutral'>        }</span>
 322 |     | <span class='neutral'>    }</span>
 323 |     | <span class='neutral'></span>
 324 |     | <span class='neutral'>    // Returns slot value with updated packed variable.</span>
 325 |     | <span class='neutral'>    function getUpdatedSlotValue(bytes32 curValue, uint256 varValue, uint256 offsetLeft, uint256 offsetRight)</span>
 326 |     | <span class='neutral'>        internal</span>
 327 |     | <span class='neutral'>        pure</span>
 328 |     | <span class='neutral'>        returns (bytes32 newValue)</span>
 329 |     | <span class='neutral'>    {</span>
 330 |     | <span class='neutral'>        return bytes32((uint256(curValue) &amp; ~getMaskByOffsets(offsetLeft, offsetRight)) | (varValue &lt;&lt; offsetRight));</span>
 331 |     | <span class='neutral'>    }</span>
 332 |     | <span class='neutral'>}</span>
 333 |     | <span class='neutral'></span>
 334 |     | <span class='unexecuted'>library stdStorage {</span>
 335 |     | <span class='neutral'>    Vm private constant vm = Vm(address(uint160(uint256(keccak256(&quot;hevm cheat code&quot;)))));</span>
 336 |     | <span class='neutral'></span>
 337 |     | <span class='neutral'>    function sigs(string memory sigStr) internal pure returns (bytes4) {</span>
 338 |     | <span class='neutral'>        return stdStorageSafe.sigs(sigStr);</span>
 339 |     | <span class='neutral'>    }</span>
 340 |     | <span class='neutral'></span>
 341 |     | <span class='neutral'>    function find(StdStorage storage self) internal returns (uint256) {</span>
 342 |     | <span class='neutral'>        return find(self, true);</span>
 343 |     | <span class='neutral'>    }</span>
 344 |     | <span class='neutral'></span>
 345 |     | <span class='neutral'>    function find(StdStorage storage self, bool _clear) internal returns (uint256) {</span>
 346 |     | <span class='neutral'>        return stdStorageSafe.find(self, _clear).slot;</span>
 347 |     | <span class='neutral'>    }</span>
 348 |     | <span class='neutral'></span>
 349 |     | <span class='neutral'>    function target(StdStorage storage self, address _target) internal returns (StdStorage storage) {</span>
 350 |     | <span class='neutral'>        return stdStorageSafe.target(self, _target);</span>
 351 |     | <span class='neutral'>    }</span>
 352 |     | <span class='neutral'></span>
 353 |     | <span class='neutral'>    function sig(StdStorage storage self, bytes4 _sig) internal returns (StdStorage storage) {</span>
 354 |     | <span class='neutral'>        return stdStorageSafe.sig(self, _sig);</span>
 355 |     | <span class='neutral'>    }</span>
 356 |     | <span class='neutral'></span>
 357 |     | <span class='neutral'>    function sig(StdStorage storage self, string memory _sig) internal returns (StdStorage storage) {</span>
 358 |     | <span class='neutral'>        return stdStorageSafe.sig(self, _sig);</span>
 359 |     | <span class='neutral'>    }</span>
 360 |     | <span class='neutral'></span>
 361 |     | <span class='neutral'>    function with_key(StdStorage storage self, address who) internal returns (StdStorage storage) {</span>
 362 |     | <span class='neutral'>        return stdStorageSafe.with_key(self, who);</span>
 363 |     | <span class='neutral'>    }</span>
 364 |     | <span class='neutral'></span>
 365 |     | <span class='neutral'>    function with_key(StdStorage storage self, uint256 amt) internal returns (StdStorage storage) {</span>
 366 |     | <span class='neutral'>        return stdStorageSafe.with_key(self, amt);</span>
 367 |     | <span class='neutral'>    }</span>
 368 |     | <span class='neutral'></span>
 369 |     | <span class='neutral'>    function with_key(StdStorage storage self, bytes32 key) internal returns (StdStorage storage) {</span>
 370 |     | <span class='neutral'>        return stdStorageSafe.with_key(self, key);</span>
 371 |     | <span class='neutral'>    }</span>
 372 |     | <span class='neutral'></span>
 373 |     | <span class='neutral'>    function with_calldata(StdStorage storage self, bytes memory _calldata) internal returns (StdStorage storage) {</span>
 374 |     | <span class='neutral'>        return stdStorageSafe.with_calldata(self, _calldata);</span>
 375 |     | <span class='neutral'>    }</span>
 376 |     | <span class='neutral'></span>
 377 |     | <span class='neutral'>    function enable_packed_slots(StdStorage storage self) internal returns (StdStorage storage) {</span>
 378 |     | <span class='neutral'>        return stdStorageSafe.enable_packed_slots(self);</span>
 379 |     | <span class='neutral'>    }</span>
 380 |     | <span class='neutral'></span>
 381 |     | <span class='neutral'>    function depth(StdStorage storage self, uint256 _depth) internal returns (StdStorage storage) {</span>
 382 |     | <span class='neutral'>        return stdStorageSafe.depth(self, _depth);</span>
 383 |     | <span class='neutral'>    }</span>
 384 |     | <span class='neutral'></span>
 385 |     | <span class='neutral'>    function clear(StdStorage storage self) internal {</span>
 386 |     | <span class='neutral'>        stdStorageSafe.clear(self);</span>
 387 |     | <span class='neutral'>    }</span>
 388 |     | <span class='neutral'></span>
 389 |     | <span class='neutral'>    function checked_write(StdStorage storage self, address who) internal {</span>
 390 |     | <span class='neutral'>        checked_write(self, bytes32(uint256(uint160(who))));</span>
 391 |     | <span class='neutral'>    }</span>
 392 |     | <span class='neutral'></span>
 393 |     | <span class='neutral'>    function checked_write(StdStorage storage self, uint256 amt) internal {</span>
 394 |     | <span class='neutral'>        checked_write(self, bytes32(amt));</span>
 395 |     | <span class='neutral'>    }</span>
 396 |     | <span class='neutral'></span>
 397 |     | <span class='neutral'>    function checked_write_int(StdStorage storage self, int256 val) internal {</span>
 398 |     | <span class='neutral'>        checked_write(self, bytes32(uint256(val)));</span>
 399 |     | <span class='neutral'>    }</span>
 400 |     | <span class='neutral'></span>
 401 |     | <span class='neutral'>    function checked_write(StdStorage storage self, bool write) internal {</span>
 402 |     | <span class='neutral'>        bytes32 t;</span>
 403 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 404 |     | <span class='neutral'>        assembly {</span>
 405 |     | <span class='neutral'>            t := write</span>
 406 |     | <span class='neutral'>        }</span>
 407 |     | <span class='neutral'>        checked_write(self, t);</span>
 408 |     | <span class='neutral'>    }</span>
 409 |     | <span class='neutral'></span>
 410 |     | <span class='neutral'>    function checked_write(StdStorage storage self, bytes32 set) internal {</span>
 411 |     | <span class='neutral'>        address who = self._target;</span>
 412 |     | <span class='neutral'>        bytes4 fsig = self._sig;</span>
 413 |     | <span class='neutral'>        uint256 field_depth = self._depth;</span>
 414 |     | <span class='neutral'>        bytes memory params = stdStorageSafe.getCallParams(self);</span>
 415 |     | <span class='neutral'></span>
 416 |     | <span class='neutral'>        if (!self.finds[who][fsig][keccak256(abi.encodePacked(params, field_depth))].found) {</span>
 417 |     | <span class='neutral'>            find(self, false);</span>
 418 |     | <span class='neutral'>        }</span>
 419 |     | <span class='neutral'>        FindData storage data = self.finds[who][fsig][keccak256(abi.encodePacked(params, field_depth))];</span>
 420 |     | <span class='neutral'>        if ((data.offsetLeft + data.offsetRight) &gt; 0) {</span>
 421 |     | <span class='neutral'>            uint256 maxVal = 2 ** (256 - (data.offsetLeft + data.offsetRight));</span>
 422 |     | <span class='neutral'>            require(</span>
 423 |     | <span class='neutral'>                uint256(set) &lt; maxVal,</span>
 424 |     | <span class='neutral'>                string(</span>
 425 |     | <span class='neutral'>                    abi.encodePacked(</span>
 426 |     | <span class='neutral'>                        &quot;stdStorage find(StdStorage): Packed slot. We can&#39;t fit value greater than &quot;,</span>
 427 |     | <span class='neutral'>                        vm.toString(maxVal)</span>
 428 |     | <span class='neutral'>                    )</span>
 429 |     | <span class='neutral'>                )</span>
 430 |     | <span class='neutral'>            );</span>
 431 |     | <span class='neutral'>        }</span>
 432 |     | <span class='neutral'>        bytes32 curVal = vm.load(who, bytes32(data.slot));</span>
 433 |     | <span class='neutral'>        bytes32 valToSet = stdStorageSafe.getUpdatedSlotValue(curVal, uint256(set), data.offsetLeft, data.offsetRight);</span>
 434 |     | <span class='neutral'></span>
 435 |     | <span class='neutral'>        vm.store(who, bytes32(data.slot), valToSet);</span>
 436 |     | <span class='neutral'></span>
 437 |     | <span class='neutral'>        (bool success, bytes32 callResult) = stdStorageSafe.callTarget(self);</span>
 438 |     | <span class='neutral'></span>
 439 |     | <span class='neutral'>        if (!success || callResult != set) {</span>
 440 |     | <span class='neutral'>            vm.store(who, bytes32(data.slot), curVal);</span>
 441 |     | <span class='neutral'>            revert(&quot;stdStorage find(StdStorage): Failed to write value.&quot;);</span>
 442 |     | <span class='neutral'>        }</span>
 443 |     | <span class='neutral'>        clear(self);</span>
 444 |     | <span class='neutral'>    }</span>
 445 |     | <span class='neutral'></span>
 446 |     | <span class='neutral'>    function read_bytes32(StdStorage storage self) internal returns (bytes32) {</span>
 447 |     | <span class='neutral'>        return stdStorageSafe.read_bytes32(self);</span>
 448 |     | <span class='neutral'>    }</span>
 449 |     | <span class='neutral'></span>
 450 |     | <span class='neutral'>    function read_bool(StdStorage storage self) internal returns (bool) {</span>
 451 |     | <span class='neutral'>        return stdStorageSafe.read_bool(self);</span>
 452 |     | <span class='neutral'>    }</span>
 453 |     | <span class='neutral'></span>
 454 |     | <span class='neutral'>    function read_address(StdStorage storage self) internal returns (address) {</span>
 455 |     | <span class='neutral'>        return stdStorageSafe.read_address(self);</span>
 456 |     | <span class='neutral'>    }</span>
 457 |     | <span class='neutral'></span>
 458 |     | <span class='neutral'>    function read_uint(StdStorage storage self) internal returns (uint256) {</span>
 459 |     | <span class='neutral'>        return stdStorageSafe.read_uint(self);</span>
 460 |     | <span class='neutral'>    }</span>
 461 |     | <span class='neutral'></span>
 462 |     | <span class='neutral'>    function read_int(StdStorage storage self) internal returns (int256) {</span>
 463 |     | <span class='neutral'>        return stdStorageSafe.read_int(self);</span>
 464 |     | <span class='neutral'>    }</span>
 465 |     | <span class='neutral'></span>
 466 |     | <span class='neutral'>    function parent(StdStorage storage self) internal returns (uint256, bytes32) {</span>
 467 |     | <span class='neutral'>        return stdStorageSafe.parent(self);</span>
 468 |     | <span class='neutral'>    }</span>
 469 |     | <span class='neutral'></span>
 470 |     | <span class='neutral'>    function root(StdStorage storage self) internal returns (uint256) {</span>
 471 |     | <span class='neutral'>        return stdStorageSafe.root(self);</span>
 472 |     | <span class='neutral'>    }</span>
 473 |     | <span class='neutral'>}</span>
 474 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/phantom/Documents/azemora/azemora-contracts/lib/forge-std/src/StdStyle.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'>pragma solidity &gt;=0.4.22 &lt;0.9.0;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>import {VmSafe} from &quot;./Vm.sol&quot;;</span>
   5 |     | <span class='neutral'></span>
   6 |     | <span class='unexecuted'>library StdStyle {</span>
   7 |     | <span class='neutral'>    VmSafe private constant vm = VmSafe(address(uint160(uint256(keccak256(&quot;hevm cheat code&quot;)))));</span>
   8 |     | <span class='neutral'></span>
   9 |     | <span class='neutral'>    string constant RED = &quot;\u001b[91m&quot;;</span>
  10 |     | <span class='neutral'>    string constant GREEN = &quot;\u001b[92m&quot;;</span>
  11 |     | <span class='neutral'>    string constant YELLOW = &quot;\u001b[93m&quot;;</span>
  12 |     | <span class='neutral'>    string constant BLUE = &quot;\u001b[94m&quot;;</span>
  13 |     | <span class='neutral'>    string constant MAGENTA = &quot;\u001b[95m&quot;;</span>
  14 |     | <span class='neutral'>    string constant CYAN = &quot;\u001b[96m&quot;;</span>
  15 |     | <span class='neutral'>    string constant BOLD = &quot;\u001b[1m&quot;;</span>
  16 |     | <span class='neutral'>    string constant DIM = &quot;\u001b[2m&quot;;</span>
  17 |     | <span class='neutral'>    string constant ITALIC = &quot;\u001b[3m&quot;;</span>
  18 |     | <span class='neutral'>    string constant UNDERLINE = &quot;\u001b[4m&quot;;</span>
  19 |     | <span class='neutral'>    string constant INVERSE = &quot;\u001b[7m&quot;;</span>
  20 |     | <span class='neutral'>    string constant RESET = &quot;\u001b[0m&quot;;</span>
  21 |     | <span class='neutral'></span>
  22 |     | <span class='neutral'>    function styleConcat(string memory style, string memory self) private pure returns (string memory) {</span>
  23 |     | <span class='neutral'>        return string(abi.encodePacked(style, self, RESET));</span>
  24 |     | <span class='neutral'>    }</span>
  25 |     | <span class='neutral'></span>
  26 |     | <span class='neutral'>    function red(string memory self) internal pure returns (string memory) {</span>
  27 |     | <span class='neutral'>        return styleConcat(RED, self);</span>
  28 |     | <span class='neutral'>    }</span>
  29 |     | <span class='neutral'></span>
  30 |     | <span class='neutral'>    function red(uint256 self) internal pure returns (string memory) {</span>
  31 |     | <span class='neutral'>        return red(vm.toString(self));</span>
  32 |     | <span class='neutral'>    }</span>
  33 |     | <span class='neutral'></span>
  34 |     | <span class='neutral'>    function red(int256 self) internal pure returns (string memory) {</span>
  35 |     | <span class='neutral'>        return red(vm.toString(self));</span>
  36 |     | <span class='neutral'>    }</span>
  37 |     | <span class='neutral'></span>
  38 |     | <span class='neutral'>    function red(address self) internal pure returns (string memory) {</span>
  39 |     | <span class='neutral'>        return red(vm.toString(self));</span>
  40 |     | <span class='neutral'>    }</span>
  41 |     | <span class='neutral'></span>
  42 |     | <span class='neutral'>    function red(bool self) internal pure returns (string memory) {</span>
  43 |     | <span class='neutral'>        return red(vm.toString(self));</span>
  44 |     | <span class='neutral'>    }</span>
  45 |     | <span class='neutral'></span>
  46 |     | <span class='neutral'>    function redBytes(bytes memory self) internal pure returns (string memory) {</span>
  47 |     | <span class='neutral'>        return red(vm.toString(self));</span>
  48 |     | <span class='neutral'>    }</span>
  49 |     | <span class='neutral'></span>
  50 |     | <span class='neutral'>    function redBytes32(bytes32 self) internal pure returns (string memory) {</span>
  51 |     | <span class='neutral'>        return red(vm.toString(self));</span>
  52 |     | <span class='neutral'>    }</span>
  53 |     | <span class='neutral'></span>
  54 |     | <span class='neutral'>    function green(string memory self) internal pure returns (string memory) {</span>
  55 |     | <span class='neutral'>        return styleConcat(GREEN, self);</span>
  56 |     | <span class='neutral'>    }</span>
  57 |     | <span class='neutral'></span>
  58 |     | <span class='neutral'>    function green(uint256 self) internal pure returns (string memory) {</span>
  59 |     | <span class='neutral'>        return green(vm.toString(self));</span>
  60 |     | <span class='neutral'>    }</span>
  61 |     | <span class='neutral'></span>
  62 |     | <span class='neutral'>    function green(int256 self) internal pure returns (string memory) {</span>
  63 |     | <span class='neutral'>        return green(vm.toString(self));</span>
  64 |     | <span class='neutral'>    }</span>
  65 |     | <span class='neutral'></span>
  66 |     | <span class='neutral'>    function green(address self) internal pure returns (string memory) {</span>
  67 |     | <span class='neutral'>        return green(vm.toString(self));</span>
  68 |     | <span class='neutral'>    }</span>
  69 |     | <span class='neutral'></span>
  70 |     | <span class='neutral'>    function green(bool self) internal pure returns (string memory) {</span>
  71 |     | <span class='neutral'>        return green(vm.toString(self));</span>
  72 |     | <span class='neutral'>    }</span>
  73 |     | <span class='neutral'></span>
  74 |     | <span class='neutral'>    function greenBytes(bytes memory self) internal pure returns (string memory) {</span>
  75 |     | <span class='neutral'>        return green(vm.toString(self));</span>
  76 |     | <span class='neutral'>    }</span>
  77 |     | <span class='neutral'></span>
  78 |     | <span class='neutral'>    function greenBytes32(bytes32 self) internal pure returns (string memory) {</span>
  79 |     | <span class='neutral'>        return green(vm.toString(self));</span>
  80 |     | <span class='neutral'>    }</span>
  81 |     | <span class='neutral'></span>
  82 |     | <span class='neutral'>    function yellow(string memory self) internal pure returns (string memory) {</span>
  83 |     | <span class='neutral'>        return styleConcat(YELLOW, self);</span>
  84 |     | <span class='neutral'>    }</span>
  85 |     | <span class='neutral'></span>
  86 |     | <span class='neutral'>    function yellow(uint256 self) internal pure returns (string memory) {</span>
  87 |     | <span class='neutral'>        return yellow(vm.toString(self));</span>
  88 |     | <span class='neutral'>    }</span>
  89 |     | <span class='neutral'></span>
  90 |     | <span class='neutral'>    function yellow(int256 self) internal pure returns (string memory) {</span>
  91 |     | <span class='neutral'>        return yellow(vm.toString(self));</span>
  92 |     | <span class='neutral'>    }</span>
  93 |     | <span class='neutral'></span>
  94 |     | <span class='neutral'>    function yellow(address self) internal pure returns (string memory) {</span>
  95 |     | <span class='neutral'>        return yellow(vm.toString(self));</span>
  96 |     | <span class='neutral'>    }</span>
  97 |     | <span class='neutral'></span>
  98 |     | <span class='neutral'>    function yellow(bool self) internal pure returns (string memory) {</span>
  99 |     | <span class='neutral'>        return yellow(vm.toString(self));</span>
 100 |     | <span class='neutral'>    }</span>
 101 |     | <span class='neutral'></span>
 102 |     | <span class='neutral'>    function yellowBytes(bytes memory self) internal pure returns (string memory) {</span>
 103 |     | <span class='neutral'>        return yellow(vm.toString(self));</span>
 104 |     | <span class='neutral'>    }</span>
 105 |     | <span class='neutral'></span>
 106 |     | <span class='neutral'>    function yellowBytes32(bytes32 self) internal pure returns (string memory) {</span>
 107 |     | <span class='neutral'>        return yellow(vm.toString(self));</span>
 108 |     | <span class='neutral'>    }</span>
 109 |     | <span class='neutral'></span>
 110 |     | <span class='neutral'>    function blue(string memory self) internal pure returns (string memory) {</span>
 111 |     | <span class='neutral'>        return styleConcat(BLUE, self);</span>
 112 |     | <span class='neutral'>    }</span>
 113 |     | <span class='neutral'></span>
 114 |     | <span class='neutral'>    function blue(uint256 self) internal pure returns (string memory) {</span>
 115 |     | <span class='neutral'>        return blue(vm.toString(self));</span>
 116 |     | <span class='neutral'>    }</span>
 117 |     | <span class='neutral'></span>
 118 |     | <span class='neutral'>    function blue(int256 self) internal pure returns (string memory) {</span>
 119 |     | <span class='neutral'>        return blue(vm.toString(self));</span>
 120 |     | <span class='neutral'>    }</span>
 121 |     | <span class='neutral'></span>
 122 |     | <span class='neutral'>    function blue(address self) internal pure returns (string memory) {</span>
 123 |     | <span class='neutral'>        return blue(vm.toString(self));</span>
 124 |     | <span class='neutral'>    }</span>
 125 |     | <span class='neutral'></span>
 126 |     | <span class='neutral'>    function blue(bool self) internal pure returns (string memory) {</span>
 127 |     | <span class='neutral'>        return blue(vm.toString(self));</span>
 128 |     | <span class='neutral'>    }</span>
 129 |     | <span class='neutral'></span>
 130 |     | <span class='neutral'>    function blueBytes(bytes memory self) internal pure returns (string memory) {</span>
 131 |     | <span class='neutral'>        return blue(vm.toString(self));</span>
 132 |     | <span class='neutral'>    }</span>
 133 |     | <span class='neutral'></span>
 134 |     | <span class='neutral'>    function blueBytes32(bytes32 self) internal pure returns (string memory) {</span>
 135 |     | <span class='neutral'>        return blue(vm.toString(self));</span>
 136 |     | <span class='neutral'>    }</span>
 137 |     | <span class='neutral'></span>
 138 |     | <span class='neutral'>    function magenta(string memory self) internal pure returns (string memory) {</span>
 139 |     | <span class='neutral'>        return styleConcat(MAGENTA, self);</span>
 140 |     | <span class='neutral'>    }</span>
 141 |     | <span class='neutral'></span>
 142 |     | <span class='neutral'>    function magenta(uint256 self) internal pure returns (string memory) {</span>
 143 |     | <span class='neutral'>        return magenta(vm.toString(self));</span>
 144 |     | <span class='neutral'>    }</span>
 145 |     | <span class='neutral'></span>
 146 |     | <span class='neutral'>    function magenta(int256 self) internal pure returns (string memory) {</span>
 147 |     | <span class='neutral'>        return magenta(vm.toString(self));</span>
 148 |     | <span class='neutral'>    }</span>
 149 |     | <span class='neutral'></span>
 150 |     | <span class='neutral'>    function magenta(address self) internal pure returns (string memory) {</span>
 151 |     | <span class='neutral'>        return magenta(vm.toString(self));</span>
 152 |     | <span class='neutral'>    }</span>
 153 |     | <span class='neutral'></span>
 154 |     | <span class='neutral'>    function magenta(bool self) internal pure returns (string memory) {</span>
 155 |     | <span class='neutral'>        return magenta(vm.toString(self));</span>
 156 |     | <span class='neutral'>    }</span>
 157 |     | <span class='neutral'></span>
 158 |     | <span class='neutral'>    function magentaBytes(bytes memory self) internal pure returns (string memory) {</span>
 159 |     | <span class='neutral'>        return magenta(vm.toString(self));</span>
 160 |     | <span class='neutral'>    }</span>
 161 |     | <span class='neutral'></span>
 162 |     | <span class='neutral'>    function magentaBytes32(bytes32 self) internal pure returns (string memory) {</span>
 163 |     | <span class='neutral'>        return magenta(vm.toString(self));</span>
 164 |     | <span class='neutral'>    }</span>
 165 |     | <span class='neutral'></span>
 166 |     | <span class='neutral'>    function cyan(string memory self) internal pure returns (string memory) {</span>
 167 |     | <span class='neutral'>        return styleConcat(CYAN, self);</span>
 168 |     | <span class='neutral'>    }</span>
 169 |     | <span class='neutral'></span>
 170 |     | <span class='neutral'>    function cyan(uint256 self) internal pure returns (string memory) {</span>
 171 |     | <span class='neutral'>        return cyan(vm.toString(self));</span>
 172 |     | <span class='neutral'>    }</span>
 173 |     | <span class='neutral'></span>
 174 |     | <span class='neutral'>    function cyan(int256 self) internal pure returns (string memory) {</span>
 175 |     | <span class='neutral'>        return cyan(vm.toString(self));</span>
 176 |     | <span class='neutral'>    }</span>
 177 |     | <span class='neutral'></span>
 178 |     | <span class='neutral'>    function cyan(address self) internal pure returns (string memory) {</span>
 179 |     | <span class='neutral'>        return cyan(vm.toString(self));</span>
 180 |     | <span class='neutral'>    }</span>
 181 |     | <span class='neutral'></span>
 182 |     | <span class='neutral'>    function cyan(bool self) internal pure returns (string memory) {</span>
 183 |     | <span class='neutral'>        return cyan(vm.toString(self));</span>
 184 |     | <span class='neutral'>    }</span>
 185 |     | <span class='neutral'></span>
 186 |     | <span class='neutral'>    function cyanBytes(bytes memory self) internal pure returns (string memory) {</span>
 187 |     | <span class='neutral'>        return cyan(vm.toString(self));</span>
 188 |     | <span class='neutral'>    }</span>
 189 |     | <span class='neutral'></span>
 190 |     | <span class='neutral'>    function cyanBytes32(bytes32 self) internal pure returns (string memory) {</span>
 191 |     | <span class='neutral'>        return cyan(vm.toString(self));</span>
 192 |     | <span class='neutral'>    }</span>
 193 |     | <span class='neutral'></span>
 194 |     | <span class='neutral'>    function bold(string memory self) internal pure returns (string memory) {</span>
 195 |     | <span class='neutral'>        return styleConcat(BOLD, self);</span>
 196 |     | <span class='neutral'>    }</span>
 197 |     | <span class='neutral'></span>
 198 |     | <span class='neutral'>    function bold(uint256 self) internal pure returns (string memory) {</span>
 199 |     | <span class='neutral'>        return bold(vm.toString(self));</span>
 200 |     | <span class='neutral'>    }</span>
 201 |     | <span class='neutral'></span>
 202 |     | <span class='neutral'>    function bold(int256 self) internal pure returns (string memory) {</span>
 203 |     | <span class='neutral'>        return bold(vm.toString(self));</span>
 204 |     | <span class='neutral'>    }</span>
 205 |     | <span class='neutral'></span>
 206 |     | <span class='neutral'>    function bold(address self) internal pure returns (string memory) {</span>
 207 |     | <span class='neutral'>        return bold(vm.toString(self));</span>
 208 |     | <span class='neutral'>    }</span>
 209 |     | <span class='neutral'></span>
 210 |     | <span class='neutral'>    function bold(bool self) internal pure returns (string memory) {</span>
 211 |     | <span class='neutral'>        return bold(vm.toString(self));</span>
 212 |     | <span class='neutral'>    }</span>
 213 |     | <span class='neutral'></span>
 214 |     | <span class='neutral'>    function boldBytes(bytes memory self) internal pure returns (string memory) {</span>
 215 |     | <span class='neutral'>        return bold(vm.toString(self));</span>
 216 |     | <span class='neutral'>    }</span>
 217 |     | <span class='neutral'></span>
 218 |     | <span class='neutral'>    function boldBytes32(bytes32 self) internal pure returns (string memory) {</span>
 219 |     | <span class='neutral'>        return bold(vm.toString(self));</span>
 220 |     | <span class='neutral'>    }</span>
 221 |     | <span class='neutral'></span>
 222 |     | <span class='neutral'>    function dim(string memory self) internal pure returns (string memory) {</span>
 223 |     | <span class='neutral'>        return styleConcat(DIM, self);</span>
 224 |     | <span class='neutral'>    }</span>
 225 |     | <span class='neutral'></span>
 226 |     | <span class='neutral'>    function dim(uint256 self) internal pure returns (string memory) {</span>
 227 |     | <span class='neutral'>        return dim(vm.toString(self));</span>
 228 |     | <span class='neutral'>    }</span>
 229 |     | <span class='neutral'></span>
 230 |     | <span class='neutral'>    function dim(int256 self) internal pure returns (string memory) {</span>
 231 |     | <span class='neutral'>        return dim(vm.toString(self));</span>
 232 |     | <span class='neutral'>    }</span>
 233 |     | <span class='neutral'></span>
 234 |     | <span class='neutral'>    function dim(address self) internal pure returns (string memory) {</span>
 235 |     | <span class='neutral'>        return dim(vm.toString(self));</span>
 236 |     | <span class='neutral'>    }</span>
 237 |     | <span class='neutral'></span>
 238 |     | <span class='neutral'>    function dim(bool self) internal pure returns (string memory) {</span>
 239 |     | <span class='neutral'>        return dim(vm.toString(self));</span>
 240 |     | <span class='neutral'>    }</span>
 241 |     | <span class='neutral'></span>
 242 |     | <span class='neutral'>    function dimBytes(bytes memory self) internal pure returns (string memory) {</span>
 243 |     | <span class='neutral'>        return dim(vm.toString(self));</span>
 244 |     | <span class='neutral'>    }</span>
 245 |     | <span class='neutral'></span>
 246 |     | <span class='neutral'>    function dimBytes32(bytes32 self) internal pure returns (string memory) {</span>
 247 |     | <span class='neutral'>        return dim(vm.toString(self));</span>
 248 |     | <span class='neutral'>    }</span>
 249 |     | <span class='neutral'></span>
 250 |     | <span class='neutral'>    function italic(string memory self) internal pure returns (string memory) {</span>
 251 |     | <span class='neutral'>        return styleConcat(ITALIC, self);</span>
 252 |     | <span class='neutral'>    }</span>
 253 |     | <span class='neutral'></span>
 254 |     | <span class='neutral'>    function italic(uint256 self) internal pure returns (string memory) {</span>
 255 |     | <span class='neutral'>        return italic(vm.toString(self));</span>
 256 |     | <span class='neutral'>    }</span>
 257 |     | <span class='neutral'></span>
 258 |     | <span class='neutral'>    function italic(int256 self) internal pure returns (string memory) {</span>
 259 |     | <span class='neutral'>        return italic(vm.toString(self));</span>
 260 |     | <span class='neutral'>    }</span>
 261 |     | <span class='neutral'></span>
 262 |     | <span class='neutral'>    function italic(address self) internal pure returns (string memory) {</span>
 263 |     | <span class='neutral'>        return italic(vm.toString(self));</span>
 264 |     | <span class='neutral'>    }</span>
 265 |     | <span class='neutral'></span>
 266 |     | <span class='neutral'>    function italic(bool self) internal pure returns (string memory) {</span>
 267 |     | <span class='neutral'>        return italic(vm.toString(self));</span>
 268 |     | <span class='neutral'>    }</span>
 269 |     | <span class='neutral'></span>
 270 |     | <span class='neutral'>    function italicBytes(bytes memory self) internal pure returns (string memory) {</span>
 271 |     | <span class='neutral'>        return italic(vm.toString(self));</span>
 272 |     | <span class='neutral'>    }</span>
 273 |     | <span class='neutral'></span>
 274 |     | <span class='neutral'>    function italicBytes32(bytes32 self) internal pure returns (string memory) {</span>
 275 |     | <span class='neutral'>        return italic(vm.toString(self));</span>
 276 |     | <span class='neutral'>    }</span>
 277 |     | <span class='neutral'></span>
 278 |     | <span class='neutral'>    function underline(string memory self) internal pure returns (string memory) {</span>
 279 |     | <span class='neutral'>        return styleConcat(UNDERLINE, self);</span>
 280 |     | <span class='neutral'>    }</span>
 281 |     | <span class='neutral'></span>
 282 |     | <span class='neutral'>    function underline(uint256 self) internal pure returns (string memory) {</span>
 283 |     | <span class='neutral'>        return underline(vm.toString(self));</span>
 284 |     | <span class='neutral'>    }</span>
 285 |     | <span class='neutral'></span>
 286 |     | <span class='neutral'>    function underline(int256 self) internal pure returns (string memory) {</span>
 287 |     | <span class='neutral'>        return underline(vm.toString(self));</span>
 288 |     | <span class='neutral'>    }</span>
 289 |     | <span class='neutral'></span>
 290 |     | <span class='neutral'>    function underline(address self) internal pure returns (string memory) {</span>
 291 |     | <span class='neutral'>        return underline(vm.toString(self));</span>
 292 |     | <span class='neutral'>    }</span>
 293 |     | <span class='neutral'></span>
 294 |     | <span class='neutral'>    function underline(bool self) internal pure returns (string memory) {</span>
 295 |     | <span class='neutral'>        return underline(vm.toString(self));</span>
 296 |     | <span class='neutral'>    }</span>
 297 |     | <span class='neutral'></span>
 298 |     | <span class='neutral'>    function underlineBytes(bytes memory self) internal pure returns (string memory) {</span>
 299 |     | <span class='neutral'>        return underline(vm.toString(self));</span>
 300 |     | <span class='neutral'>    }</span>
 301 |     | <span class='neutral'></span>
 302 |     | <span class='neutral'>    function underlineBytes32(bytes32 self) internal pure returns (string memory) {</span>
 303 |     | <span class='neutral'>        return underline(vm.toString(self));</span>
 304 |     | <span class='neutral'>    }</span>
 305 |     | <span class='neutral'></span>
 306 |     | <span class='neutral'>    function inverse(string memory self) internal pure returns (string memory) {</span>
 307 |     | <span class='neutral'>        return styleConcat(INVERSE, self);</span>
 308 |     | <span class='neutral'>    }</span>
 309 |     | <span class='neutral'></span>
 310 |     | <span class='neutral'>    function inverse(uint256 self) internal pure returns (string memory) {</span>
 311 |     | <span class='neutral'>        return inverse(vm.toString(self));</span>
 312 |     | <span class='neutral'>    }</span>
 313 |     | <span class='neutral'></span>
 314 |     | <span class='neutral'>    function inverse(int256 self) internal pure returns (string memory) {</span>
 315 |     | <span class='neutral'>        return inverse(vm.toString(self));</span>
 316 |     | <span class='neutral'>    }</span>
 317 |     | <span class='neutral'></span>
 318 |     | <span class='neutral'>    function inverse(address self) internal pure returns (string memory) {</span>
 319 |     | <span class='neutral'>        return inverse(vm.toString(self));</span>
 320 |     | <span class='neutral'>    }</span>
 321 |     | <span class='neutral'></span>
 322 |     | <span class='neutral'>    function inverse(bool self) internal pure returns (string memory) {</span>
 323 |     | <span class='neutral'>        return inverse(vm.toString(self));</span>
 324 |     | <span class='neutral'>    }</span>
 325 |     | <span class='neutral'></span>
 326 |     | <span class='neutral'>    function inverseBytes(bytes memory self) internal pure returns (string memory) {</span>
 327 |     | <span class='neutral'>        return inverse(vm.toString(self));</span>
 328 |     | <span class='neutral'>    }</span>
 329 |     | <span class='neutral'></span>
 330 |     | <span class='neutral'>    function inverseBytes32(bytes32 self) internal pure returns (string memory) {</span>
 331 |     | <span class='neutral'>        return inverse(vm.toString(self));</span>
 332 |     | <span class='neutral'>    }</span>
 333 |     | <span class='neutral'>}</span>
 334 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/phantom/Documents/azemora/azemora-contracts/lib/forge-std/src/StdToml.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'>pragma solidity &gt;=0.6.0 &lt;0.9.0;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>pragma experimental ABIEncoderV2;</span>
   5 |     | <span class='neutral'></span>
   6 |     | <span class='neutral'>import {VmSafe} from &quot;./Vm.sol&quot;;</span>
   7 |     | <span class='neutral'></span>
   8 |     | <span class='neutral'>// Helpers for parsing and writing TOML files</span>
   9 |     | <span class='neutral'>// To parse:</span>
  10 |     | <span class='neutral'>// ```</span>
  11 |     | <span class='neutral'>// using stdToml for string;</span>
  12 |     | <span class='neutral'>// string memory toml = vm.readFile(&quot;&lt;some_path&gt;&quot;);</span>
  13 |     | <span class='neutral'>// toml.readUint(&quot;&lt;json_path&gt;&quot;);</span>
  14 |     | <span class='neutral'>// ```</span>
  15 |     | <span class='neutral'>// To write:</span>
  16 |     | <span class='neutral'>// ```</span>
  17 |     | <span class='neutral'>// using stdToml for string;</span>
  18 |     | <span class='neutral'>// string memory json = &quot;json&quot;;</span>
  19 |     | <span class='neutral'>// json.serialize(&quot;a&quot;, uint256(123));</span>
  20 |     | <span class='neutral'>// string memory semiFinal = json.serialize(&quot;b&quot;, string(&quot;test&quot;));</span>
  21 |     | <span class='neutral'>// string memory finalJson = json.serialize(&quot;c&quot;, semiFinal);</span>
  22 |     | <span class='neutral'>// finalJson.write(&quot;&lt;some_path&gt;&quot;);</span>
  23 |     | <span class='neutral'>// ```</span>
  24 |     | <span class='neutral'></span>
  25 |     | <span class='unexecuted'>library stdToml {</span>
  26 |     | <span class='neutral'>    VmSafe private constant vm = VmSafe(address(uint160(uint256(keccak256(&quot;hevm cheat code&quot;)))));</span>
  27 |     | <span class='neutral'></span>
  28 |     | <span class='neutral'>    function keyExists(string memory toml, string memory key) internal view returns (bool) {</span>
  29 |     | <span class='neutral'>        return vm.keyExistsToml(toml, key);</span>
  30 |     | <span class='neutral'>    }</span>
  31 |     | <span class='neutral'></span>
  32 |     | <span class='neutral'>    function parseRaw(string memory toml, string memory key) internal pure returns (bytes memory) {</span>
  33 |     | <span class='neutral'>        return vm.parseToml(toml, key);</span>
  34 |     | <span class='neutral'>    }</span>
  35 |     | <span class='neutral'></span>
  36 |     | <span class='neutral'>    function readUint(string memory toml, string memory key) internal pure returns (uint256) {</span>
  37 |     | <span class='neutral'>        return vm.parseTomlUint(toml, key);</span>
  38 |     | <span class='neutral'>    }</span>
  39 |     | <span class='neutral'></span>
  40 |     | <span class='neutral'>    function readUintArray(string memory toml, string memory key) internal pure returns (uint256[] memory) {</span>
  41 |     | <span class='neutral'>        return vm.parseTomlUintArray(toml, key);</span>
  42 |     | <span class='neutral'>    }</span>
  43 |     | <span class='neutral'></span>
  44 |     | <span class='neutral'>    function readInt(string memory toml, string memory key) internal pure returns (int256) {</span>
  45 |     | <span class='neutral'>        return vm.parseTomlInt(toml, key);</span>
  46 |     | <span class='neutral'>    }</span>
  47 |     | <span class='neutral'></span>
  48 |     | <span class='neutral'>    function readIntArray(string memory toml, string memory key) internal pure returns (int256[] memory) {</span>
  49 |     | <span class='neutral'>        return vm.parseTomlIntArray(toml, key);</span>
  50 |     | <span class='neutral'>    }</span>
  51 |     | <span class='neutral'></span>
  52 |     | <span class='neutral'>    function readBytes32(string memory toml, string memory key) internal pure returns (bytes32) {</span>
  53 |     | <span class='neutral'>        return vm.parseTomlBytes32(toml, key);</span>
  54 |     | <span class='neutral'>    }</span>
  55 |     | <span class='neutral'></span>
  56 |     | <span class='neutral'>    function readBytes32Array(string memory toml, string memory key) internal pure returns (bytes32[] memory) {</span>
  57 |     | <span class='neutral'>        return vm.parseTomlBytes32Array(toml, key);</span>
  58 |     | <span class='neutral'>    }</span>
  59 |     | <span class='neutral'></span>
  60 |     | <span class='neutral'>    function readString(string memory toml, string memory key) internal pure returns (string memory) {</span>
  61 |     | <span class='neutral'>        return vm.parseTomlString(toml, key);</span>
  62 |     | <span class='neutral'>    }</span>
  63 |     | <span class='neutral'></span>
  64 |     | <span class='neutral'>    function readStringArray(string memory toml, string memory key) internal pure returns (string[] memory) {</span>
  65 |     | <span class='neutral'>        return vm.parseTomlStringArray(toml, key);</span>
  66 |     | <span class='neutral'>    }</span>
  67 |     | <span class='neutral'></span>
  68 |     | <span class='neutral'>    function readAddress(string memory toml, string memory key) internal pure returns (address) {</span>
  69 |     | <span class='neutral'>        return vm.parseTomlAddress(toml, key);</span>
  70 |     | <span class='neutral'>    }</span>
  71 |     | <span class='neutral'></span>
  72 |     | <span class='neutral'>    function readAddressArray(string memory toml, string memory key) internal pure returns (address[] memory) {</span>
  73 |     | <span class='neutral'>        return vm.parseTomlAddressArray(toml, key);</span>
  74 |     | <span class='neutral'>    }</span>
  75 |     | <span class='neutral'></span>
  76 |     | <span class='neutral'>    function readBool(string memory toml, string memory key) internal pure returns (bool) {</span>
  77 |     | <span class='neutral'>        return vm.parseTomlBool(toml, key);</span>
  78 |     | <span class='neutral'>    }</span>
  79 |     | <span class='neutral'></span>
  80 |     | <span class='neutral'>    function readBoolArray(string memory toml, string memory key) internal pure returns (bool[] memory) {</span>
  81 |     | <span class='neutral'>        return vm.parseTomlBoolArray(toml, key);</span>
  82 |     | <span class='neutral'>    }</span>
  83 |     | <span class='neutral'></span>
  84 |     | <span class='neutral'>    function readBytes(string memory toml, string memory key) internal pure returns (bytes memory) {</span>
  85 |     | <span class='neutral'>        return vm.parseTomlBytes(toml, key);</span>
  86 |     | <span class='neutral'>    }</span>
  87 |     | <span class='neutral'></span>
  88 |     | <span class='neutral'>    function readBytesArray(string memory toml, string memory key) internal pure returns (bytes[] memory) {</span>
  89 |     | <span class='neutral'>        return vm.parseTomlBytesArray(toml, key);</span>
  90 |     | <span class='neutral'>    }</span>
  91 |     | <span class='neutral'></span>
  92 |     | <span class='neutral'>    function readUintOr(string memory toml, string memory key, uint256 defaultValue) internal view returns (uint256) {</span>
  93 |     | <span class='neutral'>        return keyExists(toml, key) ? readUint(toml, key) : defaultValue;</span>
  94 |     | <span class='neutral'>    }</span>
  95 |     | <span class='neutral'></span>
  96 |     | <span class='neutral'>    function readUintArrayOr(string memory toml, string memory key, uint256[] memory defaultValue)</span>
  97 |     | <span class='neutral'>        internal</span>
  98 |     | <span class='neutral'>        view</span>
  99 |     | <span class='neutral'>        returns (uint256[] memory)</span>
 100 |     | <span class='neutral'>    {</span>
 101 |     | <span class='neutral'>        return keyExists(toml, key) ? readUintArray(toml, key) : defaultValue;</span>
 102 |     | <span class='neutral'>    }</span>
 103 |     | <span class='neutral'></span>
 104 |     | <span class='neutral'>    function readIntOr(string memory toml, string memory key, int256 defaultValue) internal view returns (int256) {</span>
 105 |     | <span class='neutral'>        return keyExists(toml, key) ? readInt(toml, key) : defaultValue;</span>
 106 |     | <span class='neutral'>    }</span>
 107 |     | <span class='neutral'></span>
 108 |     | <span class='neutral'>    function readIntArrayOr(string memory toml, string memory key, int256[] memory defaultValue)</span>
 109 |     | <span class='neutral'>        internal</span>
 110 |     | <span class='neutral'>        view</span>
 111 |     | <span class='neutral'>        returns (int256[] memory)</span>
 112 |     | <span class='neutral'>    {</span>
 113 |     | <span class='neutral'>        return keyExists(toml, key) ? readIntArray(toml, key) : defaultValue;</span>
 114 |     | <span class='neutral'>    }</span>
 115 |     | <span class='neutral'></span>
 116 |     | <span class='neutral'>    function readBytes32Or(string memory toml, string memory key, bytes32 defaultValue)</span>
 117 |     | <span class='neutral'>        internal</span>
 118 |     | <span class='neutral'>        view</span>
 119 |     | <span class='neutral'>        returns (bytes32)</span>
 120 |     | <span class='neutral'>    {</span>
 121 |     | <span class='neutral'>        return keyExists(toml, key) ? readBytes32(toml, key) : defaultValue;</span>
 122 |     | <span class='neutral'>    }</span>
 123 |     | <span class='neutral'></span>
 124 |     | <span class='neutral'>    function readBytes32ArrayOr(string memory toml, string memory key, bytes32[] memory defaultValue)</span>
 125 |     | <span class='neutral'>        internal</span>
 126 |     | <span class='neutral'>        view</span>
 127 |     | <span class='neutral'>        returns (bytes32[] memory)</span>
 128 |     | <span class='neutral'>    {</span>
 129 |     | <span class='neutral'>        return keyExists(toml, key) ? readBytes32Array(toml, key) : defaultValue;</span>
 130 |     | <span class='neutral'>    }</span>
 131 |     | <span class='neutral'></span>
 132 |     | <span class='neutral'>    function readStringOr(string memory toml, string memory key, string memory defaultValue)</span>
 133 |     | <span class='neutral'>        internal</span>
 134 |     | <span class='neutral'>        view</span>
 135 |     | <span class='neutral'>        returns (string memory)</span>
 136 |     | <span class='neutral'>    {</span>
 137 |     | <span class='neutral'>        return keyExists(toml, key) ? readString(toml, key) : defaultValue;</span>
 138 |     | <span class='neutral'>    }</span>
 139 |     | <span class='neutral'></span>
 140 |     | <span class='neutral'>    function readStringArrayOr(string memory toml, string memory key, string[] memory defaultValue)</span>
 141 |     | <span class='neutral'>        internal</span>
 142 |     | <span class='neutral'>        view</span>
 143 |     | <span class='neutral'>        returns (string[] memory)</span>
 144 |     | <span class='neutral'>    {</span>
 145 |     | <span class='neutral'>        return keyExists(toml, key) ? readStringArray(toml, key) : defaultValue;</span>
 146 |     | <span class='neutral'>    }</span>
 147 |     | <span class='neutral'></span>
 148 |     | <span class='neutral'>    function readAddressOr(string memory toml, string memory key, address defaultValue)</span>
 149 |     | <span class='neutral'>        internal</span>
 150 |     | <span class='neutral'>        view</span>
 151 |     | <span class='neutral'>        returns (address)</span>
 152 |     | <span class='neutral'>    {</span>
 153 |     | <span class='neutral'>        return keyExists(toml, key) ? readAddress(toml, key) : defaultValue;</span>
 154 |     | <span class='neutral'>    }</span>
 155 |     | <span class='neutral'></span>
 156 |     | <span class='neutral'>    function readAddressArrayOr(string memory toml, string memory key, address[] memory defaultValue)</span>
 157 |     | <span class='neutral'>        internal</span>
 158 |     | <span class='neutral'>        view</span>
 159 |     | <span class='neutral'>        returns (address[] memory)</span>
 160 |     | <span class='neutral'>    {</span>
 161 |     | <span class='neutral'>        return keyExists(toml, key) ? readAddressArray(toml, key) : defaultValue;</span>
 162 |     | <span class='neutral'>    }</span>
 163 |     | <span class='neutral'></span>
 164 |     | <span class='neutral'>    function readBoolOr(string memory toml, string memory key, bool defaultValue) internal view returns (bool) {</span>
 165 |     | <span class='neutral'>        return keyExists(toml, key) ? readBool(toml, key) : defaultValue;</span>
 166 |     | <span class='neutral'>    }</span>
 167 |     | <span class='neutral'></span>
 168 |     | <span class='neutral'>    function readBoolArrayOr(string memory toml, string memory key, bool[] memory defaultValue)</span>
 169 |     | <span class='neutral'>        internal</span>
 170 |     | <span class='neutral'>        view</span>
 171 |     | <span class='neutral'>        returns (bool[] memory)</span>
 172 |     | <span class='neutral'>    {</span>
 173 |     | <span class='neutral'>        return keyExists(toml, key) ? readBoolArray(toml, key) : defaultValue;</span>
 174 |     | <span class='neutral'>    }</span>
 175 |     | <span class='neutral'></span>
 176 |     | <span class='neutral'>    function readBytesOr(string memory toml, string memory key, bytes memory defaultValue)</span>
 177 |     | <span class='neutral'>        internal</span>
 178 |     | <span class='neutral'>        view</span>
 179 |     | <span class='neutral'>        returns (bytes memory)</span>
 180 |     | <span class='neutral'>    {</span>
 181 |     | <span class='neutral'>        return keyExists(toml, key) ? readBytes(toml, key) : defaultValue;</span>
 182 |     | <span class='neutral'>    }</span>
 183 |     | <span class='neutral'></span>
 184 |     | <span class='neutral'>    function readBytesArrayOr(string memory toml, string memory key, bytes[] memory defaultValue)</span>
 185 |     | <span class='neutral'>        internal</span>
 186 |     | <span class='neutral'>        view</span>
 187 |     | <span class='neutral'>        returns (bytes[] memory)</span>
 188 |     | <span class='neutral'>    {</span>
 189 |     | <span class='neutral'>        return keyExists(toml, key) ? readBytesArray(toml, key) : defaultValue;</span>
 190 |     | <span class='neutral'>    }</span>
 191 |     | <span class='neutral'></span>
 192 |     | <span class='neutral'>    function serialize(string memory jsonKey, string memory rootObject) internal returns (string memory) {</span>
 193 |     | <span class='neutral'>        return vm.serializeJson(jsonKey, rootObject);</span>
 194 |     | <span class='neutral'>    }</span>
 195 |     | <span class='neutral'></span>
 196 |     | <span class='neutral'>    function serialize(string memory jsonKey, string memory key, bool value) internal returns (string memory) {</span>
 197 |     | <span class='neutral'>        return vm.serializeBool(jsonKey, key, value);</span>
 198 |     | <span class='neutral'>    }</span>
 199 |     | <span class='neutral'></span>
 200 |     | <span class='neutral'>    function serialize(string memory jsonKey, string memory key, bool[] memory value)</span>
 201 |     | <span class='neutral'>        internal</span>
 202 |     | <span class='neutral'>        returns (string memory)</span>
 203 |     | <span class='neutral'>    {</span>
 204 |     | <span class='neutral'>        return vm.serializeBool(jsonKey, key, value);</span>
 205 |     | <span class='neutral'>    }</span>
 206 |     | <span class='neutral'></span>
 207 |     | <span class='neutral'>    function serialize(string memory jsonKey, string memory key, uint256 value) internal returns (string memory) {</span>
 208 |     | <span class='neutral'>        return vm.serializeUint(jsonKey, key, value);</span>
 209 |     | <span class='neutral'>    }</span>
 210 |     | <span class='neutral'></span>
 211 |     | <span class='neutral'>    function serialize(string memory jsonKey, string memory key, uint256[] memory value)</span>
 212 |     | <span class='neutral'>        internal</span>
 213 |     | <span class='neutral'>        returns (string memory)</span>
 214 |     | <span class='neutral'>    {</span>
 215 |     | <span class='neutral'>        return vm.serializeUint(jsonKey, key, value);</span>
 216 |     | <span class='neutral'>    }</span>
 217 |     | <span class='neutral'></span>
 218 |     | <span class='neutral'>    function serialize(string memory jsonKey, string memory key, int256 value) internal returns (string memory) {</span>
 219 |     | <span class='neutral'>        return vm.serializeInt(jsonKey, key, value);</span>
 220 |     | <span class='neutral'>    }</span>
 221 |     | <span class='neutral'></span>
 222 |     | <span class='neutral'>    function serialize(string memory jsonKey, string memory key, int256[] memory value)</span>
 223 |     | <span class='neutral'>        internal</span>
 224 |     | <span class='neutral'>        returns (string memory)</span>
 225 |     | <span class='neutral'>    {</span>
 226 |     | <span class='neutral'>        return vm.serializeInt(jsonKey, key, value);</span>
 227 |     | <span class='neutral'>    }</span>
 228 |     | <span class='neutral'></span>
 229 |     | <span class='neutral'>    function serialize(string memory jsonKey, string memory key, address value) internal returns (string memory) {</span>
 230 |     | <span class='neutral'>        return vm.serializeAddress(jsonKey, key, value);</span>
 231 |     | <span class='neutral'>    }</span>
 232 |     | <span class='neutral'></span>
 233 |     | <span class='neutral'>    function serialize(string memory jsonKey, string memory key, address[] memory value)</span>
 234 |     | <span class='neutral'>        internal</span>
 235 |     | <span class='neutral'>        returns (string memory)</span>
 236 |     | <span class='neutral'>    {</span>
 237 |     | <span class='neutral'>        return vm.serializeAddress(jsonKey, key, value);</span>
 238 |     | <span class='neutral'>    }</span>
 239 |     | <span class='neutral'></span>
 240 |     | <span class='neutral'>    function serialize(string memory jsonKey, string memory key, bytes32 value) internal returns (string memory) {</span>
 241 |     | <span class='neutral'>        return vm.serializeBytes32(jsonKey, key, value);</span>
 242 |     | <span class='neutral'>    }</span>
 243 |     | <span class='neutral'></span>
 244 |     | <span class='neutral'>    function serialize(string memory jsonKey, string memory key, bytes32[] memory value)</span>
 245 |     | <span class='neutral'>        internal</span>
 246 |     | <span class='neutral'>        returns (string memory)</span>
 247 |     | <span class='neutral'>    {</span>
 248 |     | <span class='neutral'>        return vm.serializeBytes32(jsonKey, key, value);</span>
 249 |     | <span class='neutral'>    }</span>
 250 |     | <span class='neutral'></span>
 251 |     | <span class='neutral'>    function serialize(string memory jsonKey, string memory key, bytes memory value) internal returns (string memory) {</span>
 252 |     | <span class='neutral'>        return vm.serializeBytes(jsonKey, key, value);</span>
 253 |     | <span class='neutral'>    }</span>
 254 |     | <span class='neutral'></span>
 255 |     | <span class='neutral'>    function serialize(string memory jsonKey, string memory key, bytes[] memory value)</span>
 256 |     | <span class='neutral'>        internal</span>
 257 |     | <span class='neutral'>        returns (string memory)</span>
 258 |     | <span class='neutral'>    {</span>
 259 |     | <span class='neutral'>        return vm.serializeBytes(jsonKey, key, value);</span>
 260 |     | <span class='neutral'>    }</span>
 261 |     | <span class='neutral'></span>
 262 |     | <span class='neutral'>    function serialize(string memory jsonKey, string memory key, string memory value)</span>
 263 |     | <span class='neutral'>        internal</span>
 264 |     | <span class='neutral'>        returns (string memory)</span>
 265 |     | <span class='neutral'>    {</span>
 266 |     | <span class='neutral'>        return vm.serializeString(jsonKey, key, value);</span>
 267 |     | <span class='neutral'>    }</span>
 268 |     | <span class='neutral'></span>
 269 |     | <span class='neutral'>    function serialize(string memory jsonKey, string memory key, string[] memory value)</span>
 270 |     | <span class='neutral'>        internal</span>
 271 |     | <span class='neutral'>        returns (string memory)</span>
 272 |     | <span class='neutral'>    {</span>
 273 |     | <span class='neutral'>        return vm.serializeString(jsonKey, key, value);</span>
 274 |     | <span class='neutral'>    }</span>
 275 |     | <span class='neutral'></span>
 276 |     | <span class='neutral'>    function write(string memory jsonKey, string memory path) internal {</span>
 277 |     | <span class='neutral'>        vm.writeToml(jsonKey, path);</span>
 278 |     | <span class='neutral'>    }</span>
 279 |     | <span class='neutral'></span>
 280 |     | <span class='neutral'>    function write(string memory jsonKey, string memory path, string memory valueKey) internal {</span>
 281 |     | <span class='neutral'>        vm.writeToml(jsonKey, path, valueKey);</span>
 282 |     | <span class='neutral'>    }</span>
 283 |     | <span class='neutral'>}</span>
 284 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/phantom/Documents/azemora/azemora-contracts/lib/forge-std/src/StdUtils.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'>pragma solidity &gt;=0.6.2 &lt;0.9.0;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>pragma experimental ABIEncoderV2;</span>
   5 |     | <span class='neutral'></span>
   6 |     | <span class='neutral'>import {IMulticall3} from &quot;./interfaces/IMulticall3.sol&quot;;</span>
   7 |     | <span class='neutral'>import {VmSafe} from &quot;./Vm.sol&quot;;</span>
   8 |     | <span class='neutral'></span>
   9 |     | <span class='neutral'>abstract contract StdUtils {</span>
  10 |     | <span class='neutral'>    /*//////////////////////////////////////////////////////////////////////////</span>
  11 |     | <span class='neutral'>                                     CONSTANTS</span>
  12 |     | <span class='neutral'>    //////////////////////////////////////////////////////////////////////////*/</span>
  13 |     | <span class='neutral'></span>
  14 |     | <span class='neutral'>    IMulticall3 private constant multicall = IMulticall3(0xcA11bde05977b3631167028862bE2a173976CA11);</span>
  15 |     | <span class='neutral'>    VmSafe private constant vm = VmSafe(address(uint160(uint256(keccak256(&quot;hevm cheat code&quot;)))));</span>
  16 |     | <span class='unexecuted'>    address private constant CONSOLE2_ADDRESS = 0x000000000000000000636F6e736F6c652e6c6f67;</span>
  17 |     | <span class='neutral'>    uint256 private constant INT256_MIN_ABS =</span>
  18 |     | <span class='neutral'>        57896044618658097711785492504343953926634992332820282019728792003956564819968;</span>
  19 |     | <span class='neutral'>    uint256 private constant SECP256K1_ORDER =</span>
  20 |     | <span class='neutral'>        115792089237316195423570985008687907852837564279074904382605163141518161494337;</span>
  21 |     | <span class='neutral'>    uint256 private constant UINT256_MAX =</span>
  22 |     | <span class='unexecuted'>        115792089237316195423570985008687907853269984665640564039457584007913129639935;</span>
  23 |     | <span class='neutral'></span>
  24 |     | <span class='neutral'>    // Used by default when deploying with create2, https://github.com/Arachnid/deterministic-deployment-proxy.</span>
  25 |     | <span class='neutral'>    address private constant CREATE2_FACTORY = 0x4e59b44847b379578588920cA78FbF26c0B4956C;</span>
  26 |     | <span class='neutral'></span>
  27 |     | <span class='neutral'>    /*//////////////////////////////////////////////////////////////////////////</span>
  28 |     | <span class='neutral'>                                 INTERNAL FUNCTIONS</span>
  29 |     | <span class='neutral'>    //////////////////////////////////////////////////////////////////////////*/</span>
  30 |     | <span class='neutral'></span>
  31 |     | <span class='unexecuted'>    function _bound(uint256 x, uint256 min, uint256 max) internal pure virtual returns (uint256 result) {</span>
  32 |     | <span class='unexecuted'>        require(min &lt;= max, &quot;StdUtils bound(uint256,uint256,uint256): Max is less than min.&quot;);</span>
  33 |     | <span class='neutral'>        // If x is between min and max, return x directly. This is to ensure that dictionary values</span>
  34 |     | <span class='neutral'>        // do not get shifted if the min is nonzero. More info: https://github.com/foundry-rs/forge-std/issues/188</span>
  35 |     | <span class='unexecuted'>        if (x &gt;= min &amp;&amp; x &lt;= max) return x;</span>
  36 |     | <span class='neutral'></span>
  37 |     | <span class='unexecuted'>        uint256 size = max - min + 1;</span>
  38 |     | <span class='neutral'></span>
  39 |     | <span class='neutral'>        // If the value is 0, 1, 2, 3, wrap that to min, min+1, min+2, min+3. Similarly for the UINT256_MAX side.</span>
  40 |     | <span class='neutral'>        // This helps ensure coverage of the min/max values.</span>
  41 |     | <span class='unexecuted'>        if (x &lt;= 3 &amp;&amp; size &gt; x) return min + x;</span>
  42 |     | <span class='unexecuted'>        if (x &gt;= UINT256_MAX - 3 &amp;&amp; size &gt; UINT256_MAX - x) return max - (UINT256_MAX - x);</span>
  43 |     | <span class='neutral'></span>
  44 |     | <span class='neutral'>        // Otherwise, wrap x into the range [min, max], i.e. the range is inclusive.</span>
  45 |     | <span class='unexecuted'>        if (x &gt; max) {</span>
  46 |     | <span class='unexecuted'>            uint256 diff = x - max;</span>
  47 |     | <span class='unexecuted'>            uint256 rem = diff % size;</span>
  48 |     | <span class='unexecuted'>            if (rem == 0) return max;</span>
  49 |     | <span class='unexecuted'>            result = min + rem - 1;</span>
  50 |     | <span class='unexecuted'>        } else if (x &lt; min) {</span>
  51 |     | <span class='unexecuted'>            uint256 diff = min - x;</span>
  52 |     | <span class='unexecuted'>            uint256 rem = diff % size;</span>
  53 |     | <span class='unexecuted'>            if (rem == 0) return min;</span>
  54 |     | <span class='unexecuted'>            result = max - rem + 1;</span>
  55 |     | <span class='neutral'>        }</span>
  56 |     | <span class='neutral'>    }</span>
  57 |     | <span class='neutral'></span>
  58 |     | <span class='unexecuted'>    function bound(uint256 x, uint256 min, uint256 max) internal pure virtual returns (uint256 result) {</span>
  59 |     | <span class='unexecuted'>        result = _bound(x, min, max);</span>
  60 |     | <span class='unexecuted'>        console2_log_StdUtils(&quot;Bound result&quot;, result);</span>
  61 |     | <span class='neutral'>    }</span>
  62 |     | <span class='neutral'></span>
  63 |     | <span class='neutral'>    function _bound(int256 x, int256 min, int256 max) internal pure virtual returns (int256 result) {</span>
  64 |     | <span class='neutral'>        require(min &lt;= max, &quot;StdUtils bound(int256,int256,int256): Max is less than min.&quot;);</span>
  65 |     | <span class='neutral'></span>
  66 |     | <span class='neutral'>        // Shifting all int256 values to uint256 to use _bound function. The range of two types are:</span>
  67 |     | <span class='neutral'>        // int256 : -(2**255) ~ (2**255 - 1)</span>
  68 |     | <span class='neutral'>        // uint256:     0     ~ (2**256 - 1)</span>
  69 |     | <span class='neutral'>        // So, add 2**255, INT256_MIN_ABS to the integer values.</span>
  70 |     | <span class='neutral'>        //</span>
  71 |     | <span class='neutral'>        // If the given integer value is -2**255, we cannot use `-uint256(-x)` because of the overflow.</span>
  72 |     | <span class='neutral'>        // So, use `~uint256(x) + 1` instead.</span>
  73 |     | <span class='neutral'>        uint256 _x = x &lt; 0 ? (INT256_MIN_ABS - ~uint256(x) - 1) : (uint256(x) + INT256_MIN_ABS);</span>
  74 |     | <span class='neutral'>        uint256 _min = min &lt; 0 ? (INT256_MIN_ABS - ~uint256(min) - 1) : (uint256(min) + INT256_MIN_ABS);</span>
  75 |     | <span class='neutral'>        uint256 _max = max &lt; 0 ? (INT256_MIN_ABS - ~uint256(max) - 1) : (uint256(max) + INT256_MIN_ABS);</span>
  76 |     | <span class='neutral'></span>
  77 |     | <span class='neutral'>        uint256 y = _bound(_x, _min, _max);</span>
  78 |     | <span class='neutral'></span>
  79 |     | <span class='neutral'>        // To move it back to int256 value, subtract INT256_MIN_ABS at here.</span>
  80 |     | <span class='neutral'>        result = y &lt; INT256_MIN_ABS ? int256(~(INT256_MIN_ABS - y) + 1) : int256(y - INT256_MIN_ABS);</span>
  81 |     | <span class='neutral'>    }</span>
  82 |     | <span class='neutral'></span>
  83 |     | <span class='neutral'>    function bound(int256 x, int256 min, int256 max) internal pure virtual returns (int256 result) {</span>
  84 |     | <span class='neutral'>        result = _bound(x, min, max);</span>
  85 |     | <span class='neutral'>        console2_log_StdUtils(&quot;Bound result&quot;, vm.toString(result));</span>
  86 |     | <span class='neutral'>    }</span>
  87 |     | <span class='neutral'></span>
  88 |     | <span class='neutral'>    function boundPrivateKey(uint256 privateKey) internal pure virtual returns (uint256 result) {</span>
  89 |     | <span class='neutral'>        result = _bound(privateKey, 1, SECP256K1_ORDER - 1);</span>
  90 |     | <span class='neutral'>    }</span>
  91 |     | <span class='neutral'></span>
  92 |     | <span class='neutral'>    function bytesToUint(bytes memory b) internal pure virtual returns (uint256) {</span>
  93 |     | <span class='neutral'>        require(b.length &lt;= 32, &quot;StdUtils bytesToUint(bytes): Bytes length exceeds 32.&quot;);</span>
  94 |     | <span class='neutral'>        return abi.decode(abi.encodePacked(new bytes(32 - b.length), b), (uint256));</span>
  95 |     | <span class='neutral'>    }</span>
  96 |     | <span class='neutral'></span>
  97 |     | <span class='neutral'>    /// @dev Compute the address a contract will be deployed at for a given deployer address and nonce</span>
  98 |     | <span class='neutral'>    /// @notice adapted from Solmate implementation (https://github.com/Rari-Capital/solmate/blob/main/src/utils/LibRLP.sol)</span>
  99 |     | <span class='neutral'>    function computeCreateAddress(address deployer, uint256 nonce) internal pure virtual returns (address) {</span>
 100 |     | <span class='neutral'>        console2_log_StdUtils(&quot;computeCreateAddress is deprecated. Please use vm.computeCreateAddress instead.&quot;);</span>
 101 |     | <span class='neutral'>        return vm.computeCreateAddress(deployer, nonce);</span>
 102 |     | <span class='neutral'>    }</span>
 103 |     | <span class='neutral'></span>
 104 |     | <span class='neutral'>    function computeCreate2Address(bytes32 salt, bytes32 initcodeHash, address deployer)</span>
 105 |     | <span class='neutral'>        internal</span>
 106 |     | <span class='neutral'>        pure</span>
 107 |     | <span class='neutral'>        virtual</span>
 108 |     | <span class='neutral'>        returns (address)</span>
 109 |     | <span class='neutral'>    {</span>
 110 |     | <span class='neutral'>        console2_log_StdUtils(&quot;computeCreate2Address is deprecated. Please use vm.computeCreate2Address instead.&quot;);</span>
 111 |     | <span class='neutral'>        return vm.computeCreate2Address(salt, initcodeHash, deployer);</span>
 112 |     | <span class='neutral'>    }</span>
 113 |     | <span class='neutral'></span>
 114 |     | <span class='neutral'>    /// @dev returns the address of a contract created with CREATE2 using the default CREATE2 deployer</span>
 115 |     | <span class='neutral'>    function computeCreate2Address(bytes32 salt, bytes32 initCodeHash) internal pure returns (address) {</span>
 116 |     | <span class='neutral'>        console2_log_StdUtils(&quot;computeCreate2Address is deprecated. Please use vm.computeCreate2Address instead.&quot;);</span>
 117 |     | <span class='neutral'>        return vm.computeCreate2Address(salt, initCodeHash);</span>
 118 |     | <span class='neutral'>    }</span>
 119 |     | <span class='neutral'></span>
 120 |     | <span class='neutral'>    /// @dev returns the hash of the init code (creation code + no args) used in CREATE2 with no constructor arguments</span>
 121 |     | <span class='neutral'>    /// @param creationCode the creation code of a contract C, as returned by type(C).creationCode</span>
 122 |     | <span class='neutral'>    function hashInitCode(bytes memory creationCode) internal pure returns (bytes32) {</span>
 123 |     | <span class='neutral'>        return hashInitCode(creationCode, &quot;&quot;);</span>
 124 |     | <span class='neutral'>    }</span>
 125 |     | <span class='neutral'></span>
 126 |     | <span class='neutral'>    /// @dev returns the hash of the init code (creation code + ABI-encoded args) used in CREATE2</span>
 127 |     | <span class='neutral'>    /// @param creationCode the creation code of a contract C, as returned by type(C).creationCode</span>
 128 |     | <span class='neutral'>    /// @param args the ABI-encoded arguments to the constructor of C</span>
 129 |     | <span class='neutral'>    function hashInitCode(bytes memory creationCode, bytes memory args) internal pure returns (bytes32) {</span>
 130 |     | <span class='neutral'>        return keccak256(abi.encodePacked(creationCode, args));</span>
 131 |     | <span class='neutral'>    }</span>
 132 |     | <span class='neutral'></span>
 133 |     | <span class='neutral'>    // Performs a single call with Multicall3 to query the ERC-20 token balances of the given addresses.</span>
 134 |     | <span class='neutral'>    function getTokenBalances(address token, address[] memory addresses)</span>
 135 |     | <span class='neutral'>        internal</span>
 136 |     | <span class='neutral'>        virtual</span>
 137 |     | <span class='neutral'>        returns (uint256[] memory balances)</span>
 138 |     | <span class='neutral'>    {</span>
 139 |     | <span class='neutral'>        uint256 tokenCodeSize;</span>
 140 |     | <span class='neutral'>        assembly {</span>
 141 |     | <span class='neutral'>            tokenCodeSize := extcodesize(token)</span>
 142 |     | <span class='neutral'>        }</span>
 143 |     | <span class='neutral'>        require(tokenCodeSize &gt; 0, &quot;StdUtils getTokenBalances(address,address[]): Token address is not a contract.&quot;);</span>
 144 |     | <span class='neutral'></span>
 145 |     | <span class='neutral'>        // ABI encode the aggregate call to Multicall3.</span>
 146 |     | <span class='neutral'>        uint256 length = addresses.length;</span>
 147 |     | <span class='neutral'>        IMulticall3.Call[] memory calls = new IMulticall3.Call[](length);</span>
 148 |     | <span class='neutral'>        for (uint256 i = 0; i &lt; length; ++i) {</span>
 149 |     | <span class='neutral'>            // 0x70a08231 = bytes4(&quot;balanceOf(address)&quot;))</span>
 150 |     | <span class='neutral'>            calls[i] = IMulticall3.Call({target: token, callData: abi.encodeWithSelector(0x70a08231, (addresses[i]))});</span>
 151 |     | <span class='neutral'>        }</span>
 152 |     | <span class='neutral'></span>
 153 |     | <span class='neutral'>        // Make the aggregate call.</span>
 154 |     | <span class='neutral'>        (, bytes[] memory returnData) = multicall.aggregate(calls);</span>
 155 |     | <span class='neutral'></span>
 156 |     | <span class='neutral'>        // ABI decode the return data and return the balances.</span>
 157 |     | <span class='neutral'>        balances = new uint256[](length);</span>
 158 |     | <span class='neutral'>        for (uint256 i = 0; i &lt; length; ++i) {</span>
 159 |     | <span class='neutral'>            balances[i] = abi.decode(returnData[i], (uint256));</span>
 160 |     | <span class='neutral'>        }</span>
 161 |     | <span class='neutral'>    }</span>
 162 |     | <span class='neutral'></span>
 163 |     | <span class='neutral'>    /*//////////////////////////////////////////////////////////////////////////</span>
 164 |     | <span class='neutral'>                                 PRIVATE FUNCTIONS</span>
 165 |     | <span class='neutral'>    //////////////////////////////////////////////////////////////////////////*/</span>
 166 |     | <span class='neutral'></span>
 167 |     | <span class='neutral'>    function addressFromLast20Bytes(bytes32 bytesValue) private pure returns (address) {</span>
 168 |     | <span class='neutral'>        return address(uint160(uint256(bytesValue)));</span>
 169 |     | <span class='neutral'>    }</span>
 170 |     | <span class='neutral'></span>
 171 |     | <span class='neutral'>    // This section is used to prevent the compilation of console, which shortens the compilation time when console is</span>
 172 |     | <span class='neutral'>    // not used elsewhere. We also trick the compiler into letting us make the console log methods as `pure` to avoid</span>
 173 |     | <span class='neutral'>    // any breaking changes to function signatures.</span>
 174 |     | <span class='neutral'>    function _castLogPayloadViewToPure(function(bytes memory) internal view fnIn)</span>
 175 |     | <span class='neutral'>        internal</span>
 176 |     | <span class='neutral'>        pure</span>
 177 |     | <span class='neutral'>        returns (function(bytes memory) internal pure fnOut)</span>
 178 |     | <span class='neutral'>    {</span>
 179 |     | <span class='neutral'>        assembly {</span>
 180 |     | <span class='neutral'>            fnOut := fnIn</span>
 181 |     | <span class='neutral'>        }</span>
 182 |     | <span class='neutral'>    }</span>
 183 |     | <span class='neutral'></span>
 184 |     | <span class='unexecuted'>    function _sendLogPayload(bytes memory payload) internal pure {</span>
 185 |     | <span class='unexecuted'>        _castLogPayloadViewToPure(_sendLogPayloadView)(payload);</span>
 186 |     | <span class='neutral'>    }</span>
 187 |     | <span class='neutral'></span>
 188 |     | <span class='unexecuted'>    function _sendLogPayloadView(bytes memory payload) private view {</span>
 189 |     | <span class='unexecuted'>        uint256 payloadLength = payload.length;</span>
 190 |     | <span class='neutral'>        address consoleAddress = CONSOLE2_ADDRESS;</span>
 191 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 192 |     | <span class='unexecuted'>        assembly {</span>
 193 |     | <span class='unexecuted'>            let payloadStart := add(payload, 32)</span>
 194 |     | <span class='unexecuted'>            let r := staticcall(gas(), consoleAddress, payloadStart, payloadLength, 0, 0)</span>
 195 |     | <span class='neutral'>        }</span>
 196 |     | <span class='neutral'>    }</span>
 197 |     | <span class='neutral'></span>
 198 |     | <span class='neutral'>    function console2_log_StdUtils(string memory p0) private pure {</span>
 199 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string)&quot;, p0));</span>
 200 |     | <span class='neutral'>    }</span>
 201 |     | <span class='neutral'></span>
 202 |     | <span class='unexecuted'>    function console2_log_StdUtils(string memory p0, uint256 p1) private pure {</span>
 203 |     | <span class='unexecuted'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,uint256)&quot;, p0, p1));</span>
 204 |     | <span class='neutral'>    }</span>
 205 |     | <span class='neutral'></span>
 206 |     | <span class='neutral'>    function console2_log_StdUtils(string memory p0, string memory p1) private pure {</span>
 207 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,string)&quot;, p0, p1));</span>
 208 |     | <span class='neutral'>    }</span>
 209 |     | <span class='neutral'>}</span>
 210 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/phantom/Documents/azemora/azemora-contracts/lib/forge-std/src/Test.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>pragma solidity &gt;=0.6.2 &lt;0.9.0;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>pragma experimental ABIEncoderV2;</span>
  5 |     | <span class='neutral'></span>
  6 |     | <span class='neutral'>//  ABOUT</span>
  7 |     | <span class='neutral'>// Forge Std&#39;s default Test.</span>
  8 |     | <span class='neutral'></span>
  9 |     | <span class='neutral'>//  MODULES</span>
 10 |     | <span class='neutral'>import {console} from &quot;./console.sol&quot;;</span>
 11 |     | <span class='neutral'>import {console2} from &quot;./console2.sol&quot;;</span>
 12 |     | <span class='neutral'>import {safeconsole} from &quot;./safeconsole.sol&quot;;</span>
 13 |     | <span class='neutral'>import {StdAssertions} from &quot;./StdAssertions.sol&quot;;</span>
 14 |     | <span class='neutral'>import {StdChains} from &quot;./StdChains.sol&quot;;</span>
 15 |     | <span class='neutral'>import {StdCheats} from &quot;./StdCheats.sol&quot;;</span>
 16 |     | <span class='neutral'>import {StdConstants} from &quot;./StdConstants.sol&quot;;</span>
 17 |     | <span class='neutral'>import {stdError} from &quot;./StdError.sol&quot;;</span>
 18 |     | <span class='neutral'>import {StdInvariant} from &quot;./StdInvariant.sol&quot;;</span>
 19 |     | <span class='neutral'>import {stdJson} from &quot;./StdJson.sol&quot;;</span>
 20 |     | <span class='neutral'>import {stdMath} from &quot;./StdMath.sol&quot;;</span>
 21 |     | <span class='neutral'>import {StdStorage, stdStorage} from &quot;./StdStorage.sol&quot;;</span>
 22 |     | <span class='neutral'>import {StdStyle} from &quot;./StdStyle.sol&quot;;</span>
 23 |     | <span class='neutral'>import {stdToml} from &quot;./StdToml.sol&quot;;</span>
 24 |     | <span class='neutral'>import {StdUtils} from &quot;./StdUtils.sol&quot;;</span>
 25 |     | <span class='neutral'>import {Vm} from &quot;./Vm.sol&quot;;</span>
 26 |     | <span class='neutral'></span>
 27 |     | <span class='neutral'>//  BOILERPLATE</span>
 28 |     | <span class='neutral'>import {TestBase} from &quot;./Base.sol&quot;;</span>
 29 |     | <span class='neutral'></span>
 30 |     | <span class='neutral'>//  TEST</span>
 31 |     | <span class='neutral'>abstract contract Test is TestBase, StdAssertions, StdChains, StdCheats, StdInvariant, StdUtils {</span>
 32 |     | <span class='neutral'>    // Note: IS_TEST() must return true.</span>
 33 | *   | <span class='executed'>    bool public IS_TEST = true;</span>
 34 |     | <span class='neutral'>}</span>
 35 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/phantom/Documents/azemora/azemora-contracts/lib/forge-std/src/Vm.sol</b>
<code>
    1 |     | <span class='neutral'>// Automatically @generated by scripts/vm.py. Do not modify manually.</span>
    2 |     | <span class='neutral'></span>
    3 |     | <span class='neutral'>// SPDX-License-Identifier: MIT OR Apache-2.0</span>
    4 |     | <span class='neutral'>pragma solidity &gt;=0.6.2 &lt;0.9.0;</span>
    5 |     | <span class='neutral'>pragma experimental ABIEncoderV2;</span>
    6 |     | <span class='neutral'></span>
    7 |     | <span class='neutral'>/// The `VmSafe` interface does not allow manipulation of the EVM state or other actions that may</span>
    8 |     | <span class='neutral'>/// result in Script simulations differing from on-chain execution. It is recommended to only use</span>
    9 |     | <span class='neutral'>/// these cheats in scripts.</span>
   10 |     | <span class='neutral'>interface VmSafe {</span>
   11 |     | <span class='neutral'>    /// A modification applied to either `msg.sender` or `tx.origin`. Returned by `readCallers`.</span>
   12 |     | <span class='neutral'>    enum CallerMode {</span>
   13 |     | <span class='neutral'>        // No caller modification is currently active.</span>
   14 |     | <span class='neutral'>        None,</span>
   15 |     | <span class='neutral'>        // A one time broadcast triggered by a `vm.broadcast()` call is currently active.</span>
   16 |     | <span class='neutral'>        Broadcast,</span>
   17 |     | <span class='neutral'>        // A recurrent broadcast triggered by a `vm.startBroadcast()` call is currently active.</span>
   18 |     | <span class='neutral'>        RecurrentBroadcast,</span>
   19 |     | <span class='neutral'>        // A one time prank triggered by a `vm.prank()` call is currently active.</span>
   20 |     | <span class='neutral'>        Prank,</span>
   21 |     | <span class='neutral'>        // A recurrent prank triggered by a `vm.startPrank()` call is currently active.</span>
   22 |     | <span class='neutral'>        RecurrentPrank</span>
   23 |     | <span class='neutral'>    }</span>
   24 |     | <span class='neutral'></span>
   25 |     | <span class='neutral'>    /// The kind of account access that occurred.</span>
   26 |     | <span class='neutral'>    enum AccountAccessKind {</span>
   27 |     | <span class='neutral'>        // The account was called.</span>
   28 |     | <span class='neutral'>        Call,</span>
   29 |     | <span class='neutral'>        // The account was called via delegatecall.</span>
   30 |     | <span class='neutral'>        DelegateCall,</span>
   31 |     | <span class='neutral'>        // The account was called via callcode.</span>
   32 |     | <span class='neutral'>        CallCode,</span>
   33 |     | <span class='neutral'>        // The account was called via staticcall.</span>
   34 |     | <span class='neutral'>        StaticCall,</span>
   35 |     | <span class='neutral'>        // The account was created.</span>
   36 |     | <span class='neutral'>        Create,</span>
   37 |     | <span class='neutral'>        // The account was selfdestructed.</span>
   38 |     | <span class='neutral'>        SelfDestruct,</span>
   39 |     | <span class='neutral'>        // Synthetic access indicating the current context has resumed after a previous sub-context (AccountAccess).</span>
   40 |     | <span class='neutral'>        Resume,</span>
   41 |     | <span class='neutral'>        // The account&#39;s balance was read.</span>
   42 |     | <span class='neutral'>        Balance,</span>
   43 |     | <span class='neutral'>        // The account&#39;s codesize was read.</span>
   44 |     | <span class='neutral'>        Extcodesize,</span>
   45 |     | <span class='neutral'>        // The account&#39;s codehash was read.</span>
   46 |     | <span class='neutral'>        Extcodehash,</span>
   47 |     | <span class='neutral'>        // The account&#39;s code was copied.</span>
   48 |     | <span class='neutral'>        Extcodecopy</span>
   49 |     | <span class='neutral'>    }</span>
   50 |     | <span class='neutral'></span>
   51 |     | <span class='neutral'>    /// Forge execution contexts.</span>
   52 |     | <span class='neutral'>    enum ForgeContext {</span>
   53 |     | <span class='neutral'>        // Test group execution context (test, coverage or snapshot).</span>
   54 |     | <span class='neutral'>        TestGroup,</span>
   55 |     | <span class='neutral'>        // `forge test` execution context.</span>
   56 |     | <span class='neutral'>        Test,</span>
   57 |     | <span class='neutral'>        // `forge coverage` execution context.</span>
   58 |     | <span class='neutral'>        Coverage,</span>
   59 |     | <span class='neutral'>        // `forge snapshot` execution context.</span>
   60 |     | <span class='neutral'>        Snapshot,</span>
   61 |     | <span class='neutral'>        // Script group execution context (dry run, broadcast or resume).</span>
   62 |     | <span class='neutral'>        ScriptGroup,</span>
   63 |     | <span class='neutral'>        // `forge script` execution context.</span>
   64 |     | <span class='neutral'>        ScriptDryRun,</span>
   65 |     | <span class='neutral'>        // `forge script --broadcast` execution context.</span>
   66 |     | <span class='neutral'>        ScriptBroadcast,</span>
   67 |     | <span class='neutral'>        // `forge script --resume` execution context.</span>
   68 |     | <span class='neutral'>        ScriptResume,</span>
   69 |     | <span class='neutral'>        // Unknown `forge` execution context.</span>
   70 |     | <span class='neutral'>        Unknown</span>
   71 |     | <span class='neutral'>    }</span>
   72 |     | <span class='neutral'></span>
   73 |     | <span class='neutral'>    /// The transaction type (`txType`) of the broadcast.</span>
   74 |     | <span class='neutral'>    enum BroadcastTxType {</span>
   75 |     | <span class='neutral'>        // Represents a CALL broadcast tx.</span>
   76 |     | <span class='neutral'>        Call,</span>
   77 |     | <span class='neutral'>        // Represents a CREATE broadcast tx.</span>
   78 |     | <span class='neutral'>        Create,</span>
   79 |     | <span class='neutral'>        // Represents a CREATE2 broadcast tx.</span>
   80 |     | <span class='neutral'>        Create2</span>
   81 |     | <span class='neutral'>    }</span>
   82 |     | <span class='neutral'></span>
   83 |     | <span class='neutral'>    /// An Ethereum log. Returned by `getRecordedLogs`.</span>
   84 |     | <span class='neutral'>    struct Log {</span>
   85 |     | <span class='neutral'>        // The topics of the log, including the signature, if any.</span>
   86 |     | <span class='neutral'>        bytes32[] topics;</span>
   87 |     | <span class='neutral'>        // The raw data of the log.</span>
   88 |     | <span class='neutral'>        bytes data;</span>
   89 |     | <span class='neutral'>        // The address of the log&#39;s emitter.</span>
   90 |     | <span class='neutral'>        address emitter;</span>
   91 |     | <span class='neutral'>    }</span>
   92 |     | <span class='neutral'></span>
   93 |     | <span class='neutral'>    /// An RPC URL and its alias. Returned by `rpcUrlStructs`.</span>
   94 |     | <span class='neutral'>    struct Rpc {</span>
   95 |     | <span class='neutral'>        // The alias of the RPC URL.</span>
   96 |     | <span class='neutral'>        string key;</span>
   97 |     | <span class='neutral'>        // The RPC URL.</span>
   98 |     | <span class='neutral'>        string url;</span>
   99 |     | <span class='neutral'>    }</span>
  100 |     | <span class='neutral'></span>
  101 |     | <span class='neutral'>    /// An RPC log object. Returned by `eth_getLogs`.</span>
  102 |     | <span class='neutral'>    struct EthGetLogs {</span>
  103 |     | <span class='neutral'>        // The address of the log&#39;s emitter.</span>
  104 |     | <span class='neutral'>        address emitter;</span>
  105 |     | <span class='neutral'>        // The topics of the log, including the signature, if any.</span>
  106 |     | <span class='neutral'>        bytes32[] topics;</span>
  107 |     | <span class='neutral'>        // The raw data of the log.</span>
  108 |     | <span class='neutral'>        bytes data;</span>
  109 |     | <span class='neutral'>        // The block hash.</span>
  110 |     | <span class='neutral'>        bytes32 blockHash;</span>
  111 |     | <span class='neutral'>        // The block number.</span>
  112 |     | <span class='neutral'>        uint64 blockNumber;</span>
  113 |     | <span class='neutral'>        // The transaction hash.</span>
  114 |     | <span class='neutral'>        bytes32 transactionHash;</span>
  115 |     | <span class='neutral'>        // The transaction index in the block.</span>
  116 |     | <span class='neutral'>        uint64 transactionIndex;</span>
  117 |     | <span class='neutral'>        // The log index.</span>
  118 |     | <span class='neutral'>        uint256 logIndex;</span>
  119 |     | <span class='neutral'>        // Whether the log was removed.</span>
  120 |     | <span class='neutral'>        bool removed;</span>
  121 |     | <span class='neutral'>    }</span>
  122 |     | <span class='neutral'></span>
  123 |     | <span class='neutral'>    /// A single entry in a directory listing. Returned by `readDir`.</span>
  124 |     | <span class='neutral'>    struct DirEntry {</span>
  125 |     | <span class='neutral'>        // The error message, if any.</span>
  126 |     | <span class='neutral'>        string errorMessage;</span>
  127 |     | <span class='neutral'>        // The path of the entry.</span>
  128 |     | <span class='neutral'>        string path;</span>
  129 |     | <span class='neutral'>        // The depth of the entry.</span>
  130 |     | <span class='neutral'>        uint64 depth;</span>
  131 |     | <span class='neutral'>        // Whether the entry is a directory.</span>
  132 |     | <span class='neutral'>        bool isDir;</span>
  133 |     | <span class='neutral'>        // Whether the entry is a symlink.</span>
  134 |     | <span class='neutral'>        bool isSymlink;</span>
  135 |     | <span class='neutral'>    }</span>
  136 |     | <span class='neutral'></span>
  137 |     | <span class='neutral'>    /// Metadata information about a file.</span>
  138 |     | <span class='neutral'>    /// This structure is returned from the `fsMetadata` function and represents known</span>
  139 |     | <span class='neutral'>    /// metadata about a file such as its permissions, size, modification</span>
  140 |     | <span class='neutral'>    /// times, etc.</span>
  141 |     | <span class='neutral'>    struct FsMetadata {</span>
  142 |     | <span class='neutral'>        // True if this metadata is for a directory.</span>
  143 |     | <span class='neutral'>        bool isDir;</span>
  144 |     | <span class='neutral'>        // True if this metadata is for a symlink.</span>
  145 |     | <span class='neutral'>        bool isSymlink;</span>
  146 |     | <span class='neutral'>        // The size of the file, in bytes, this metadata is for.</span>
  147 |     | <span class='neutral'>        uint256 length;</span>
  148 |     | <span class='neutral'>        // True if this metadata is for a readonly (unwritable) file.</span>
  149 |     | <span class='neutral'>        bool readOnly;</span>
  150 |     | <span class='neutral'>        // The last modification time listed in this metadata.</span>
  151 |     | <span class='neutral'>        uint256 modified;</span>
  152 |     | <span class='neutral'>        // The last access time of this metadata.</span>
  153 |     | <span class='neutral'>        uint256 accessed;</span>
  154 |     | <span class='neutral'>        // The creation time listed in this metadata.</span>
  155 |     | <span class='neutral'>        uint256 created;</span>
  156 |     | <span class='neutral'>    }</span>
  157 |     | <span class='neutral'></span>
  158 |     | <span class='neutral'>    /// A wallet with a public and private key.</span>
  159 |     | <span class='neutral'>    struct Wallet {</span>
  160 |     | <span class='neutral'>        // The wallet&#39;s address.</span>
  161 |     | <span class='neutral'>        address addr;</span>
  162 |     | <span class='neutral'>        // The wallet&#39;s public key `X`.</span>
  163 |     | <span class='neutral'>        uint256 publicKeyX;</span>
  164 |     | <span class='neutral'>        // The wallet&#39;s public key `Y`.</span>
  165 |     | <span class='neutral'>        uint256 publicKeyY;</span>
  166 |     | <span class='neutral'>        // The wallet&#39;s private key.</span>
  167 |     | <span class='neutral'>        uint256 privateKey;</span>
  168 |     | <span class='neutral'>    }</span>
  169 |     | <span class='neutral'></span>
  170 |     | <span class='neutral'>    /// The result of a `tryFfi` call.</span>
  171 |     | <span class='neutral'>    struct FfiResult {</span>
  172 |     | <span class='neutral'>        // The exit code of the call.</span>
  173 |     | <span class='neutral'>        int32 exitCode;</span>
  174 |     | <span class='neutral'>        // The optionally hex-decoded `stdout` data.</span>
  175 |     | <span class='neutral'>        bytes stdout;</span>
  176 |     | <span class='neutral'>        // The `stderr` data.</span>
  177 |     | <span class='neutral'>        bytes stderr;</span>
  178 |     | <span class='neutral'>    }</span>
  179 |     | <span class='neutral'></span>
  180 |     | <span class='neutral'>    /// Information on the chain and fork.</span>
  181 |     | <span class='neutral'>    struct ChainInfo {</span>
  182 |     | <span class='neutral'>        // The fork identifier. Set to zero if no fork is active.</span>
  183 |     | <span class='neutral'>        uint256 forkId;</span>
  184 |     | <span class='neutral'>        // The chain ID of the current fork.</span>
  185 |     | <span class='neutral'>        uint256 chainId;</span>
  186 |     | <span class='neutral'>    }</span>
  187 |     | <span class='neutral'></span>
  188 |     | <span class='neutral'>    /// Information about a blockchain.</span>
  189 |     | <span class='neutral'>    struct Chain {</span>
  190 |     | <span class='neutral'>        // The chain name.</span>
  191 |     | <span class='neutral'>        string name;</span>
  192 |     | <span class='neutral'>        // The chain&#39;s Chain ID.</span>
  193 |     | <span class='neutral'>        uint256 chainId;</span>
  194 |     | <span class='neutral'>        // The chain&#39;s alias. (i.e. what gets specified in `foundry.toml`).</span>
  195 |     | <span class='neutral'>        string chainAlias;</span>
  196 |     | <span class='neutral'>        // A default RPC endpoint for this chain.</span>
  197 |     | <span class='neutral'>        string rpcUrl;</span>
  198 |     | <span class='neutral'>    }</span>
  199 |     | <span class='neutral'></span>
  200 |     | <span class='neutral'>    /// The result of a `stopAndReturnStateDiff` call.</span>
  201 |     | <span class='neutral'>    struct AccountAccess {</span>
  202 |     | <span class='neutral'>        // The chain and fork the access occurred.</span>
  203 |     | <span class='neutral'>        ChainInfo chainInfo;</span>
  204 |     | <span class='neutral'>        // The kind of account access that determines what the account is.</span>
  205 |     | <span class='neutral'>        // If kind is Call, DelegateCall, StaticCall or CallCode, then the account is the callee.</span>
  206 |     | <span class='neutral'>        // If kind is Create, then the account is the newly created account.</span>
  207 |     | <span class='neutral'>        // If kind is SelfDestruct, then the account is the selfdestruct recipient.</span>
  208 |     | <span class='neutral'>        // If kind is a Resume, then account represents a account context that has resumed.</span>
  209 |     | <span class='neutral'>        AccountAccessKind kind;</span>
  210 |     | <span class='neutral'>        // The account that was accessed.</span>
  211 |     | <span class='neutral'>        // It&#39;s either the account created, callee or a selfdestruct recipient for CREATE, CALL or SELFDESTRUCT.</span>
  212 |     | <span class='neutral'>        address account;</span>
  213 |     | <span class='neutral'>        // What accessed the account.</span>
  214 |     | <span class='neutral'>        address accessor;</span>
  215 |     | <span class='neutral'>        // If the account was initialized or empty prior to the access.</span>
  216 |     | <span class='neutral'>        // An account is considered initialized if it has code, a</span>
  217 |     | <span class='neutral'>        // non-zero nonce, or a non-zero balance.</span>
  218 |     | <span class='neutral'>        bool initialized;</span>
  219 |     | <span class='neutral'>        // The previous balance of the accessed account.</span>
  220 |     | <span class='neutral'>        uint256 oldBalance;</span>
  221 |     | <span class='neutral'>        // The potential new balance of the accessed account.</span>
  222 |     | <span class='neutral'>        // That is, all balance changes are recorded here, even if reverts occurred.</span>
  223 |     | <span class='neutral'>        uint256 newBalance;</span>
  224 |     | <span class='neutral'>        // Code of the account deployed by CREATE.</span>
  225 |     | <span class='neutral'>        bytes deployedCode;</span>
  226 |     | <span class='neutral'>        // Value passed along with the account access</span>
  227 |     | <span class='neutral'>        uint256 value;</span>
  228 |     | <span class='neutral'>        // Input data provided to the CREATE or CALL</span>
  229 |     | <span class='neutral'>        bytes data;</span>
  230 |     | <span class='neutral'>        // If this access reverted in either the current or parent context.</span>
  231 |     | <span class='neutral'>        bool reverted;</span>
  232 |     | <span class='neutral'>        // An ordered list of storage accesses made during an account access operation.</span>
  233 |     | <span class='neutral'>        StorageAccess[] storageAccesses;</span>
  234 |     | <span class='neutral'>        // Call depth traversed during the recording of state differences</span>
  235 |     | <span class='neutral'>        uint64 depth;</span>
  236 |     | <span class='neutral'>    }</span>
  237 |     | <span class='neutral'></span>
  238 |     | <span class='neutral'>    /// The storage accessed during an `AccountAccess`.</span>
  239 |     | <span class='neutral'>    struct StorageAccess {</span>
  240 |     | <span class='neutral'>        // The account whose storage was accessed.</span>
  241 |     | <span class='neutral'>        address account;</span>
  242 |     | <span class='neutral'>        // The slot that was accessed.</span>
  243 |     | <span class='neutral'>        bytes32 slot;</span>
  244 |     | <span class='neutral'>        // If the access was a write.</span>
  245 |     | <span class='neutral'>        bool isWrite;</span>
  246 |     | <span class='neutral'>        // The previous value of the slot.</span>
  247 |     | <span class='neutral'>        bytes32 previousValue;</span>
  248 |     | <span class='neutral'>        // The new value of the slot.</span>
  249 |     | <span class='neutral'>        bytes32 newValue;</span>
  250 |     | <span class='neutral'>        // If the access was reverted.</span>
  251 |     | <span class='neutral'>        bool reverted;</span>
  252 |     | <span class='neutral'>    }</span>
  253 |     | <span class='neutral'></span>
  254 |     | <span class='neutral'>    /// Gas used. Returned by `lastCallGas`.</span>
  255 |     | <span class='neutral'>    struct Gas {</span>
  256 |     | <span class='neutral'>        // The gas limit of the call.</span>
  257 |     | <span class='neutral'>        uint64 gasLimit;</span>
  258 |     | <span class='neutral'>        // The total gas used.</span>
  259 |     | <span class='neutral'>        uint64 gasTotalUsed;</span>
  260 |     | <span class='neutral'>        // DEPRECATED: The amount of gas used for memory expansion. Ref: &lt;https://github.com/foundry-rs/foundry/pull/7934#pullrequestreview-2069236939&gt;</span>
  261 |     | <span class='neutral'>        uint64 gasMemoryUsed;</span>
  262 |     | <span class='neutral'>        // The amount of gas refunded.</span>
  263 |     | <span class='neutral'>        int64 gasRefunded;</span>
  264 |     | <span class='neutral'>        // The amount of gas remaining.</span>
  265 |     | <span class='neutral'>        uint64 gasRemaining;</span>
  266 |     | <span class='neutral'>    }</span>
  267 |     | <span class='neutral'></span>
  268 |     | <span class='neutral'>    /// The result of the `stopDebugTraceRecording` call</span>
  269 |     | <span class='neutral'>    struct DebugStep {</span>
  270 |     | <span class='neutral'>        // The stack before executing the step of the run.</span>
  271 |     | <span class='neutral'>        // stack\[0\] represents the top of the stack.</span>
  272 |     | <span class='neutral'>        // and only stack data relevant to the opcode execution is contained.</span>
  273 |     | <span class='neutral'>        uint256[] stack;</span>
  274 |     | <span class='neutral'>        // The memory input data before executing the step of the run.</span>
  275 |     | <span class='neutral'>        // only input data relevant to the opcode execution is contained.</span>
  276 |     | <span class='neutral'>        // e.g. for MLOAD, it will have memory\[offset:offset+32\] copied here.</span>
  277 |     | <span class='neutral'>        // the offset value can be get by the stack data.</span>
  278 |     | <span class='neutral'>        bytes memoryInput;</span>
  279 |     | <span class='neutral'>        // The opcode that was accessed.</span>
  280 |     | <span class='neutral'>        uint8 opcode;</span>
  281 |     | <span class='neutral'>        // The call depth of the step.</span>
  282 |     | <span class='neutral'>        uint64 depth;</span>
  283 |     | <span class='neutral'>        // Whether the call end up with out of gas error.</span>
  284 |     | <span class='neutral'>        bool isOutOfGas;</span>
  285 |     | <span class='neutral'>        // The contract address where the opcode is running</span>
  286 |     | <span class='neutral'>        address contractAddr;</span>
  287 |     | <span class='neutral'>    }</span>
  288 |     | <span class='neutral'></span>
  289 |     | <span class='neutral'>    /// Represents a transaction&#39;s broadcast details.</span>
  290 |     | <span class='neutral'>    struct BroadcastTxSummary {</span>
  291 |     | <span class='neutral'>        // The hash of the transaction that was broadcasted</span>
  292 |     | <span class='neutral'>        bytes32 txHash;</span>
  293 |     | <span class='neutral'>        // Represent the type of transaction among CALL, CREATE, CREATE2</span>
  294 |     | <span class='neutral'>        BroadcastTxType txType;</span>
  295 |     | <span class='neutral'>        // The address of the contract that was called or created.</span>
  296 |     | <span class='neutral'>        // This is address of the contract that is created if the txType is CREATE or CREATE2.</span>
  297 |     | <span class='neutral'>        address contractAddress;</span>
  298 |     | <span class='neutral'>        // The block number the transaction landed in.</span>
  299 |     | <span class='neutral'>        uint64 blockNumber;</span>
  300 |     | <span class='neutral'>        // Status of the transaction, retrieved from the transaction receipt.</span>
  301 |     | <span class='neutral'>        bool success;</span>
  302 |     | <span class='neutral'>    }</span>
  303 |     | <span class='neutral'></span>
  304 |     | <span class='neutral'>    /// Holds a signed EIP-7702 authorization for an authority account to delegate to an implementation.</span>
  305 |     | <span class='neutral'>    struct SignedDelegation {</span>
  306 |     | <span class='neutral'>        // The y-parity of the recovered secp256k1 signature (0 or 1).</span>
  307 |     | <span class='neutral'>        uint8 v;</span>
  308 |     | <span class='neutral'>        // First 32 bytes of the signature.</span>
  309 |     | <span class='neutral'>        bytes32 r;</span>
  310 |     | <span class='neutral'>        // Second 32 bytes of the signature.</span>
  311 |     | <span class='neutral'>        bytes32 s;</span>
  312 |     | <span class='neutral'>        // The current nonce of the authority account at signing time.</span>
  313 |     | <span class='neutral'>        // Used to ensure signature can&#39;t be replayed after account nonce changes.</span>
  314 |     | <span class='neutral'>        uint64 nonce;</span>
  315 |     | <span class='neutral'>        // Address of the contract implementation that will be delegated to.</span>
  316 |     | <span class='neutral'>        // Gets encoded into delegation code: 0xef0100 || implementation.</span>
  317 |     | <span class='neutral'>        address implementation;</span>
  318 |     | <span class='neutral'>    }</span>
  319 |     | <span class='neutral'></span>
  320 |     | <span class='neutral'>    /// Represents a &quot;potential&quot; revert reason from a single subsequent call when using `vm.assumeNoReverts`.</span>
  321 |     | <span class='neutral'>    /// Reverts that match will result in a FOUNDRY::ASSUME rejection, whereas unmatched reverts will be surfaced</span>
  322 |     | <span class='neutral'>    /// as normal.</span>
  323 |     | <span class='neutral'>    struct PotentialRevert {</span>
  324 |     | <span class='neutral'>        // The allowed origin of the revert opcode; address(0) allows reverts from any address</span>
  325 |     | <span class='neutral'>        address reverter;</span>
  326 |     | <span class='neutral'>        // When true, only matches on the beginning of the revert data, otherwise, matches on entire revert data</span>
  327 |     | <span class='neutral'>        bool partialMatch;</span>
  328 |     | <span class='neutral'>        // The data to use to match encountered reverts</span>
  329 |     | <span class='neutral'>        bytes revertData;</span>
  330 |     | <span class='neutral'>    }</span>
  331 |     | <span class='neutral'></span>
  332 |     | <span class='neutral'>    /// An EIP-2930 access list item.</span>
  333 |     | <span class='neutral'>    struct AccessListItem {</span>
  334 |     | <span class='neutral'>        // The address to be added in access list.</span>
  335 |     | <span class='neutral'>        address target;</span>
  336 |     | <span class='neutral'>        // The storage keys to be added in access list.</span>
  337 |     | <span class='neutral'>        bytes32[] storageKeys;</span>
  338 |     | <span class='neutral'>    }</span>
  339 |     | <span class='neutral'></span>
  340 |     | <span class='neutral'>    // ======== Crypto ========</span>
  341 |     | <span class='neutral'></span>
  342 |     | <span class='neutral'>    /// Derives a private key from the name, labels the account with that name, and returns the wallet.</span>
  343 |     | <span class='neutral'>    function createWallet(string calldata walletLabel) external returns (Wallet memory wallet);</span>
  344 |     | <span class='neutral'></span>
  345 |     | <span class='neutral'>    /// Generates a wallet from the private key and returns the wallet.</span>
  346 |     | <span class='neutral'>    function createWallet(uint256 privateKey) external returns (Wallet memory wallet);</span>
  347 |     | <span class='neutral'></span>
  348 |     | <span class='neutral'>    /// Generates a wallet from the private key, labels the account with that name, and returns the wallet.</span>
  349 |     | <span class='neutral'>    function createWallet(uint256 privateKey, string calldata walletLabel) external returns (Wallet memory wallet);</span>
  350 |     | <span class='neutral'></span>
  351 |     | <span class='neutral'>    /// Derive a private key from a provided mnenomic string (or mnenomic file path)</span>
  352 |     | <span class='neutral'>    /// at the derivation path `m/44&#39;/60&#39;/0&#39;/0/{index}`.</span>
  353 |     | <span class='neutral'>    function deriveKey(string calldata mnemonic, uint32 index) external pure returns (uint256 privateKey);</span>
  354 |     | <span class='neutral'></span>
  355 |     | <span class='neutral'>    /// Derive a private key from a provided mnenomic string (or mnenomic file path)</span>
  356 |     | <span class='neutral'>    /// at `{derivationPath}{index}`.</span>
  357 |     | <span class='neutral'>    function deriveKey(string calldata mnemonic, string calldata derivationPath, uint32 index)</span>
  358 |     | <span class='neutral'>        external</span>
  359 |     | <span class='neutral'>        pure</span>
  360 |     | <span class='neutral'>        returns (uint256 privateKey);</span>
  361 |     | <span class='neutral'></span>
  362 |     | <span class='neutral'>    /// Derive a private key from a provided mnenomic string (or mnenomic file path) in the specified language</span>
  363 |     | <span class='neutral'>    /// at the derivation path `m/44&#39;/60&#39;/0&#39;/0/{index}`.</span>
  364 |     | <span class='neutral'>    function deriveKey(string calldata mnemonic, uint32 index, string calldata language)</span>
  365 |     | <span class='neutral'>        external</span>
  366 |     | <span class='neutral'>        pure</span>
  367 |     | <span class='neutral'>        returns (uint256 privateKey);</span>
  368 |     | <span class='neutral'></span>
  369 |     | <span class='neutral'>    /// Derive a private key from a provided mnenomic string (or mnenomic file path) in the specified language</span>
  370 |     | <span class='neutral'>    /// at `{derivationPath}{index}`.</span>
  371 |     | <span class='neutral'>    function deriveKey(string calldata mnemonic, string calldata derivationPath, uint32 index, string calldata language)</span>
  372 |     | <span class='neutral'>        external</span>
  373 |     | <span class='neutral'>        pure</span>
  374 |     | <span class='neutral'>        returns (uint256 privateKey);</span>
  375 |     | <span class='neutral'></span>
  376 |     | <span class='neutral'>    /// Derives secp256r1 public key from the provided `privateKey`.</span>
  377 |     | <span class='neutral'>    function publicKeyP256(uint256 privateKey) external pure returns (uint256 publicKeyX, uint256 publicKeyY);</span>
  378 |     | <span class='neutral'></span>
  379 |     | <span class='neutral'>    /// Adds a private key to the local forge wallet and returns the address.</span>
  380 |     | <span class='neutral'>    function rememberKey(uint256 privateKey) external returns (address keyAddr);</span>
  381 |     | <span class='neutral'></span>
  382 |     | <span class='neutral'>    /// Derive a set number of wallets from a mnemonic at the derivation path `m/44&#39;/60&#39;/0&#39;/0/{0..count}`.</span>
  383 |     | <span class='neutral'>    /// The respective private keys are saved to the local forge wallet for later use and their addresses are returned.</span>
  384 |     | <span class='neutral'>    function rememberKeys(string calldata mnemonic, string calldata derivationPath, uint32 count)</span>
  385 |     | <span class='neutral'>        external</span>
  386 |     | <span class='neutral'>        returns (address[] memory keyAddrs);</span>
  387 |     | <span class='neutral'></span>
  388 |     | <span class='neutral'>    /// Derive a set number of wallets from a mnemonic in the specified language at the derivation path `m/44&#39;/60&#39;/0&#39;/0/{0..count}`.</span>
  389 |     | <span class='neutral'>    /// The respective private keys are saved to the local forge wallet for later use and their addresses are returned.</span>
  390 |     | <span class='neutral'>    function rememberKeys(</span>
  391 |     | <span class='neutral'>        string calldata mnemonic,</span>
  392 |     | <span class='neutral'>        string calldata derivationPath,</span>
  393 |     | <span class='neutral'>        string calldata language,</span>
  394 |     | <span class='neutral'>        uint32 count</span>
  395 |     | <span class='neutral'>    ) external returns (address[] memory keyAddrs);</span>
  396 |     | <span class='neutral'></span>
  397 |     | <span class='neutral'>    /// Signs data with a `Wallet`.</span>
  398 |     | <span class='neutral'>    /// Returns a compact signature (`r`, `vs`) as per EIP-2098, where `vs` encodes both the</span>
  399 |     | <span class='neutral'>    /// signature&#39;s `s` value, and the recovery id `v` in a single bytes32.</span>
  400 |     | <span class='neutral'>    /// This format reduces the signature size from 65 to 64 bytes.</span>
  401 |     | <span class='neutral'>    function signCompact(Wallet calldata wallet, bytes32 digest) external returns (bytes32 r, bytes32 vs);</span>
  402 |     | <span class='neutral'></span>
  403 |     | <span class='neutral'>    /// Signs `digest` with `privateKey` using the secp256k1 curve.</span>
  404 |     | <span class='neutral'>    /// Returns a compact signature (`r`, `vs`) as per EIP-2098, where `vs` encodes both the</span>
  405 |     | <span class='neutral'>    /// signature&#39;s `s` value, and the recovery id `v` in a single bytes32.</span>
  406 |     | <span class='neutral'>    /// This format reduces the signature size from 65 to 64 bytes.</span>
  407 |     | <span class='neutral'>    function signCompact(uint256 privateKey, bytes32 digest) external pure returns (bytes32 r, bytes32 vs);</span>
  408 |     | <span class='neutral'></span>
  409 |     | <span class='neutral'>    /// Signs `digest` with signer provided to script using the secp256k1 curve.</span>
  410 |     | <span class='neutral'>    /// Returns a compact signature (`r`, `vs`) as per EIP-2098, where `vs` encodes both the</span>
  411 |     | <span class='neutral'>    /// signature&#39;s `s` value, and the recovery id `v` in a single bytes32.</span>
  412 |     | <span class='neutral'>    /// This format reduces the signature size from 65 to 64 bytes.</span>
  413 |     | <span class='neutral'>    /// If `--sender` is provided, the signer with provided address is used, otherwise,</span>
  414 |     | <span class='neutral'>    /// if exactly one signer is provided to the script, that signer is used.</span>
  415 |     | <span class='neutral'>    /// Raises error if signer passed through `--sender` does not match any unlocked signers or</span>
  416 |     | <span class='neutral'>    /// if `--sender` is not provided and not exactly one signer is passed to the script.</span>
  417 |     | <span class='neutral'>    function signCompact(bytes32 digest) external pure returns (bytes32 r, bytes32 vs);</span>
  418 |     | <span class='neutral'></span>
  419 |     | <span class='neutral'>    /// Signs `digest` with signer provided to script using the secp256k1 curve.</span>
  420 |     | <span class='neutral'>    /// Returns a compact signature (`r`, `vs`) as per EIP-2098, where `vs` encodes both the</span>
  421 |     | <span class='neutral'>    /// signature&#39;s `s` value, and the recovery id `v` in a single bytes32.</span>
  422 |     | <span class='neutral'>    /// This format reduces the signature size from 65 to 64 bytes.</span>
  423 |     | <span class='neutral'>    /// Raises error if none of the signers passed into the script have provided address.</span>
  424 |     | <span class='neutral'>    function signCompact(address signer, bytes32 digest) external pure returns (bytes32 r, bytes32 vs);</span>
  425 |     | <span class='neutral'></span>
  426 |     | <span class='neutral'>    /// Signs `digest` with `privateKey` using the secp256r1 curve.</span>
  427 |     | <span class='neutral'>    function signP256(uint256 privateKey, bytes32 digest) external pure returns (bytes32 r, bytes32 s);</span>
  428 |     | <span class='neutral'></span>
  429 |     | <span class='neutral'>    /// Signs data with a `Wallet`.</span>
  430 |     | <span class='neutral'>    function sign(Wallet calldata wallet, bytes32 digest) external returns (uint8 v, bytes32 r, bytes32 s);</span>
  431 |     | <span class='neutral'></span>
  432 |     | <span class='neutral'>    /// Signs `digest` with `privateKey` using the secp256k1 curve.</span>
  433 |     | <span class='neutral'>    function sign(uint256 privateKey, bytes32 digest) external pure returns (uint8 v, bytes32 r, bytes32 s);</span>
  434 |     | <span class='neutral'></span>
  435 |     | <span class='neutral'>    /// Signs `digest` with signer provided to script using the secp256k1 curve.</span>
  436 |     | <span class='neutral'>    /// If `--sender` is provided, the signer with provided address is used, otherwise,</span>
  437 |     | <span class='neutral'>    /// if exactly one signer is provided to the script, that signer is used.</span>
  438 |     | <span class='neutral'>    /// Raises error if signer passed through `--sender` does not match any unlocked signers or</span>
  439 |     | <span class='neutral'>    /// if `--sender` is not provided and not exactly one signer is passed to the script.</span>
  440 |     | <span class='neutral'>    function sign(bytes32 digest) external pure returns (uint8 v, bytes32 r, bytes32 s);</span>
  441 |     | <span class='neutral'></span>
  442 |     | <span class='neutral'>    /// Signs `digest` with signer provided to script using the secp256k1 curve.</span>
  443 |     | <span class='neutral'>    /// Raises error if none of the signers passed into the script have provided address.</span>
  444 |     | <span class='neutral'>    function sign(address signer, bytes32 digest) external pure returns (uint8 v, bytes32 r, bytes32 s);</span>
  445 |     | <span class='neutral'></span>
  446 |     | <span class='neutral'>    // ======== Environment ========</span>
  447 |     | <span class='neutral'></span>
  448 |     | <span class='neutral'>    /// Gets the environment variable `name` and parses it as `address`.</span>
  449 |     | <span class='neutral'>    /// Reverts if the variable was not found or could not be parsed.</span>
  450 |     | <span class='neutral'>    function envAddress(string calldata name) external view returns (address value);</span>
  451 |     | <span class='neutral'></span>
  452 |     | <span class='neutral'>    /// Gets the environment variable `name` and parses it as an array of `address`, delimited by `delim`.</span>
  453 |     | <span class='neutral'>    /// Reverts if the variable was not found or could not be parsed.</span>
  454 |     | <span class='neutral'>    function envAddress(string calldata name, string calldata delim) external view returns (address[] memory value);</span>
  455 |     | <span class='neutral'></span>
  456 |     | <span class='neutral'>    /// Gets the environment variable `name` and parses it as `bool`.</span>
  457 |     | <span class='neutral'>    /// Reverts if the variable was not found or could not be parsed.</span>
  458 |     | <span class='neutral'>    function envBool(string calldata name) external view returns (bool value);</span>
  459 |     | <span class='neutral'></span>
  460 |     | <span class='neutral'>    /// Gets the environment variable `name` and parses it as an array of `bool`, delimited by `delim`.</span>
  461 |     | <span class='neutral'>    /// Reverts if the variable was not found or could not be parsed.</span>
  462 |     | <span class='neutral'>    function envBool(string calldata name, string calldata delim) external view returns (bool[] memory value);</span>
  463 |     | <span class='neutral'></span>
  464 |     | <span class='neutral'>    /// Gets the environment variable `name` and parses it as `bytes32`.</span>
  465 |     | <span class='neutral'>    /// Reverts if the variable was not found or could not be parsed.</span>
  466 |     | <span class='neutral'>    function envBytes32(string calldata name) external view returns (bytes32 value);</span>
  467 |     | <span class='neutral'></span>
  468 |     | <span class='neutral'>    /// Gets the environment variable `name` and parses it as an array of `bytes32`, delimited by `delim`.</span>
  469 |     | <span class='neutral'>    /// Reverts if the variable was not found or could not be parsed.</span>
  470 |     | <span class='neutral'>    function envBytes32(string calldata name, string calldata delim) external view returns (bytes32[] memory value);</span>
  471 |     | <span class='neutral'></span>
  472 |     | <span class='neutral'>    /// Gets the environment variable `name` and parses it as `bytes`.</span>
  473 |     | <span class='neutral'>    /// Reverts if the variable was not found or could not be parsed.</span>
  474 |     | <span class='neutral'>    function envBytes(string calldata name) external view returns (bytes memory value);</span>
  475 |     | <span class='neutral'></span>
  476 |     | <span class='neutral'>    /// Gets the environment variable `name` and parses it as an array of `bytes`, delimited by `delim`.</span>
  477 |     | <span class='neutral'>    /// Reverts if the variable was not found or could not be parsed.</span>
  478 |     | <span class='neutral'>    function envBytes(string calldata name, string calldata delim) external view returns (bytes[] memory value);</span>
  479 |     | <span class='neutral'></span>
  480 |     | <span class='neutral'>    /// Gets the environment variable `name` and returns true if it exists, else returns false.</span>
  481 |     | <span class='neutral'>    function envExists(string calldata name) external view returns (bool result);</span>
  482 |     | <span class='neutral'></span>
  483 |     | <span class='neutral'>    /// Gets the environment variable `name` and parses it as `int256`.</span>
  484 |     | <span class='neutral'>    /// Reverts if the variable was not found or could not be parsed.</span>
  485 |     | <span class='neutral'>    function envInt(string calldata name) external view returns (int256 value);</span>
  486 |     | <span class='neutral'></span>
  487 |     | <span class='neutral'>    /// Gets the environment variable `name` and parses it as an array of `int256`, delimited by `delim`.</span>
  488 |     | <span class='neutral'>    /// Reverts if the variable was not found or could not be parsed.</span>
  489 |     | <span class='neutral'>    function envInt(string calldata name, string calldata delim) external view returns (int256[] memory value);</span>
  490 |     | <span class='neutral'></span>
  491 |     | <span class='neutral'>    /// Gets the environment variable `name` and parses it as `bool`.</span>
  492 |     | <span class='neutral'>    /// Reverts if the variable could not be parsed.</span>
  493 |     | <span class='neutral'>    /// Returns `defaultValue` if the variable was not found.</span>
  494 |     | <span class='neutral'>    function envOr(string calldata name, bool defaultValue) external view returns (bool value);</span>
  495 |     | <span class='neutral'></span>
  496 |     | <span class='neutral'>    /// Gets the environment variable `name` and parses it as `uint256`.</span>
  497 |     | <span class='neutral'>    /// Reverts if the variable could not be parsed.</span>
  498 |     | <span class='neutral'>    /// Returns `defaultValue` if the variable was not found.</span>
  499 |     | <span class='neutral'>    function envOr(string calldata name, uint256 defaultValue) external view returns (uint256 value);</span>
  500 |     | <span class='neutral'></span>
  501 |     | <span class='neutral'>    /// Gets the environment variable `name` and parses it as an array of `address`, delimited by `delim`.</span>
  502 |     | <span class='neutral'>    /// Reverts if the variable could not be parsed.</span>
  503 |     | <span class='neutral'>    /// Returns `defaultValue` if the variable was not found.</span>
  504 |     | <span class='neutral'>    function envOr(string calldata name, string calldata delim, address[] calldata defaultValue)</span>
  505 |     | <span class='neutral'>        external</span>
  506 |     | <span class='neutral'>        view</span>
  507 |     | <span class='neutral'>        returns (address[] memory value);</span>
  508 |     | <span class='neutral'></span>
  509 |     | <span class='neutral'>    /// Gets the environment variable `name` and parses it as an array of `bytes32`, delimited by `delim`.</span>
  510 |     | <span class='neutral'>    /// Reverts if the variable could not be parsed.</span>
  511 |     | <span class='neutral'>    /// Returns `defaultValue` if the variable was not found.</span>
  512 |     | <span class='neutral'>    function envOr(string calldata name, string calldata delim, bytes32[] calldata defaultValue)</span>
  513 |     | <span class='neutral'>        external</span>
  514 |     | <span class='neutral'>        view</span>
  515 |     | <span class='neutral'>        returns (bytes32[] memory value);</span>
  516 |     | <span class='neutral'></span>
  517 |     | <span class='neutral'>    /// Gets the environment variable `name` and parses it as an array of `string`, delimited by `delim`.</span>
  518 |     | <span class='neutral'>    /// Reverts if the variable could not be parsed.</span>
  519 |     | <span class='neutral'>    /// Returns `defaultValue` if the variable was not found.</span>
  520 |     | <span class='neutral'>    function envOr(string calldata name, string calldata delim, string[] calldata defaultValue)</span>
  521 |     | <span class='neutral'>        external</span>
  522 |     | <span class='neutral'>        view</span>
  523 |     | <span class='neutral'>        returns (string[] memory value);</span>
  524 |     | <span class='neutral'></span>
  525 |     | <span class='neutral'>    /// Gets the environment variable `name` and parses it as an array of `bytes`, delimited by `delim`.</span>
  526 |     | <span class='neutral'>    /// Reverts if the variable could not be parsed.</span>
  527 |     | <span class='neutral'>    /// Returns `defaultValue` if the variable was not found.</span>
  528 |     | <span class='neutral'>    function envOr(string calldata name, string calldata delim, bytes[] calldata defaultValue)</span>
  529 |     | <span class='neutral'>        external</span>
  530 |     | <span class='neutral'>        view</span>
  531 |     | <span class='neutral'>        returns (bytes[] memory value);</span>
  532 |     | <span class='neutral'></span>
  533 |     | <span class='neutral'>    /// Gets the environment variable `name` and parses it as `int256`.</span>
  534 |     | <span class='neutral'>    /// Reverts if the variable could not be parsed.</span>
  535 |     | <span class='neutral'>    /// Returns `defaultValue` if the variable was not found.</span>
  536 |     | <span class='neutral'>    function envOr(string calldata name, int256 defaultValue) external view returns (int256 value);</span>
  537 |     | <span class='neutral'></span>
  538 |     | <span class='neutral'>    /// Gets the environment variable `name` and parses it as `address`.</span>
  539 |     | <span class='neutral'>    /// Reverts if the variable could not be parsed.</span>
  540 |     | <span class='neutral'>    /// Returns `defaultValue` if the variable was not found.</span>
  541 |     | <span class='neutral'>    function envOr(string calldata name, address defaultValue) external view returns (address value);</span>
  542 |     | <span class='neutral'></span>
  543 |     | <span class='neutral'>    /// Gets the environment variable `name` and parses it as `bytes32`.</span>
  544 |     | <span class='neutral'>    /// Reverts if the variable could not be parsed.</span>
  545 |     | <span class='neutral'>    /// Returns `defaultValue` if the variable was not found.</span>
  546 |     | <span class='neutral'>    function envOr(string calldata name, bytes32 defaultValue) external view returns (bytes32 value);</span>
  547 |     | <span class='neutral'></span>
  548 |     | <span class='neutral'>    /// Gets the environment variable `name` and parses it as `string`.</span>
  549 |     | <span class='neutral'>    /// Reverts if the variable could not be parsed.</span>
  550 |     | <span class='neutral'>    /// Returns `defaultValue` if the variable was not found.</span>
  551 |     | <span class='neutral'>    function envOr(string calldata name, string calldata defaultValue) external view returns (string memory value);</span>
  552 |     | <span class='neutral'></span>
  553 |     | <span class='neutral'>    /// Gets the environment variable `name` and parses it as `bytes`.</span>
  554 |     | <span class='neutral'>    /// Reverts if the variable could not be parsed.</span>
  555 |     | <span class='neutral'>    /// Returns `defaultValue` if the variable was not found.</span>
  556 |     | <span class='neutral'>    function envOr(string calldata name, bytes calldata defaultValue) external view returns (bytes memory value);</span>
  557 |     | <span class='neutral'></span>
  558 |     | <span class='neutral'>    /// Gets the environment variable `name` and parses it as an array of `bool`, delimited by `delim`.</span>
  559 |     | <span class='neutral'>    /// Reverts if the variable could not be parsed.</span>
  560 |     | <span class='neutral'>    /// Returns `defaultValue` if the variable was not found.</span>
  561 |     | <span class='neutral'>    function envOr(string calldata name, string calldata delim, bool[] calldata defaultValue)</span>
  562 |     | <span class='neutral'>        external</span>
  563 |     | <span class='neutral'>        view</span>
  564 |     | <span class='neutral'>        returns (bool[] memory value);</span>
  565 |     | <span class='neutral'></span>
  566 |     | <span class='neutral'>    /// Gets the environment variable `name` and parses it as an array of `uint256`, delimited by `delim`.</span>
  567 |     | <span class='neutral'>    /// Reverts if the variable could not be parsed.</span>
  568 |     | <span class='neutral'>    /// Returns `defaultValue` if the variable was not found.</span>
  569 |     | <span class='neutral'>    function envOr(string calldata name, string calldata delim, uint256[] calldata defaultValue)</span>
  570 |     | <span class='neutral'>        external</span>
  571 |     | <span class='neutral'>        view</span>
  572 |     | <span class='neutral'>        returns (uint256[] memory value);</span>
  573 |     | <span class='neutral'></span>
  574 |     | <span class='neutral'>    /// Gets the environment variable `name` and parses it as an array of `int256`, delimited by `delim`.</span>
  575 |     | <span class='neutral'>    /// Reverts if the variable could not be parsed.</span>
  576 |     | <span class='neutral'>    /// Returns `defaultValue` if the variable was not found.</span>
  577 |     | <span class='neutral'>    function envOr(string calldata name, string calldata delim, int256[] calldata defaultValue)</span>
  578 |     | <span class='neutral'>        external</span>
  579 |     | <span class='neutral'>        view</span>
  580 |     | <span class='neutral'>        returns (int256[] memory value);</span>
  581 |     | <span class='neutral'></span>
  582 |     | <span class='neutral'>    /// Gets the environment variable `name` and parses it as `string`.</span>
  583 |     | <span class='neutral'>    /// Reverts if the variable was not found or could not be parsed.</span>
  584 |     | <span class='neutral'>    function envString(string calldata name) external view returns (string memory value);</span>
  585 |     | <span class='neutral'></span>
  586 |     | <span class='neutral'>    /// Gets the environment variable `name` and parses it as an array of `string`, delimited by `delim`.</span>
  587 |     | <span class='neutral'>    /// Reverts if the variable was not found or could not be parsed.</span>
  588 |     | <span class='neutral'>    function envString(string calldata name, string calldata delim) external view returns (string[] memory value);</span>
  589 |     | <span class='neutral'></span>
  590 |     | <span class='neutral'>    /// Gets the environment variable `name` and parses it as `uint256`.</span>
  591 |     | <span class='neutral'>    /// Reverts if the variable was not found or could not be parsed.</span>
  592 |     | <span class='neutral'>    function envUint(string calldata name) external view returns (uint256 value);</span>
  593 |     | <span class='neutral'></span>
  594 |     | <span class='neutral'>    /// Gets the environment variable `name` and parses it as an array of `uint256`, delimited by `delim`.</span>
  595 |     | <span class='neutral'>    /// Reverts if the variable was not found or could not be parsed.</span>
  596 |     | <span class='neutral'>    function envUint(string calldata name, string calldata delim) external view returns (uint256[] memory value);</span>
  597 |     | <span class='neutral'></span>
  598 |     | <span class='neutral'>    /// Returns true if `forge` command was executed in given context.</span>
  599 |     | <span class='neutral'>    function isContext(ForgeContext context) external view returns (bool result);</span>
  600 |     | <span class='neutral'></span>
  601 |     | <span class='neutral'>    /// Sets environment variables.</span>
  602 |     | <span class='neutral'>    function setEnv(string calldata name, string calldata value) external;</span>
  603 |     | <span class='neutral'></span>
  604 |     | <span class='neutral'>    // ======== EVM ========</span>
  605 |     | <span class='neutral'></span>
  606 |     | <span class='neutral'>    /// Gets all accessed reads and write slot from a `vm.record` session, for a given address.</span>
  607 |     | <span class='neutral'>    function accesses(address target) external returns (bytes32[] memory readSlots, bytes32[] memory writeSlots);</span>
  608 |     | <span class='neutral'></span>
  609 |     | <span class='neutral'>    /// Gets the address for a given private key.</span>
  610 |     | <span class='neutral'>    function addr(uint256 privateKey) external pure returns (address keyAddr);</span>
  611 |     | <span class='neutral'></span>
  612 |     | <span class='neutral'>    /// Gets all the logs according to specified filter.</span>
  613 |     | <span class='neutral'>    function eth_getLogs(uint256 fromBlock, uint256 toBlock, address target, bytes32[] calldata topics)</span>
  614 |     | <span class='neutral'>        external</span>
  615 |     | <span class='neutral'>        returns (EthGetLogs[] memory logs);</span>
  616 |     | <span class='neutral'></span>
  617 |     | <span class='neutral'>    /// Gets the current `block.blobbasefee`.</span>
  618 |     | <span class='neutral'>    /// You should use this instead of `block.blobbasefee` if you use `vm.blobBaseFee`, as `block.blobbasefee` is assumed to be constant across a transaction,</span>
  619 |     | <span class='neutral'>    /// and as a result will get optimized out by the compiler.</span>
  620 |     | <span class='neutral'>    /// See https://github.com/foundry-rs/foundry/issues/6180</span>
  621 |     | <span class='neutral'>    function getBlobBaseFee() external view returns (uint256 blobBaseFee);</span>
  622 |     | <span class='neutral'></span>
  623 |     | <span class='neutral'>    /// Gets the current `block.number`.</span>
  624 |     | <span class='neutral'>    /// You should use this instead of `block.number` if you use `vm.roll`, as `block.number` is assumed to be constant across a transaction,</span>
  625 |     | <span class='neutral'>    /// and as a result will get optimized out by the compiler.</span>
  626 |     | <span class='neutral'>    /// See https://github.com/foundry-rs/foundry/issues/6180</span>
  627 |     | <span class='neutral'>    function getBlockNumber() external view returns (uint256 height);</span>
  628 |     | <span class='neutral'></span>
  629 |     | <span class='neutral'>    /// Gets the current `block.timestamp`.</span>
  630 |     | <span class='neutral'>    /// You should use this instead of `block.timestamp` if you use `vm.warp`, as `block.timestamp` is assumed to be constant across a transaction,</span>
  631 |     | <span class='neutral'>    /// and as a result will get optimized out by the compiler.</span>
  632 |     | <span class='neutral'>    /// See https://github.com/foundry-rs/foundry/issues/6180</span>
  633 |     | <span class='neutral'>    function getBlockTimestamp() external view returns (uint256 timestamp);</span>
  634 |     | <span class='neutral'></span>
  635 |     | <span class='neutral'>    /// Gets the map key and parent of a mapping at a given slot, for a given address.</span>
  636 |     | <span class='neutral'>    function getMappingKeyAndParentOf(address target, bytes32 elementSlot)</span>
  637 |     | <span class='neutral'>        external</span>
  638 |     | <span class='neutral'>        returns (bool found, bytes32 key, bytes32 parent);</span>
  639 |     | <span class='neutral'></span>
  640 |     | <span class='neutral'>    /// Gets the number of elements in the mapping at the given slot, for a given address.</span>
  641 |     | <span class='neutral'>    function getMappingLength(address target, bytes32 mappingSlot) external returns (uint256 length);</span>
  642 |     | <span class='neutral'></span>
  643 |     | <span class='neutral'>    /// Gets the elements at index idx of the mapping at the given slot, for a given address. The</span>
  644 |     | <span class='neutral'>    /// index must be less than the length of the mapping (i.e. the number of keys in the mapping).</span>
  645 |     | <span class='neutral'>    function getMappingSlotAt(address target, bytes32 mappingSlot, uint256 idx) external returns (bytes32 value);</span>
  646 |     | <span class='neutral'></span>
  647 |     | <span class='neutral'>    /// Gets the nonce of an account.</span>
  648 |     | <span class='neutral'>    function getNonce(address account) external view returns (uint64 nonce);</span>
  649 |     | <span class='neutral'></span>
  650 |     | <span class='neutral'>    /// Get the nonce of a `Wallet`.</span>
  651 |     | <span class='neutral'>    function getNonce(Wallet calldata wallet) external returns (uint64 nonce);</span>
  652 |     | <span class='neutral'></span>
  653 |     | <span class='neutral'>    /// Gets all the recorded logs.</span>
  654 |     | <span class='neutral'>    function getRecordedLogs() external returns (Log[] memory logs);</span>
  655 |     | <span class='neutral'></span>
  656 |     | <span class='neutral'>    /// Returns state diffs from current `vm.startStateDiffRecording` session.</span>
  657 |     | <span class='neutral'>    function getStateDiff() external view returns (string memory diff);</span>
  658 |     | <span class='neutral'></span>
  659 |     | <span class='neutral'>    /// Returns state diffs from current `vm.startStateDiffRecording` session, in json format.</span>
  660 |     | <span class='neutral'>    function getStateDiffJson() external view returns (string memory diff);</span>
  661 |     | <span class='neutral'></span>
  662 |     | <span class='neutral'>    /// Gets the gas used in the last call from the callee perspective.</span>
  663 |     | <span class='neutral'>    function lastCallGas() external view returns (Gas memory gas);</span>
  664 |     | <span class='neutral'></span>
  665 |     | <span class='neutral'>    /// Loads a storage slot from an address.</span>
  666 |     | <span class='neutral'>    function load(address target, bytes32 slot) external view returns (bytes32 data);</span>
  667 |     | <span class='neutral'></span>
  668 |     | <span class='neutral'>    /// Pauses gas metering (i.e. gas usage is not counted). Noop if already paused.</span>
  669 |     | <span class='neutral'>    function pauseGasMetering() external;</span>
  670 |     | <span class='neutral'></span>
  671 |     | <span class='neutral'>    /// Records all storage reads and writes. Use `accesses` to get the recorded data.</span>
  672 |     | <span class='neutral'>    /// Subsequent calls to `record` will clear the previous data.</span>
  673 |     | <span class='neutral'>    function record() external;</span>
  674 |     | <span class='neutral'></span>
  675 |     | <span class='neutral'>    /// Record all the transaction logs.</span>
  676 |     | <span class='neutral'>    function recordLogs() external;</span>
  677 |     | <span class='neutral'></span>
  678 |     | <span class='neutral'>    /// Reset gas metering (i.e. gas usage is set to gas limit).</span>
  679 |     | <span class='neutral'>    function resetGasMetering() external;</span>
  680 |     | <span class='neutral'></span>
  681 |     | <span class='neutral'>    /// Resumes gas metering (i.e. gas usage is counted again). Noop if already on.</span>
  682 |     | <span class='neutral'>    function resumeGasMetering() external;</span>
  683 |     | <span class='neutral'></span>
  684 |     | <span class='neutral'>    /// Performs an Ethereum JSON-RPC request to the current fork URL.</span>
  685 |     | <span class='neutral'>    function rpc(string calldata method, string calldata params) external returns (bytes memory data);</span>
  686 |     | <span class='neutral'></span>
  687 |     | <span class='neutral'>    /// Performs an Ethereum JSON-RPC request to the given endpoint.</span>
  688 |     | <span class='neutral'>    function rpc(string calldata urlOrAlias, string calldata method, string calldata params)</span>
  689 |     | <span class='neutral'>        external</span>
  690 |     | <span class='neutral'>        returns (bytes memory data);</span>
  691 |     | <span class='neutral'></span>
  692 |     | <span class='neutral'>    /// Records the debug trace during the run.</span>
  693 |     | <span class='neutral'>    function startDebugTraceRecording() external;</span>
  694 |     | <span class='neutral'></span>
  695 |     | <span class='neutral'>    /// Starts recording all map SSTOREs for later retrieval.</span>
  696 |     | <span class='neutral'>    function startMappingRecording() external;</span>
  697 |     | <span class='neutral'></span>
  698 |     | <span class='neutral'>    /// Record all account accesses as part of CREATE, CALL or SELFDESTRUCT opcodes in order,</span>
  699 |     | <span class='neutral'>    /// along with the context of the calls</span>
  700 |     | <span class='neutral'>    function startStateDiffRecording() external;</span>
  701 |     | <span class='neutral'></span>
  702 |     | <span class='neutral'>    /// Stop debug trace recording and returns the recorded debug trace.</span>
  703 |     | <span class='neutral'>    function stopAndReturnDebugTraceRecording() external returns (DebugStep[] memory step);</span>
  704 |     | <span class='neutral'></span>
  705 |     | <span class='neutral'>    /// Returns an ordered array of all account accesses from a `vm.startStateDiffRecording` session.</span>
  706 |     | <span class='neutral'>    function stopAndReturnStateDiff() external returns (AccountAccess[] memory accountAccesses);</span>
  707 |     | <span class='neutral'></span>
  708 |     | <span class='neutral'>    /// Stops recording all map SSTOREs for later retrieval and clears the recorded data.</span>
  709 |     | <span class='neutral'>    function stopMappingRecording() external;</span>
  710 |     | <span class='neutral'></span>
  711 |     | <span class='neutral'>    /// Stops recording storage reads and writes.</span>
  712 |     | <span class='neutral'>    function stopRecord() external;</span>
  713 |     | <span class='neutral'></span>
  714 |     | <span class='neutral'>    // ======== Filesystem ========</span>
  715 |     | <span class='neutral'></span>
  716 |     | <span class='neutral'>    /// Closes file for reading, resetting the offset and allowing to read it from beginning with readLine.</span>
  717 |     | <span class='neutral'>    /// `path` is relative to the project root.</span>
  718 |     | <span class='neutral'>    function closeFile(string calldata path) external;</span>
  719 |     | <span class='neutral'></span>
  720 |     | <span class='neutral'>    /// Copies the contents of one file to another. This function will **overwrite** the contents of `to`.</span>
  721 |     | <span class='neutral'>    /// On success, the total number of bytes copied is returned and it is equal to the length of the `to` file as reported by `metadata`.</span>
  722 |     | <span class='neutral'>    /// Both `from` and `to` are relative to the project root.</span>
  723 |     | <span class='neutral'>    function copyFile(string calldata from, string calldata to) external returns (uint64 copied);</span>
  724 |     | <span class='neutral'></span>
  725 |     | <span class='neutral'>    /// Creates a new, empty directory at the provided path.</span>
  726 |     | <span class='neutral'>    /// This cheatcode will revert in the following situations, but is not limited to just these cases:</span>
  727 |     | <span class='neutral'>    /// - User lacks permissions to modify `path`.</span>
  728 |     | <span class='neutral'>    /// - A parent of the given path doesn&#39;t exist and `recursive` is false.</span>
  729 |     | <span class='neutral'>    /// - `path` already exists and `recursive` is false.</span>
  730 |     | <span class='neutral'>    /// `path` is relative to the project root.</span>
  731 |     | <span class='neutral'>    function createDir(string calldata path, bool recursive) external;</span>
  732 |     | <span class='neutral'></span>
  733 |     | <span class='neutral'>    /// Deploys a contract from an artifact file. Takes in the relative path to the json file or the path to the</span>
  734 |     | <span class='neutral'>    /// artifact in the form of &lt;path&gt;:&lt;contract&gt;:&lt;version&gt; where &lt;contract&gt; and &lt;version&gt; parts are optional.</span>
  735 |     | <span class='neutral'>    function deployCode(string calldata artifactPath) external returns (address deployedAddress);</span>
  736 |     | <span class='neutral'></span>
  737 |     | <span class='neutral'>    /// Deploys a contract from an artifact file. Takes in the relative path to the json file or the path to the</span>
  738 |     | <span class='neutral'>    /// artifact in the form of &lt;path&gt;:&lt;contract&gt;:&lt;version&gt; where &lt;contract&gt; and &lt;version&gt; parts are optional.</span>
  739 |     | <span class='neutral'>    /// Additionally accepts abi-encoded constructor arguments.</span>
  740 |     | <span class='neutral'>    function deployCode(string calldata artifactPath, bytes calldata constructorArgs)</span>
  741 |     | <span class='neutral'>        external</span>
  742 |     | <span class='neutral'>        returns (address deployedAddress);</span>
  743 |     | <span class='neutral'></span>
  744 |     | <span class='neutral'>    /// Deploys a contract from an artifact file. Takes in the relative path to the json file or the path to the</span>
  745 |     | <span class='neutral'>    /// artifact in the form of &lt;path&gt;:&lt;contract&gt;:&lt;version&gt; where &lt;contract&gt; and &lt;version&gt; parts are optional.</span>
  746 |     | <span class='neutral'>    /// Additionally accepts `msg.value`.</span>
  747 |     | <span class='neutral'>    function deployCode(string calldata artifactPath, uint256 value) external returns (address deployedAddress);</span>
  748 |     | <span class='neutral'></span>
  749 |     | <span class='neutral'>    /// Deploys a contract from an artifact file. Takes in the relative path to the json file or the path to the</span>
  750 |     | <span class='neutral'>    /// artifact in the form of &lt;path&gt;:&lt;contract&gt;:&lt;version&gt; where &lt;contract&gt; and &lt;version&gt; parts are optional.</span>
  751 |     | <span class='neutral'>    /// Additionally accepts abi-encoded constructor arguments and `msg.value`.</span>
  752 |     | <span class='neutral'>    function deployCode(string calldata artifactPath, bytes calldata constructorArgs, uint256 value)</span>
  753 |     | <span class='neutral'>        external</span>
  754 |     | <span class='neutral'>        returns (address deployedAddress);</span>
  755 |     | <span class='neutral'></span>
  756 |     | <span class='neutral'>    /// Deploys a contract from an artifact file, using the CREATE2 salt. Takes in the relative path to the json file or the path to the</span>
  757 |     | <span class='neutral'>    /// artifact in the form of &lt;path&gt;:&lt;contract&gt;:&lt;version&gt; where &lt;contract&gt; and &lt;version&gt; parts are optional.</span>
  758 |     | <span class='neutral'>    function deployCode(string calldata artifactPath, bytes32 salt) external returns (address deployedAddress);</span>
  759 |     | <span class='neutral'></span>
  760 |     | <span class='neutral'>    /// Deploys a contract from an artifact file, using the CREATE2 salt. Takes in the relative path to the json file or the path to the</span>
  761 |     | <span class='neutral'>    /// artifact in the form of &lt;path&gt;:&lt;contract&gt;:&lt;version&gt; where &lt;contract&gt; and &lt;version&gt; parts are optional.</span>
  762 |     | <span class='neutral'>    /// Additionally accepts abi-encoded constructor arguments.</span>
  763 |     | <span class='neutral'>    function deployCode(string calldata artifactPath, bytes calldata constructorArgs, bytes32 salt)</span>
  764 |     | <span class='neutral'>        external</span>
  765 |     | <span class='neutral'>        returns (address deployedAddress);</span>
  766 |     | <span class='neutral'></span>
  767 |     | <span class='neutral'>    /// Deploys a contract from an artifact file, using the CREATE2 salt. Takes in the relative path to the json file or the path to the</span>
  768 |     | <span class='neutral'>    /// artifact in the form of &lt;path&gt;:&lt;contract&gt;:&lt;version&gt; where &lt;contract&gt; and &lt;version&gt; parts are optional.</span>
  769 |     | <span class='neutral'>    /// Additionally accepts `msg.value`.</span>
  770 |     | <span class='neutral'>    function deployCode(string calldata artifactPath, uint256 value, bytes32 salt)</span>
  771 |     | <span class='neutral'>        external</span>
  772 |     | <span class='neutral'>        returns (address deployedAddress);</span>
  773 |     | <span class='neutral'></span>
  774 |     | <span class='neutral'>    /// Deploys a contract from an artifact file, using the CREATE2 salt. Takes in the relative path to the json file or the path to the</span>
  775 |     | <span class='neutral'>    /// artifact in the form of &lt;path&gt;:&lt;contract&gt;:&lt;version&gt; where &lt;contract&gt; and &lt;version&gt; parts are optional.</span>
  776 |     | <span class='neutral'>    /// Additionally accepts abi-encoded constructor arguments and `msg.value`.</span>
  777 |     | <span class='neutral'>    function deployCode(string calldata artifactPath, bytes calldata constructorArgs, uint256 value, bytes32 salt)</span>
  778 |     | <span class='neutral'>        external</span>
  779 |     | <span class='neutral'>        returns (address deployedAddress);</span>
  780 |     | <span class='neutral'></span>
  781 |     | <span class='neutral'>    /// Returns true if the given path points to an existing entity, else returns false.</span>
  782 |     | <span class='neutral'>    function exists(string calldata path) external view returns (bool result);</span>
  783 |     | <span class='neutral'></span>
  784 |     | <span class='neutral'>    /// Performs a foreign function call via the terminal.</span>
  785 |     | <span class='neutral'>    function ffi(string[] calldata commandInput) external returns (bytes memory result);</span>
  786 |     | <span class='neutral'></span>
  787 |     | <span class='neutral'>    /// Given a path, query the file system to get information about a file, directory, etc.</span>
  788 |     | <span class='neutral'>    function fsMetadata(string calldata path) external view returns (FsMetadata memory metadata);</span>
  789 |     | <span class='neutral'></span>
  790 |     | <span class='neutral'>    /// Gets the artifact path from code (aka. creation code).</span>
  791 |     | <span class='neutral'>    function getArtifactPathByCode(bytes calldata code) external view returns (string memory path);</span>
  792 |     | <span class='neutral'></span>
  793 |     | <span class='neutral'>    /// Gets the artifact path from deployed code (aka. runtime code).</span>
  794 |     | <span class='neutral'>    function getArtifactPathByDeployedCode(bytes calldata deployedCode) external view returns (string memory path);</span>
  795 |     | <span class='neutral'></span>
  796 |     | <span class='neutral'>    /// Returns the most recent broadcast for the given contract on `chainId` matching `txType`.</span>
  797 |     | <span class='neutral'>    /// For example:</span>
  798 |     | <span class='neutral'>    /// The most recent deployment can be fetched by passing `txType` as `CREATE` or `CREATE2`.</span>
  799 |     | <span class='neutral'>    /// The most recent call can be fetched by passing `txType` as `CALL`.</span>
  800 |     | <span class='neutral'>    function getBroadcast(string calldata contractName, uint64 chainId, BroadcastTxType txType)</span>
  801 |     | <span class='neutral'>        external</span>
  802 |     | <span class='neutral'>        view</span>
  803 |     | <span class='neutral'>        returns (BroadcastTxSummary memory);</span>
  804 |     | <span class='neutral'></span>
  805 |     | <span class='neutral'>    /// Returns all broadcasts for the given contract on `chainId` with the specified `txType`.</span>
  806 |     | <span class='neutral'>    /// Sorted such that the most recent broadcast is the first element, and the oldest is the last. i.e descending order of BroadcastTxSummary.blockNumber.</span>
  807 |     | <span class='neutral'>    function getBroadcasts(string calldata contractName, uint64 chainId, BroadcastTxType txType)</span>
  808 |     | <span class='neutral'>        external</span>
  809 |     | <span class='neutral'>        view</span>
  810 |     | <span class='neutral'>        returns (BroadcastTxSummary[] memory);</span>
  811 |     | <span class='neutral'></span>
  812 |     | <span class='neutral'>    /// Returns all broadcasts for the given contract on `chainId`.</span>
  813 |     | <span class='neutral'>    /// Sorted such that the most recent broadcast is the first element, and the oldest is the last. i.e descending order of BroadcastTxSummary.blockNumber.</span>
  814 |     | <span class='neutral'>    function getBroadcasts(string calldata contractName, uint64 chainId)</span>
  815 |     | <span class='neutral'>        external</span>
  816 |     | <span class='neutral'>        view</span>
  817 |     | <span class='neutral'>        returns (BroadcastTxSummary[] memory);</span>
  818 |     | <span class='neutral'></span>
  819 |     | <span class='neutral'>    /// Gets the creation bytecode from an artifact file. Takes in the relative path to the json file or the path to the</span>
  820 |     | <span class='neutral'>    /// artifact in the form of &lt;path&gt;:&lt;contract&gt;:&lt;version&gt; where &lt;contract&gt; and &lt;version&gt; parts are optional.</span>
  821 |     | <span class='neutral'>    function getCode(string calldata artifactPath) external view returns (bytes memory creationBytecode);</span>
  822 |     | <span class='neutral'></span>
  823 |     | <span class='neutral'>    /// Gets the deployed bytecode from an artifact file. Takes in the relative path to the json file or the path to the</span>
  824 |     | <span class='neutral'>    /// artifact in the form of &lt;path&gt;:&lt;contract&gt;:&lt;version&gt; where &lt;contract&gt; and &lt;version&gt; parts are optional.</span>
  825 |     | <span class='neutral'>    function getDeployedCode(string calldata artifactPath) external view returns (bytes memory runtimeBytecode);</span>
  826 |     | <span class='neutral'></span>
  827 |     | <span class='neutral'>    /// Returns the most recent deployment for the current `chainId`.</span>
  828 |     | <span class='neutral'>    function getDeployment(string calldata contractName) external view returns (address deployedAddress);</span>
  829 |     | <span class='neutral'></span>
  830 |     | <span class='neutral'>    /// Returns the most recent deployment for the given contract on `chainId`</span>
  831 |     | <span class='neutral'>    function getDeployment(string calldata contractName, uint64 chainId)</span>
  832 |     | <span class='neutral'>        external</span>
  833 |     | <span class='neutral'>        view</span>
  834 |     | <span class='neutral'>        returns (address deployedAddress);</span>
  835 |     | <span class='neutral'></span>
  836 |     | <span class='neutral'>    /// Returns all deployments for the given contract on `chainId`</span>
  837 |     | <span class='neutral'>    /// Sorted in descending order of deployment time i.e descending order of BroadcastTxSummary.blockNumber.</span>
  838 |     | <span class='neutral'>    /// The most recent deployment is the first element, and the oldest is the last.</span>
  839 |     | <span class='neutral'>    function getDeployments(string calldata contractName, uint64 chainId)</span>
  840 |     | <span class='neutral'>        external</span>
  841 |     | <span class='neutral'>        view</span>
  842 |     | <span class='neutral'>        returns (address[] memory deployedAddresses);</span>
  843 |     | <span class='neutral'></span>
  844 |     | <span class='neutral'>    /// Returns true if the path exists on disk and is pointing at a directory, else returns false.</span>
  845 |     | <span class='neutral'>    function isDir(string calldata path) external view returns (bool result);</span>
  846 |     | <span class='neutral'></span>
  847 |     | <span class='neutral'>    /// Returns true if the path exists on disk and is pointing at a regular file, else returns false.</span>
  848 |     | <span class='neutral'>    function isFile(string calldata path) external view returns (bool result);</span>
  849 |     | <span class='neutral'></span>
  850 |     | <span class='neutral'>    /// Get the path of the current project root.</span>
  851 |     | <span class='neutral'>    function projectRoot() external view returns (string memory path);</span>
  852 |     | <span class='neutral'></span>
  853 |     | <span class='neutral'>    /// Prompts the user for a string value in the terminal.</span>
  854 |     | <span class='neutral'>    function prompt(string calldata promptText) external returns (string memory input);</span>
  855 |     | <span class='neutral'></span>
  856 |     | <span class='neutral'>    /// Prompts the user for an address in the terminal.</span>
  857 |     | <span class='neutral'>    function promptAddress(string calldata promptText) external returns (address);</span>
  858 |     | <span class='neutral'></span>
  859 |     | <span class='neutral'>    /// Prompts the user for a hidden string value in the terminal.</span>
  860 |     | <span class='neutral'>    function promptSecret(string calldata promptText) external returns (string memory input);</span>
  861 |     | <span class='neutral'></span>
  862 |     | <span class='neutral'>    /// Prompts the user for hidden uint256 in the terminal (usually pk).</span>
  863 |     | <span class='neutral'>    function promptSecretUint(string calldata promptText) external returns (uint256);</span>
  864 |     | <span class='neutral'></span>
  865 |     | <span class='neutral'>    /// Prompts the user for uint256 in the terminal.</span>
  866 |     | <span class='neutral'>    function promptUint(string calldata promptText) external returns (uint256);</span>
  867 |     | <span class='neutral'></span>
  868 |     | <span class='neutral'>    /// Reads the directory at the given path recursively, up to `maxDepth`.</span>
  869 |     | <span class='neutral'>    /// `maxDepth` defaults to 1, meaning only the direct children of the given directory will be returned.</span>
  870 |     | <span class='neutral'>    /// Follows symbolic links if `followLinks` is true.</span>
  871 |     | <span class='neutral'>    function readDir(string calldata path) external view returns (DirEntry[] memory entries);</span>
  872 |     | <span class='neutral'></span>
  873 |     | <span class='neutral'>    /// See `readDir(string)`.</span>
  874 |     | <span class='neutral'>    function readDir(string calldata path, uint64 maxDepth) external view returns (DirEntry[] memory entries);</span>
  875 |     | <span class='neutral'></span>
  876 |     | <span class='neutral'>    /// See `readDir(string)`.</span>
  877 |     | <span class='neutral'>    function readDir(string calldata path, uint64 maxDepth, bool followLinks)</span>
  878 |     | <span class='neutral'>        external</span>
  879 |     | <span class='neutral'>        view</span>
  880 |     | <span class='neutral'>        returns (DirEntry[] memory entries);</span>
  881 |     | <span class='neutral'></span>
  882 |     | <span class='neutral'>    /// Reads the entire content of file to string. `path` is relative to the project root.</span>
  883 |     | <span class='neutral'>    function readFile(string calldata path) external view returns (string memory data);</span>
  884 |     | <span class='neutral'></span>
  885 |     | <span class='neutral'>    /// Reads the entire content of file as binary. `path` is relative to the project root.</span>
  886 |     | <span class='neutral'>    function readFileBinary(string calldata path) external view returns (bytes memory data);</span>
  887 |     | <span class='neutral'></span>
  888 |     | <span class='neutral'>    /// Reads next line of file to string.</span>
  889 |     | <span class='neutral'>    function readLine(string calldata path) external view returns (string memory line);</span>
  890 |     | <span class='neutral'></span>
  891 |     | <span class='neutral'>    /// Reads a symbolic link, returning the path that the link points to.</span>
  892 |     | <span class='neutral'>    /// This cheatcode will revert in the following situations, but is not limited to just these cases:</span>
  893 |     | <span class='neutral'>    /// - `path` is not a symbolic link.</span>
  894 |     | <span class='neutral'>    /// - `path` does not exist.</span>
  895 |     | <span class='neutral'>    function readLink(string calldata linkPath) external view returns (string memory targetPath);</span>
  896 |     | <span class='neutral'></span>
  897 |     | <span class='neutral'>    /// Removes a directory at the provided path.</span>
  898 |     | <span class='neutral'>    /// This cheatcode will revert in the following situations, but is not limited to just these cases:</span>
  899 |     | <span class='neutral'>    /// - `path` doesn&#39;t exist.</span>
  900 |     | <span class='neutral'>    /// - `path` isn&#39;t a directory.</span>
  901 |     | <span class='neutral'>    /// - User lacks permissions to modify `path`.</span>
  902 |     | <span class='neutral'>    /// - The directory is not empty and `recursive` is false.</span>
  903 |     | <span class='neutral'>    /// `path` is relative to the project root.</span>
  904 |     | <span class='neutral'>    function removeDir(string calldata path, bool recursive) external;</span>
  905 |     | <span class='neutral'></span>
  906 |     | <span class='neutral'>    /// Removes a file from the filesystem.</span>
  907 |     | <span class='neutral'>    /// This cheatcode will revert in the following situations, but is not limited to just these cases:</span>
  908 |     | <span class='neutral'>    /// - `path` points to a directory.</span>
  909 |     | <span class='neutral'>    /// - The file doesn&#39;t exist.</span>
  910 |     | <span class='neutral'>    /// - The user lacks permissions to remove the file.</span>
  911 |     | <span class='neutral'>    /// `path` is relative to the project root.</span>
  912 |     | <span class='neutral'>    function removeFile(string calldata path) external;</span>
  913 |     | <span class='neutral'></span>
  914 |     | <span class='neutral'>    /// Performs a foreign function call via terminal and returns the exit code, stdout, and stderr.</span>
  915 |     | <span class='neutral'>    function tryFfi(string[] calldata commandInput) external returns (FfiResult memory result);</span>
  916 |     | <span class='neutral'></span>
  917 |     | <span class='neutral'>    /// Returns the time since unix epoch in milliseconds.</span>
  918 |     | <span class='neutral'>    function unixTime() external view returns (uint256 milliseconds);</span>
  919 |     | <span class='neutral'></span>
  920 |     | <span class='neutral'>    /// Writes data to file, creating a file if it does not exist, and entirely replacing its contents if it does.</span>
  921 |     | <span class='neutral'>    /// `path` is relative to the project root.</span>
  922 |     | <span class='neutral'>    function writeFile(string calldata path, string calldata data) external;</span>
  923 |     | <span class='neutral'></span>
  924 |     | <span class='neutral'>    /// Writes binary data to a file, creating a file if it does not exist, and entirely replacing its contents if it does.</span>
  925 |     | <span class='neutral'>    /// `path` is relative to the project root.</span>
  926 |     | <span class='neutral'>    function writeFileBinary(string calldata path, bytes calldata data) external;</span>
  927 |     | <span class='neutral'></span>
  928 |     | <span class='neutral'>    /// Writes line to file, creating a file if it does not exist.</span>
  929 |     | <span class='neutral'>    /// `path` is relative to the project root.</span>
  930 |     | <span class='neutral'>    function writeLine(string calldata path, string calldata data) external;</span>
  931 |     | <span class='neutral'></span>
  932 |     | <span class='neutral'>    // ======== JSON ========</span>
  933 |     | <span class='neutral'></span>
  934 |     | <span class='neutral'>    /// Checks if `key` exists in a JSON object.</span>
  935 |     | <span class='neutral'>    function keyExistsJson(string calldata json, string calldata key) external view returns (bool);</span>
  936 |     | <span class='neutral'></span>
  937 |     | <span class='neutral'>    /// Parses a string of JSON data at `key` and coerces it to `address`.</span>
  938 |     | <span class='neutral'>    function parseJsonAddress(string calldata json, string calldata key) external pure returns (address);</span>
  939 |     | <span class='neutral'></span>
  940 |     | <span class='neutral'>    /// Parses a string of JSON data at `key` and coerces it to `address[]`.</span>
  941 |     | <span class='neutral'>    function parseJsonAddressArray(string calldata json, string calldata key)</span>
  942 |     | <span class='neutral'>        external</span>
  943 |     | <span class='neutral'>        pure</span>
  944 |     | <span class='neutral'>        returns (address[] memory);</span>
  945 |     | <span class='neutral'></span>
  946 |     | <span class='neutral'>    /// Parses a string of JSON data at `key` and coerces it to `bool`.</span>
  947 |     | <span class='neutral'>    function parseJsonBool(string calldata json, string calldata key) external pure returns (bool);</span>
  948 |     | <span class='neutral'></span>
  949 |     | <span class='neutral'>    /// Parses a string of JSON data at `key` and coerces it to `bool[]`.</span>
  950 |     | <span class='neutral'>    function parseJsonBoolArray(string calldata json, string calldata key) external pure returns (bool[] memory);</span>
  951 |     | <span class='neutral'></span>
  952 |     | <span class='neutral'>    /// Parses a string of JSON data at `key` and coerces it to `bytes`.</span>
  953 |     | <span class='neutral'>    function parseJsonBytes(string calldata json, string calldata key) external pure returns (bytes memory);</span>
  954 |     | <span class='neutral'></span>
  955 |     | <span class='neutral'>    /// Parses a string of JSON data at `key` and coerces it to `bytes32`.</span>
  956 |     | <span class='neutral'>    function parseJsonBytes32(string calldata json, string calldata key) external pure returns (bytes32);</span>
  957 |     | <span class='neutral'></span>
  958 |     | <span class='neutral'>    /// Parses a string of JSON data at `key` and coerces it to `bytes32[]`.</span>
  959 |     | <span class='neutral'>    function parseJsonBytes32Array(string calldata json, string calldata key)</span>
  960 |     | <span class='neutral'>        external</span>
  961 |     | <span class='neutral'>        pure</span>
  962 |     | <span class='neutral'>        returns (bytes32[] memory);</span>
  963 |     | <span class='neutral'></span>
  964 |     | <span class='neutral'>    /// Parses a string of JSON data at `key` and coerces it to `bytes[]`.</span>
  965 |     | <span class='neutral'>    function parseJsonBytesArray(string calldata json, string calldata key) external pure returns (bytes[] memory);</span>
  966 |     | <span class='neutral'></span>
  967 |     | <span class='neutral'>    /// Parses a string of JSON data at `key` and coerces it to `int256`.</span>
  968 |     | <span class='neutral'>    function parseJsonInt(string calldata json, string calldata key) external pure returns (int256);</span>
  969 |     | <span class='neutral'></span>
  970 |     | <span class='neutral'>    /// Parses a string of JSON data at `key` and coerces it to `int256[]`.</span>
  971 |     | <span class='neutral'>    function parseJsonIntArray(string calldata json, string calldata key) external pure returns (int256[] memory);</span>
  972 |     | <span class='neutral'></span>
  973 |     | <span class='neutral'>    /// Returns an array of all the keys in a JSON object.</span>
  974 |     | <span class='neutral'>    function parseJsonKeys(string calldata json, string calldata key) external pure returns (string[] memory keys);</span>
  975 |     | <span class='neutral'></span>
  976 |     | <span class='neutral'>    /// Parses a string of JSON data at `key` and coerces it to `string`.</span>
  977 |     | <span class='neutral'>    function parseJsonString(string calldata json, string calldata key) external pure returns (string memory);</span>
  978 |     | <span class='neutral'></span>
  979 |     | <span class='neutral'>    /// Parses a string of JSON data at `key` and coerces it to `string[]`.</span>
  980 |     | <span class='neutral'>    function parseJsonStringArray(string calldata json, string calldata key) external pure returns (string[] memory);</span>
  981 |     | <span class='neutral'></span>
  982 |     | <span class='neutral'>    /// Parses a string of JSON data at `key` and coerces it to type array corresponding to `typeDescription`.</span>
  983 |     | <span class='neutral'>    function parseJsonTypeArray(string calldata json, string calldata key, string calldata typeDescription)</span>
  984 |     | <span class='neutral'>        external</span>
  985 |     | <span class='neutral'>        pure</span>
  986 |     | <span class='neutral'>        returns (bytes memory);</span>
  987 |     | <span class='neutral'></span>
  988 |     | <span class='neutral'>    /// Parses a string of JSON data and coerces it to type corresponding to `typeDescription`.</span>
  989 |     | <span class='neutral'>    function parseJsonType(string calldata json, string calldata typeDescription)</span>
  990 |     | <span class='neutral'>        external</span>
  991 |     | <span class='neutral'>        pure</span>
  992 |     | <span class='neutral'>        returns (bytes memory);</span>
  993 |     | <span class='neutral'></span>
  994 |     | <span class='neutral'>    /// Parses a string of JSON data at `key` and coerces it to type corresponding to `typeDescription`.</span>
  995 |     | <span class='neutral'>    function parseJsonType(string calldata json, string calldata key, string calldata typeDescription)</span>
  996 |     | <span class='neutral'>        external</span>
  997 |     | <span class='neutral'>        pure</span>
  998 |     | <span class='neutral'>        returns (bytes memory);</span>
  999 |     | <span class='neutral'></span>
 1000 |     | <span class='neutral'>    /// Parses a string of JSON data at `key` and coerces it to `uint256`.</span>
 1001 |     | <span class='neutral'>    function parseJsonUint(string calldata json, string calldata key) external pure returns (uint256);</span>
 1002 |     | <span class='neutral'></span>
 1003 |     | <span class='neutral'>    /// Parses a string of JSON data at `key` and coerces it to `uint256[]`.</span>
 1004 |     | <span class='neutral'>    function parseJsonUintArray(string calldata json, string calldata key) external pure returns (uint256[] memory);</span>
 1005 |     | <span class='neutral'></span>
 1006 |     | <span class='neutral'>    /// ABI-encodes a JSON object.</span>
 1007 |     | <span class='neutral'>    function parseJson(string calldata json) external pure returns (bytes memory abiEncodedData);</span>
 1008 |     | <span class='neutral'></span>
 1009 |     | <span class='neutral'>    /// ABI-encodes a JSON object at `key`.</span>
 1010 |     | <span class='neutral'>    function parseJson(string calldata json, string calldata key) external pure returns (bytes memory abiEncodedData);</span>
 1011 |     | <span class='neutral'></span>
 1012 |     | <span class='neutral'>    /// See `serializeJson`.</span>
 1013 |     | <span class='neutral'>    function serializeAddress(string calldata objectKey, string calldata valueKey, address value)</span>
 1014 |     | <span class='neutral'>        external</span>
 1015 |     | <span class='neutral'>        returns (string memory json);</span>
 1016 |     | <span class='neutral'></span>
 1017 |     | <span class='neutral'>    /// See `serializeJson`.</span>
 1018 |     | <span class='neutral'>    function serializeAddress(string calldata objectKey, string calldata valueKey, address[] calldata values)</span>
 1019 |     | <span class='neutral'>        external</span>
 1020 |     | <span class='neutral'>        returns (string memory json);</span>
 1021 |     | <span class='neutral'></span>
 1022 |     | <span class='neutral'>    /// See `serializeJson`.</span>
 1023 |     | <span class='neutral'>    function serializeBool(string calldata objectKey, string calldata valueKey, bool value)</span>
 1024 |     | <span class='neutral'>        external</span>
 1025 |     | <span class='neutral'>        returns (string memory json);</span>
 1026 |     | <span class='neutral'></span>
 1027 |     | <span class='neutral'>    /// See `serializeJson`.</span>
 1028 |     | <span class='neutral'>    function serializeBool(string calldata objectKey, string calldata valueKey, bool[] calldata values)</span>
 1029 |     | <span class='neutral'>        external</span>
 1030 |     | <span class='neutral'>        returns (string memory json);</span>
 1031 |     | <span class='neutral'></span>
 1032 |     | <span class='neutral'>    /// See `serializeJson`.</span>
 1033 |     | <span class='neutral'>    function serializeBytes32(string calldata objectKey, string calldata valueKey, bytes32 value)</span>
 1034 |     | <span class='neutral'>        external</span>
 1035 |     | <span class='neutral'>        returns (string memory json);</span>
 1036 |     | <span class='neutral'></span>
 1037 |     | <span class='neutral'>    /// See `serializeJson`.</span>
 1038 |     | <span class='neutral'>    function serializeBytes32(string calldata objectKey, string calldata valueKey, bytes32[] calldata values)</span>
 1039 |     | <span class='neutral'>        external</span>
 1040 |     | <span class='neutral'>        returns (string memory json);</span>
 1041 |     | <span class='neutral'></span>
 1042 |     | <span class='neutral'>    /// See `serializeJson`.</span>
 1043 |     | <span class='neutral'>    function serializeBytes(string calldata objectKey, string calldata valueKey, bytes calldata value)</span>
 1044 |     | <span class='neutral'>        external</span>
 1045 |     | <span class='neutral'>        returns (string memory json);</span>
 1046 |     | <span class='neutral'></span>
 1047 |     | <span class='neutral'>    /// See `serializeJson`.</span>
 1048 |     | <span class='neutral'>    function serializeBytes(string calldata objectKey, string calldata valueKey, bytes[] calldata values)</span>
 1049 |     | <span class='neutral'>        external</span>
 1050 |     | <span class='neutral'>        returns (string memory json);</span>
 1051 |     | <span class='neutral'></span>
 1052 |     | <span class='neutral'>    /// See `serializeJson`.</span>
 1053 |     | <span class='neutral'>    function serializeInt(string calldata objectKey, string calldata valueKey, int256 value)</span>
 1054 |     | <span class='neutral'>        external</span>
 1055 |     | <span class='neutral'>        returns (string memory json);</span>
 1056 |     | <span class='neutral'></span>
 1057 |     | <span class='neutral'>    /// See `serializeJson`.</span>
 1058 |     | <span class='neutral'>    function serializeInt(string calldata objectKey, string calldata valueKey, int256[] calldata values)</span>
 1059 |     | <span class='neutral'>        external</span>
 1060 |     | <span class='neutral'>        returns (string memory json);</span>
 1061 |     | <span class='neutral'></span>
 1062 |     | <span class='neutral'>    /// Serializes a key and value to a JSON object stored in-memory that can be later written to a file.</span>
 1063 |     | <span class='neutral'>    /// Returns the stringified version of the specific JSON file up to that moment.</span>
 1064 |     | <span class='neutral'>    function serializeJson(string calldata objectKey, string calldata value) external returns (string memory json);</span>
 1065 |     | <span class='neutral'></span>
 1066 |     | <span class='neutral'>    /// See `serializeJson`.</span>
 1067 |     | <span class='neutral'>    function serializeJsonType(string calldata typeDescription, bytes calldata value)</span>
 1068 |     | <span class='neutral'>        external</span>
 1069 |     | <span class='neutral'>        pure</span>
 1070 |     | <span class='neutral'>        returns (string memory json);</span>
 1071 |     | <span class='neutral'></span>
 1072 |     | <span class='neutral'>    /// See `serializeJson`.</span>
 1073 |     | <span class='neutral'>    function serializeJsonType(</span>
 1074 |     | <span class='neutral'>        string calldata objectKey,</span>
 1075 |     | <span class='neutral'>        string calldata valueKey,</span>
 1076 |     | <span class='neutral'>        string calldata typeDescription,</span>
 1077 |     | <span class='neutral'>        bytes calldata value</span>
 1078 |     | <span class='neutral'>    ) external returns (string memory json);</span>
 1079 |     | <span class='neutral'></span>
 1080 |     | <span class='neutral'>    /// See `serializeJson`.</span>
 1081 |     | <span class='neutral'>    function serializeString(string calldata objectKey, string calldata valueKey, string calldata value)</span>
 1082 |     | <span class='neutral'>        external</span>
 1083 |     | <span class='neutral'>        returns (string memory json);</span>
 1084 |     | <span class='neutral'></span>
 1085 |     | <span class='neutral'>    /// See `serializeJson`.</span>
 1086 |     | <span class='neutral'>    function serializeString(string calldata objectKey, string calldata valueKey, string[] calldata values)</span>
 1087 |     | <span class='neutral'>        external</span>
 1088 |     | <span class='neutral'>        returns (string memory json);</span>
 1089 |     | <span class='neutral'></span>
 1090 |     | <span class='neutral'>    /// See `serializeJson`.</span>
 1091 |     | <span class='neutral'>    function serializeUintToHex(string calldata objectKey, string calldata valueKey, uint256 value)</span>
 1092 |     | <span class='neutral'>        external</span>
 1093 |     | <span class='neutral'>        returns (string memory json);</span>
 1094 |     | <span class='neutral'></span>
 1095 |     | <span class='neutral'>    /// See `serializeJson`.</span>
 1096 |     | <span class='neutral'>    function serializeUint(string calldata objectKey, string calldata valueKey, uint256 value)</span>
 1097 |     | <span class='neutral'>        external</span>
 1098 |     | <span class='neutral'>        returns (string memory json);</span>
 1099 |     | <span class='neutral'></span>
 1100 |     | <span class='neutral'>    /// See `serializeJson`.</span>
 1101 |     | <span class='neutral'>    function serializeUint(string calldata objectKey, string calldata valueKey, uint256[] calldata values)</span>
 1102 |     | <span class='neutral'>        external</span>
 1103 |     | <span class='neutral'>        returns (string memory json);</span>
 1104 |     | <span class='neutral'></span>
 1105 |     | <span class='neutral'>    /// Write a serialized JSON object to a file. If the file exists, it will be overwritten.</span>
 1106 |     | <span class='neutral'>    function writeJson(string calldata json, string calldata path) external;</span>
 1107 |     | <span class='neutral'></span>
 1108 |     | <span class='neutral'>    /// Write a serialized JSON object to an **existing** JSON file, replacing a value with key = &lt;value_key.&gt;</span>
 1109 |     | <span class='neutral'>    /// This is useful to replace a specific value of a JSON file, without having to parse the entire thing.</span>
 1110 |     | <span class='neutral'>    function writeJson(string calldata json, string calldata path, string calldata valueKey) external;</span>
 1111 |     | <span class='neutral'></span>
 1112 |     | <span class='neutral'>    /// Checks if `key` exists in a JSON object</span>
 1113 |     | <span class='neutral'>    /// `keyExists` is being deprecated in favor of `keyExistsJson`. It will be removed in future versions.</span>
 1114 |     | <span class='neutral'>    function keyExists(string calldata json, string calldata key) external view returns (bool);</span>
 1115 |     | <span class='neutral'></span>
 1116 |     | <span class='neutral'>    // ======== Scripting ========</span>
 1117 |     | <span class='neutral'></span>
 1118 |     | <span class='neutral'>    /// Attach an EIP-4844 blob to the next call</span>
 1119 |     | <span class='neutral'>    function attachBlob(bytes calldata blob) external;</span>
 1120 |     | <span class='neutral'></span>
 1121 |     | <span class='neutral'>    /// Designate the next call as an EIP-7702 transaction</span>
 1122 |     | <span class='neutral'>    function attachDelegation(SignedDelegation calldata signedDelegation) external;</span>
 1123 |     | <span class='neutral'></span>
 1124 |     | <span class='neutral'>    /// Designate the next call as an EIP-7702 transaction, with optional cross-chain validity.</span>
 1125 |     | <span class='neutral'>    function attachDelegation(SignedDelegation calldata signedDelegation, bool crossChain) external;</span>
 1126 |     | <span class='neutral'></span>
 1127 |     | <span class='neutral'>    /// Takes a signed transaction and broadcasts it to the network.</span>
 1128 |     | <span class='neutral'>    function broadcastRawTransaction(bytes calldata data) external;</span>
 1129 |     | <span class='neutral'></span>
 1130 |     | <span class='neutral'>    /// Has the next call (at this call depth only) create transactions that can later be signed and sent onchain.</span>
 1131 |     | <span class='neutral'>    /// Broadcasting address is determined by checking the following in order:</span>
 1132 |     | <span class='neutral'>    /// 1. If `--sender` argument was provided, that address is used.</span>
 1133 |     | <span class='neutral'>    /// 2. If exactly one signer (e.g. private key, hw wallet, keystore) is set when `forge broadcast` is invoked, that signer is used.</span>
 1134 |     | <span class='neutral'>    /// 3. Otherwise, default foundry sender (1804c8AB1F12E6bbf3894d4083f33e07309d1f38) is used.</span>
 1135 |     | <span class='neutral'>    function broadcast() external;</span>
 1136 |     | <span class='neutral'></span>
 1137 |     | <span class='neutral'>    /// Has the next call (at this call depth only) create a transaction with the address provided</span>
 1138 |     | <span class='neutral'>    /// as the sender that can later be signed and sent onchain.</span>
 1139 |     | <span class='neutral'>    function broadcast(address signer) external;</span>
 1140 |     | <span class='neutral'></span>
 1141 |     | <span class='neutral'>    /// Has the next call (at this call depth only) create a transaction with the private key</span>
 1142 |     | <span class='neutral'>    /// provided as the sender that can later be signed and sent onchain.</span>
 1143 |     | <span class='neutral'>    function broadcast(uint256 privateKey) external;</span>
 1144 |     | <span class='neutral'></span>
 1145 |     | <span class='neutral'>    /// Returns addresses of available unlocked wallets in the script environment.</span>
 1146 |     | <span class='neutral'>    function getWallets() external returns (address[] memory wallets);</span>
 1147 |     | <span class='neutral'></span>
 1148 |     | <span class='neutral'>    /// Sign an EIP-7702 authorization and designate the next call as an EIP-7702 transaction</span>
 1149 |     | <span class='neutral'>    function signAndAttachDelegation(address implementation, uint256 privateKey)</span>
 1150 |     | <span class='neutral'>        external</span>
 1151 |     | <span class='neutral'>        returns (SignedDelegation memory signedDelegation);</span>
 1152 |     | <span class='neutral'></span>
 1153 |     | <span class='neutral'>    /// Sign an EIP-7702 authorization and designate the next call as an EIP-7702 transaction for specific nonce</span>
 1154 |     | <span class='neutral'>    function signAndAttachDelegation(address implementation, uint256 privateKey, uint64 nonce)</span>
 1155 |     | <span class='neutral'>        external</span>
 1156 |     | <span class='neutral'>        returns (SignedDelegation memory signedDelegation);</span>
 1157 |     | <span class='neutral'></span>
 1158 |     | <span class='neutral'>    /// Sign an EIP-7702 authorization and designate the next call as an EIP-7702 transaction, with optional cross-chain validity.</span>
 1159 |     | <span class='neutral'>    function signAndAttachDelegation(address implementation, uint256 privateKey, bool crossChain)</span>
 1160 |     | <span class='neutral'>        external</span>
 1161 |     | <span class='neutral'>        returns (SignedDelegation memory signedDelegation);</span>
 1162 |     | <span class='neutral'></span>
 1163 |     | <span class='neutral'>    /// Sign an EIP-7702 authorization for delegation</span>
 1164 |     | <span class='neutral'>    function signDelegation(address implementation, uint256 privateKey)</span>
 1165 |     | <span class='neutral'>        external</span>
 1166 |     | <span class='neutral'>        returns (SignedDelegation memory signedDelegation);</span>
 1167 |     | <span class='neutral'></span>
 1168 |     | <span class='neutral'>    /// Sign an EIP-7702 authorization for delegation for specific nonce</span>
 1169 |     | <span class='neutral'>    function signDelegation(address implementation, uint256 privateKey, uint64 nonce)</span>
 1170 |     | <span class='neutral'>        external</span>
 1171 |     | <span class='neutral'>        returns (SignedDelegation memory signedDelegation);</span>
 1172 |     | <span class='neutral'></span>
 1173 |     | <span class='neutral'>    /// Sign an EIP-7702 authorization for delegation, with optional cross-chain validity.</span>
 1174 |     | <span class='neutral'>    function signDelegation(address implementation, uint256 privateKey, bool crossChain)</span>
 1175 |     | <span class='neutral'>        external</span>
 1176 |     | <span class='neutral'>        returns (SignedDelegation memory signedDelegation);</span>
 1177 |     | <span class='neutral'></span>
 1178 |     | <span class='neutral'>    /// Has all subsequent calls (at this call depth only) create transactions that can later be signed and sent onchain.</span>
 1179 |     | <span class='neutral'>    /// Broadcasting address is determined by checking the following in order:</span>
 1180 |     | <span class='neutral'>    /// 1. If `--sender` argument was provided, that address is used.</span>
 1181 |     | <span class='neutral'>    /// 2. If exactly one signer (e.g. private key, hw wallet, keystore) is set when `forge broadcast` is invoked, that signer is used.</span>
 1182 |     | <span class='neutral'>    /// 3. Otherwise, default foundry sender (1804c8AB1F12E6bbf3894d4083f33e07309d1f38) is used.</span>
 1183 |     | <span class='neutral'>    function startBroadcast() external;</span>
 1184 |     | <span class='neutral'></span>
 1185 |     | <span class='neutral'>    /// Has all subsequent calls (at this call depth only) create transactions with the address</span>
 1186 |     | <span class='neutral'>    /// provided that can later be signed and sent onchain.</span>
 1187 |     | <span class='neutral'>    function startBroadcast(address signer) external;</span>
 1188 |     | <span class='neutral'></span>
 1189 |     | <span class='neutral'>    /// Has all subsequent calls (at this call depth only) create transactions with the private key</span>
 1190 |     | <span class='neutral'>    /// provided that can later be signed and sent onchain.</span>
 1191 |     | <span class='neutral'>    function startBroadcast(uint256 privateKey) external;</span>
 1192 |     | <span class='neutral'></span>
 1193 |     | <span class='neutral'>    /// Stops collecting onchain transactions.</span>
 1194 |     | <span class='neutral'>    function stopBroadcast() external;</span>
 1195 |     | <span class='neutral'></span>
 1196 |     | <span class='neutral'>    // ======== String ========</span>
 1197 |     | <span class='neutral'></span>
 1198 |     | <span class='neutral'>    /// Returns true if `search` is found in `subject`, false otherwise.</span>
 1199 |     | <span class='neutral'>    function contains(string calldata subject, string calldata search) external returns (bool result);</span>
 1200 |     | <span class='neutral'></span>
 1201 |     | <span class='neutral'>    /// Returns the index of the first occurrence of a `key` in an `input` string.</span>
 1202 |     | <span class='neutral'>    /// Returns `NOT_FOUND` (i.e. `type(uint256).max`) if the `key` is not found.</span>
 1203 |     | <span class='neutral'>    /// Returns 0 in case of an empty `key`.</span>
 1204 |     | <span class='neutral'>    function indexOf(string calldata input, string calldata key) external pure returns (uint256);</span>
 1205 |     | <span class='neutral'></span>
 1206 |     | <span class='neutral'>    /// Parses the given `string` into an `address`.</span>
 1207 |     | <span class='neutral'>    function parseAddress(string calldata stringifiedValue) external pure returns (address parsedValue);</span>
 1208 |     | <span class='neutral'></span>
 1209 |     | <span class='neutral'>    /// Parses the given `string` into a `bool`.</span>
 1210 |     | <span class='neutral'>    function parseBool(string calldata stringifiedValue) external pure returns (bool parsedValue);</span>
 1211 |     | <span class='neutral'></span>
 1212 |     | <span class='neutral'>    /// Parses the given `string` into `bytes`.</span>
 1213 |     | <span class='neutral'>    function parseBytes(string calldata stringifiedValue) external pure returns (bytes memory parsedValue);</span>
 1214 |     | <span class='neutral'></span>
 1215 |     | <span class='neutral'>    /// Parses the given `string` into a `bytes32`.</span>
 1216 |     | <span class='neutral'>    function parseBytes32(string calldata stringifiedValue) external pure returns (bytes32 parsedValue);</span>
 1217 |     | <span class='neutral'></span>
 1218 |     | <span class='neutral'>    /// Parses the given `string` into a `int256`.</span>
 1219 |     | <span class='neutral'>    function parseInt(string calldata stringifiedValue) external pure returns (int256 parsedValue);</span>
 1220 |     | <span class='neutral'></span>
 1221 |     | <span class='neutral'>    /// Parses the given `string` into a `uint256`.</span>
 1222 |     | <span class='neutral'>    function parseUint(string calldata stringifiedValue) external pure returns (uint256 parsedValue);</span>
 1223 |     | <span class='neutral'></span>
 1224 |     | <span class='neutral'>    /// Replaces occurrences of `from` in the given `string` with `to`.</span>
 1225 |     | <span class='neutral'>    function replace(string calldata input, string calldata from, string calldata to)</span>
 1226 |     | <span class='neutral'>        external</span>
 1227 |     | <span class='neutral'>        pure</span>
 1228 |     | <span class='neutral'>        returns (string memory output);</span>
 1229 |     | <span class='neutral'></span>
 1230 |     | <span class='neutral'>    /// Splits the given `string` into an array of strings divided by the `delimiter`.</span>
 1231 |     | <span class='neutral'>    function split(string calldata input, string calldata delimiter) external pure returns (string[] memory outputs);</span>
 1232 |     | <span class='neutral'></span>
 1233 |     | <span class='neutral'>    /// Converts the given `string` value to Lowercase.</span>
 1234 |     | <span class='neutral'>    function toLowercase(string calldata input) external pure returns (string memory output);</span>
 1235 |     | <span class='neutral'></span>
 1236 |     | <span class='neutral'>    /// Converts the given value to a `string`.</span>
 1237 |     | <span class='neutral'>    function toString(address value) external pure returns (string memory stringifiedValue);</span>
 1238 |     | <span class='neutral'></span>
 1239 |     | <span class='neutral'>    /// Converts the given value to a `string`.</span>
 1240 |     | <span class='neutral'>    function toString(bytes calldata value) external pure returns (string memory stringifiedValue);</span>
 1241 |     | <span class='neutral'></span>
 1242 |     | <span class='neutral'>    /// Converts the given value to a `string`.</span>
 1243 |     | <span class='neutral'>    function toString(bytes32 value) external pure returns (string memory stringifiedValue);</span>
 1244 |     | <span class='neutral'></span>
 1245 |     | <span class='neutral'>    /// Converts the given value to a `string`.</span>
 1246 |     | <span class='neutral'>    function toString(bool value) external pure returns (string memory stringifiedValue);</span>
 1247 |     | <span class='neutral'></span>
 1248 |     | <span class='neutral'>    /// Converts the given value to a `string`.</span>
 1249 |     | <span class='neutral'>    function toString(uint256 value) external pure returns (string memory stringifiedValue);</span>
 1250 |     | <span class='neutral'></span>
 1251 |     | <span class='neutral'>    /// Converts the given value to a `string`.</span>
 1252 |     | <span class='neutral'>    function toString(int256 value) external pure returns (string memory stringifiedValue);</span>
 1253 |     | <span class='neutral'></span>
 1254 |     | <span class='neutral'>    /// Converts the given `string` value to Uppercase.</span>
 1255 |     | <span class='neutral'>    function toUppercase(string calldata input) external pure returns (string memory output);</span>
 1256 |     | <span class='neutral'></span>
 1257 |     | <span class='neutral'>    /// Trims leading and trailing whitespace from the given `string` value.</span>
 1258 |     | <span class='neutral'>    function trim(string calldata input) external pure returns (string memory output);</span>
 1259 |     | <span class='neutral'></span>
 1260 |     | <span class='neutral'>    // ======== Testing ========</span>
 1261 |     | <span class='neutral'></span>
 1262 |     | <span class='neutral'>    /// Compares two `uint256` values. Expects difference to be less than or equal to `maxDelta`.</span>
 1263 |     | <span class='neutral'>    /// Formats values with decimals in failure message.</span>
 1264 |     | <span class='neutral'>    function assertApproxEqAbsDecimal(uint256 left, uint256 right, uint256 maxDelta, uint256 decimals) external pure;</span>
 1265 |     | <span class='neutral'></span>
 1266 |     | <span class='neutral'>    /// Compares two `uint256` values. Expects difference to be less than or equal to `maxDelta`.</span>
 1267 |     | <span class='neutral'>    /// Formats values with decimals in failure message. Includes error message into revert string on failure.</span>
 1268 |     | <span class='neutral'>    function assertApproxEqAbsDecimal(</span>
 1269 |     | <span class='neutral'>        uint256 left,</span>
 1270 |     | <span class='neutral'>        uint256 right,</span>
 1271 |     | <span class='neutral'>        uint256 maxDelta,</span>
 1272 |     | <span class='neutral'>        uint256 decimals,</span>
 1273 |     | <span class='neutral'>        string calldata error</span>
 1274 |     | <span class='neutral'>    ) external pure;</span>
 1275 |     | <span class='neutral'></span>
 1276 |     | <span class='neutral'>    /// Compares two `int256` values. Expects difference to be less than or equal to `maxDelta`.</span>
 1277 |     | <span class='neutral'>    /// Formats values with decimals in failure message.</span>
 1278 |     | <span class='neutral'>    function assertApproxEqAbsDecimal(int256 left, int256 right, uint256 maxDelta, uint256 decimals) external pure;</span>
 1279 |     | <span class='neutral'></span>
 1280 |     | <span class='neutral'>    /// Compares two `int256` values. Expects difference to be less than or equal to `maxDelta`.</span>
 1281 |     | <span class='neutral'>    /// Formats values with decimals in failure message. Includes error message into revert string on failure.</span>
 1282 |     | <span class='neutral'>    function assertApproxEqAbsDecimal(</span>
 1283 |     | <span class='neutral'>        int256 left,</span>
 1284 |     | <span class='neutral'>        int256 right,</span>
 1285 |     | <span class='neutral'>        uint256 maxDelta,</span>
 1286 |     | <span class='neutral'>        uint256 decimals,</span>
 1287 |     | <span class='neutral'>        string calldata error</span>
 1288 |     | <span class='neutral'>    ) external pure;</span>
 1289 |     | <span class='neutral'></span>
 1290 |     | <span class='neutral'>    /// Compares two `uint256` values. Expects difference to be less than or equal to `maxDelta`.</span>
 1291 |     | <span class='neutral'>    function assertApproxEqAbs(uint256 left, uint256 right, uint256 maxDelta) external pure;</span>
 1292 |     | <span class='neutral'></span>
 1293 |     | <span class='neutral'>    /// Compares two `uint256` values. Expects difference to be less than or equal to `maxDelta`.</span>
 1294 |     | <span class='neutral'>    /// Includes error message into revert string on failure.</span>
 1295 |     | <span class='neutral'>    function assertApproxEqAbs(uint256 left, uint256 right, uint256 maxDelta, string calldata error) external pure;</span>
 1296 |     | <span class='neutral'></span>
 1297 |     | <span class='neutral'>    /// Compares two `int256` values. Expects difference to be less than or equal to `maxDelta`.</span>
 1298 |     | <span class='neutral'>    function assertApproxEqAbs(int256 left, int256 right, uint256 maxDelta) external pure;</span>
 1299 |     | <span class='neutral'></span>
 1300 |     | <span class='neutral'>    /// Compares two `int256` values. Expects difference to be less than or equal to `maxDelta`.</span>
 1301 |     | <span class='neutral'>    /// Includes error message into revert string on failure.</span>
 1302 |     | <span class='neutral'>    function assertApproxEqAbs(int256 left, int256 right, uint256 maxDelta, string calldata error) external pure;</span>
 1303 |     | <span class='neutral'></span>
 1304 |     | <span class='neutral'>    /// Compares two `uint256` values. Expects relative difference in percents to be less than or equal to `maxPercentDelta`.</span>
 1305 |     | <span class='neutral'>    /// `maxPercentDelta` is an 18 decimal fixed point number, where 1e18 == 100%</span>
 1306 |     | <span class='neutral'>    /// Formats values with decimals in failure message.</span>
 1307 |     | <span class='neutral'>    function assertApproxEqRelDecimal(uint256 left, uint256 right, uint256 maxPercentDelta, uint256 decimals)</span>
 1308 |     | <span class='neutral'>        external</span>
 1309 |     | <span class='neutral'>        pure;</span>
 1310 |     | <span class='neutral'></span>
 1311 |     | <span class='neutral'>    /// Compares two `uint256` values. Expects relative difference in percents to be less than or equal to `maxPercentDelta`.</span>
 1312 |     | <span class='neutral'>    /// `maxPercentDelta` is an 18 decimal fixed point number, where 1e18 == 100%</span>
 1313 |     | <span class='neutral'>    /// Formats values with decimals in failure message. Includes error message into revert string on failure.</span>
 1314 |     | <span class='neutral'>    function assertApproxEqRelDecimal(</span>
 1315 |     | <span class='neutral'>        uint256 left,</span>
 1316 |     | <span class='neutral'>        uint256 right,</span>
 1317 |     | <span class='neutral'>        uint256 maxPercentDelta,</span>
 1318 |     | <span class='neutral'>        uint256 decimals,</span>
 1319 |     | <span class='neutral'>        string calldata error</span>
 1320 |     | <span class='neutral'>    ) external pure;</span>
 1321 |     | <span class='neutral'></span>
 1322 |     | <span class='neutral'>    /// Compares two `int256` values. Expects relative difference in percents to be less than or equal to `maxPercentDelta`.</span>
 1323 |     | <span class='neutral'>    /// `maxPercentDelta` is an 18 decimal fixed point number, where 1e18 == 100%</span>
 1324 |     | <span class='neutral'>    /// Formats values with decimals in failure message.</span>
 1325 |     | <span class='neutral'>    function assertApproxEqRelDecimal(int256 left, int256 right, uint256 maxPercentDelta, uint256 decimals)</span>
 1326 |     | <span class='neutral'>        external</span>
 1327 |     | <span class='neutral'>        pure;</span>
 1328 |     | <span class='neutral'></span>
 1329 |     | <span class='neutral'>    /// Compares two `int256` values. Expects relative difference in percents to be less than or equal to `maxPercentDelta`.</span>
 1330 |     | <span class='neutral'>    /// `maxPercentDelta` is an 18 decimal fixed point number, where 1e18 == 100%</span>
 1331 |     | <span class='neutral'>    /// Formats values with decimals in failure message. Includes error message into revert string on failure.</span>
 1332 |     | <span class='neutral'>    function assertApproxEqRelDecimal(</span>
 1333 |     | <span class='neutral'>        int256 left,</span>
 1334 |     | <span class='neutral'>        int256 right,</span>
 1335 |     | <span class='neutral'>        uint256 maxPercentDelta,</span>
 1336 |     | <span class='neutral'>        uint256 decimals,</span>
 1337 |     | <span class='neutral'>        string calldata error</span>
 1338 |     | <span class='neutral'>    ) external pure;</span>
 1339 |     | <span class='neutral'></span>
 1340 |     | <span class='neutral'>    /// Compares two `uint256` values. Expects relative difference in percents to be less than or equal to `maxPercentDelta`.</span>
 1341 |     | <span class='neutral'>    /// `maxPercentDelta` is an 18 decimal fixed point number, where 1e18 == 100%</span>
 1342 |     | <span class='neutral'>    function assertApproxEqRel(uint256 left, uint256 right, uint256 maxPercentDelta) external pure;</span>
 1343 |     | <span class='neutral'></span>
 1344 |     | <span class='neutral'>    /// Compares two `uint256` values. Expects relative difference in percents to be less than or equal to `maxPercentDelta`.</span>
 1345 |     | <span class='neutral'>    /// `maxPercentDelta` is an 18 decimal fixed point number, where 1e18 == 100%</span>
 1346 |     | <span class='neutral'>    /// Includes error message into revert string on failure.</span>
 1347 |     | <span class='neutral'>    function assertApproxEqRel(uint256 left, uint256 right, uint256 maxPercentDelta, string calldata error)</span>
 1348 |     | <span class='neutral'>        external</span>
 1349 |     | <span class='neutral'>        pure;</span>
 1350 |     | <span class='neutral'></span>
 1351 |     | <span class='neutral'>    /// Compares two `int256` values. Expects relative difference in percents to be less than or equal to `maxPercentDelta`.</span>
 1352 |     | <span class='neutral'>    /// `maxPercentDelta` is an 18 decimal fixed point number, where 1e18 == 100%</span>
 1353 |     | <span class='neutral'>    function assertApproxEqRel(int256 left, int256 right, uint256 maxPercentDelta) external pure;</span>
 1354 |     | <span class='neutral'></span>
 1355 |     | <span class='neutral'>    /// Compares two `int256` values. Expects relative difference in percents to be less than or equal to `maxPercentDelta`.</span>
 1356 |     | <span class='neutral'>    /// `maxPercentDelta` is an 18 decimal fixed point number, where 1e18 == 100%</span>
 1357 |     | <span class='neutral'>    /// Includes error message into revert string on failure.</span>
 1358 |     | <span class='neutral'>    function assertApproxEqRel(int256 left, int256 right, uint256 maxPercentDelta, string calldata error)</span>
 1359 |     | <span class='neutral'>        external</span>
 1360 |     | <span class='neutral'>        pure;</span>
 1361 |     | <span class='neutral'></span>
 1362 |     | <span class='neutral'>    /// Asserts that two `uint256` values are equal, formatting them with decimals in failure message.</span>
 1363 |     | <span class='neutral'>    function assertEqDecimal(uint256 left, uint256 right, uint256 decimals) external pure;</span>
 1364 |     | <span class='neutral'></span>
 1365 |     | <span class='neutral'>    /// Asserts that two `uint256` values are equal, formatting them with decimals in failure message.</span>
 1366 |     | <span class='neutral'>    /// Includes error message into revert string on failure.</span>
 1367 |     | <span class='neutral'>    function assertEqDecimal(uint256 left, uint256 right, uint256 decimals, string calldata error) external pure;</span>
 1368 |     | <span class='neutral'></span>
 1369 |     | <span class='neutral'>    /// Asserts that two `int256` values are equal, formatting them with decimals in failure message.</span>
 1370 |     | <span class='neutral'>    function assertEqDecimal(int256 left, int256 right, uint256 decimals) external pure;</span>
 1371 |     | <span class='neutral'></span>
 1372 |     | <span class='neutral'>    /// Asserts that two `int256` values are equal, formatting them with decimals in failure message.</span>
 1373 |     | <span class='neutral'>    /// Includes error message into revert string on failure.</span>
 1374 |     | <span class='neutral'>    function assertEqDecimal(int256 left, int256 right, uint256 decimals, string calldata error) external pure;</span>
 1375 |     | <span class='neutral'></span>
 1376 |     | <span class='neutral'>    /// Asserts that two `bool` values are equal.</span>
 1377 |     | <span class='neutral'>    function assertEq(bool left, bool right) external pure;</span>
 1378 |     | <span class='neutral'></span>
 1379 |     | <span class='neutral'>    /// Asserts that two `bool` values are equal and includes error message into revert string on failure.</span>
 1380 |     | <span class='neutral'>    function assertEq(bool left, bool right, string calldata error) external pure;</span>
 1381 |     | <span class='neutral'></span>
 1382 |     | <span class='neutral'>    /// Asserts that two `string` values are equal.</span>
 1383 |     | <span class='neutral'>    function assertEq(string calldata left, string calldata right) external pure;</span>
 1384 |     | <span class='neutral'></span>
 1385 |     | <span class='neutral'>    /// Asserts that two `string` values are equal and includes error message into revert string on failure.</span>
 1386 |     | <span class='neutral'>    function assertEq(string calldata left, string calldata right, string calldata error) external pure;</span>
 1387 |     | <span class='neutral'></span>
 1388 |     | <span class='neutral'>    /// Asserts that two `bytes` values are equal.</span>
 1389 |     | <span class='neutral'>    function assertEq(bytes calldata left, bytes calldata right) external pure;</span>
 1390 |     | <span class='neutral'></span>
 1391 |     | <span class='neutral'>    /// Asserts that two `bytes` values are equal and includes error message into revert string on failure.</span>
 1392 |     | <span class='neutral'>    function assertEq(bytes calldata left, bytes calldata right, string calldata error) external pure;</span>
 1393 |     | <span class='neutral'></span>
 1394 |     | <span class='neutral'>    /// Asserts that two arrays of `bool` values are equal.</span>
 1395 |     | <span class='neutral'>    function assertEq(bool[] calldata left, bool[] calldata right) external pure;</span>
 1396 |     | <span class='neutral'></span>
 1397 |     | <span class='neutral'>    /// Asserts that two arrays of `bool` values are equal and includes error message into revert string on failure.</span>
 1398 |     | <span class='neutral'>    function assertEq(bool[] calldata left, bool[] calldata right, string calldata error) external pure;</span>
 1399 |     | <span class='neutral'></span>
 1400 |     | <span class='neutral'>    /// Asserts that two arrays of `uint256 values are equal.</span>
 1401 |     | <span class='neutral'>    function assertEq(uint256[] calldata left, uint256[] calldata right) external pure;</span>
 1402 |     | <span class='neutral'></span>
 1403 |     | <span class='neutral'>    /// Asserts that two arrays of `uint256` values are equal and includes error message into revert string on failure.</span>
 1404 |     | <span class='neutral'>    function assertEq(uint256[] calldata left, uint256[] calldata right, string calldata error) external pure;</span>
 1405 |     | <span class='neutral'></span>
 1406 |     | <span class='neutral'>    /// Asserts that two arrays of `int256` values are equal.</span>
 1407 |     | <span class='neutral'>    function assertEq(int256[] calldata left, int256[] calldata right) external pure;</span>
 1408 |     | <span class='neutral'></span>
 1409 |     | <span class='neutral'>    /// Asserts that two arrays of `int256` values are equal and includes error message into revert string on failure.</span>
 1410 |     | <span class='neutral'>    function assertEq(int256[] calldata left, int256[] calldata right, string calldata error) external pure;</span>
 1411 |     | <span class='neutral'></span>
 1412 |     | <span class='neutral'>    /// Asserts that two `uint256` values are equal.</span>
 1413 |     | <span class='neutral'>    function assertEq(uint256 left, uint256 right) external pure;</span>
 1414 |     | <span class='neutral'></span>
 1415 |     | <span class='neutral'>    /// Asserts that two arrays of `address` values are equal.</span>
 1416 |     | <span class='neutral'>    function assertEq(address[] calldata left, address[] calldata right) external pure;</span>
 1417 |     | <span class='neutral'></span>
 1418 |     | <span class='neutral'>    /// Asserts that two arrays of `address` values are equal and includes error message into revert string on failure.</span>
 1419 |     | <span class='neutral'>    function assertEq(address[] calldata left, address[] calldata right, string calldata error) external pure;</span>
 1420 |     | <span class='neutral'></span>
 1421 |     | <span class='neutral'>    /// Asserts that two arrays of `bytes32` values are equal.</span>
 1422 |     | <span class='neutral'>    function assertEq(bytes32[] calldata left, bytes32[] calldata right) external pure;</span>
 1423 |     | <span class='neutral'></span>
 1424 |     | <span class='neutral'>    /// Asserts that two arrays of `bytes32` values are equal and includes error message into revert string on failure.</span>
 1425 |     | <span class='neutral'>    function assertEq(bytes32[] calldata left, bytes32[] calldata right, string calldata error) external pure;</span>
 1426 |     | <span class='neutral'></span>
 1427 |     | <span class='neutral'>    /// Asserts that two arrays of `string` values are equal.</span>
 1428 |     | <span class='neutral'>    function assertEq(string[] calldata left, string[] calldata right) external pure;</span>
 1429 |     | <span class='neutral'></span>
 1430 |     | <span class='neutral'>    /// Asserts that two arrays of `string` values are equal and includes error message into revert string on failure.</span>
 1431 |     | <span class='neutral'>    function assertEq(string[] calldata left, string[] calldata right, string calldata error) external pure;</span>
 1432 |     | <span class='neutral'></span>
 1433 |     | <span class='neutral'>    /// Asserts that two arrays of `bytes` values are equal.</span>
 1434 |     | <span class='neutral'>    function assertEq(bytes[] calldata left, bytes[] calldata right) external pure;</span>
 1435 |     | <span class='neutral'></span>
 1436 |     | <span class='neutral'>    /// Asserts that two arrays of `bytes` values are equal and includes error message into revert string on failure.</span>
 1437 |     | <span class='neutral'>    function assertEq(bytes[] calldata left, bytes[] calldata right, string calldata error) external pure;</span>
 1438 |     | <span class='neutral'></span>
 1439 |     | <span class='neutral'>    /// Asserts that two `uint256` values are equal and includes error message into revert string on failure.</span>
 1440 |     | <span class='neutral'>    function assertEq(uint256 left, uint256 right, string calldata error) external pure;</span>
 1441 |     | <span class='neutral'></span>
 1442 |     | <span class='neutral'>    /// Asserts that two `int256` values are equal.</span>
 1443 |     | <span class='neutral'>    function assertEq(int256 left, int256 right) external pure;</span>
 1444 |     | <span class='neutral'></span>
 1445 |     | <span class='neutral'>    /// Asserts that two `int256` values are equal and includes error message into revert string on failure.</span>
 1446 |     | <span class='neutral'>    function assertEq(int256 left, int256 right, string calldata error) external pure;</span>
 1447 |     | <span class='neutral'></span>
 1448 |     | <span class='neutral'>    /// Asserts that two `address` values are equal.</span>
 1449 |     | <span class='neutral'>    function assertEq(address left, address right) external pure;</span>
 1450 |     | <span class='neutral'></span>
 1451 |     | <span class='neutral'>    /// Asserts that two `address` values are equal and includes error message into revert string on failure.</span>
 1452 |     | <span class='neutral'>    function assertEq(address left, address right, string calldata error) external pure;</span>
 1453 |     | <span class='neutral'></span>
 1454 |     | <span class='neutral'>    /// Asserts that two `bytes32` values are equal.</span>
 1455 |     | <span class='neutral'>    function assertEq(bytes32 left, bytes32 right) external pure;</span>
 1456 |     | <span class='neutral'></span>
 1457 |     | <span class='neutral'>    /// Asserts that two `bytes32` values are equal and includes error message into revert string on failure.</span>
 1458 |     | <span class='neutral'>    function assertEq(bytes32 left, bytes32 right, string calldata error) external pure;</span>
 1459 |     | <span class='neutral'></span>
 1460 |     | <span class='neutral'>    /// Asserts that the given condition is false.</span>
 1461 |     | <span class='neutral'>    function assertFalse(bool condition) external pure;</span>
 1462 |     | <span class='neutral'></span>
 1463 |     | <span class='neutral'>    /// Asserts that the given condition is false and includes error message into revert string on failure.</span>
 1464 |     | <span class='neutral'>    function assertFalse(bool condition, string calldata error) external pure;</span>
 1465 |     | <span class='neutral'></span>
 1466 |     | <span class='neutral'>    /// Compares two `uint256` values. Expects first value to be greater than or equal to second.</span>
 1467 |     | <span class='neutral'>    /// Formats values with decimals in failure message.</span>
 1468 |     | <span class='neutral'>    function assertGeDecimal(uint256 left, uint256 right, uint256 decimals) external pure;</span>
 1469 |     | <span class='neutral'></span>
 1470 |     | <span class='neutral'>    /// Compares two `uint256` values. Expects first value to be greater than or equal to second.</span>
 1471 |     | <span class='neutral'>    /// Formats values with decimals in failure message. Includes error message into revert string on failure.</span>
 1472 |     | <span class='neutral'>    function assertGeDecimal(uint256 left, uint256 right, uint256 decimals, string calldata error) external pure;</span>
 1473 |     | <span class='neutral'></span>
 1474 |     | <span class='neutral'>    /// Compares two `int256` values. Expects first value to be greater than or equal to second.</span>
 1475 |     | <span class='neutral'>    /// Formats values with decimals in failure message.</span>
 1476 |     | <span class='neutral'>    function assertGeDecimal(int256 left, int256 right, uint256 decimals) external pure;</span>
 1477 |     | <span class='neutral'></span>
 1478 |     | <span class='neutral'>    /// Compares two `int256` values. Expects first value to be greater than or equal to second.</span>
 1479 |     | <span class='neutral'>    /// Formats values with decimals in failure message. Includes error message into revert string on failure.</span>
 1480 |     | <span class='neutral'>    function assertGeDecimal(int256 left, int256 right, uint256 decimals, string calldata error) external pure;</span>
 1481 |     | <span class='neutral'></span>
 1482 |     | <span class='neutral'>    /// Compares two `uint256` values. Expects first value to be greater than or equal to second.</span>
 1483 |     | <span class='neutral'>    function assertGe(uint256 left, uint256 right) external pure;</span>
 1484 |     | <span class='neutral'></span>
 1485 |     | <span class='neutral'>    /// Compares two `uint256` values. Expects first value to be greater than or equal to second.</span>
 1486 |     | <span class='neutral'>    /// Includes error message into revert string on failure.</span>
 1487 |     | <span class='neutral'>    function assertGe(uint256 left, uint256 right, string calldata error) external pure;</span>
 1488 |     | <span class='neutral'></span>
 1489 |     | <span class='neutral'>    /// Compares two `int256` values. Expects first value to be greater than or equal to second.</span>
 1490 |     | <span class='neutral'>    function assertGe(int256 left, int256 right) external pure;</span>
 1491 |     | <span class='neutral'></span>
 1492 |     | <span class='neutral'>    /// Compares two `int256` values. Expects first value to be greater than or equal to second.</span>
 1493 |     | <span class='neutral'>    /// Includes error message into revert string on failure.</span>
 1494 |     | <span class='neutral'>    function assertGe(int256 left, int256 right, string calldata error) external pure;</span>
 1495 |     | <span class='neutral'></span>
 1496 |     | <span class='neutral'>    /// Compares two `uint256` values. Expects first value to be greater than second.</span>
 1497 |     | <span class='neutral'>    /// Formats values with decimals in failure message.</span>
 1498 |     | <span class='neutral'>    function assertGtDecimal(uint256 left, uint256 right, uint256 decimals) external pure;</span>
 1499 |     | <span class='neutral'></span>
 1500 |     | <span class='neutral'>    /// Compares two `uint256` values. Expects first value to be greater than second.</span>
 1501 |     | <span class='neutral'>    /// Formats values with decimals in failure message. Includes error message into revert string on failure.</span>
 1502 |     | <span class='neutral'>    function assertGtDecimal(uint256 left, uint256 right, uint256 decimals, string calldata error) external pure;</span>
 1503 |     | <span class='neutral'></span>
 1504 |     | <span class='neutral'>    /// Compares two `int256` values. Expects first value to be greater than second.</span>
 1505 |     | <span class='neutral'>    /// Formats values with decimals in failure message.</span>
 1506 |     | <span class='neutral'>    function assertGtDecimal(int256 left, int256 right, uint256 decimals) external pure;</span>
 1507 |     | <span class='neutral'></span>
 1508 |     | <span class='neutral'>    /// Compares two `int256` values. Expects first value to be greater than second.</span>
 1509 |     | <span class='neutral'>    /// Formats values with decimals in failure message. Includes error message into revert string on failure.</span>
 1510 |     | <span class='neutral'>    function assertGtDecimal(int256 left, int256 right, uint256 decimals, string calldata error) external pure;</span>
 1511 |     | <span class='neutral'></span>
 1512 |     | <span class='neutral'>    /// Compares two `uint256` values. Expects first value to be greater than second.</span>
 1513 |     | <span class='neutral'>    function assertGt(uint256 left, uint256 right) external pure;</span>
 1514 |     | <span class='neutral'></span>
 1515 |     | <span class='neutral'>    /// Compares two `uint256` values. Expects first value to be greater than second.</span>
 1516 |     | <span class='neutral'>    /// Includes error message into revert string on failure.</span>
 1517 |     | <span class='neutral'>    function assertGt(uint256 left, uint256 right, string calldata error) external pure;</span>
 1518 |     | <span class='neutral'></span>
 1519 |     | <span class='neutral'>    /// Compares two `int256` values. Expects first value to be greater than second.</span>
 1520 |     | <span class='neutral'>    function assertGt(int256 left, int256 right) external pure;</span>
 1521 |     | <span class='neutral'></span>
 1522 |     | <span class='neutral'>    /// Compares two `int256` values. Expects first value to be greater than second.</span>
 1523 |     | <span class='neutral'>    /// Includes error message into revert string on failure.</span>
 1524 |     | <span class='neutral'>    function assertGt(int256 left, int256 right, string calldata error) external pure;</span>
 1525 |     | <span class='neutral'></span>
 1526 |     | <span class='neutral'>    /// Compares two `uint256` values. Expects first value to be less than or equal to second.</span>
 1527 |     | <span class='neutral'>    /// Formats values with decimals in failure message.</span>
 1528 |     | <span class='neutral'>    function assertLeDecimal(uint256 left, uint256 right, uint256 decimals) external pure;</span>
 1529 |     | <span class='neutral'></span>
 1530 |     | <span class='neutral'>    /// Compares two `uint256` values. Expects first value to be less than or equal to second.</span>
 1531 |     | <span class='neutral'>    /// Formats values with decimals in failure message. Includes error message into revert string on failure.</span>
 1532 |     | <span class='neutral'>    function assertLeDecimal(uint256 left, uint256 right, uint256 decimals, string calldata error) external pure;</span>
 1533 |     | <span class='neutral'></span>
 1534 |     | <span class='neutral'>    /// Compares two `int256` values. Expects first value to be less than or equal to second.</span>
 1535 |     | <span class='neutral'>    /// Formats values with decimals in failure message.</span>
 1536 |     | <span class='neutral'>    function assertLeDecimal(int256 left, int256 right, uint256 decimals) external pure;</span>
 1537 |     | <span class='neutral'></span>
 1538 |     | <span class='neutral'>    /// Compares two `int256` values. Expects first value to be less than or equal to second.</span>
 1539 |     | <span class='neutral'>    /// Formats values with decimals in failure message. Includes error message into revert string on failure.</span>
 1540 |     | <span class='neutral'>    function assertLeDecimal(int256 left, int256 right, uint256 decimals, string calldata error) external pure;</span>
 1541 |     | <span class='neutral'></span>
 1542 |     | <span class='neutral'>    /// Compares two `uint256` values. Expects first value to be less than or equal to second.</span>
 1543 |     | <span class='neutral'>    function assertLe(uint256 left, uint256 right) external pure;</span>
 1544 |     | <span class='neutral'></span>
 1545 |     | <span class='neutral'>    /// Compares two `uint256` values. Expects first value to be less than or equal to second.</span>
 1546 |     | <span class='neutral'>    /// Includes error message into revert string on failure.</span>
 1547 |     | <span class='neutral'>    function assertLe(uint256 left, uint256 right, string calldata error) external pure;</span>
 1548 |     | <span class='neutral'></span>
 1549 |     | <span class='neutral'>    /// Compares two `int256` values. Expects first value to be less than or equal to second.</span>
 1550 |     | <span class='neutral'>    function assertLe(int256 left, int256 right) external pure;</span>
 1551 |     | <span class='neutral'></span>
 1552 |     | <span class='neutral'>    /// Compares two `int256` values. Expects first value to be less than or equal to second.</span>
 1553 |     | <span class='neutral'>    /// Includes error message into revert string on failure.</span>
 1554 |     | <span class='neutral'>    function assertLe(int256 left, int256 right, string calldata error) external pure;</span>
 1555 |     | <span class='neutral'></span>
 1556 |     | <span class='neutral'>    /// Compares two `uint256` values. Expects first value to be less than second.</span>
 1557 |     | <span class='neutral'>    /// Formats values with decimals in failure message.</span>
 1558 |     | <span class='neutral'>    function assertLtDecimal(uint256 left, uint256 right, uint256 decimals) external pure;</span>
 1559 |     | <span class='neutral'></span>
 1560 |     | <span class='neutral'>    /// Compares two `uint256` values. Expects first value to be less than second.</span>
 1561 |     | <span class='neutral'>    /// Formats values with decimals in failure message. Includes error message into revert string on failure.</span>
 1562 |     | <span class='neutral'>    function assertLtDecimal(uint256 left, uint256 right, uint256 decimals, string calldata error) external pure;</span>
 1563 |     | <span class='neutral'></span>
 1564 |     | <span class='neutral'>    /// Compares two `int256` values. Expects first value to be less than second.</span>
 1565 |     | <span class='neutral'>    /// Formats values with decimals in failure message.</span>
 1566 |     | <span class='neutral'>    function assertLtDecimal(int256 left, int256 right, uint256 decimals) external pure;</span>
 1567 |     | <span class='neutral'></span>
 1568 |     | <span class='neutral'>    /// Compares two `int256` values. Expects first value to be less than second.</span>
 1569 |     | <span class='neutral'>    /// Formats values with decimals in failure message. Includes error message into revert string on failure.</span>
 1570 |     | <span class='neutral'>    function assertLtDecimal(int256 left, int256 right, uint256 decimals, string calldata error) external pure;</span>
 1571 |     | <span class='neutral'></span>
 1572 |     | <span class='neutral'>    /// Compares two `uint256` values. Expects first value to be less than second.</span>
 1573 |     | <span class='neutral'>    function assertLt(uint256 left, uint256 right) external pure;</span>
 1574 |     | <span class='neutral'></span>
 1575 |     | <span class='neutral'>    /// Compares two `uint256` values. Expects first value to be less than second.</span>
 1576 |     | <span class='neutral'>    /// Includes error message into revert string on failure.</span>
 1577 |     | <span class='neutral'>    function assertLt(uint256 left, uint256 right, string calldata error) external pure;</span>
 1578 |     | <span class='neutral'></span>
 1579 |     | <span class='neutral'>    /// Compares two `int256` values. Expects first value to be less than second.</span>
 1580 |     | <span class='neutral'>    function assertLt(int256 left, int256 right) external pure;</span>
 1581 |     | <span class='neutral'></span>
 1582 |     | <span class='neutral'>    /// Compares two `int256` values. Expects first value to be less than second.</span>
 1583 |     | <span class='neutral'>    /// Includes error message into revert string on failure.</span>
 1584 |     | <span class='neutral'>    function assertLt(int256 left, int256 right, string calldata error) external pure;</span>
 1585 |     | <span class='neutral'></span>
 1586 |     | <span class='neutral'>    /// Asserts that two `uint256` values are not equal, formatting them with decimals in failure message.</span>
 1587 |     | <span class='neutral'>    function assertNotEqDecimal(uint256 left, uint256 right, uint256 decimals) external pure;</span>
 1588 |     | <span class='neutral'></span>
 1589 |     | <span class='neutral'>    /// Asserts that two `uint256` values are not equal, formatting them with decimals in failure message.</span>
 1590 |     | <span class='neutral'>    /// Includes error message into revert string on failure.</span>
 1591 |     | <span class='neutral'>    function assertNotEqDecimal(uint256 left, uint256 right, uint256 decimals, string calldata error) external pure;</span>
 1592 |     | <span class='neutral'></span>
 1593 |     | <span class='neutral'>    /// Asserts that two `int256` values are not equal, formatting them with decimals in failure message.</span>
 1594 |     | <span class='neutral'>    function assertNotEqDecimal(int256 left, int256 right, uint256 decimals) external pure;</span>
 1595 |     | <span class='neutral'></span>
 1596 |     | <span class='neutral'>    /// Asserts that two `int256` values are not equal, formatting them with decimals in failure message.</span>
 1597 |     | <span class='neutral'>    /// Includes error message into revert string on failure.</span>
 1598 |     | <span class='neutral'>    function assertNotEqDecimal(int256 left, int256 right, uint256 decimals, string calldata error) external pure;</span>
 1599 |     | <span class='neutral'></span>
 1600 |     | <span class='neutral'>    /// Asserts that two `bool` values are not equal.</span>
 1601 |     | <span class='neutral'>    function assertNotEq(bool left, bool right) external pure;</span>
 1602 |     | <span class='neutral'></span>
 1603 |     | <span class='neutral'>    /// Asserts that two `bool` values are not equal and includes error message into revert string on failure.</span>
 1604 |     | <span class='neutral'>    function assertNotEq(bool left, bool right, string calldata error) external pure;</span>
 1605 |     | <span class='neutral'></span>
 1606 |     | <span class='neutral'>    /// Asserts that two `string` values are not equal.</span>
 1607 |     | <span class='neutral'>    function assertNotEq(string calldata left, string calldata right) external pure;</span>
 1608 |     | <span class='neutral'></span>
 1609 |     | <span class='neutral'>    /// Asserts that two `string` values are not equal and includes error message into revert string on failure.</span>
 1610 |     | <span class='neutral'>    function assertNotEq(string calldata left, string calldata right, string calldata error) external pure;</span>
 1611 |     | <span class='neutral'></span>
 1612 |     | <span class='neutral'>    /// Asserts that two `bytes` values are not equal.</span>
 1613 |     | <span class='neutral'>    function assertNotEq(bytes calldata left, bytes calldata right) external pure;</span>
 1614 |     | <span class='neutral'></span>
 1615 |     | <span class='neutral'>    /// Asserts that two `bytes` values are not equal and includes error message into revert string on failure.</span>
 1616 |     | <span class='neutral'>    function assertNotEq(bytes calldata left, bytes calldata right, string calldata error) external pure;</span>
 1617 |     | <span class='neutral'></span>
 1618 |     | <span class='neutral'>    /// Asserts that two arrays of `bool` values are not equal.</span>
 1619 |     | <span class='neutral'>    function assertNotEq(bool[] calldata left, bool[] calldata right) external pure;</span>
 1620 |     | <span class='neutral'></span>
 1621 |     | <span class='neutral'>    /// Asserts that two arrays of `bool` values are not equal and includes error message into revert string on failure.</span>
 1622 |     | <span class='neutral'>    function assertNotEq(bool[] calldata left, bool[] calldata right, string calldata error) external pure;</span>
 1623 |     | <span class='neutral'></span>
 1624 |     | <span class='neutral'>    /// Asserts that two arrays of `uint256` values are not equal.</span>
 1625 |     | <span class='neutral'>    function assertNotEq(uint256[] calldata left, uint256[] calldata right) external pure;</span>
 1626 |     | <span class='neutral'></span>
 1627 |     | <span class='neutral'>    /// Asserts that two arrays of `uint256` values are not equal and includes error message into revert string on failure.</span>
 1628 |     | <span class='neutral'>    function assertNotEq(uint256[] calldata left, uint256[] calldata right, string calldata error) external pure;</span>
 1629 |     | <span class='neutral'></span>
 1630 |     | <span class='neutral'>    /// Asserts that two arrays of `int256` values are not equal.</span>
 1631 |     | <span class='neutral'>    function assertNotEq(int256[] calldata left, int256[] calldata right) external pure;</span>
 1632 |     | <span class='neutral'></span>
 1633 |     | <span class='neutral'>    /// Asserts that two arrays of `int256` values are not equal and includes error message into revert string on failure.</span>
 1634 |     | <span class='neutral'>    function assertNotEq(int256[] calldata left, int256[] calldata right, string calldata error) external pure;</span>
 1635 |     | <span class='neutral'></span>
 1636 |     | <span class='neutral'>    /// Asserts that two `uint256` values are not equal.</span>
 1637 |     | <span class='neutral'>    function assertNotEq(uint256 left, uint256 right) external pure;</span>
 1638 |     | <span class='neutral'></span>
 1639 |     | <span class='neutral'>    /// Asserts that two arrays of `address` values are not equal.</span>
 1640 |     | <span class='neutral'>    function assertNotEq(address[] calldata left, address[] calldata right) external pure;</span>
 1641 |     | <span class='neutral'></span>
 1642 |     | <span class='neutral'>    /// Asserts that two arrays of `address` values are not equal and includes error message into revert string on failure.</span>
 1643 |     | <span class='neutral'>    function assertNotEq(address[] calldata left, address[] calldata right, string calldata error) external pure;</span>
 1644 |     | <span class='neutral'></span>
 1645 |     | <span class='neutral'>    /// Asserts that two arrays of `bytes32` values are not equal.</span>
 1646 |     | <span class='neutral'>    function assertNotEq(bytes32[] calldata left, bytes32[] calldata right) external pure;</span>
 1647 |     | <span class='neutral'></span>
 1648 |     | <span class='neutral'>    /// Asserts that two arrays of `bytes32` values are not equal and includes error message into revert string on failure.</span>
 1649 |     | <span class='neutral'>    function assertNotEq(bytes32[] calldata left, bytes32[] calldata right, string calldata error) external pure;</span>
 1650 |     | <span class='neutral'></span>
 1651 |     | <span class='neutral'>    /// Asserts that two arrays of `string` values are not equal.</span>
 1652 |     | <span class='neutral'>    function assertNotEq(string[] calldata left, string[] calldata right) external pure;</span>
 1653 |     | <span class='neutral'></span>
 1654 |     | <span class='neutral'>    /// Asserts that two arrays of `string` values are not equal and includes error message into revert string on failure.</span>
 1655 |     | <span class='neutral'>    function assertNotEq(string[] calldata left, string[] calldata right, string calldata error) external pure;</span>
 1656 |     | <span class='neutral'></span>
 1657 |     | <span class='neutral'>    /// Asserts that two arrays of `bytes` values are not equal.</span>
 1658 |     | <span class='neutral'>    function assertNotEq(bytes[] calldata left, bytes[] calldata right) external pure;</span>
 1659 |     | <span class='neutral'></span>
 1660 |     | <span class='neutral'>    /// Asserts that two arrays of `bytes` values are not equal and includes error message into revert string on failure.</span>
 1661 |     | <span class='neutral'>    function assertNotEq(bytes[] calldata left, bytes[] calldata right, string calldata error) external pure;</span>
 1662 |     | <span class='neutral'></span>
 1663 |     | <span class='neutral'>    /// Asserts that two `uint256` values are not equal and includes error message into revert string on failure.</span>
 1664 |     | <span class='neutral'>    function assertNotEq(uint256 left, uint256 right, string calldata error) external pure;</span>
 1665 |     | <span class='neutral'></span>
 1666 |     | <span class='neutral'>    /// Asserts that two `int256` values are not equal.</span>
 1667 |     | <span class='neutral'>    function assertNotEq(int256 left, int256 right) external pure;</span>
 1668 |     | <span class='neutral'></span>
 1669 |     | <span class='neutral'>    /// Asserts that two `int256` values are not equal and includes error message into revert string on failure.</span>
 1670 |     | <span class='neutral'>    function assertNotEq(int256 left, int256 right, string calldata error) external pure;</span>
 1671 |     | <span class='neutral'></span>
 1672 |     | <span class='neutral'>    /// Asserts that two `address` values are not equal.</span>
 1673 |     | <span class='neutral'>    function assertNotEq(address left, address right) external pure;</span>
 1674 |     | <span class='neutral'></span>
 1675 |     | <span class='neutral'>    /// Asserts that two `address` values are not equal and includes error message into revert string on failure.</span>
 1676 |     | <span class='neutral'>    function assertNotEq(address left, address right, string calldata error) external pure;</span>
 1677 |     | <span class='neutral'></span>
 1678 |     | <span class='neutral'>    /// Asserts that two `bytes32` values are not equal.</span>
 1679 |     | <span class='neutral'>    function assertNotEq(bytes32 left, bytes32 right) external pure;</span>
 1680 |     | <span class='neutral'></span>
 1681 |     | <span class='neutral'>    /// Asserts that two `bytes32` values are not equal and includes error message into revert string on failure.</span>
 1682 |     | <span class='neutral'>    function assertNotEq(bytes32 left, bytes32 right, string calldata error) external pure;</span>
 1683 |     | <span class='neutral'></span>
 1684 |     | <span class='neutral'>    /// Asserts that the given condition is true.</span>
 1685 |     | <span class='neutral'>    function assertTrue(bool condition) external pure;</span>
 1686 |     | <span class='neutral'></span>
 1687 |     | <span class='neutral'>    /// Asserts that the given condition is true and includes error message into revert string on failure.</span>
 1688 |     | <span class='neutral'>    function assertTrue(bool condition, string calldata error) external pure;</span>
 1689 |     | <span class='neutral'></span>
 1690 |     | <span class='neutral'>    /// If the condition is false, discard this run&#39;s fuzz inputs and generate new ones.</span>
 1691 |     | <span class='neutral'>    function assume(bool condition) external pure;</span>
 1692 |     | <span class='neutral'></span>
 1693 |     | <span class='neutral'>    /// Discard this run&#39;s fuzz inputs and generate new ones if next call reverted.</span>
 1694 |     | <span class='neutral'>    function assumeNoRevert() external pure;</span>
 1695 |     | <span class='neutral'></span>
 1696 |     | <span class='neutral'>    /// Discard this run&#39;s fuzz inputs and generate new ones if next call reverts with the potential revert parameters.</span>
 1697 |     | <span class='neutral'>    function assumeNoRevert(PotentialRevert calldata potentialRevert) external pure;</span>
 1698 |     | <span class='neutral'></span>
 1699 |     | <span class='neutral'>    /// Discard this run&#39;s fuzz inputs and generate new ones if next call reverts with the any of the potential revert parameters.</span>
 1700 |     | <span class='neutral'>    function assumeNoRevert(PotentialRevert[] calldata potentialReverts) external pure;</span>
 1701 |     | <span class='neutral'></span>
 1702 |     | <span class='neutral'>    /// Writes a breakpoint to jump to in the debugger.</span>
 1703 |     | <span class='neutral'>    function breakpoint(string calldata char) external pure;</span>
 1704 |     | <span class='neutral'></span>
 1705 |     | <span class='neutral'>    /// Writes a conditional breakpoint to jump to in the debugger.</span>
 1706 |     | <span class='neutral'>    function breakpoint(string calldata char, bool value) external pure;</span>
 1707 |     | <span class='neutral'></span>
 1708 |     | <span class='neutral'>    /// Returns true if the current Foundry version is greater than or equal to the given version.</span>
 1709 |     | <span class='neutral'>    /// The given version string must be in the format `major.minor.patch`.</span>
 1710 |     | <span class='neutral'>    /// This is equivalent to `foundryVersionCmp(version) &gt;= 0`.</span>
 1711 |     | <span class='neutral'>    function foundryVersionAtLeast(string calldata version) external view returns (bool);</span>
 1712 |     | <span class='neutral'></span>
 1713 |     | <span class='neutral'>    /// Compares the current Foundry version with the given version string.</span>
 1714 |     | <span class='neutral'>    /// The given version string must be in the format `major.minor.patch`.</span>
 1715 |     | <span class='neutral'>    /// Returns:</span>
 1716 |     | <span class='neutral'>    /// -1 if current Foundry version is less than the given version</span>
 1717 |     | <span class='neutral'>    /// 0 if current Foundry version equals the given version</span>
 1718 |     | <span class='neutral'>    /// 1 if current Foundry version is greater than the given version</span>
 1719 |     | <span class='neutral'>    /// This result can then be used with a comparison operator against `0`.</span>
 1720 |     | <span class='neutral'>    /// For example, to check if the current Foundry version is greater than or equal to `1.0.0`:</span>
 1721 |     | <span class='neutral'>    /// `if (foundryVersionCmp(&quot;1.0.0&quot;) &gt;= 0) { ... }`</span>
 1722 |     | <span class='neutral'>    function foundryVersionCmp(string calldata version) external view returns (int256);</span>
 1723 |     | <span class='neutral'></span>
 1724 |     | <span class='neutral'>    /// Returns a Chain struct for specific alias</span>
 1725 |     | <span class='neutral'>    function getChain(string calldata chainAlias) external view returns (Chain memory chain);</span>
 1726 |     | <span class='neutral'></span>
 1727 |     | <span class='neutral'>    /// Returns a Chain struct for specific chainId</span>
 1728 |     | <span class='neutral'>    function getChain(uint256 chainId) external view returns (Chain memory chain);</span>
 1729 |     | <span class='neutral'></span>
 1730 |     | <span class='neutral'>    /// Returns the Foundry version.</span>
 1731 |     | <span class='neutral'>    /// Format: &lt;cargo_version&gt;-&lt;tag&gt;+&lt;git_sha_short&gt;.&lt;unix_build_timestamp&gt;.&lt;profile&gt;</span>
 1732 |     | <span class='neutral'>    /// Sample output: 0.3.0-nightly+3cb96bde9b.1737036656.debug</span>
 1733 |     | <span class='neutral'>    /// Note: Build timestamps may vary slightly across platforms due to separate CI jobs.</span>
 1734 |     | <span class='neutral'>    /// For reliable version comparisons, use UNIX format (e.g., &gt;= 1700000000)</span>
 1735 |     | <span class='neutral'>    /// to compare timestamps while ignoring minor time differences.</span>
 1736 |     | <span class='neutral'>    function getFoundryVersion() external view returns (string memory version);</span>
 1737 |     | <span class='neutral'></span>
 1738 |     | <span class='neutral'>    /// Returns the RPC url for the given alias.</span>
 1739 |     | <span class='neutral'>    function rpcUrl(string calldata rpcAlias) external view returns (string memory json);</span>
 1740 |     | <span class='neutral'></span>
 1741 |     | <span class='neutral'>    /// Returns all rpc urls and their aliases as structs.</span>
 1742 |     | <span class='neutral'>    function rpcUrlStructs() external view returns (Rpc[] memory urls);</span>
 1743 |     | <span class='neutral'></span>
 1744 |     | <span class='neutral'>    /// Returns all rpc urls and their aliases `[alias, url][]`.</span>
 1745 |     | <span class='neutral'>    function rpcUrls() external view returns (string[2][] memory urls);</span>
 1746 |     | <span class='neutral'></span>
 1747 |     | <span class='neutral'>    /// Suspends execution of the main thread for `duration` milliseconds.</span>
 1748 |     | <span class='neutral'>    function sleep(uint256 duration) external;</span>
 1749 |     | <span class='neutral'></span>
 1750 |     | <span class='neutral'>    // ======== Toml ========</span>
 1751 |     | <span class='neutral'></span>
 1752 |     | <span class='neutral'>    /// Checks if `key` exists in a TOML table.</span>
 1753 |     | <span class='neutral'>    function keyExistsToml(string calldata toml, string calldata key) external view returns (bool);</span>
 1754 |     | <span class='neutral'></span>
 1755 |     | <span class='neutral'>    /// Parses a string of TOML data at `key` and coerces it to `address`.</span>
 1756 |     | <span class='neutral'>    function parseTomlAddress(string calldata toml, string calldata key) external pure returns (address);</span>
 1757 |     | <span class='neutral'></span>
 1758 |     | <span class='neutral'>    /// Parses a string of TOML data at `key` and coerces it to `address[]`.</span>
 1759 |     | <span class='neutral'>    function parseTomlAddressArray(string calldata toml, string calldata key)</span>
 1760 |     | <span class='neutral'>        external</span>
 1761 |     | <span class='neutral'>        pure</span>
 1762 |     | <span class='neutral'>        returns (address[] memory);</span>
 1763 |     | <span class='neutral'></span>
 1764 |     | <span class='neutral'>    /// Parses a string of TOML data at `key` and coerces it to `bool`.</span>
 1765 |     | <span class='neutral'>    function parseTomlBool(string calldata toml, string calldata key) external pure returns (bool);</span>
 1766 |     | <span class='neutral'></span>
 1767 |     | <span class='neutral'>    /// Parses a string of TOML data at `key` and coerces it to `bool[]`.</span>
 1768 |     | <span class='neutral'>    function parseTomlBoolArray(string calldata toml, string calldata key) external pure returns (bool[] memory);</span>
 1769 |     | <span class='neutral'></span>
 1770 |     | <span class='neutral'>    /// Parses a string of TOML data at `key` and coerces it to `bytes`.</span>
 1771 |     | <span class='neutral'>    function parseTomlBytes(string calldata toml, string calldata key) external pure returns (bytes memory);</span>
 1772 |     | <span class='neutral'></span>
 1773 |     | <span class='neutral'>    /// Parses a string of TOML data at `key` and coerces it to `bytes32`.</span>
 1774 |     | <span class='neutral'>    function parseTomlBytes32(string calldata toml, string calldata key) external pure returns (bytes32);</span>
 1775 |     | <span class='neutral'></span>
 1776 |     | <span class='neutral'>    /// Parses a string of TOML data at `key` and coerces it to `bytes32[]`.</span>
 1777 |     | <span class='neutral'>    function parseTomlBytes32Array(string calldata toml, string calldata key)</span>
 1778 |     | <span class='neutral'>        external</span>
 1779 |     | <span class='neutral'>        pure</span>
 1780 |     | <span class='neutral'>        returns (bytes32[] memory);</span>
 1781 |     | <span class='neutral'></span>
 1782 |     | <span class='neutral'>    /// Parses a string of TOML data at `key` and coerces it to `bytes[]`.</span>
 1783 |     | <span class='neutral'>    function parseTomlBytesArray(string calldata toml, string calldata key) external pure returns (bytes[] memory);</span>
 1784 |     | <span class='neutral'></span>
 1785 |     | <span class='neutral'>    /// Parses a string of TOML data at `key` and coerces it to `int256`.</span>
 1786 |     | <span class='neutral'>    function parseTomlInt(string calldata toml, string calldata key) external pure returns (int256);</span>
 1787 |     | <span class='neutral'></span>
 1788 |     | <span class='neutral'>    /// Parses a string of TOML data at `key` and coerces it to `int256[]`.</span>
 1789 |     | <span class='neutral'>    function parseTomlIntArray(string calldata toml, string calldata key) external pure returns (int256[] memory);</span>
 1790 |     | <span class='neutral'></span>
 1791 |     | <span class='neutral'>    /// Returns an array of all the keys in a TOML table.</span>
 1792 |     | <span class='neutral'>    function parseTomlKeys(string calldata toml, string calldata key) external pure returns (string[] memory keys);</span>
 1793 |     | <span class='neutral'></span>
 1794 |     | <span class='neutral'>    /// Parses a string of TOML data at `key` and coerces it to `string`.</span>
 1795 |     | <span class='neutral'>    function parseTomlString(string calldata toml, string calldata key) external pure returns (string memory);</span>
 1796 |     | <span class='neutral'></span>
 1797 |     | <span class='neutral'>    /// Parses a string of TOML data at `key` and coerces it to `string[]`.</span>
 1798 |     | <span class='neutral'>    function parseTomlStringArray(string calldata toml, string calldata key) external pure returns (string[] memory);</span>
 1799 |     | <span class='neutral'></span>
 1800 |     | <span class='neutral'>    /// Parses a string of TOML data at `key` and coerces it to type array corresponding to `typeDescription`.</span>
 1801 |     | <span class='neutral'>    function parseTomlTypeArray(string calldata toml, string calldata key, string calldata typeDescription)</span>
 1802 |     | <span class='neutral'>        external</span>
 1803 |     | <span class='neutral'>        pure</span>
 1804 |     | <span class='neutral'>        returns (bytes memory);</span>
 1805 |     | <span class='neutral'></span>
 1806 |     | <span class='neutral'>    /// Parses a string of TOML data and coerces it to type corresponding to `typeDescription`.</span>
 1807 |     | <span class='neutral'>    function parseTomlType(string calldata toml, string calldata typeDescription)</span>
 1808 |     | <span class='neutral'>        external</span>
 1809 |     | <span class='neutral'>        pure</span>
 1810 |     | <span class='neutral'>        returns (bytes memory);</span>
 1811 |     | <span class='neutral'></span>
 1812 |     | <span class='neutral'>    /// Parses a string of TOML data at `key` and coerces it to type corresponding to `typeDescription`.</span>
 1813 |     | <span class='neutral'>    function parseTomlType(string calldata toml, string calldata key, string calldata typeDescription)</span>
 1814 |     | <span class='neutral'>        external</span>
 1815 |     | <span class='neutral'>        pure</span>
 1816 |     | <span class='neutral'>        returns (bytes memory);</span>
 1817 |     | <span class='neutral'></span>
 1818 |     | <span class='neutral'>    /// Parses a string of TOML data at `key` and coerces it to `uint256`.</span>
 1819 |     | <span class='neutral'>    function parseTomlUint(string calldata toml, string calldata key) external pure returns (uint256);</span>
 1820 |     | <span class='neutral'></span>
 1821 |     | <span class='neutral'>    /// Parses a string of TOML data at `key` and coerces it to `uint256[]`.</span>
 1822 |     | <span class='neutral'>    function parseTomlUintArray(string calldata toml, string calldata key) external pure returns (uint256[] memory);</span>
 1823 |     | <span class='neutral'></span>
 1824 |     | <span class='neutral'>    /// ABI-encodes a TOML table.</span>
 1825 |     | <span class='neutral'>    function parseToml(string calldata toml) external pure returns (bytes memory abiEncodedData);</span>
 1826 |     | <span class='neutral'></span>
 1827 |     | <span class='neutral'>    /// ABI-encodes a TOML table at `key`.</span>
 1828 |     | <span class='neutral'>    function parseToml(string calldata toml, string calldata key) external pure returns (bytes memory abiEncodedData);</span>
 1829 |     | <span class='neutral'></span>
 1830 |     | <span class='neutral'>    /// Takes serialized JSON, converts to TOML and write a serialized TOML to a file.</span>
 1831 |     | <span class='neutral'>    function writeToml(string calldata json, string calldata path) external;</span>
 1832 |     | <span class='neutral'></span>
 1833 |     | <span class='neutral'>    /// Takes serialized JSON, converts to TOML and write a serialized TOML table to an **existing** TOML file, replacing a value with key = &lt;value_key.&gt;</span>
 1834 |     | <span class='neutral'>    /// This is useful to replace a specific value of a TOML file, without having to parse the entire thing.</span>
 1835 |     | <span class='neutral'>    function writeToml(string calldata json, string calldata path, string calldata valueKey) external;</span>
 1836 |     | <span class='neutral'></span>
 1837 |     | <span class='neutral'>    // ======== Utilities ========</span>
 1838 |     | <span class='neutral'></span>
 1839 |     | <span class='neutral'>    /// Compute the address of a contract created with CREATE2 using the given CREATE2 deployer.</span>
 1840 |     | <span class='neutral'>    function computeCreate2Address(bytes32 salt, bytes32 initCodeHash, address deployer)</span>
 1841 |     | <span class='neutral'>        external</span>
 1842 |     | <span class='neutral'>        pure</span>
 1843 |     | <span class='neutral'>        returns (address);</span>
 1844 |     | <span class='neutral'></span>
 1845 |     | <span class='neutral'>    /// Compute the address of a contract created with CREATE2 using the default CREATE2 deployer.</span>
 1846 |     | <span class='neutral'>    function computeCreate2Address(bytes32 salt, bytes32 initCodeHash) external pure returns (address);</span>
 1847 |     | <span class='neutral'></span>
 1848 |     | <span class='neutral'>    /// Compute the address a contract will be deployed at for a given deployer address and nonce.</span>
 1849 |     | <span class='neutral'>    function computeCreateAddress(address deployer, uint256 nonce) external pure returns (address);</span>
 1850 |     | <span class='neutral'></span>
 1851 |     | <span class='neutral'>    /// Utility cheatcode to copy storage of `from` contract to another `to` contract.</span>
 1852 |     | <span class='neutral'>    function copyStorage(address from, address to) external;</span>
 1853 |     | <span class='neutral'></span>
 1854 |     | <span class='neutral'>    /// Returns ENS namehash for provided string.</span>
 1855 |     | <span class='neutral'>    function ensNamehash(string calldata name) external pure returns (bytes32);</span>
 1856 |     | <span class='neutral'></span>
 1857 |     | <span class='neutral'>    /// Gets the label for the specified address.</span>
 1858 |     | <span class='neutral'>    function getLabel(address account) external view returns (string memory currentLabel);</span>
 1859 |     | <span class='neutral'></span>
 1860 |     | <span class='neutral'>    /// Labels an address in call traces.</span>
 1861 |     | <span class='neutral'>    function label(address account, string calldata newLabel) external;</span>
 1862 |     | <span class='neutral'></span>
 1863 |     | <span class='neutral'>    /// Pauses collection of call traces. Useful in cases when you want to skip tracing of</span>
 1864 |     | <span class='neutral'>    /// complex calls which are not useful for debugging.</span>
 1865 |     | <span class='neutral'>    function pauseTracing() external view;</span>
 1866 |     | <span class='neutral'></span>
 1867 |     | <span class='neutral'>    /// Returns a random `address`.</span>
 1868 |     | <span class='neutral'>    function randomAddress() external returns (address);</span>
 1869 |     | <span class='neutral'></span>
 1870 |     | <span class='neutral'>    /// Returns a random `bool`.</span>
 1871 |     | <span class='neutral'>    function randomBool() external view returns (bool);</span>
 1872 |     | <span class='neutral'></span>
 1873 |     | <span class='neutral'>    /// Returns a random byte array value of the given length.</span>
 1874 |     | <span class='neutral'>    function randomBytes(uint256 len) external view returns (bytes memory);</span>
 1875 |     | <span class='neutral'></span>
 1876 |     | <span class='neutral'>    /// Returns a random fixed-size byte array of length 4.</span>
 1877 |     | <span class='neutral'>    function randomBytes4() external view returns (bytes4);</span>
 1878 |     | <span class='neutral'></span>
 1879 |     | <span class='neutral'>    /// Returns a random fixed-size byte array of length 8.</span>
 1880 |     | <span class='neutral'>    function randomBytes8() external view returns (bytes8);</span>
 1881 |     | <span class='neutral'></span>
 1882 |     | <span class='neutral'>    /// Returns a random `int256` value.</span>
 1883 |     | <span class='neutral'>    function randomInt() external view returns (int256);</span>
 1884 |     | <span class='neutral'></span>
 1885 |     | <span class='neutral'>    /// Returns a random `int256` value of given bits.</span>
 1886 |     | <span class='neutral'>    function randomInt(uint256 bits) external view returns (int256);</span>
 1887 |     | <span class='neutral'></span>
 1888 |     | <span class='neutral'>    /// Returns a random uint256 value.</span>
 1889 |     | <span class='neutral'>    function randomUint() external returns (uint256);</span>
 1890 |     | <span class='neutral'></span>
 1891 |     | <span class='neutral'>    /// Returns random uint256 value between the provided range (=min..=max).</span>
 1892 |     | <span class='neutral'>    function randomUint(uint256 min, uint256 max) external returns (uint256);</span>
 1893 |     | <span class='neutral'></span>
 1894 |     | <span class='neutral'>    /// Returns a random `uint256` value of given bits.</span>
 1895 |     | <span class='neutral'>    function randomUint(uint256 bits) external view returns (uint256);</span>
 1896 |     | <span class='neutral'></span>
 1897 |     | <span class='neutral'>    /// Unpauses collection of call traces.</span>
 1898 |     | <span class='neutral'>    function resumeTracing() external view;</span>
 1899 |     | <span class='neutral'></span>
 1900 |     | <span class='neutral'>    /// Utility cheatcode to set arbitrary storage for given target address.</span>
 1901 |     | <span class='neutral'>    function setArbitraryStorage(address target) external;</span>
 1902 |     | <span class='neutral'></span>
 1903 |     | <span class='neutral'>    /// Utility cheatcode to set arbitrary storage for given target address and overwrite</span>
 1904 |     | <span class='neutral'>    /// any storage slots that have been previously set.</span>
 1905 |     | <span class='neutral'>    function setArbitraryStorage(address target, bool overwrite) external;</span>
 1906 |     | <span class='neutral'></span>
 1907 |     | <span class='neutral'>    /// Randomly shuffles an array.</span>
 1908 |     | <span class='neutral'>    function shuffle(uint256[] calldata array) external returns (uint256[] memory);</span>
 1909 |     | <span class='neutral'></span>
 1910 |     | <span class='neutral'>    /// Sorts an array in ascending order.</span>
 1911 |     | <span class='neutral'>    function sort(uint256[] calldata array) external returns (uint256[] memory);</span>
 1912 |     | <span class='neutral'></span>
 1913 |     | <span class='neutral'>    /// Encodes a `bytes` value to a base64url string.</span>
 1914 |     | <span class='neutral'>    function toBase64URL(bytes calldata data) external pure returns (string memory);</span>
 1915 |     | <span class='neutral'></span>
 1916 |     | <span class='neutral'>    /// Encodes a `string` value to a base64url string.</span>
 1917 |     | <span class='neutral'>    function toBase64URL(string calldata data) external pure returns (string memory);</span>
 1918 |     | <span class='neutral'></span>
 1919 |     | <span class='neutral'>    /// Encodes a `bytes` value to a base64 string.</span>
 1920 |     | <span class='neutral'>    function toBase64(bytes calldata data) external pure returns (string memory);</span>
 1921 |     | <span class='neutral'></span>
 1922 |     | <span class='neutral'>    /// Encodes a `string` value to a base64 string.</span>
 1923 |     | <span class='neutral'>    function toBase64(string calldata data) external pure returns (string memory);</span>
 1924 |     | <span class='neutral'></span>
 1925 |     | <span class='neutral'>    // Generates the hash of the canonical EIP-712 type representation.</span>
 1926 |     | <span class='neutral'>    //</span>
 1927 |     | <span class='neutral'>    // Supports 2 different inputs:</span>
 1928 |     | <span class='neutral'>    //  1. Name of the type (i.e. &quot;Transaction&quot;):</span>
 1929 |     | <span class='neutral'>    //     * requires previous binding generation with `forge bind-json`.</span>
 1930 |     | <span class='neutral'>    //     * bindings will be retrieved from the path configured in `foundry.toml`.</span>
 1931 |     | <span class='neutral'>    //</span>
 1932 |     | <span class='neutral'>    //  2. String representation of the type (i.e. &quot;Foo(Bar bar) Bar(uint256 baz)&quot;).</span>
 1933 |     | <span class='neutral'>    //     * Note: the cheatcode will output the canonical type even if the input is malformated</span>
 1934 |     | <span class='neutral'>    //             with the wrong order of elements or with extra whitespaces.</span>
 1935 |     | <span class='neutral'>    function eip712HashType(string calldata typeNameOrDefinition) external pure returns (bytes32 typeHash);</span>
 1936 |     | <span class='neutral'></span>
 1937 |     | <span class='neutral'>    // Generates the hash of the canonical EIP-712 type representation.</span>
 1938 |     | <span class='neutral'>    // Requires previous binding generation with `forge bind-json`.</span>
 1939 |     | <span class='neutral'>    //</span>
 1940 |     | <span class='neutral'>    // Params:</span>
 1941 |     | <span class='neutral'>    //  * `bindingsPath`: path where the output of `forge bind-json` is stored.</span>
 1942 |     | <span class='neutral'>    //  * `typeName`: Name of the type (i.e. &quot;Transaction&quot;).</span>
 1943 |     | <span class='neutral'>    function eip712HashType(string calldata bindingsPath, string calldata typeName)</span>
 1944 |     | <span class='neutral'>        external</span>
 1945 |     | <span class='neutral'>        pure</span>
 1946 |     | <span class='neutral'>        returns (bytes32 typeHash);</span>
 1947 |     | <span class='neutral'></span>
 1948 |     | <span class='neutral'>    // Generates the struct hash of the canonical EIP-712 type representation and its abi-encoded data.</span>
 1949 |     | <span class='neutral'>    //</span>
 1950 |     | <span class='neutral'>    // Supports 2 different inputs:</span>
 1951 |     | <span class='neutral'>    //  1. Name of the type (i.e. &quot;PermitSingle&quot;):</span>
 1952 |     | <span class='neutral'>    //     * requires previous binding generation with `forge bind-json`.</span>
 1953 |     | <span class='neutral'>    //     * bindings will be retrieved from the path configured in `foundry.toml`.</span>
 1954 |     | <span class='neutral'>    //</span>
 1955 |     | <span class='neutral'>    //  2. String representation of the type (i.e. &quot;Foo(Bar bar) Bar(uint256 baz)&quot;).</span>
 1956 |     | <span class='neutral'>    //     * Note: the cheatcode will use the canonical type even if the input is malformated</span>
 1957 |     | <span class='neutral'>    //             with the wrong order of elements or with extra whitespaces.</span>
 1958 |     | <span class='neutral'>    function eip712HashStruct(string calldata typeNameOrDefinition, bytes calldata abiEncodedData)</span>
 1959 |     | <span class='neutral'>        external</span>
 1960 |     | <span class='neutral'>        pure</span>
 1961 |     | <span class='neutral'>        returns (bytes32 typeHash);</span>
 1962 |     | <span class='neutral'></span>
 1963 |     | <span class='neutral'>    // Generates the struct hash of the canonical EIP-712 type representation and its abi-encoded data.</span>
 1964 |     | <span class='neutral'>    // Requires previous binding generation with `forge bind-json`.</span>
 1965 |     | <span class='neutral'>    //</span>
 1966 |     | <span class='neutral'>    // Params:</span>
 1967 |     | <span class='neutral'>    //  * `bindingsPath`: path where the output of `forge bind-json` is stored.</span>
 1968 |     | <span class='neutral'>    //  * `typeName`: Name of the type (i.e. &quot;PermitSingle&quot;).</span>
 1969 |     | <span class='neutral'>    //  * `abiEncodedData`: ABI-encoded data for the struct that is being hashed.</span>
 1970 |     | <span class='neutral'>    function eip712HashStruct(string calldata bindingsPath, string calldata typeName, bytes calldata abiEncodedData)</span>
 1971 |     | <span class='neutral'>        external</span>
 1972 |     | <span class='neutral'>        pure</span>
 1973 |     | <span class='neutral'>        returns (bytes32 typeHash);</span>
 1974 |     | <span class='neutral'></span>
 1975 |     | <span class='neutral'>    // Generates a ready-to-sign digest of human-readable typed data following the EIP-712 standard.</span>
 1976 |     | <span class='neutral'>    function eip712HashTypedData(string calldata jsonData) external pure returns (bytes32 digest);</span>
 1977 |     | <span class='neutral'>}</span>
 1978 |     | <span class='neutral'></span>
 1979 |     | <span class='neutral'>/// The `Vm` interface does allow manipulation of the EVM state. These are all intended to be used</span>
 1980 |     | <span class='neutral'>/// in tests, but it is not recommended to use these cheats in scripts.</span>
 1981 |     | <span class='neutral'>interface Vm is VmSafe {</span>
 1982 |     | <span class='neutral'>    // ======== EVM ========</span>
 1983 |     | <span class='neutral'></span>
 1984 |     | <span class='neutral'>    /// Utility cheatcode to set an EIP-2930 access list for all subsequent transactions.</span>
 1985 |     | <span class='neutral'>    function accessList(AccessListItem[] calldata access) external;</span>
 1986 |     | <span class='neutral'></span>
 1987 |     | <span class='neutral'>    /// Returns the identifier of the currently active fork. Reverts if no fork is currently active.</span>
 1988 |     | <span class='neutral'>    function activeFork() external view returns (uint256 forkId);</span>
 1989 |     | <span class='neutral'></span>
 1990 |     | <span class='neutral'>    /// In forking mode, explicitly grant the given address cheatcode access.</span>
 1991 |     | <span class='neutral'>    function allowCheatcodes(address account) external;</span>
 1992 |     | <span class='neutral'></span>
 1993 |     | <span class='neutral'>    /// Sets `block.blobbasefee`</span>
 1994 |     | <span class='neutral'>    function blobBaseFee(uint256 newBlobBaseFee) external;</span>
 1995 |     | <span class='neutral'></span>
 1996 |     | <span class='neutral'>    /// Sets the blobhashes in the transaction.</span>
 1997 |     | <span class='neutral'>    /// Not available on EVM versions before Cancun.</span>
 1998 |     | <span class='neutral'>    /// If used on unsupported EVM versions it will revert.</span>
 1999 |     | <span class='neutral'>    function blobhashes(bytes32[] calldata hashes) external;</span>
 2000 |     | <span class='neutral'></span>
 2001 |     | <span class='neutral'>    /// Sets `block.chainid`.</span>
 2002 |     | <span class='neutral'>    function chainId(uint256 newChainId) external;</span>
 2003 |     | <span class='neutral'></span>
 2004 |     | <span class='neutral'>    /// Clears all mocked calls.</span>
 2005 |     | <span class='neutral'>    function clearMockedCalls() external;</span>
 2006 |     | <span class='neutral'></span>
 2007 |     | <span class='neutral'>    /// Clones a source account code, state, balance and nonce to a target account and updates in-memory EVM state.</span>
 2008 |     | <span class='neutral'>    function cloneAccount(address source, address target) external;</span>
 2009 |     | <span class='neutral'></span>
 2010 |     | <span class='neutral'>    /// Sets `block.coinbase`.</span>
 2011 |     | <span class='neutral'>    function coinbase(address newCoinbase) external;</span>
 2012 |     | <span class='neutral'></span>
 2013 |     | <span class='neutral'>    /// Marks the slots of an account and the account address as cold.</span>
 2014 |     | <span class='neutral'>    function cool(address target) external;</span>
 2015 |     | <span class='neutral'></span>
 2016 |     | <span class='neutral'>    /// Utility cheatcode to mark specific storage slot as cold, simulating no prior read.</span>
 2017 |     | <span class='neutral'>    function coolSlot(address target, bytes32 slot) external;</span>
 2018 |     | <span class='neutral'></span>
 2019 |     | <span class='neutral'>    /// Creates a new fork with the given endpoint and the _latest_ block and returns the identifier of the fork.</span>
 2020 |     | <span class='neutral'>    function createFork(string calldata urlOrAlias) external returns (uint256 forkId);</span>
 2021 |     | <span class='neutral'></span>
 2022 |     | <span class='neutral'>    /// Creates a new fork with the given endpoint and block and returns the identifier of the fork.</span>
 2023 |     | <span class='neutral'>    function createFork(string calldata urlOrAlias, uint256 blockNumber) external returns (uint256 forkId);</span>
 2024 |     | <span class='neutral'></span>
 2025 |     | <span class='neutral'>    /// Creates a new fork with the given endpoint and at the block the given transaction was mined in,</span>
 2026 |     | <span class='neutral'>    /// replays all transaction mined in the block before the transaction, and returns the identifier of the fork.</span>
 2027 |     | <span class='neutral'>    function createFork(string calldata urlOrAlias, bytes32 txHash) external returns (uint256 forkId);</span>
 2028 |     | <span class='neutral'></span>
 2029 |     | <span class='neutral'>    /// Creates and also selects a new fork with the given endpoint and the latest block and returns the identifier of the fork.</span>
 2030 |     | <span class='neutral'>    function createSelectFork(string calldata urlOrAlias) external returns (uint256 forkId);</span>
 2031 |     | <span class='neutral'></span>
 2032 |     | <span class='neutral'>    /// Creates and also selects a new fork with the given endpoint and block and returns the identifier of the fork.</span>
 2033 |     | <span class='neutral'>    function createSelectFork(string calldata urlOrAlias, uint256 blockNumber) external returns (uint256 forkId);</span>
 2034 |     | <span class='neutral'></span>
 2035 |     | <span class='neutral'>    /// Creates and also selects new fork with the given endpoint and at the block the given transaction was mined in,</span>
 2036 |     | <span class='neutral'>    /// replays all transaction mined in the block before the transaction, returns the identifier of the fork.</span>
 2037 |     | <span class='neutral'>    function createSelectFork(string calldata urlOrAlias, bytes32 txHash) external returns (uint256 forkId);</span>
 2038 |     | <span class='neutral'></span>
 2039 |     | <span class='neutral'>    /// Sets an address&#39; balance.</span>
 2040 |     | <span class='neutral'>    function deal(address account, uint256 newBalance) external;</span>
 2041 |     | <span class='neutral'></span>
 2042 |     | <span class='neutral'>    /// Removes the snapshot with the given ID created by `snapshot`.</span>
 2043 |     | <span class='neutral'>    /// Takes the snapshot ID to delete.</span>
 2044 |     | <span class='neutral'>    /// Returns `true` if the snapshot was successfully deleted.</span>
 2045 |     | <span class='neutral'>    /// Returns `false` if the snapshot does not exist.</span>
 2046 |     | <span class='neutral'>    function deleteStateSnapshot(uint256 snapshotId) external returns (bool success);</span>
 2047 |     | <span class='neutral'></span>
 2048 |     | <span class='neutral'>    /// Removes _all_ snapshots previously created by `snapshot`.</span>
 2049 |     | <span class='neutral'>    function deleteStateSnapshots() external;</span>
 2050 |     | <span class='neutral'></span>
 2051 |     | <span class='neutral'>    /// Sets `block.difficulty`.</span>
 2052 |     | <span class='neutral'>    /// Not available on EVM versions from Paris onwards. Use `prevrandao` instead.</span>
 2053 |     | <span class='neutral'>    /// Reverts if used on unsupported EVM versions.</span>
 2054 |     | <span class='neutral'>    function difficulty(uint256 newDifficulty) external;</span>
 2055 |     | <span class='neutral'></span>
 2056 |     | <span class='neutral'>    /// Dump a genesis JSON file&#39;s `allocs` to disk.</span>
 2057 |     | <span class='neutral'>    function dumpState(string calldata pathToStateJson) external;</span>
 2058 |     | <span class='neutral'></span>
 2059 |     | <span class='neutral'>    /// Sets an address&#39; code.</span>
 2060 |     | <span class='neutral'>    function etch(address target, bytes calldata newRuntimeBytecode) external;</span>
 2061 |     | <span class='neutral'></span>
 2062 |     | <span class='neutral'>    /// Sets `block.basefee`.</span>
 2063 |     | <span class='neutral'>    function fee(uint256 newBasefee) external;</span>
 2064 |     | <span class='neutral'></span>
 2065 |     | <span class='neutral'>    /// Gets the blockhashes from the current transaction.</span>
 2066 |     | <span class='neutral'>    /// Not available on EVM versions before Cancun.</span>
 2067 |     | <span class='neutral'>    /// If used on unsupported EVM versions it will revert.</span>
 2068 |     | <span class='neutral'>    function getBlobhashes() external view returns (bytes32[] memory hashes);</span>
 2069 |     | <span class='neutral'></span>
 2070 |     | <span class='neutral'>    /// Returns true if the account is marked as persistent.</span>
 2071 |     | <span class='neutral'>    function isPersistent(address account) external view returns (bool persistent);</span>
 2072 |     | <span class='neutral'></span>
 2073 |     | <span class='neutral'>    /// Load a genesis JSON file&#39;s `allocs` into the in-memory EVM state.</span>
 2074 |     | <span class='neutral'>    function loadAllocs(string calldata pathToAllocsJson) external;</span>
 2075 |     | <span class='neutral'></span>
 2076 |     | <span class='neutral'>    /// Marks that the account(s) should use persistent storage across fork swaps in a multifork setup</span>
 2077 |     | <span class='neutral'>    /// Meaning, changes made to the state of this account will be kept when switching forks.</span>
 2078 |     | <span class='neutral'>    function makePersistent(address account) external;</span>
 2079 |     | <span class='neutral'></span>
 2080 |     | <span class='neutral'>    /// See `makePersistent(address)`.</span>
 2081 |     | <span class='neutral'>    function makePersistent(address account0, address account1) external;</span>
 2082 |     | <span class='neutral'></span>
 2083 |     | <span class='neutral'>    /// See `makePersistent(address)`.</span>
 2084 |     | <span class='neutral'>    function makePersistent(address account0, address account1, address account2) external;</span>
 2085 |     | <span class='neutral'></span>
 2086 |     | <span class='neutral'>    /// See `makePersistent(address)`.</span>
 2087 |     | <span class='neutral'>    function makePersistent(address[] calldata accounts) external;</span>
 2088 |     | <span class='neutral'></span>
 2089 |     | <span class='neutral'>    /// Reverts a call to an address with specified revert data.</span>
 2090 |     | <span class='neutral'>    function mockCallRevert(address callee, bytes calldata data, bytes calldata revertData) external;</span>
 2091 |     | <span class='neutral'></span>
 2092 |     | <span class='neutral'>    /// Reverts a call to an address with a specific `msg.value`, with specified revert data.</span>
 2093 |     | <span class='neutral'>    function mockCallRevert(address callee, uint256 msgValue, bytes calldata data, bytes calldata revertData)</span>
 2094 |     | <span class='neutral'>        external;</span>
 2095 |     | <span class='neutral'></span>
 2096 |     | <span class='neutral'>    /// Reverts a call to an address with specified revert data.</span>
 2097 |     | <span class='neutral'>    /// Overload to pass the function selector directly `token.approve.selector` instead of `abi.encodeWithSelector(token.approve.selector)`.</span>
 2098 |     | <span class='neutral'>    function mockCallRevert(address callee, bytes4 data, bytes calldata revertData) external;</span>
 2099 |     | <span class='neutral'></span>
 2100 |     | <span class='neutral'>    /// Reverts a call to an address with a specific `msg.value`, with specified revert data.</span>
 2101 |     | <span class='neutral'>    /// Overload to pass the function selector directly `token.approve.selector` instead of `abi.encodeWithSelector(token.approve.selector)`.</span>
 2102 |     | <span class='neutral'>    function mockCallRevert(address callee, uint256 msgValue, bytes4 data, bytes calldata revertData) external;</span>
 2103 |     | <span class='neutral'></span>
 2104 |     | <span class='neutral'>    /// Mocks a call to an address, returning specified data.</span>
 2105 |     | <span class='neutral'>    /// Calldata can either be strict or a partial match, e.g. if you only</span>
 2106 |     | <span class='neutral'>    /// pass a Solidity selector to the expected calldata, then the entire Solidity</span>
 2107 |     | <span class='neutral'>    /// function will be mocked.</span>
 2108 |     | <span class='neutral'>    function mockCall(address callee, bytes calldata data, bytes calldata returnData) external;</span>
 2109 |     | <span class='neutral'></span>
 2110 |     | <span class='neutral'>    /// Mocks a call to an address with a specific `msg.value`, returning specified data.</span>
 2111 |     | <span class='neutral'>    /// Calldata match takes precedence over `msg.value` in case of ambiguity.</span>
 2112 |     | <span class='neutral'>    function mockCall(address callee, uint256 msgValue, bytes calldata data, bytes calldata returnData) external;</span>
 2113 |     | <span class='neutral'></span>
 2114 |     | <span class='neutral'>    /// Mocks a call to an address, returning specified data.</span>
 2115 |     | <span class='neutral'>    /// Calldata can either be strict or a partial match, e.g. if you only</span>
 2116 |     | <span class='neutral'>    /// pass a Solidity selector to the expected calldata, then the entire Solidity</span>
 2117 |     | <span class='neutral'>    /// function will be mocked.</span>
 2118 |     | <span class='neutral'>    /// Overload to pass the function selector directly `token.approve.selector` instead of `abi.encodeWithSelector(token.approve.selector)`.</span>
 2119 |     | <span class='neutral'>    function mockCall(address callee, bytes4 data, bytes calldata returnData) external;</span>
 2120 |     | <span class='neutral'></span>
 2121 |     | <span class='neutral'>    /// Mocks a call to an address with a specific `msg.value`, returning specified data.</span>
 2122 |     | <span class='neutral'>    /// Calldata match takes precedence over `msg.value` in case of ambiguity.</span>
 2123 |     | <span class='neutral'>    /// Overload to pass the function selector directly `token.approve.selector` instead of `abi.encodeWithSelector(token.approve.selector)`.</span>
 2124 |     | <span class='neutral'>    function mockCall(address callee, uint256 msgValue, bytes4 data, bytes calldata returnData) external;</span>
 2125 |     | <span class='neutral'></span>
 2126 |     | <span class='neutral'>    /// Mocks multiple calls to an address, returning specified data for each call.</span>
 2127 |     | <span class='neutral'>    function mockCalls(address callee, bytes calldata data, bytes[] calldata returnData) external;</span>
 2128 |     | <span class='neutral'></span>
 2129 |     | <span class='neutral'>    /// Mocks multiple calls to an address with a specific `msg.value`, returning specified data for each call.</span>
 2130 |     | <span class='neutral'>    function mockCalls(address callee, uint256 msgValue, bytes calldata data, bytes[] calldata returnData) external;</span>
 2131 |     | <span class='neutral'></span>
 2132 |     | <span class='neutral'>    /// Whenever a call is made to `callee` with calldata `data`, this cheatcode instead calls</span>
 2133 |     | <span class='neutral'>    /// `target` with the same calldata. This functionality is similar to a delegate call made to</span>
 2134 |     | <span class='neutral'>    /// `target` contract from `callee`.</span>
 2135 |     | <span class='neutral'>    /// Can be used to substitute a call to a function with another implementation that captures</span>
 2136 |     | <span class='neutral'>    /// the primary logic of the original function but is easier to reason about.</span>
 2137 |     | <span class='neutral'>    /// If calldata is not a strict match then partial match by selector is attempted.</span>
 2138 |     | <span class='neutral'>    function mockFunction(address callee, address target, bytes calldata data) external;</span>
 2139 |     | <span class='neutral'></span>
 2140 |     | <span class='neutral'>    /// Utility cheatcode to remove any EIP-2930 access list set by `accessList` cheatcode.</span>
 2141 |     | <span class='neutral'>    function noAccessList() external;</span>
 2142 |     | <span class='neutral'></span>
 2143 |     | <span class='neutral'>    /// Sets the *next* call&#39;s `msg.sender` to be the input address.</span>
 2144 |     | <span class='neutral'>    function prank(address msgSender) external;</span>
 2145 |     | <span class='neutral'></span>
 2146 |     | <span class='neutral'>    /// Sets the *next* call&#39;s `msg.sender` to be the input address, and the `tx.origin` to be the second input.</span>
 2147 |     | <span class='neutral'>    function prank(address msgSender, address txOrigin) external;</span>
 2148 |     | <span class='neutral'></span>
 2149 |     | <span class='neutral'>    /// Sets the *next* delegate call&#39;s `msg.sender` to be the input address.</span>
 2150 |     | <span class='neutral'>    function prank(address msgSender, bool delegateCall) external;</span>
 2151 |     | <span class='neutral'></span>
 2152 |     | <span class='neutral'>    /// Sets the *next* delegate call&#39;s `msg.sender` to be the input address, and the `tx.origin` to be the second input.</span>
 2153 |     | <span class='neutral'>    function prank(address msgSender, address txOrigin, bool delegateCall) external;</span>
 2154 |     | <span class='neutral'></span>
 2155 |     | <span class='neutral'>    /// Sets `block.prevrandao`.</span>
 2156 |     | <span class='neutral'>    /// Not available on EVM versions before Paris. Use `difficulty` instead.</span>
 2157 |     | <span class='neutral'>    /// If used on unsupported EVM versions it will revert.</span>
 2158 |     | <span class='neutral'>    function prevrandao(bytes32 newPrevrandao) external;</span>
 2159 |     | <span class='neutral'></span>
 2160 |     | <span class='neutral'>    /// Sets `block.prevrandao`.</span>
 2161 |     | <span class='neutral'>    /// Not available on EVM versions before Paris. Use `difficulty` instead.</span>
 2162 |     | <span class='neutral'>    /// If used on unsupported EVM versions it will revert.</span>
 2163 |     | <span class='neutral'>    function prevrandao(uint256 newPrevrandao) external;</span>
 2164 |     | <span class='neutral'></span>
 2165 |     | <span class='neutral'>    /// Reads the current `msg.sender` and `tx.origin` from state and reports if there is any active caller modification.</span>
 2166 |     | <span class='neutral'>    function readCallers() external returns (CallerMode callerMode, address msgSender, address txOrigin);</span>
 2167 |     | <span class='neutral'></span>
 2168 |     | <span class='neutral'>    /// Resets the nonce of an account to 0 for EOAs and 1 for contract accounts.</span>
 2169 |     | <span class='neutral'>    function resetNonce(address account) external;</span>
 2170 |     | <span class='neutral'></span>
 2171 |     | <span class='neutral'>    /// Revert the state of the EVM to a previous snapshot</span>
 2172 |     | <span class='neutral'>    /// Takes the snapshot ID to revert to.</span>
 2173 |     | <span class='neutral'>    /// Returns `true` if the snapshot was successfully reverted.</span>
 2174 |     | <span class='neutral'>    /// Returns `false` if the snapshot does not exist.</span>
 2175 |     | <span class='neutral'>    /// **Note:** This does not automatically delete the snapshot. To delete the snapshot use `deleteStateSnapshot`.</span>
 2176 |     | <span class='neutral'>    function revertToState(uint256 snapshotId) external returns (bool success);</span>
 2177 |     | <span class='neutral'></span>
 2178 |     | <span class='neutral'>    /// Revert the state of the EVM to a previous snapshot and automatically deletes the snapshots</span>
 2179 |     | <span class='neutral'>    /// Takes the snapshot ID to revert to.</span>
 2180 |     | <span class='neutral'>    /// Returns `true` if the snapshot was successfully reverted and deleted.</span>
 2181 |     | <span class='neutral'>    /// Returns `false` if the snapshot does not exist.</span>
 2182 |     | <span class='neutral'>    function revertToStateAndDelete(uint256 snapshotId) external returns (bool success);</span>
 2183 |     | <span class='neutral'></span>
 2184 |     | <span class='neutral'>    /// Revokes persistent status from the address, previously added via `makePersistent`.</span>
 2185 |     | <span class='neutral'>    function revokePersistent(address account) external;</span>
 2186 |     | <span class='neutral'></span>
 2187 |     | <span class='neutral'>    /// See `revokePersistent(address)`.</span>
 2188 |     | <span class='neutral'>    function revokePersistent(address[] calldata accounts) external;</span>
 2189 |     | <span class='neutral'></span>
 2190 |     | <span class='neutral'>    /// Sets `block.height`.</span>
 2191 |     | <span class='neutral'>    function roll(uint256 newHeight) external;</span>
 2192 |     | <span class='neutral'></span>
 2193 |     | <span class='neutral'>    /// Updates the currently active fork to given block number</span>
 2194 |     | <span class='neutral'>    /// This is similar to `roll` but for the currently active fork.</span>
 2195 |     | <span class='neutral'>    function rollFork(uint256 blockNumber) external;</span>
 2196 |     | <span class='neutral'></span>
 2197 |     | <span class='neutral'>    /// Updates the currently active fork to given transaction. This will `rollFork` with the number</span>
 2198 |     | <span class='neutral'>    /// of the block the transaction was mined in and replays all transaction mined before it in the block.</span>
 2199 |     | <span class='neutral'>    function rollFork(bytes32 txHash) external;</span>
 2200 |     | <span class='neutral'></span>
 2201 |     | <span class='neutral'>    /// Updates the given fork to given block number.</span>
 2202 |     | <span class='neutral'>    function rollFork(uint256 forkId, uint256 blockNumber) external;</span>
 2203 |     | <span class='neutral'></span>
 2204 |     | <span class='neutral'>    /// Updates the given fork to block number of the given transaction and replays all transaction mined before it in the block.</span>
 2205 |     | <span class='neutral'>    function rollFork(uint256 forkId, bytes32 txHash) external;</span>
 2206 |     | <span class='neutral'></span>
 2207 |     | <span class='neutral'>    /// Takes a fork identifier created by `createFork` and sets the corresponding forked state as active.</span>
 2208 |     | <span class='neutral'>    function selectFork(uint256 forkId) external;</span>
 2209 |     | <span class='neutral'></span>
 2210 |     | <span class='neutral'>    /// Set blockhash for the current block.</span>
 2211 |     | <span class='neutral'>    /// It only sets the blockhash for blocks where `block.number - 256 &lt;= number &lt; block.number`.</span>
 2212 |     | <span class='neutral'>    function setBlockhash(uint256 blockNumber, bytes32 blockHash) external;</span>
 2213 |     | <span class='neutral'></span>
 2214 |     | <span class='neutral'>    /// Sets the nonce of an account. Must be higher than the current nonce of the account.</span>
 2215 |     | <span class='neutral'>    function setNonce(address account, uint64 newNonce) external;</span>
 2216 |     | <span class='neutral'></span>
 2217 |     | <span class='neutral'>    /// Sets the nonce of an account to an arbitrary value.</span>
 2218 |     | <span class='neutral'>    function setNonceUnsafe(address account, uint64 newNonce) external;</span>
 2219 |     | <span class='neutral'></span>
 2220 |     | <span class='neutral'>    /// Snapshot capture the gas usage of the last call by name from the callee perspective.</span>
 2221 |     | <span class='neutral'>    function snapshotGasLastCall(string calldata name) external returns (uint256 gasUsed);</span>
 2222 |     | <span class='neutral'></span>
 2223 |     | <span class='neutral'>    /// Snapshot capture the gas usage of the last call by name in a group from the callee perspective.</span>
 2224 |     | <span class='neutral'>    function snapshotGasLastCall(string calldata group, string calldata name) external returns (uint256 gasUsed);</span>
 2225 |     | <span class='neutral'></span>
 2226 |     | <span class='neutral'>    /// Snapshot the current state of the evm.</span>
 2227 |     | <span class='neutral'>    /// Returns the ID of the snapshot that was created.</span>
 2228 |     | <span class='neutral'>    /// To revert a snapshot use `revertToState`.</span>
 2229 |     | <span class='neutral'>    function snapshotState() external returns (uint256 snapshotId);</span>
 2230 |     | <span class='neutral'></span>
 2231 |     | <span class='neutral'>    /// Snapshot capture an arbitrary numerical value by name.</span>
 2232 |     | <span class='neutral'>    /// The group name is derived from the contract name.</span>
 2233 |     | <span class='neutral'>    function snapshotValue(string calldata name, uint256 value) external;</span>
 2234 |     | <span class='neutral'></span>
 2235 |     | <span class='neutral'>    /// Snapshot capture an arbitrary numerical value by name in a group.</span>
 2236 |     | <span class='neutral'>    function snapshotValue(string calldata group, string calldata name, uint256 value) external;</span>
 2237 |     | <span class='neutral'></span>
 2238 |     | <span class='neutral'>    /// Sets all subsequent calls&#39; `msg.sender` to be the input address until `stopPrank` is called.</span>
 2239 |     | <span class='neutral'>    function startPrank(address msgSender) external;</span>
 2240 |     | <span class='neutral'></span>
 2241 |     | <span class='neutral'>    /// Sets all subsequent calls&#39; `msg.sender` to be the input address until `stopPrank` is called, and the `tx.origin` to be the second input.</span>
 2242 |     | <span class='neutral'>    function startPrank(address msgSender, address txOrigin) external;</span>
 2243 |     | <span class='neutral'></span>
 2244 |     | <span class='neutral'>    /// Sets all subsequent delegate calls&#39; `msg.sender` to be the input address until `stopPrank` is called.</span>
 2245 |     | <span class='neutral'>    function startPrank(address msgSender, bool delegateCall) external;</span>
 2246 |     | <span class='neutral'></span>
 2247 |     | <span class='neutral'>    /// Sets all subsequent delegate calls&#39; `msg.sender` to be the input address until `stopPrank` is called, and the `tx.origin` to be the second input.</span>
 2248 |     | <span class='neutral'>    function startPrank(address msgSender, address txOrigin, bool delegateCall) external;</span>
 2249 |     | <span class='neutral'></span>
 2250 |     | <span class='neutral'>    /// Start a snapshot capture of the current gas usage by name.</span>
 2251 |     | <span class='neutral'>    /// The group name is derived from the contract name.</span>
 2252 |     | <span class='neutral'>    function startSnapshotGas(string calldata name) external;</span>
 2253 |     | <span class='neutral'></span>
 2254 |     | <span class='neutral'>    /// Start a snapshot capture of the current gas usage by name in a group.</span>
 2255 |     | <span class='neutral'>    function startSnapshotGas(string calldata group, string calldata name) external;</span>
 2256 |     | <span class='neutral'></span>
 2257 |     | <span class='neutral'>    /// Resets subsequent calls&#39; `msg.sender` to be `address(this)`.</span>
 2258 |     | <span class='neutral'>    function stopPrank() external;</span>
 2259 |     | <span class='neutral'></span>
 2260 |     | <span class='neutral'>    /// Stop the snapshot capture of the current gas by latest snapshot name, capturing the gas used since the start.</span>
 2261 |     | <span class='neutral'>    function stopSnapshotGas() external returns (uint256 gasUsed);</span>
 2262 |     | <span class='neutral'></span>
 2263 |     | <span class='neutral'>    /// Stop the snapshot capture of the current gas usage by name, capturing the gas used since the start.</span>
 2264 |     | <span class='neutral'>    /// The group name is derived from the contract name.</span>
 2265 |     | <span class='neutral'>    function stopSnapshotGas(string calldata name) external returns (uint256 gasUsed);</span>
 2266 |     | <span class='neutral'></span>
 2267 |     | <span class='neutral'>    /// Stop the snapshot capture of the current gas usage by name in a group, capturing the gas used since the start.</span>
 2268 |     | <span class='neutral'>    function stopSnapshotGas(string calldata group, string calldata name) external returns (uint256 gasUsed);</span>
 2269 |     | <span class='neutral'></span>
 2270 |     | <span class='neutral'>    /// Stores a value to an address&#39; storage slot.</span>
 2271 |     | <span class='neutral'>    function store(address target, bytes32 slot, bytes32 value) external;</span>
 2272 |     | <span class='neutral'></span>
 2273 |     | <span class='neutral'>    /// Fetches the given transaction from the active fork and executes it on the current state.</span>
 2274 |     | <span class='neutral'>    function transact(bytes32 txHash) external;</span>
 2275 |     | <span class='neutral'></span>
 2276 |     | <span class='neutral'>    /// Fetches the given transaction from the given fork and executes it on the current state.</span>
 2277 |     | <span class='neutral'>    function transact(uint256 forkId, bytes32 txHash) external;</span>
 2278 |     | <span class='neutral'></span>
 2279 |     | <span class='neutral'>    /// Sets `tx.gasprice`.</span>
 2280 |     | <span class='neutral'>    function txGasPrice(uint256 newGasPrice) external;</span>
 2281 |     | <span class='neutral'></span>
 2282 |     | <span class='neutral'>    /// Utility cheatcode to mark specific storage slot as warm, simulating a prior read.</span>
 2283 |     | <span class='neutral'>    function warmSlot(address target, bytes32 slot) external;</span>
 2284 |     | <span class='neutral'></span>
 2285 |     | <span class='neutral'>    /// Sets `block.timestamp`.</span>
 2286 |     | <span class='neutral'>    function warp(uint256 newTimestamp) external;</span>
 2287 |     | <span class='neutral'></span>
 2288 |     | <span class='neutral'>    /// `deleteSnapshot` is being deprecated in favor of `deleteStateSnapshot`. It will be removed in future versions.</span>
 2289 |     | <span class='neutral'>    function deleteSnapshot(uint256 snapshotId) external returns (bool success);</span>
 2290 |     | <span class='neutral'></span>
 2291 |     | <span class='neutral'>    /// `deleteSnapshots` is being deprecated in favor of `deleteStateSnapshots`. It will be removed in future versions.</span>
 2292 |     | <span class='neutral'>    function deleteSnapshots() external;</span>
 2293 |     | <span class='neutral'></span>
 2294 |     | <span class='neutral'>    /// `revertToAndDelete` is being deprecated in favor of `revertToStateAndDelete`. It will be removed in future versions.</span>
 2295 |     | <span class='neutral'>    function revertToAndDelete(uint256 snapshotId) external returns (bool success);</span>
 2296 |     | <span class='neutral'></span>
 2297 |     | <span class='neutral'>    /// `revertTo` is being deprecated in favor of `revertToState`. It will be removed in future versions.</span>
 2298 |     | <span class='neutral'>    function revertTo(uint256 snapshotId) external returns (bool success);</span>
 2299 |     | <span class='neutral'></span>
 2300 |     | <span class='neutral'>    /// `snapshot` is being deprecated in favor of `snapshotState`. It will be removed in future versions.</span>
 2301 |     | <span class='neutral'>    function snapshot() external returns (uint256 snapshotId);</span>
 2302 |     | <span class='neutral'></span>
 2303 |     | <span class='neutral'>    // ======== Testing ========</span>
 2304 |     | <span class='neutral'></span>
 2305 |     | <span class='neutral'>    /// Expect a call to an address with the specified `msg.value` and calldata, and a *minimum* amount of gas.</span>
 2306 |     | <span class='neutral'>    function expectCallMinGas(address callee, uint256 msgValue, uint64 minGas, bytes calldata data) external;</span>
 2307 |     | <span class='neutral'></span>
 2308 |     | <span class='neutral'>    /// Expect given number of calls to an address with the specified `msg.value` and calldata, and a *minimum* amount of gas.</span>
 2309 |     | <span class='neutral'>    function expectCallMinGas(address callee, uint256 msgValue, uint64 minGas, bytes calldata data, uint64 count)</span>
 2310 |     | <span class='neutral'>        external;</span>
 2311 |     | <span class='neutral'></span>
 2312 |     | <span class='neutral'>    /// Expects a call to an address with the specified calldata.</span>
 2313 |     | <span class='neutral'>    /// Calldata can either be a strict or a partial match.</span>
 2314 |     | <span class='neutral'>    function expectCall(address callee, bytes calldata data) external;</span>
 2315 |     | <span class='neutral'></span>
 2316 |     | <span class='neutral'>    /// Expects given number of calls to an address with the specified calldata.</span>
 2317 |     | <span class='neutral'>    function expectCall(address callee, bytes calldata data, uint64 count) external;</span>
 2318 |     | <span class='neutral'></span>
 2319 |     | <span class='neutral'>    /// Expects a call to an address with the specified `msg.value` and calldata.</span>
 2320 |     | <span class='neutral'>    function expectCall(address callee, uint256 msgValue, bytes calldata data) external;</span>
 2321 |     | <span class='neutral'></span>
 2322 |     | <span class='neutral'>    /// Expects given number of calls to an address with the specified `msg.value` and calldata.</span>
 2323 |     | <span class='neutral'>    function expectCall(address callee, uint256 msgValue, bytes calldata data, uint64 count) external;</span>
 2324 |     | <span class='neutral'></span>
 2325 |     | <span class='neutral'>    /// Expect a call to an address with the specified `msg.value`, gas, and calldata.</span>
 2326 |     | <span class='neutral'>    function expectCall(address callee, uint256 msgValue, uint64 gas, bytes calldata data) external;</span>
 2327 |     | <span class='neutral'></span>
 2328 |     | <span class='neutral'>    /// Expects given number of calls to an address with the specified `msg.value`, gas, and calldata.</span>
 2329 |     | <span class='neutral'>    function expectCall(address callee, uint256 msgValue, uint64 gas, bytes calldata data, uint64 count) external;</span>
 2330 |     | <span class='neutral'></span>
 2331 |     | <span class='neutral'>    /// Expects the deployment of the specified bytecode by the specified address using the CREATE opcode</span>
 2332 |     | <span class='neutral'>    function expectCreate(bytes calldata bytecode, address deployer) external;</span>
 2333 |     | <span class='neutral'></span>
 2334 |     | <span class='neutral'>    /// Expects the deployment of the specified bytecode by the specified address using the CREATE2 opcode</span>
 2335 |     | <span class='neutral'>    function expectCreate2(bytes calldata bytecode, address deployer) external;</span>
 2336 |     | <span class='neutral'></span>
 2337 |     | <span class='neutral'>    /// Prepare an expected anonymous log with (bool checkTopic1, bool checkTopic2, bool checkTopic3, bool checkData.).</span>
 2338 |     | <span class='neutral'>    /// Call this function, then emit an anonymous event, then call a function. Internally after the call, we check if</span>
 2339 |     | <span class='neutral'>    /// logs were emitted in the expected order with the expected topics and data (as specified by the booleans).</span>
 2340 |     | <span class='neutral'>    function expectEmitAnonymous(bool checkTopic0, bool checkTopic1, bool checkTopic2, bool checkTopic3, bool checkData)</span>
 2341 |     | <span class='neutral'>        external;</span>
 2342 |     | <span class='neutral'></span>
 2343 |     | <span class='neutral'>    /// Same as the previous method, but also checks supplied address against emitting contract.</span>
 2344 |     | <span class='neutral'>    function expectEmitAnonymous(</span>
 2345 |     | <span class='neutral'>        bool checkTopic0,</span>
 2346 |     | <span class='neutral'>        bool checkTopic1,</span>
 2347 |     | <span class='neutral'>        bool checkTopic2,</span>
 2348 |     | <span class='neutral'>        bool checkTopic3,</span>
 2349 |     | <span class='neutral'>        bool checkData,</span>
 2350 |     | <span class='neutral'>        address emitter</span>
 2351 |     | <span class='neutral'>    ) external;</span>
 2352 |     | <span class='neutral'></span>
 2353 |     | <span class='neutral'>    /// Prepare an expected anonymous log with all topic and data checks enabled.</span>
 2354 |     | <span class='neutral'>    /// Call this function, then emit an anonymous event, then call a function. Internally after the call, we check if</span>
 2355 |     | <span class='neutral'>    /// logs were emitted in the expected order with the expected topics and data.</span>
 2356 |     | <span class='neutral'>    function expectEmitAnonymous() external;</span>
 2357 |     | <span class='neutral'></span>
 2358 |     | <span class='neutral'>    /// Same as the previous method, but also checks supplied address against emitting contract.</span>
 2359 |     | <span class='neutral'>    function expectEmitAnonymous(address emitter) external;</span>
 2360 |     | <span class='neutral'></span>
 2361 |     | <span class='neutral'>    /// Prepare an expected log with (bool checkTopic1, bool checkTopic2, bool checkTopic3, bool checkData.).</span>
 2362 |     | <span class='neutral'>    /// Call this function, then emit an event, then call a function. Internally after the call, we check if</span>
 2363 |     | <span class='neutral'>    /// logs were emitted in the expected order with the expected topics and data (as specified by the booleans).</span>
 2364 |     | <span class='neutral'>    function expectEmit(bool checkTopic1, bool checkTopic2, bool checkTopic3, bool checkData) external;</span>
 2365 |     | <span class='neutral'></span>
 2366 |     | <span class='neutral'>    /// Same as the previous method, but also checks supplied address against emitting contract.</span>
 2367 |     | <span class='neutral'>    function expectEmit(bool checkTopic1, bool checkTopic2, bool checkTopic3, bool checkData, address emitter)</span>
 2368 |     | <span class='neutral'>        external;</span>
 2369 |     | <span class='neutral'></span>
 2370 |     | <span class='neutral'>    /// Prepare an expected log with all topic and data checks enabled.</span>
 2371 |     | <span class='neutral'>    /// Call this function, then emit an event, then call a function. Internally after the call, we check if</span>
 2372 |     | <span class='neutral'>    /// logs were emitted in the expected order with the expected topics and data.</span>
 2373 |     | <span class='neutral'>    function expectEmit() external;</span>
 2374 |     | <span class='neutral'></span>
 2375 |     | <span class='neutral'>    /// Same as the previous method, but also checks supplied address against emitting contract.</span>
 2376 |     | <span class='neutral'>    function expectEmit(address emitter) external;</span>
 2377 |     | <span class='neutral'></span>
 2378 |     | <span class='neutral'>    /// Expect a given number of logs with the provided topics.</span>
 2379 |     | <span class='neutral'>    function expectEmit(bool checkTopic1, bool checkTopic2, bool checkTopic3, bool checkData, uint64 count) external;</span>
 2380 |     | <span class='neutral'></span>
 2381 |     | <span class='neutral'>    /// Expect a given number of logs from a specific emitter with the provided topics.</span>
 2382 |     | <span class='neutral'>    function expectEmit(</span>
 2383 |     | <span class='neutral'>        bool checkTopic1,</span>
 2384 |     | <span class='neutral'>        bool checkTopic2,</span>
 2385 |     | <span class='neutral'>        bool checkTopic3,</span>
 2386 |     | <span class='neutral'>        bool checkData,</span>
 2387 |     | <span class='neutral'>        address emitter,</span>
 2388 |     | <span class='neutral'>        uint64 count</span>
 2389 |     | <span class='neutral'>    ) external;</span>
 2390 |     | <span class='neutral'></span>
 2391 |     | <span class='neutral'>    /// Expect a given number of logs with all topic and data checks enabled.</span>
 2392 |     | <span class='neutral'>    function expectEmit(uint64 count) external;</span>
 2393 |     | <span class='neutral'></span>
 2394 |     | <span class='neutral'>    /// Expect a given number of logs from a specific emitter with all topic and data checks enabled.</span>
 2395 |     | <span class='neutral'>    function expectEmit(address emitter, uint64 count) external;</span>
 2396 |     | <span class='neutral'></span>
 2397 |     | <span class='neutral'>    /// Expects an error on next call that starts with the revert data.</span>
 2398 |     | <span class='neutral'>    function expectPartialRevert(bytes4 revertData) external;</span>
 2399 |     | <span class='neutral'></span>
 2400 |     | <span class='neutral'>    /// Expects an error on next call to reverter address, that starts with the revert data.</span>
 2401 |     | <span class='neutral'>    function expectPartialRevert(bytes4 revertData, address reverter) external;</span>
 2402 |     | <span class='neutral'></span>
 2403 |     | <span class='neutral'>    /// Expects an error on next call with any revert data.</span>
 2404 |     | <span class='neutral'>    function expectRevert() external;</span>
 2405 |     | <span class='neutral'></span>
 2406 |     | <span class='neutral'>    /// Expects an error on next call that exactly matches the revert data.</span>
 2407 |     | <span class='neutral'>    function expectRevert(bytes4 revertData) external;</span>
 2408 |     | <span class='neutral'></span>
 2409 |     | <span class='neutral'>    /// Expects a `count` number of reverts from the upcoming calls from the reverter address that match the revert data.</span>
 2410 |     | <span class='neutral'>    function expectRevert(bytes4 revertData, address reverter, uint64 count) external;</span>
 2411 |     | <span class='neutral'></span>
 2412 |     | <span class='neutral'>    /// Expects a `count` number of reverts from the upcoming calls from the reverter address that exactly match the revert data.</span>
 2413 |     | <span class='neutral'>    function expectRevert(bytes calldata revertData, address reverter, uint64 count) external;</span>
 2414 |     | <span class='neutral'></span>
 2415 |     | <span class='neutral'>    /// Expects an error on next call that exactly matches the revert data.</span>
 2416 |     | <span class='neutral'>    function expectRevert(bytes calldata revertData) external;</span>
 2417 |     | <span class='neutral'></span>
 2418 |     | <span class='neutral'>    /// Expects an error with any revert data on next call to reverter address.</span>
 2419 |     | <span class='neutral'>    function expectRevert(address reverter) external;</span>
 2420 |     | <span class='neutral'></span>
 2421 |     | <span class='neutral'>    /// Expects an error from reverter address on next call, with any revert data.</span>
 2422 |     | <span class='neutral'>    function expectRevert(bytes4 revertData, address reverter) external;</span>
 2423 |     | <span class='neutral'></span>
 2424 |     | <span class='neutral'>    /// Expects an error from reverter address on next call, that exactly matches the revert data.</span>
 2425 |     | <span class='neutral'>    function expectRevert(bytes calldata revertData, address reverter) external;</span>
 2426 |     | <span class='neutral'></span>
 2427 |     | <span class='neutral'>    /// Expects a `count` number of reverts from the upcoming calls with any revert data or reverter.</span>
 2428 |     | <span class='neutral'>    function expectRevert(uint64 count) external;</span>
 2429 |     | <span class='neutral'></span>
 2430 |     | <span class='neutral'>    /// Expects a `count` number of reverts from the upcoming calls that match the revert data.</span>
 2431 |     | <span class='neutral'>    function expectRevert(bytes4 revertData, uint64 count) external;</span>
 2432 |     | <span class='neutral'></span>
 2433 |     | <span class='neutral'>    /// Expects a `count` number of reverts from the upcoming calls that exactly match the revert data.</span>
 2434 |     | <span class='neutral'>    function expectRevert(bytes calldata revertData, uint64 count) external;</span>
 2435 |     | <span class='neutral'></span>
 2436 |     | <span class='neutral'>    /// Expects a `count` number of reverts from the upcoming calls from the reverter address.</span>
 2437 |     | <span class='neutral'>    function expectRevert(address reverter, uint64 count) external;</span>
 2438 |     | <span class='neutral'></span>
 2439 |     | <span class='neutral'>    /// Only allows memory writes to offsets [0x00, 0x60)  [min, max) in the current subcontext. If any other</span>
 2440 |     | <span class='neutral'>    /// memory is written to, the test will fail. Can be called multiple times to add more ranges to the set.</span>
 2441 |     | <span class='neutral'>    function expectSafeMemory(uint64 min, uint64 max) external;</span>
 2442 |     | <span class='neutral'></span>
 2443 |     | <span class='neutral'>    /// Only allows memory writes to offsets [0x00, 0x60)  [min, max) in the next created subcontext.</span>
 2444 |     | <span class='neutral'>    /// If any other memory is written to, the test will fail. Can be called multiple times to add more ranges</span>
 2445 |     | <span class='neutral'>    /// to the set.</span>
 2446 |     | <span class='neutral'>    function expectSafeMemoryCall(uint64 min, uint64 max) external;</span>
 2447 |     | <span class='neutral'></span>
 2448 |     | <span class='neutral'>    /// Marks a test as skipped. Must be called at the top level of a test.</span>
 2449 |     | <span class='neutral'>    function skip(bool skipTest) external;</span>
 2450 |     | <span class='neutral'></span>
 2451 |     | <span class='neutral'>    /// Marks a test as skipped with a reason. Must be called at the top level of a test.</span>
 2452 |     | <span class='neutral'>    function skip(bool skipTest, string calldata reason) external;</span>
 2453 |     | <span class='neutral'></span>
 2454 |     | <span class='neutral'>    /// Stops all safe memory expectation in the current subcontext.</span>
 2455 |     | <span class='neutral'>    function stopExpectSafeMemory() external;</span>
 2456 |     | <span class='neutral'></span>
 2457 |     | <span class='neutral'>    // ======== Utilities ========</span>
 2458 |     | <span class='neutral'></span>
 2459 |     | <span class='neutral'>    /// Causes the next contract creation (via new) to fail and return its initcode in the returndata buffer.</span>
 2460 |     | <span class='neutral'>    /// This allows type-safe access to the initcode payload that would be used for contract creation.</span>
 2461 |     | <span class='neutral'>    /// Example usage:</span>
 2462 |     | <span class='neutral'>    /// vm.interceptInitcode();</span>
 2463 |     | <span class='neutral'>    /// bytes memory initcode;</span>
 2464 |     | <span class='neutral'>    /// try new MyContract(param1, param2) { assert(false); }</span>
 2465 |     | <span class='neutral'>    /// catch (bytes memory interceptedInitcode) { initcode = interceptedInitcode; }</span>
 2466 |     | <span class='neutral'>    function interceptInitcode() external;</span>
 2467 |     | <span class='neutral'>}</span>
 2468 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/phantom/Documents/azemora/azemora-contracts/lib/forge-std/src/console.sol</b>
<code>
    1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
    2 |     | <span class='neutral'>pragma solidity &gt;=0.4.22 &lt;0.9.0;</span>
    3 |     | <span class='neutral'></span>
    4 |     | <span class='unexecuted'>library console {</span>
    5 |     | <span class='neutral'>    address constant CONSOLE_ADDRESS =</span>
    6 |     | <span class='unexecuted'>        0x000000000000000000636F6e736F6c652e6c6f67;</span>
    7 |     | <span class='neutral'></span>
    8 |     | <span class='unexecuted'>    function _sendLogPayloadImplementation(bytes memory payload) internal view {</span>
    9 |     | <span class='unexecuted'>        address consoleAddress = CONSOLE_ADDRESS;</span>
   10 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
   11 |     | <span class='unexecuted'>        assembly {</span>
   12 |     | <span class='unexecuted'>            pop(</span>
   13 |     | <span class='unexecuted'>                staticcall(</span>
   14 |     | <span class='unexecuted'>                    gas(),</span>
   15 |     | <span class='unexecuted'>                    consoleAddress,</span>
   16 |     | <span class='unexecuted'>                    add(payload, 32),</span>
   17 |     | <span class='unexecuted'>                    mload(payload),</span>
   18 |     | <span class='unexecuted'>                    0,</span>
   19 |     | <span class='unexecuted'>                    0</span>
   20 |     | <span class='neutral'>                )</span>
   21 |     | <span class='neutral'>            )</span>
   22 |     | <span class='neutral'>        }</span>
   23 |     | <span class='neutral'>    }</span>
   24 |     | <span class='neutral'></span>
   25 |     | <span class='neutral'>    function _castToPure(</span>
   26 |     | <span class='neutral'>      function(bytes memory) internal view fnIn</span>
   27 |     | <span class='neutral'>    ) internal pure returns (function(bytes memory) pure fnOut) {</span>
   28 |     | <span class='neutral'>        assembly {</span>
   29 |     | <span class='neutral'>            fnOut := fnIn</span>
   30 |     | <span class='neutral'>        }</span>
   31 |     | <span class='neutral'>    }</span>
   32 |     | <span class='neutral'></span>
   33 |     | <span class='unexecuted'>    function _sendLogPayload(bytes memory payload) internal pure {</span>
   34 |     | <span class='unexecuted'>        _castToPure(_sendLogPayloadImplementation)(payload);</span>
   35 |     | <span class='neutral'>    }</span>
   36 |     | <span class='neutral'></span>
   37 |     | <span class='neutral'>    function log() internal pure {</span>
   38 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log()&quot;));</span>
   39 |     | <span class='neutral'>    }</span>
   40 |     | <span class='neutral'></span>
   41 |     | <span class='neutral'>    function logInt(int256 p0) internal pure {</span>
   42 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(int256)&quot;, p0));</span>
   43 |     | <span class='neutral'>    }</span>
   44 |     | <span class='neutral'></span>
   45 |     | <span class='neutral'>    function logUint(uint256 p0) internal pure {</span>
   46 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256)&quot;, p0));</span>
   47 |     | <span class='neutral'>    }</span>
   48 |     | <span class='neutral'></span>
   49 |     | <span class='neutral'>    function logString(string memory p0) internal pure {</span>
   50 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string)&quot;, p0));</span>
   51 |     | <span class='neutral'>    }</span>
   52 |     | <span class='neutral'></span>
   53 |     | <span class='neutral'>    function logBool(bool p0) internal pure {</span>
   54 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool)&quot;, p0));</span>
   55 |     | <span class='neutral'>    }</span>
   56 |     | <span class='neutral'></span>
   57 |     | <span class='neutral'>    function logAddress(address p0) internal pure {</span>
   58 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address)&quot;, p0));</span>
   59 |     | <span class='neutral'>    }</span>
   60 |     | <span class='neutral'></span>
   61 |     | <span class='unexecuted'>    function logBytes(bytes memory p0) internal pure {</span>
   62 |     | <span class='unexecuted'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes)&quot;, p0));</span>
   63 |     | <span class='neutral'>    }</span>
   64 |     | <span class='neutral'></span>
   65 |     | <span class='neutral'>    function logBytes1(bytes1 p0) internal pure {</span>
   66 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes1)&quot;, p0));</span>
   67 |     | <span class='neutral'>    }</span>
   68 |     | <span class='neutral'></span>
   69 |     | <span class='neutral'>    function logBytes2(bytes2 p0) internal pure {</span>
   70 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes2)&quot;, p0));</span>
   71 |     | <span class='neutral'>    }</span>
   72 |     | <span class='neutral'></span>
   73 |     | <span class='neutral'>    function logBytes3(bytes3 p0) internal pure {</span>
   74 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes3)&quot;, p0));</span>
   75 |     | <span class='neutral'>    }</span>
   76 |     | <span class='neutral'></span>
   77 |     | <span class='neutral'>    function logBytes4(bytes4 p0) internal pure {</span>
   78 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes4)&quot;, p0));</span>
   79 |     | <span class='neutral'>    }</span>
   80 |     | <span class='neutral'></span>
   81 |     | <span class='neutral'>    function logBytes5(bytes5 p0) internal pure {</span>
   82 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes5)&quot;, p0));</span>
   83 |     | <span class='neutral'>    }</span>
   84 |     | <span class='neutral'></span>
   85 |     | <span class='neutral'>    function logBytes6(bytes6 p0) internal pure {</span>
   86 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes6)&quot;, p0));</span>
   87 |     | <span class='neutral'>    }</span>
   88 |     | <span class='neutral'></span>
   89 |     | <span class='neutral'>    function logBytes7(bytes7 p0) internal pure {</span>
   90 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes7)&quot;, p0));</span>
   91 |     | <span class='neutral'>    }</span>
   92 |     | <span class='neutral'></span>
   93 |     | <span class='neutral'>    function logBytes8(bytes8 p0) internal pure {</span>
   94 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes8)&quot;, p0));</span>
   95 |     | <span class='neutral'>    }</span>
   96 |     | <span class='neutral'></span>
   97 |     | <span class='neutral'>    function logBytes9(bytes9 p0) internal pure {</span>
   98 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes9)&quot;, p0));</span>
   99 |     | <span class='neutral'>    }</span>
  100 |     | <span class='neutral'></span>
  101 |     | <span class='neutral'>    function logBytes10(bytes10 p0) internal pure {</span>
  102 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes10)&quot;, p0));</span>
  103 |     | <span class='neutral'>    }</span>
  104 |     | <span class='neutral'></span>
  105 |     | <span class='neutral'>    function logBytes11(bytes11 p0) internal pure {</span>
  106 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes11)&quot;, p0));</span>
  107 |     | <span class='neutral'>    }</span>
  108 |     | <span class='neutral'></span>
  109 |     | <span class='neutral'>    function logBytes12(bytes12 p0) internal pure {</span>
  110 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes12)&quot;, p0));</span>
  111 |     | <span class='neutral'>    }</span>
  112 |     | <span class='neutral'></span>
  113 |     | <span class='neutral'>    function logBytes13(bytes13 p0) internal pure {</span>
  114 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes13)&quot;, p0));</span>
  115 |     | <span class='neutral'>    }</span>
  116 |     | <span class='neutral'></span>
  117 |     | <span class='neutral'>    function logBytes14(bytes14 p0) internal pure {</span>
  118 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes14)&quot;, p0));</span>
  119 |     | <span class='neutral'>    }</span>
  120 |     | <span class='neutral'></span>
  121 |     | <span class='neutral'>    function logBytes15(bytes15 p0) internal pure {</span>
  122 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes15)&quot;, p0));</span>
  123 |     | <span class='neutral'>    }</span>
  124 |     | <span class='neutral'></span>
  125 |     | <span class='neutral'>    function logBytes16(bytes16 p0) internal pure {</span>
  126 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes16)&quot;, p0));</span>
  127 |     | <span class='neutral'>    }</span>
  128 |     | <span class='neutral'></span>
  129 |     | <span class='neutral'>    function logBytes17(bytes17 p0) internal pure {</span>
  130 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes17)&quot;, p0));</span>
  131 |     | <span class='neutral'>    }</span>
  132 |     | <span class='neutral'></span>
  133 |     | <span class='neutral'>    function logBytes18(bytes18 p0) internal pure {</span>
  134 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes18)&quot;, p0));</span>
  135 |     | <span class='neutral'>    }</span>
  136 |     | <span class='neutral'></span>
  137 |     | <span class='neutral'>    function logBytes19(bytes19 p0) internal pure {</span>
  138 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes19)&quot;, p0));</span>
  139 |     | <span class='neutral'>    }</span>
  140 |     | <span class='neutral'></span>
  141 |     | <span class='neutral'>    function logBytes20(bytes20 p0) internal pure {</span>
  142 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes20)&quot;, p0));</span>
  143 |     | <span class='neutral'>    }</span>
  144 |     | <span class='neutral'></span>
  145 |     | <span class='neutral'>    function logBytes21(bytes21 p0) internal pure {</span>
  146 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes21)&quot;, p0));</span>
  147 |     | <span class='neutral'>    }</span>
  148 |     | <span class='neutral'></span>
  149 |     | <span class='neutral'>    function logBytes22(bytes22 p0) internal pure {</span>
  150 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes22)&quot;, p0));</span>
  151 |     | <span class='neutral'>    }</span>
  152 |     | <span class='neutral'></span>
  153 |     | <span class='neutral'>    function logBytes23(bytes23 p0) internal pure {</span>
  154 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes23)&quot;, p0));</span>
  155 |     | <span class='neutral'>    }</span>
  156 |     | <span class='neutral'></span>
  157 |     | <span class='neutral'>    function logBytes24(bytes24 p0) internal pure {</span>
  158 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes24)&quot;, p0));</span>
  159 |     | <span class='neutral'>    }</span>
  160 |     | <span class='neutral'></span>
  161 |     | <span class='neutral'>    function logBytes25(bytes25 p0) internal pure {</span>
  162 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes25)&quot;, p0));</span>
  163 |     | <span class='neutral'>    }</span>
  164 |     | <span class='neutral'></span>
  165 |     | <span class='neutral'>    function logBytes26(bytes26 p0) internal pure {</span>
  166 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes26)&quot;, p0));</span>
  167 |     | <span class='neutral'>    }</span>
  168 |     | <span class='neutral'></span>
  169 |     | <span class='neutral'>    function logBytes27(bytes27 p0) internal pure {</span>
  170 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes27)&quot;, p0));</span>
  171 |     | <span class='neutral'>    }</span>
  172 |     | <span class='neutral'></span>
  173 |     | <span class='neutral'>    function logBytes28(bytes28 p0) internal pure {</span>
  174 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes28)&quot;, p0));</span>
  175 |     | <span class='neutral'>    }</span>
  176 |     | <span class='neutral'></span>
  177 |     | <span class='neutral'>    function logBytes29(bytes29 p0) internal pure {</span>
  178 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes29)&quot;, p0));</span>
  179 |     | <span class='neutral'>    }</span>
  180 |     | <span class='neutral'></span>
  181 |     | <span class='neutral'>    function logBytes30(bytes30 p0) internal pure {</span>
  182 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes30)&quot;, p0));</span>
  183 |     | <span class='neutral'>    }</span>
  184 |     | <span class='neutral'></span>
  185 |     | <span class='neutral'>    function logBytes31(bytes31 p0) internal pure {</span>
  186 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes31)&quot;, p0));</span>
  187 |     | <span class='neutral'>    }</span>
  188 |     | <span class='neutral'></span>
  189 |     | <span class='neutral'>    function logBytes32(bytes32 p0) internal pure {</span>
  190 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes32)&quot;, p0));</span>
  191 |     | <span class='neutral'>    }</span>
  192 |     | <span class='neutral'></span>
  193 |     | <span class='neutral'>    function log(uint256 p0) internal pure {</span>
  194 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256)&quot;, p0));</span>
  195 |     | <span class='neutral'>    }</span>
  196 |     | <span class='neutral'></span>
  197 |     | <span class='neutral'>    function log(int256 p0) internal pure {</span>
  198 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(int256)&quot;, p0));</span>
  199 |     | <span class='neutral'>    }</span>
  200 |     | <span class='neutral'></span>
  201 |     | <span class='unexecuted'>    function log(string memory p0) internal pure {</span>
  202 |     | <span class='unexecuted'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string)&quot;, p0));</span>
  203 |     | <span class='neutral'>    }</span>
  204 |     | <span class='neutral'></span>
  205 |     | <span class='neutral'>    function log(bool p0) internal pure {</span>
  206 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool)&quot;, p0));</span>
  207 |     | <span class='neutral'>    }</span>
  208 |     | <span class='neutral'></span>
  209 |     | <span class='neutral'>    function log(address p0) internal pure {</span>
  210 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address)&quot;, p0));</span>
  211 |     | <span class='neutral'>    }</span>
  212 |     | <span class='neutral'></span>
  213 |     | <span class='neutral'>    function log(uint256 p0, uint256 p1) internal pure {</span>
  214 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,uint256)&quot;, p0, p1));</span>
  215 |     | <span class='neutral'>    }</span>
  216 |     | <span class='neutral'></span>
  217 |     | <span class='neutral'>    function log(uint256 p0, string memory p1) internal pure {</span>
  218 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,string)&quot;, p0, p1));</span>
  219 |     | <span class='neutral'>    }</span>
  220 |     | <span class='neutral'></span>
  221 |     | <span class='neutral'>    function log(uint256 p0, bool p1) internal pure {</span>
  222 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,bool)&quot;, p0, p1));</span>
  223 |     | <span class='neutral'>    }</span>
  224 |     | <span class='neutral'></span>
  225 |     | <span class='neutral'>    function log(uint256 p0, address p1) internal pure {</span>
  226 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,address)&quot;, p0, p1));</span>
  227 |     | <span class='neutral'>    }</span>
  228 |     | <span class='neutral'></span>
  229 |     | <span class='unexecuted'>    function log(string memory p0, uint256 p1) internal pure {</span>
  230 |     | <span class='unexecuted'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,uint256)&quot;, p0, p1));</span>
  231 |     | <span class='neutral'>    }</span>
  232 |     | <span class='neutral'></span>
  233 |     | <span class='neutral'>    function log(string memory p0, int256 p1) internal pure {</span>
  234 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,int256)&quot;, p0, p1));</span>
  235 |     | <span class='neutral'>    }</span>
  236 |     | <span class='neutral'></span>
  237 |     | <span class='neutral'>    function log(string memory p0, string memory p1) internal pure {</span>
  238 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,string)&quot;, p0, p1));</span>
  239 |     | <span class='neutral'>    }</span>
  240 |     | <span class='neutral'></span>
  241 |     | <span class='unexecuted'>    function log(string memory p0, bool p1) internal pure {</span>
  242 |     | <span class='unexecuted'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,bool)&quot;, p0, p1));</span>
  243 |     | <span class='neutral'>    }</span>
  244 |     | <span class='neutral'></span>
  245 |     | <span class='unexecuted'>    function log(string memory p0, address p1) internal pure {</span>
  246 |     | <span class='unexecuted'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,address)&quot;, p0, p1));</span>
  247 |     | <span class='neutral'>    }</span>
  248 |     | <span class='neutral'></span>
  249 |     | <span class='neutral'>    function log(bool p0, uint256 p1) internal pure {</span>
  250 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,uint256)&quot;, p0, p1));</span>
  251 |     | <span class='neutral'>    }</span>
  252 |     | <span class='neutral'></span>
  253 |     | <span class='neutral'>    function log(bool p0, string memory p1) internal pure {</span>
  254 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,string)&quot;, p0, p1));</span>
  255 |     | <span class='neutral'>    }</span>
  256 |     | <span class='neutral'></span>
  257 |     | <span class='neutral'>    function log(bool p0, bool p1) internal pure {</span>
  258 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,bool)&quot;, p0, p1));</span>
  259 |     | <span class='neutral'>    }</span>
  260 |     | <span class='neutral'></span>
  261 |     | <span class='neutral'>    function log(bool p0, address p1) internal pure {</span>
  262 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,address)&quot;, p0, p1));</span>
  263 |     | <span class='neutral'>    }</span>
  264 |     | <span class='neutral'></span>
  265 |     | <span class='neutral'>    function log(address p0, uint256 p1) internal pure {</span>
  266 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,uint256)&quot;, p0, p1));</span>
  267 |     | <span class='neutral'>    }</span>
  268 |     | <span class='neutral'></span>
  269 |     | <span class='neutral'>    function log(address p0, string memory p1) internal pure {</span>
  270 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,string)&quot;, p0, p1));</span>
  271 |     | <span class='neutral'>    }</span>
  272 |     | <span class='neutral'></span>
  273 |     | <span class='neutral'>    function log(address p0, bool p1) internal pure {</span>
  274 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,bool)&quot;, p0, p1));</span>
  275 |     | <span class='neutral'>    }</span>
  276 |     | <span class='neutral'></span>
  277 |     | <span class='neutral'>    function log(address p0, address p1) internal pure {</span>
  278 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,address)&quot;, p0, p1));</span>
  279 |     | <span class='neutral'>    }</span>
  280 |     | <span class='neutral'></span>
  281 |     | <span class='neutral'>    function log(uint256 p0, uint256 p1, uint256 p2) internal pure {</span>
  282 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,uint256,uint256)&quot;, p0, p1, p2));</span>
  283 |     | <span class='neutral'>    }</span>
  284 |     | <span class='neutral'></span>
  285 |     | <span class='neutral'>    function log(uint256 p0, uint256 p1, string memory p2) internal pure {</span>
  286 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,uint256,string)&quot;, p0, p1, p2));</span>
  287 |     | <span class='neutral'>    }</span>
  288 |     | <span class='neutral'></span>
  289 |     | <span class='neutral'>    function log(uint256 p0, uint256 p1, bool p2) internal pure {</span>
  290 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,uint256,bool)&quot;, p0, p1, p2));</span>
  291 |     | <span class='neutral'>    }</span>
  292 |     | <span class='neutral'></span>
  293 |     | <span class='neutral'>    function log(uint256 p0, uint256 p1, address p2) internal pure {</span>
  294 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,uint256,address)&quot;, p0, p1, p2));</span>
  295 |     | <span class='neutral'>    }</span>
  296 |     | <span class='neutral'></span>
  297 |     | <span class='neutral'>    function log(uint256 p0, string memory p1, uint256 p2) internal pure {</span>
  298 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,string,uint256)&quot;, p0, p1, p2));</span>
  299 |     | <span class='neutral'>    }</span>
  300 |     | <span class='neutral'></span>
  301 |     | <span class='neutral'>    function log(uint256 p0, string memory p1, string memory p2) internal pure {</span>
  302 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,string,string)&quot;, p0, p1, p2));</span>
  303 |     | <span class='neutral'>    }</span>
  304 |     | <span class='neutral'></span>
  305 |     | <span class='neutral'>    function log(uint256 p0, string memory p1, bool p2) internal pure {</span>
  306 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,string,bool)&quot;, p0, p1, p2));</span>
  307 |     | <span class='neutral'>    }</span>
  308 |     | <span class='neutral'></span>
  309 |     | <span class='neutral'>    function log(uint256 p0, string memory p1, address p2) internal pure {</span>
  310 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,string,address)&quot;, p0, p1, p2));</span>
  311 |     | <span class='neutral'>    }</span>
  312 |     | <span class='neutral'></span>
  313 |     | <span class='neutral'>    function log(uint256 p0, bool p1, uint256 p2) internal pure {</span>
  314 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,bool,uint256)&quot;, p0, p1, p2));</span>
  315 |     | <span class='neutral'>    }</span>
  316 |     | <span class='neutral'></span>
  317 |     | <span class='neutral'>    function log(uint256 p0, bool p1, string memory p2) internal pure {</span>
  318 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,bool,string)&quot;, p0, p1, p2));</span>
  319 |     | <span class='neutral'>    }</span>
  320 |     | <span class='neutral'></span>
  321 |     | <span class='neutral'>    function log(uint256 p0, bool p1, bool p2) internal pure {</span>
  322 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,bool,bool)&quot;, p0, p1, p2));</span>
  323 |     | <span class='neutral'>    }</span>
  324 |     | <span class='neutral'></span>
  325 |     | <span class='neutral'>    function log(uint256 p0, bool p1, address p2) internal pure {</span>
  326 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,bool,address)&quot;, p0, p1, p2));</span>
  327 |     | <span class='neutral'>    }</span>
  328 |     | <span class='neutral'></span>
  329 |     | <span class='neutral'>    function log(uint256 p0, address p1, uint256 p2) internal pure {</span>
  330 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,address,uint256)&quot;, p0, p1, p2));</span>
  331 |     | <span class='neutral'>    }</span>
  332 |     | <span class='neutral'></span>
  333 |     | <span class='neutral'>    function log(uint256 p0, address p1, string memory p2) internal pure {</span>
  334 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,address,string)&quot;, p0, p1, p2));</span>
  335 |     | <span class='neutral'>    }</span>
  336 |     | <span class='neutral'></span>
  337 |     | <span class='neutral'>    function log(uint256 p0, address p1, bool p2) internal pure {</span>
  338 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,address,bool)&quot;, p0, p1, p2));</span>
  339 |     | <span class='neutral'>    }</span>
  340 |     | <span class='neutral'></span>
  341 |     | <span class='neutral'>    function log(uint256 p0, address p1, address p2) internal pure {</span>
  342 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,address,address)&quot;, p0, p1, p2));</span>
  343 |     | <span class='neutral'>    }</span>
  344 |     | <span class='neutral'></span>
  345 |     | <span class='neutral'>    function log(string memory p0, uint256 p1, uint256 p2) internal pure {</span>
  346 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,uint256,uint256)&quot;, p0, p1, p2));</span>
  347 |     | <span class='neutral'>    }</span>
  348 |     | <span class='neutral'></span>
  349 |     | <span class='neutral'>    function log(string memory p0, uint256 p1, string memory p2) internal pure {</span>
  350 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,uint256,string)&quot;, p0, p1, p2));</span>
  351 |     | <span class='neutral'>    }</span>
  352 |     | <span class='neutral'></span>
  353 |     | <span class='neutral'>    function log(string memory p0, uint256 p1, bool p2) internal pure {</span>
  354 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,uint256,bool)&quot;, p0, p1, p2));</span>
  355 |     | <span class='neutral'>    }</span>
  356 |     | <span class='neutral'></span>
  357 |     | <span class='neutral'>    function log(string memory p0, uint256 p1, address p2) internal pure {</span>
  358 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,uint256,address)&quot;, p0, p1, p2));</span>
  359 |     | <span class='neutral'>    }</span>
  360 |     | <span class='neutral'></span>
  361 |     | <span class='neutral'>    function log(string memory p0, string memory p1, uint256 p2) internal pure {</span>
  362 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,string,uint256)&quot;, p0, p1, p2));</span>
  363 |     | <span class='neutral'>    }</span>
  364 |     | <span class='neutral'></span>
  365 |     | <span class='neutral'>    function log(string memory p0, string memory p1, string memory p2) internal pure {</span>
  366 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,string,string)&quot;, p0, p1, p2));</span>
  367 |     | <span class='neutral'>    }</span>
  368 |     | <span class='neutral'></span>
  369 |     | <span class='neutral'>    function log(string memory p0, string memory p1, bool p2) internal pure {</span>
  370 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,string,bool)&quot;, p0, p1, p2));</span>
  371 |     | <span class='neutral'>    }</span>
  372 |     | <span class='neutral'></span>
  373 |     | <span class='neutral'>    function log(string memory p0, string memory p1, address p2) internal pure {</span>
  374 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,string,address)&quot;, p0, p1, p2));</span>
  375 |     | <span class='neutral'>    }</span>
  376 |     | <span class='neutral'></span>
  377 |     | <span class='neutral'>    function log(string memory p0, bool p1, uint256 p2) internal pure {</span>
  378 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,bool,uint256)&quot;, p0, p1, p2));</span>
  379 |     | <span class='neutral'>    }</span>
  380 |     | <span class='neutral'></span>
  381 |     | <span class='neutral'>    function log(string memory p0, bool p1, string memory p2) internal pure {</span>
  382 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,bool,string)&quot;, p0, p1, p2));</span>
  383 |     | <span class='neutral'>    }</span>
  384 |     | <span class='neutral'></span>
  385 |     | <span class='neutral'>    function log(string memory p0, bool p1, bool p2) internal pure {</span>
  386 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,bool,bool)&quot;, p0, p1, p2));</span>
  387 |     | <span class='neutral'>    }</span>
  388 |     | <span class='neutral'></span>
  389 |     | <span class='neutral'>    function log(string memory p0, bool p1, address p2) internal pure {</span>
  390 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,bool,address)&quot;, p0, p1, p2));</span>
  391 |     | <span class='neutral'>    }</span>
  392 |     | <span class='neutral'></span>
  393 |     | <span class='neutral'>    function log(string memory p0, address p1, uint256 p2) internal pure {</span>
  394 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,address,uint256)&quot;, p0, p1, p2));</span>
  395 |     | <span class='neutral'>    }</span>
  396 |     | <span class='neutral'></span>
  397 |     | <span class='neutral'>    function log(string memory p0, address p1, string memory p2) internal pure {</span>
  398 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,address,string)&quot;, p0, p1, p2));</span>
  399 |     | <span class='neutral'>    }</span>
  400 |     | <span class='neutral'></span>
  401 |     | <span class='neutral'>    function log(string memory p0, address p1, bool p2) internal pure {</span>
  402 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,address,bool)&quot;, p0, p1, p2));</span>
  403 |     | <span class='neutral'>    }</span>
  404 |     | <span class='neutral'></span>
  405 |     | <span class='neutral'>    function log(string memory p0, address p1, address p2) internal pure {</span>
  406 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,address,address)&quot;, p0, p1, p2));</span>
  407 |     | <span class='neutral'>    }</span>
  408 |     | <span class='neutral'></span>
  409 |     | <span class='neutral'>    function log(bool p0, uint256 p1, uint256 p2) internal pure {</span>
  410 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,uint256,uint256)&quot;, p0, p1, p2));</span>
  411 |     | <span class='neutral'>    }</span>
  412 |     | <span class='neutral'></span>
  413 |     | <span class='neutral'>    function log(bool p0, uint256 p1, string memory p2) internal pure {</span>
  414 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,uint256,string)&quot;, p0, p1, p2));</span>
  415 |     | <span class='neutral'>    }</span>
  416 |     | <span class='neutral'></span>
  417 |     | <span class='neutral'>    function log(bool p0, uint256 p1, bool p2) internal pure {</span>
  418 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,uint256,bool)&quot;, p0, p1, p2));</span>
  419 |     | <span class='neutral'>    }</span>
  420 |     | <span class='neutral'></span>
  421 |     | <span class='neutral'>    function log(bool p0, uint256 p1, address p2) internal pure {</span>
  422 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,uint256,address)&quot;, p0, p1, p2));</span>
  423 |     | <span class='neutral'>    }</span>
  424 |     | <span class='neutral'></span>
  425 |     | <span class='neutral'>    function log(bool p0, string memory p1, uint256 p2) internal pure {</span>
  426 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,string,uint256)&quot;, p0, p1, p2));</span>
  427 |     | <span class='neutral'>    }</span>
  428 |     | <span class='neutral'></span>
  429 |     | <span class='neutral'>    function log(bool p0, string memory p1, string memory p2) internal pure {</span>
  430 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,string,string)&quot;, p0, p1, p2));</span>
  431 |     | <span class='neutral'>    }</span>
  432 |     | <span class='neutral'></span>
  433 |     | <span class='neutral'>    function log(bool p0, string memory p1, bool p2) internal pure {</span>
  434 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,string,bool)&quot;, p0, p1, p2));</span>
  435 |     | <span class='neutral'>    }</span>
  436 |     | <span class='neutral'></span>
  437 |     | <span class='neutral'>    function log(bool p0, string memory p1, address p2) internal pure {</span>
  438 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,string,address)&quot;, p0, p1, p2));</span>
  439 |     | <span class='neutral'>    }</span>
  440 |     | <span class='neutral'></span>
  441 |     | <span class='neutral'>    function log(bool p0, bool p1, uint256 p2) internal pure {</span>
  442 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,bool,uint256)&quot;, p0, p1, p2));</span>
  443 |     | <span class='neutral'>    }</span>
  444 |     | <span class='neutral'></span>
  445 |     | <span class='neutral'>    function log(bool p0, bool p1, string memory p2) internal pure {</span>
  446 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,bool,string)&quot;, p0, p1, p2));</span>
  447 |     | <span class='neutral'>    }</span>
  448 |     | <span class='neutral'></span>
  449 |     | <span class='neutral'>    function log(bool p0, bool p1, bool p2) internal pure {</span>
  450 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,bool,bool)&quot;, p0, p1, p2));</span>
  451 |     | <span class='neutral'>    }</span>
  452 |     | <span class='neutral'></span>
  453 |     | <span class='neutral'>    function log(bool p0, bool p1, address p2) internal pure {</span>
  454 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,bool,address)&quot;, p0, p1, p2));</span>
  455 |     | <span class='neutral'>    }</span>
  456 |     | <span class='neutral'></span>
  457 |     | <span class='neutral'>    function log(bool p0, address p1, uint256 p2) internal pure {</span>
  458 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,address,uint256)&quot;, p0, p1, p2));</span>
  459 |     | <span class='neutral'>    }</span>
  460 |     | <span class='neutral'></span>
  461 |     | <span class='neutral'>    function log(bool p0, address p1, string memory p2) internal pure {</span>
  462 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,address,string)&quot;, p0, p1, p2));</span>
  463 |     | <span class='neutral'>    }</span>
  464 |     | <span class='neutral'></span>
  465 |     | <span class='neutral'>    function log(bool p0, address p1, bool p2) internal pure {</span>
  466 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,address,bool)&quot;, p0, p1, p2));</span>
  467 |     | <span class='neutral'>    }</span>
  468 |     | <span class='neutral'></span>
  469 |     | <span class='neutral'>    function log(bool p0, address p1, address p2) internal pure {</span>
  470 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,address,address)&quot;, p0, p1, p2));</span>
  471 |     | <span class='neutral'>    }</span>
  472 |     | <span class='neutral'></span>
  473 |     | <span class='neutral'>    function log(address p0, uint256 p1, uint256 p2) internal pure {</span>
  474 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,uint256,uint256)&quot;, p0, p1, p2));</span>
  475 |     | <span class='neutral'>    }</span>
  476 |     | <span class='neutral'></span>
  477 |     | <span class='neutral'>    function log(address p0, uint256 p1, string memory p2) internal pure {</span>
  478 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,uint256,string)&quot;, p0, p1, p2));</span>
  479 |     | <span class='neutral'>    }</span>
  480 |     | <span class='neutral'></span>
  481 |     | <span class='neutral'>    function log(address p0, uint256 p1, bool p2) internal pure {</span>
  482 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,uint256,bool)&quot;, p0, p1, p2));</span>
  483 |     | <span class='neutral'>    }</span>
  484 |     | <span class='neutral'></span>
  485 |     | <span class='neutral'>    function log(address p0, uint256 p1, address p2) internal pure {</span>
  486 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,uint256,address)&quot;, p0, p1, p2));</span>
  487 |     | <span class='neutral'>    }</span>
  488 |     | <span class='neutral'></span>
  489 |     | <span class='neutral'>    function log(address p0, string memory p1, uint256 p2) internal pure {</span>
  490 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,string,uint256)&quot;, p0, p1, p2));</span>
  491 |     | <span class='neutral'>    }</span>
  492 |     | <span class='neutral'></span>
  493 |     | <span class='neutral'>    function log(address p0, string memory p1, string memory p2) internal pure {</span>
  494 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,string,string)&quot;, p0, p1, p2));</span>
  495 |     | <span class='neutral'>    }</span>
  496 |     | <span class='neutral'></span>
  497 |     | <span class='neutral'>    function log(address p0, string memory p1, bool p2) internal pure {</span>
  498 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,string,bool)&quot;, p0, p1, p2));</span>
  499 |     | <span class='neutral'>    }</span>
  500 |     | <span class='neutral'></span>
  501 |     | <span class='neutral'>    function log(address p0, string memory p1, address p2) internal pure {</span>
  502 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,string,address)&quot;, p0, p1, p2));</span>
  503 |     | <span class='neutral'>    }</span>
  504 |     | <span class='neutral'></span>
  505 |     | <span class='neutral'>    function log(address p0, bool p1, uint256 p2) internal pure {</span>
  506 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,bool,uint256)&quot;, p0, p1, p2));</span>
  507 |     | <span class='neutral'>    }</span>
  508 |     | <span class='neutral'></span>
  509 |     | <span class='neutral'>    function log(address p0, bool p1, string memory p2) internal pure {</span>
  510 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,bool,string)&quot;, p0, p1, p2));</span>
  511 |     | <span class='neutral'>    }</span>
  512 |     | <span class='neutral'></span>
  513 |     | <span class='neutral'>    function log(address p0, bool p1, bool p2) internal pure {</span>
  514 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,bool,bool)&quot;, p0, p1, p2));</span>
  515 |     | <span class='neutral'>    }</span>
  516 |     | <span class='neutral'></span>
  517 |     | <span class='neutral'>    function log(address p0, bool p1, address p2) internal pure {</span>
  518 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,bool,address)&quot;, p0, p1, p2));</span>
  519 |     | <span class='neutral'>    }</span>
  520 |     | <span class='neutral'></span>
  521 |     | <span class='neutral'>    function log(address p0, address p1, uint256 p2) internal pure {</span>
  522 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,address,uint256)&quot;, p0, p1, p2));</span>
  523 |     | <span class='neutral'>    }</span>
  524 |     | <span class='neutral'></span>
  525 |     | <span class='neutral'>    function log(address p0, address p1, string memory p2) internal pure {</span>
  526 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,address,string)&quot;, p0, p1, p2));</span>
  527 |     | <span class='neutral'>    }</span>
  528 |     | <span class='neutral'></span>
  529 |     | <span class='neutral'>    function log(address p0, address p1, bool p2) internal pure {</span>
  530 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,address,bool)&quot;, p0, p1, p2));</span>
  531 |     | <span class='neutral'>    }</span>
  532 |     | <span class='neutral'></span>
  533 |     | <span class='neutral'>    function log(address p0, address p1, address p2) internal pure {</span>
  534 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,address,address)&quot;, p0, p1, p2));</span>
  535 |     | <span class='neutral'>    }</span>
  536 |     | <span class='neutral'></span>
  537 |     | <span class='neutral'>    function log(uint256 p0, uint256 p1, uint256 p2, uint256 p3) internal pure {</span>
  538 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,uint256,uint256,uint256)&quot;, p0, p1, p2, p3));</span>
  539 |     | <span class='neutral'>    }</span>
  540 |     | <span class='neutral'></span>
  541 |     | <span class='neutral'>    function log(uint256 p0, uint256 p1, uint256 p2, string memory p3) internal pure {</span>
  542 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,uint256,uint256,string)&quot;, p0, p1, p2, p3));</span>
  543 |     | <span class='neutral'>    }</span>
  544 |     | <span class='neutral'></span>
  545 |     | <span class='neutral'>    function log(uint256 p0, uint256 p1, uint256 p2, bool p3) internal pure {</span>
  546 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,uint256,uint256,bool)&quot;, p0, p1, p2, p3));</span>
  547 |     | <span class='neutral'>    }</span>
  548 |     | <span class='neutral'></span>
  549 |     | <span class='neutral'>    function log(uint256 p0, uint256 p1, uint256 p2, address p3) internal pure {</span>
  550 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,uint256,uint256,address)&quot;, p0, p1, p2, p3));</span>
  551 |     | <span class='neutral'>    }</span>
  552 |     | <span class='neutral'></span>
  553 |     | <span class='neutral'>    function log(uint256 p0, uint256 p1, string memory p2, uint256 p3) internal pure {</span>
  554 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,uint256,string,uint256)&quot;, p0, p1, p2, p3));</span>
  555 |     | <span class='neutral'>    }</span>
  556 |     | <span class='neutral'></span>
  557 |     | <span class='neutral'>    function log(uint256 p0, uint256 p1, string memory p2, string memory p3) internal pure {</span>
  558 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,uint256,string,string)&quot;, p0, p1, p2, p3));</span>
  559 |     | <span class='neutral'>    }</span>
  560 |     | <span class='neutral'></span>
  561 |     | <span class='neutral'>    function log(uint256 p0, uint256 p1, string memory p2, bool p3) internal pure {</span>
  562 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,uint256,string,bool)&quot;, p0, p1, p2, p3));</span>
  563 |     | <span class='neutral'>    }</span>
  564 |     | <span class='neutral'></span>
  565 |     | <span class='neutral'>    function log(uint256 p0, uint256 p1, string memory p2, address p3) internal pure {</span>
  566 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,uint256,string,address)&quot;, p0, p1, p2, p3));</span>
  567 |     | <span class='neutral'>    }</span>
  568 |     | <span class='neutral'></span>
  569 |     | <span class='neutral'>    function log(uint256 p0, uint256 p1, bool p2, uint256 p3) internal pure {</span>
  570 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,uint256,bool,uint256)&quot;, p0, p1, p2, p3));</span>
  571 |     | <span class='neutral'>    }</span>
  572 |     | <span class='neutral'></span>
  573 |     | <span class='neutral'>    function log(uint256 p0, uint256 p1, bool p2, string memory p3) internal pure {</span>
  574 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,uint256,bool,string)&quot;, p0, p1, p2, p3));</span>
  575 |     | <span class='neutral'>    }</span>
  576 |     | <span class='neutral'></span>
  577 |     | <span class='neutral'>    function log(uint256 p0, uint256 p1, bool p2, bool p3) internal pure {</span>
  578 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,uint256,bool,bool)&quot;, p0, p1, p2, p3));</span>
  579 |     | <span class='neutral'>    }</span>
  580 |     | <span class='neutral'></span>
  581 |     | <span class='neutral'>    function log(uint256 p0, uint256 p1, bool p2, address p3) internal pure {</span>
  582 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,uint256,bool,address)&quot;, p0, p1, p2, p3));</span>
  583 |     | <span class='neutral'>    }</span>
  584 |     | <span class='neutral'></span>
  585 |     | <span class='neutral'>    function log(uint256 p0, uint256 p1, address p2, uint256 p3) internal pure {</span>
  586 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,uint256,address,uint256)&quot;, p0, p1, p2, p3));</span>
  587 |     | <span class='neutral'>    }</span>
  588 |     | <span class='neutral'></span>
  589 |     | <span class='neutral'>    function log(uint256 p0, uint256 p1, address p2, string memory p3) internal pure {</span>
  590 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,uint256,address,string)&quot;, p0, p1, p2, p3));</span>
  591 |     | <span class='neutral'>    }</span>
  592 |     | <span class='neutral'></span>
  593 |     | <span class='neutral'>    function log(uint256 p0, uint256 p1, address p2, bool p3) internal pure {</span>
  594 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,uint256,address,bool)&quot;, p0, p1, p2, p3));</span>
  595 |     | <span class='neutral'>    }</span>
  596 |     | <span class='neutral'></span>
  597 |     | <span class='neutral'>    function log(uint256 p0, uint256 p1, address p2, address p3) internal pure {</span>
  598 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,uint256,address,address)&quot;, p0, p1, p2, p3));</span>
  599 |     | <span class='neutral'>    }</span>
  600 |     | <span class='neutral'></span>
  601 |     | <span class='neutral'>    function log(uint256 p0, string memory p1, uint256 p2, uint256 p3) internal pure {</span>
  602 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,string,uint256,uint256)&quot;, p0, p1, p2, p3));</span>
  603 |     | <span class='neutral'>    }</span>
  604 |     | <span class='neutral'></span>
  605 |     | <span class='neutral'>    function log(uint256 p0, string memory p1, uint256 p2, string memory p3) internal pure {</span>
  606 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,string,uint256,string)&quot;, p0, p1, p2, p3));</span>
  607 |     | <span class='neutral'>    }</span>
  608 |     | <span class='neutral'></span>
  609 |     | <span class='neutral'>    function log(uint256 p0, string memory p1, uint256 p2, bool p3) internal pure {</span>
  610 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,string,uint256,bool)&quot;, p0, p1, p2, p3));</span>
  611 |     | <span class='neutral'>    }</span>
  612 |     | <span class='neutral'></span>
  613 |     | <span class='neutral'>    function log(uint256 p0, string memory p1, uint256 p2, address p3) internal pure {</span>
  614 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,string,uint256,address)&quot;, p0, p1, p2, p3));</span>
  615 |     | <span class='neutral'>    }</span>
  616 |     | <span class='neutral'></span>
  617 |     | <span class='neutral'>    function log(uint256 p0, string memory p1, string memory p2, uint256 p3) internal pure {</span>
  618 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,string,string,uint256)&quot;, p0, p1, p2, p3));</span>
  619 |     | <span class='neutral'>    }</span>
  620 |     | <span class='neutral'></span>
  621 |     | <span class='neutral'>    function log(uint256 p0, string memory p1, string memory p2, string memory p3) internal pure {</span>
  622 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,string,string,string)&quot;, p0, p1, p2, p3));</span>
  623 |     | <span class='neutral'>    }</span>
  624 |     | <span class='neutral'></span>
  625 |     | <span class='neutral'>    function log(uint256 p0, string memory p1, string memory p2, bool p3) internal pure {</span>
  626 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,string,string,bool)&quot;, p0, p1, p2, p3));</span>
  627 |     | <span class='neutral'>    }</span>
  628 |     | <span class='neutral'></span>
  629 |     | <span class='neutral'>    function log(uint256 p0, string memory p1, string memory p2, address p3) internal pure {</span>
  630 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,string,string,address)&quot;, p0, p1, p2, p3));</span>
  631 |     | <span class='neutral'>    }</span>
  632 |     | <span class='neutral'></span>
  633 |     | <span class='neutral'>    function log(uint256 p0, string memory p1, bool p2, uint256 p3) internal pure {</span>
  634 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,string,bool,uint256)&quot;, p0, p1, p2, p3));</span>
  635 |     | <span class='neutral'>    }</span>
  636 |     | <span class='neutral'></span>
  637 |     | <span class='neutral'>    function log(uint256 p0, string memory p1, bool p2, string memory p3) internal pure {</span>
  638 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,string,bool,string)&quot;, p0, p1, p2, p3));</span>
  639 |     | <span class='neutral'>    }</span>
  640 |     | <span class='neutral'></span>
  641 |     | <span class='neutral'>    function log(uint256 p0, string memory p1, bool p2, bool p3) internal pure {</span>
  642 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,string,bool,bool)&quot;, p0, p1, p2, p3));</span>
  643 |     | <span class='neutral'>    }</span>
  644 |     | <span class='neutral'></span>
  645 |     | <span class='neutral'>    function log(uint256 p0, string memory p1, bool p2, address p3) internal pure {</span>
  646 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,string,bool,address)&quot;, p0, p1, p2, p3));</span>
  647 |     | <span class='neutral'>    }</span>
  648 |     | <span class='neutral'></span>
  649 |     | <span class='neutral'>    function log(uint256 p0, string memory p1, address p2, uint256 p3) internal pure {</span>
  650 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,string,address,uint256)&quot;, p0, p1, p2, p3));</span>
  651 |     | <span class='neutral'>    }</span>
  652 |     | <span class='neutral'></span>
  653 |     | <span class='neutral'>    function log(uint256 p0, string memory p1, address p2, string memory p3) internal pure {</span>
  654 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,string,address,string)&quot;, p0, p1, p2, p3));</span>
  655 |     | <span class='neutral'>    }</span>
  656 |     | <span class='neutral'></span>
  657 |     | <span class='neutral'>    function log(uint256 p0, string memory p1, address p2, bool p3) internal pure {</span>
  658 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,string,address,bool)&quot;, p0, p1, p2, p3));</span>
  659 |     | <span class='neutral'>    }</span>
  660 |     | <span class='neutral'></span>
  661 |     | <span class='neutral'>    function log(uint256 p0, string memory p1, address p2, address p3) internal pure {</span>
  662 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,string,address,address)&quot;, p0, p1, p2, p3));</span>
  663 |     | <span class='neutral'>    }</span>
  664 |     | <span class='neutral'></span>
  665 |     | <span class='neutral'>    function log(uint256 p0, bool p1, uint256 p2, uint256 p3) internal pure {</span>
  666 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,bool,uint256,uint256)&quot;, p0, p1, p2, p3));</span>
  667 |     | <span class='neutral'>    }</span>
  668 |     | <span class='neutral'></span>
  669 |     | <span class='neutral'>    function log(uint256 p0, bool p1, uint256 p2, string memory p3) internal pure {</span>
  670 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,bool,uint256,string)&quot;, p0, p1, p2, p3));</span>
  671 |     | <span class='neutral'>    }</span>
  672 |     | <span class='neutral'></span>
  673 |     | <span class='neutral'>    function log(uint256 p0, bool p1, uint256 p2, bool p3) internal pure {</span>
  674 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,bool,uint256,bool)&quot;, p0, p1, p2, p3));</span>
  675 |     | <span class='neutral'>    }</span>
  676 |     | <span class='neutral'></span>
  677 |     | <span class='neutral'>    function log(uint256 p0, bool p1, uint256 p2, address p3) internal pure {</span>
  678 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,bool,uint256,address)&quot;, p0, p1, p2, p3));</span>
  679 |     | <span class='neutral'>    }</span>
  680 |     | <span class='neutral'></span>
  681 |     | <span class='neutral'>    function log(uint256 p0, bool p1, string memory p2, uint256 p3) internal pure {</span>
  682 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,bool,string,uint256)&quot;, p0, p1, p2, p3));</span>
  683 |     | <span class='neutral'>    }</span>
  684 |     | <span class='neutral'></span>
  685 |     | <span class='neutral'>    function log(uint256 p0, bool p1, string memory p2, string memory p3) internal pure {</span>
  686 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,bool,string,string)&quot;, p0, p1, p2, p3));</span>
  687 |     | <span class='neutral'>    }</span>
  688 |     | <span class='neutral'></span>
  689 |     | <span class='neutral'>    function log(uint256 p0, bool p1, string memory p2, bool p3) internal pure {</span>
  690 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,bool,string,bool)&quot;, p0, p1, p2, p3));</span>
  691 |     | <span class='neutral'>    }</span>
  692 |     | <span class='neutral'></span>
  693 |     | <span class='neutral'>    function log(uint256 p0, bool p1, string memory p2, address p3) internal pure {</span>
  694 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,bool,string,address)&quot;, p0, p1, p2, p3));</span>
  695 |     | <span class='neutral'>    }</span>
  696 |     | <span class='neutral'></span>
  697 |     | <span class='neutral'>    function log(uint256 p0, bool p1, bool p2, uint256 p3) internal pure {</span>
  698 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,bool,bool,uint256)&quot;, p0, p1, p2, p3));</span>
  699 |     | <span class='neutral'>    }</span>
  700 |     | <span class='neutral'></span>
  701 |     | <span class='neutral'>    function log(uint256 p0, bool p1, bool p2, string memory p3) internal pure {</span>
  702 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,bool,bool,string)&quot;, p0, p1, p2, p3));</span>
  703 |     | <span class='neutral'>    }</span>
  704 |     | <span class='neutral'></span>
  705 |     | <span class='neutral'>    function log(uint256 p0, bool p1, bool p2, bool p3) internal pure {</span>
  706 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,bool,bool,bool)&quot;, p0, p1, p2, p3));</span>
  707 |     | <span class='neutral'>    }</span>
  708 |     | <span class='neutral'></span>
  709 |     | <span class='neutral'>    function log(uint256 p0, bool p1, bool p2, address p3) internal pure {</span>
  710 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,bool,bool,address)&quot;, p0, p1, p2, p3));</span>
  711 |     | <span class='neutral'>    }</span>
  712 |     | <span class='neutral'></span>
  713 |     | <span class='neutral'>    function log(uint256 p0, bool p1, address p2, uint256 p3) internal pure {</span>
  714 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,bool,address,uint256)&quot;, p0, p1, p2, p3));</span>
  715 |     | <span class='neutral'>    }</span>
  716 |     | <span class='neutral'></span>
  717 |     | <span class='neutral'>    function log(uint256 p0, bool p1, address p2, string memory p3) internal pure {</span>
  718 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,bool,address,string)&quot;, p0, p1, p2, p3));</span>
  719 |     | <span class='neutral'>    }</span>
  720 |     | <span class='neutral'></span>
  721 |     | <span class='neutral'>    function log(uint256 p0, bool p1, address p2, bool p3) internal pure {</span>
  722 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,bool,address,bool)&quot;, p0, p1, p2, p3));</span>
  723 |     | <span class='neutral'>    }</span>
  724 |     | <span class='neutral'></span>
  725 |     | <span class='neutral'>    function log(uint256 p0, bool p1, address p2, address p3) internal pure {</span>
  726 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,bool,address,address)&quot;, p0, p1, p2, p3));</span>
  727 |     | <span class='neutral'>    }</span>
  728 |     | <span class='neutral'></span>
  729 |     | <span class='neutral'>    function log(uint256 p0, address p1, uint256 p2, uint256 p3) internal pure {</span>
  730 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,address,uint256,uint256)&quot;, p0, p1, p2, p3));</span>
  731 |     | <span class='neutral'>    }</span>
  732 |     | <span class='neutral'></span>
  733 |     | <span class='neutral'>    function log(uint256 p0, address p1, uint256 p2, string memory p3) internal pure {</span>
  734 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,address,uint256,string)&quot;, p0, p1, p2, p3));</span>
  735 |     | <span class='neutral'>    }</span>
  736 |     | <span class='neutral'></span>
  737 |     | <span class='neutral'>    function log(uint256 p0, address p1, uint256 p2, bool p3) internal pure {</span>
  738 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,address,uint256,bool)&quot;, p0, p1, p2, p3));</span>
  739 |     | <span class='neutral'>    }</span>
  740 |     | <span class='neutral'></span>
  741 |     | <span class='neutral'>    function log(uint256 p0, address p1, uint256 p2, address p3) internal pure {</span>
  742 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,address,uint256,address)&quot;, p0, p1, p2, p3));</span>
  743 |     | <span class='neutral'>    }</span>
  744 |     | <span class='neutral'></span>
  745 |     | <span class='neutral'>    function log(uint256 p0, address p1, string memory p2, uint256 p3) internal pure {</span>
  746 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,address,string,uint256)&quot;, p0, p1, p2, p3));</span>
  747 |     | <span class='neutral'>    }</span>
  748 |     | <span class='neutral'></span>
  749 |     | <span class='neutral'>    function log(uint256 p0, address p1, string memory p2, string memory p3) internal pure {</span>
  750 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,address,string,string)&quot;, p0, p1, p2, p3));</span>
  751 |     | <span class='neutral'>    }</span>
  752 |     | <span class='neutral'></span>
  753 |     | <span class='neutral'>    function log(uint256 p0, address p1, string memory p2, bool p3) internal pure {</span>
  754 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,address,string,bool)&quot;, p0, p1, p2, p3));</span>
  755 |     | <span class='neutral'>    }</span>
  756 |     | <span class='neutral'></span>
  757 |     | <span class='neutral'>    function log(uint256 p0, address p1, string memory p2, address p3) internal pure {</span>
  758 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,address,string,address)&quot;, p0, p1, p2, p3));</span>
  759 |     | <span class='neutral'>    }</span>
  760 |     | <span class='neutral'></span>
  761 |     | <span class='neutral'>    function log(uint256 p0, address p1, bool p2, uint256 p3) internal pure {</span>
  762 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,address,bool,uint256)&quot;, p0, p1, p2, p3));</span>
  763 |     | <span class='neutral'>    }</span>
  764 |     | <span class='neutral'></span>
  765 |     | <span class='neutral'>    function log(uint256 p0, address p1, bool p2, string memory p3) internal pure {</span>
  766 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,address,bool,string)&quot;, p0, p1, p2, p3));</span>
  767 |     | <span class='neutral'>    }</span>
  768 |     | <span class='neutral'></span>
  769 |     | <span class='neutral'>    function log(uint256 p0, address p1, bool p2, bool p3) internal pure {</span>
  770 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,address,bool,bool)&quot;, p0, p1, p2, p3));</span>
  771 |     | <span class='neutral'>    }</span>
  772 |     | <span class='neutral'></span>
  773 |     | <span class='neutral'>    function log(uint256 p0, address p1, bool p2, address p3) internal pure {</span>
  774 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,address,bool,address)&quot;, p0, p1, p2, p3));</span>
  775 |     | <span class='neutral'>    }</span>
  776 |     | <span class='neutral'></span>
  777 |     | <span class='neutral'>    function log(uint256 p0, address p1, address p2, uint256 p3) internal pure {</span>
  778 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,address,address,uint256)&quot;, p0, p1, p2, p3));</span>
  779 |     | <span class='neutral'>    }</span>
  780 |     | <span class='neutral'></span>
  781 |     | <span class='neutral'>    function log(uint256 p0, address p1, address p2, string memory p3) internal pure {</span>
  782 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,address,address,string)&quot;, p0, p1, p2, p3));</span>
  783 |     | <span class='neutral'>    }</span>
  784 |     | <span class='neutral'></span>
  785 |     | <span class='neutral'>    function log(uint256 p0, address p1, address p2, bool p3) internal pure {</span>
  786 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,address,address,bool)&quot;, p0, p1, p2, p3));</span>
  787 |     | <span class='neutral'>    }</span>
  788 |     | <span class='neutral'></span>
  789 |     | <span class='neutral'>    function log(uint256 p0, address p1, address p2, address p3) internal pure {</span>
  790 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,address,address,address)&quot;, p0, p1, p2, p3));</span>
  791 |     | <span class='neutral'>    }</span>
  792 |     | <span class='neutral'></span>
  793 |     | <span class='neutral'>    function log(string memory p0, uint256 p1, uint256 p2, uint256 p3) internal pure {</span>
  794 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,uint256,uint256,uint256)&quot;, p0, p1, p2, p3));</span>
  795 |     | <span class='neutral'>    }</span>
  796 |     | <span class='neutral'></span>
  797 |     | <span class='neutral'>    function log(string memory p0, uint256 p1, uint256 p2, string memory p3) internal pure {</span>
  798 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,uint256,uint256,string)&quot;, p0, p1, p2, p3));</span>
  799 |     | <span class='neutral'>    }</span>
  800 |     | <span class='neutral'></span>
  801 |     | <span class='neutral'>    function log(string memory p0, uint256 p1, uint256 p2, bool p3) internal pure {</span>
  802 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,uint256,uint256,bool)&quot;, p0, p1, p2, p3));</span>
  803 |     | <span class='neutral'>    }</span>
  804 |     | <span class='neutral'></span>
  805 |     | <span class='neutral'>    function log(string memory p0, uint256 p1, uint256 p2, address p3) internal pure {</span>
  806 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,uint256,uint256,address)&quot;, p0, p1, p2, p3));</span>
  807 |     | <span class='neutral'>    }</span>
  808 |     | <span class='neutral'></span>
  809 |     | <span class='neutral'>    function log(string memory p0, uint256 p1, string memory p2, uint256 p3) internal pure {</span>
  810 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,uint256,string,uint256)&quot;, p0, p1, p2, p3));</span>
  811 |     | <span class='neutral'>    }</span>
  812 |     | <span class='neutral'></span>
  813 |     | <span class='neutral'>    function log(string memory p0, uint256 p1, string memory p2, string memory p3) internal pure {</span>
  814 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,uint256,string,string)&quot;, p0, p1, p2, p3));</span>
  815 |     | <span class='neutral'>    }</span>
  816 |     | <span class='neutral'></span>
  817 |     | <span class='neutral'>    function log(string memory p0, uint256 p1, string memory p2, bool p3) internal pure {</span>
  818 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,uint256,string,bool)&quot;, p0, p1, p2, p3));</span>
  819 |     | <span class='neutral'>    }</span>
  820 |     | <span class='neutral'></span>
  821 |     | <span class='neutral'>    function log(string memory p0, uint256 p1, string memory p2, address p3) internal pure {</span>
  822 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,uint256,string,address)&quot;, p0, p1, p2, p3));</span>
  823 |     | <span class='neutral'>    }</span>
  824 |     | <span class='neutral'></span>
  825 |     | <span class='neutral'>    function log(string memory p0, uint256 p1, bool p2, uint256 p3) internal pure {</span>
  826 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,uint256,bool,uint256)&quot;, p0, p1, p2, p3));</span>
  827 |     | <span class='neutral'>    }</span>
  828 |     | <span class='neutral'></span>
  829 |     | <span class='neutral'>    function log(string memory p0, uint256 p1, bool p2, string memory p3) internal pure {</span>
  830 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,uint256,bool,string)&quot;, p0, p1, p2, p3));</span>
  831 |     | <span class='neutral'>    }</span>
  832 |     | <span class='neutral'></span>
  833 |     | <span class='neutral'>    function log(string memory p0, uint256 p1, bool p2, bool p3) internal pure {</span>
  834 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,uint256,bool,bool)&quot;, p0, p1, p2, p3));</span>
  835 |     | <span class='neutral'>    }</span>
  836 |     | <span class='neutral'></span>
  837 |     | <span class='neutral'>    function log(string memory p0, uint256 p1, bool p2, address p3) internal pure {</span>
  838 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,uint256,bool,address)&quot;, p0, p1, p2, p3));</span>
  839 |     | <span class='neutral'>    }</span>
  840 |     | <span class='neutral'></span>
  841 |     | <span class='neutral'>    function log(string memory p0, uint256 p1, address p2, uint256 p3) internal pure {</span>
  842 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,uint256,address,uint256)&quot;, p0, p1, p2, p3));</span>
  843 |     | <span class='neutral'>    }</span>
  844 |     | <span class='neutral'></span>
  845 |     | <span class='neutral'>    function log(string memory p0, uint256 p1, address p2, string memory p3) internal pure {</span>
  846 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,uint256,address,string)&quot;, p0, p1, p2, p3));</span>
  847 |     | <span class='neutral'>    }</span>
  848 |     | <span class='neutral'></span>
  849 |     | <span class='neutral'>    function log(string memory p0, uint256 p1, address p2, bool p3) internal pure {</span>
  850 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,uint256,address,bool)&quot;, p0, p1, p2, p3));</span>
  851 |     | <span class='neutral'>    }</span>
  852 |     | <span class='neutral'></span>
  853 |     | <span class='neutral'>    function log(string memory p0, uint256 p1, address p2, address p3) internal pure {</span>
  854 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,uint256,address,address)&quot;, p0, p1, p2, p3));</span>
  855 |     | <span class='neutral'>    }</span>
  856 |     | <span class='neutral'></span>
  857 |     | <span class='neutral'>    function log(string memory p0, string memory p1, uint256 p2, uint256 p3) internal pure {</span>
  858 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,string,uint256,uint256)&quot;, p0, p1, p2, p3));</span>
  859 |     | <span class='neutral'>    }</span>
  860 |     | <span class='neutral'></span>
  861 |     | <span class='neutral'>    function log(string memory p0, string memory p1, uint256 p2, string memory p3) internal pure {</span>
  862 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,string,uint256,string)&quot;, p0, p1, p2, p3));</span>
  863 |     | <span class='neutral'>    }</span>
  864 |     | <span class='neutral'></span>
  865 |     | <span class='neutral'>    function log(string memory p0, string memory p1, uint256 p2, bool p3) internal pure {</span>
  866 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,string,uint256,bool)&quot;, p0, p1, p2, p3));</span>
  867 |     | <span class='neutral'>    }</span>
  868 |     | <span class='neutral'></span>
  869 |     | <span class='neutral'>    function log(string memory p0, string memory p1, uint256 p2, address p3) internal pure {</span>
  870 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,string,uint256,address)&quot;, p0, p1, p2, p3));</span>
  871 |     | <span class='neutral'>    }</span>
  872 |     | <span class='neutral'></span>
  873 |     | <span class='neutral'>    function log(string memory p0, string memory p1, string memory p2, uint256 p3) internal pure {</span>
  874 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,string,string,uint256)&quot;, p0, p1, p2, p3));</span>
  875 |     | <span class='neutral'>    }</span>
  876 |     | <span class='neutral'></span>
  877 |     | <span class='neutral'>    function log(string memory p0, string memory p1, string memory p2, string memory p3) internal pure {</span>
  878 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,string,string,string)&quot;, p0, p1, p2, p3));</span>
  879 |     | <span class='neutral'>    }</span>
  880 |     | <span class='neutral'></span>
  881 |     | <span class='neutral'>    function log(string memory p0, string memory p1, string memory p2, bool p3) internal pure {</span>
  882 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,string,string,bool)&quot;, p0, p1, p2, p3));</span>
  883 |     | <span class='neutral'>    }</span>
  884 |     | <span class='neutral'></span>
  885 |     | <span class='neutral'>    function log(string memory p0, string memory p1, string memory p2, address p3) internal pure {</span>
  886 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,string,string,address)&quot;, p0, p1, p2, p3));</span>
  887 |     | <span class='neutral'>    }</span>
  888 |     | <span class='neutral'></span>
  889 |     | <span class='neutral'>    function log(string memory p0, string memory p1, bool p2, uint256 p3) internal pure {</span>
  890 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,string,bool,uint256)&quot;, p0, p1, p2, p3));</span>
  891 |     | <span class='neutral'>    }</span>
  892 |     | <span class='neutral'></span>
  893 |     | <span class='neutral'>    function log(string memory p0, string memory p1, bool p2, string memory p3) internal pure {</span>
  894 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,string,bool,string)&quot;, p0, p1, p2, p3));</span>
  895 |     | <span class='neutral'>    }</span>
  896 |     | <span class='neutral'></span>
  897 |     | <span class='neutral'>    function log(string memory p0, string memory p1, bool p2, bool p3) internal pure {</span>
  898 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,string,bool,bool)&quot;, p0, p1, p2, p3));</span>
  899 |     | <span class='neutral'>    }</span>
  900 |     | <span class='neutral'></span>
  901 |     | <span class='neutral'>    function log(string memory p0, string memory p1, bool p2, address p3) internal pure {</span>
  902 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,string,bool,address)&quot;, p0, p1, p2, p3));</span>
  903 |     | <span class='neutral'>    }</span>
  904 |     | <span class='neutral'></span>
  905 |     | <span class='neutral'>    function log(string memory p0, string memory p1, address p2, uint256 p3) internal pure {</span>
  906 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,string,address,uint256)&quot;, p0, p1, p2, p3));</span>
  907 |     | <span class='neutral'>    }</span>
  908 |     | <span class='neutral'></span>
  909 |     | <span class='neutral'>    function log(string memory p0, string memory p1, address p2, string memory p3) internal pure {</span>
  910 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,string,address,string)&quot;, p0, p1, p2, p3));</span>
  911 |     | <span class='neutral'>    }</span>
  912 |     | <span class='neutral'></span>
  913 |     | <span class='neutral'>    function log(string memory p0, string memory p1, address p2, bool p3) internal pure {</span>
  914 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,string,address,bool)&quot;, p0, p1, p2, p3));</span>
  915 |     | <span class='neutral'>    }</span>
  916 |     | <span class='neutral'></span>
  917 |     | <span class='neutral'>    function log(string memory p0, string memory p1, address p2, address p3) internal pure {</span>
  918 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,string,address,address)&quot;, p0, p1, p2, p3));</span>
  919 |     | <span class='neutral'>    }</span>
  920 |     | <span class='neutral'></span>
  921 |     | <span class='neutral'>    function log(string memory p0, bool p1, uint256 p2, uint256 p3) internal pure {</span>
  922 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,bool,uint256,uint256)&quot;, p0, p1, p2, p3));</span>
  923 |     | <span class='neutral'>    }</span>
  924 |     | <span class='neutral'></span>
  925 |     | <span class='neutral'>    function log(string memory p0, bool p1, uint256 p2, string memory p3) internal pure {</span>
  926 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,bool,uint256,string)&quot;, p0, p1, p2, p3));</span>
  927 |     | <span class='neutral'>    }</span>
  928 |     | <span class='neutral'></span>
  929 |     | <span class='neutral'>    function log(string memory p0, bool p1, uint256 p2, bool p3) internal pure {</span>
  930 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,bool,uint256,bool)&quot;, p0, p1, p2, p3));</span>
  931 |     | <span class='neutral'>    }</span>
  932 |     | <span class='neutral'></span>
  933 |     | <span class='neutral'>    function log(string memory p0, bool p1, uint256 p2, address p3) internal pure {</span>
  934 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,bool,uint256,address)&quot;, p0, p1, p2, p3));</span>
  935 |     | <span class='neutral'>    }</span>
  936 |     | <span class='neutral'></span>
  937 |     | <span class='neutral'>    function log(string memory p0, bool p1, string memory p2, uint256 p3) internal pure {</span>
  938 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,bool,string,uint256)&quot;, p0, p1, p2, p3));</span>
  939 |     | <span class='neutral'>    }</span>
  940 |     | <span class='neutral'></span>
  941 |     | <span class='neutral'>    function log(string memory p0, bool p1, string memory p2, string memory p3) internal pure {</span>
  942 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,bool,string,string)&quot;, p0, p1, p2, p3));</span>
  943 |     | <span class='neutral'>    }</span>
  944 |     | <span class='neutral'></span>
  945 |     | <span class='neutral'>    function log(string memory p0, bool p1, string memory p2, bool p3) internal pure {</span>
  946 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,bool,string,bool)&quot;, p0, p1, p2, p3));</span>
  947 |     | <span class='neutral'>    }</span>
  948 |     | <span class='neutral'></span>
  949 |     | <span class='neutral'>    function log(string memory p0, bool p1, string memory p2, address p3) internal pure {</span>
  950 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,bool,string,address)&quot;, p0, p1, p2, p3));</span>
  951 |     | <span class='neutral'>    }</span>
  952 |     | <span class='neutral'></span>
  953 |     | <span class='neutral'>    function log(string memory p0, bool p1, bool p2, uint256 p3) internal pure {</span>
  954 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,bool,bool,uint256)&quot;, p0, p1, p2, p3));</span>
  955 |     | <span class='neutral'>    }</span>
  956 |     | <span class='neutral'></span>
  957 |     | <span class='neutral'>    function log(string memory p0, bool p1, bool p2, string memory p3) internal pure {</span>
  958 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,bool,bool,string)&quot;, p0, p1, p2, p3));</span>
  959 |     | <span class='neutral'>    }</span>
  960 |     | <span class='neutral'></span>
  961 |     | <span class='neutral'>    function log(string memory p0, bool p1, bool p2, bool p3) internal pure {</span>
  962 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,bool,bool,bool)&quot;, p0, p1, p2, p3));</span>
  963 |     | <span class='neutral'>    }</span>
  964 |     | <span class='neutral'></span>
  965 |     | <span class='neutral'>    function log(string memory p0, bool p1, bool p2, address p3) internal pure {</span>
  966 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,bool,bool,address)&quot;, p0, p1, p2, p3));</span>
  967 |     | <span class='neutral'>    }</span>
  968 |     | <span class='neutral'></span>
  969 |     | <span class='neutral'>    function log(string memory p0, bool p1, address p2, uint256 p3) internal pure {</span>
  970 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,bool,address,uint256)&quot;, p0, p1, p2, p3));</span>
  971 |     | <span class='neutral'>    }</span>
  972 |     | <span class='neutral'></span>
  973 |     | <span class='neutral'>    function log(string memory p0, bool p1, address p2, string memory p3) internal pure {</span>
  974 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,bool,address,string)&quot;, p0, p1, p2, p3));</span>
  975 |     | <span class='neutral'>    }</span>
  976 |     | <span class='neutral'></span>
  977 |     | <span class='neutral'>    function log(string memory p0, bool p1, address p2, bool p3) internal pure {</span>
  978 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,bool,address,bool)&quot;, p0, p1, p2, p3));</span>
  979 |     | <span class='neutral'>    }</span>
  980 |     | <span class='neutral'></span>
  981 |     | <span class='neutral'>    function log(string memory p0, bool p1, address p2, address p3) internal pure {</span>
  982 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,bool,address,address)&quot;, p0, p1, p2, p3));</span>
  983 |     | <span class='neutral'>    }</span>
  984 |     | <span class='neutral'></span>
  985 |     | <span class='neutral'>    function log(string memory p0, address p1, uint256 p2, uint256 p3) internal pure {</span>
  986 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,address,uint256,uint256)&quot;, p0, p1, p2, p3));</span>
  987 |     | <span class='neutral'>    }</span>
  988 |     | <span class='neutral'></span>
  989 |     | <span class='neutral'>    function log(string memory p0, address p1, uint256 p2, string memory p3) internal pure {</span>
  990 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,address,uint256,string)&quot;, p0, p1, p2, p3));</span>
  991 |     | <span class='neutral'>    }</span>
  992 |     | <span class='neutral'></span>
  993 |     | <span class='neutral'>    function log(string memory p0, address p1, uint256 p2, bool p3) internal pure {</span>
  994 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,address,uint256,bool)&quot;, p0, p1, p2, p3));</span>
  995 |     | <span class='neutral'>    }</span>
  996 |     | <span class='neutral'></span>
  997 |     | <span class='neutral'>    function log(string memory p0, address p1, uint256 p2, address p3) internal pure {</span>
  998 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,address,uint256,address)&quot;, p0, p1, p2, p3));</span>
  999 |     | <span class='neutral'>    }</span>
 1000 |     | <span class='neutral'></span>
 1001 |     | <span class='neutral'>    function log(string memory p0, address p1, string memory p2, uint256 p3) internal pure {</span>
 1002 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,address,string,uint256)&quot;, p0, p1, p2, p3));</span>
 1003 |     | <span class='neutral'>    }</span>
 1004 |     | <span class='neutral'></span>
 1005 |     | <span class='neutral'>    function log(string memory p0, address p1, string memory p2, string memory p3) internal pure {</span>
 1006 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,address,string,string)&quot;, p0, p1, p2, p3));</span>
 1007 |     | <span class='neutral'>    }</span>
 1008 |     | <span class='neutral'></span>
 1009 |     | <span class='neutral'>    function log(string memory p0, address p1, string memory p2, bool p3) internal pure {</span>
 1010 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,address,string,bool)&quot;, p0, p1, p2, p3));</span>
 1011 |     | <span class='neutral'>    }</span>
 1012 |     | <span class='neutral'></span>
 1013 |     | <span class='neutral'>    function log(string memory p0, address p1, string memory p2, address p3) internal pure {</span>
 1014 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,address,string,address)&quot;, p0, p1, p2, p3));</span>
 1015 |     | <span class='neutral'>    }</span>
 1016 |     | <span class='neutral'></span>
 1017 |     | <span class='neutral'>    function log(string memory p0, address p1, bool p2, uint256 p3) internal pure {</span>
 1018 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,address,bool,uint256)&quot;, p0, p1, p2, p3));</span>
 1019 |     | <span class='neutral'>    }</span>
 1020 |     | <span class='neutral'></span>
 1021 |     | <span class='neutral'>    function log(string memory p0, address p1, bool p2, string memory p3) internal pure {</span>
 1022 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,address,bool,string)&quot;, p0, p1, p2, p3));</span>
 1023 |     | <span class='neutral'>    }</span>
 1024 |     | <span class='neutral'></span>
 1025 |     | <span class='neutral'>    function log(string memory p0, address p1, bool p2, bool p3) internal pure {</span>
 1026 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,address,bool,bool)&quot;, p0, p1, p2, p3));</span>
 1027 |     | <span class='neutral'>    }</span>
 1028 |     | <span class='neutral'></span>
 1029 |     | <span class='neutral'>    function log(string memory p0, address p1, bool p2, address p3) internal pure {</span>
 1030 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,address,bool,address)&quot;, p0, p1, p2, p3));</span>
 1031 |     | <span class='neutral'>    }</span>
 1032 |     | <span class='neutral'></span>
 1033 |     | <span class='neutral'>    function log(string memory p0, address p1, address p2, uint256 p3) internal pure {</span>
 1034 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,address,address,uint256)&quot;, p0, p1, p2, p3));</span>
 1035 |     | <span class='neutral'>    }</span>
 1036 |     | <span class='neutral'></span>
 1037 |     | <span class='neutral'>    function log(string memory p0, address p1, address p2, string memory p3) internal pure {</span>
 1038 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,address,address,string)&quot;, p0, p1, p2, p3));</span>
 1039 |     | <span class='neutral'>    }</span>
 1040 |     | <span class='neutral'></span>
 1041 |     | <span class='neutral'>    function log(string memory p0, address p1, address p2, bool p3) internal pure {</span>
 1042 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,address,address,bool)&quot;, p0, p1, p2, p3));</span>
 1043 |     | <span class='neutral'>    }</span>
 1044 |     | <span class='neutral'></span>
 1045 |     | <span class='neutral'>    function log(string memory p0, address p1, address p2, address p3) internal pure {</span>
 1046 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,address,address,address)&quot;, p0, p1, p2, p3));</span>
 1047 |     | <span class='neutral'>    }</span>
 1048 |     | <span class='neutral'></span>
 1049 |     | <span class='neutral'>    function log(bool p0, uint256 p1, uint256 p2, uint256 p3) internal pure {</span>
 1050 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,uint256,uint256,uint256)&quot;, p0, p1, p2, p3));</span>
 1051 |     | <span class='neutral'>    }</span>
 1052 |     | <span class='neutral'></span>
 1053 |     | <span class='neutral'>    function log(bool p0, uint256 p1, uint256 p2, string memory p3) internal pure {</span>
 1054 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,uint256,uint256,string)&quot;, p0, p1, p2, p3));</span>
 1055 |     | <span class='neutral'>    }</span>
 1056 |     | <span class='neutral'></span>
 1057 |     | <span class='neutral'>    function log(bool p0, uint256 p1, uint256 p2, bool p3) internal pure {</span>
 1058 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,uint256,uint256,bool)&quot;, p0, p1, p2, p3));</span>
 1059 |     | <span class='neutral'>    }</span>
 1060 |     | <span class='neutral'></span>
 1061 |     | <span class='neutral'>    function log(bool p0, uint256 p1, uint256 p2, address p3) internal pure {</span>
 1062 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,uint256,uint256,address)&quot;, p0, p1, p2, p3));</span>
 1063 |     | <span class='neutral'>    }</span>
 1064 |     | <span class='neutral'></span>
 1065 |     | <span class='neutral'>    function log(bool p0, uint256 p1, string memory p2, uint256 p3) internal pure {</span>
 1066 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,uint256,string,uint256)&quot;, p0, p1, p2, p3));</span>
 1067 |     | <span class='neutral'>    }</span>
 1068 |     | <span class='neutral'></span>
 1069 |     | <span class='neutral'>    function log(bool p0, uint256 p1, string memory p2, string memory p3) internal pure {</span>
 1070 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,uint256,string,string)&quot;, p0, p1, p2, p3));</span>
 1071 |     | <span class='neutral'>    }</span>
 1072 |     | <span class='neutral'></span>
 1073 |     | <span class='neutral'>    function log(bool p0, uint256 p1, string memory p2, bool p3) internal pure {</span>
 1074 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,uint256,string,bool)&quot;, p0, p1, p2, p3));</span>
 1075 |     | <span class='neutral'>    }</span>
 1076 |     | <span class='neutral'></span>
 1077 |     | <span class='neutral'>    function log(bool p0, uint256 p1, string memory p2, address p3) internal pure {</span>
 1078 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,uint256,string,address)&quot;, p0, p1, p2, p3));</span>
 1079 |     | <span class='neutral'>    }</span>
 1080 |     | <span class='neutral'></span>
 1081 |     | <span class='neutral'>    function log(bool p0, uint256 p1, bool p2, uint256 p3) internal pure {</span>
 1082 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,uint256,bool,uint256)&quot;, p0, p1, p2, p3));</span>
 1083 |     | <span class='neutral'>    }</span>
 1084 |     | <span class='neutral'></span>
 1085 |     | <span class='neutral'>    function log(bool p0, uint256 p1, bool p2, string memory p3) internal pure {</span>
 1086 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,uint256,bool,string)&quot;, p0, p1, p2, p3));</span>
 1087 |     | <span class='neutral'>    }</span>
 1088 |     | <span class='neutral'></span>
 1089 |     | <span class='neutral'>    function log(bool p0, uint256 p1, bool p2, bool p3) internal pure {</span>
 1090 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,uint256,bool,bool)&quot;, p0, p1, p2, p3));</span>
 1091 |     | <span class='neutral'>    }</span>
 1092 |     | <span class='neutral'></span>
 1093 |     | <span class='neutral'>    function log(bool p0, uint256 p1, bool p2, address p3) internal pure {</span>
 1094 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,uint256,bool,address)&quot;, p0, p1, p2, p3));</span>
 1095 |     | <span class='neutral'>    }</span>
 1096 |     | <span class='neutral'></span>
 1097 |     | <span class='neutral'>    function log(bool p0, uint256 p1, address p2, uint256 p3) internal pure {</span>
 1098 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,uint256,address,uint256)&quot;, p0, p1, p2, p3));</span>
 1099 |     | <span class='neutral'>    }</span>
 1100 |     | <span class='neutral'></span>
 1101 |     | <span class='neutral'>    function log(bool p0, uint256 p1, address p2, string memory p3) internal pure {</span>
 1102 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,uint256,address,string)&quot;, p0, p1, p2, p3));</span>
 1103 |     | <span class='neutral'>    }</span>
 1104 |     | <span class='neutral'></span>
 1105 |     | <span class='neutral'>    function log(bool p0, uint256 p1, address p2, bool p3) internal pure {</span>
 1106 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,uint256,address,bool)&quot;, p0, p1, p2, p3));</span>
 1107 |     | <span class='neutral'>    }</span>
 1108 |     | <span class='neutral'></span>
 1109 |     | <span class='neutral'>    function log(bool p0, uint256 p1, address p2, address p3) internal pure {</span>
 1110 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,uint256,address,address)&quot;, p0, p1, p2, p3));</span>
 1111 |     | <span class='neutral'>    }</span>
 1112 |     | <span class='neutral'></span>
 1113 |     | <span class='neutral'>    function log(bool p0, string memory p1, uint256 p2, uint256 p3) internal pure {</span>
 1114 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,string,uint256,uint256)&quot;, p0, p1, p2, p3));</span>
 1115 |     | <span class='neutral'>    }</span>
 1116 |     | <span class='neutral'></span>
 1117 |     | <span class='neutral'>    function log(bool p0, string memory p1, uint256 p2, string memory p3) internal pure {</span>
 1118 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,string,uint256,string)&quot;, p0, p1, p2, p3));</span>
 1119 |     | <span class='neutral'>    }</span>
 1120 |     | <span class='neutral'></span>
 1121 |     | <span class='neutral'>    function log(bool p0, string memory p1, uint256 p2, bool p3) internal pure {</span>
 1122 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,string,uint256,bool)&quot;, p0, p1, p2, p3));</span>
 1123 |     | <span class='neutral'>    }</span>
 1124 |     | <span class='neutral'></span>
 1125 |     | <span class='neutral'>    function log(bool p0, string memory p1, uint256 p2, address p3) internal pure {</span>
 1126 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,string,uint256,address)&quot;, p0, p1, p2, p3));</span>
 1127 |     | <span class='neutral'>    }</span>
 1128 |     | <span class='neutral'></span>
 1129 |     | <span class='neutral'>    function log(bool p0, string memory p1, string memory p2, uint256 p3) internal pure {</span>
 1130 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,string,string,uint256)&quot;, p0, p1, p2, p3));</span>
 1131 |     | <span class='neutral'>    }</span>
 1132 |     | <span class='neutral'></span>
 1133 |     | <span class='neutral'>    function log(bool p0, string memory p1, string memory p2, string memory p3) internal pure {</span>
 1134 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,string,string,string)&quot;, p0, p1, p2, p3));</span>
 1135 |     | <span class='neutral'>    }</span>
 1136 |     | <span class='neutral'></span>
 1137 |     | <span class='neutral'>    function log(bool p0, string memory p1, string memory p2, bool p3) internal pure {</span>
 1138 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,string,string,bool)&quot;, p0, p1, p2, p3));</span>
 1139 |     | <span class='neutral'>    }</span>
 1140 |     | <span class='neutral'></span>
 1141 |     | <span class='neutral'>    function log(bool p0, string memory p1, string memory p2, address p3) internal pure {</span>
 1142 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,string,string,address)&quot;, p0, p1, p2, p3));</span>
 1143 |     | <span class='neutral'>    }</span>
 1144 |     | <span class='neutral'></span>
 1145 |     | <span class='neutral'>    function log(bool p0, string memory p1, bool p2, uint256 p3) internal pure {</span>
 1146 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,string,bool,uint256)&quot;, p0, p1, p2, p3));</span>
 1147 |     | <span class='neutral'>    }</span>
 1148 |     | <span class='neutral'></span>
 1149 |     | <span class='neutral'>    function log(bool p0, string memory p1, bool p2, string memory p3) internal pure {</span>
 1150 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,string,bool,string)&quot;, p0, p1, p2, p3));</span>
 1151 |     | <span class='neutral'>    }</span>
 1152 |     | <span class='neutral'></span>
 1153 |     | <span class='neutral'>    function log(bool p0, string memory p1, bool p2, bool p3) internal pure {</span>
 1154 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,string,bool,bool)&quot;, p0, p1, p2, p3));</span>
 1155 |     | <span class='neutral'>    }</span>
 1156 |     | <span class='neutral'></span>
 1157 |     | <span class='neutral'>    function log(bool p0, string memory p1, bool p2, address p3) internal pure {</span>
 1158 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,string,bool,address)&quot;, p0, p1, p2, p3));</span>
 1159 |     | <span class='neutral'>    }</span>
 1160 |     | <span class='neutral'></span>
 1161 |     | <span class='neutral'>    function log(bool p0, string memory p1, address p2, uint256 p3) internal pure {</span>
 1162 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,string,address,uint256)&quot;, p0, p1, p2, p3));</span>
 1163 |     | <span class='neutral'>    }</span>
 1164 |     | <span class='neutral'></span>
 1165 |     | <span class='neutral'>    function log(bool p0, string memory p1, address p2, string memory p3) internal pure {</span>
 1166 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,string,address,string)&quot;, p0, p1, p2, p3));</span>
 1167 |     | <span class='neutral'>    }</span>
 1168 |     | <span class='neutral'></span>
 1169 |     | <span class='neutral'>    function log(bool p0, string memory p1, address p2, bool p3) internal pure {</span>
 1170 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,string,address,bool)&quot;, p0, p1, p2, p3));</span>
 1171 |     | <span class='neutral'>    }</span>
 1172 |     | <span class='neutral'></span>
 1173 |     | <span class='neutral'>    function log(bool p0, string memory p1, address p2, address p3) internal pure {</span>
 1174 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,string,address,address)&quot;, p0, p1, p2, p3));</span>
 1175 |     | <span class='neutral'>    }</span>
 1176 |     | <span class='neutral'></span>
 1177 |     | <span class='neutral'>    function log(bool p0, bool p1, uint256 p2, uint256 p3) internal pure {</span>
 1178 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,bool,uint256,uint256)&quot;, p0, p1, p2, p3));</span>
 1179 |     | <span class='neutral'>    }</span>
 1180 |     | <span class='neutral'></span>
 1181 |     | <span class='neutral'>    function log(bool p0, bool p1, uint256 p2, string memory p3) internal pure {</span>
 1182 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,bool,uint256,string)&quot;, p0, p1, p2, p3));</span>
 1183 |     | <span class='neutral'>    }</span>
 1184 |     | <span class='neutral'></span>
 1185 |     | <span class='neutral'>    function log(bool p0, bool p1, uint256 p2, bool p3) internal pure {</span>
 1186 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,bool,uint256,bool)&quot;, p0, p1, p2, p3));</span>
 1187 |     | <span class='neutral'>    }</span>
 1188 |     | <span class='neutral'></span>
 1189 |     | <span class='neutral'>    function log(bool p0, bool p1, uint256 p2, address p3) internal pure {</span>
 1190 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,bool,uint256,address)&quot;, p0, p1, p2, p3));</span>
 1191 |     | <span class='neutral'>    }</span>
 1192 |     | <span class='neutral'></span>
 1193 |     | <span class='neutral'>    function log(bool p0, bool p1, string memory p2, uint256 p3) internal pure {</span>
 1194 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,bool,string,uint256)&quot;, p0, p1, p2, p3));</span>
 1195 |     | <span class='neutral'>    }</span>
 1196 |     | <span class='neutral'></span>
 1197 |     | <span class='neutral'>    function log(bool p0, bool p1, string memory p2, string memory p3) internal pure {</span>
 1198 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,bool,string,string)&quot;, p0, p1, p2, p3));</span>
 1199 |     | <span class='neutral'>    }</span>
 1200 |     | <span class='neutral'></span>
 1201 |     | <span class='neutral'>    function log(bool p0, bool p1, string memory p2, bool p3) internal pure {</span>
 1202 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,bool,string,bool)&quot;, p0, p1, p2, p3));</span>
 1203 |     | <span class='neutral'>    }</span>
 1204 |     | <span class='neutral'></span>
 1205 |     | <span class='neutral'>    function log(bool p0, bool p1, string memory p2, address p3) internal pure {</span>
 1206 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,bool,string,address)&quot;, p0, p1, p2, p3));</span>
 1207 |     | <span class='neutral'>    }</span>
 1208 |     | <span class='neutral'></span>
 1209 |     | <span class='neutral'>    function log(bool p0, bool p1, bool p2, uint256 p3) internal pure {</span>
 1210 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,bool,bool,uint256)&quot;, p0, p1, p2, p3));</span>
 1211 |     | <span class='neutral'>    }</span>
 1212 |     | <span class='neutral'></span>
 1213 |     | <span class='neutral'>    function log(bool p0, bool p1, bool p2, string memory p3) internal pure {</span>
 1214 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,bool,bool,string)&quot;, p0, p1, p2, p3));</span>
 1215 |     | <span class='neutral'>    }</span>
 1216 |     | <span class='neutral'></span>
 1217 |     | <span class='neutral'>    function log(bool p0, bool p1, bool p2, bool p3) internal pure {</span>
 1218 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,bool,bool,bool)&quot;, p0, p1, p2, p3));</span>
 1219 |     | <span class='neutral'>    }</span>
 1220 |     | <span class='neutral'></span>
 1221 |     | <span class='neutral'>    function log(bool p0, bool p1, bool p2, address p3) internal pure {</span>
 1222 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,bool,bool,address)&quot;, p0, p1, p2, p3));</span>
 1223 |     | <span class='neutral'>    }</span>
 1224 |     | <span class='neutral'></span>
 1225 |     | <span class='neutral'>    function log(bool p0, bool p1, address p2, uint256 p3) internal pure {</span>
 1226 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,bool,address,uint256)&quot;, p0, p1, p2, p3));</span>
 1227 |     | <span class='neutral'>    }</span>
 1228 |     | <span class='neutral'></span>
 1229 |     | <span class='neutral'>    function log(bool p0, bool p1, address p2, string memory p3) internal pure {</span>
 1230 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,bool,address,string)&quot;, p0, p1, p2, p3));</span>
 1231 |     | <span class='neutral'>    }</span>
 1232 |     | <span class='neutral'></span>
 1233 |     | <span class='neutral'>    function log(bool p0, bool p1, address p2, bool p3) internal pure {</span>
 1234 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,bool,address,bool)&quot;, p0, p1, p2, p3));</span>
 1235 |     | <span class='neutral'>    }</span>
 1236 |     | <span class='neutral'></span>
 1237 |     | <span class='neutral'>    function log(bool p0, bool p1, address p2, address p3) internal pure {</span>
 1238 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,bool,address,address)&quot;, p0, p1, p2, p3));</span>
 1239 |     | <span class='neutral'>    }</span>
 1240 |     | <span class='neutral'></span>
 1241 |     | <span class='neutral'>    function log(bool p0, address p1, uint256 p2, uint256 p3) internal pure {</span>
 1242 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,address,uint256,uint256)&quot;, p0, p1, p2, p3));</span>
 1243 |     | <span class='neutral'>    }</span>
 1244 |     | <span class='neutral'></span>
 1245 |     | <span class='neutral'>    function log(bool p0, address p1, uint256 p2, string memory p3) internal pure {</span>
 1246 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,address,uint256,string)&quot;, p0, p1, p2, p3));</span>
 1247 |     | <span class='neutral'>    }</span>
 1248 |     | <span class='neutral'></span>
 1249 |     | <span class='neutral'>    function log(bool p0, address p1, uint256 p2, bool p3) internal pure {</span>
 1250 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,address,uint256,bool)&quot;, p0, p1, p2, p3));</span>
 1251 |     | <span class='neutral'>    }</span>
 1252 |     | <span class='neutral'></span>
 1253 |     | <span class='neutral'>    function log(bool p0, address p1, uint256 p2, address p3) internal pure {</span>
 1254 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,address,uint256,address)&quot;, p0, p1, p2, p3));</span>
 1255 |     | <span class='neutral'>    }</span>
 1256 |     | <span class='neutral'></span>
 1257 |     | <span class='neutral'>    function log(bool p0, address p1, string memory p2, uint256 p3) internal pure {</span>
 1258 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,address,string,uint256)&quot;, p0, p1, p2, p3));</span>
 1259 |     | <span class='neutral'>    }</span>
 1260 |     | <span class='neutral'></span>
 1261 |     | <span class='neutral'>    function log(bool p0, address p1, string memory p2, string memory p3) internal pure {</span>
 1262 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,address,string,string)&quot;, p0, p1, p2, p3));</span>
 1263 |     | <span class='neutral'>    }</span>
 1264 |     | <span class='neutral'></span>
 1265 |     | <span class='neutral'>    function log(bool p0, address p1, string memory p2, bool p3) internal pure {</span>
 1266 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,address,string,bool)&quot;, p0, p1, p2, p3));</span>
 1267 |     | <span class='neutral'>    }</span>
 1268 |     | <span class='neutral'></span>
 1269 |     | <span class='neutral'>    function log(bool p0, address p1, string memory p2, address p3) internal pure {</span>
 1270 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,address,string,address)&quot;, p0, p1, p2, p3));</span>
 1271 |     | <span class='neutral'>    }</span>
 1272 |     | <span class='neutral'></span>
 1273 |     | <span class='neutral'>    function log(bool p0, address p1, bool p2, uint256 p3) internal pure {</span>
 1274 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,address,bool,uint256)&quot;, p0, p1, p2, p3));</span>
 1275 |     | <span class='neutral'>    }</span>
 1276 |     | <span class='neutral'></span>
 1277 |     | <span class='neutral'>    function log(bool p0, address p1, bool p2, string memory p3) internal pure {</span>
 1278 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,address,bool,string)&quot;, p0, p1, p2, p3));</span>
 1279 |     | <span class='neutral'>    }</span>
 1280 |     | <span class='neutral'></span>
 1281 |     | <span class='neutral'>    function log(bool p0, address p1, bool p2, bool p3) internal pure {</span>
 1282 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,address,bool,bool)&quot;, p0, p1, p2, p3));</span>
 1283 |     | <span class='neutral'>    }</span>
 1284 |     | <span class='neutral'></span>
 1285 |     | <span class='neutral'>    function log(bool p0, address p1, bool p2, address p3) internal pure {</span>
 1286 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,address,bool,address)&quot;, p0, p1, p2, p3));</span>
 1287 |     | <span class='neutral'>    }</span>
 1288 |     | <span class='neutral'></span>
 1289 |     | <span class='neutral'>    function log(bool p0, address p1, address p2, uint256 p3) internal pure {</span>
 1290 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,address,address,uint256)&quot;, p0, p1, p2, p3));</span>
 1291 |     | <span class='neutral'>    }</span>
 1292 |     | <span class='neutral'></span>
 1293 |     | <span class='neutral'>    function log(bool p0, address p1, address p2, string memory p3) internal pure {</span>
 1294 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,address,address,string)&quot;, p0, p1, p2, p3));</span>
 1295 |     | <span class='neutral'>    }</span>
 1296 |     | <span class='neutral'></span>
 1297 |     | <span class='neutral'>    function log(bool p0, address p1, address p2, bool p3) internal pure {</span>
 1298 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,address,address,bool)&quot;, p0, p1, p2, p3));</span>
 1299 |     | <span class='neutral'>    }</span>
 1300 |     | <span class='neutral'></span>
 1301 |     | <span class='neutral'>    function log(bool p0, address p1, address p2, address p3) internal pure {</span>
 1302 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,address,address,address)&quot;, p0, p1, p2, p3));</span>
 1303 |     | <span class='neutral'>    }</span>
 1304 |     | <span class='neutral'></span>
 1305 |     | <span class='neutral'>    function log(address p0, uint256 p1, uint256 p2, uint256 p3) internal pure {</span>
 1306 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,uint256,uint256,uint256)&quot;, p0, p1, p2, p3));</span>
 1307 |     | <span class='neutral'>    }</span>
 1308 |     | <span class='neutral'></span>
 1309 |     | <span class='neutral'>    function log(address p0, uint256 p1, uint256 p2, string memory p3) internal pure {</span>
 1310 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,uint256,uint256,string)&quot;, p0, p1, p2, p3));</span>
 1311 |     | <span class='neutral'>    }</span>
 1312 |     | <span class='neutral'></span>
 1313 |     | <span class='neutral'>    function log(address p0, uint256 p1, uint256 p2, bool p3) internal pure {</span>
 1314 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,uint256,uint256,bool)&quot;, p0, p1, p2, p3));</span>
 1315 |     | <span class='neutral'>    }</span>
 1316 |     | <span class='neutral'></span>
 1317 |     | <span class='neutral'>    function log(address p0, uint256 p1, uint256 p2, address p3) internal pure {</span>
 1318 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,uint256,uint256,address)&quot;, p0, p1, p2, p3));</span>
 1319 |     | <span class='neutral'>    }</span>
 1320 |     | <span class='neutral'></span>
 1321 |     | <span class='neutral'>    function log(address p0, uint256 p1, string memory p2, uint256 p3) internal pure {</span>
 1322 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,uint256,string,uint256)&quot;, p0, p1, p2, p3));</span>
 1323 |     | <span class='neutral'>    }</span>
 1324 |     | <span class='neutral'></span>
 1325 |     | <span class='neutral'>    function log(address p0, uint256 p1, string memory p2, string memory p3) internal pure {</span>
 1326 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,uint256,string,string)&quot;, p0, p1, p2, p3));</span>
 1327 |     | <span class='neutral'>    }</span>
 1328 |     | <span class='neutral'></span>
 1329 |     | <span class='neutral'>    function log(address p0, uint256 p1, string memory p2, bool p3) internal pure {</span>
 1330 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,uint256,string,bool)&quot;, p0, p1, p2, p3));</span>
 1331 |     | <span class='neutral'>    }</span>
 1332 |     | <span class='neutral'></span>
 1333 |     | <span class='neutral'>    function log(address p0, uint256 p1, string memory p2, address p3) internal pure {</span>
 1334 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,uint256,string,address)&quot;, p0, p1, p2, p3));</span>
 1335 |     | <span class='neutral'>    }</span>
 1336 |     | <span class='neutral'></span>
 1337 |     | <span class='neutral'>    function log(address p0, uint256 p1, bool p2, uint256 p3) internal pure {</span>
 1338 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,uint256,bool,uint256)&quot;, p0, p1, p2, p3));</span>
 1339 |     | <span class='neutral'>    }</span>
 1340 |     | <span class='neutral'></span>
 1341 |     | <span class='neutral'>    function log(address p0, uint256 p1, bool p2, string memory p3) internal pure {</span>
 1342 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,uint256,bool,string)&quot;, p0, p1, p2, p3));</span>
 1343 |     | <span class='neutral'>    }</span>
 1344 |     | <span class='neutral'></span>
 1345 |     | <span class='neutral'>    function log(address p0, uint256 p1, bool p2, bool p3) internal pure {</span>
 1346 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,uint256,bool,bool)&quot;, p0, p1, p2, p3));</span>
 1347 |     | <span class='neutral'>    }</span>
 1348 |     | <span class='neutral'></span>
 1349 |     | <span class='neutral'>    function log(address p0, uint256 p1, bool p2, address p3) internal pure {</span>
 1350 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,uint256,bool,address)&quot;, p0, p1, p2, p3));</span>
 1351 |     | <span class='neutral'>    }</span>
 1352 |     | <span class='neutral'></span>
 1353 |     | <span class='neutral'>    function log(address p0, uint256 p1, address p2, uint256 p3) internal pure {</span>
 1354 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,uint256,address,uint256)&quot;, p0, p1, p2, p3));</span>
 1355 |     | <span class='neutral'>    }</span>
 1356 |     | <span class='neutral'></span>
 1357 |     | <span class='neutral'>    function log(address p0, uint256 p1, address p2, string memory p3) internal pure {</span>
 1358 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,uint256,address,string)&quot;, p0, p1, p2, p3));</span>
 1359 |     | <span class='neutral'>    }</span>
 1360 |     | <span class='neutral'></span>
 1361 |     | <span class='neutral'>    function log(address p0, uint256 p1, address p2, bool p3) internal pure {</span>
 1362 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,uint256,address,bool)&quot;, p0, p1, p2, p3));</span>
 1363 |     | <span class='neutral'>    }</span>
 1364 |     | <span class='neutral'></span>
 1365 |     | <span class='neutral'>    function log(address p0, uint256 p1, address p2, address p3) internal pure {</span>
 1366 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,uint256,address,address)&quot;, p0, p1, p2, p3));</span>
 1367 |     | <span class='neutral'>    }</span>
 1368 |     | <span class='neutral'></span>
 1369 |     | <span class='neutral'>    function log(address p0, string memory p1, uint256 p2, uint256 p3) internal pure {</span>
 1370 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,string,uint256,uint256)&quot;, p0, p1, p2, p3));</span>
 1371 |     | <span class='neutral'>    }</span>
 1372 |     | <span class='neutral'></span>
 1373 |     | <span class='neutral'>    function log(address p0, string memory p1, uint256 p2, string memory p3) internal pure {</span>
 1374 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,string,uint256,string)&quot;, p0, p1, p2, p3));</span>
 1375 |     | <span class='neutral'>    }</span>
 1376 |     | <span class='neutral'></span>
 1377 |     | <span class='neutral'>    function log(address p0, string memory p1, uint256 p2, bool p3) internal pure {</span>
 1378 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,string,uint256,bool)&quot;, p0, p1, p2, p3));</span>
 1379 |     | <span class='neutral'>    }</span>
 1380 |     | <span class='neutral'></span>
 1381 |     | <span class='neutral'>    function log(address p0, string memory p1, uint256 p2, address p3) internal pure {</span>
 1382 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,string,uint256,address)&quot;, p0, p1, p2, p3));</span>
 1383 |     | <span class='neutral'>    }</span>
 1384 |     | <span class='neutral'></span>
 1385 |     | <span class='neutral'>    function log(address p0, string memory p1, string memory p2, uint256 p3) internal pure {</span>
 1386 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,string,string,uint256)&quot;, p0, p1, p2, p3));</span>
 1387 |     | <span class='neutral'>    }</span>
 1388 |     | <span class='neutral'></span>
 1389 |     | <span class='neutral'>    function log(address p0, string memory p1, string memory p2, string memory p3) internal pure {</span>
 1390 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,string,string,string)&quot;, p0, p1, p2, p3));</span>
 1391 |     | <span class='neutral'>    }</span>
 1392 |     | <span class='neutral'></span>
 1393 |     | <span class='neutral'>    function log(address p0, string memory p1, string memory p2, bool p3) internal pure {</span>
 1394 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,string,string,bool)&quot;, p0, p1, p2, p3));</span>
 1395 |     | <span class='neutral'>    }</span>
 1396 |     | <span class='neutral'></span>
 1397 |     | <span class='neutral'>    function log(address p0, string memory p1, string memory p2, address p3) internal pure {</span>
 1398 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,string,string,address)&quot;, p0, p1, p2, p3));</span>
 1399 |     | <span class='neutral'>    }</span>
 1400 |     | <span class='neutral'></span>
 1401 |     | <span class='neutral'>    function log(address p0, string memory p1, bool p2, uint256 p3) internal pure {</span>
 1402 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,string,bool,uint256)&quot;, p0, p1, p2, p3));</span>
 1403 |     | <span class='neutral'>    }</span>
 1404 |     | <span class='neutral'></span>
 1405 |     | <span class='neutral'>    function log(address p0, string memory p1, bool p2, string memory p3) internal pure {</span>
 1406 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,string,bool,string)&quot;, p0, p1, p2, p3));</span>
 1407 |     | <span class='neutral'>    }</span>
 1408 |     | <span class='neutral'></span>
 1409 |     | <span class='neutral'>    function log(address p0, string memory p1, bool p2, bool p3) internal pure {</span>
 1410 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,string,bool,bool)&quot;, p0, p1, p2, p3));</span>
 1411 |     | <span class='neutral'>    }</span>
 1412 |     | <span class='neutral'></span>
 1413 |     | <span class='neutral'>    function log(address p0, string memory p1, bool p2, address p3) internal pure {</span>
 1414 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,string,bool,address)&quot;, p0, p1, p2, p3));</span>
 1415 |     | <span class='neutral'>    }</span>
 1416 |     | <span class='neutral'></span>
 1417 |     | <span class='neutral'>    function log(address p0, string memory p1, address p2, uint256 p3) internal pure {</span>
 1418 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,string,address,uint256)&quot;, p0, p1, p2, p3));</span>
 1419 |     | <span class='neutral'>    }</span>
 1420 |     | <span class='neutral'></span>
 1421 |     | <span class='neutral'>    function log(address p0, string memory p1, address p2, string memory p3) internal pure {</span>
 1422 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,string,address,string)&quot;, p0, p1, p2, p3));</span>
 1423 |     | <span class='neutral'>    }</span>
 1424 |     | <span class='neutral'></span>
 1425 |     | <span class='neutral'>    function log(address p0, string memory p1, address p2, bool p3) internal pure {</span>
 1426 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,string,address,bool)&quot;, p0, p1, p2, p3));</span>
 1427 |     | <span class='neutral'>    }</span>
 1428 |     | <span class='neutral'></span>
 1429 |     | <span class='neutral'>    function log(address p0, string memory p1, address p2, address p3) internal pure {</span>
 1430 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,string,address,address)&quot;, p0, p1, p2, p3));</span>
 1431 |     | <span class='neutral'>    }</span>
 1432 |     | <span class='neutral'></span>
 1433 |     | <span class='neutral'>    function log(address p0, bool p1, uint256 p2, uint256 p3) internal pure {</span>
 1434 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,bool,uint256,uint256)&quot;, p0, p1, p2, p3));</span>
 1435 |     | <span class='neutral'>    }</span>
 1436 |     | <span class='neutral'></span>
 1437 |     | <span class='neutral'>    function log(address p0, bool p1, uint256 p2, string memory p3) internal pure {</span>
 1438 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,bool,uint256,string)&quot;, p0, p1, p2, p3));</span>
 1439 |     | <span class='neutral'>    }</span>
 1440 |     | <span class='neutral'></span>
 1441 |     | <span class='neutral'>    function log(address p0, bool p1, uint256 p2, bool p3) internal pure {</span>
 1442 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,bool,uint256,bool)&quot;, p0, p1, p2, p3));</span>
 1443 |     | <span class='neutral'>    }</span>
 1444 |     | <span class='neutral'></span>
 1445 |     | <span class='neutral'>    function log(address p0, bool p1, uint256 p2, address p3) internal pure {</span>
 1446 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,bool,uint256,address)&quot;, p0, p1, p2, p3));</span>
 1447 |     | <span class='neutral'>    }</span>
 1448 |     | <span class='neutral'></span>
 1449 |     | <span class='neutral'>    function log(address p0, bool p1, string memory p2, uint256 p3) internal pure {</span>
 1450 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,bool,string,uint256)&quot;, p0, p1, p2, p3));</span>
 1451 |     | <span class='neutral'>    }</span>
 1452 |     | <span class='neutral'></span>
 1453 |     | <span class='neutral'>    function log(address p0, bool p1, string memory p2, string memory p3) internal pure {</span>
 1454 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,bool,string,string)&quot;, p0, p1, p2, p3));</span>
 1455 |     | <span class='neutral'>    }</span>
 1456 |     | <span class='neutral'></span>
 1457 |     | <span class='neutral'>    function log(address p0, bool p1, string memory p2, bool p3) internal pure {</span>
 1458 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,bool,string,bool)&quot;, p0, p1, p2, p3));</span>
 1459 |     | <span class='neutral'>    }</span>
 1460 |     | <span class='neutral'></span>
 1461 |     | <span class='neutral'>    function log(address p0, bool p1, string memory p2, address p3) internal pure {</span>
 1462 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,bool,string,address)&quot;, p0, p1, p2, p3));</span>
 1463 |     | <span class='neutral'>    }</span>
 1464 |     | <span class='neutral'></span>
 1465 |     | <span class='neutral'>    function log(address p0, bool p1, bool p2, uint256 p3) internal pure {</span>
 1466 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,bool,bool,uint256)&quot;, p0, p1, p2, p3));</span>
 1467 |     | <span class='neutral'>    }</span>
 1468 |     | <span class='neutral'></span>
 1469 |     | <span class='neutral'>    function log(address p0, bool p1, bool p2, string memory p3) internal pure {</span>
 1470 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,bool,bool,string)&quot;, p0, p1, p2, p3));</span>
 1471 |     | <span class='neutral'>    }</span>
 1472 |     | <span class='neutral'></span>
 1473 |     | <span class='neutral'>    function log(address p0, bool p1, bool p2, bool p3) internal pure {</span>
 1474 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,bool,bool,bool)&quot;, p0, p1, p2, p3));</span>
 1475 |     | <span class='neutral'>    }</span>
 1476 |     | <span class='neutral'></span>
 1477 |     | <span class='neutral'>    function log(address p0, bool p1, bool p2, address p3) internal pure {</span>
 1478 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,bool,bool,address)&quot;, p0, p1, p2, p3));</span>
 1479 |     | <span class='neutral'>    }</span>
 1480 |     | <span class='neutral'></span>
 1481 |     | <span class='neutral'>    function log(address p0, bool p1, address p2, uint256 p3) internal pure {</span>
 1482 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,bool,address,uint256)&quot;, p0, p1, p2, p3));</span>
 1483 |     | <span class='neutral'>    }</span>
 1484 |     | <span class='neutral'></span>
 1485 |     | <span class='neutral'>    function log(address p0, bool p1, address p2, string memory p3) internal pure {</span>
 1486 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,bool,address,string)&quot;, p0, p1, p2, p3));</span>
 1487 |     | <span class='neutral'>    }</span>
 1488 |     | <span class='neutral'></span>
 1489 |     | <span class='neutral'>    function log(address p0, bool p1, address p2, bool p3) internal pure {</span>
 1490 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,bool,address,bool)&quot;, p0, p1, p2, p3));</span>
 1491 |     | <span class='neutral'>    }</span>
 1492 |     | <span class='neutral'></span>
 1493 |     | <span class='neutral'>    function log(address p0, bool p1, address p2, address p3) internal pure {</span>
 1494 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,bool,address,address)&quot;, p0, p1, p2, p3));</span>
 1495 |     | <span class='neutral'>    }</span>
 1496 |     | <span class='neutral'></span>
 1497 |     | <span class='neutral'>    function log(address p0, address p1, uint256 p2, uint256 p3) internal pure {</span>
 1498 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,address,uint256,uint256)&quot;, p0, p1, p2, p3));</span>
 1499 |     | <span class='neutral'>    }</span>
 1500 |     | <span class='neutral'></span>
 1501 |     | <span class='neutral'>    function log(address p0, address p1, uint256 p2, string memory p3) internal pure {</span>
 1502 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,address,uint256,string)&quot;, p0, p1, p2, p3));</span>
 1503 |     | <span class='neutral'>    }</span>
 1504 |     | <span class='neutral'></span>
 1505 |     | <span class='neutral'>    function log(address p0, address p1, uint256 p2, bool p3) internal pure {</span>
 1506 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,address,uint256,bool)&quot;, p0, p1, p2, p3));</span>
 1507 |     | <span class='neutral'>    }</span>
 1508 |     | <span class='neutral'></span>
 1509 |     | <span class='neutral'>    function log(address p0, address p1, uint256 p2, address p3) internal pure {</span>
 1510 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,address,uint256,address)&quot;, p0, p1, p2, p3));</span>
 1511 |     | <span class='neutral'>    }</span>
 1512 |     | <span class='neutral'></span>
 1513 |     | <span class='neutral'>    function log(address p0, address p1, string memory p2, uint256 p3) internal pure {</span>
 1514 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,address,string,uint256)&quot;, p0, p1, p2, p3));</span>
 1515 |     | <span class='neutral'>    }</span>
 1516 |     | <span class='neutral'></span>
 1517 |     | <span class='neutral'>    function log(address p0, address p1, string memory p2, string memory p3) internal pure {</span>
 1518 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,address,string,string)&quot;, p0, p1, p2, p3));</span>
 1519 |     | <span class='neutral'>    }</span>
 1520 |     | <span class='neutral'></span>
 1521 |     | <span class='neutral'>    function log(address p0, address p1, string memory p2, bool p3) internal pure {</span>
 1522 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,address,string,bool)&quot;, p0, p1, p2, p3));</span>
 1523 |     | <span class='neutral'>    }</span>
 1524 |     | <span class='neutral'></span>
 1525 |     | <span class='neutral'>    function log(address p0, address p1, string memory p2, address p3) internal pure {</span>
 1526 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,address,string,address)&quot;, p0, p1, p2, p3));</span>
 1527 |     | <span class='neutral'>    }</span>
 1528 |     | <span class='neutral'></span>
 1529 |     | <span class='neutral'>    function log(address p0, address p1, bool p2, uint256 p3) internal pure {</span>
 1530 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,address,bool,uint256)&quot;, p0, p1, p2, p3));</span>
 1531 |     | <span class='neutral'>    }</span>
 1532 |     | <span class='neutral'></span>
 1533 |     | <span class='neutral'>    function log(address p0, address p1, bool p2, string memory p3) internal pure {</span>
 1534 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,address,bool,string)&quot;, p0, p1, p2, p3));</span>
 1535 |     | <span class='neutral'>    }</span>
 1536 |     | <span class='neutral'></span>
 1537 |     | <span class='neutral'>    function log(address p0, address p1, bool p2, bool p3) internal pure {</span>
 1538 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,address,bool,bool)&quot;, p0, p1, p2, p3));</span>
 1539 |     | <span class='neutral'>    }</span>
 1540 |     | <span class='neutral'></span>
 1541 |     | <span class='neutral'>    function log(address p0, address p1, bool p2, address p3) internal pure {</span>
 1542 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,address,bool,address)&quot;, p0, p1, p2, p3));</span>
 1543 |     | <span class='neutral'>    }</span>
 1544 |     | <span class='neutral'></span>
 1545 |     | <span class='neutral'>    function log(address p0, address p1, address p2, uint256 p3) internal pure {</span>
 1546 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,address,address,uint256)&quot;, p0, p1, p2, p3));</span>
 1547 |     | <span class='neutral'>    }</span>
 1548 |     | <span class='neutral'></span>
 1549 |     | <span class='neutral'>    function log(address p0, address p1, address p2, string memory p3) internal pure {</span>
 1550 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,address,address,string)&quot;, p0, p1, p2, p3));</span>
 1551 |     | <span class='neutral'>    }</span>
 1552 |     | <span class='neutral'></span>
 1553 |     | <span class='neutral'>    function log(address p0, address p1, address p2, bool p3) internal pure {</span>
 1554 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,address,address,bool)&quot;, p0, p1, p2, p3));</span>
 1555 |     | <span class='neutral'>    }</span>
 1556 |     | <span class='neutral'></span>
 1557 |     | <span class='neutral'>    function log(address p0, address p1, address p2, address p3) internal pure {</span>
 1558 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,address,address,address)&quot;, p0, p1, p2, p3));</span>
 1559 |     | <span class='neutral'>    }</span>
 1560 |     | <span class='neutral'>}</span>
 1561 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/phantom/Documents/azemora/azemora-contracts/lib/forge-std/src/console2.sol</b>
<code>
 1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
 2 |     | <span class='neutral'>pragma solidity &gt;=0.4.22 &lt;0.9.0;</span>
 3 |     | <span class='neutral'></span>
 4 |     | <span class='neutral'>import {console as console2} from &quot;./console.sol&quot;;</span>
 5 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/phantom/Documents/azemora/azemora-contracts/lib/forge-std/src/interfaces/IMulticall3.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>pragma solidity &gt;=0.6.2 &lt;0.9.0;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>pragma experimental ABIEncoderV2;</span>
  5 |     | <span class='neutral'></span>
  6 |     | <span class='neutral'>interface IMulticall3 {</span>
  7 |     | <span class='neutral'>    struct Call {</span>
  8 |     | <span class='neutral'>        address target;</span>
  9 |     | <span class='neutral'>        bytes callData;</span>
 10 |     | <span class='neutral'>    }</span>
 11 |     | <span class='neutral'></span>
 12 |     | <span class='neutral'>    struct Call3 {</span>
 13 |     | <span class='neutral'>        address target;</span>
 14 |     | <span class='neutral'>        bool allowFailure;</span>
 15 |     | <span class='neutral'>        bytes callData;</span>
 16 |     | <span class='neutral'>    }</span>
 17 |     | <span class='neutral'></span>
 18 |     | <span class='neutral'>    struct Call3Value {</span>
 19 |     | <span class='neutral'>        address target;</span>
 20 |     | <span class='neutral'>        bool allowFailure;</span>
 21 |     | <span class='neutral'>        uint256 value;</span>
 22 |     | <span class='neutral'>        bytes callData;</span>
 23 |     | <span class='neutral'>    }</span>
 24 |     | <span class='neutral'></span>
 25 |     | <span class='neutral'>    struct Result {</span>
 26 |     | <span class='neutral'>        bool success;</span>
 27 |     | <span class='neutral'>        bytes returnData;</span>
 28 |     | <span class='neutral'>    }</span>
 29 |     | <span class='neutral'></span>
 30 |     | <span class='neutral'>    function aggregate(Call[] calldata calls)</span>
 31 |     | <span class='neutral'>        external</span>
 32 |     | <span class='neutral'>        payable</span>
 33 |     | <span class='neutral'>        returns (uint256 blockNumber, bytes[] memory returnData);</span>
 34 |     | <span class='neutral'></span>
 35 |     | <span class='neutral'>    function aggregate3(Call3[] calldata calls) external payable returns (Result[] memory returnData);</span>
 36 |     | <span class='neutral'></span>
 37 |     | <span class='neutral'>    function aggregate3Value(Call3Value[] calldata calls) external payable returns (Result[] memory returnData);</span>
 38 |     | <span class='neutral'></span>
 39 |     | <span class='neutral'>    function blockAndAggregate(Call[] calldata calls)</span>
 40 |     | <span class='neutral'>        external</span>
 41 |     | <span class='neutral'>        payable</span>
 42 |     | <span class='neutral'>        returns (uint256 blockNumber, bytes32 blockHash, Result[] memory returnData);</span>
 43 |     | <span class='neutral'></span>
 44 |     | <span class='neutral'>    function getBasefee() external view returns (uint256 basefee);</span>
 45 |     | <span class='neutral'></span>
 46 |     | <span class='neutral'>    function getBlockHash(uint256 blockNumber) external view returns (bytes32 blockHash);</span>
 47 |     | <span class='neutral'></span>
 48 |     | <span class='neutral'>    function getBlockNumber() external view returns (uint256 blockNumber);</span>
 49 |     | <span class='neutral'></span>
 50 |     | <span class='neutral'>    function getChainId() external view returns (uint256 chainid);</span>
 51 |     | <span class='neutral'></span>
 52 |     | <span class='neutral'>    function getCurrentBlockCoinbase() external view returns (address coinbase);</span>
 53 |     | <span class='neutral'></span>
 54 |     | <span class='neutral'>    function getCurrentBlockDifficulty() external view returns (uint256 difficulty);</span>
 55 |     | <span class='neutral'></span>
 56 |     | <span class='neutral'>    function getCurrentBlockGasLimit() external view returns (uint256 gaslimit);</span>
 57 |     | <span class='neutral'></span>
 58 |     | <span class='neutral'>    function getCurrentBlockTimestamp() external view returns (uint256 timestamp);</span>
 59 |     | <span class='neutral'></span>
 60 |     | <span class='neutral'>    function getEthBalance(address addr) external view returns (uint256 balance);</span>
 61 |     | <span class='neutral'></span>
 62 |     | <span class='neutral'>    function getLastBlockHash() external view returns (bytes32 blockHash);</span>
 63 |     | <span class='neutral'></span>
 64 |     | <span class='neutral'>    function tryAggregate(bool requireSuccess, Call[] calldata calls)</span>
 65 |     | <span class='neutral'>        external</span>
 66 |     | <span class='neutral'>        payable</span>
 67 |     | <span class='neutral'>        returns (Result[] memory returnData);</span>
 68 |     | <span class='neutral'></span>
 69 |     | <span class='neutral'>    function tryBlockAndAggregate(bool requireSuccess, Call[] calldata calls)</span>
 70 |     | <span class='neutral'>        external</span>
 71 |     | <span class='neutral'>        payable</span>
 72 |     | <span class='neutral'>        returns (uint256 blockNumber, bytes32 blockHash, Result[] memory returnData);</span>
 73 |     | <span class='neutral'>}</span>
 74 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/phantom/Documents/azemora/azemora-contracts/lib/forge-std/src/safeconsole.sol</b>
<code>
     1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
     2 |     | <span class='neutral'>pragma solidity &gt;=0.6.2 &lt;0.9.0;</span>
     3 |     | <span class='neutral'></span>
     4 |     | <span class='neutral'>/// @author philogy &lt;https://github.com/philogy&gt;</span>
     5 |     | <span class='neutral'>/// @dev Code generated automatically by script.</span>
     6 |     | <span class='unexecuted'>library safeconsole {</span>
     7 |     | <span class='neutral'>    uint256 constant CONSOLE_ADDR = 0x000000000000000000000000000000000000000000636F6e736F6c652e6c6f67;</span>
     8 |     | <span class='neutral'></span>
     9 |     | <span class='neutral'>    // Credit to [0age](https://twitter.com/z0age/status/1654922202930888704) and [0xdapper](https://github.com/foundry-rs/forge-std/pull/374)</span>
    10 |     | <span class='neutral'>    // for the view-to-pure log trick.</span>
    11 |     | <span class='neutral'>    function _sendLogPayload(uint256 offset, uint256 size) private pure {</span>
    12 |     | <span class='neutral'>        function(uint256, uint256) internal view fnIn = _sendLogPayloadView;</span>
    13 |     | <span class='neutral'>        function(uint256, uint256) internal pure pureSendLogPayload;</span>
    14 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
    15 |     | <span class='neutral'>        assembly {</span>
    16 |     | <span class='neutral'>            pureSendLogPayload := fnIn</span>
    17 |     | <span class='neutral'>        }</span>
    18 |     | <span class='neutral'>        pureSendLogPayload(offset, size);</span>
    19 |     | <span class='neutral'>    }</span>
    20 |     | <span class='neutral'></span>
    21 |     | <span class='neutral'>    function _sendLogPayloadView(uint256 offset, uint256 size) private view {</span>
    22 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
    23 |     | <span class='neutral'>        assembly {</span>
    24 |     | <span class='neutral'>            pop(staticcall(gas(), CONSOLE_ADDR, offset, size, 0x0, 0x0))</span>
    25 |     | <span class='neutral'>        }</span>
    26 |     | <span class='neutral'>    }</span>
    27 |     | <span class='neutral'></span>
    28 |     | <span class='neutral'>    function _memcopy(uint256 fromOffset, uint256 toOffset, uint256 length) private pure {</span>
    29 |     | <span class='neutral'>        function(uint256, uint256, uint256) internal view fnIn = _memcopyView;</span>
    30 |     | <span class='neutral'>        function(uint256, uint256, uint256) internal pure pureMemcopy;</span>
    31 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
    32 |     | <span class='neutral'>        assembly {</span>
    33 |     | <span class='neutral'>            pureMemcopy := fnIn</span>
    34 |     | <span class='neutral'>        }</span>
    35 |     | <span class='neutral'>        pureMemcopy(fromOffset, toOffset, length);</span>
    36 |     | <span class='neutral'>    }</span>
    37 |     | <span class='neutral'></span>
    38 |     | <span class='neutral'>    function _memcopyView(uint256 fromOffset, uint256 toOffset, uint256 length) private view {</span>
    39 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
    40 |     | <span class='neutral'>        assembly {</span>
    41 |     | <span class='neutral'>            pop(staticcall(gas(), 0x4, fromOffset, length, toOffset, length))</span>
    42 |     | <span class='neutral'>        }</span>
    43 |     | <span class='neutral'>    }</span>
    44 |     | <span class='neutral'></span>
    45 |     | <span class='neutral'>    function logMemory(uint256 offset, uint256 length) internal pure {</span>
    46 |     | <span class='neutral'>        if (offset &gt;= 0x60) {</span>
    47 |     | <span class='neutral'>            // Sufficient memory before slice to prepare call header.</span>
    48 |     | <span class='neutral'>            bytes32 m0;</span>
    49 |     | <span class='neutral'>            bytes32 m1;</span>
    50 |     | <span class='neutral'>            bytes32 m2;</span>
    51 |     | <span class='neutral'>            /// @solidity memory-safe-assembly</span>
    52 |     | <span class='neutral'>            assembly {</span>
    53 |     | <span class='neutral'>                m0 := mload(sub(offset, 0x60))</span>
    54 |     | <span class='neutral'>                m1 := mload(sub(offset, 0x40))</span>
    55 |     | <span class='neutral'>                m2 := mload(sub(offset, 0x20))</span>
    56 |     | <span class='neutral'>                // Selector of `log(bytes)`.</span>
    57 |     | <span class='neutral'>                mstore(sub(offset, 0x60), 0x0be77f56)</span>
    58 |     | <span class='neutral'>                mstore(sub(offset, 0x40), 0x20)</span>
    59 |     | <span class='neutral'>                mstore(sub(offset, 0x20), length)</span>
    60 |     | <span class='neutral'>            }</span>
    61 |     | <span class='neutral'>            _sendLogPayload(offset - 0x44, length + 0x44);</span>
    62 |     | <span class='neutral'>            /// @solidity memory-safe-assembly</span>
    63 |     | <span class='neutral'>            assembly {</span>
    64 |     | <span class='neutral'>                mstore(sub(offset, 0x60), m0)</span>
    65 |     | <span class='neutral'>                mstore(sub(offset, 0x40), m1)</span>
    66 |     | <span class='neutral'>                mstore(sub(offset, 0x20), m2)</span>
    67 |     | <span class='neutral'>            }</span>
    68 |     | <span class='neutral'>        } else {</span>
    69 |     | <span class='neutral'>            // Insufficient space, so copy slice forward, add header and reverse.</span>
    70 |     | <span class='neutral'>            bytes32 m0;</span>
    71 |     | <span class='neutral'>            bytes32 m1;</span>
    72 |     | <span class='neutral'>            bytes32 m2;</span>
    73 |     | <span class='neutral'>            uint256 endOffset = offset + length;</span>
    74 |     | <span class='neutral'>            /// @solidity memory-safe-assembly</span>
    75 |     | <span class='neutral'>            assembly {</span>
    76 |     | <span class='neutral'>                m0 := mload(add(endOffset, 0x00))</span>
    77 |     | <span class='neutral'>                m1 := mload(add(endOffset, 0x20))</span>
    78 |     | <span class='neutral'>                m2 := mload(add(endOffset, 0x40))</span>
    79 |     | <span class='neutral'>            }</span>
    80 |     | <span class='neutral'>            _memcopy(offset, offset + 0x60, length);</span>
    81 |     | <span class='neutral'>            /// @solidity memory-safe-assembly</span>
    82 |     | <span class='neutral'>            assembly {</span>
    83 |     | <span class='neutral'>                // Selector of `log(bytes)`.</span>
    84 |     | <span class='neutral'>                mstore(add(offset, 0x00), 0x0be77f56)</span>
    85 |     | <span class='neutral'>                mstore(add(offset, 0x20), 0x20)</span>
    86 |     | <span class='neutral'>                mstore(add(offset, 0x40), length)</span>
    87 |     | <span class='neutral'>            }</span>
    88 |     | <span class='neutral'>            _sendLogPayload(offset + 0x1c, length + 0x44);</span>
    89 |     | <span class='neutral'>            _memcopy(offset + 0x60, offset, length);</span>
    90 |     | <span class='neutral'>            /// @solidity memory-safe-assembly</span>
    91 |     | <span class='neutral'>            assembly {</span>
    92 |     | <span class='neutral'>                mstore(add(endOffset, 0x00), m0)</span>
    93 |     | <span class='neutral'>                mstore(add(endOffset, 0x20), m1)</span>
    94 |     | <span class='neutral'>                mstore(add(endOffset, 0x40), m2)</span>
    95 |     | <span class='neutral'>            }</span>
    96 |     | <span class='neutral'>        }</span>
    97 |     | <span class='neutral'>    }</span>
    98 |     | <span class='neutral'></span>
    99 |     | <span class='neutral'>    function log(address p0) internal pure {</span>
   100 |     | <span class='neutral'>        bytes32 m0;</span>
   101 |     | <span class='neutral'>        bytes32 m1;</span>
   102 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
   103 |     | <span class='neutral'>        assembly {</span>
   104 |     | <span class='neutral'>            m0 := mload(0x00)</span>
   105 |     | <span class='neutral'>            m1 := mload(0x20)</span>
   106 |     | <span class='neutral'>            // Selector of `log(address)`.</span>
   107 |     | <span class='neutral'>            mstore(0x00, 0x2c2ecbc2)</span>
   108 |     | <span class='neutral'>            mstore(0x20, p0)</span>
   109 |     | <span class='neutral'>        }</span>
   110 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x24);</span>
   111 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
   112 |     | <span class='neutral'>        assembly {</span>
   113 |     | <span class='neutral'>            mstore(0x00, m0)</span>
   114 |     | <span class='neutral'>            mstore(0x20, m1)</span>
   115 |     | <span class='neutral'>        }</span>
   116 |     | <span class='neutral'>    }</span>
   117 |     | <span class='neutral'></span>
   118 |     | <span class='neutral'>    function log(bool p0) internal pure {</span>
   119 |     | <span class='neutral'>        bytes32 m0;</span>
   120 |     | <span class='neutral'>        bytes32 m1;</span>
   121 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
   122 |     | <span class='neutral'>        assembly {</span>
   123 |     | <span class='neutral'>            m0 := mload(0x00)</span>
   124 |     | <span class='neutral'>            m1 := mload(0x20)</span>
   125 |     | <span class='neutral'>            // Selector of `log(bool)`.</span>
   126 |     | <span class='neutral'>            mstore(0x00, 0x32458eed)</span>
   127 |     | <span class='neutral'>            mstore(0x20, p0)</span>
   128 |     | <span class='neutral'>        }</span>
   129 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x24);</span>
   130 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
   131 |     | <span class='neutral'>        assembly {</span>
   132 |     | <span class='neutral'>            mstore(0x00, m0)</span>
   133 |     | <span class='neutral'>            mstore(0x20, m1)</span>
   134 |     | <span class='neutral'>        }</span>
   135 |     | <span class='neutral'>    }</span>
   136 |     | <span class='neutral'></span>
   137 |     | <span class='neutral'>    function log(uint256 p0) internal pure {</span>
   138 |     | <span class='neutral'>        bytes32 m0;</span>
   139 |     | <span class='neutral'>        bytes32 m1;</span>
   140 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
   141 |     | <span class='neutral'>        assembly {</span>
   142 |     | <span class='neutral'>            m0 := mload(0x00)</span>
   143 |     | <span class='neutral'>            m1 := mload(0x20)</span>
   144 |     | <span class='neutral'>            // Selector of `log(uint256)`.</span>
   145 |     | <span class='neutral'>            mstore(0x00, 0xf82c50f1)</span>
   146 |     | <span class='neutral'>            mstore(0x20, p0)</span>
   147 |     | <span class='neutral'>        }</span>
   148 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x24);</span>
   149 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
   150 |     | <span class='neutral'>        assembly {</span>
   151 |     | <span class='neutral'>            mstore(0x00, m0)</span>
   152 |     | <span class='neutral'>            mstore(0x20, m1)</span>
   153 |     | <span class='neutral'>        }</span>
   154 |     | <span class='neutral'>    }</span>
   155 |     | <span class='neutral'></span>
   156 |     | <span class='neutral'>    function log(bytes32 p0) internal pure {</span>
   157 |     | <span class='neutral'>        bytes32 m0;</span>
   158 |     | <span class='neutral'>        bytes32 m1;</span>
   159 |     | <span class='neutral'>        bytes32 m2;</span>
   160 |     | <span class='neutral'>        bytes32 m3;</span>
   161 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
   162 |     | <span class='neutral'>        assembly {</span>
   163 |     | <span class='neutral'>            function writeString(pos, w) {</span>
   164 |     | <span class='neutral'>                let length := 0</span>
   165 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
   166 |     | <span class='neutral'>                mstore(pos, length)</span>
   167 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
   168 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
   169 |     | <span class='neutral'>            }</span>
   170 |     | <span class='neutral'>            m0 := mload(0x00)</span>
   171 |     | <span class='neutral'>            m1 := mload(0x20)</span>
   172 |     | <span class='neutral'>            m2 := mload(0x40)</span>
   173 |     | <span class='neutral'>            m3 := mload(0x60)</span>
   174 |     | <span class='neutral'>            // Selector of `log(string)`.</span>
   175 |     | <span class='neutral'>            mstore(0x00, 0x41304fac)</span>
   176 |     | <span class='neutral'>            mstore(0x20, 0x20)</span>
   177 |     | <span class='neutral'>            writeString(0x40, p0)</span>
   178 |     | <span class='neutral'>        }</span>
   179 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x64);</span>
   180 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
   181 |     | <span class='neutral'>        assembly {</span>
   182 |     | <span class='neutral'>            mstore(0x00, m0)</span>
   183 |     | <span class='neutral'>            mstore(0x20, m1)</span>
   184 |     | <span class='neutral'>            mstore(0x40, m2)</span>
   185 |     | <span class='neutral'>            mstore(0x60, m3)</span>
   186 |     | <span class='neutral'>        }</span>
   187 |     | <span class='neutral'>    }</span>
   188 |     | <span class='neutral'></span>
   189 |     | <span class='neutral'>    function log(address p0, address p1) internal pure {</span>
   190 |     | <span class='neutral'>        bytes32 m0;</span>
   191 |     | <span class='neutral'>        bytes32 m1;</span>
   192 |     | <span class='neutral'>        bytes32 m2;</span>
   193 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
   194 |     | <span class='neutral'>        assembly {</span>
   195 |     | <span class='neutral'>            m0 := mload(0x00)</span>
   196 |     | <span class='neutral'>            m1 := mload(0x20)</span>
   197 |     | <span class='neutral'>            m2 := mload(0x40)</span>
   198 |     | <span class='neutral'>            // Selector of `log(address,address)`.</span>
   199 |     | <span class='neutral'>            mstore(0x00, 0xdaf0d4aa)</span>
   200 |     | <span class='neutral'>            mstore(0x20, p0)</span>
   201 |     | <span class='neutral'>            mstore(0x40, p1)</span>
   202 |     | <span class='neutral'>        }</span>
   203 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x44);</span>
   204 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
   205 |     | <span class='neutral'>        assembly {</span>
   206 |     | <span class='neutral'>            mstore(0x00, m0)</span>
   207 |     | <span class='neutral'>            mstore(0x20, m1)</span>
   208 |     | <span class='neutral'>            mstore(0x40, m2)</span>
   209 |     | <span class='neutral'>        }</span>
   210 |     | <span class='neutral'>    }</span>
   211 |     | <span class='neutral'></span>
   212 |     | <span class='neutral'>    function log(address p0, bool p1) internal pure {</span>
   213 |     | <span class='neutral'>        bytes32 m0;</span>
   214 |     | <span class='neutral'>        bytes32 m1;</span>
   215 |     | <span class='neutral'>        bytes32 m2;</span>
   216 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
   217 |     | <span class='neutral'>        assembly {</span>
   218 |     | <span class='neutral'>            m0 := mload(0x00)</span>
   219 |     | <span class='neutral'>            m1 := mload(0x20)</span>
   220 |     | <span class='neutral'>            m2 := mload(0x40)</span>
   221 |     | <span class='neutral'>            // Selector of `log(address,bool)`.</span>
   222 |     | <span class='neutral'>            mstore(0x00, 0x75b605d3)</span>
   223 |     | <span class='neutral'>            mstore(0x20, p0)</span>
   224 |     | <span class='neutral'>            mstore(0x40, p1)</span>
   225 |     | <span class='neutral'>        }</span>
   226 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x44);</span>
   227 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
   228 |     | <span class='neutral'>        assembly {</span>
   229 |     | <span class='neutral'>            mstore(0x00, m0)</span>
   230 |     | <span class='neutral'>            mstore(0x20, m1)</span>
   231 |     | <span class='neutral'>            mstore(0x40, m2)</span>
   232 |     | <span class='neutral'>        }</span>
   233 |     | <span class='neutral'>    }</span>
   234 |     | <span class='neutral'></span>
   235 |     | <span class='neutral'>    function log(address p0, uint256 p1) internal pure {</span>
   236 |     | <span class='neutral'>        bytes32 m0;</span>
   237 |     | <span class='neutral'>        bytes32 m1;</span>
   238 |     | <span class='neutral'>        bytes32 m2;</span>
   239 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
   240 |     | <span class='neutral'>        assembly {</span>
   241 |     | <span class='neutral'>            m0 := mload(0x00)</span>
   242 |     | <span class='neutral'>            m1 := mload(0x20)</span>
   243 |     | <span class='neutral'>            m2 := mload(0x40)</span>
   244 |     | <span class='neutral'>            // Selector of `log(address,uint256)`.</span>
   245 |     | <span class='neutral'>            mstore(0x00, 0x8309e8a8)</span>
   246 |     | <span class='neutral'>            mstore(0x20, p0)</span>
   247 |     | <span class='neutral'>            mstore(0x40, p1)</span>
   248 |     | <span class='neutral'>        }</span>
   249 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x44);</span>
   250 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
   251 |     | <span class='neutral'>        assembly {</span>
   252 |     | <span class='neutral'>            mstore(0x00, m0)</span>
   253 |     | <span class='neutral'>            mstore(0x20, m1)</span>
   254 |     | <span class='neutral'>            mstore(0x40, m2)</span>
   255 |     | <span class='neutral'>        }</span>
   256 |     | <span class='neutral'>    }</span>
   257 |     | <span class='neutral'></span>
   258 |     | <span class='neutral'>    function log(address p0, bytes32 p1) internal pure {</span>
   259 |     | <span class='neutral'>        bytes32 m0;</span>
   260 |     | <span class='neutral'>        bytes32 m1;</span>
   261 |     | <span class='neutral'>        bytes32 m2;</span>
   262 |     | <span class='neutral'>        bytes32 m3;</span>
   263 |     | <span class='neutral'>        bytes32 m4;</span>
   264 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
   265 |     | <span class='neutral'>        assembly {</span>
   266 |     | <span class='neutral'>            function writeString(pos, w) {</span>
   267 |     | <span class='neutral'>                let length := 0</span>
   268 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
   269 |     | <span class='neutral'>                mstore(pos, length)</span>
   270 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
   271 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
   272 |     | <span class='neutral'>            }</span>
   273 |     | <span class='neutral'>            m0 := mload(0x00)</span>
   274 |     | <span class='neutral'>            m1 := mload(0x20)</span>
   275 |     | <span class='neutral'>            m2 := mload(0x40)</span>
   276 |     | <span class='neutral'>            m3 := mload(0x60)</span>
   277 |     | <span class='neutral'>            m4 := mload(0x80)</span>
   278 |     | <span class='neutral'>            // Selector of `log(address,string)`.</span>
   279 |     | <span class='neutral'>            mstore(0x00, 0x759f86bb)</span>
   280 |     | <span class='neutral'>            mstore(0x20, p0)</span>
   281 |     | <span class='neutral'>            mstore(0x40, 0x40)</span>
   282 |     | <span class='neutral'>            writeString(0x60, p1)</span>
   283 |     | <span class='neutral'>        }</span>
   284 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x84);</span>
   285 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
   286 |     | <span class='neutral'>        assembly {</span>
   287 |     | <span class='neutral'>            mstore(0x00, m0)</span>
   288 |     | <span class='neutral'>            mstore(0x20, m1)</span>
   289 |     | <span class='neutral'>            mstore(0x40, m2)</span>
   290 |     | <span class='neutral'>            mstore(0x60, m3)</span>
   291 |     | <span class='neutral'>            mstore(0x80, m4)</span>
   292 |     | <span class='neutral'>        }</span>
   293 |     | <span class='neutral'>    }</span>
   294 |     | <span class='neutral'></span>
   295 |     | <span class='neutral'>    function log(bool p0, address p1) internal pure {</span>
   296 |     | <span class='neutral'>        bytes32 m0;</span>
   297 |     | <span class='neutral'>        bytes32 m1;</span>
   298 |     | <span class='neutral'>        bytes32 m2;</span>
   299 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
   300 |     | <span class='neutral'>        assembly {</span>
   301 |     | <span class='neutral'>            m0 := mload(0x00)</span>
   302 |     | <span class='neutral'>            m1 := mload(0x20)</span>
   303 |     | <span class='neutral'>            m2 := mload(0x40)</span>
   304 |     | <span class='neutral'>            // Selector of `log(bool,address)`.</span>
   305 |     | <span class='neutral'>            mstore(0x00, 0x853c4849)</span>
   306 |     | <span class='neutral'>            mstore(0x20, p0)</span>
   307 |     | <span class='neutral'>            mstore(0x40, p1)</span>
   308 |     | <span class='neutral'>        }</span>
   309 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x44);</span>
   310 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
   311 |     | <span class='neutral'>        assembly {</span>
   312 |     | <span class='neutral'>            mstore(0x00, m0)</span>
   313 |     | <span class='neutral'>            mstore(0x20, m1)</span>
   314 |     | <span class='neutral'>            mstore(0x40, m2)</span>
   315 |     | <span class='neutral'>        }</span>
   316 |     | <span class='neutral'>    }</span>
   317 |     | <span class='neutral'></span>
   318 |     | <span class='neutral'>    function log(bool p0, bool p1) internal pure {</span>
   319 |     | <span class='neutral'>        bytes32 m0;</span>
   320 |     | <span class='neutral'>        bytes32 m1;</span>
   321 |     | <span class='neutral'>        bytes32 m2;</span>
   322 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
   323 |     | <span class='neutral'>        assembly {</span>
   324 |     | <span class='neutral'>            m0 := mload(0x00)</span>
   325 |     | <span class='neutral'>            m1 := mload(0x20)</span>
   326 |     | <span class='neutral'>            m2 := mload(0x40)</span>
   327 |     | <span class='neutral'>            // Selector of `log(bool,bool)`.</span>
   328 |     | <span class='neutral'>            mstore(0x00, 0x2a110e83)</span>
   329 |     | <span class='neutral'>            mstore(0x20, p0)</span>
   330 |     | <span class='neutral'>            mstore(0x40, p1)</span>
   331 |     | <span class='neutral'>        }</span>
   332 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x44);</span>
   333 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
   334 |     | <span class='neutral'>        assembly {</span>
   335 |     | <span class='neutral'>            mstore(0x00, m0)</span>
   336 |     | <span class='neutral'>            mstore(0x20, m1)</span>
   337 |     | <span class='neutral'>            mstore(0x40, m2)</span>
   338 |     | <span class='neutral'>        }</span>
   339 |     | <span class='neutral'>    }</span>
   340 |     | <span class='neutral'></span>
   341 |     | <span class='neutral'>    function log(bool p0, uint256 p1) internal pure {</span>
   342 |     | <span class='neutral'>        bytes32 m0;</span>
   343 |     | <span class='neutral'>        bytes32 m1;</span>
   344 |     | <span class='neutral'>        bytes32 m2;</span>
   345 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
   346 |     | <span class='neutral'>        assembly {</span>
   347 |     | <span class='neutral'>            m0 := mload(0x00)</span>
   348 |     | <span class='neutral'>            m1 := mload(0x20)</span>
   349 |     | <span class='neutral'>            m2 := mload(0x40)</span>
   350 |     | <span class='neutral'>            // Selector of `log(bool,uint256)`.</span>
   351 |     | <span class='neutral'>            mstore(0x00, 0x399174d3)</span>
   352 |     | <span class='neutral'>            mstore(0x20, p0)</span>
   353 |     | <span class='neutral'>            mstore(0x40, p1)</span>
   354 |     | <span class='neutral'>        }</span>
   355 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x44);</span>
   356 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
   357 |     | <span class='neutral'>        assembly {</span>
   358 |     | <span class='neutral'>            mstore(0x00, m0)</span>
   359 |     | <span class='neutral'>            mstore(0x20, m1)</span>
   360 |     | <span class='neutral'>            mstore(0x40, m2)</span>
   361 |     | <span class='neutral'>        }</span>
   362 |     | <span class='neutral'>    }</span>
   363 |     | <span class='neutral'></span>
   364 |     | <span class='neutral'>    function log(bool p0, bytes32 p1) internal pure {</span>
   365 |     | <span class='neutral'>        bytes32 m0;</span>
   366 |     | <span class='neutral'>        bytes32 m1;</span>
   367 |     | <span class='neutral'>        bytes32 m2;</span>
   368 |     | <span class='neutral'>        bytes32 m3;</span>
   369 |     | <span class='neutral'>        bytes32 m4;</span>
   370 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
   371 |     | <span class='neutral'>        assembly {</span>
   372 |     | <span class='neutral'>            function writeString(pos, w) {</span>
   373 |     | <span class='neutral'>                let length := 0</span>
   374 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
   375 |     | <span class='neutral'>                mstore(pos, length)</span>
   376 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
   377 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
   378 |     | <span class='neutral'>            }</span>
   379 |     | <span class='neutral'>            m0 := mload(0x00)</span>
   380 |     | <span class='neutral'>            m1 := mload(0x20)</span>
   381 |     | <span class='neutral'>            m2 := mload(0x40)</span>
   382 |     | <span class='neutral'>            m3 := mload(0x60)</span>
   383 |     | <span class='neutral'>            m4 := mload(0x80)</span>
   384 |     | <span class='neutral'>            // Selector of `log(bool,string)`.</span>
   385 |     | <span class='neutral'>            mstore(0x00, 0x8feac525)</span>
   386 |     | <span class='neutral'>            mstore(0x20, p0)</span>
   387 |     | <span class='neutral'>            mstore(0x40, 0x40)</span>
   388 |     | <span class='neutral'>            writeString(0x60, p1)</span>
   389 |     | <span class='neutral'>        }</span>
   390 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x84);</span>
   391 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
   392 |     | <span class='neutral'>        assembly {</span>
   393 |     | <span class='neutral'>            mstore(0x00, m0)</span>
   394 |     | <span class='neutral'>            mstore(0x20, m1)</span>
   395 |     | <span class='neutral'>            mstore(0x40, m2)</span>
   396 |     | <span class='neutral'>            mstore(0x60, m3)</span>
   397 |     | <span class='neutral'>            mstore(0x80, m4)</span>
   398 |     | <span class='neutral'>        }</span>
   399 |     | <span class='neutral'>    }</span>
   400 |     | <span class='neutral'></span>
   401 |     | <span class='neutral'>    function log(uint256 p0, address p1) internal pure {</span>
   402 |     | <span class='neutral'>        bytes32 m0;</span>
   403 |     | <span class='neutral'>        bytes32 m1;</span>
   404 |     | <span class='neutral'>        bytes32 m2;</span>
   405 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
   406 |     | <span class='neutral'>        assembly {</span>
   407 |     | <span class='neutral'>            m0 := mload(0x00)</span>
   408 |     | <span class='neutral'>            m1 := mload(0x20)</span>
   409 |     | <span class='neutral'>            m2 := mload(0x40)</span>
   410 |     | <span class='neutral'>            // Selector of `log(uint256,address)`.</span>
   411 |     | <span class='neutral'>            mstore(0x00, 0x69276c86)</span>
   412 |     | <span class='neutral'>            mstore(0x20, p0)</span>
   413 |     | <span class='neutral'>            mstore(0x40, p1)</span>
   414 |     | <span class='neutral'>        }</span>
   415 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x44);</span>
   416 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
   417 |     | <span class='neutral'>        assembly {</span>
   418 |     | <span class='neutral'>            mstore(0x00, m0)</span>
   419 |     | <span class='neutral'>            mstore(0x20, m1)</span>
   420 |     | <span class='neutral'>            mstore(0x40, m2)</span>
   421 |     | <span class='neutral'>        }</span>
   422 |     | <span class='neutral'>    }</span>
   423 |     | <span class='neutral'></span>
   424 |     | <span class='neutral'>    function log(uint256 p0, bool p1) internal pure {</span>
   425 |     | <span class='neutral'>        bytes32 m0;</span>
   426 |     | <span class='neutral'>        bytes32 m1;</span>
   427 |     | <span class='neutral'>        bytes32 m2;</span>
   428 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
   429 |     | <span class='neutral'>        assembly {</span>
   430 |     | <span class='neutral'>            m0 := mload(0x00)</span>
   431 |     | <span class='neutral'>            m1 := mload(0x20)</span>
   432 |     | <span class='neutral'>            m2 := mload(0x40)</span>
   433 |     | <span class='neutral'>            // Selector of `log(uint256,bool)`.</span>
   434 |     | <span class='neutral'>            mstore(0x00, 0x1c9d7eb3)</span>
   435 |     | <span class='neutral'>            mstore(0x20, p0)</span>
   436 |     | <span class='neutral'>            mstore(0x40, p1)</span>
   437 |     | <span class='neutral'>        }</span>
   438 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x44);</span>
   439 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
   440 |     | <span class='neutral'>        assembly {</span>
   441 |     | <span class='neutral'>            mstore(0x00, m0)</span>
   442 |     | <span class='neutral'>            mstore(0x20, m1)</span>
   443 |     | <span class='neutral'>            mstore(0x40, m2)</span>
   444 |     | <span class='neutral'>        }</span>
   445 |     | <span class='neutral'>    }</span>
   446 |     | <span class='neutral'></span>
   447 |     | <span class='neutral'>    function log(uint256 p0, uint256 p1) internal pure {</span>
   448 |     | <span class='neutral'>        bytes32 m0;</span>
   449 |     | <span class='neutral'>        bytes32 m1;</span>
   450 |     | <span class='neutral'>        bytes32 m2;</span>
   451 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
   452 |     | <span class='neutral'>        assembly {</span>
   453 |     | <span class='neutral'>            m0 := mload(0x00)</span>
   454 |     | <span class='neutral'>            m1 := mload(0x20)</span>
   455 |     | <span class='neutral'>            m2 := mload(0x40)</span>
   456 |     | <span class='neutral'>            // Selector of `log(uint256,uint256)`.</span>
   457 |     | <span class='neutral'>            mstore(0x00, 0xf666715a)</span>
   458 |     | <span class='neutral'>            mstore(0x20, p0)</span>
   459 |     | <span class='neutral'>            mstore(0x40, p1)</span>
   460 |     | <span class='neutral'>        }</span>
   461 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x44);</span>
   462 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
   463 |     | <span class='neutral'>        assembly {</span>
   464 |     | <span class='neutral'>            mstore(0x00, m0)</span>
   465 |     | <span class='neutral'>            mstore(0x20, m1)</span>
   466 |     | <span class='neutral'>            mstore(0x40, m2)</span>
   467 |     | <span class='neutral'>        }</span>
   468 |     | <span class='neutral'>    }</span>
   469 |     | <span class='neutral'></span>
   470 |     | <span class='neutral'>    function log(uint256 p0, bytes32 p1) internal pure {</span>
   471 |     | <span class='neutral'>        bytes32 m0;</span>
   472 |     | <span class='neutral'>        bytes32 m1;</span>
   473 |     | <span class='neutral'>        bytes32 m2;</span>
   474 |     | <span class='neutral'>        bytes32 m3;</span>
   475 |     | <span class='neutral'>        bytes32 m4;</span>
   476 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
   477 |     | <span class='neutral'>        assembly {</span>
   478 |     | <span class='neutral'>            function writeString(pos, w) {</span>
   479 |     | <span class='neutral'>                let length := 0</span>
   480 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
   481 |     | <span class='neutral'>                mstore(pos, length)</span>
   482 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
   483 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
   484 |     | <span class='neutral'>            }</span>
   485 |     | <span class='neutral'>            m0 := mload(0x00)</span>
   486 |     | <span class='neutral'>            m1 := mload(0x20)</span>
   487 |     | <span class='neutral'>            m2 := mload(0x40)</span>
   488 |     | <span class='neutral'>            m3 := mload(0x60)</span>
   489 |     | <span class='neutral'>            m4 := mload(0x80)</span>
   490 |     | <span class='neutral'>            // Selector of `log(uint256,string)`.</span>
   491 |     | <span class='neutral'>            mstore(0x00, 0x643fd0df)</span>
   492 |     | <span class='neutral'>            mstore(0x20, p0)</span>
   493 |     | <span class='neutral'>            mstore(0x40, 0x40)</span>
   494 |     | <span class='neutral'>            writeString(0x60, p1)</span>
   495 |     | <span class='neutral'>        }</span>
   496 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x84);</span>
   497 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
   498 |     | <span class='neutral'>        assembly {</span>
   499 |     | <span class='neutral'>            mstore(0x00, m0)</span>
   500 |     | <span class='neutral'>            mstore(0x20, m1)</span>
   501 |     | <span class='neutral'>            mstore(0x40, m2)</span>
   502 |     | <span class='neutral'>            mstore(0x60, m3)</span>
   503 |     | <span class='neutral'>            mstore(0x80, m4)</span>
   504 |     | <span class='neutral'>        }</span>
   505 |     | <span class='neutral'>    }</span>
   506 |     | <span class='neutral'></span>
   507 |     | <span class='neutral'>    function log(bytes32 p0, address p1) internal pure {</span>
   508 |     | <span class='neutral'>        bytes32 m0;</span>
   509 |     | <span class='neutral'>        bytes32 m1;</span>
   510 |     | <span class='neutral'>        bytes32 m2;</span>
   511 |     | <span class='neutral'>        bytes32 m3;</span>
   512 |     | <span class='neutral'>        bytes32 m4;</span>
   513 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
   514 |     | <span class='neutral'>        assembly {</span>
   515 |     | <span class='neutral'>            function writeString(pos, w) {</span>
   516 |     | <span class='neutral'>                let length := 0</span>
   517 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
   518 |     | <span class='neutral'>                mstore(pos, length)</span>
   519 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
   520 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
   521 |     | <span class='neutral'>            }</span>
   522 |     | <span class='neutral'>            m0 := mload(0x00)</span>
   523 |     | <span class='neutral'>            m1 := mload(0x20)</span>
   524 |     | <span class='neutral'>            m2 := mload(0x40)</span>
   525 |     | <span class='neutral'>            m3 := mload(0x60)</span>
   526 |     | <span class='neutral'>            m4 := mload(0x80)</span>
   527 |     | <span class='neutral'>            // Selector of `log(string,address)`.</span>
   528 |     | <span class='neutral'>            mstore(0x00, 0x319af333)</span>
   529 |     | <span class='neutral'>            mstore(0x20, 0x40)</span>
   530 |     | <span class='neutral'>            mstore(0x40, p1)</span>
   531 |     | <span class='neutral'>            writeString(0x60, p0)</span>
   532 |     | <span class='neutral'>        }</span>
   533 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x84);</span>
   534 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
   535 |     | <span class='neutral'>        assembly {</span>
   536 |     | <span class='neutral'>            mstore(0x00, m0)</span>
   537 |     | <span class='neutral'>            mstore(0x20, m1)</span>
   538 |     | <span class='neutral'>            mstore(0x40, m2)</span>
   539 |     | <span class='neutral'>            mstore(0x60, m3)</span>
   540 |     | <span class='neutral'>            mstore(0x80, m4)</span>
   541 |     | <span class='neutral'>        }</span>
   542 |     | <span class='neutral'>    }</span>
   543 |     | <span class='neutral'></span>
   544 |     | <span class='neutral'>    function log(bytes32 p0, bool p1) internal pure {</span>
   545 |     | <span class='neutral'>        bytes32 m0;</span>
   546 |     | <span class='neutral'>        bytes32 m1;</span>
   547 |     | <span class='neutral'>        bytes32 m2;</span>
   548 |     | <span class='neutral'>        bytes32 m3;</span>
   549 |     | <span class='neutral'>        bytes32 m4;</span>
   550 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
   551 |     | <span class='neutral'>        assembly {</span>
   552 |     | <span class='neutral'>            function writeString(pos, w) {</span>
   553 |     | <span class='neutral'>                let length := 0</span>
   554 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
   555 |     | <span class='neutral'>                mstore(pos, length)</span>
   556 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
   557 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
   558 |     | <span class='neutral'>            }</span>
   559 |     | <span class='neutral'>            m0 := mload(0x00)</span>
   560 |     | <span class='neutral'>            m1 := mload(0x20)</span>
   561 |     | <span class='neutral'>            m2 := mload(0x40)</span>
   562 |     | <span class='neutral'>            m3 := mload(0x60)</span>
   563 |     | <span class='neutral'>            m4 := mload(0x80)</span>
   564 |     | <span class='neutral'>            // Selector of `log(string,bool)`.</span>
   565 |     | <span class='neutral'>            mstore(0x00, 0xc3b55635)</span>
   566 |     | <span class='neutral'>            mstore(0x20, 0x40)</span>
   567 |     | <span class='neutral'>            mstore(0x40, p1)</span>
   568 |     | <span class='neutral'>            writeString(0x60, p0)</span>
   569 |     | <span class='neutral'>        }</span>
   570 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x84);</span>
   571 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
   572 |     | <span class='neutral'>        assembly {</span>
   573 |     | <span class='neutral'>            mstore(0x00, m0)</span>
   574 |     | <span class='neutral'>            mstore(0x20, m1)</span>
   575 |     | <span class='neutral'>            mstore(0x40, m2)</span>
   576 |     | <span class='neutral'>            mstore(0x60, m3)</span>
   577 |     | <span class='neutral'>            mstore(0x80, m4)</span>
   578 |     | <span class='neutral'>        }</span>
   579 |     | <span class='neutral'>    }</span>
   580 |     | <span class='neutral'></span>
   581 |     | <span class='neutral'>    function log(bytes32 p0, uint256 p1) internal pure {</span>
   582 |     | <span class='neutral'>        bytes32 m0;</span>
   583 |     | <span class='neutral'>        bytes32 m1;</span>
   584 |     | <span class='neutral'>        bytes32 m2;</span>
   585 |     | <span class='neutral'>        bytes32 m3;</span>
   586 |     | <span class='neutral'>        bytes32 m4;</span>
   587 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
   588 |     | <span class='neutral'>        assembly {</span>
   589 |     | <span class='neutral'>            function writeString(pos, w) {</span>
   590 |     | <span class='neutral'>                let length := 0</span>
   591 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
   592 |     | <span class='neutral'>                mstore(pos, length)</span>
   593 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
   594 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
   595 |     | <span class='neutral'>            }</span>
   596 |     | <span class='neutral'>            m0 := mload(0x00)</span>
   597 |     | <span class='neutral'>            m1 := mload(0x20)</span>
   598 |     | <span class='neutral'>            m2 := mload(0x40)</span>
   599 |     | <span class='neutral'>            m3 := mload(0x60)</span>
   600 |     | <span class='neutral'>            m4 := mload(0x80)</span>
   601 |     | <span class='neutral'>            // Selector of `log(string,uint256)`.</span>
   602 |     | <span class='neutral'>            mstore(0x00, 0xb60e72cc)</span>
   603 |     | <span class='neutral'>            mstore(0x20, 0x40)</span>
   604 |     | <span class='neutral'>            mstore(0x40, p1)</span>
   605 |     | <span class='neutral'>            writeString(0x60, p0)</span>
   606 |     | <span class='neutral'>        }</span>
   607 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x84);</span>
   608 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
   609 |     | <span class='neutral'>        assembly {</span>
   610 |     | <span class='neutral'>            mstore(0x00, m0)</span>
   611 |     | <span class='neutral'>            mstore(0x20, m1)</span>
   612 |     | <span class='neutral'>            mstore(0x40, m2)</span>
   613 |     | <span class='neutral'>            mstore(0x60, m3)</span>
   614 |     | <span class='neutral'>            mstore(0x80, m4)</span>
   615 |     | <span class='neutral'>        }</span>
   616 |     | <span class='neutral'>    }</span>
   617 |     | <span class='neutral'></span>
   618 |     | <span class='neutral'>    function log(bytes32 p0, bytes32 p1) internal pure {</span>
   619 |     | <span class='neutral'>        bytes32 m0;</span>
   620 |     | <span class='neutral'>        bytes32 m1;</span>
   621 |     | <span class='neutral'>        bytes32 m2;</span>
   622 |     | <span class='neutral'>        bytes32 m3;</span>
   623 |     | <span class='neutral'>        bytes32 m4;</span>
   624 |     | <span class='neutral'>        bytes32 m5;</span>
   625 |     | <span class='neutral'>        bytes32 m6;</span>
   626 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
   627 |     | <span class='neutral'>        assembly {</span>
   628 |     | <span class='neutral'>            function writeString(pos, w) {</span>
   629 |     | <span class='neutral'>                let length := 0</span>
   630 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
   631 |     | <span class='neutral'>                mstore(pos, length)</span>
   632 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
   633 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
   634 |     | <span class='neutral'>            }</span>
   635 |     | <span class='neutral'>            m0 := mload(0x00)</span>
   636 |     | <span class='neutral'>            m1 := mload(0x20)</span>
   637 |     | <span class='neutral'>            m2 := mload(0x40)</span>
   638 |     | <span class='neutral'>            m3 := mload(0x60)</span>
   639 |     | <span class='neutral'>            m4 := mload(0x80)</span>
   640 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
   641 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
   642 |     | <span class='neutral'>            // Selector of `log(string,string)`.</span>
   643 |     | <span class='neutral'>            mstore(0x00, 0x4b5c4277)</span>
   644 |     | <span class='neutral'>            mstore(0x20, 0x40)</span>
   645 |     | <span class='neutral'>            mstore(0x40, 0x80)</span>
   646 |     | <span class='neutral'>            writeString(0x60, p0)</span>
   647 |     | <span class='neutral'>            writeString(0xa0, p1)</span>
   648 |     | <span class='neutral'>        }</span>
   649 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xc4);</span>
   650 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
   651 |     | <span class='neutral'>        assembly {</span>
   652 |     | <span class='neutral'>            mstore(0x00, m0)</span>
   653 |     | <span class='neutral'>            mstore(0x20, m1)</span>
   654 |     | <span class='neutral'>            mstore(0x40, m2)</span>
   655 |     | <span class='neutral'>            mstore(0x60, m3)</span>
   656 |     | <span class='neutral'>            mstore(0x80, m4)</span>
   657 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
   658 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
   659 |     | <span class='neutral'>        }</span>
   660 |     | <span class='neutral'>    }</span>
   661 |     | <span class='neutral'></span>
   662 |     | <span class='neutral'>    function log(address p0, address p1, address p2) internal pure {</span>
   663 |     | <span class='neutral'>        bytes32 m0;</span>
   664 |     | <span class='neutral'>        bytes32 m1;</span>
   665 |     | <span class='neutral'>        bytes32 m2;</span>
   666 |     | <span class='neutral'>        bytes32 m3;</span>
   667 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
   668 |     | <span class='neutral'>        assembly {</span>
   669 |     | <span class='neutral'>            m0 := mload(0x00)</span>
   670 |     | <span class='neutral'>            m1 := mload(0x20)</span>
   671 |     | <span class='neutral'>            m2 := mload(0x40)</span>
   672 |     | <span class='neutral'>            m3 := mload(0x60)</span>
   673 |     | <span class='neutral'>            // Selector of `log(address,address,address)`.</span>
   674 |     | <span class='neutral'>            mstore(0x00, 0x018c84c2)</span>
   675 |     | <span class='neutral'>            mstore(0x20, p0)</span>
   676 |     | <span class='neutral'>            mstore(0x40, p1)</span>
   677 |     | <span class='neutral'>            mstore(0x60, p2)</span>
   678 |     | <span class='neutral'>        }</span>
   679 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x64);</span>
   680 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
   681 |     | <span class='neutral'>        assembly {</span>
   682 |     | <span class='neutral'>            mstore(0x00, m0)</span>
   683 |     | <span class='neutral'>            mstore(0x20, m1)</span>
   684 |     | <span class='neutral'>            mstore(0x40, m2)</span>
   685 |     | <span class='neutral'>            mstore(0x60, m3)</span>
   686 |     | <span class='neutral'>        }</span>
   687 |     | <span class='neutral'>    }</span>
   688 |     | <span class='neutral'></span>
   689 |     | <span class='neutral'>    function log(address p0, address p1, bool p2) internal pure {</span>
   690 |     | <span class='neutral'>        bytes32 m0;</span>
   691 |     | <span class='neutral'>        bytes32 m1;</span>
   692 |     | <span class='neutral'>        bytes32 m2;</span>
   693 |     | <span class='neutral'>        bytes32 m3;</span>
   694 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
   695 |     | <span class='neutral'>        assembly {</span>
   696 |     | <span class='neutral'>            m0 := mload(0x00)</span>
   697 |     | <span class='neutral'>            m1 := mload(0x20)</span>
   698 |     | <span class='neutral'>            m2 := mload(0x40)</span>
   699 |     | <span class='neutral'>            m3 := mload(0x60)</span>
   700 |     | <span class='neutral'>            // Selector of `log(address,address,bool)`.</span>
   701 |     | <span class='neutral'>            mstore(0x00, 0xf2a66286)</span>
   702 |     | <span class='neutral'>            mstore(0x20, p0)</span>
   703 |     | <span class='neutral'>            mstore(0x40, p1)</span>
   704 |     | <span class='neutral'>            mstore(0x60, p2)</span>
   705 |     | <span class='neutral'>        }</span>
   706 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x64);</span>
   707 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
   708 |     | <span class='neutral'>        assembly {</span>
   709 |     | <span class='neutral'>            mstore(0x00, m0)</span>
   710 |     | <span class='neutral'>            mstore(0x20, m1)</span>
   711 |     | <span class='neutral'>            mstore(0x40, m2)</span>
   712 |     | <span class='neutral'>            mstore(0x60, m3)</span>
   713 |     | <span class='neutral'>        }</span>
   714 |     | <span class='neutral'>    }</span>
   715 |     | <span class='neutral'></span>
   716 |     | <span class='neutral'>    function log(address p0, address p1, uint256 p2) internal pure {</span>
   717 |     | <span class='neutral'>        bytes32 m0;</span>
   718 |     | <span class='neutral'>        bytes32 m1;</span>
   719 |     | <span class='neutral'>        bytes32 m2;</span>
   720 |     | <span class='neutral'>        bytes32 m3;</span>
   721 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
   722 |     | <span class='neutral'>        assembly {</span>
   723 |     | <span class='neutral'>            m0 := mload(0x00)</span>
   724 |     | <span class='neutral'>            m1 := mload(0x20)</span>
   725 |     | <span class='neutral'>            m2 := mload(0x40)</span>
   726 |     | <span class='neutral'>            m3 := mload(0x60)</span>
   727 |     | <span class='neutral'>            // Selector of `log(address,address,uint256)`.</span>
   728 |     | <span class='neutral'>            mstore(0x00, 0x17fe6185)</span>
   729 |     | <span class='neutral'>            mstore(0x20, p0)</span>
   730 |     | <span class='neutral'>            mstore(0x40, p1)</span>
   731 |     | <span class='neutral'>            mstore(0x60, p2)</span>
   732 |     | <span class='neutral'>        }</span>
   733 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x64);</span>
   734 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
   735 |     | <span class='neutral'>        assembly {</span>
   736 |     | <span class='neutral'>            mstore(0x00, m0)</span>
   737 |     | <span class='neutral'>            mstore(0x20, m1)</span>
   738 |     | <span class='neutral'>            mstore(0x40, m2)</span>
   739 |     | <span class='neutral'>            mstore(0x60, m3)</span>
   740 |     | <span class='neutral'>        }</span>
   741 |     | <span class='neutral'>    }</span>
   742 |     | <span class='neutral'></span>
   743 |     | <span class='neutral'>    function log(address p0, address p1, bytes32 p2) internal pure {</span>
   744 |     | <span class='neutral'>        bytes32 m0;</span>
   745 |     | <span class='neutral'>        bytes32 m1;</span>
   746 |     | <span class='neutral'>        bytes32 m2;</span>
   747 |     | <span class='neutral'>        bytes32 m3;</span>
   748 |     | <span class='neutral'>        bytes32 m4;</span>
   749 |     | <span class='neutral'>        bytes32 m5;</span>
   750 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
   751 |     | <span class='neutral'>        assembly {</span>
   752 |     | <span class='neutral'>            function writeString(pos, w) {</span>
   753 |     | <span class='neutral'>                let length := 0</span>
   754 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
   755 |     | <span class='neutral'>                mstore(pos, length)</span>
   756 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
   757 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
   758 |     | <span class='neutral'>            }</span>
   759 |     | <span class='neutral'>            m0 := mload(0x00)</span>
   760 |     | <span class='neutral'>            m1 := mload(0x20)</span>
   761 |     | <span class='neutral'>            m2 := mload(0x40)</span>
   762 |     | <span class='neutral'>            m3 := mload(0x60)</span>
   763 |     | <span class='neutral'>            m4 := mload(0x80)</span>
   764 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
   765 |     | <span class='neutral'>            // Selector of `log(address,address,string)`.</span>
   766 |     | <span class='neutral'>            mstore(0x00, 0x007150be)</span>
   767 |     | <span class='neutral'>            mstore(0x20, p0)</span>
   768 |     | <span class='neutral'>            mstore(0x40, p1)</span>
   769 |     | <span class='neutral'>            mstore(0x60, 0x60)</span>
   770 |     | <span class='neutral'>            writeString(0x80, p2)</span>
   771 |     | <span class='neutral'>        }</span>
   772 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xa4);</span>
   773 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
   774 |     | <span class='neutral'>        assembly {</span>
   775 |     | <span class='neutral'>            mstore(0x00, m0)</span>
   776 |     | <span class='neutral'>            mstore(0x20, m1)</span>
   777 |     | <span class='neutral'>            mstore(0x40, m2)</span>
   778 |     | <span class='neutral'>            mstore(0x60, m3)</span>
   779 |     | <span class='neutral'>            mstore(0x80, m4)</span>
   780 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
   781 |     | <span class='neutral'>        }</span>
   782 |     | <span class='neutral'>    }</span>
   783 |     | <span class='neutral'></span>
   784 |     | <span class='neutral'>    function log(address p0, bool p1, address p2) internal pure {</span>
   785 |     | <span class='neutral'>        bytes32 m0;</span>
   786 |     | <span class='neutral'>        bytes32 m1;</span>
   787 |     | <span class='neutral'>        bytes32 m2;</span>
   788 |     | <span class='neutral'>        bytes32 m3;</span>
   789 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
   790 |     | <span class='neutral'>        assembly {</span>
   791 |     | <span class='neutral'>            m0 := mload(0x00)</span>
   792 |     | <span class='neutral'>            m1 := mload(0x20)</span>
   793 |     | <span class='neutral'>            m2 := mload(0x40)</span>
   794 |     | <span class='neutral'>            m3 := mload(0x60)</span>
   795 |     | <span class='neutral'>            // Selector of `log(address,bool,address)`.</span>
   796 |     | <span class='neutral'>            mstore(0x00, 0xf11699ed)</span>
   797 |     | <span class='neutral'>            mstore(0x20, p0)</span>
   798 |     | <span class='neutral'>            mstore(0x40, p1)</span>
   799 |     | <span class='neutral'>            mstore(0x60, p2)</span>
   800 |     | <span class='neutral'>        }</span>
   801 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x64);</span>
   802 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
   803 |     | <span class='neutral'>        assembly {</span>
   804 |     | <span class='neutral'>            mstore(0x00, m0)</span>
   805 |     | <span class='neutral'>            mstore(0x20, m1)</span>
   806 |     | <span class='neutral'>            mstore(0x40, m2)</span>
   807 |     | <span class='neutral'>            mstore(0x60, m3)</span>
   808 |     | <span class='neutral'>        }</span>
   809 |     | <span class='neutral'>    }</span>
   810 |     | <span class='neutral'></span>
   811 |     | <span class='neutral'>    function log(address p0, bool p1, bool p2) internal pure {</span>
   812 |     | <span class='neutral'>        bytes32 m0;</span>
   813 |     | <span class='neutral'>        bytes32 m1;</span>
   814 |     | <span class='neutral'>        bytes32 m2;</span>
   815 |     | <span class='neutral'>        bytes32 m3;</span>
   816 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
   817 |     | <span class='neutral'>        assembly {</span>
   818 |     | <span class='neutral'>            m0 := mload(0x00)</span>
   819 |     | <span class='neutral'>            m1 := mload(0x20)</span>
   820 |     | <span class='neutral'>            m2 := mload(0x40)</span>
   821 |     | <span class='neutral'>            m3 := mload(0x60)</span>
   822 |     | <span class='neutral'>            // Selector of `log(address,bool,bool)`.</span>
   823 |     | <span class='neutral'>            mstore(0x00, 0xeb830c92)</span>
   824 |     | <span class='neutral'>            mstore(0x20, p0)</span>
   825 |     | <span class='neutral'>            mstore(0x40, p1)</span>
   826 |     | <span class='neutral'>            mstore(0x60, p2)</span>
   827 |     | <span class='neutral'>        }</span>
   828 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x64);</span>
   829 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
   830 |     | <span class='neutral'>        assembly {</span>
   831 |     | <span class='neutral'>            mstore(0x00, m0)</span>
   832 |     | <span class='neutral'>            mstore(0x20, m1)</span>
   833 |     | <span class='neutral'>            mstore(0x40, m2)</span>
   834 |     | <span class='neutral'>            mstore(0x60, m3)</span>
   835 |     | <span class='neutral'>        }</span>
   836 |     | <span class='neutral'>    }</span>
   837 |     | <span class='neutral'></span>
   838 |     | <span class='neutral'>    function log(address p0, bool p1, uint256 p2) internal pure {</span>
   839 |     | <span class='neutral'>        bytes32 m0;</span>
   840 |     | <span class='neutral'>        bytes32 m1;</span>
   841 |     | <span class='neutral'>        bytes32 m2;</span>
   842 |     | <span class='neutral'>        bytes32 m3;</span>
   843 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
   844 |     | <span class='neutral'>        assembly {</span>
   845 |     | <span class='neutral'>            m0 := mload(0x00)</span>
   846 |     | <span class='neutral'>            m1 := mload(0x20)</span>
   847 |     | <span class='neutral'>            m2 := mload(0x40)</span>
   848 |     | <span class='neutral'>            m3 := mload(0x60)</span>
   849 |     | <span class='neutral'>            // Selector of `log(address,bool,uint256)`.</span>
   850 |     | <span class='neutral'>            mstore(0x00, 0x9c4f99fb)</span>
   851 |     | <span class='neutral'>            mstore(0x20, p0)</span>
   852 |     | <span class='neutral'>            mstore(0x40, p1)</span>
   853 |     | <span class='neutral'>            mstore(0x60, p2)</span>
   854 |     | <span class='neutral'>        }</span>
   855 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x64);</span>
   856 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
   857 |     | <span class='neutral'>        assembly {</span>
   858 |     | <span class='neutral'>            mstore(0x00, m0)</span>
   859 |     | <span class='neutral'>            mstore(0x20, m1)</span>
   860 |     | <span class='neutral'>            mstore(0x40, m2)</span>
   861 |     | <span class='neutral'>            mstore(0x60, m3)</span>
   862 |     | <span class='neutral'>        }</span>
   863 |     | <span class='neutral'>    }</span>
   864 |     | <span class='neutral'></span>
   865 |     | <span class='neutral'>    function log(address p0, bool p1, bytes32 p2) internal pure {</span>
   866 |     | <span class='neutral'>        bytes32 m0;</span>
   867 |     | <span class='neutral'>        bytes32 m1;</span>
   868 |     | <span class='neutral'>        bytes32 m2;</span>
   869 |     | <span class='neutral'>        bytes32 m3;</span>
   870 |     | <span class='neutral'>        bytes32 m4;</span>
   871 |     | <span class='neutral'>        bytes32 m5;</span>
   872 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
   873 |     | <span class='neutral'>        assembly {</span>
   874 |     | <span class='neutral'>            function writeString(pos, w) {</span>
   875 |     | <span class='neutral'>                let length := 0</span>
   876 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
   877 |     | <span class='neutral'>                mstore(pos, length)</span>
   878 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
   879 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
   880 |     | <span class='neutral'>            }</span>
   881 |     | <span class='neutral'>            m0 := mload(0x00)</span>
   882 |     | <span class='neutral'>            m1 := mload(0x20)</span>
   883 |     | <span class='neutral'>            m2 := mload(0x40)</span>
   884 |     | <span class='neutral'>            m3 := mload(0x60)</span>
   885 |     | <span class='neutral'>            m4 := mload(0x80)</span>
   886 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
   887 |     | <span class='neutral'>            // Selector of `log(address,bool,string)`.</span>
   888 |     | <span class='neutral'>            mstore(0x00, 0x212255cc)</span>
   889 |     | <span class='neutral'>            mstore(0x20, p0)</span>
   890 |     | <span class='neutral'>            mstore(0x40, p1)</span>
   891 |     | <span class='neutral'>            mstore(0x60, 0x60)</span>
   892 |     | <span class='neutral'>            writeString(0x80, p2)</span>
   893 |     | <span class='neutral'>        }</span>
   894 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xa4);</span>
   895 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
   896 |     | <span class='neutral'>        assembly {</span>
   897 |     | <span class='neutral'>            mstore(0x00, m0)</span>
   898 |     | <span class='neutral'>            mstore(0x20, m1)</span>
   899 |     | <span class='neutral'>            mstore(0x40, m2)</span>
   900 |     | <span class='neutral'>            mstore(0x60, m3)</span>
   901 |     | <span class='neutral'>            mstore(0x80, m4)</span>
   902 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
   903 |     | <span class='neutral'>        }</span>
   904 |     | <span class='neutral'>    }</span>
   905 |     | <span class='neutral'></span>
   906 |     | <span class='neutral'>    function log(address p0, uint256 p1, address p2) internal pure {</span>
   907 |     | <span class='neutral'>        bytes32 m0;</span>
   908 |     | <span class='neutral'>        bytes32 m1;</span>
   909 |     | <span class='neutral'>        bytes32 m2;</span>
   910 |     | <span class='neutral'>        bytes32 m3;</span>
   911 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
   912 |     | <span class='neutral'>        assembly {</span>
   913 |     | <span class='neutral'>            m0 := mload(0x00)</span>
   914 |     | <span class='neutral'>            m1 := mload(0x20)</span>
   915 |     | <span class='neutral'>            m2 := mload(0x40)</span>
   916 |     | <span class='neutral'>            m3 := mload(0x60)</span>
   917 |     | <span class='neutral'>            // Selector of `log(address,uint256,address)`.</span>
   918 |     | <span class='neutral'>            mstore(0x00, 0x7bc0d848)</span>
   919 |     | <span class='neutral'>            mstore(0x20, p0)</span>
   920 |     | <span class='neutral'>            mstore(0x40, p1)</span>
   921 |     | <span class='neutral'>            mstore(0x60, p2)</span>
   922 |     | <span class='neutral'>        }</span>
   923 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x64);</span>
   924 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
   925 |     | <span class='neutral'>        assembly {</span>
   926 |     | <span class='neutral'>            mstore(0x00, m0)</span>
   927 |     | <span class='neutral'>            mstore(0x20, m1)</span>
   928 |     | <span class='neutral'>            mstore(0x40, m2)</span>
   929 |     | <span class='neutral'>            mstore(0x60, m3)</span>
   930 |     | <span class='neutral'>        }</span>
   931 |     | <span class='neutral'>    }</span>
   932 |     | <span class='neutral'></span>
   933 |     | <span class='neutral'>    function log(address p0, uint256 p1, bool p2) internal pure {</span>
   934 |     | <span class='neutral'>        bytes32 m0;</span>
   935 |     | <span class='neutral'>        bytes32 m1;</span>
   936 |     | <span class='neutral'>        bytes32 m2;</span>
   937 |     | <span class='neutral'>        bytes32 m3;</span>
   938 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
   939 |     | <span class='neutral'>        assembly {</span>
   940 |     | <span class='neutral'>            m0 := mload(0x00)</span>
   941 |     | <span class='neutral'>            m1 := mload(0x20)</span>
   942 |     | <span class='neutral'>            m2 := mload(0x40)</span>
   943 |     | <span class='neutral'>            m3 := mload(0x60)</span>
   944 |     | <span class='neutral'>            // Selector of `log(address,uint256,bool)`.</span>
   945 |     | <span class='neutral'>            mstore(0x00, 0x678209a8)</span>
   946 |     | <span class='neutral'>            mstore(0x20, p0)</span>
   947 |     | <span class='neutral'>            mstore(0x40, p1)</span>
   948 |     | <span class='neutral'>            mstore(0x60, p2)</span>
   949 |     | <span class='neutral'>        }</span>
   950 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x64);</span>
   951 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
   952 |     | <span class='neutral'>        assembly {</span>
   953 |     | <span class='neutral'>            mstore(0x00, m0)</span>
   954 |     | <span class='neutral'>            mstore(0x20, m1)</span>
   955 |     | <span class='neutral'>            mstore(0x40, m2)</span>
   956 |     | <span class='neutral'>            mstore(0x60, m3)</span>
   957 |     | <span class='neutral'>        }</span>
   958 |     | <span class='neutral'>    }</span>
   959 |     | <span class='neutral'></span>
   960 |     | <span class='neutral'>    function log(address p0, uint256 p1, uint256 p2) internal pure {</span>
   961 |     | <span class='neutral'>        bytes32 m0;</span>
   962 |     | <span class='neutral'>        bytes32 m1;</span>
   963 |     | <span class='neutral'>        bytes32 m2;</span>
   964 |     | <span class='neutral'>        bytes32 m3;</span>
   965 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
   966 |     | <span class='neutral'>        assembly {</span>
   967 |     | <span class='neutral'>            m0 := mload(0x00)</span>
   968 |     | <span class='neutral'>            m1 := mload(0x20)</span>
   969 |     | <span class='neutral'>            m2 := mload(0x40)</span>
   970 |     | <span class='neutral'>            m3 := mload(0x60)</span>
   971 |     | <span class='neutral'>            // Selector of `log(address,uint256,uint256)`.</span>
   972 |     | <span class='neutral'>            mstore(0x00, 0xb69bcaf6)</span>
   973 |     | <span class='neutral'>            mstore(0x20, p0)</span>
   974 |     | <span class='neutral'>            mstore(0x40, p1)</span>
   975 |     | <span class='neutral'>            mstore(0x60, p2)</span>
   976 |     | <span class='neutral'>        }</span>
   977 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x64);</span>
   978 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
   979 |     | <span class='neutral'>        assembly {</span>
   980 |     | <span class='neutral'>            mstore(0x00, m0)</span>
   981 |     | <span class='neutral'>            mstore(0x20, m1)</span>
   982 |     | <span class='neutral'>            mstore(0x40, m2)</span>
   983 |     | <span class='neutral'>            mstore(0x60, m3)</span>
   984 |     | <span class='neutral'>        }</span>
   985 |     | <span class='neutral'>    }</span>
   986 |     | <span class='neutral'></span>
   987 |     | <span class='neutral'>    function log(address p0, uint256 p1, bytes32 p2) internal pure {</span>
   988 |     | <span class='neutral'>        bytes32 m0;</span>
   989 |     | <span class='neutral'>        bytes32 m1;</span>
   990 |     | <span class='neutral'>        bytes32 m2;</span>
   991 |     | <span class='neutral'>        bytes32 m3;</span>
   992 |     | <span class='neutral'>        bytes32 m4;</span>
   993 |     | <span class='neutral'>        bytes32 m5;</span>
   994 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
   995 |     | <span class='neutral'>        assembly {</span>
   996 |     | <span class='neutral'>            function writeString(pos, w) {</span>
   997 |     | <span class='neutral'>                let length := 0</span>
   998 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
   999 |     | <span class='neutral'>                mstore(pos, length)</span>
  1000 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  1001 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  1002 |     | <span class='neutral'>            }</span>
  1003 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  1004 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  1005 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  1006 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  1007 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  1008 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  1009 |     | <span class='neutral'>            // Selector of `log(address,uint256,string)`.</span>
  1010 |     | <span class='neutral'>            mstore(0x00, 0xa1f2e8aa)</span>
  1011 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  1012 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  1013 |     | <span class='neutral'>            mstore(0x60, 0x60)</span>
  1014 |     | <span class='neutral'>            writeString(0x80, p2)</span>
  1015 |     | <span class='neutral'>        }</span>
  1016 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xa4);</span>
  1017 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  1018 |     | <span class='neutral'>        assembly {</span>
  1019 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  1020 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  1021 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  1022 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  1023 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  1024 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  1025 |     | <span class='neutral'>        }</span>
  1026 |     | <span class='neutral'>    }</span>
  1027 |     | <span class='neutral'></span>
  1028 |     | <span class='neutral'>    function log(address p0, bytes32 p1, address p2) internal pure {</span>
  1029 |     | <span class='neutral'>        bytes32 m0;</span>
  1030 |     | <span class='neutral'>        bytes32 m1;</span>
  1031 |     | <span class='neutral'>        bytes32 m2;</span>
  1032 |     | <span class='neutral'>        bytes32 m3;</span>
  1033 |     | <span class='neutral'>        bytes32 m4;</span>
  1034 |     | <span class='neutral'>        bytes32 m5;</span>
  1035 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  1036 |     | <span class='neutral'>        assembly {</span>
  1037 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  1038 |     | <span class='neutral'>                let length := 0</span>
  1039 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  1040 |     | <span class='neutral'>                mstore(pos, length)</span>
  1041 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  1042 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  1043 |     | <span class='neutral'>            }</span>
  1044 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  1045 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  1046 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  1047 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  1048 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  1049 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  1050 |     | <span class='neutral'>            // Selector of `log(address,string,address)`.</span>
  1051 |     | <span class='neutral'>            mstore(0x00, 0xf08744e8)</span>
  1052 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  1053 |     | <span class='neutral'>            mstore(0x40, 0x60)</span>
  1054 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  1055 |     | <span class='neutral'>            writeString(0x80, p1)</span>
  1056 |     | <span class='neutral'>        }</span>
  1057 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xa4);</span>
  1058 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  1059 |     | <span class='neutral'>        assembly {</span>
  1060 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  1061 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  1062 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  1063 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  1064 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  1065 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  1066 |     | <span class='neutral'>        }</span>
  1067 |     | <span class='neutral'>    }</span>
  1068 |     | <span class='neutral'></span>
  1069 |     | <span class='neutral'>    function log(address p0, bytes32 p1, bool p2) internal pure {</span>
  1070 |     | <span class='neutral'>        bytes32 m0;</span>
  1071 |     | <span class='neutral'>        bytes32 m1;</span>
  1072 |     | <span class='neutral'>        bytes32 m2;</span>
  1073 |     | <span class='neutral'>        bytes32 m3;</span>
  1074 |     | <span class='neutral'>        bytes32 m4;</span>
  1075 |     | <span class='neutral'>        bytes32 m5;</span>
  1076 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  1077 |     | <span class='neutral'>        assembly {</span>
  1078 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  1079 |     | <span class='neutral'>                let length := 0</span>
  1080 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  1081 |     | <span class='neutral'>                mstore(pos, length)</span>
  1082 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  1083 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  1084 |     | <span class='neutral'>            }</span>
  1085 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  1086 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  1087 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  1088 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  1089 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  1090 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  1091 |     | <span class='neutral'>            // Selector of `log(address,string,bool)`.</span>
  1092 |     | <span class='neutral'>            mstore(0x00, 0xcf020fb1)</span>
  1093 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  1094 |     | <span class='neutral'>            mstore(0x40, 0x60)</span>
  1095 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  1096 |     | <span class='neutral'>            writeString(0x80, p1)</span>
  1097 |     | <span class='neutral'>        }</span>
  1098 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xa4);</span>
  1099 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  1100 |     | <span class='neutral'>        assembly {</span>
  1101 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  1102 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  1103 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  1104 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  1105 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  1106 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  1107 |     | <span class='neutral'>        }</span>
  1108 |     | <span class='neutral'>    }</span>
  1109 |     | <span class='neutral'></span>
  1110 |     | <span class='neutral'>    function log(address p0, bytes32 p1, uint256 p2) internal pure {</span>
  1111 |     | <span class='neutral'>        bytes32 m0;</span>
  1112 |     | <span class='neutral'>        bytes32 m1;</span>
  1113 |     | <span class='neutral'>        bytes32 m2;</span>
  1114 |     | <span class='neutral'>        bytes32 m3;</span>
  1115 |     | <span class='neutral'>        bytes32 m4;</span>
  1116 |     | <span class='neutral'>        bytes32 m5;</span>
  1117 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  1118 |     | <span class='neutral'>        assembly {</span>
  1119 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  1120 |     | <span class='neutral'>                let length := 0</span>
  1121 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  1122 |     | <span class='neutral'>                mstore(pos, length)</span>
  1123 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  1124 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  1125 |     | <span class='neutral'>            }</span>
  1126 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  1127 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  1128 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  1129 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  1130 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  1131 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  1132 |     | <span class='neutral'>            // Selector of `log(address,string,uint256)`.</span>
  1133 |     | <span class='neutral'>            mstore(0x00, 0x67dd6ff1)</span>
  1134 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  1135 |     | <span class='neutral'>            mstore(0x40, 0x60)</span>
  1136 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  1137 |     | <span class='neutral'>            writeString(0x80, p1)</span>
  1138 |     | <span class='neutral'>        }</span>
  1139 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xa4);</span>
  1140 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  1141 |     | <span class='neutral'>        assembly {</span>
  1142 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  1143 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  1144 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  1145 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  1146 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  1147 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  1148 |     | <span class='neutral'>        }</span>
  1149 |     | <span class='neutral'>    }</span>
  1150 |     | <span class='neutral'></span>
  1151 |     | <span class='neutral'>    function log(address p0, bytes32 p1, bytes32 p2) internal pure {</span>
  1152 |     | <span class='neutral'>        bytes32 m0;</span>
  1153 |     | <span class='neutral'>        bytes32 m1;</span>
  1154 |     | <span class='neutral'>        bytes32 m2;</span>
  1155 |     | <span class='neutral'>        bytes32 m3;</span>
  1156 |     | <span class='neutral'>        bytes32 m4;</span>
  1157 |     | <span class='neutral'>        bytes32 m5;</span>
  1158 |     | <span class='neutral'>        bytes32 m6;</span>
  1159 |     | <span class='neutral'>        bytes32 m7;</span>
  1160 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  1161 |     | <span class='neutral'>        assembly {</span>
  1162 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  1163 |     | <span class='neutral'>                let length := 0</span>
  1164 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  1165 |     | <span class='neutral'>                mstore(pos, length)</span>
  1166 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  1167 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  1168 |     | <span class='neutral'>            }</span>
  1169 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  1170 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  1171 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  1172 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  1173 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  1174 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  1175 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
  1176 |     | <span class='neutral'>            m7 := mload(0xe0)</span>
  1177 |     | <span class='neutral'>            // Selector of `log(address,string,string)`.</span>
  1178 |     | <span class='neutral'>            mstore(0x00, 0xfb772265)</span>
  1179 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  1180 |     | <span class='neutral'>            mstore(0x40, 0x60)</span>
  1181 |     | <span class='neutral'>            mstore(0x60, 0xa0)</span>
  1182 |     | <span class='neutral'>            writeString(0x80, p1)</span>
  1183 |     | <span class='neutral'>            writeString(0xc0, p2)</span>
  1184 |     | <span class='neutral'>        }</span>
  1185 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xe4);</span>
  1186 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  1187 |     | <span class='neutral'>        assembly {</span>
  1188 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  1189 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  1190 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  1191 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  1192 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  1193 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  1194 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
  1195 |     | <span class='neutral'>            mstore(0xe0, m7)</span>
  1196 |     | <span class='neutral'>        }</span>
  1197 |     | <span class='neutral'>    }</span>
  1198 |     | <span class='neutral'></span>
  1199 |     | <span class='neutral'>    function log(bool p0, address p1, address p2) internal pure {</span>
  1200 |     | <span class='neutral'>        bytes32 m0;</span>
  1201 |     | <span class='neutral'>        bytes32 m1;</span>
  1202 |     | <span class='neutral'>        bytes32 m2;</span>
  1203 |     | <span class='neutral'>        bytes32 m3;</span>
  1204 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  1205 |     | <span class='neutral'>        assembly {</span>
  1206 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  1207 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  1208 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  1209 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  1210 |     | <span class='neutral'>            // Selector of `log(bool,address,address)`.</span>
  1211 |     | <span class='neutral'>            mstore(0x00, 0xd2763667)</span>
  1212 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  1213 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  1214 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  1215 |     | <span class='neutral'>        }</span>
  1216 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x64);</span>
  1217 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  1218 |     | <span class='neutral'>        assembly {</span>
  1219 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  1220 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  1221 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  1222 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  1223 |     | <span class='neutral'>        }</span>
  1224 |     | <span class='neutral'>    }</span>
  1225 |     | <span class='neutral'></span>
  1226 |     | <span class='neutral'>    function log(bool p0, address p1, bool p2) internal pure {</span>
  1227 |     | <span class='neutral'>        bytes32 m0;</span>
  1228 |     | <span class='neutral'>        bytes32 m1;</span>
  1229 |     | <span class='neutral'>        bytes32 m2;</span>
  1230 |     | <span class='neutral'>        bytes32 m3;</span>
  1231 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  1232 |     | <span class='neutral'>        assembly {</span>
  1233 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  1234 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  1235 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  1236 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  1237 |     | <span class='neutral'>            // Selector of `log(bool,address,bool)`.</span>
  1238 |     | <span class='neutral'>            mstore(0x00, 0x18c9c746)</span>
  1239 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  1240 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  1241 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  1242 |     | <span class='neutral'>        }</span>
  1243 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x64);</span>
  1244 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  1245 |     | <span class='neutral'>        assembly {</span>
  1246 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  1247 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  1248 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  1249 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  1250 |     | <span class='neutral'>        }</span>
  1251 |     | <span class='neutral'>    }</span>
  1252 |     | <span class='neutral'></span>
  1253 |     | <span class='neutral'>    function log(bool p0, address p1, uint256 p2) internal pure {</span>
  1254 |     | <span class='neutral'>        bytes32 m0;</span>
  1255 |     | <span class='neutral'>        bytes32 m1;</span>
  1256 |     | <span class='neutral'>        bytes32 m2;</span>
  1257 |     | <span class='neutral'>        bytes32 m3;</span>
  1258 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  1259 |     | <span class='neutral'>        assembly {</span>
  1260 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  1261 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  1262 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  1263 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  1264 |     | <span class='neutral'>            // Selector of `log(bool,address,uint256)`.</span>
  1265 |     | <span class='neutral'>            mstore(0x00, 0x5f7b9afb)</span>
  1266 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  1267 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  1268 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  1269 |     | <span class='neutral'>        }</span>
  1270 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x64);</span>
  1271 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  1272 |     | <span class='neutral'>        assembly {</span>
  1273 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  1274 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  1275 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  1276 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  1277 |     | <span class='neutral'>        }</span>
  1278 |     | <span class='neutral'>    }</span>
  1279 |     | <span class='neutral'></span>
  1280 |     | <span class='neutral'>    function log(bool p0, address p1, bytes32 p2) internal pure {</span>
  1281 |     | <span class='neutral'>        bytes32 m0;</span>
  1282 |     | <span class='neutral'>        bytes32 m1;</span>
  1283 |     | <span class='neutral'>        bytes32 m2;</span>
  1284 |     | <span class='neutral'>        bytes32 m3;</span>
  1285 |     | <span class='neutral'>        bytes32 m4;</span>
  1286 |     | <span class='neutral'>        bytes32 m5;</span>
  1287 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  1288 |     | <span class='neutral'>        assembly {</span>
  1289 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  1290 |     | <span class='neutral'>                let length := 0</span>
  1291 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  1292 |     | <span class='neutral'>                mstore(pos, length)</span>
  1293 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  1294 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  1295 |     | <span class='neutral'>            }</span>
  1296 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  1297 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  1298 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  1299 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  1300 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  1301 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  1302 |     | <span class='neutral'>            // Selector of `log(bool,address,string)`.</span>
  1303 |     | <span class='neutral'>            mstore(0x00, 0xde9a9270)</span>
  1304 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  1305 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  1306 |     | <span class='neutral'>            mstore(0x60, 0x60)</span>
  1307 |     | <span class='neutral'>            writeString(0x80, p2)</span>
  1308 |     | <span class='neutral'>        }</span>
  1309 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xa4);</span>
  1310 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  1311 |     | <span class='neutral'>        assembly {</span>
  1312 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  1313 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  1314 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  1315 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  1316 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  1317 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  1318 |     | <span class='neutral'>        }</span>
  1319 |     | <span class='neutral'>    }</span>
  1320 |     | <span class='neutral'></span>
  1321 |     | <span class='neutral'>    function log(bool p0, bool p1, address p2) internal pure {</span>
  1322 |     | <span class='neutral'>        bytes32 m0;</span>
  1323 |     | <span class='neutral'>        bytes32 m1;</span>
  1324 |     | <span class='neutral'>        bytes32 m2;</span>
  1325 |     | <span class='neutral'>        bytes32 m3;</span>
  1326 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  1327 |     | <span class='neutral'>        assembly {</span>
  1328 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  1329 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  1330 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  1331 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  1332 |     | <span class='neutral'>            // Selector of `log(bool,bool,address)`.</span>
  1333 |     | <span class='neutral'>            mstore(0x00, 0x1078f68d)</span>
  1334 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  1335 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  1336 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  1337 |     | <span class='neutral'>        }</span>
  1338 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x64);</span>
  1339 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  1340 |     | <span class='neutral'>        assembly {</span>
  1341 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  1342 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  1343 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  1344 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  1345 |     | <span class='neutral'>        }</span>
  1346 |     | <span class='neutral'>    }</span>
  1347 |     | <span class='neutral'></span>
  1348 |     | <span class='neutral'>    function log(bool p0, bool p1, bool p2) internal pure {</span>
  1349 |     | <span class='neutral'>        bytes32 m0;</span>
  1350 |     | <span class='neutral'>        bytes32 m1;</span>
  1351 |     | <span class='neutral'>        bytes32 m2;</span>
  1352 |     | <span class='neutral'>        bytes32 m3;</span>
  1353 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  1354 |     | <span class='neutral'>        assembly {</span>
  1355 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  1356 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  1357 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  1358 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  1359 |     | <span class='neutral'>            // Selector of `log(bool,bool,bool)`.</span>
  1360 |     | <span class='neutral'>            mstore(0x00, 0x50709698)</span>
  1361 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  1362 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  1363 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  1364 |     | <span class='neutral'>        }</span>
  1365 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x64);</span>
  1366 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  1367 |     | <span class='neutral'>        assembly {</span>
  1368 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  1369 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  1370 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  1371 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  1372 |     | <span class='neutral'>        }</span>
  1373 |     | <span class='neutral'>    }</span>
  1374 |     | <span class='neutral'></span>
  1375 |     | <span class='neutral'>    function log(bool p0, bool p1, uint256 p2) internal pure {</span>
  1376 |     | <span class='neutral'>        bytes32 m0;</span>
  1377 |     | <span class='neutral'>        bytes32 m1;</span>
  1378 |     | <span class='neutral'>        bytes32 m2;</span>
  1379 |     | <span class='neutral'>        bytes32 m3;</span>
  1380 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  1381 |     | <span class='neutral'>        assembly {</span>
  1382 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  1383 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  1384 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  1385 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  1386 |     | <span class='neutral'>            // Selector of `log(bool,bool,uint256)`.</span>
  1387 |     | <span class='neutral'>            mstore(0x00, 0x12f21602)</span>
  1388 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  1389 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  1390 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  1391 |     | <span class='neutral'>        }</span>
  1392 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x64);</span>
  1393 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  1394 |     | <span class='neutral'>        assembly {</span>
  1395 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  1396 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  1397 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  1398 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  1399 |     | <span class='neutral'>        }</span>
  1400 |     | <span class='neutral'>    }</span>
  1401 |     | <span class='neutral'></span>
  1402 |     | <span class='neutral'>    function log(bool p0, bool p1, bytes32 p2) internal pure {</span>
  1403 |     | <span class='neutral'>        bytes32 m0;</span>
  1404 |     | <span class='neutral'>        bytes32 m1;</span>
  1405 |     | <span class='neutral'>        bytes32 m2;</span>
  1406 |     | <span class='neutral'>        bytes32 m3;</span>
  1407 |     | <span class='neutral'>        bytes32 m4;</span>
  1408 |     | <span class='neutral'>        bytes32 m5;</span>
  1409 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  1410 |     | <span class='neutral'>        assembly {</span>
  1411 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  1412 |     | <span class='neutral'>                let length := 0</span>
  1413 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  1414 |     | <span class='neutral'>                mstore(pos, length)</span>
  1415 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  1416 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  1417 |     | <span class='neutral'>            }</span>
  1418 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  1419 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  1420 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  1421 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  1422 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  1423 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  1424 |     | <span class='neutral'>            // Selector of `log(bool,bool,string)`.</span>
  1425 |     | <span class='neutral'>            mstore(0x00, 0x2555fa46)</span>
  1426 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  1427 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  1428 |     | <span class='neutral'>            mstore(0x60, 0x60)</span>
  1429 |     | <span class='neutral'>            writeString(0x80, p2)</span>
  1430 |     | <span class='neutral'>        }</span>
  1431 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xa4);</span>
  1432 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  1433 |     | <span class='neutral'>        assembly {</span>
  1434 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  1435 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  1436 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  1437 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  1438 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  1439 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  1440 |     | <span class='neutral'>        }</span>
  1441 |     | <span class='neutral'>    }</span>
  1442 |     | <span class='neutral'></span>
  1443 |     | <span class='neutral'>    function log(bool p0, uint256 p1, address p2) internal pure {</span>
  1444 |     | <span class='neutral'>        bytes32 m0;</span>
  1445 |     | <span class='neutral'>        bytes32 m1;</span>
  1446 |     | <span class='neutral'>        bytes32 m2;</span>
  1447 |     | <span class='neutral'>        bytes32 m3;</span>
  1448 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  1449 |     | <span class='neutral'>        assembly {</span>
  1450 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  1451 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  1452 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  1453 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  1454 |     | <span class='neutral'>            // Selector of `log(bool,uint256,address)`.</span>
  1455 |     | <span class='neutral'>            mstore(0x00, 0x088ef9d2)</span>
  1456 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  1457 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  1458 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  1459 |     | <span class='neutral'>        }</span>
  1460 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x64);</span>
  1461 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  1462 |     | <span class='neutral'>        assembly {</span>
  1463 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  1464 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  1465 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  1466 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  1467 |     | <span class='neutral'>        }</span>
  1468 |     | <span class='neutral'>    }</span>
  1469 |     | <span class='neutral'></span>
  1470 |     | <span class='neutral'>    function log(bool p0, uint256 p1, bool p2) internal pure {</span>
  1471 |     | <span class='neutral'>        bytes32 m0;</span>
  1472 |     | <span class='neutral'>        bytes32 m1;</span>
  1473 |     | <span class='neutral'>        bytes32 m2;</span>
  1474 |     | <span class='neutral'>        bytes32 m3;</span>
  1475 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  1476 |     | <span class='neutral'>        assembly {</span>
  1477 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  1478 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  1479 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  1480 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  1481 |     | <span class='neutral'>            // Selector of `log(bool,uint256,bool)`.</span>
  1482 |     | <span class='neutral'>            mstore(0x00, 0xe8defba9)</span>
  1483 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  1484 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  1485 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  1486 |     | <span class='neutral'>        }</span>
  1487 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x64);</span>
  1488 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  1489 |     | <span class='neutral'>        assembly {</span>
  1490 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  1491 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  1492 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  1493 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  1494 |     | <span class='neutral'>        }</span>
  1495 |     | <span class='neutral'>    }</span>
  1496 |     | <span class='neutral'></span>
  1497 |     | <span class='neutral'>    function log(bool p0, uint256 p1, uint256 p2) internal pure {</span>
  1498 |     | <span class='neutral'>        bytes32 m0;</span>
  1499 |     | <span class='neutral'>        bytes32 m1;</span>
  1500 |     | <span class='neutral'>        bytes32 m2;</span>
  1501 |     | <span class='neutral'>        bytes32 m3;</span>
  1502 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  1503 |     | <span class='neutral'>        assembly {</span>
  1504 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  1505 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  1506 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  1507 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  1508 |     | <span class='neutral'>            // Selector of `log(bool,uint256,uint256)`.</span>
  1509 |     | <span class='neutral'>            mstore(0x00, 0x37103367)</span>
  1510 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  1511 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  1512 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  1513 |     | <span class='neutral'>        }</span>
  1514 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x64);</span>
  1515 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  1516 |     | <span class='neutral'>        assembly {</span>
  1517 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  1518 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  1519 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  1520 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  1521 |     | <span class='neutral'>        }</span>
  1522 |     | <span class='neutral'>    }</span>
  1523 |     | <span class='neutral'></span>
  1524 |     | <span class='neutral'>    function log(bool p0, uint256 p1, bytes32 p2) internal pure {</span>
  1525 |     | <span class='neutral'>        bytes32 m0;</span>
  1526 |     | <span class='neutral'>        bytes32 m1;</span>
  1527 |     | <span class='neutral'>        bytes32 m2;</span>
  1528 |     | <span class='neutral'>        bytes32 m3;</span>
  1529 |     | <span class='neutral'>        bytes32 m4;</span>
  1530 |     | <span class='neutral'>        bytes32 m5;</span>
  1531 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  1532 |     | <span class='neutral'>        assembly {</span>
  1533 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  1534 |     | <span class='neutral'>                let length := 0</span>
  1535 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  1536 |     | <span class='neutral'>                mstore(pos, length)</span>
  1537 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  1538 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  1539 |     | <span class='neutral'>            }</span>
  1540 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  1541 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  1542 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  1543 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  1544 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  1545 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  1546 |     | <span class='neutral'>            // Selector of `log(bool,uint256,string)`.</span>
  1547 |     | <span class='neutral'>            mstore(0x00, 0xc3fc3970)</span>
  1548 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  1549 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  1550 |     | <span class='neutral'>            mstore(0x60, 0x60)</span>
  1551 |     | <span class='neutral'>            writeString(0x80, p2)</span>
  1552 |     | <span class='neutral'>        }</span>
  1553 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xa4);</span>
  1554 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  1555 |     | <span class='neutral'>        assembly {</span>
  1556 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  1557 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  1558 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  1559 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  1560 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  1561 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  1562 |     | <span class='neutral'>        }</span>
  1563 |     | <span class='neutral'>    }</span>
  1564 |     | <span class='neutral'></span>
  1565 |     | <span class='neutral'>    function log(bool p0, bytes32 p1, address p2) internal pure {</span>
  1566 |     | <span class='neutral'>        bytes32 m0;</span>
  1567 |     | <span class='neutral'>        bytes32 m1;</span>
  1568 |     | <span class='neutral'>        bytes32 m2;</span>
  1569 |     | <span class='neutral'>        bytes32 m3;</span>
  1570 |     | <span class='neutral'>        bytes32 m4;</span>
  1571 |     | <span class='neutral'>        bytes32 m5;</span>
  1572 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  1573 |     | <span class='neutral'>        assembly {</span>
  1574 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  1575 |     | <span class='neutral'>                let length := 0</span>
  1576 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  1577 |     | <span class='neutral'>                mstore(pos, length)</span>
  1578 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  1579 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  1580 |     | <span class='neutral'>            }</span>
  1581 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  1582 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  1583 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  1584 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  1585 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  1586 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  1587 |     | <span class='neutral'>            // Selector of `log(bool,string,address)`.</span>
  1588 |     | <span class='neutral'>            mstore(0x00, 0x9591b953)</span>
  1589 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  1590 |     | <span class='neutral'>            mstore(0x40, 0x60)</span>
  1591 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  1592 |     | <span class='neutral'>            writeString(0x80, p1)</span>
  1593 |     | <span class='neutral'>        }</span>
  1594 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xa4);</span>
  1595 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  1596 |     | <span class='neutral'>        assembly {</span>
  1597 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  1598 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  1599 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  1600 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  1601 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  1602 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  1603 |     | <span class='neutral'>        }</span>
  1604 |     | <span class='neutral'>    }</span>
  1605 |     | <span class='neutral'></span>
  1606 |     | <span class='neutral'>    function log(bool p0, bytes32 p1, bool p2) internal pure {</span>
  1607 |     | <span class='neutral'>        bytes32 m0;</span>
  1608 |     | <span class='neutral'>        bytes32 m1;</span>
  1609 |     | <span class='neutral'>        bytes32 m2;</span>
  1610 |     | <span class='neutral'>        bytes32 m3;</span>
  1611 |     | <span class='neutral'>        bytes32 m4;</span>
  1612 |     | <span class='neutral'>        bytes32 m5;</span>
  1613 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  1614 |     | <span class='neutral'>        assembly {</span>
  1615 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  1616 |     | <span class='neutral'>                let length := 0</span>
  1617 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  1618 |     | <span class='neutral'>                mstore(pos, length)</span>
  1619 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  1620 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  1621 |     | <span class='neutral'>            }</span>
  1622 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  1623 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  1624 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  1625 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  1626 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  1627 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  1628 |     | <span class='neutral'>            // Selector of `log(bool,string,bool)`.</span>
  1629 |     | <span class='neutral'>            mstore(0x00, 0xdbb4c247)</span>
  1630 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  1631 |     | <span class='neutral'>            mstore(0x40, 0x60)</span>
  1632 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  1633 |     | <span class='neutral'>            writeString(0x80, p1)</span>
  1634 |     | <span class='neutral'>        }</span>
  1635 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xa4);</span>
  1636 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  1637 |     | <span class='neutral'>        assembly {</span>
  1638 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  1639 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  1640 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  1641 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  1642 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  1643 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  1644 |     | <span class='neutral'>        }</span>
  1645 |     | <span class='neutral'>    }</span>
  1646 |     | <span class='neutral'></span>
  1647 |     | <span class='neutral'>    function log(bool p0, bytes32 p1, uint256 p2) internal pure {</span>
  1648 |     | <span class='neutral'>        bytes32 m0;</span>
  1649 |     | <span class='neutral'>        bytes32 m1;</span>
  1650 |     | <span class='neutral'>        bytes32 m2;</span>
  1651 |     | <span class='neutral'>        bytes32 m3;</span>
  1652 |     | <span class='neutral'>        bytes32 m4;</span>
  1653 |     | <span class='neutral'>        bytes32 m5;</span>
  1654 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  1655 |     | <span class='neutral'>        assembly {</span>
  1656 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  1657 |     | <span class='neutral'>                let length := 0</span>
  1658 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  1659 |     | <span class='neutral'>                mstore(pos, length)</span>
  1660 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  1661 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  1662 |     | <span class='neutral'>            }</span>
  1663 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  1664 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  1665 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  1666 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  1667 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  1668 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  1669 |     | <span class='neutral'>            // Selector of `log(bool,string,uint256)`.</span>
  1670 |     | <span class='neutral'>            mstore(0x00, 0x1093ee11)</span>
  1671 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  1672 |     | <span class='neutral'>            mstore(0x40, 0x60)</span>
  1673 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  1674 |     | <span class='neutral'>            writeString(0x80, p1)</span>
  1675 |     | <span class='neutral'>        }</span>
  1676 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xa4);</span>
  1677 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  1678 |     | <span class='neutral'>        assembly {</span>
  1679 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  1680 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  1681 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  1682 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  1683 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  1684 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  1685 |     | <span class='neutral'>        }</span>
  1686 |     | <span class='neutral'>    }</span>
  1687 |     | <span class='neutral'></span>
  1688 |     | <span class='neutral'>    function log(bool p0, bytes32 p1, bytes32 p2) internal pure {</span>
  1689 |     | <span class='neutral'>        bytes32 m0;</span>
  1690 |     | <span class='neutral'>        bytes32 m1;</span>
  1691 |     | <span class='neutral'>        bytes32 m2;</span>
  1692 |     | <span class='neutral'>        bytes32 m3;</span>
  1693 |     | <span class='neutral'>        bytes32 m4;</span>
  1694 |     | <span class='neutral'>        bytes32 m5;</span>
  1695 |     | <span class='neutral'>        bytes32 m6;</span>
  1696 |     | <span class='neutral'>        bytes32 m7;</span>
  1697 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  1698 |     | <span class='neutral'>        assembly {</span>
  1699 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  1700 |     | <span class='neutral'>                let length := 0</span>
  1701 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  1702 |     | <span class='neutral'>                mstore(pos, length)</span>
  1703 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  1704 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  1705 |     | <span class='neutral'>            }</span>
  1706 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  1707 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  1708 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  1709 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  1710 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  1711 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  1712 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
  1713 |     | <span class='neutral'>            m7 := mload(0xe0)</span>
  1714 |     | <span class='neutral'>            // Selector of `log(bool,string,string)`.</span>
  1715 |     | <span class='neutral'>            mstore(0x00, 0xb076847f)</span>
  1716 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  1717 |     | <span class='neutral'>            mstore(0x40, 0x60)</span>
  1718 |     | <span class='neutral'>            mstore(0x60, 0xa0)</span>
  1719 |     | <span class='neutral'>            writeString(0x80, p1)</span>
  1720 |     | <span class='neutral'>            writeString(0xc0, p2)</span>
  1721 |     | <span class='neutral'>        }</span>
  1722 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xe4);</span>
  1723 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  1724 |     | <span class='neutral'>        assembly {</span>
  1725 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  1726 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  1727 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  1728 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  1729 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  1730 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  1731 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
  1732 |     | <span class='neutral'>            mstore(0xe0, m7)</span>
  1733 |     | <span class='neutral'>        }</span>
  1734 |     | <span class='neutral'>    }</span>
  1735 |     | <span class='neutral'></span>
  1736 |     | <span class='neutral'>    function log(uint256 p0, address p1, address p2) internal pure {</span>
  1737 |     | <span class='neutral'>        bytes32 m0;</span>
  1738 |     | <span class='neutral'>        bytes32 m1;</span>
  1739 |     | <span class='neutral'>        bytes32 m2;</span>
  1740 |     | <span class='neutral'>        bytes32 m3;</span>
  1741 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  1742 |     | <span class='neutral'>        assembly {</span>
  1743 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  1744 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  1745 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  1746 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  1747 |     | <span class='neutral'>            // Selector of `log(uint256,address,address)`.</span>
  1748 |     | <span class='neutral'>            mstore(0x00, 0xbcfd9be0)</span>
  1749 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  1750 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  1751 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  1752 |     | <span class='neutral'>        }</span>
  1753 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x64);</span>
  1754 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  1755 |     | <span class='neutral'>        assembly {</span>
  1756 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  1757 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  1758 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  1759 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  1760 |     | <span class='neutral'>        }</span>
  1761 |     | <span class='neutral'>    }</span>
  1762 |     | <span class='neutral'></span>
  1763 |     | <span class='neutral'>    function log(uint256 p0, address p1, bool p2) internal pure {</span>
  1764 |     | <span class='neutral'>        bytes32 m0;</span>
  1765 |     | <span class='neutral'>        bytes32 m1;</span>
  1766 |     | <span class='neutral'>        bytes32 m2;</span>
  1767 |     | <span class='neutral'>        bytes32 m3;</span>
  1768 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  1769 |     | <span class='neutral'>        assembly {</span>
  1770 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  1771 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  1772 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  1773 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  1774 |     | <span class='neutral'>            // Selector of `log(uint256,address,bool)`.</span>
  1775 |     | <span class='neutral'>            mstore(0x00, 0x9b6ec042)</span>
  1776 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  1777 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  1778 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  1779 |     | <span class='neutral'>        }</span>
  1780 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x64);</span>
  1781 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  1782 |     | <span class='neutral'>        assembly {</span>
  1783 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  1784 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  1785 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  1786 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  1787 |     | <span class='neutral'>        }</span>
  1788 |     | <span class='neutral'>    }</span>
  1789 |     | <span class='neutral'></span>
  1790 |     | <span class='neutral'>    function log(uint256 p0, address p1, uint256 p2) internal pure {</span>
  1791 |     | <span class='neutral'>        bytes32 m0;</span>
  1792 |     | <span class='neutral'>        bytes32 m1;</span>
  1793 |     | <span class='neutral'>        bytes32 m2;</span>
  1794 |     | <span class='neutral'>        bytes32 m3;</span>
  1795 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  1796 |     | <span class='neutral'>        assembly {</span>
  1797 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  1798 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  1799 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  1800 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  1801 |     | <span class='neutral'>            // Selector of `log(uint256,address,uint256)`.</span>
  1802 |     | <span class='neutral'>            mstore(0x00, 0x5a9b5ed5)</span>
  1803 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  1804 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  1805 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  1806 |     | <span class='neutral'>        }</span>
  1807 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x64);</span>
  1808 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  1809 |     | <span class='neutral'>        assembly {</span>
  1810 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  1811 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  1812 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  1813 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  1814 |     | <span class='neutral'>        }</span>
  1815 |     | <span class='neutral'>    }</span>
  1816 |     | <span class='neutral'></span>
  1817 |     | <span class='neutral'>    function log(uint256 p0, address p1, bytes32 p2) internal pure {</span>
  1818 |     | <span class='neutral'>        bytes32 m0;</span>
  1819 |     | <span class='neutral'>        bytes32 m1;</span>
  1820 |     | <span class='neutral'>        bytes32 m2;</span>
  1821 |     | <span class='neutral'>        bytes32 m3;</span>
  1822 |     | <span class='neutral'>        bytes32 m4;</span>
  1823 |     | <span class='neutral'>        bytes32 m5;</span>
  1824 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  1825 |     | <span class='neutral'>        assembly {</span>
  1826 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  1827 |     | <span class='neutral'>                let length := 0</span>
  1828 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  1829 |     | <span class='neutral'>                mstore(pos, length)</span>
  1830 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  1831 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  1832 |     | <span class='neutral'>            }</span>
  1833 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  1834 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  1835 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  1836 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  1837 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  1838 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  1839 |     | <span class='neutral'>            // Selector of `log(uint256,address,string)`.</span>
  1840 |     | <span class='neutral'>            mstore(0x00, 0x63cb41f9)</span>
  1841 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  1842 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  1843 |     | <span class='neutral'>            mstore(0x60, 0x60)</span>
  1844 |     | <span class='neutral'>            writeString(0x80, p2)</span>
  1845 |     | <span class='neutral'>        }</span>
  1846 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xa4);</span>
  1847 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  1848 |     | <span class='neutral'>        assembly {</span>
  1849 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  1850 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  1851 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  1852 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  1853 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  1854 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  1855 |     | <span class='neutral'>        }</span>
  1856 |     | <span class='neutral'>    }</span>
  1857 |     | <span class='neutral'></span>
  1858 |     | <span class='neutral'>    function log(uint256 p0, bool p1, address p2) internal pure {</span>
  1859 |     | <span class='neutral'>        bytes32 m0;</span>
  1860 |     | <span class='neutral'>        bytes32 m1;</span>
  1861 |     | <span class='neutral'>        bytes32 m2;</span>
  1862 |     | <span class='neutral'>        bytes32 m3;</span>
  1863 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  1864 |     | <span class='neutral'>        assembly {</span>
  1865 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  1866 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  1867 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  1868 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  1869 |     | <span class='neutral'>            // Selector of `log(uint256,bool,address)`.</span>
  1870 |     | <span class='neutral'>            mstore(0x00, 0x35085f7b)</span>
  1871 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  1872 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  1873 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  1874 |     | <span class='neutral'>        }</span>
  1875 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x64);</span>
  1876 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  1877 |     | <span class='neutral'>        assembly {</span>
  1878 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  1879 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  1880 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  1881 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  1882 |     | <span class='neutral'>        }</span>
  1883 |     | <span class='neutral'>    }</span>
  1884 |     | <span class='neutral'></span>
  1885 |     | <span class='neutral'>    function log(uint256 p0, bool p1, bool p2) internal pure {</span>
  1886 |     | <span class='neutral'>        bytes32 m0;</span>
  1887 |     | <span class='neutral'>        bytes32 m1;</span>
  1888 |     | <span class='neutral'>        bytes32 m2;</span>
  1889 |     | <span class='neutral'>        bytes32 m3;</span>
  1890 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  1891 |     | <span class='neutral'>        assembly {</span>
  1892 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  1893 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  1894 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  1895 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  1896 |     | <span class='neutral'>            // Selector of `log(uint256,bool,bool)`.</span>
  1897 |     | <span class='neutral'>            mstore(0x00, 0x20718650)</span>
  1898 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  1899 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  1900 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  1901 |     | <span class='neutral'>        }</span>
  1902 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x64);</span>
  1903 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  1904 |     | <span class='neutral'>        assembly {</span>
  1905 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  1906 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  1907 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  1908 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  1909 |     | <span class='neutral'>        }</span>
  1910 |     | <span class='neutral'>    }</span>
  1911 |     | <span class='neutral'></span>
  1912 |     | <span class='neutral'>    function log(uint256 p0, bool p1, uint256 p2) internal pure {</span>
  1913 |     | <span class='neutral'>        bytes32 m0;</span>
  1914 |     | <span class='neutral'>        bytes32 m1;</span>
  1915 |     | <span class='neutral'>        bytes32 m2;</span>
  1916 |     | <span class='neutral'>        bytes32 m3;</span>
  1917 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  1918 |     | <span class='neutral'>        assembly {</span>
  1919 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  1920 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  1921 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  1922 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  1923 |     | <span class='neutral'>            // Selector of `log(uint256,bool,uint256)`.</span>
  1924 |     | <span class='neutral'>            mstore(0x00, 0x20098014)</span>
  1925 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  1926 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  1927 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  1928 |     | <span class='neutral'>        }</span>
  1929 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x64);</span>
  1930 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  1931 |     | <span class='neutral'>        assembly {</span>
  1932 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  1933 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  1934 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  1935 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  1936 |     | <span class='neutral'>        }</span>
  1937 |     | <span class='neutral'>    }</span>
  1938 |     | <span class='neutral'></span>
  1939 |     | <span class='neutral'>    function log(uint256 p0, bool p1, bytes32 p2) internal pure {</span>
  1940 |     | <span class='neutral'>        bytes32 m0;</span>
  1941 |     | <span class='neutral'>        bytes32 m1;</span>
  1942 |     | <span class='neutral'>        bytes32 m2;</span>
  1943 |     | <span class='neutral'>        bytes32 m3;</span>
  1944 |     | <span class='neutral'>        bytes32 m4;</span>
  1945 |     | <span class='neutral'>        bytes32 m5;</span>
  1946 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  1947 |     | <span class='neutral'>        assembly {</span>
  1948 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  1949 |     | <span class='neutral'>                let length := 0</span>
  1950 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  1951 |     | <span class='neutral'>                mstore(pos, length)</span>
  1952 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  1953 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  1954 |     | <span class='neutral'>            }</span>
  1955 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  1956 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  1957 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  1958 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  1959 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  1960 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  1961 |     | <span class='neutral'>            // Selector of `log(uint256,bool,string)`.</span>
  1962 |     | <span class='neutral'>            mstore(0x00, 0x85775021)</span>
  1963 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  1964 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  1965 |     | <span class='neutral'>            mstore(0x60, 0x60)</span>
  1966 |     | <span class='neutral'>            writeString(0x80, p2)</span>
  1967 |     | <span class='neutral'>        }</span>
  1968 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xa4);</span>
  1969 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  1970 |     | <span class='neutral'>        assembly {</span>
  1971 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  1972 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  1973 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  1974 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  1975 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  1976 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  1977 |     | <span class='neutral'>        }</span>
  1978 |     | <span class='neutral'>    }</span>
  1979 |     | <span class='neutral'></span>
  1980 |     | <span class='neutral'>    function log(uint256 p0, uint256 p1, address p2) internal pure {</span>
  1981 |     | <span class='neutral'>        bytes32 m0;</span>
  1982 |     | <span class='neutral'>        bytes32 m1;</span>
  1983 |     | <span class='neutral'>        bytes32 m2;</span>
  1984 |     | <span class='neutral'>        bytes32 m3;</span>
  1985 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  1986 |     | <span class='neutral'>        assembly {</span>
  1987 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  1988 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  1989 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  1990 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  1991 |     | <span class='neutral'>            // Selector of `log(uint256,uint256,address)`.</span>
  1992 |     | <span class='neutral'>            mstore(0x00, 0x5c96b331)</span>
  1993 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  1994 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  1995 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  1996 |     | <span class='neutral'>        }</span>
  1997 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x64);</span>
  1998 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  1999 |     | <span class='neutral'>        assembly {</span>
  2000 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  2001 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  2002 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  2003 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  2004 |     | <span class='neutral'>        }</span>
  2005 |     | <span class='neutral'>    }</span>
  2006 |     | <span class='neutral'></span>
  2007 |     | <span class='neutral'>    function log(uint256 p0, uint256 p1, bool p2) internal pure {</span>
  2008 |     | <span class='neutral'>        bytes32 m0;</span>
  2009 |     | <span class='neutral'>        bytes32 m1;</span>
  2010 |     | <span class='neutral'>        bytes32 m2;</span>
  2011 |     | <span class='neutral'>        bytes32 m3;</span>
  2012 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  2013 |     | <span class='neutral'>        assembly {</span>
  2014 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  2015 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  2016 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  2017 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  2018 |     | <span class='neutral'>            // Selector of `log(uint256,uint256,bool)`.</span>
  2019 |     | <span class='neutral'>            mstore(0x00, 0x4766da72)</span>
  2020 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  2021 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  2022 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  2023 |     | <span class='neutral'>        }</span>
  2024 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x64);</span>
  2025 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  2026 |     | <span class='neutral'>        assembly {</span>
  2027 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  2028 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  2029 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  2030 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  2031 |     | <span class='neutral'>        }</span>
  2032 |     | <span class='neutral'>    }</span>
  2033 |     | <span class='neutral'></span>
  2034 |     | <span class='neutral'>    function log(uint256 p0, uint256 p1, uint256 p2) internal pure {</span>
  2035 |     | <span class='neutral'>        bytes32 m0;</span>
  2036 |     | <span class='neutral'>        bytes32 m1;</span>
  2037 |     | <span class='neutral'>        bytes32 m2;</span>
  2038 |     | <span class='neutral'>        bytes32 m3;</span>
  2039 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  2040 |     | <span class='neutral'>        assembly {</span>
  2041 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  2042 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  2043 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  2044 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  2045 |     | <span class='neutral'>            // Selector of `log(uint256,uint256,uint256)`.</span>
  2046 |     | <span class='neutral'>            mstore(0x00, 0xd1ed7a3c)</span>
  2047 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  2048 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  2049 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  2050 |     | <span class='neutral'>        }</span>
  2051 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x64);</span>
  2052 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  2053 |     | <span class='neutral'>        assembly {</span>
  2054 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  2055 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  2056 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  2057 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  2058 |     | <span class='neutral'>        }</span>
  2059 |     | <span class='neutral'>    }</span>
  2060 |     | <span class='neutral'></span>
  2061 |     | <span class='neutral'>    function log(uint256 p0, uint256 p1, bytes32 p2) internal pure {</span>
  2062 |     | <span class='neutral'>        bytes32 m0;</span>
  2063 |     | <span class='neutral'>        bytes32 m1;</span>
  2064 |     | <span class='neutral'>        bytes32 m2;</span>
  2065 |     | <span class='neutral'>        bytes32 m3;</span>
  2066 |     | <span class='neutral'>        bytes32 m4;</span>
  2067 |     | <span class='neutral'>        bytes32 m5;</span>
  2068 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  2069 |     | <span class='neutral'>        assembly {</span>
  2070 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  2071 |     | <span class='neutral'>                let length := 0</span>
  2072 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  2073 |     | <span class='neutral'>                mstore(pos, length)</span>
  2074 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  2075 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  2076 |     | <span class='neutral'>            }</span>
  2077 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  2078 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  2079 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  2080 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  2081 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  2082 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  2083 |     | <span class='neutral'>            // Selector of `log(uint256,uint256,string)`.</span>
  2084 |     | <span class='neutral'>            mstore(0x00, 0x71d04af2)</span>
  2085 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  2086 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  2087 |     | <span class='neutral'>            mstore(0x60, 0x60)</span>
  2088 |     | <span class='neutral'>            writeString(0x80, p2)</span>
  2089 |     | <span class='neutral'>        }</span>
  2090 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xa4);</span>
  2091 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  2092 |     | <span class='neutral'>        assembly {</span>
  2093 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  2094 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  2095 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  2096 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  2097 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  2098 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  2099 |     | <span class='neutral'>        }</span>
  2100 |     | <span class='neutral'>    }</span>
  2101 |     | <span class='neutral'></span>
  2102 |     | <span class='neutral'>    function log(uint256 p0, bytes32 p1, address p2) internal pure {</span>
  2103 |     | <span class='neutral'>        bytes32 m0;</span>
  2104 |     | <span class='neutral'>        bytes32 m1;</span>
  2105 |     | <span class='neutral'>        bytes32 m2;</span>
  2106 |     | <span class='neutral'>        bytes32 m3;</span>
  2107 |     | <span class='neutral'>        bytes32 m4;</span>
  2108 |     | <span class='neutral'>        bytes32 m5;</span>
  2109 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  2110 |     | <span class='neutral'>        assembly {</span>
  2111 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  2112 |     | <span class='neutral'>                let length := 0</span>
  2113 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  2114 |     | <span class='neutral'>                mstore(pos, length)</span>
  2115 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  2116 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  2117 |     | <span class='neutral'>            }</span>
  2118 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  2119 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  2120 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  2121 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  2122 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  2123 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  2124 |     | <span class='neutral'>            // Selector of `log(uint256,string,address)`.</span>
  2125 |     | <span class='neutral'>            mstore(0x00, 0x7afac959)</span>
  2126 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  2127 |     | <span class='neutral'>            mstore(0x40, 0x60)</span>
  2128 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  2129 |     | <span class='neutral'>            writeString(0x80, p1)</span>
  2130 |     | <span class='neutral'>        }</span>
  2131 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xa4);</span>
  2132 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  2133 |     | <span class='neutral'>        assembly {</span>
  2134 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  2135 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  2136 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  2137 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  2138 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  2139 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  2140 |     | <span class='neutral'>        }</span>
  2141 |     | <span class='neutral'>    }</span>
  2142 |     | <span class='neutral'></span>
  2143 |     | <span class='neutral'>    function log(uint256 p0, bytes32 p1, bool p2) internal pure {</span>
  2144 |     | <span class='neutral'>        bytes32 m0;</span>
  2145 |     | <span class='neutral'>        bytes32 m1;</span>
  2146 |     | <span class='neutral'>        bytes32 m2;</span>
  2147 |     | <span class='neutral'>        bytes32 m3;</span>
  2148 |     | <span class='neutral'>        bytes32 m4;</span>
  2149 |     | <span class='neutral'>        bytes32 m5;</span>
  2150 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  2151 |     | <span class='neutral'>        assembly {</span>
  2152 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  2153 |     | <span class='neutral'>                let length := 0</span>
  2154 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  2155 |     | <span class='neutral'>                mstore(pos, length)</span>
  2156 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  2157 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  2158 |     | <span class='neutral'>            }</span>
  2159 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  2160 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  2161 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  2162 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  2163 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  2164 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  2165 |     | <span class='neutral'>            // Selector of `log(uint256,string,bool)`.</span>
  2166 |     | <span class='neutral'>            mstore(0x00, 0x4ceda75a)</span>
  2167 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  2168 |     | <span class='neutral'>            mstore(0x40, 0x60)</span>
  2169 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  2170 |     | <span class='neutral'>            writeString(0x80, p1)</span>
  2171 |     | <span class='neutral'>        }</span>
  2172 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xa4);</span>
  2173 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  2174 |     | <span class='neutral'>        assembly {</span>
  2175 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  2176 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  2177 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  2178 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  2179 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  2180 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  2181 |     | <span class='neutral'>        }</span>
  2182 |     | <span class='neutral'>    }</span>
  2183 |     | <span class='neutral'></span>
  2184 |     | <span class='neutral'>    function log(uint256 p0, bytes32 p1, uint256 p2) internal pure {</span>
  2185 |     | <span class='neutral'>        bytes32 m0;</span>
  2186 |     | <span class='neutral'>        bytes32 m1;</span>
  2187 |     | <span class='neutral'>        bytes32 m2;</span>
  2188 |     | <span class='neutral'>        bytes32 m3;</span>
  2189 |     | <span class='neutral'>        bytes32 m4;</span>
  2190 |     | <span class='neutral'>        bytes32 m5;</span>
  2191 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  2192 |     | <span class='neutral'>        assembly {</span>
  2193 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  2194 |     | <span class='neutral'>                let length := 0</span>
  2195 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  2196 |     | <span class='neutral'>                mstore(pos, length)</span>
  2197 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  2198 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  2199 |     | <span class='neutral'>            }</span>
  2200 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  2201 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  2202 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  2203 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  2204 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  2205 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  2206 |     | <span class='neutral'>            // Selector of `log(uint256,string,uint256)`.</span>
  2207 |     | <span class='neutral'>            mstore(0x00, 0x37aa7d4c)</span>
  2208 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  2209 |     | <span class='neutral'>            mstore(0x40, 0x60)</span>
  2210 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  2211 |     | <span class='neutral'>            writeString(0x80, p1)</span>
  2212 |     | <span class='neutral'>        }</span>
  2213 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xa4);</span>
  2214 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  2215 |     | <span class='neutral'>        assembly {</span>
  2216 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  2217 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  2218 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  2219 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  2220 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  2221 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  2222 |     | <span class='neutral'>        }</span>
  2223 |     | <span class='neutral'>    }</span>
  2224 |     | <span class='neutral'></span>
  2225 |     | <span class='neutral'>    function log(uint256 p0, bytes32 p1, bytes32 p2) internal pure {</span>
  2226 |     | <span class='neutral'>        bytes32 m0;</span>
  2227 |     | <span class='neutral'>        bytes32 m1;</span>
  2228 |     | <span class='neutral'>        bytes32 m2;</span>
  2229 |     | <span class='neutral'>        bytes32 m3;</span>
  2230 |     | <span class='neutral'>        bytes32 m4;</span>
  2231 |     | <span class='neutral'>        bytes32 m5;</span>
  2232 |     | <span class='neutral'>        bytes32 m6;</span>
  2233 |     | <span class='neutral'>        bytes32 m7;</span>
  2234 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  2235 |     | <span class='neutral'>        assembly {</span>
  2236 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  2237 |     | <span class='neutral'>                let length := 0</span>
  2238 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  2239 |     | <span class='neutral'>                mstore(pos, length)</span>
  2240 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  2241 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  2242 |     | <span class='neutral'>            }</span>
  2243 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  2244 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  2245 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  2246 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  2247 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  2248 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  2249 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
  2250 |     | <span class='neutral'>            m7 := mload(0xe0)</span>
  2251 |     | <span class='neutral'>            // Selector of `log(uint256,string,string)`.</span>
  2252 |     | <span class='neutral'>            mstore(0x00, 0xb115611f)</span>
  2253 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  2254 |     | <span class='neutral'>            mstore(0x40, 0x60)</span>
  2255 |     | <span class='neutral'>            mstore(0x60, 0xa0)</span>
  2256 |     | <span class='neutral'>            writeString(0x80, p1)</span>
  2257 |     | <span class='neutral'>            writeString(0xc0, p2)</span>
  2258 |     | <span class='neutral'>        }</span>
  2259 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xe4);</span>
  2260 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  2261 |     | <span class='neutral'>        assembly {</span>
  2262 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  2263 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  2264 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  2265 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  2266 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  2267 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  2268 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
  2269 |     | <span class='neutral'>            mstore(0xe0, m7)</span>
  2270 |     | <span class='neutral'>        }</span>
  2271 |     | <span class='neutral'>    }</span>
  2272 |     | <span class='neutral'></span>
  2273 |     | <span class='neutral'>    function log(bytes32 p0, address p1, address p2) internal pure {</span>
  2274 |     | <span class='neutral'>        bytes32 m0;</span>
  2275 |     | <span class='neutral'>        bytes32 m1;</span>
  2276 |     | <span class='neutral'>        bytes32 m2;</span>
  2277 |     | <span class='neutral'>        bytes32 m3;</span>
  2278 |     | <span class='neutral'>        bytes32 m4;</span>
  2279 |     | <span class='neutral'>        bytes32 m5;</span>
  2280 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  2281 |     | <span class='neutral'>        assembly {</span>
  2282 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  2283 |     | <span class='neutral'>                let length := 0</span>
  2284 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  2285 |     | <span class='neutral'>                mstore(pos, length)</span>
  2286 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  2287 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  2288 |     | <span class='neutral'>            }</span>
  2289 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  2290 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  2291 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  2292 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  2293 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  2294 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  2295 |     | <span class='neutral'>            // Selector of `log(string,address,address)`.</span>
  2296 |     | <span class='neutral'>            mstore(0x00, 0xfcec75e0)</span>
  2297 |     | <span class='neutral'>            mstore(0x20, 0x60)</span>
  2298 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  2299 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  2300 |     | <span class='neutral'>            writeString(0x80, p0)</span>
  2301 |     | <span class='neutral'>        }</span>
  2302 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xa4);</span>
  2303 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  2304 |     | <span class='neutral'>        assembly {</span>
  2305 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  2306 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  2307 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  2308 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  2309 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  2310 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  2311 |     | <span class='neutral'>        }</span>
  2312 |     | <span class='neutral'>    }</span>
  2313 |     | <span class='neutral'></span>
  2314 |     | <span class='neutral'>    function log(bytes32 p0, address p1, bool p2) internal pure {</span>
  2315 |     | <span class='neutral'>        bytes32 m0;</span>
  2316 |     | <span class='neutral'>        bytes32 m1;</span>
  2317 |     | <span class='neutral'>        bytes32 m2;</span>
  2318 |     | <span class='neutral'>        bytes32 m3;</span>
  2319 |     | <span class='neutral'>        bytes32 m4;</span>
  2320 |     | <span class='neutral'>        bytes32 m5;</span>
  2321 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  2322 |     | <span class='neutral'>        assembly {</span>
  2323 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  2324 |     | <span class='neutral'>                let length := 0</span>
  2325 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  2326 |     | <span class='neutral'>                mstore(pos, length)</span>
  2327 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  2328 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  2329 |     | <span class='neutral'>            }</span>
  2330 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  2331 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  2332 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  2333 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  2334 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  2335 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  2336 |     | <span class='neutral'>            // Selector of `log(string,address,bool)`.</span>
  2337 |     | <span class='neutral'>            mstore(0x00, 0xc91d5ed4)</span>
  2338 |     | <span class='neutral'>            mstore(0x20, 0x60)</span>
  2339 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  2340 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  2341 |     | <span class='neutral'>            writeString(0x80, p0)</span>
  2342 |     | <span class='neutral'>        }</span>
  2343 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xa4);</span>
  2344 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  2345 |     | <span class='neutral'>        assembly {</span>
  2346 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  2347 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  2348 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  2349 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  2350 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  2351 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  2352 |     | <span class='neutral'>        }</span>
  2353 |     | <span class='neutral'>    }</span>
  2354 |     | <span class='neutral'></span>
  2355 |     | <span class='neutral'>    function log(bytes32 p0, address p1, uint256 p2) internal pure {</span>
  2356 |     | <span class='neutral'>        bytes32 m0;</span>
  2357 |     | <span class='neutral'>        bytes32 m1;</span>
  2358 |     | <span class='neutral'>        bytes32 m2;</span>
  2359 |     | <span class='neutral'>        bytes32 m3;</span>
  2360 |     | <span class='neutral'>        bytes32 m4;</span>
  2361 |     | <span class='neutral'>        bytes32 m5;</span>
  2362 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  2363 |     | <span class='neutral'>        assembly {</span>
  2364 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  2365 |     | <span class='neutral'>                let length := 0</span>
  2366 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  2367 |     | <span class='neutral'>                mstore(pos, length)</span>
  2368 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  2369 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  2370 |     | <span class='neutral'>            }</span>
  2371 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  2372 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  2373 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  2374 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  2375 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  2376 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  2377 |     | <span class='neutral'>            // Selector of `log(string,address,uint256)`.</span>
  2378 |     | <span class='neutral'>            mstore(0x00, 0x0d26b925)</span>
  2379 |     | <span class='neutral'>            mstore(0x20, 0x60)</span>
  2380 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  2381 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  2382 |     | <span class='neutral'>            writeString(0x80, p0)</span>
  2383 |     | <span class='neutral'>        }</span>
  2384 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xa4);</span>
  2385 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  2386 |     | <span class='neutral'>        assembly {</span>
  2387 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  2388 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  2389 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  2390 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  2391 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  2392 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  2393 |     | <span class='neutral'>        }</span>
  2394 |     | <span class='neutral'>    }</span>
  2395 |     | <span class='neutral'></span>
  2396 |     | <span class='neutral'>    function log(bytes32 p0, address p1, bytes32 p2) internal pure {</span>
  2397 |     | <span class='neutral'>        bytes32 m0;</span>
  2398 |     | <span class='neutral'>        bytes32 m1;</span>
  2399 |     | <span class='neutral'>        bytes32 m2;</span>
  2400 |     | <span class='neutral'>        bytes32 m3;</span>
  2401 |     | <span class='neutral'>        bytes32 m4;</span>
  2402 |     | <span class='neutral'>        bytes32 m5;</span>
  2403 |     | <span class='neutral'>        bytes32 m6;</span>
  2404 |     | <span class='neutral'>        bytes32 m7;</span>
  2405 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  2406 |     | <span class='neutral'>        assembly {</span>
  2407 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  2408 |     | <span class='neutral'>                let length := 0</span>
  2409 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  2410 |     | <span class='neutral'>                mstore(pos, length)</span>
  2411 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  2412 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  2413 |     | <span class='neutral'>            }</span>
  2414 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  2415 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  2416 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  2417 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  2418 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  2419 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  2420 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
  2421 |     | <span class='neutral'>            m7 := mload(0xe0)</span>
  2422 |     | <span class='neutral'>            // Selector of `log(string,address,string)`.</span>
  2423 |     | <span class='neutral'>            mstore(0x00, 0xe0e9ad4f)</span>
  2424 |     | <span class='neutral'>            mstore(0x20, 0x60)</span>
  2425 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  2426 |     | <span class='neutral'>            mstore(0x60, 0xa0)</span>
  2427 |     | <span class='neutral'>            writeString(0x80, p0)</span>
  2428 |     | <span class='neutral'>            writeString(0xc0, p2)</span>
  2429 |     | <span class='neutral'>        }</span>
  2430 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xe4);</span>
  2431 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  2432 |     | <span class='neutral'>        assembly {</span>
  2433 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  2434 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  2435 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  2436 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  2437 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  2438 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  2439 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
  2440 |     | <span class='neutral'>            mstore(0xe0, m7)</span>
  2441 |     | <span class='neutral'>        }</span>
  2442 |     | <span class='neutral'>    }</span>
  2443 |     | <span class='neutral'></span>
  2444 |     | <span class='neutral'>    function log(bytes32 p0, bool p1, address p2) internal pure {</span>
  2445 |     | <span class='neutral'>        bytes32 m0;</span>
  2446 |     | <span class='neutral'>        bytes32 m1;</span>
  2447 |     | <span class='neutral'>        bytes32 m2;</span>
  2448 |     | <span class='neutral'>        bytes32 m3;</span>
  2449 |     | <span class='neutral'>        bytes32 m4;</span>
  2450 |     | <span class='neutral'>        bytes32 m5;</span>
  2451 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  2452 |     | <span class='neutral'>        assembly {</span>
  2453 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  2454 |     | <span class='neutral'>                let length := 0</span>
  2455 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  2456 |     | <span class='neutral'>                mstore(pos, length)</span>
  2457 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  2458 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  2459 |     | <span class='neutral'>            }</span>
  2460 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  2461 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  2462 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  2463 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  2464 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  2465 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  2466 |     | <span class='neutral'>            // Selector of `log(string,bool,address)`.</span>
  2467 |     | <span class='neutral'>            mstore(0x00, 0x932bbb38)</span>
  2468 |     | <span class='neutral'>            mstore(0x20, 0x60)</span>
  2469 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  2470 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  2471 |     | <span class='neutral'>            writeString(0x80, p0)</span>
  2472 |     | <span class='neutral'>        }</span>
  2473 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xa4);</span>
  2474 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  2475 |     | <span class='neutral'>        assembly {</span>
  2476 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  2477 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  2478 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  2479 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  2480 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  2481 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  2482 |     | <span class='neutral'>        }</span>
  2483 |     | <span class='neutral'>    }</span>
  2484 |     | <span class='neutral'></span>
  2485 |     | <span class='neutral'>    function log(bytes32 p0, bool p1, bool p2) internal pure {</span>
  2486 |     | <span class='neutral'>        bytes32 m0;</span>
  2487 |     | <span class='neutral'>        bytes32 m1;</span>
  2488 |     | <span class='neutral'>        bytes32 m2;</span>
  2489 |     | <span class='neutral'>        bytes32 m3;</span>
  2490 |     | <span class='neutral'>        bytes32 m4;</span>
  2491 |     | <span class='neutral'>        bytes32 m5;</span>
  2492 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  2493 |     | <span class='neutral'>        assembly {</span>
  2494 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  2495 |     | <span class='neutral'>                let length := 0</span>
  2496 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  2497 |     | <span class='neutral'>                mstore(pos, length)</span>
  2498 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  2499 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  2500 |     | <span class='neutral'>            }</span>
  2501 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  2502 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  2503 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  2504 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  2505 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  2506 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  2507 |     | <span class='neutral'>            // Selector of `log(string,bool,bool)`.</span>
  2508 |     | <span class='neutral'>            mstore(0x00, 0x850b7ad6)</span>
  2509 |     | <span class='neutral'>            mstore(0x20, 0x60)</span>
  2510 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  2511 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  2512 |     | <span class='neutral'>            writeString(0x80, p0)</span>
  2513 |     | <span class='neutral'>        }</span>
  2514 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xa4);</span>
  2515 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  2516 |     | <span class='neutral'>        assembly {</span>
  2517 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  2518 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  2519 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  2520 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  2521 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  2522 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  2523 |     | <span class='neutral'>        }</span>
  2524 |     | <span class='neutral'>    }</span>
  2525 |     | <span class='neutral'></span>
  2526 |     | <span class='neutral'>    function log(bytes32 p0, bool p1, uint256 p2) internal pure {</span>
  2527 |     | <span class='neutral'>        bytes32 m0;</span>
  2528 |     | <span class='neutral'>        bytes32 m1;</span>
  2529 |     | <span class='neutral'>        bytes32 m2;</span>
  2530 |     | <span class='neutral'>        bytes32 m3;</span>
  2531 |     | <span class='neutral'>        bytes32 m4;</span>
  2532 |     | <span class='neutral'>        bytes32 m5;</span>
  2533 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  2534 |     | <span class='neutral'>        assembly {</span>
  2535 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  2536 |     | <span class='neutral'>                let length := 0</span>
  2537 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  2538 |     | <span class='neutral'>                mstore(pos, length)</span>
  2539 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  2540 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  2541 |     | <span class='neutral'>            }</span>
  2542 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  2543 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  2544 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  2545 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  2546 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  2547 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  2548 |     | <span class='neutral'>            // Selector of `log(string,bool,uint256)`.</span>
  2549 |     | <span class='neutral'>            mstore(0x00, 0xc95958d6)</span>
  2550 |     | <span class='neutral'>            mstore(0x20, 0x60)</span>
  2551 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  2552 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  2553 |     | <span class='neutral'>            writeString(0x80, p0)</span>
  2554 |     | <span class='neutral'>        }</span>
  2555 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xa4);</span>
  2556 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  2557 |     | <span class='neutral'>        assembly {</span>
  2558 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  2559 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  2560 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  2561 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  2562 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  2563 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  2564 |     | <span class='neutral'>        }</span>
  2565 |     | <span class='neutral'>    }</span>
  2566 |     | <span class='neutral'></span>
  2567 |     | <span class='neutral'>    function log(bytes32 p0, bool p1, bytes32 p2) internal pure {</span>
  2568 |     | <span class='neutral'>        bytes32 m0;</span>
  2569 |     | <span class='neutral'>        bytes32 m1;</span>
  2570 |     | <span class='neutral'>        bytes32 m2;</span>
  2571 |     | <span class='neutral'>        bytes32 m3;</span>
  2572 |     | <span class='neutral'>        bytes32 m4;</span>
  2573 |     | <span class='neutral'>        bytes32 m5;</span>
  2574 |     | <span class='neutral'>        bytes32 m6;</span>
  2575 |     | <span class='neutral'>        bytes32 m7;</span>
  2576 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  2577 |     | <span class='neutral'>        assembly {</span>
  2578 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  2579 |     | <span class='neutral'>                let length := 0</span>
  2580 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  2581 |     | <span class='neutral'>                mstore(pos, length)</span>
  2582 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  2583 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  2584 |     | <span class='neutral'>            }</span>
  2585 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  2586 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  2587 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  2588 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  2589 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  2590 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  2591 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
  2592 |     | <span class='neutral'>            m7 := mload(0xe0)</span>
  2593 |     | <span class='neutral'>            // Selector of `log(string,bool,string)`.</span>
  2594 |     | <span class='neutral'>            mstore(0x00, 0xe298f47d)</span>
  2595 |     | <span class='neutral'>            mstore(0x20, 0x60)</span>
  2596 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  2597 |     | <span class='neutral'>            mstore(0x60, 0xa0)</span>
  2598 |     | <span class='neutral'>            writeString(0x80, p0)</span>
  2599 |     | <span class='neutral'>            writeString(0xc0, p2)</span>
  2600 |     | <span class='neutral'>        }</span>
  2601 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xe4);</span>
  2602 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  2603 |     | <span class='neutral'>        assembly {</span>
  2604 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  2605 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  2606 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  2607 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  2608 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  2609 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  2610 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
  2611 |     | <span class='neutral'>            mstore(0xe0, m7)</span>
  2612 |     | <span class='neutral'>        }</span>
  2613 |     | <span class='neutral'>    }</span>
  2614 |     | <span class='neutral'></span>
  2615 |     | <span class='neutral'>    function log(bytes32 p0, uint256 p1, address p2) internal pure {</span>
  2616 |     | <span class='neutral'>        bytes32 m0;</span>
  2617 |     | <span class='neutral'>        bytes32 m1;</span>
  2618 |     | <span class='neutral'>        bytes32 m2;</span>
  2619 |     | <span class='neutral'>        bytes32 m3;</span>
  2620 |     | <span class='neutral'>        bytes32 m4;</span>
  2621 |     | <span class='neutral'>        bytes32 m5;</span>
  2622 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  2623 |     | <span class='neutral'>        assembly {</span>
  2624 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  2625 |     | <span class='neutral'>                let length := 0</span>
  2626 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  2627 |     | <span class='neutral'>                mstore(pos, length)</span>
  2628 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  2629 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  2630 |     | <span class='neutral'>            }</span>
  2631 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  2632 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  2633 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  2634 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  2635 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  2636 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  2637 |     | <span class='neutral'>            // Selector of `log(string,uint256,address)`.</span>
  2638 |     | <span class='neutral'>            mstore(0x00, 0x1c7ec448)</span>
  2639 |     | <span class='neutral'>            mstore(0x20, 0x60)</span>
  2640 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  2641 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  2642 |     | <span class='neutral'>            writeString(0x80, p0)</span>
  2643 |     | <span class='neutral'>        }</span>
  2644 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xa4);</span>
  2645 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  2646 |     | <span class='neutral'>        assembly {</span>
  2647 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  2648 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  2649 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  2650 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  2651 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  2652 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  2653 |     | <span class='neutral'>        }</span>
  2654 |     | <span class='neutral'>    }</span>
  2655 |     | <span class='neutral'></span>
  2656 |     | <span class='neutral'>    function log(bytes32 p0, uint256 p1, bool p2) internal pure {</span>
  2657 |     | <span class='neutral'>        bytes32 m0;</span>
  2658 |     | <span class='neutral'>        bytes32 m1;</span>
  2659 |     | <span class='neutral'>        bytes32 m2;</span>
  2660 |     | <span class='neutral'>        bytes32 m3;</span>
  2661 |     | <span class='neutral'>        bytes32 m4;</span>
  2662 |     | <span class='neutral'>        bytes32 m5;</span>
  2663 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  2664 |     | <span class='neutral'>        assembly {</span>
  2665 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  2666 |     | <span class='neutral'>                let length := 0</span>
  2667 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  2668 |     | <span class='neutral'>                mstore(pos, length)</span>
  2669 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  2670 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  2671 |     | <span class='neutral'>            }</span>
  2672 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  2673 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  2674 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  2675 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  2676 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  2677 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  2678 |     | <span class='neutral'>            // Selector of `log(string,uint256,bool)`.</span>
  2679 |     | <span class='neutral'>            mstore(0x00, 0xca7733b1)</span>
  2680 |     | <span class='neutral'>            mstore(0x20, 0x60)</span>
  2681 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  2682 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  2683 |     | <span class='neutral'>            writeString(0x80, p0)</span>
  2684 |     | <span class='neutral'>        }</span>
  2685 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xa4);</span>
  2686 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  2687 |     | <span class='neutral'>        assembly {</span>
  2688 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  2689 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  2690 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  2691 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  2692 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  2693 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  2694 |     | <span class='neutral'>        }</span>
  2695 |     | <span class='neutral'>    }</span>
  2696 |     | <span class='neutral'></span>
  2697 |     | <span class='neutral'>    function log(bytes32 p0, uint256 p1, uint256 p2) internal pure {</span>
  2698 |     | <span class='neutral'>        bytes32 m0;</span>
  2699 |     | <span class='neutral'>        bytes32 m1;</span>
  2700 |     | <span class='neutral'>        bytes32 m2;</span>
  2701 |     | <span class='neutral'>        bytes32 m3;</span>
  2702 |     | <span class='neutral'>        bytes32 m4;</span>
  2703 |     | <span class='neutral'>        bytes32 m5;</span>
  2704 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  2705 |     | <span class='neutral'>        assembly {</span>
  2706 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  2707 |     | <span class='neutral'>                let length := 0</span>
  2708 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  2709 |     | <span class='neutral'>                mstore(pos, length)</span>
  2710 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  2711 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  2712 |     | <span class='neutral'>            }</span>
  2713 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  2714 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  2715 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  2716 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  2717 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  2718 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  2719 |     | <span class='neutral'>            // Selector of `log(string,uint256,uint256)`.</span>
  2720 |     | <span class='neutral'>            mstore(0x00, 0xca47c4eb)</span>
  2721 |     | <span class='neutral'>            mstore(0x20, 0x60)</span>
  2722 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  2723 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  2724 |     | <span class='neutral'>            writeString(0x80, p0)</span>
  2725 |     | <span class='neutral'>        }</span>
  2726 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xa4);</span>
  2727 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  2728 |     | <span class='neutral'>        assembly {</span>
  2729 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  2730 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  2731 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  2732 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  2733 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  2734 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  2735 |     | <span class='neutral'>        }</span>
  2736 |     | <span class='neutral'>    }</span>
  2737 |     | <span class='neutral'></span>
  2738 |     | <span class='neutral'>    function log(bytes32 p0, uint256 p1, bytes32 p2) internal pure {</span>
  2739 |     | <span class='neutral'>        bytes32 m0;</span>
  2740 |     | <span class='neutral'>        bytes32 m1;</span>
  2741 |     | <span class='neutral'>        bytes32 m2;</span>
  2742 |     | <span class='neutral'>        bytes32 m3;</span>
  2743 |     | <span class='neutral'>        bytes32 m4;</span>
  2744 |     | <span class='neutral'>        bytes32 m5;</span>
  2745 |     | <span class='neutral'>        bytes32 m6;</span>
  2746 |     | <span class='neutral'>        bytes32 m7;</span>
  2747 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  2748 |     | <span class='neutral'>        assembly {</span>
  2749 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  2750 |     | <span class='neutral'>                let length := 0</span>
  2751 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  2752 |     | <span class='neutral'>                mstore(pos, length)</span>
  2753 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  2754 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  2755 |     | <span class='neutral'>            }</span>
  2756 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  2757 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  2758 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  2759 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  2760 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  2761 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  2762 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
  2763 |     | <span class='neutral'>            m7 := mload(0xe0)</span>
  2764 |     | <span class='neutral'>            // Selector of `log(string,uint256,string)`.</span>
  2765 |     | <span class='neutral'>            mstore(0x00, 0x5970e089)</span>
  2766 |     | <span class='neutral'>            mstore(0x20, 0x60)</span>
  2767 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  2768 |     | <span class='neutral'>            mstore(0x60, 0xa0)</span>
  2769 |     | <span class='neutral'>            writeString(0x80, p0)</span>
  2770 |     | <span class='neutral'>            writeString(0xc0, p2)</span>
  2771 |     | <span class='neutral'>        }</span>
  2772 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xe4);</span>
  2773 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  2774 |     | <span class='neutral'>        assembly {</span>
  2775 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  2776 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  2777 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  2778 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  2779 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  2780 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  2781 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
  2782 |     | <span class='neutral'>            mstore(0xe0, m7)</span>
  2783 |     | <span class='neutral'>        }</span>
  2784 |     | <span class='neutral'>    }</span>
  2785 |     | <span class='neutral'></span>
  2786 |     | <span class='neutral'>    function log(bytes32 p0, bytes32 p1, address p2) internal pure {</span>
  2787 |     | <span class='neutral'>        bytes32 m0;</span>
  2788 |     | <span class='neutral'>        bytes32 m1;</span>
  2789 |     | <span class='neutral'>        bytes32 m2;</span>
  2790 |     | <span class='neutral'>        bytes32 m3;</span>
  2791 |     | <span class='neutral'>        bytes32 m4;</span>
  2792 |     | <span class='neutral'>        bytes32 m5;</span>
  2793 |     | <span class='neutral'>        bytes32 m6;</span>
  2794 |     | <span class='neutral'>        bytes32 m7;</span>
  2795 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  2796 |     | <span class='neutral'>        assembly {</span>
  2797 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  2798 |     | <span class='neutral'>                let length := 0</span>
  2799 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  2800 |     | <span class='neutral'>                mstore(pos, length)</span>
  2801 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  2802 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  2803 |     | <span class='neutral'>            }</span>
  2804 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  2805 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  2806 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  2807 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  2808 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  2809 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  2810 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
  2811 |     | <span class='neutral'>            m7 := mload(0xe0)</span>
  2812 |     | <span class='neutral'>            // Selector of `log(string,string,address)`.</span>
  2813 |     | <span class='neutral'>            mstore(0x00, 0x95ed0195)</span>
  2814 |     | <span class='neutral'>            mstore(0x20, 0x60)</span>
  2815 |     | <span class='neutral'>            mstore(0x40, 0xa0)</span>
  2816 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  2817 |     | <span class='neutral'>            writeString(0x80, p0)</span>
  2818 |     | <span class='neutral'>            writeString(0xc0, p1)</span>
  2819 |     | <span class='neutral'>        }</span>
  2820 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xe4);</span>
  2821 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  2822 |     | <span class='neutral'>        assembly {</span>
  2823 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  2824 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  2825 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  2826 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  2827 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  2828 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  2829 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
  2830 |     | <span class='neutral'>            mstore(0xe0, m7)</span>
  2831 |     | <span class='neutral'>        }</span>
  2832 |     | <span class='neutral'>    }</span>
  2833 |     | <span class='neutral'></span>
  2834 |     | <span class='neutral'>    function log(bytes32 p0, bytes32 p1, bool p2) internal pure {</span>
  2835 |     | <span class='neutral'>        bytes32 m0;</span>
  2836 |     | <span class='neutral'>        bytes32 m1;</span>
  2837 |     | <span class='neutral'>        bytes32 m2;</span>
  2838 |     | <span class='neutral'>        bytes32 m3;</span>
  2839 |     | <span class='neutral'>        bytes32 m4;</span>
  2840 |     | <span class='neutral'>        bytes32 m5;</span>
  2841 |     | <span class='neutral'>        bytes32 m6;</span>
  2842 |     | <span class='neutral'>        bytes32 m7;</span>
  2843 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  2844 |     | <span class='neutral'>        assembly {</span>
  2845 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  2846 |     | <span class='neutral'>                let length := 0</span>
  2847 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  2848 |     | <span class='neutral'>                mstore(pos, length)</span>
  2849 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  2850 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  2851 |     | <span class='neutral'>            }</span>
  2852 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  2853 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  2854 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  2855 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  2856 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  2857 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  2858 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
  2859 |     | <span class='neutral'>            m7 := mload(0xe0)</span>
  2860 |     | <span class='neutral'>            // Selector of `log(string,string,bool)`.</span>
  2861 |     | <span class='neutral'>            mstore(0x00, 0xb0e0f9b5)</span>
  2862 |     | <span class='neutral'>            mstore(0x20, 0x60)</span>
  2863 |     | <span class='neutral'>            mstore(0x40, 0xa0)</span>
  2864 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  2865 |     | <span class='neutral'>            writeString(0x80, p0)</span>
  2866 |     | <span class='neutral'>            writeString(0xc0, p1)</span>
  2867 |     | <span class='neutral'>        }</span>
  2868 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xe4);</span>
  2869 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  2870 |     | <span class='neutral'>        assembly {</span>
  2871 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  2872 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  2873 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  2874 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  2875 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  2876 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  2877 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
  2878 |     | <span class='neutral'>            mstore(0xe0, m7)</span>
  2879 |     | <span class='neutral'>        }</span>
  2880 |     | <span class='neutral'>    }</span>
  2881 |     | <span class='neutral'></span>
  2882 |     | <span class='neutral'>    function log(bytes32 p0, bytes32 p1, uint256 p2) internal pure {</span>
  2883 |     | <span class='neutral'>        bytes32 m0;</span>
  2884 |     | <span class='neutral'>        bytes32 m1;</span>
  2885 |     | <span class='neutral'>        bytes32 m2;</span>
  2886 |     | <span class='neutral'>        bytes32 m3;</span>
  2887 |     | <span class='neutral'>        bytes32 m4;</span>
  2888 |     | <span class='neutral'>        bytes32 m5;</span>
  2889 |     | <span class='neutral'>        bytes32 m6;</span>
  2890 |     | <span class='neutral'>        bytes32 m7;</span>
  2891 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  2892 |     | <span class='neutral'>        assembly {</span>
  2893 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  2894 |     | <span class='neutral'>                let length := 0</span>
  2895 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  2896 |     | <span class='neutral'>                mstore(pos, length)</span>
  2897 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  2898 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  2899 |     | <span class='neutral'>            }</span>
  2900 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  2901 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  2902 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  2903 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  2904 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  2905 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  2906 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
  2907 |     | <span class='neutral'>            m7 := mload(0xe0)</span>
  2908 |     | <span class='neutral'>            // Selector of `log(string,string,uint256)`.</span>
  2909 |     | <span class='neutral'>            mstore(0x00, 0x5821efa1)</span>
  2910 |     | <span class='neutral'>            mstore(0x20, 0x60)</span>
  2911 |     | <span class='neutral'>            mstore(0x40, 0xa0)</span>
  2912 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  2913 |     | <span class='neutral'>            writeString(0x80, p0)</span>
  2914 |     | <span class='neutral'>            writeString(0xc0, p1)</span>
  2915 |     | <span class='neutral'>        }</span>
  2916 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xe4);</span>
  2917 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  2918 |     | <span class='neutral'>        assembly {</span>
  2919 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  2920 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  2921 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  2922 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  2923 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  2924 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  2925 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
  2926 |     | <span class='neutral'>            mstore(0xe0, m7)</span>
  2927 |     | <span class='neutral'>        }</span>
  2928 |     | <span class='neutral'>    }</span>
  2929 |     | <span class='neutral'></span>
  2930 |     | <span class='neutral'>    function log(bytes32 p0, bytes32 p1, bytes32 p2) internal pure {</span>
  2931 |     | <span class='neutral'>        bytes32 m0;</span>
  2932 |     | <span class='neutral'>        bytes32 m1;</span>
  2933 |     | <span class='neutral'>        bytes32 m2;</span>
  2934 |     | <span class='neutral'>        bytes32 m3;</span>
  2935 |     | <span class='neutral'>        bytes32 m4;</span>
  2936 |     | <span class='neutral'>        bytes32 m5;</span>
  2937 |     | <span class='neutral'>        bytes32 m6;</span>
  2938 |     | <span class='neutral'>        bytes32 m7;</span>
  2939 |     | <span class='neutral'>        bytes32 m8;</span>
  2940 |     | <span class='neutral'>        bytes32 m9;</span>
  2941 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  2942 |     | <span class='neutral'>        assembly {</span>
  2943 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  2944 |     | <span class='neutral'>                let length := 0</span>
  2945 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  2946 |     | <span class='neutral'>                mstore(pos, length)</span>
  2947 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  2948 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  2949 |     | <span class='neutral'>            }</span>
  2950 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  2951 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  2952 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  2953 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  2954 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  2955 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  2956 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
  2957 |     | <span class='neutral'>            m7 := mload(0xe0)</span>
  2958 |     | <span class='neutral'>            m8 := mload(0x100)</span>
  2959 |     | <span class='neutral'>            m9 := mload(0x120)</span>
  2960 |     | <span class='neutral'>            // Selector of `log(string,string,string)`.</span>
  2961 |     | <span class='neutral'>            mstore(0x00, 0x2ced7cef)</span>
  2962 |     | <span class='neutral'>            mstore(0x20, 0x60)</span>
  2963 |     | <span class='neutral'>            mstore(0x40, 0xa0)</span>
  2964 |     | <span class='neutral'>            mstore(0x60, 0xe0)</span>
  2965 |     | <span class='neutral'>            writeString(0x80, p0)</span>
  2966 |     | <span class='neutral'>            writeString(0xc0, p1)</span>
  2967 |     | <span class='neutral'>            writeString(0x100, p2)</span>
  2968 |     | <span class='neutral'>        }</span>
  2969 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x124);</span>
  2970 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  2971 |     | <span class='neutral'>        assembly {</span>
  2972 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  2973 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  2974 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  2975 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  2976 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  2977 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  2978 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
  2979 |     | <span class='neutral'>            mstore(0xe0, m7)</span>
  2980 |     | <span class='neutral'>            mstore(0x100, m8)</span>
  2981 |     | <span class='neutral'>            mstore(0x120, m9)</span>
  2982 |     | <span class='neutral'>        }</span>
  2983 |     | <span class='neutral'>    }</span>
  2984 |     | <span class='neutral'></span>
  2985 |     | <span class='neutral'>    function log(address p0, address p1, address p2, address p3) internal pure {</span>
  2986 |     | <span class='neutral'>        bytes32 m0;</span>
  2987 |     | <span class='neutral'>        bytes32 m1;</span>
  2988 |     | <span class='neutral'>        bytes32 m2;</span>
  2989 |     | <span class='neutral'>        bytes32 m3;</span>
  2990 |     | <span class='neutral'>        bytes32 m4;</span>
  2991 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  2992 |     | <span class='neutral'>        assembly {</span>
  2993 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  2994 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  2995 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  2996 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  2997 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  2998 |     | <span class='neutral'>            // Selector of `log(address,address,address,address)`.</span>
  2999 |     | <span class='neutral'>            mstore(0x00, 0x665bf134)</span>
  3000 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  3001 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  3002 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  3003 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  3004 |     | <span class='neutral'>        }</span>
  3005 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x84);</span>
  3006 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  3007 |     | <span class='neutral'>        assembly {</span>
  3008 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  3009 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  3010 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  3011 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  3012 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  3013 |     | <span class='neutral'>        }</span>
  3014 |     | <span class='neutral'>    }</span>
  3015 |     | <span class='neutral'></span>
  3016 |     | <span class='neutral'>    function log(address p0, address p1, address p2, bool p3) internal pure {</span>
  3017 |     | <span class='neutral'>        bytes32 m0;</span>
  3018 |     | <span class='neutral'>        bytes32 m1;</span>
  3019 |     | <span class='neutral'>        bytes32 m2;</span>
  3020 |     | <span class='neutral'>        bytes32 m3;</span>
  3021 |     | <span class='neutral'>        bytes32 m4;</span>
  3022 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  3023 |     | <span class='neutral'>        assembly {</span>
  3024 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  3025 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  3026 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  3027 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  3028 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  3029 |     | <span class='neutral'>            // Selector of `log(address,address,address,bool)`.</span>
  3030 |     | <span class='neutral'>            mstore(0x00, 0x0e378994)</span>
  3031 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  3032 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  3033 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  3034 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  3035 |     | <span class='neutral'>        }</span>
  3036 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x84);</span>
  3037 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  3038 |     | <span class='neutral'>        assembly {</span>
  3039 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  3040 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  3041 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  3042 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  3043 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  3044 |     | <span class='neutral'>        }</span>
  3045 |     | <span class='neutral'>    }</span>
  3046 |     | <span class='neutral'></span>
  3047 |     | <span class='neutral'>    function log(address p0, address p1, address p2, uint256 p3) internal pure {</span>
  3048 |     | <span class='neutral'>        bytes32 m0;</span>
  3049 |     | <span class='neutral'>        bytes32 m1;</span>
  3050 |     | <span class='neutral'>        bytes32 m2;</span>
  3051 |     | <span class='neutral'>        bytes32 m3;</span>
  3052 |     | <span class='neutral'>        bytes32 m4;</span>
  3053 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  3054 |     | <span class='neutral'>        assembly {</span>
  3055 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  3056 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  3057 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  3058 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  3059 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  3060 |     | <span class='neutral'>            // Selector of `log(address,address,address,uint256)`.</span>
  3061 |     | <span class='neutral'>            mstore(0x00, 0x94250d77)</span>
  3062 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  3063 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  3064 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  3065 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  3066 |     | <span class='neutral'>        }</span>
  3067 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x84);</span>
  3068 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  3069 |     | <span class='neutral'>        assembly {</span>
  3070 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  3071 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  3072 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  3073 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  3074 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  3075 |     | <span class='neutral'>        }</span>
  3076 |     | <span class='neutral'>    }</span>
  3077 |     | <span class='neutral'></span>
  3078 |     | <span class='neutral'>    function log(address p0, address p1, address p2, bytes32 p3) internal pure {</span>
  3079 |     | <span class='neutral'>        bytes32 m0;</span>
  3080 |     | <span class='neutral'>        bytes32 m1;</span>
  3081 |     | <span class='neutral'>        bytes32 m2;</span>
  3082 |     | <span class='neutral'>        bytes32 m3;</span>
  3083 |     | <span class='neutral'>        bytes32 m4;</span>
  3084 |     | <span class='neutral'>        bytes32 m5;</span>
  3085 |     | <span class='neutral'>        bytes32 m6;</span>
  3086 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  3087 |     | <span class='neutral'>        assembly {</span>
  3088 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  3089 |     | <span class='neutral'>                let length := 0</span>
  3090 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  3091 |     | <span class='neutral'>                mstore(pos, length)</span>
  3092 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  3093 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  3094 |     | <span class='neutral'>            }</span>
  3095 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  3096 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  3097 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  3098 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  3099 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  3100 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  3101 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
  3102 |     | <span class='neutral'>            // Selector of `log(address,address,address,string)`.</span>
  3103 |     | <span class='neutral'>            mstore(0x00, 0xf808da20)</span>
  3104 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  3105 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  3106 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  3107 |     | <span class='neutral'>            mstore(0x80, 0x80)</span>
  3108 |     | <span class='neutral'>            writeString(0xa0, p3)</span>
  3109 |     | <span class='neutral'>        }</span>
  3110 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xc4);</span>
  3111 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  3112 |     | <span class='neutral'>        assembly {</span>
  3113 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  3114 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  3115 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  3116 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  3117 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  3118 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  3119 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
  3120 |     | <span class='neutral'>        }</span>
  3121 |     | <span class='neutral'>    }</span>
  3122 |     | <span class='neutral'></span>
  3123 |     | <span class='neutral'>    function log(address p0, address p1, bool p2, address p3) internal pure {</span>
  3124 |     | <span class='neutral'>        bytes32 m0;</span>
  3125 |     | <span class='neutral'>        bytes32 m1;</span>
  3126 |     | <span class='neutral'>        bytes32 m2;</span>
  3127 |     | <span class='neutral'>        bytes32 m3;</span>
  3128 |     | <span class='neutral'>        bytes32 m4;</span>
  3129 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  3130 |     | <span class='neutral'>        assembly {</span>
  3131 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  3132 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  3133 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  3134 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  3135 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  3136 |     | <span class='neutral'>            // Selector of `log(address,address,bool,address)`.</span>
  3137 |     | <span class='neutral'>            mstore(0x00, 0x9f1bc36e)</span>
  3138 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  3139 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  3140 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  3141 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  3142 |     | <span class='neutral'>        }</span>
  3143 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x84);</span>
  3144 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  3145 |     | <span class='neutral'>        assembly {</span>
  3146 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  3147 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  3148 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  3149 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  3150 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  3151 |     | <span class='neutral'>        }</span>
  3152 |     | <span class='neutral'>    }</span>
  3153 |     | <span class='neutral'></span>
  3154 |     | <span class='neutral'>    function log(address p0, address p1, bool p2, bool p3) internal pure {</span>
  3155 |     | <span class='neutral'>        bytes32 m0;</span>
  3156 |     | <span class='neutral'>        bytes32 m1;</span>
  3157 |     | <span class='neutral'>        bytes32 m2;</span>
  3158 |     | <span class='neutral'>        bytes32 m3;</span>
  3159 |     | <span class='neutral'>        bytes32 m4;</span>
  3160 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  3161 |     | <span class='neutral'>        assembly {</span>
  3162 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  3163 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  3164 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  3165 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  3166 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  3167 |     | <span class='neutral'>            // Selector of `log(address,address,bool,bool)`.</span>
  3168 |     | <span class='neutral'>            mstore(0x00, 0x2cd4134a)</span>
  3169 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  3170 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  3171 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  3172 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  3173 |     | <span class='neutral'>        }</span>
  3174 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x84);</span>
  3175 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  3176 |     | <span class='neutral'>        assembly {</span>
  3177 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  3178 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  3179 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  3180 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  3181 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  3182 |     | <span class='neutral'>        }</span>
  3183 |     | <span class='neutral'>    }</span>
  3184 |     | <span class='neutral'></span>
  3185 |     | <span class='neutral'>    function log(address p0, address p1, bool p2, uint256 p3) internal pure {</span>
  3186 |     | <span class='neutral'>        bytes32 m0;</span>
  3187 |     | <span class='neutral'>        bytes32 m1;</span>
  3188 |     | <span class='neutral'>        bytes32 m2;</span>
  3189 |     | <span class='neutral'>        bytes32 m3;</span>
  3190 |     | <span class='neutral'>        bytes32 m4;</span>
  3191 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  3192 |     | <span class='neutral'>        assembly {</span>
  3193 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  3194 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  3195 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  3196 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  3197 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  3198 |     | <span class='neutral'>            // Selector of `log(address,address,bool,uint256)`.</span>
  3199 |     | <span class='neutral'>            mstore(0x00, 0x3971e78c)</span>
  3200 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  3201 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  3202 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  3203 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  3204 |     | <span class='neutral'>        }</span>
  3205 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x84);</span>
  3206 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  3207 |     | <span class='neutral'>        assembly {</span>
  3208 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  3209 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  3210 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  3211 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  3212 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  3213 |     | <span class='neutral'>        }</span>
  3214 |     | <span class='neutral'>    }</span>
  3215 |     | <span class='neutral'></span>
  3216 |     | <span class='neutral'>    function log(address p0, address p1, bool p2, bytes32 p3) internal pure {</span>
  3217 |     | <span class='neutral'>        bytes32 m0;</span>
  3218 |     | <span class='neutral'>        bytes32 m1;</span>
  3219 |     | <span class='neutral'>        bytes32 m2;</span>
  3220 |     | <span class='neutral'>        bytes32 m3;</span>
  3221 |     | <span class='neutral'>        bytes32 m4;</span>
  3222 |     | <span class='neutral'>        bytes32 m5;</span>
  3223 |     | <span class='neutral'>        bytes32 m6;</span>
  3224 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  3225 |     | <span class='neutral'>        assembly {</span>
  3226 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  3227 |     | <span class='neutral'>                let length := 0</span>
  3228 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  3229 |     | <span class='neutral'>                mstore(pos, length)</span>
  3230 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  3231 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  3232 |     | <span class='neutral'>            }</span>
  3233 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  3234 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  3235 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  3236 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  3237 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  3238 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  3239 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
  3240 |     | <span class='neutral'>            // Selector of `log(address,address,bool,string)`.</span>
  3241 |     | <span class='neutral'>            mstore(0x00, 0xaa6540c8)</span>
  3242 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  3243 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  3244 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  3245 |     | <span class='neutral'>            mstore(0x80, 0x80)</span>
  3246 |     | <span class='neutral'>            writeString(0xa0, p3)</span>
  3247 |     | <span class='neutral'>        }</span>
  3248 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xc4);</span>
  3249 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  3250 |     | <span class='neutral'>        assembly {</span>
  3251 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  3252 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  3253 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  3254 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  3255 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  3256 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  3257 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
  3258 |     | <span class='neutral'>        }</span>
  3259 |     | <span class='neutral'>    }</span>
  3260 |     | <span class='neutral'></span>
  3261 |     | <span class='neutral'>    function log(address p0, address p1, uint256 p2, address p3) internal pure {</span>
  3262 |     | <span class='neutral'>        bytes32 m0;</span>
  3263 |     | <span class='neutral'>        bytes32 m1;</span>
  3264 |     | <span class='neutral'>        bytes32 m2;</span>
  3265 |     | <span class='neutral'>        bytes32 m3;</span>
  3266 |     | <span class='neutral'>        bytes32 m4;</span>
  3267 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  3268 |     | <span class='neutral'>        assembly {</span>
  3269 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  3270 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  3271 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  3272 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  3273 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  3274 |     | <span class='neutral'>            // Selector of `log(address,address,uint256,address)`.</span>
  3275 |     | <span class='neutral'>            mstore(0x00, 0x8da6def5)</span>
  3276 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  3277 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  3278 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  3279 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  3280 |     | <span class='neutral'>        }</span>
  3281 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x84);</span>
  3282 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  3283 |     | <span class='neutral'>        assembly {</span>
  3284 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  3285 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  3286 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  3287 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  3288 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  3289 |     | <span class='neutral'>        }</span>
  3290 |     | <span class='neutral'>    }</span>
  3291 |     | <span class='neutral'></span>
  3292 |     | <span class='neutral'>    function log(address p0, address p1, uint256 p2, bool p3) internal pure {</span>
  3293 |     | <span class='neutral'>        bytes32 m0;</span>
  3294 |     | <span class='neutral'>        bytes32 m1;</span>
  3295 |     | <span class='neutral'>        bytes32 m2;</span>
  3296 |     | <span class='neutral'>        bytes32 m3;</span>
  3297 |     | <span class='neutral'>        bytes32 m4;</span>
  3298 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  3299 |     | <span class='neutral'>        assembly {</span>
  3300 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  3301 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  3302 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  3303 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  3304 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  3305 |     | <span class='neutral'>            // Selector of `log(address,address,uint256,bool)`.</span>
  3306 |     | <span class='neutral'>            mstore(0x00, 0x9b4254e2)</span>
  3307 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  3308 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  3309 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  3310 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  3311 |     | <span class='neutral'>        }</span>
  3312 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x84);</span>
  3313 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  3314 |     | <span class='neutral'>        assembly {</span>
  3315 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  3316 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  3317 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  3318 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  3319 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  3320 |     | <span class='neutral'>        }</span>
  3321 |     | <span class='neutral'>    }</span>
  3322 |     | <span class='neutral'></span>
  3323 |     | <span class='neutral'>    function log(address p0, address p1, uint256 p2, uint256 p3) internal pure {</span>
  3324 |     | <span class='neutral'>        bytes32 m0;</span>
  3325 |     | <span class='neutral'>        bytes32 m1;</span>
  3326 |     | <span class='neutral'>        bytes32 m2;</span>
  3327 |     | <span class='neutral'>        bytes32 m3;</span>
  3328 |     | <span class='neutral'>        bytes32 m4;</span>
  3329 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  3330 |     | <span class='neutral'>        assembly {</span>
  3331 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  3332 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  3333 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  3334 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  3335 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  3336 |     | <span class='neutral'>            // Selector of `log(address,address,uint256,uint256)`.</span>
  3337 |     | <span class='neutral'>            mstore(0x00, 0xbe553481)</span>
  3338 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  3339 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  3340 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  3341 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  3342 |     | <span class='neutral'>        }</span>
  3343 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x84);</span>
  3344 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  3345 |     | <span class='neutral'>        assembly {</span>
  3346 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  3347 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  3348 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  3349 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  3350 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  3351 |     | <span class='neutral'>        }</span>
  3352 |     | <span class='neutral'>    }</span>
  3353 |     | <span class='neutral'></span>
  3354 |     | <span class='neutral'>    function log(address p0, address p1, uint256 p2, bytes32 p3) internal pure {</span>
  3355 |     | <span class='neutral'>        bytes32 m0;</span>
  3356 |     | <span class='neutral'>        bytes32 m1;</span>
  3357 |     | <span class='neutral'>        bytes32 m2;</span>
  3358 |     | <span class='neutral'>        bytes32 m3;</span>
  3359 |     | <span class='neutral'>        bytes32 m4;</span>
  3360 |     | <span class='neutral'>        bytes32 m5;</span>
  3361 |     | <span class='neutral'>        bytes32 m6;</span>
  3362 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  3363 |     | <span class='neutral'>        assembly {</span>
  3364 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  3365 |     | <span class='neutral'>                let length := 0</span>
  3366 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  3367 |     | <span class='neutral'>                mstore(pos, length)</span>
  3368 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  3369 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  3370 |     | <span class='neutral'>            }</span>
  3371 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  3372 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  3373 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  3374 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  3375 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  3376 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  3377 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
  3378 |     | <span class='neutral'>            // Selector of `log(address,address,uint256,string)`.</span>
  3379 |     | <span class='neutral'>            mstore(0x00, 0xfdb4f990)</span>
  3380 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  3381 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  3382 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  3383 |     | <span class='neutral'>            mstore(0x80, 0x80)</span>
  3384 |     | <span class='neutral'>            writeString(0xa0, p3)</span>
  3385 |     | <span class='neutral'>        }</span>
  3386 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xc4);</span>
  3387 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  3388 |     | <span class='neutral'>        assembly {</span>
  3389 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  3390 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  3391 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  3392 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  3393 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  3394 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  3395 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
  3396 |     | <span class='neutral'>        }</span>
  3397 |     | <span class='neutral'>    }</span>
  3398 |     | <span class='neutral'></span>
  3399 |     | <span class='neutral'>    function log(address p0, address p1, bytes32 p2, address p3) internal pure {</span>
  3400 |     | <span class='neutral'>        bytes32 m0;</span>
  3401 |     | <span class='neutral'>        bytes32 m1;</span>
  3402 |     | <span class='neutral'>        bytes32 m2;</span>
  3403 |     | <span class='neutral'>        bytes32 m3;</span>
  3404 |     | <span class='neutral'>        bytes32 m4;</span>
  3405 |     | <span class='neutral'>        bytes32 m5;</span>
  3406 |     | <span class='neutral'>        bytes32 m6;</span>
  3407 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  3408 |     | <span class='neutral'>        assembly {</span>
  3409 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  3410 |     | <span class='neutral'>                let length := 0</span>
  3411 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  3412 |     | <span class='neutral'>                mstore(pos, length)</span>
  3413 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  3414 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  3415 |     | <span class='neutral'>            }</span>
  3416 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  3417 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  3418 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  3419 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  3420 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  3421 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  3422 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
  3423 |     | <span class='neutral'>            // Selector of `log(address,address,string,address)`.</span>
  3424 |     | <span class='neutral'>            mstore(0x00, 0x8f736d16)</span>
  3425 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  3426 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  3427 |     | <span class='neutral'>            mstore(0x60, 0x80)</span>
  3428 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  3429 |     | <span class='neutral'>            writeString(0xa0, p2)</span>
  3430 |     | <span class='neutral'>        }</span>
  3431 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xc4);</span>
  3432 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  3433 |     | <span class='neutral'>        assembly {</span>
  3434 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  3435 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  3436 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  3437 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  3438 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  3439 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  3440 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
  3441 |     | <span class='neutral'>        }</span>
  3442 |     | <span class='neutral'>    }</span>
  3443 |     | <span class='neutral'></span>
  3444 |     | <span class='neutral'>    function log(address p0, address p1, bytes32 p2, bool p3) internal pure {</span>
  3445 |     | <span class='neutral'>        bytes32 m0;</span>
  3446 |     | <span class='neutral'>        bytes32 m1;</span>
  3447 |     | <span class='neutral'>        bytes32 m2;</span>
  3448 |     | <span class='neutral'>        bytes32 m3;</span>
  3449 |     | <span class='neutral'>        bytes32 m4;</span>
  3450 |     | <span class='neutral'>        bytes32 m5;</span>
  3451 |     | <span class='neutral'>        bytes32 m6;</span>
  3452 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  3453 |     | <span class='neutral'>        assembly {</span>
  3454 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  3455 |     | <span class='neutral'>                let length := 0</span>
  3456 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  3457 |     | <span class='neutral'>                mstore(pos, length)</span>
  3458 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  3459 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  3460 |     | <span class='neutral'>            }</span>
  3461 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  3462 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  3463 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  3464 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  3465 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  3466 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  3467 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
  3468 |     | <span class='neutral'>            // Selector of `log(address,address,string,bool)`.</span>
  3469 |     | <span class='neutral'>            mstore(0x00, 0x6f1a594e)</span>
  3470 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  3471 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  3472 |     | <span class='neutral'>            mstore(0x60, 0x80)</span>
  3473 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  3474 |     | <span class='neutral'>            writeString(0xa0, p2)</span>
  3475 |     | <span class='neutral'>        }</span>
  3476 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xc4);</span>
  3477 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  3478 |     | <span class='neutral'>        assembly {</span>
  3479 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  3480 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  3481 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  3482 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  3483 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  3484 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  3485 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
  3486 |     | <span class='neutral'>        }</span>
  3487 |     | <span class='neutral'>    }</span>
  3488 |     | <span class='neutral'></span>
  3489 |     | <span class='neutral'>    function log(address p0, address p1, bytes32 p2, uint256 p3) internal pure {</span>
  3490 |     | <span class='neutral'>        bytes32 m0;</span>
  3491 |     | <span class='neutral'>        bytes32 m1;</span>
  3492 |     | <span class='neutral'>        bytes32 m2;</span>
  3493 |     | <span class='neutral'>        bytes32 m3;</span>
  3494 |     | <span class='neutral'>        bytes32 m4;</span>
  3495 |     | <span class='neutral'>        bytes32 m5;</span>
  3496 |     | <span class='neutral'>        bytes32 m6;</span>
  3497 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  3498 |     | <span class='neutral'>        assembly {</span>
  3499 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  3500 |     | <span class='neutral'>                let length := 0</span>
  3501 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  3502 |     | <span class='neutral'>                mstore(pos, length)</span>
  3503 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  3504 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  3505 |     | <span class='neutral'>            }</span>
  3506 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  3507 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  3508 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  3509 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  3510 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  3511 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  3512 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
  3513 |     | <span class='neutral'>            // Selector of `log(address,address,string,uint256)`.</span>
  3514 |     | <span class='neutral'>            mstore(0x00, 0xef1cefe7)</span>
  3515 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  3516 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  3517 |     | <span class='neutral'>            mstore(0x60, 0x80)</span>
  3518 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  3519 |     | <span class='neutral'>            writeString(0xa0, p2)</span>
  3520 |     | <span class='neutral'>        }</span>
  3521 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xc4);</span>
  3522 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  3523 |     | <span class='neutral'>        assembly {</span>
  3524 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  3525 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  3526 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  3527 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  3528 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  3529 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  3530 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
  3531 |     | <span class='neutral'>        }</span>
  3532 |     | <span class='neutral'>    }</span>
  3533 |     | <span class='neutral'></span>
  3534 |     | <span class='neutral'>    function log(address p0, address p1, bytes32 p2, bytes32 p3) internal pure {</span>
  3535 |     | <span class='neutral'>        bytes32 m0;</span>
  3536 |     | <span class='neutral'>        bytes32 m1;</span>
  3537 |     | <span class='neutral'>        bytes32 m2;</span>
  3538 |     | <span class='neutral'>        bytes32 m3;</span>
  3539 |     | <span class='neutral'>        bytes32 m4;</span>
  3540 |     | <span class='neutral'>        bytes32 m5;</span>
  3541 |     | <span class='neutral'>        bytes32 m6;</span>
  3542 |     | <span class='neutral'>        bytes32 m7;</span>
  3543 |     | <span class='neutral'>        bytes32 m8;</span>
  3544 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  3545 |     | <span class='neutral'>        assembly {</span>
  3546 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  3547 |     | <span class='neutral'>                let length := 0</span>
  3548 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  3549 |     | <span class='neutral'>                mstore(pos, length)</span>
  3550 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  3551 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  3552 |     | <span class='neutral'>            }</span>
  3553 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  3554 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  3555 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  3556 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  3557 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  3558 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  3559 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
  3560 |     | <span class='neutral'>            m7 := mload(0xe0)</span>
  3561 |     | <span class='neutral'>            m8 := mload(0x100)</span>
  3562 |     | <span class='neutral'>            // Selector of `log(address,address,string,string)`.</span>
  3563 |     | <span class='neutral'>            mstore(0x00, 0x21bdaf25)</span>
  3564 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  3565 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  3566 |     | <span class='neutral'>            mstore(0x60, 0x80)</span>
  3567 |     | <span class='neutral'>            mstore(0x80, 0xc0)</span>
  3568 |     | <span class='neutral'>            writeString(0xa0, p2)</span>
  3569 |     | <span class='neutral'>            writeString(0xe0, p3)</span>
  3570 |     | <span class='neutral'>        }</span>
  3571 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x104);</span>
  3572 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  3573 |     | <span class='neutral'>        assembly {</span>
  3574 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  3575 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  3576 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  3577 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  3578 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  3579 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  3580 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
  3581 |     | <span class='neutral'>            mstore(0xe0, m7)</span>
  3582 |     | <span class='neutral'>            mstore(0x100, m8)</span>
  3583 |     | <span class='neutral'>        }</span>
  3584 |     | <span class='neutral'>    }</span>
  3585 |     | <span class='neutral'></span>
  3586 |     | <span class='neutral'>    function log(address p0, bool p1, address p2, address p3) internal pure {</span>
  3587 |     | <span class='neutral'>        bytes32 m0;</span>
  3588 |     | <span class='neutral'>        bytes32 m1;</span>
  3589 |     | <span class='neutral'>        bytes32 m2;</span>
  3590 |     | <span class='neutral'>        bytes32 m3;</span>
  3591 |     | <span class='neutral'>        bytes32 m4;</span>
  3592 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  3593 |     | <span class='neutral'>        assembly {</span>
  3594 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  3595 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  3596 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  3597 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  3598 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  3599 |     | <span class='neutral'>            // Selector of `log(address,bool,address,address)`.</span>
  3600 |     | <span class='neutral'>            mstore(0x00, 0x660375dd)</span>
  3601 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  3602 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  3603 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  3604 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  3605 |     | <span class='neutral'>        }</span>
  3606 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x84);</span>
  3607 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  3608 |     | <span class='neutral'>        assembly {</span>
  3609 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  3610 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  3611 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  3612 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  3613 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  3614 |     | <span class='neutral'>        }</span>
  3615 |     | <span class='neutral'>    }</span>
  3616 |     | <span class='neutral'></span>
  3617 |     | <span class='neutral'>    function log(address p0, bool p1, address p2, bool p3) internal pure {</span>
  3618 |     | <span class='neutral'>        bytes32 m0;</span>
  3619 |     | <span class='neutral'>        bytes32 m1;</span>
  3620 |     | <span class='neutral'>        bytes32 m2;</span>
  3621 |     | <span class='neutral'>        bytes32 m3;</span>
  3622 |     | <span class='neutral'>        bytes32 m4;</span>
  3623 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  3624 |     | <span class='neutral'>        assembly {</span>
  3625 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  3626 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  3627 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  3628 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  3629 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  3630 |     | <span class='neutral'>            // Selector of `log(address,bool,address,bool)`.</span>
  3631 |     | <span class='neutral'>            mstore(0x00, 0xa6f50b0f)</span>
  3632 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  3633 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  3634 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  3635 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  3636 |     | <span class='neutral'>        }</span>
  3637 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x84);</span>
  3638 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  3639 |     | <span class='neutral'>        assembly {</span>
  3640 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  3641 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  3642 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  3643 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  3644 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  3645 |     | <span class='neutral'>        }</span>
  3646 |     | <span class='neutral'>    }</span>
  3647 |     | <span class='neutral'></span>
  3648 |     | <span class='neutral'>    function log(address p0, bool p1, address p2, uint256 p3) internal pure {</span>
  3649 |     | <span class='neutral'>        bytes32 m0;</span>
  3650 |     | <span class='neutral'>        bytes32 m1;</span>
  3651 |     | <span class='neutral'>        bytes32 m2;</span>
  3652 |     | <span class='neutral'>        bytes32 m3;</span>
  3653 |     | <span class='neutral'>        bytes32 m4;</span>
  3654 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  3655 |     | <span class='neutral'>        assembly {</span>
  3656 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  3657 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  3658 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  3659 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  3660 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  3661 |     | <span class='neutral'>            // Selector of `log(address,bool,address,uint256)`.</span>
  3662 |     | <span class='neutral'>            mstore(0x00, 0xa75c59de)</span>
  3663 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  3664 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  3665 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  3666 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  3667 |     | <span class='neutral'>        }</span>
  3668 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x84);</span>
  3669 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  3670 |     | <span class='neutral'>        assembly {</span>
  3671 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  3672 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  3673 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  3674 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  3675 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  3676 |     | <span class='neutral'>        }</span>
  3677 |     | <span class='neutral'>    }</span>
  3678 |     | <span class='neutral'></span>
  3679 |     | <span class='neutral'>    function log(address p0, bool p1, address p2, bytes32 p3) internal pure {</span>
  3680 |     | <span class='neutral'>        bytes32 m0;</span>
  3681 |     | <span class='neutral'>        bytes32 m1;</span>
  3682 |     | <span class='neutral'>        bytes32 m2;</span>
  3683 |     | <span class='neutral'>        bytes32 m3;</span>
  3684 |     | <span class='neutral'>        bytes32 m4;</span>
  3685 |     | <span class='neutral'>        bytes32 m5;</span>
  3686 |     | <span class='neutral'>        bytes32 m6;</span>
  3687 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  3688 |     | <span class='neutral'>        assembly {</span>
  3689 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  3690 |     | <span class='neutral'>                let length := 0</span>
  3691 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  3692 |     | <span class='neutral'>                mstore(pos, length)</span>
  3693 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  3694 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  3695 |     | <span class='neutral'>            }</span>
  3696 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  3697 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  3698 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  3699 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  3700 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  3701 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  3702 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
  3703 |     | <span class='neutral'>            // Selector of `log(address,bool,address,string)`.</span>
  3704 |     | <span class='neutral'>            mstore(0x00, 0x2dd778e6)</span>
  3705 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  3706 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  3707 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  3708 |     | <span class='neutral'>            mstore(0x80, 0x80)</span>
  3709 |     | <span class='neutral'>            writeString(0xa0, p3)</span>
  3710 |     | <span class='neutral'>        }</span>
  3711 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xc4);</span>
  3712 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  3713 |     | <span class='neutral'>        assembly {</span>
  3714 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  3715 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  3716 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  3717 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  3718 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  3719 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  3720 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
  3721 |     | <span class='neutral'>        }</span>
  3722 |     | <span class='neutral'>    }</span>
  3723 |     | <span class='neutral'></span>
  3724 |     | <span class='neutral'>    function log(address p0, bool p1, bool p2, address p3) internal pure {</span>
  3725 |     | <span class='neutral'>        bytes32 m0;</span>
  3726 |     | <span class='neutral'>        bytes32 m1;</span>
  3727 |     | <span class='neutral'>        bytes32 m2;</span>
  3728 |     | <span class='neutral'>        bytes32 m3;</span>
  3729 |     | <span class='neutral'>        bytes32 m4;</span>
  3730 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  3731 |     | <span class='neutral'>        assembly {</span>
  3732 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  3733 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  3734 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  3735 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  3736 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  3737 |     | <span class='neutral'>            // Selector of `log(address,bool,bool,address)`.</span>
  3738 |     | <span class='neutral'>            mstore(0x00, 0xcf394485)</span>
  3739 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  3740 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  3741 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  3742 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  3743 |     | <span class='neutral'>        }</span>
  3744 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x84);</span>
  3745 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  3746 |     | <span class='neutral'>        assembly {</span>
  3747 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  3748 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  3749 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  3750 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  3751 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  3752 |     | <span class='neutral'>        }</span>
  3753 |     | <span class='neutral'>    }</span>
  3754 |     | <span class='neutral'></span>
  3755 |     | <span class='neutral'>    function log(address p0, bool p1, bool p2, bool p3) internal pure {</span>
  3756 |     | <span class='neutral'>        bytes32 m0;</span>
  3757 |     | <span class='neutral'>        bytes32 m1;</span>
  3758 |     | <span class='neutral'>        bytes32 m2;</span>
  3759 |     | <span class='neutral'>        bytes32 m3;</span>
  3760 |     | <span class='neutral'>        bytes32 m4;</span>
  3761 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  3762 |     | <span class='neutral'>        assembly {</span>
  3763 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  3764 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  3765 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  3766 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  3767 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  3768 |     | <span class='neutral'>            // Selector of `log(address,bool,bool,bool)`.</span>
  3769 |     | <span class='neutral'>            mstore(0x00, 0xcac43479)</span>
  3770 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  3771 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  3772 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  3773 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  3774 |     | <span class='neutral'>        }</span>
  3775 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x84);</span>
  3776 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  3777 |     | <span class='neutral'>        assembly {</span>
  3778 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  3779 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  3780 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  3781 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  3782 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  3783 |     | <span class='neutral'>        }</span>
  3784 |     | <span class='neutral'>    }</span>
  3785 |     | <span class='neutral'></span>
  3786 |     | <span class='neutral'>    function log(address p0, bool p1, bool p2, uint256 p3) internal pure {</span>
  3787 |     | <span class='neutral'>        bytes32 m0;</span>
  3788 |     | <span class='neutral'>        bytes32 m1;</span>
  3789 |     | <span class='neutral'>        bytes32 m2;</span>
  3790 |     | <span class='neutral'>        bytes32 m3;</span>
  3791 |     | <span class='neutral'>        bytes32 m4;</span>
  3792 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  3793 |     | <span class='neutral'>        assembly {</span>
  3794 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  3795 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  3796 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  3797 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  3798 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  3799 |     | <span class='neutral'>            // Selector of `log(address,bool,bool,uint256)`.</span>
  3800 |     | <span class='neutral'>            mstore(0x00, 0x8c4e5de6)</span>
  3801 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  3802 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  3803 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  3804 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  3805 |     | <span class='neutral'>        }</span>
  3806 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x84);</span>
  3807 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  3808 |     | <span class='neutral'>        assembly {</span>
  3809 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  3810 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  3811 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  3812 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  3813 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  3814 |     | <span class='neutral'>        }</span>
  3815 |     | <span class='neutral'>    }</span>
  3816 |     | <span class='neutral'></span>
  3817 |     | <span class='neutral'>    function log(address p0, bool p1, bool p2, bytes32 p3) internal pure {</span>
  3818 |     | <span class='neutral'>        bytes32 m0;</span>
  3819 |     | <span class='neutral'>        bytes32 m1;</span>
  3820 |     | <span class='neutral'>        bytes32 m2;</span>
  3821 |     | <span class='neutral'>        bytes32 m3;</span>
  3822 |     | <span class='neutral'>        bytes32 m4;</span>
  3823 |     | <span class='neutral'>        bytes32 m5;</span>
  3824 |     | <span class='neutral'>        bytes32 m6;</span>
  3825 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  3826 |     | <span class='neutral'>        assembly {</span>
  3827 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  3828 |     | <span class='neutral'>                let length := 0</span>
  3829 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  3830 |     | <span class='neutral'>                mstore(pos, length)</span>
  3831 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  3832 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  3833 |     | <span class='neutral'>            }</span>
  3834 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  3835 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  3836 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  3837 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  3838 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  3839 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  3840 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
  3841 |     | <span class='neutral'>            // Selector of `log(address,bool,bool,string)`.</span>
  3842 |     | <span class='neutral'>            mstore(0x00, 0xdfc4a2e8)</span>
  3843 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  3844 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  3845 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  3846 |     | <span class='neutral'>            mstore(0x80, 0x80)</span>
  3847 |     | <span class='neutral'>            writeString(0xa0, p3)</span>
  3848 |     | <span class='neutral'>        }</span>
  3849 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xc4);</span>
  3850 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  3851 |     | <span class='neutral'>        assembly {</span>
  3852 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  3853 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  3854 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  3855 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  3856 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  3857 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  3858 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
  3859 |     | <span class='neutral'>        }</span>
  3860 |     | <span class='neutral'>    }</span>
  3861 |     | <span class='neutral'></span>
  3862 |     | <span class='neutral'>    function log(address p0, bool p1, uint256 p2, address p3) internal pure {</span>
  3863 |     | <span class='neutral'>        bytes32 m0;</span>
  3864 |     | <span class='neutral'>        bytes32 m1;</span>
  3865 |     | <span class='neutral'>        bytes32 m2;</span>
  3866 |     | <span class='neutral'>        bytes32 m3;</span>
  3867 |     | <span class='neutral'>        bytes32 m4;</span>
  3868 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  3869 |     | <span class='neutral'>        assembly {</span>
  3870 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  3871 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  3872 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  3873 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  3874 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  3875 |     | <span class='neutral'>            // Selector of `log(address,bool,uint256,address)`.</span>
  3876 |     | <span class='neutral'>            mstore(0x00, 0xccf790a1)</span>
  3877 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  3878 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  3879 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  3880 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  3881 |     | <span class='neutral'>        }</span>
  3882 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x84);</span>
  3883 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  3884 |     | <span class='neutral'>        assembly {</span>
  3885 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  3886 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  3887 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  3888 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  3889 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  3890 |     | <span class='neutral'>        }</span>
  3891 |     | <span class='neutral'>    }</span>
  3892 |     | <span class='neutral'></span>
  3893 |     | <span class='neutral'>    function log(address p0, bool p1, uint256 p2, bool p3) internal pure {</span>
  3894 |     | <span class='neutral'>        bytes32 m0;</span>
  3895 |     | <span class='neutral'>        bytes32 m1;</span>
  3896 |     | <span class='neutral'>        bytes32 m2;</span>
  3897 |     | <span class='neutral'>        bytes32 m3;</span>
  3898 |     | <span class='neutral'>        bytes32 m4;</span>
  3899 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  3900 |     | <span class='neutral'>        assembly {</span>
  3901 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  3902 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  3903 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  3904 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  3905 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  3906 |     | <span class='neutral'>            // Selector of `log(address,bool,uint256,bool)`.</span>
  3907 |     | <span class='neutral'>            mstore(0x00, 0xc4643e20)</span>
  3908 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  3909 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  3910 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  3911 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  3912 |     | <span class='neutral'>        }</span>
  3913 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x84);</span>
  3914 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  3915 |     | <span class='neutral'>        assembly {</span>
  3916 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  3917 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  3918 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  3919 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  3920 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  3921 |     | <span class='neutral'>        }</span>
  3922 |     | <span class='neutral'>    }</span>
  3923 |     | <span class='neutral'></span>
  3924 |     | <span class='neutral'>    function log(address p0, bool p1, uint256 p2, uint256 p3) internal pure {</span>
  3925 |     | <span class='neutral'>        bytes32 m0;</span>
  3926 |     | <span class='neutral'>        bytes32 m1;</span>
  3927 |     | <span class='neutral'>        bytes32 m2;</span>
  3928 |     | <span class='neutral'>        bytes32 m3;</span>
  3929 |     | <span class='neutral'>        bytes32 m4;</span>
  3930 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  3931 |     | <span class='neutral'>        assembly {</span>
  3932 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  3933 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  3934 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  3935 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  3936 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  3937 |     | <span class='neutral'>            // Selector of `log(address,bool,uint256,uint256)`.</span>
  3938 |     | <span class='neutral'>            mstore(0x00, 0x386ff5f4)</span>
  3939 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  3940 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  3941 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  3942 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  3943 |     | <span class='neutral'>        }</span>
  3944 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x84);</span>
  3945 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  3946 |     | <span class='neutral'>        assembly {</span>
  3947 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  3948 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  3949 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  3950 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  3951 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  3952 |     | <span class='neutral'>        }</span>
  3953 |     | <span class='neutral'>    }</span>
  3954 |     | <span class='neutral'></span>
  3955 |     | <span class='neutral'>    function log(address p0, bool p1, uint256 p2, bytes32 p3) internal pure {</span>
  3956 |     | <span class='neutral'>        bytes32 m0;</span>
  3957 |     | <span class='neutral'>        bytes32 m1;</span>
  3958 |     | <span class='neutral'>        bytes32 m2;</span>
  3959 |     | <span class='neutral'>        bytes32 m3;</span>
  3960 |     | <span class='neutral'>        bytes32 m4;</span>
  3961 |     | <span class='neutral'>        bytes32 m5;</span>
  3962 |     | <span class='neutral'>        bytes32 m6;</span>
  3963 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  3964 |     | <span class='neutral'>        assembly {</span>
  3965 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  3966 |     | <span class='neutral'>                let length := 0</span>
  3967 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  3968 |     | <span class='neutral'>                mstore(pos, length)</span>
  3969 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  3970 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  3971 |     | <span class='neutral'>            }</span>
  3972 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  3973 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  3974 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  3975 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  3976 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  3977 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  3978 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
  3979 |     | <span class='neutral'>            // Selector of `log(address,bool,uint256,string)`.</span>
  3980 |     | <span class='neutral'>            mstore(0x00, 0x0aa6cfad)</span>
  3981 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  3982 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  3983 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  3984 |     | <span class='neutral'>            mstore(0x80, 0x80)</span>
  3985 |     | <span class='neutral'>            writeString(0xa0, p3)</span>
  3986 |     | <span class='neutral'>        }</span>
  3987 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xc4);</span>
  3988 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  3989 |     | <span class='neutral'>        assembly {</span>
  3990 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  3991 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  3992 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  3993 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  3994 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  3995 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  3996 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
  3997 |     | <span class='neutral'>        }</span>
  3998 |     | <span class='neutral'>    }</span>
  3999 |     | <span class='neutral'></span>
  4000 |     | <span class='neutral'>    function log(address p0, bool p1, bytes32 p2, address p3) internal pure {</span>
  4001 |     | <span class='neutral'>        bytes32 m0;</span>
  4002 |     | <span class='neutral'>        bytes32 m1;</span>
  4003 |     | <span class='neutral'>        bytes32 m2;</span>
  4004 |     | <span class='neutral'>        bytes32 m3;</span>
  4005 |     | <span class='neutral'>        bytes32 m4;</span>
  4006 |     | <span class='neutral'>        bytes32 m5;</span>
  4007 |     | <span class='neutral'>        bytes32 m6;</span>
  4008 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  4009 |     | <span class='neutral'>        assembly {</span>
  4010 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  4011 |     | <span class='neutral'>                let length := 0</span>
  4012 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  4013 |     | <span class='neutral'>                mstore(pos, length)</span>
  4014 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  4015 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  4016 |     | <span class='neutral'>            }</span>
  4017 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  4018 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  4019 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  4020 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  4021 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  4022 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  4023 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
  4024 |     | <span class='neutral'>            // Selector of `log(address,bool,string,address)`.</span>
  4025 |     | <span class='neutral'>            mstore(0x00, 0x19fd4956)</span>
  4026 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  4027 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  4028 |     | <span class='neutral'>            mstore(0x60, 0x80)</span>
  4029 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  4030 |     | <span class='neutral'>            writeString(0xa0, p2)</span>
  4031 |     | <span class='neutral'>        }</span>
  4032 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xc4);</span>
  4033 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  4034 |     | <span class='neutral'>        assembly {</span>
  4035 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  4036 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  4037 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  4038 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  4039 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  4040 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  4041 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
  4042 |     | <span class='neutral'>        }</span>
  4043 |     | <span class='neutral'>    }</span>
  4044 |     | <span class='neutral'></span>
  4045 |     | <span class='neutral'>    function log(address p0, bool p1, bytes32 p2, bool p3) internal pure {</span>
  4046 |     | <span class='neutral'>        bytes32 m0;</span>
  4047 |     | <span class='neutral'>        bytes32 m1;</span>
  4048 |     | <span class='neutral'>        bytes32 m2;</span>
  4049 |     | <span class='neutral'>        bytes32 m3;</span>
  4050 |     | <span class='neutral'>        bytes32 m4;</span>
  4051 |     | <span class='neutral'>        bytes32 m5;</span>
  4052 |     | <span class='neutral'>        bytes32 m6;</span>
  4053 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  4054 |     | <span class='neutral'>        assembly {</span>
  4055 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  4056 |     | <span class='neutral'>                let length := 0</span>
  4057 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  4058 |     | <span class='neutral'>                mstore(pos, length)</span>
  4059 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  4060 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  4061 |     | <span class='neutral'>            }</span>
  4062 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  4063 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  4064 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  4065 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  4066 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  4067 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  4068 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
  4069 |     | <span class='neutral'>            // Selector of `log(address,bool,string,bool)`.</span>
  4070 |     | <span class='neutral'>            mstore(0x00, 0x50ad461d)</span>
  4071 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  4072 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  4073 |     | <span class='neutral'>            mstore(0x60, 0x80)</span>
  4074 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  4075 |     | <span class='neutral'>            writeString(0xa0, p2)</span>
  4076 |     | <span class='neutral'>        }</span>
  4077 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xc4);</span>
  4078 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  4079 |     | <span class='neutral'>        assembly {</span>
  4080 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  4081 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  4082 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  4083 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  4084 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  4085 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  4086 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
  4087 |     | <span class='neutral'>        }</span>
  4088 |     | <span class='neutral'>    }</span>
  4089 |     | <span class='neutral'></span>
  4090 |     | <span class='neutral'>    function log(address p0, bool p1, bytes32 p2, uint256 p3) internal pure {</span>
  4091 |     | <span class='neutral'>        bytes32 m0;</span>
  4092 |     | <span class='neutral'>        bytes32 m1;</span>
  4093 |     | <span class='neutral'>        bytes32 m2;</span>
  4094 |     | <span class='neutral'>        bytes32 m3;</span>
  4095 |     | <span class='neutral'>        bytes32 m4;</span>
  4096 |     | <span class='neutral'>        bytes32 m5;</span>
  4097 |     | <span class='neutral'>        bytes32 m6;</span>
  4098 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  4099 |     | <span class='neutral'>        assembly {</span>
  4100 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  4101 |     | <span class='neutral'>                let length := 0</span>
  4102 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  4103 |     | <span class='neutral'>                mstore(pos, length)</span>
  4104 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  4105 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  4106 |     | <span class='neutral'>            }</span>
  4107 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  4108 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  4109 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  4110 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  4111 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  4112 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  4113 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
  4114 |     | <span class='neutral'>            // Selector of `log(address,bool,string,uint256)`.</span>
  4115 |     | <span class='neutral'>            mstore(0x00, 0x80e6a20b)</span>
  4116 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  4117 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  4118 |     | <span class='neutral'>            mstore(0x60, 0x80)</span>
  4119 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  4120 |     | <span class='neutral'>            writeString(0xa0, p2)</span>
  4121 |     | <span class='neutral'>        }</span>
  4122 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xc4);</span>
  4123 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  4124 |     | <span class='neutral'>        assembly {</span>
  4125 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  4126 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  4127 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  4128 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  4129 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  4130 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  4131 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
  4132 |     | <span class='neutral'>        }</span>
  4133 |     | <span class='neutral'>    }</span>
  4134 |     | <span class='neutral'></span>
  4135 |     | <span class='neutral'>    function log(address p0, bool p1, bytes32 p2, bytes32 p3) internal pure {</span>
  4136 |     | <span class='neutral'>        bytes32 m0;</span>
  4137 |     | <span class='neutral'>        bytes32 m1;</span>
  4138 |     | <span class='neutral'>        bytes32 m2;</span>
  4139 |     | <span class='neutral'>        bytes32 m3;</span>
  4140 |     | <span class='neutral'>        bytes32 m4;</span>
  4141 |     | <span class='neutral'>        bytes32 m5;</span>
  4142 |     | <span class='neutral'>        bytes32 m6;</span>
  4143 |     | <span class='neutral'>        bytes32 m7;</span>
  4144 |     | <span class='neutral'>        bytes32 m8;</span>
  4145 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  4146 |     | <span class='neutral'>        assembly {</span>
  4147 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  4148 |     | <span class='neutral'>                let length := 0</span>
  4149 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  4150 |     | <span class='neutral'>                mstore(pos, length)</span>
  4151 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  4152 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  4153 |     | <span class='neutral'>            }</span>
  4154 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  4155 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  4156 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  4157 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  4158 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  4159 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  4160 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
  4161 |     | <span class='neutral'>            m7 := mload(0xe0)</span>
  4162 |     | <span class='neutral'>            m8 := mload(0x100)</span>
  4163 |     | <span class='neutral'>            // Selector of `log(address,bool,string,string)`.</span>
  4164 |     | <span class='neutral'>            mstore(0x00, 0x475c5c33)</span>
  4165 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  4166 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  4167 |     | <span class='neutral'>            mstore(0x60, 0x80)</span>
  4168 |     | <span class='neutral'>            mstore(0x80, 0xc0)</span>
  4169 |     | <span class='neutral'>            writeString(0xa0, p2)</span>
  4170 |     | <span class='neutral'>            writeString(0xe0, p3)</span>
  4171 |     | <span class='neutral'>        }</span>
  4172 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x104);</span>
  4173 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  4174 |     | <span class='neutral'>        assembly {</span>
  4175 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  4176 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  4177 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  4178 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  4179 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  4180 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  4181 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
  4182 |     | <span class='neutral'>            mstore(0xe0, m7)</span>
  4183 |     | <span class='neutral'>            mstore(0x100, m8)</span>
  4184 |     | <span class='neutral'>        }</span>
  4185 |     | <span class='neutral'>    }</span>
  4186 |     | <span class='neutral'></span>
  4187 |     | <span class='neutral'>    function log(address p0, uint256 p1, address p2, address p3) internal pure {</span>
  4188 |     | <span class='neutral'>        bytes32 m0;</span>
  4189 |     | <span class='neutral'>        bytes32 m1;</span>
  4190 |     | <span class='neutral'>        bytes32 m2;</span>
  4191 |     | <span class='neutral'>        bytes32 m3;</span>
  4192 |     | <span class='neutral'>        bytes32 m4;</span>
  4193 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  4194 |     | <span class='neutral'>        assembly {</span>
  4195 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  4196 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  4197 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  4198 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  4199 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  4200 |     | <span class='neutral'>            // Selector of `log(address,uint256,address,address)`.</span>
  4201 |     | <span class='neutral'>            mstore(0x00, 0x478d1c62)</span>
  4202 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  4203 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  4204 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  4205 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  4206 |     | <span class='neutral'>        }</span>
  4207 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x84);</span>
  4208 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  4209 |     | <span class='neutral'>        assembly {</span>
  4210 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  4211 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  4212 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  4213 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  4214 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  4215 |     | <span class='neutral'>        }</span>
  4216 |     | <span class='neutral'>    }</span>
  4217 |     | <span class='neutral'></span>
  4218 |     | <span class='neutral'>    function log(address p0, uint256 p1, address p2, bool p3) internal pure {</span>
  4219 |     | <span class='neutral'>        bytes32 m0;</span>
  4220 |     | <span class='neutral'>        bytes32 m1;</span>
  4221 |     | <span class='neutral'>        bytes32 m2;</span>
  4222 |     | <span class='neutral'>        bytes32 m3;</span>
  4223 |     | <span class='neutral'>        bytes32 m4;</span>
  4224 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  4225 |     | <span class='neutral'>        assembly {</span>
  4226 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  4227 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  4228 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  4229 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  4230 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  4231 |     | <span class='neutral'>            // Selector of `log(address,uint256,address,bool)`.</span>
  4232 |     | <span class='neutral'>            mstore(0x00, 0xa1bcc9b3)</span>
  4233 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  4234 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  4235 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  4236 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  4237 |     | <span class='neutral'>        }</span>
  4238 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x84);</span>
  4239 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  4240 |     | <span class='neutral'>        assembly {</span>
  4241 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  4242 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  4243 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  4244 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  4245 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  4246 |     | <span class='neutral'>        }</span>
  4247 |     | <span class='neutral'>    }</span>
  4248 |     | <span class='neutral'></span>
  4249 |     | <span class='neutral'>    function log(address p0, uint256 p1, address p2, uint256 p3) internal pure {</span>
  4250 |     | <span class='neutral'>        bytes32 m0;</span>
  4251 |     | <span class='neutral'>        bytes32 m1;</span>
  4252 |     | <span class='neutral'>        bytes32 m2;</span>
  4253 |     | <span class='neutral'>        bytes32 m3;</span>
  4254 |     | <span class='neutral'>        bytes32 m4;</span>
  4255 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  4256 |     | <span class='neutral'>        assembly {</span>
  4257 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  4258 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  4259 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  4260 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  4261 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  4262 |     | <span class='neutral'>            // Selector of `log(address,uint256,address,uint256)`.</span>
  4263 |     | <span class='neutral'>            mstore(0x00, 0x100f650e)</span>
  4264 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  4265 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  4266 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  4267 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  4268 |     | <span class='neutral'>        }</span>
  4269 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x84);</span>
  4270 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  4271 |     | <span class='neutral'>        assembly {</span>
  4272 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  4273 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  4274 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  4275 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  4276 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  4277 |     | <span class='neutral'>        }</span>
  4278 |     | <span class='neutral'>    }</span>
  4279 |     | <span class='neutral'></span>
  4280 |     | <span class='neutral'>    function log(address p0, uint256 p1, address p2, bytes32 p3) internal pure {</span>
  4281 |     | <span class='neutral'>        bytes32 m0;</span>
  4282 |     | <span class='neutral'>        bytes32 m1;</span>
  4283 |     | <span class='neutral'>        bytes32 m2;</span>
  4284 |     | <span class='neutral'>        bytes32 m3;</span>
  4285 |     | <span class='neutral'>        bytes32 m4;</span>
  4286 |     | <span class='neutral'>        bytes32 m5;</span>
  4287 |     | <span class='neutral'>        bytes32 m6;</span>
  4288 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  4289 |     | <span class='neutral'>        assembly {</span>
  4290 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  4291 |     | <span class='neutral'>                let length := 0</span>
  4292 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  4293 |     | <span class='neutral'>                mstore(pos, length)</span>
  4294 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  4295 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  4296 |     | <span class='neutral'>            }</span>
  4297 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  4298 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  4299 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  4300 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  4301 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  4302 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  4303 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
  4304 |     | <span class='neutral'>            // Selector of `log(address,uint256,address,string)`.</span>
  4305 |     | <span class='neutral'>            mstore(0x00, 0x1da986ea)</span>
  4306 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  4307 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  4308 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  4309 |     | <span class='neutral'>            mstore(0x80, 0x80)</span>
  4310 |     | <span class='neutral'>            writeString(0xa0, p3)</span>
  4311 |     | <span class='neutral'>        }</span>
  4312 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xc4);</span>
  4313 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  4314 |     | <span class='neutral'>        assembly {</span>
  4315 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  4316 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  4317 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  4318 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  4319 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  4320 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  4321 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
  4322 |     | <span class='neutral'>        }</span>
  4323 |     | <span class='neutral'>    }</span>
  4324 |     | <span class='neutral'></span>
  4325 |     | <span class='neutral'>    function log(address p0, uint256 p1, bool p2, address p3) internal pure {</span>
  4326 |     | <span class='neutral'>        bytes32 m0;</span>
  4327 |     | <span class='neutral'>        bytes32 m1;</span>
  4328 |     | <span class='neutral'>        bytes32 m2;</span>
  4329 |     | <span class='neutral'>        bytes32 m3;</span>
  4330 |     | <span class='neutral'>        bytes32 m4;</span>
  4331 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  4332 |     | <span class='neutral'>        assembly {</span>
  4333 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  4334 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  4335 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  4336 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  4337 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  4338 |     | <span class='neutral'>            // Selector of `log(address,uint256,bool,address)`.</span>
  4339 |     | <span class='neutral'>            mstore(0x00, 0xa31bfdcc)</span>
  4340 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  4341 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  4342 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  4343 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  4344 |     | <span class='neutral'>        }</span>
  4345 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x84);</span>
  4346 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  4347 |     | <span class='neutral'>        assembly {</span>
  4348 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  4349 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  4350 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  4351 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  4352 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  4353 |     | <span class='neutral'>        }</span>
  4354 |     | <span class='neutral'>    }</span>
  4355 |     | <span class='neutral'></span>
  4356 |     | <span class='neutral'>    function log(address p0, uint256 p1, bool p2, bool p3) internal pure {</span>
  4357 |     | <span class='neutral'>        bytes32 m0;</span>
  4358 |     | <span class='neutral'>        bytes32 m1;</span>
  4359 |     | <span class='neutral'>        bytes32 m2;</span>
  4360 |     | <span class='neutral'>        bytes32 m3;</span>
  4361 |     | <span class='neutral'>        bytes32 m4;</span>
  4362 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  4363 |     | <span class='neutral'>        assembly {</span>
  4364 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  4365 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  4366 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  4367 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  4368 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  4369 |     | <span class='neutral'>            // Selector of `log(address,uint256,bool,bool)`.</span>
  4370 |     | <span class='neutral'>            mstore(0x00, 0x3bf5e537)</span>
  4371 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  4372 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  4373 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  4374 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  4375 |     | <span class='neutral'>        }</span>
  4376 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x84);</span>
  4377 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  4378 |     | <span class='neutral'>        assembly {</span>
  4379 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  4380 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  4381 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  4382 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  4383 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  4384 |     | <span class='neutral'>        }</span>
  4385 |     | <span class='neutral'>    }</span>
  4386 |     | <span class='neutral'></span>
  4387 |     | <span class='neutral'>    function log(address p0, uint256 p1, bool p2, uint256 p3) internal pure {</span>
  4388 |     | <span class='neutral'>        bytes32 m0;</span>
  4389 |     | <span class='neutral'>        bytes32 m1;</span>
  4390 |     | <span class='neutral'>        bytes32 m2;</span>
  4391 |     | <span class='neutral'>        bytes32 m3;</span>
  4392 |     | <span class='neutral'>        bytes32 m4;</span>
  4393 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  4394 |     | <span class='neutral'>        assembly {</span>
  4395 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  4396 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  4397 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  4398 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  4399 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  4400 |     | <span class='neutral'>            // Selector of `log(address,uint256,bool,uint256)`.</span>
  4401 |     | <span class='neutral'>            mstore(0x00, 0x22f6b999)</span>
  4402 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  4403 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  4404 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  4405 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  4406 |     | <span class='neutral'>        }</span>
  4407 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x84);</span>
  4408 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  4409 |     | <span class='neutral'>        assembly {</span>
  4410 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  4411 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  4412 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  4413 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  4414 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  4415 |     | <span class='neutral'>        }</span>
  4416 |     | <span class='neutral'>    }</span>
  4417 |     | <span class='neutral'></span>
  4418 |     | <span class='neutral'>    function log(address p0, uint256 p1, bool p2, bytes32 p3) internal pure {</span>
  4419 |     | <span class='neutral'>        bytes32 m0;</span>
  4420 |     | <span class='neutral'>        bytes32 m1;</span>
  4421 |     | <span class='neutral'>        bytes32 m2;</span>
  4422 |     | <span class='neutral'>        bytes32 m3;</span>
  4423 |     | <span class='neutral'>        bytes32 m4;</span>
  4424 |     | <span class='neutral'>        bytes32 m5;</span>
  4425 |     | <span class='neutral'>        bytes32 m6;</span>
  4426 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  4427 |     | <span class='neutral'>        assembly {</span>
  4428 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  4429 |     | <span class='neutral'>                let length := 0</span>
  4430 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  4431 |     | <span class='neutral'>                mstore(pos, length)</span>
  4432 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  4433 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  4434 |     | <span class='neutral'>            }</span>
  4435 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  4436 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  4437 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  4438 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  4439 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  4440 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  4441 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
  4442 |     | <span class='neutral'>            // Selector of `log(address,uint256,bool,string)`.</span>
  4443 |     | <span class='neutral'>            mstore(0x00, 0xc5ad85f9)</span>
  4444 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  4445 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  4446 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  4447 |     | <span class='neutral'>            mstore(0x80, 0x80)</span>
  4448 |     | <span class='neutral'>            writeString(0xa0, p3)</span>
  4449 |     | <span class='neutral'>        }</span>
  4450 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xc4);</span>
  4451 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  4452 |     | <span class='neutral'>        assembly {</span>
  4453 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  4454 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  4455 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  4456 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  4457 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  4458 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  4459 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
  4460 |     | <span class='neutral'>        }</span>
  4461 |     | <span class='neutral'>    }</span>
  4462 |     | <span class='neutral'></span>
  4463 |     | <span class='neutral'>    function log(address p0, uint256 p1, uint256 p2, address p3) internal pure {</span>
  4464 |     | <span class='neutral'>        bytes32 m0;</span>
  4465 |     | <span class='neutral'>        bytes32 m1;</span>
  4466 |     | <span class='neutral'>        bytes32 m2;</span>
  4467 |     | <span class='neutral'>        bytes32 m3;</span>
  4468 |     | <span class='neutral'>        bytes32 m4;</span>
  4469 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  4470 |     | <span class='neutral'>        assembly {</span>
  4471 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  4472 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  4473 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  4474 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  4475 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  4476 |     | <span class='neutral'>            // Selector of `log(address,uint256,uint256,address)`.</span>
  4477 |     | <span class='neutral'>            mstore(0x00, 0x20e3984d)</span>
  4478 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  4479 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  4480 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  4481 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  4482 |     | <span class='neutral'>        }</span>
  4483 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x84);</span>
  4484 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  4485 |     | <span class='neutral'>        assembly {</span>
  4486 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  4487 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  4488 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  4489 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  4490 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  4491 |     | <span class='neutral'>        }</span>
  4492 |     | <span class='neutral'>    }</span>
  4493 |     | <span class='neutral'></span>
  4494 |     | <span class='neutral'>    function log(address p0, uint256 p1, uint256 p2, bool p3) internal pure {</span>
  4495 |     | <span class='neutral'>        bytes32 m0;</span>
  4496 |     | <span class='neutral'>        bytes32 m1;</span>
  4497 |     | <span class='neutral'>        bytes32 m2;</span>
  4498 |     | <span class='neutral'>        bytes32 m3;</span>
  4499 |     | <span class='neutral'>        bytes32 m4;</span>
  4500 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  4501 |     | <span class='neutral'>        assembly {</span>
  4502 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  4503 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  4504 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  4505 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  4506 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  4507 |     | <span class='neutral'>            // Selector of `log(address,uint256,uint256,bool)`.</span>
  4508 |     | <span class='neutral'>            mstore(0x00, 0x66f1bc67)</span>
  4509 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  4510 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  4511 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  4512 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  4513 |     | <span class='neutral'>        }</span>
  4514 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x84);</span>
  4515 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  4516 |     | <span class='neutral'>        assembly {</span>
  4517 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  4518 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  4519 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  4520 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  4521 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  4522 |     | <span class='neutral'>        }</span>
  4523 |     | <span class='neutral'>    }</span>
  4524 |     | <span class='neutral'></span>
  4525 |     | <span class='neutral'>    function log(address p0, uint256 p1, uint256 p2, uint256 p3) internal pure {</span>
  4526 |     | <span class='neutral'>        bytes32 m0;</span>
  4527 |     | <span class='neutral'>        bytes32 m1;</span>
  4528 |     | <span class='neutral'>        bytes32 m2;</span>
  4529 |     | <span class='neutral'>        bytes32 m3;</span>
  4530 |     | <span class='neutral'>        bytes32 m4;</span>
  4531 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  4532 |     | <span class='neutral'>        assembly {</span>
  4533 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  4534 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  4535 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  4536 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  4537 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  4538 |     | <span class='neutral'>            // Selector of `log(address,uint256,uint256,uint256)`.</span>
  4539 |     | <span class='neutral'>            mstore(0x00, 0x34f0e636)</span>
  4540 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  4541 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  4542 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  4543 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  4544 |     | <span class='neutral'>        }</span>
  4545 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x84);</span>
  4546 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  4547 |     | <span class='neutral'>        assembly {</span>
  4548 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  4549 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  4550 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  4551 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  4552 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  4553 |     | <span class='neutral'>        }</span>
  4554 |     | <span class='neutral'>    }</span>
  4555 |     | <span class='neutral'></span>
  4556 |     | <span class='neutral'>    function log(address p0, uint256 p1, uint256 p2, bytes32 p3) internal pure {</span>
  4557 |     | <span class='neutral'>        bytes32 m0;</span>
  4558 |     | <span class='neutral'>        bytes32 m1;</span>
  4559 |     | <span class='neutral'>        bytes32 m2;</span>
  4560 |     | <span class='neutral'>        bytes32 m3;</span>
  4561 |     | <span class='neutral'>        bytes32 m4;</span>
  4562 |     | <span class='neutral'>        bytes32 m5;</span>
  4563 |     | <span class='neutral'>        bytes32 m6;</span>
  4564 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  4565 |     | <span class='neutral'>        assembly {</span>
  4566 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  4567 |     | <span class='neutral'>                let length := 0</span>
  4568 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  4569 |     | <span class='neutral'>                mstore(pos, length)</span>
  4570 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  4571 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  4572 |     | <span class='neutral'>            }</span>
  4573 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  4574 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  4575 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  4576 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  4577 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  4578 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  4579 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
  4580 |     | <span class='neutral'>            // Selector of `log(address,uint256,uint256,string)`.</span>
  4581 |     | <span class='neutral'>            mstore(0x00, 0x4a28c017)</span>
  4582 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  4583 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  4584 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  4585 |     | <span class='neutral'>            mstore(0x80, 0x80)</span>
  4586 |     | <span class='neutral'>            writeString(0xa0, p3)</span>
  4587 |     | <span class='neutral'>        }</span>
  4588 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xc4);</span>
  4589 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  4590 |     | <span class='neutral'>        assembly {</span>
  4591 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  4592 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  4593 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  4594 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  4595 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  4596 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  4597 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
  4598 |     | <span class='neutral'>        }</span>
  4599 |     | <span class='neutral'>    }</span>
  4600 |     | <span class='neutral'></span>
  4601 |     | <span class='neutral'>    function log(address p0, uint256 p1, bytes32 p2, address p3) internal pure {</span>
  4602 |     | <span class='neutral'>        bytes32 m0;</span>
  4603 |     | <span class='neutral'>        bytes32 m1;</span>
  4604 |     | <span class='neutral'>        bytes32 m2;</span>
  4605 |     | <span class='neutral'>        bytes32 m3;</span>
  4606 |     | <span class='neutral'>        bytes32 m4;</span>
  4607 |     | <span class='neutral'>        bytes32 m5;</span>
  4608 |     | <span class='neutral'>        bytes32 m6;</span>
  4609 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  4610 |     | <span class='neutral'>        assembly {</span>
  4611 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  4612 |     | <span class='neutral'>                let length := 0</span>
  4613 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  4614 |     | <span class='neutral'>                mstore(pos, length)</span>
  4615 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  4616 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  4617 |     | <span class='neutral'>            }</span>
  4618 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  4619 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  4620 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  4621 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  4622 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  4623 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  4624 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
  4625 |     | <span class='neutral'>            // Selector of `log(address,uint256,string,address)`.</span>
  4626 |     | <span class='neutral'>            mstore(0x00, 0x5c430d47)</span>
  4627 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  4628 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  4629 |     | <span class='neutral'>            mstore(0x60, 0x80)</span>
  4630 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  4631 |     | <span class='neutral'>            writeString(0xa0, p2)</span>
  4632 |     | <span class='neutral'>        }</span>
  4633 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xc4);</span>
  4634 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  4635 |     | <span class='neutral'>        assembly {</span>
  4636 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  4637 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  4638 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  4639 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  4640 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  4641 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  4642 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
  4643 |     | <span class='neutral'>        }</span>
  4644 |     | <span class='neutral'>    }</span>
  4645 |     | <span class='neutral'></span>
  4646 |     | <span class='neutral'>    function log(address p0, uint256 p1, bytes32 p2, bool p3) internal pure {</span>
  4647 |     | <span class='neutral'>        bytes32 m0;</span>
  4648 |     | <span class='neutral'>        bytes32 m1;</span>
  4649 |     | <span class='neutral'>        bytes32 m2;</span>
  4650 |     | <span class='neutral'>        bytes32 m3;</span>
  4651 |     | <span class='neutral'>        bytes32 m4;</span>
  4652 |     | <span class='neutral'>        bytes32 m5;</span>
  4653 |     | <span class='neutral'>        bytes32 m6;</span>
  4654 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  4655 |     | <span class='neutral'>        assembly {</span>
  4656 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  4657 |     | <span class='neutral'>                let length := 0</span>
  4658 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  4659 |     | <span class='neutral'>                mstore(pos, length)</span>
  4660 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  4661 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  4662 |     | <span class='neutral'>            }</span>
  4663 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  4664 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  4665 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  4666 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  4667 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  4668 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  4669 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
  4670 |     | <span class='neutral'>            // Selector of `log(address,uint256,string,bool)`.</span>
  4671 |     | <span class='neutral'>            mstore(0x00, 0xcf18105c)</span>
  4672 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  4673 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  4674 |     | <span class='neutral'>            mstore(0x60, 0x80)</span>
  4675 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  4676 |     | <span class='neutral'>            writeString(0xa0, p2)</span>
  4677 |     | <span class='neutral'>        }</span>
  4678 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xc4);</span>
  4679 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  4680 |     | <span class='neutral'>        assembly {</span>
  4681 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  4682 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  4683 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  4684 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  4685 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  4686 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  4687 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
  4688 |     | <span class='neutral'>        }</span>
  4689 |     | <span class='neutral'>    }</span>
  4690 |     | <span class='neutral'></span>
  4691 |     | <span class='neutral'>    function log(address p0, uint256 p1, bytes32 p2, uint256 p3) internal pure {</span>
  4692 |     | <span class='neutral'>        bytes32 m0;</span>
  4693 |     | <span class='neutral'>        bytes32 m1;</span>
  4694 |     | <span class='neutral'>        bytes32 m2;</span>
  4695 |     | <span class='neutral'>        bytes32 m3;</span>
  4696 |     | <span class='neutral'>        bytes32 m4;</span>
  4697 |     | <span class='neutral'>        bytes32 m5;</span>
  4698 |     | <span class='neutral'>        bytes32 m6;</span>
  4699 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  4700 |     | <span class='neutral'>        assembly {</span>
  4701 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  4702 |     | <span class='neutral'>                let length := 0</span>
  4703 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  4704 |     | <span class='neutral'>                mstore(pos, length)</span>
  4705 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  4706 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  4707 |     | <span class='neutral'>            }</span>
  4708 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  4709 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  4710 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  4711 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  4712 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  4713 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  4714 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
  4715 |     | <span class='neutral'>            // Selector of `log(address,uint256,string,uint256)`.</span>
  4716 |     | <span class='neutral'>            mstore(0x00, 0xbf01f891)</span>
  4717 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  4718 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  4719 |     | <span class='neutral'>            mstore(0x60, 0x80)</span>
  4720 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  4721 |     | <span class='neutral'>            writeString(0xa0, p2)</span>
  4722 |     | <span class='neutral'>        }</span>
  4723 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xc4);</span>
  4724 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  4725 |     | <span class='neutral'>        assembly {</span>
  4726 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  4727 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  4728 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  4729 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  4730 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  4731 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  4732 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
  4733 |     | <span class='neutral'>        }</span>
  4734 |     | <span class='neutral'>    }</span>
  4735 |     | <span class='neutral'></span>
  4736 |     | <span class='neutral'>    function log(address p0, uint256 p1, bytes32 p2, bytes32 p3) internal pure {</span>
  4737 |     | <span class='neutral'>        bytes32 m0;</span>
  4738 |     | <span class='neutral'>        bytes32 m1;</span>
  4739 |     | <span class='neutral'>        bytes32 m2;</span>
  4740 |     | <span class='neutral'>        bytes32 m3;</span>
  4741 |     | <span class='neutral'>        bytes32 m4;</span>
  4742 |     | <span class='neutral'>        bytes32 m5;</span>
  4743 |     | <span class='neutral'>        bytes32 m6;</span>
  4744 |     | <span class='neutral'>        bytes32 m7;</span>
  4745 |     | <span class='neutral'>        bytes32 m8;</span>
  4746 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  4747 |     | <span class='neutral'>        assembly {</span>
  4748 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  4749 |     | <span class='neutral'>                let length := 0</span>
  4750 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  4751 |     | <span class='neutral'>                mstore(pos, length)</span>
  4752 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  4753 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  4754 |     | <span class='neutral'>            }</span>
  4755 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  4756 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  4757 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  4758 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  4759 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  4760 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  4761 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
  4762 |     | <span class='neutral'>            m7 := mload(0xe0)</span>
  4763 |     | <span class='neutral'>            m8 := mload(0x100)</span>
  4764 |     | <span class='neutral'>            // Selector of `log(address,uint256,string,string)`.</span>
  4765 |     | <span class='neutral'>            mstore(0x00, 0x88a8c406)</span>
  4766 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  4767 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  4768 |     | <span class='neutral'>            mstore(0x60, 0x80)</span>
  4769 |     | <span class='neutral'>            mstore(0x80, 0xc0)</span>
  4770 |     | <span class='neutral'>            writeString(0xa0, p2)</span>
  4771 |     | <span class='neutral'>            writeString(0xe0, p3)</span>
  4772 |     | <span class='neutral'>        }</span>
  4773 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x104);</span>
  4774 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  4775 |     | <span class='neutral'>        assembly {</span>
  4776 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  4777 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  4778 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  4779 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  4780 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  4781 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  4782 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
  4783 |     | <span class='neutral'>            mstore(0xe0, m7)</span>
  4784 |     | <span class='neutral'>            mstore(0x100, m8)</span>
  4785 |     | <span class='neutral'>        }</span>
  4786 |     | <span class='neutral'>    }</span>
  4787 |     | <span class='neutral'></span>
  4788 |     | <span class='neutral'>    function log(address p0, bytes32 p1, address p2, address p3) internal pure {</span>
  4789 |     | <span class='neutral'>        bytes32 m0;</span>
  4790 |     | <span class='neutral'>        bytes32 m1;</span>
  4791 |     | <span class='neutral'>        bytes32 m2;</span>
  4792 |     | <span class='neutral'>        bytes32 m3;</span>
  4793 |     | <span class='neutral'>        bytes32 m4;</span>
  4794 |     | <span class='neutral'>        bytes32 m5;</span>
  4795 |     | <span class='neutral'>        bytes32 m6;</span>
  4796 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  4797 |     | <span class='neutral'>        assembly {</span>
  4798 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  4799 |     | <span class='neutral'>                let length := 0</span>
  4800 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  4801 |     | <span class='neutral'>                mstore(pos, length)</span>
  4802 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  4803 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  4804 |     | <span class='neutral'>            }</span>
  4805 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  4806 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  4807 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  4808 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  4809 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  4810 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  4811 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
  4812 |     | <span class='neutral'>            // Selector of `log(address,string,address,address)`.</span>
  4813 |     | <span class='neutral'>            mstore(0x00, 0x0d36fa20)</span>
  4814 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  4815 |     | <span class='neutral'>            mstore(0x40, 0x80)</span>
  4816 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  4817 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  4818 |     | <span class='neutral'>            writeString(0xa0, p1)</span>
  4819 |     | <span class='neutral'>        }</span>
  4820 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xc4);</span>
  4821 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  4822 |     | <span class='neutral'>        assembly {</span>
  4823 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  4824 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  4825 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  4826 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  4827 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  4828 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  4829 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
  4830 |     | <span class='neutral'>        }</span>
  4831 |     | <span class='neutral'>    }</span>
  4832 |     | <span class='neutral'></span>
  4833 |     | <span class='neutral'>    function log(address p0, bytes32 p1, address p2, bool p3) internal pure {</span>
  4834 |     | <span class='neutral'>        bytes32 m0;</span>
  4835 |     | <span class='neutral'>        bytes32 m1;</span>
  4836 |     | <span class='neutral'>        bytes32 m2;</span>
  4837 |     | <span class='neutral'>        bytes32 m3;</span>
  4838 |     | <span class='neutral'>        bytes32 m4;</span>
  4839 |     | <span class='neutral'>        bytes32 m5;</span>
  4840 |     | <span class='neutral'>        bytes32 m6;</span>
  4841 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  4842 |     | <span class='neutral'>        assembly {</span>
  4843 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  4844 |     | <span class='neutral'>                let length := 0</span>
  4845 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  4846 |     | <span class='neutral'>                mstore(pos, length)</span>
  4847 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  4848 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  4849 |     | <span class='neutral'>            }</span>
  4850 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  4851 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  4852 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  4853 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  4854 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  4855 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  4856 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
  4857 |     | <span class='neutral'>            // Selector of `log(address,string,address,bool)`.</span>
  4858 |     | <span class='neutral'>            mstore(0x00, 0x0df12b76)</span>
  4859 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  4860 |     | <span class='neutral'>            mstore(0x40, 0x80)</span>
  4861 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  4862 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  4863 |     | <span class='neutral'>            writeString(0xa0, p1)</span>
  4864 |     | <span class='neutral'>        }</span>
  4865 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xc4);</span>
  4866 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  4867 |     | <span class='neutral'>        assembly {</span>
  4868 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  4869 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  4870 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  4871 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  4872 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  4873 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  4874 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
  4875 |     | <span class='neutral'>        }</span>
  4876 |     | <span class='neutral'>    }</span>
  4877 |     | <span class='neutral'></span>
  4878 |     | <span class='neutral'>    function log(address p0, bytes32 p1, address p2, uint256 p3) internal pure {</span>
  4879 |     | <span class='neutral'>        bytes32 m0;</span>
  4880 |     | <span class='neutral'>        bytes32 m1;</span>
  4881 |     | <span class='neutral'>        bytes32 m2;</span>
  4882 |     | <span class='neutral'>        bytes32 m3;</span>
  4883 |     | <span class='neutral'>        bytes32 m4;</span>
  4884 |     | <span class='neutral'>        bytes32 m5;</span>
  4885 |     | <span class='neutral'>        bytes32 m6;</span>
  4886 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  4887 |     | <span class='neutral'>        assembly {</span>
  4888 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  4889 |     | <span class='neutral'>                let length := 0</span>
  4890 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  4891 |     | <span class='neutral'>                mstore(pos, length)</span>
  4892 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  4893 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  4894 |     | <span class='neutral'>            }</span>
  4895 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  4896 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  4897 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  4898 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  4899 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  4900 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  4901 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
  4902 |     | <span class='neutral'>            // Selector of `log(address,string,address,uint256)`.</span>
  4903 |     | <span class='neutral'>            mstore(0x00, 0x457fe3cf)</span>
  4904 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  4905 |     | <span class='neutral'>            mstore(0x40, 0x80)</span>
  4906 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  4907 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  4908 |     | <span class='neutral'>            writeString(0xa0, p1)</span>
  4909 |     | <span class='neutral'>        }</span>
  4910 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xc4);</span>
  4911 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  4912 |     | <span class='neutral'>        assembly {</span>
  4913 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  4914 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  4915 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  4916 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  4917 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  4918 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  4919 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
  4920 |     | <span class='neutral'>        }</span>
  4921 |     | <span class='neutral'>    }</span>
  4922 |     | <span class='neutral'></span>
  4923 |     | <span class='neutral'>    function log(address p0, bytes32 p1, address p2, bytes32 p3) internal pure {</span>
  4924 |     | <span class='neutral'>        bytes32 m0;</span>
  4925 |     | <span class='neutral'>        bytes32 m1;</span>
  4926 |     | <span class='neutral'>        bytes32 m2;</span>
  4927 |     | <span class='neutral'>        bytes32 m3;</span>
  4928 |     | <span class='neutral'>        bytes32 m4;</span>
  4929 |     | <span class='neutral'>        bytes32 m5;</span>
  4930 |     | <span class='neutral'>        bytes32 m6;</span>
  4931 |     | <span class='neutral'>        bytes32 m7;</span>
  4932 |     | <span class='neutral'>        bytes32 m8;</span>
  4933 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  4934 |     | <span class='neutral'>        assembly {</span>
  4935 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  4936 |     | <span class='neutral'>                let length := 0</span>
  4937 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  4938 |     | <span class='neutral'>                mstore(pos, length)</span>
  4939 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  4940 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  4941 |     | <span class='neutral'>            }</span>
  4942 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  4943 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  4944 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  4945 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  4946 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  4947 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  4948 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
  4949 |     | <span class='neutral'>            m7 := mload(0xe0)</span>
  4950 |     | <span class='neutral'>            m8 := mload(0x100)</span>
  4951 |     | <span class='neutral'>            // Selector of `log(address,string,address,string)`.</span>
  4952 |     | <span class='neutral'>            mstore(0x00, 0xf7e36245)</span>
  4953 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  4954 |     | <span class='neutral'>            mstore(0x40, 0x80)</span>
  4955 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  4956 |     | <span class='neutral'>            mstore(0x80, 0xc0)</span>
  4957 |     | <span class='neutral'>            writeString(0xa0, p1)</span>
  4958 |     | <span class='neutral'>            writeString(0xe0, p3)</span>
  4959 |     | <span class='neutral'>        }</span>
  4960 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x104);</span>
  4961 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  4962 |     | <span class='neutral'>        assembly {</span>
  4963 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  4964 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  4965 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  4966 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  4967 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  4968 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  4969 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
  4970 |     | <span class='neutral'>            mstore(0xe0, m7)</span>
  4971 |     | <span class='neutral'>            mstore(0x100, m8)</span>
  4972 |     | <span class='neutral'>        }</span>
  4973 |     | <span class='neutral'>    }</span>
  4974 |     | <span class='neutral'></span>
  4975 |     | <span class='neutral'>    function log(address p0, bytes32 p1, bool p2, address p3) internal pure {</span>
  4976 |     | <span class='neutral'>        bytes32 m0;</span>
  4977 |     | <span class='neutral'>        bytes32 m1;</span>
  4978 |     | <span class='neutral'>        bytes32 m2;</span>
  4979 |     | <span class='neutral'>        bytes32 m3;</span>
  4980 |     | <span class='neutral'>        bytes32 m4;</span>
  4981 |     | <span class='neutral'>        bytes32 m5;</span>
  4982 |     | <span class='neutral'>        bytes32 m6;</span>
  4983 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  4984 |     | <span class='neutral'>        assembly {</span>
  4985 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  4986 |     | <span class='neutral'>                let length := 0</span>
  4987 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  4988 |     | <span class='neutral'>                mstore(pos, length)</span>
  4989 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  4990 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  4991 |     | <span class='neutral'>            }</span>
  4992 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  4993 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  4994 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  4995 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  4996 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  4997 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  4998 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
  4999 |     | <span class='neutral'>            // Selector of `log(address,string,bool,address)`.</span>
  5000 |     | <span class='neutral'>            mstore(0x00, 0x205871c2)</span>
  5001 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  5002 |     | <span class='neutral'>            mstore(0x40, 0x80)</span>
  5003 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  5004 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  5005 |     | <span class='neutral'>            writeString(0xa0, p1)</span>
  5006 |     | <span class='neutral'>        }</span>
  5007 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xc4);</span>
  5008 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  5009 |     | <span class='neutral'>        assembly {</span>
  5010 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  5011 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  5012 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  5013 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  5014 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  5015 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  5016 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
  5017 |     | <span class='neutral'>        }</span>
  5018 |     | <span class='neutral'>    }</span>
  5019 |     | <span class='neutral'></span>
  5020 |     | <span class='neutral'>    function log(address p0, bytes32 p1, bool p2, bool p3) internal pure {</span>
  5021 |     | <span class='neutral'>        bytes32 m0;</span>
  5022 |     | <span class='neutral'>        bytes32 m1;</span>
  5023 |     | <span class='neutral'>        bytes32 m2;</span>
  5024 |     | <span class='neutral'>        bytes32 m3;</span>
  5025 |     | <span class='neutral'>        bytes32 m4;</span>
  5026 |     | <span class='neutral'>        bytes32 m5;</span>
  5027 |     | <span class='neutral'>        bytes32 m6;</span>
  5028 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  5029 |     | <span class='neutral'>        assembly {</span>
  5030 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  5031 |     | <span class='neutral'>                let length := 0</span>
  5032 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  5033 |     | <span class='neutral'>                mstore(pos, length)</span>
  5034 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  5035 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  5036 |     | <span class='neutral'>            }</span>
  5037 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  5038 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  5039 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  5040 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  5041 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  5042 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  5043 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
  5044 |     | <span class='neutral'>            // Selector of `log(address,string,bool,bool)`.</span>
  5045 |     | <span class='neutral'>            mstore(0x00, 0x5f1d5c9f)</span>
  5046 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  5047 |     | <span class='neutral'>            mstore(0x40, 0x80)</span>
  5048 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  5049 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  5050 |     | <span class='neutral'>            writeString(0xa0, p1)</span>
  5051 |     | <span class='neutral'>        }</span>
  5052 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xc4);</span>
  5053 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  5054 |     | <span class='neutral'>        assembly {</span>
  5055 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  5056 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  5057 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  5058 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  5059 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  5060 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  5061 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
  5062 |     | <span class='neutral'>        }</span>
  5063 |     | <span class='neutral'>    }</span>
  5064 |     | <span class='neutral'></span>
  5065 |     | <span class='neutral'>    function log(address p0, bytes32 p1, bool p2, uint256 p3) internal pure {</span>
  5066 |     | <span class='neutral'>        bytes32 m0;</span>
  5067 |     | <span class='neutral'>        bytes32 m1;</span>
  5068 |     | <span class='neutral'>        bytes32 m2;</span>
  5069 |     | <span class='neutral'>        bytes32 m3;</span>
  5070 |     | <span class='neutral'>        bytes32 m4;</span>
  5071 |     | <span class='neutral'>        bytes32 m5;</span>
  5072 |     | <span class='neutral'>        bytes32 m6;</span>
  5073 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  5074 |     | <span class='neutral'>        assembly {</span>
  5075 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  5076 |     | <span class='neutral'>                let length := 0</span>
  5077 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  5078 |     | <span class='neutral'>                mstore(pos, length)</span>
  5079 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  5080 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  5081 |     | <span class='neutral'>            }</span>
  5082 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  5083 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  5084 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  5085 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  5086 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  5087 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  5088 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
  5089 |     | <span class='neutral'>            // Selector of `log(address,string,bool,uint256)`.</span>
  5090 |     | <span class='neutral'>            mstore(0x00, 0x515e38b6)</span>
  5091 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  5092 |     | <span class='neutral'>            mstore(0x40, 0x80)</span>
  5093 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  5094 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  5095 |     | <span class='neutral'>            writeString(0xa0, p1)</span>
  5096 |     | <span class='neutral'>        }</span>
  5097 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xc4);</span>
  5098 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  5099 |     | <span class='neutral'>        assembly {</span>
  5100 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  5101 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  5102 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  5103 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  5104 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  5105 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  5106 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
  5107 |     | <span class='neutral'>        }</span>
  5108 |     | <span class='neutral'>    }</span>
  5109 |     | <span class='neutral'></span>
  5110 |     | <span class='neutral'>    function log(address p0, bytes32 p1, bool p2, bytes32 p3) internal pure {</span>
  5111 |     | <span class='neutral'>        bytes32 m0;</span>
  5112 |     | <span class='neutral'>        bytes32 m1;</span>
  5113 |     | <span class='neutral'>        bytes32 m2;</span>
  5114 |     | <span class='neutral'>        bytes32 m3;</span>
  5115 |     | <span class='neutral'>        bytes32 m4;</span>
  5116 |     | <span class='neutral'>        bytes32 m5;</span>
  5117 |     | <span class='neutral'>        bytes32 m6;</span>
  5118 |     | <span class='neutral'>        bytes32 m7;</span>
  5119 |     | <span class='neutral'>        bytes32 m8;</span>
  5120 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  5121 |     | <span class='neutral'>        assembly {</span>
  5122 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  5123 |     | <span class='neutral'>                let length := 0</span>
  5124 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  5125 |     | <span class='neutral'>                mstore(pos, length)</span>
  5126 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  5127 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  5128 |     | <span class='neutral'>            }</span>
  5129 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  5130 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  5131 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  5132 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  5133 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  5134 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  5135 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
  5136 |     | <span class='neutral'>            m7 := mload(0xe0)</span>
  5137 |     | <span class='neutral'>            m8 := mload(0x100)</span>
  5138 |     | <span class='neutral'>            // Selector of `log(address,string,bool,string)`.</span>
  5139 |     | <span class='neutral'>            mstore(0x00, 0xbc0b61fe)</span>
  5140 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  5141 |     | <span class='neutral'>            mstore(0x40, 0x80)</span>
  5142 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  5143 |     | <span class='neutral'>            mstore(0x80, 0xc0)</span>
  5144 |     | <span class='neutral'>            writeString(0xa0, p1)</span>
  5145 |     | <span class='neutral'>            writeString(0xe0, p3)</span>
  5146 |     | <span class='neutral'>        }</span>
  5147 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x104);</span>
  5148 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  5149 |     | <span class='neutral'>        assembly {</span>
  5150 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  5151 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  5152 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  5153 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  5154 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  5155 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  5156 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
  5157 |     | <span class='neutral'>            mstore(0xe0, m7)</span>
  5158 |     | <span class='neutral'>            mstore(0x100, m8)</span>
  5159 |     | <span class='neutral'>        }</span>
  5160 |     | <span class='neutral'>    }</span>
  5161 |     | <span class='neutral'></span>
  5162 |     | <span class='neutral'>    function log(address p0, bytes32 p1, uint256 p2, address p3) internal pure {</span>
  5163 |     | <span class='neutral'>        bytes32 m0;</span>
  5164 |     | <span class='neutral'>        bytes32 m1;</span>
  5165 |     | <span class='neutral'>        bytes32 m2;</span>
  5166 |     | <span class='neutral'>        bytes32 m3;</span>
  5167 |     | <span class='neutral'>        bytes32 m4;</span>
  5168 |     | <span class='neutral'>        bytes32 m5;</span>
  5169 |     | <span class='neutral'>        bytes32 m6;</span>
  5170 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  5171 |     | <span class='neutral'>        assembly {</span>
  5172 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  5173 |     | <span class='neutral'>                let length := 0</span>
  5174 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  5175 |     | <span class='neutral'>                mstore(pos, length)</span>
  5176 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  5177 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  5178 |     | <span class='neutral'>            }</span>
  5179 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  5180 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  5181 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  5182 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  5183 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  5184 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  5185 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
  5186 |     | <span class='neutral'>            // Selector of `log(address,string,uint256,address)`.</span>
  5187 |     | <span class='neutral'>            mstore(0x00, 0x63183678)</span>
  5188 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  5189 |     | <span class='neutral'>            mstore(0x40, 0x80)</span>
  5190 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  5191 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  5192 |     | <span class='neutral'>            writeString(0xa0, p1)</span>
  5193 |     | <span class='neutral'>        }</span>
  5194 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xc4);</span>
  5195 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  5196 |     | <span class='neutral'>        assembly {</span>
  5197 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  5198 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  5199 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  5200 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  5201 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  5202 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  5203 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
  5204 |     | <span class='neutral'>        }</span>
  5205 |     | <span class='neutral'>    }</span>
  5206 |     | <span class='neutral'></span>
  5207 |     | <span class='neutral'>    function log(address p0, bytes32 p1, uint256 p2, bool p3) internal pure {</span>
  5208 |     | <span class='neutral'>        bytes32 m0;</span>
  5209 |     | <span class='neutral'>        bytes32 m1;</span>
  5210 |     | <span class='neutral'>        bytes32 m2;</span>
  5211 |     | <span class='neutral'>        bytes32 m3;</span>
  5212 |     | <span class='neutral'>        bytes32 m4;</span>
  5213 |     | <span class='neutral'>        bytes32 m5;</span>
  5214 |     | <span class='neutral'>        bytes32 m6;</span>
  5215 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  5216 |     | <span class='neutral'>        assembly {</span>
  5217 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  5218 |     | <span class='neutral'>                let length := 0</span>
  5219 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  5220 |     | <span class='neutral'>                mstore(pos, length)</span>
  5221 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  5222 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  5223 |     | <span class='neutral'>            }</span>
  5224 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  5225 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  5226 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  5227 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  5228 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  5229 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  5230 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
  5231 |     | <span class='neutral'>            // Selector of `log(address,string,uint256,bool)`.</span>
  5232 |     | <span class='neutral'>            mstore(0x00, 0x0ef7e050)</span>
  5233 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  5234 |     | <span class='neutral'>            mstore(0x40, 0x80)</span>
  5235 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  5236 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  5237 |     | <span class='neutral'>            writeString(0xa0, p1)</span>
  5238 |     | <span class='neutral'>        }</span>
  5239 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xc4);</span>
  5240 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  5241 |     | <span class='neutral'>        assembly {</span>
  5242 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  5243 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  5244 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  5245 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  5246 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  5247 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  5248 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
  5249 |     | <span class='neutral'>        }</span>
  5250 |     | <span class='neutral'>    }</span>
  5251 |     | <span class='neutral'></span>
  5252 |     | <span class='neutral'>    function log(address p0, bytes32 p1, uint256 p2, uint256 p3) internal pure {</span>
  5253 |     | <span class='neutral'>        bytes32 m0;</span>
  5254 |     | <span class='neutral'>        bytes32 m1;</span>
  5255 |     | <span class='neutral'>        bytes32 m2;</span>
  5256 |     | <span class='neutral'>        bytes32 m3;</span>
  5257 |     | <span class='neutral'>        bytes32 m4;</span>
  5258 |     | <span class='neutral'>        bytes32 m5;</span>
  5259 |     | <span class='neutral'>        bytes32 m6;</span>
  5260 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  5261 |     | <span class='neutral'>        assembly {</span>
  5262 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  5263 |     | <span class='neutral'>                let length := 0</span>
  5264 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  5265 |     | <span class='neutral'>                mstore(pos, length)</span>
  5266 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  5267 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  5268 |     | <span class='neutral'>            }</span>
  5269 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  5270 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  5271 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  5272 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  5273 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  5274 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  5275 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
  5276 |     | <span class='neutral'>            // Selector of `log(address,string,uint256,uint256)`.</span>
  5277 |     | <span class='neutral'>            mstore(0x00, 0x1dc8e1b8)</span>
  5278 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  5279 |     | <span class='neutral'>            mstore(0x40, 0x80)</span>
  5280 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  5281 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  5282 |     | <span class='neutral'>            writeString(0xa0, p1)</span>
  5283 |     | <span class='neutral'>        }</span>
  5284 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xc4);</span>
  5285 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  5286 |     | <span class='neutral'>        assembly {</span>
  5287 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  5288 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  5289 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  5290 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  5291 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  5292 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  5293 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
  5294 |     | <span class='neutral'>        }</span>
  5295 |     | <span class='neutral'>    }</span>
  5296 |     | <span class='neutral'></span>
  5297 |     | <span class='neutral'>    function log(address p0, bytes32 p1, uint256 p2, bytes32 p3) internal pure {</span>
  5298 |     | <span class='neutral'>        bytes32 m0;</span>
  5299 |     | <span class='neutral'>        bytes32 m1;</span>
  5300 |     | <span class='neutral'>        bytes32 m2;</span>
  5301 |     | <span class='neutral'>        bytes32 m3;</span>
  5302 |     | <span class='neutral'>        bytes32 m4;</span>
  5303 |     | <span class='neutral'>        bytes32 m5;</span>
  5304 |     | <span class='neutral'>        bytes32 m6;</span>
  5305 |     | <span class='neutral'>        bytes32 m7;</span>
  5306 |     | <span class='neutral'>        bytes32 m8;</span>
  5307 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  5308 |     | <span class='neutral'>        assembly {</span>
  5309 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  5310 |     | <span class='neutral'>                let length := 0</span>
  5311 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  5312 |     | <span class='neutral'>                mstore(pos, length)</span>
  5313 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  5314 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  5315 |     | <span class='neutral'>            }</span>
  5316 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  5317 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  5318 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  5319 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  5320 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  5321 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  5322 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
  5323 |     | <span class='neutral'>            m7 := mload(0xe0)</span>
  5324 |     | <span class='neutral'>            m8 := mload(0x100)</span>
  5325 |     | <span class='neutral'>            // Selector of `log(address,string,uint256,string)`.</span>
  5326 |     | <span class='neutral'>            mstore(0x00, 0x448830a8)</span>
  5327 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  5328 |     | <span class='neutral'>            mstore(0x40, 0x80)</span>
  5329 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  5330 |     | <span class='neutral'>            mstore(0x80, 0xc0)</span>
  5331 |     | <span class='neutral'>            writeString(0xa0, p1)</span>
  5332 |     | <span class='neutral'>            writeString(0xe0, p3)</span>
  5333 |     | <span class='neutral'>        }</span>
  5334 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x104);</span>
  5335 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  5336 |     | <span class='neutral'>        assembly {</span>
  5337 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  5338 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  5339 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  5340 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  5341 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  5342 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  5343 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
  5344 |     | <span class='neutral'>            mstore(0xe0, m7)</span>
  5345 |     | <span class='neutral'>            mstore(0x100, m8)</span>
  5346 |     | <span class='neutral'>        }</span>
  5347 |     | <span class='neutral'>    }</span>
  5348 |     | <span class='neutral'></span>
  5349 |     | <span class='neutral'>    function log(address p0, bytes32 p1, bytes32 p2, address p3) internal pure {</span>
  5350 |     | <span class='neutral'>        bytes32 m0;</span>
  5351 |     | <span class='neutral'>        bytes32 m1;</span>
  5352 |     | <span class='neutral'>        bytes32 m2;</span>
  5353 |     | <span class='neutral'>        bytes32 m3;</span>
  5354 |     | <span class='neutral'>        bytes32 m4;</span>
  5355 |     | <span class='neutral'>        bytes32 m5;</span>
  5356 |     | <span class='neutral'>        bytes32 m6;</span>
  5357 |     | <span class='neutral'>        bytes32 m7;</span>
  5358 |     | <span class='neutral'>        bytes32 m8;</span>
  5359 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  5360 |     | <span class='neutral'>        assembly {</span>
  5361 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  5362 |     | <span class='neutral'>                let length := 0</span>
  5363 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  5364 |     | <span class='neutral'>                mstore(pos, length)</span>
  5365 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  5366 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  5367 |     | <span class='neutral'>            }</span>
  5368 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  5369 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  5370 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  5371 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  5372 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  5373 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  5374 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
  5375 |     | <span class='neutral'>            m7 := mload(0xe0)</span>
  5376 |     | <span class='neutral'>            m8 := mload(0x100)</span>
  5377 |     | <span class='neutral'>            // Selector of `log(address,string,string,address)`.</span>
  5378 |     | <span class='neutral'>            mstore(0x00, 0xa04e2f87)</span>
  5379 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  5380 |     | <span class='neutral'>            mstore(0x40, 0x80)</span>
  5381 |     | <span class='neutral'>            mstore(0x60, 0xc0)</span>
  5382 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  5383 |     | <span class='neutral'>            writeString(0xa0, p1)</span>
  5384 |     | <span class='neutral'>            writeString(0xe0, p2)</span>
  5385 |     | <span class='neutral'>        }</span>
  5386 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x104);</span>
  5387 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  5388 |     | <span class='neutral'>        assembly {</span>
  5389 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  5390 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  5391 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  5392 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  5393 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  5394 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  5395 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
  5396 |     | <span class='neutral'>            mstore(0xe0, m7)</span>
  5397 |     | <span class='neutral'>            mstore(0x100, m8)</span>
  5398 |     | <span class='neutral'>        }</span>
  5399 |     | <span class='neutral'>    }</span>
  5400 |     | <span class='neutral'></span>
  5401 |     | <span class='neutral'>    function log(address p0, bytes32 p1, bytes32 p2, bool p3) internal pure {</span>
  5402 |     | <span class='neutral'>        bytes32 m0;</span>
  5403 |     | <span class='neutral'>        bytes32 m1;</span>
  5404 |     | <span class='neutral'>        bytes32 m2;</span>
  5405 |     | <span class='neutral'>        bytes32 m3;</span>
  5406 |     | <span class='neutral'>        bytes32 m4;</span>
  5407 |     | <span class='neutral'>        bytes32 m5;</span>
  5408 |     | <span class='neutral'>        bytes32 m6;</span>
  5409 |     | <span class='neutral'>        bytes32 m7;</span>
  5410 |     | <span class='neutral'>        bytes32 m8;</span>
  5411 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  5412 |     | <span class='neutral'>        assembly {</span>
  5413 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  5414 |     | <span class='neutral'>                let length := 0</span>
  5415 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  5416 |     | <span class='neutral'>                mstore(pos, length)</span>
  5417 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  5418 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  5419 |     | <span class='neutral'>            }</span>
  5420 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  5421 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  5422 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  5423 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  5424 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  5425 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  5426 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
  5427 |     | <span class='neutral'>            m7 := mload(0xe0)</span>
  5428 |     | <span class='neutral'>            m8 := mload(0x100)</span>
  5429 |     | <span class='neutral'>            // Selector of `log(address,string,string,bool)`.</span>
  5430 |     | <span class='neutral'>            mstore(0x00, 0x35a5071f)</span>
  5431 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  5432 |     | <span class='neutral'>            mstore(0x40, 0x80)</span>
  5433 |     | <span class='neutral'>            mstore(0x60, 0xc0)</span>
  5434 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  5435 |     | <span class='neutral'>            writeString(0xa0, p1)</span>
  5436 |     | <span class='neutral'>            writeString(0xe0, p2)</span>
  5437 |     | <span class='neutral'>        }</span>
  5438 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x104);</span>
  5439 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  5440 |     | <span class='neutral'>        assembly {</span>
  5441 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  5442 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  5443 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  5444 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  5445 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  5446 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  5447 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
  5448 |     | <span class='neutral'>            mstore(0xe0, m7)</span>
  5449 |     | <span class='neutral'>            mstore(0x100, m8)</span>
  5450 |     | <span class='neutral'>        }</span>
  5451 |     | <span class='neutral'>    }</span>
  5452 |     | <span class='neutral'></span>
  5453 |     | <span class='neutral'>    function log(address p0, bytes32 p1, bytes32 p2, uint256 p3) internal pure {</span>
  5454 |     | <span class='neutral'>        bytes32 m0;</span>
  5455 |     | <span class='neutral'>        bytes32 m1;</span>
  5456 |     | <span class='neutral'>        bytes32 m2;</span>
  5457 |     | <span class='neutral'>        bytes32 m3;</span>
  5458 |     | <span class='neutral'>        bytes32 m4;</span>
  5459 |     | <span class='neutral'>        bytes32 m5;</span>
  5460 |     | <span class='neutral'>        bytes32 m6;</span>
  5461 |     | <span class='neutral'>        bytes32 m7;</span>
  5462 |     | <span class='neutral'>        bytes32 m8;</span>
  5463 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  5464 |     | <span class='neutral'>        assembly {</span>
  5465 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  5466 |     | <span class='neutral'>                let length := 0</span>
  5467 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  5468 |     | <span class='neutral'>                mstore(pos, length)</span>
  5469 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  5470 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  5471 |     | <span class='neutral'>            }</span>
  5472 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  5473 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  5474 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  5475 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  5476 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  5477 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  5478 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
  5479 |     | <span class='neutral'>            m7 := mload(0xe0)</span>
  5480 |     | <span class='neutral'>            m8 := mload(0x100)</span>
  5481 |     | <span class='neutral'>            // Selector of `log(address,string,string,uint256)`.</span>
  5482 |     | <span class='neutral'>            mstore(0x00, 0x159f8927)</span>
  5483 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  5484 |     | <span class='neutral'>            mstore(0x40, 0x80)</span>
  5485 |     | <span class='neutral'>            mstore(0x60, 0xc0)</span>
  5486 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  5487 |     | <span class='neutral'>            writeString(0xa0, p1)</span>
  5488 |     | <span class='neutral'>            writeString(0xe0, p2)</span>
  5489 |     | <span class='neutral'>        }</span>
  5490 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x104);</span>
  5491 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  5492 |     | <span class='neutral'>        assembly {</span>
  5493 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  5494 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  5495 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  5496 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  5497 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  5498 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  5499 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
  5500 |     | <span class='neutral'>            mstore(0xe0, m7)</span>
  5501 |     | <span class='neutral'>            mstore(0x100, m8)</span>
  5502 |     | <span class='neutral'>        }</span>
  5503 |     | <span class='neutral'>    }</span>
  5504 |     | <span class='neutral'></span>
  5505 |     | <span class='neutral'>    function log(address p0, bytes32 p1, bytes32 p2, bytes32 p3) internal pure {</span>
  5506 |     | <span class='neutral'>        bytes32 m0;</span>
  5507 |     | <span class='neutral'>        bytes32 m1;</span>
  5508 |     | <span class='neutral'>        bytes32 m2;</span>
  5509 |     | <span class='neutral'>        bytes32 m3;</span>
  5510 |     | <span class='neutral'>        bytes32 m4;</span>
  5511 |     | <span class='neutral'>        bytes32 m5;</span>
  5512 |     | <span class='neutral'>        bytes32 m6;</span>
  5513 |     | <span class='neutral'>        bytes32 m7;</span>
  5514 |     | <span class='neutral'>        bytes32 m8;</span>
  5515 |     | <span class='neutral'>        bytes32 m9;</span>
  5516 |     | <span class='neutral'>        bytes32 m10;</span>
  5517 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  5518 |     | <span class='neutral'>        assembly {</span>
  5519 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  5520 |     | <span class='neutral'>                let length := 0</span>
  5521 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  5522 |     | <span class='neutral'>                mstore(pos, length)</span>
  5523 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  5524 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  5525 |     | <span class='neutral'>            }</span>
  5526 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  5527 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  5528 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  5529 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  5530 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  5531 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  5532 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
  5533 |     | <span class='neutral'>            m7 := mload(0xe0)</span>
  5534 |     | <span class='neutral'>            m8 := mload(0x100)</span>
  5535 |     | <span class='neutral'>            m9 := mload(0x120)</span>
  5536 |     | <span class='neutral'>            m10 := mload(0x140)</span>
  5537 |     | <span class='neutral'>            // Selector of `log(address,string,string,string)`.</span>
  5538 |     | <span class='neutral'>            mstore(0x00, 0x5d02c50b)</span>
  5539 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  5540 |     | <span class='neutral'>            mstore(0x40, 0x80)</span>
  5541 |     | <span class='neutral'>            mstore(0x60, 0xc0)</span>
  5542 |     | <span class='neutral'>            mstore(0x80, 0x100)</span>
  5543 |     | <span class='neutral'>            writeString(0xa0, p1)</span>
  5544 |     | <span class='neutral'>            writeString(0xe0, p2)</span>
  5545 |     | <span class='neutral'>            writeString(0x120, p3)</span>
  5546 |     | <span class='neutral'>        }</span>
  5547 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x144);</span>
  5548 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  5549 |     | <span class='neutral'>        assembly {</span>
  5550 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  5551 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  5552 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  5553 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  5554 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  5555 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  5556 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
  5557 |     | <span class='neutral'>            mstore(0xe0, m7)</span>
  5558 |     | <span class='neutral'>            mstore(0x100, m8)</span>
  5559 |     | <span class='neutral'>            mstore(0x120, m9)</span>
  5560 |     | <span class='neutral'>            mstore(0x140, m10)</span>
  5561 |     | <span class='neutral'>        }</span>
  5562 |     | <span class='neutral'>    }</span>
  5563 |     | <span class='neutral'></span>
  5564 |     | <span class='neutral'>    function log(bool p0, address p1, address p2, address p3) internal pure {</span>
  5565 |     | <span class='neutral'>        bytes32 m0;</span>
  5566 |     | <span class='neutral'>        bytes32 m1;</span>
  5567 |     | <span class='neutral'>        bytes32 m2;</span>
  5568 |     | <span class='neutral'>        bytes32 m3;</span>
  5569 |     | <span class='neutral'>        bytes32 m4;</span>
  5570 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  5571 |     | <span class='neutral'>        assembly {</span>
  5572 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  5573 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  5574 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  5575 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  5576 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  5577 |     | <span class='neutral'>            // Selector of `log(bool,address,address,address)`.</span>
  5578 |     | <span class='neutral'>            mstore(0x00, 0x1d14d001)</span>
  5579 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  5580 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  5581 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  5582 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  5583 |     | <span class='neutral'>        }</span>
  5584 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x84);</span>
  5585 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  5586 |     | <span class='neutral'>        assembly {</span>
  5587 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  5588 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  5589 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  5590 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  5591 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  5592 |     | <span class='neutral'>        }</span>
  5593 |     | <span class='neutral'>    }</span>
  5594 |     | <span class='neutral'></span>
  5595 |     | <span class='neutral'>    function log(bool p0, address p1, address p2, bool p3) internal pure {</span>
  5596 |     | <span class='neutral'>        bytes32 m0;</span>
  5597 |     | <span class='neutral'>        bytes32 m1;</span>
  5598 |     | <span class='neutral'>        bytes32 m2;</span>
  5599 |     | <span class='neutral'>        bytes32 m3;</span>
  5600 |     | <span class='neutral'>        bytes32 m4;</span>
  5601 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  5602 |     | <span class='neutral'>        assembly {</span>
  5603 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  5604 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  5605 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  5606 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  5607 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  5608 |     | <span class='neutral'>            // Selector of `log(bool,address,address,bool)`.</span>
  5609 |     | <span class='neutral'>            mstore(0x00, 0x46600be0)</span>
  5610 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  5611 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  5612 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  5613 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  5614 |     | <span class='neutral'>        }</span>
  5615 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x84);</span>
  5616 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  5617 |     | <span class='neutral'>        assembly {</span>
  5618 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  5619 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  5620 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  5621 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  5622 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  5623 |     | <span class='neutral'>        }</span>
  5624 |     | <span class='neutral'>    }</span>
  5625 |     | <span class='neutral'></span>
  5626 |     | <span class='neutral'>    function log(bool p0, address p1, address p2, uint256 p3) internal pure {</span>
  5627 |     | <span class='neutral'>        bytes32 m0;</span>
  5628 |     | <span class='neutral'>        bytes32 m1;</span>
  5629 |     | <span class='neutral'>        bytes32 m2;</span>
  5630 |     | <span class='neutral'>        bytes32 m3;</span>
  5631 |     | <span class='neutral'>        bytes32 m4;</span>
  5632 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  5633 |     | <span class='neutral'>        assembly {</span>
  5634 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  5635 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  5636 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  5637 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  5638 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  5639 |     | <span class='neutral'>            // Selector of `log(bool,address,address,uint256)`.</span>
  5640 |     | <span class='neutral'>            mstore(0x00, 0x0c66d1be)</span>
  5641 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  5642 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  5643 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  5644 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  5645 |     | <span class='neutral'>        }</span>
  5646 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x84);</span>
  5647 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  5648 |     | <span class='neutral'>        assembly {</span>
  5649 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  5650 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  5651 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  5652 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  5653 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  5654 |     | <span class='neutral'>        }</span>
  5655 |     | <span class='neutral'>    }</span>
  5656 |     | <span class='neutral'></span>
  5657 |     | <span class='neutral'>    function log(bool p0, address p1, address p2, bytes32 p3) internal pure {</span>
  5658 |     | <span class='neutral'>        bytes32 m0;</span>
  5659 |     | <span class='neutral'>        bytes32 m1;</span>
  5660 |     | <span class='neutral'>        bytes32 m2;</span>
  5661 |     | <span class='neutral'>        bytes32 m3;</span>
  5662 |     | <span class='neutral'>        bytes32 m4;</span>
  5663 |     | <span class='neutral'>        bytes32 m5;</span>
  5664 |     | <span class='neutral'>        bytes32 m6;</span>
  5665 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  5666 |     | <span class='neutral'>        assembly {</span>
  5667 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  5668 |     | <span class='neutral'>                let length := 0</span>
  5669 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  5670 |     | <span class='neutral'>                mstore(pos, length)</span>
  5671 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  5672 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  5673 |     | <span class='neutral'>            }</span>
  5674 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  5675 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  5676 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  5677 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  5678 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  5679 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  5680 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
  5681 |     | <span class='neutral'>            // Selector of `log(bool,address,address,string)`.</span>
  5682 |     | <span class='neutral'>            mstore(0x00, 0xd812a167)</span>
  5683 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  5684 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  5685 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  5686 |     | <span class='neutral'>            mstore(0x80, 0x80)</span>
  5687 |     | <span class='neutral'>            writeString(0xa0, p3)</span>
  5688 |     | <span class='neutral'>        }</span>
  5689 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xc4);</span>
  5690 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  5691 |     | <span class='neutral'>        assembly {</span>
  5692 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  5693 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  5694 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  5695 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  5696 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  5697 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  5698 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
  5699 |     | <span class='neutral'>        }</span>
  5700 |     | <span class='neutral'>    }</span>
  5701 |     | <span class='neutral'></span>
  5702 |     | <span class='neutral'>    function log(bool p0, address p1, bool p2, address p3) internal pure {</span>
  5703 |     | <span class='neutral'>        bytes32 m0;</span>
  5704 |     | <span class='neutral'>        bytes32 m1;</span>
  5705 |     | <span class='neutral'>        bytes32 m2;</span>
  5706 |     | <span class='neutral'>        bytes32 m3;</span>
  5707 |     | <span class='neutral'>        bytes32 m4;</span>
  5708 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  5709 |     | <span class='neutral'>        assembly {</span>
  5710 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  5711 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  5712 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  5713 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  5714 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  5715 |     | <span class='neutral'>            // Selector of `log(bool,address,bool,address)`.</span>
  5716 |     | <span class='neutral'>            mstore(0x00, 0x1c41a336)</span>
  5717 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  5718 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  5719 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  5720 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  5721 |     | <span class='neutral'>        }</span>
  5722 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x84);</span>
  5723 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  5724 |     | <span class='neutral'>        assembly {</span>
  5725 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  5726 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  5727 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  5728 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  5729 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  5730 |     | <span class='neutral'>        }</span>
  5731 |     | <span class='neutral'>    }</span>
  5732 |     | <span class='neutral'></span>
  5733 |     | <span class='neutral'>    function log(bool p0, address p1, bool p2, bool p3) internal pure {</span>
  5734 |     | <span class='neutral'>        bytes32 m0;</span>
  5735 |     | <span class='neutral'>        bytes32 m1;</span>
  5736 |     | <span class='neutral'>        bytes32 m2;</span>
  5737 |     | <span class='neutral'>        bytes32 m3;</span>
  5738 |     | <span class='neutral'>        bytes32 m4;</span>
  5739 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  5740 |     | <span class='neutral'>        assembly {</span>
  5741 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  5742 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  5743 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  5744 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  5745 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  5746 |     | <span class='neutral'>            // Selector of `log(bool,address,bool,bool)`.</span>
  5747 |     | <span class='neutral'>            mstore(0x00, 0x6a9c478b)</span>
  5748 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  5749 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  5750 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  5751 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  5752 |     | <span class='neutral'>        }</span>
  5753 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x84);</span>
  5754 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  5755 |     | <span class='neutral'>        assembly {</span>
  5756 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  5757 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  5758 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  5759 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  5760 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  5761 |     | <span class='neutral'>        }</span>
  5762 |     | <span class='neutral'>    }</span>
  5763 |     | <span class='neutral'></span>
  5764 |     | <span class='neutral'>    function log(bool p0, address p1, bool p2, uint256 p3) internal pure {</span>
  5765 |     | <span class='neutral'>        bytes32 m0;</span>
  5766 |     | <span class='neutral'>        bytes32 m1;</span>
  5767 |     | <span class='neutral'>        bytes32 m2;</span>
  5768 |     | <span class='neutral'>        bytes32 m3;</span>
  5769 |     | <span class='neutral'>        bytes32 m4;</span>
  5770 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  5771 |     | <span class='neutral'>        assembly {</span>
  5772 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  5773 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  5774 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  5775 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  5776 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  5777 |     | <span class='neutral'>            // Selector of `log(bool,address,bool,uint256)`.</span>
  5778 |     | <span class='neutral'>            mstore(0x00, 0x07831502)</span>
  5779 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  5780 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  5781 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  5782 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  5783 |     | <span class='neutral'>        }</span>
  5784 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x84);</span>
  5785 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  5786 |     | <span class='neutral'>        assembly {</span>
  5787 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  5788 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  5789 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  5790 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  5791 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  5792 |     | <span class='neutral'>        }</span>
  5793 |     | <span class='neutral'>    }</span>
  5794 |     | <span class='neutral'></span>
  5795 |     | <span class='neutral'>    function log(bool p0, address p1, bool p2, bytes32 p3) internal pure {</span>
  5796 |     | <span class='neutral'>        bytes32 m0;</span>
  5797 |     | <span class='neutral'>        bytes32 m1;</span>
  5798 |     | <span class='neutral'>        bytes32 m2;</span>
  5799 |     | <span class='neutral'>        bytes32 m3;</span>
  5800 |     | <span class='neutral'>        bytes32 m4;</span>
  5801 |     | <span class='neutral'>        bytes32 m5;</span>
  5802 |     | <span class='neutral'>        bytes32 m6;</span>
  5803 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  5804 |     | <span class='neutral'>        assembly {</span>
  5805 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  5806 |     | <span class='neutral'>                let length := 0</span>
  5807 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  5808 |     | <span class='neutral'>                mstore(pos, length)</span>
  5809 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  5810 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  5811 |     | <span class='neutral'>            }</span>
  5812 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  5813 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  5814 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  5815 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  5816 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  5817 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  5818 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
  5819 |     | <span class='neutral'>            // Selector of `log(bool,address,bool,string)`.</span>
  5820 |     | <span class='neutral'>            mstore(0x00, 0x4a66cb34)</span>
  5821 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  5822 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  5823 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  5824 |     | <span class='neutral'>            mstore(0x80, 0x80)</span>
  5825 |     | <span class='neutral'>            writeString(0xa0, p3)</span>
  5826 |     | <span class='neutral'>        }</span>
  5827 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xc4);</span>
  5828 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  5829 |     | <span class='neutral'>        assembly {</span>
  5830 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  5831 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  5832 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  5833 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  5834 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  5835 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  5836 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
  5837 |     | <span class='neutral'>        }</span>
  5838 |     | <span class='neutral'>    }</span>
  5839 |     | <span class='neutral'></span>
  5840 |     | <span class='neutral'>    function log(bool p0, address p1, uint256 p2, address p3) internal pure {</span>
  5841 |     | <span class='neutral'>        bytes32 m0;</span>
  5842 |     | <span class='neutral'>        bytes32 m1;</span>
  5843 |     | <span class='neutral'>        bytes32 m2;</span>
  5844 |     | <span class='neutral'>        bytes32 m3;</span>
  5845 |     | <span class='neutral'>        bytes32 m4;</span>
  5846 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  5847 |     | <span class='neutral'>        assembly {</span>
  5848 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  5849 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  5850 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  5851 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  5852 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  5853 |     | <span class='neutral'>            // Selector of `log(bool,address,uint256,address)`.</span>
  5854 |     | <span class='neutral'>            mstore(0x00, 0x136b05dd)</span>
  5855 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  5856 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  5857 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  5858 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  5859 |     | <span class='neutral'>        }</span>
  5860 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x84);</span>
  5861 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  5862 |     | <span class='neutral'>        assembly {</span>
  5863 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  5864 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  5865 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  5866 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  5867 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  5868 |     | <span class='neutral'>        }</span>
  5869 |     | <span class='neutral'>    }</span>
  5870 |     | <span class='neutral'></span>
  5871 |     | <span class='neutral'>    function log(bool p0, address p1, uint256 p2, bool p3) internal pure {</span>
  5872 |     | <span class='neutral'>        bytes32 m0;</span>
  5873 |     | <span class='neutral'>        bytes32 m1;</span>
  5874 |     | <span class='neutral'>        bytes32 m2;</span>
  5875 |     | <span class='neutral'>        bytes32 m3;</span>
  5876 |     | <span class='neutral'>        bytes32 m4;</span>
  5877 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  5878 |     | <span class='neutral'>        assembly {</span>
  5879 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  5880 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  5881 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  5882 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  5883 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  5884 |     | <span class='neutral'>            // Selector of `log(bool,address,uint256,bool)`.</span>
  5885 |     | <span class='neutral'>            mstore(0x00, 0xd6019f1c)</span>
  5886 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  5887 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  5888 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  5889 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  5890 |     | <span class='neutral'>        }</span>
  5891 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x84);</span>
  5892 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  5893 |     | <span class='neutral'>        assembly {</span>
  5894 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  5895 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  5896 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  5897 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  5898 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  5899 |     | <span class='neutral'>        }</span>
  5900 |     | <span class='neutral'>    }</span>
  5901 |     | <span class='neutral'></span>
  5902 |     | <span class='neutral'>    function log(bool p0, address p1, uint256 p2, uint256 p3) internal pure {</span>
  5903 |     | <span class='neutral'>        bytes32 m0;</span>
  5904 |     | <span class='neutral'>        bytes32 m1;</span>
  5905 |     | <span class='neutral'>        bytes32 m2;</span>
  5906 |     | <span class='neutral'>        bytes32 m3;</span>
  5907 |     | <span class='neutral'>        bytes32 m4;</span>
  5908 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  5909 |     | <span class='neutral'>        assembly {</span>
  5910 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  5911 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  5912 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  5913 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  5914 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  5915 |     | <span class='neutral'>            // Selector of `log(bool,address,uint256,uint256)`.</span>
  5916 |     | <span class='neutral'>            mstore(0x00, 0x7bf181a1)</span>
  5917 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  5918 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  5919 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  5920 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  5921 |     | <span class='neutral'>        }</span>
  5922 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x84);</span>
  5923 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  5924 |     | <span class='neutral'>        assembly {</span>
  5925 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  5926 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  5927 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  5928 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  5929 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  5930 |     | <span class='neutral'>        }</span>
  5931 |     | <span class='neutral'>    }</span>
  5932 |     | <span class='neutral'></span>
  5933 |     | <span class='neutral'>    function log(bool p0, address p1, uint256 p2, bytes32 p3) internal pure {</span>
  5934 |     | <span class='neutral'>        bytes32 m0;</span>
  5935 |     | <span class='neutral'>        bytes32 m1;</span>
  5936 |     | <span class='neutral'>        bytes32 m2;</span>
  5937 |     | <span class='neutral'>        bytes32 m3;</span>
  5938 |     | <span class='neutral'>        bytes32 m4;</span>
  5939 |     | <span class='neutral'>        bytes32 m5;</span>
  5940 |     | <span class='neutral'>        bytes32 m6;</span>
  5941 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  5942 |     | <span class='neutral'>        assembly {</span>
  5943 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  5944 |     | <span class='neutral'>                let length := 0</span>
  5945 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  5946 |     | <span class='neutral'>                mstore(pos, length)</span>
  5947 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  5948 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  5949 |     | <span class='neutral'>            }</span>
  5950 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  5951 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  5952 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  5953 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  5954 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  5955 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  5956 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
  5957 |     | <span class='neutral'>            // Selector of `log(bool,address,uint256,string)`.</span>
  5958 |     | <span class='neutral'>            mstore(0x00, 0x51f09ff8)</span>
  5959 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  5960 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  5961 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  5962 |     | <span class='neutral'>            mstore(0x80, 0x80)</span>
  5963 |     | <span class='neutral'>            writeString(0xa0, p3)</span>
  5964 |     | <span class='neutral'>        }</span>
  5965 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xc4);</span>
  5966 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  5967 |     | <span class='neutral'>        assembly {</span>
  5968 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  5969 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  5970 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  5971 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  5972 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  5973 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  5974 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
  5975 |     | <span class='neutral'>        }</span>
  5976 |     | <span class='neutral'>    }</span>
  5977 |     | <span class='neutral'></span>
  5978 |     | <span class='neutral'>    function log(bool p0, address p1, bytes32 p2, address p3) internal pure {</span>
  5979 |     | <span class='neutral'>        bytes32 m0;</span>
  5980 |     | <span class='neutral'>        bytes32 m1;</span>
  5981 |     | <span class='neutral'>        bytes32 m2;</span>
  5982 |     | <span class='neutral'>        bytes32 m3;</span>
  5983 |     | <span class='neutral'>        bytes32 m4;</span>
  5984 |     | <span class='neutral'>        bytes32 m5;</span>
  5985 |     | <span class='neutral'>        bytes32 m6;</span>
  5986 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  5987 |     | <span class='neutral'>        assembly {</span>
  5988 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  5989 |     | <span class='neutral'>                let length := 0</span>
  5990 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  5991 |     | <span class='neutral'>                mstore(pos, length)</span>
  5992 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  5993 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  5994 |     | <span class='neutral'>            }</span>
  5995 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  5996 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  5997 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  5998 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  5999 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  6000 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  6001 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
  6002 |     | <span class='neutral'>            // Selector of `log(bool,address,string,address)`.</span>
  6003 |     | <span class='neutral'>            mstore(0x00, 0x6f7c603e)</span>
  6004 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  6005 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  6006 |     | <span class='neutral'>            mstore(0x60, 0x80)</span>
  6007 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  6008 |     | <span class='neutral'>            writeString(0xa0, p2)</span>
  6009 |     | <span class='neutral'>        }</span>
  6010 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xc4);</span>
  6011 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  6012 |     | <span class='neutral'>        assembly {</span>
  6013 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  6014 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  6015 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  6016 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  6017 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  6018 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  6019 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
  6020 |     | <span class='neutral'>        }</span>
  6021 |     | <span class='neutral'>    }</span>
  6022 |     | <span class='neutral'></span>
  6023 |     | <span class='neutral'>    function log(bool p0, address p1, bytes32 p2, bool p3) internal pure {</span>
  6024 |     | <span class='neutral'>        bytes32 m0;</span>
  6025 |     | <span class='neutral'>        bytes32 m1;</span>
  6026 |     | <span class='neutral'>        bytes32 m2;</span>
  6027 |     | <span class='neutral'>        bytes32 m3;</span>
  6028 |     | <span class='neutral'>        bytes32 m4;</span>
  6029 |     | <span class='neutral'>        bytes32 m5;</span>
  6030 |     | <span class='neutral'>        bytes32 m6;</span>
  6031 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  6032 |     | <span class='neutral'>        assembly {</span>
  6033 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  6034 |     | <span class='neutral'>                let length := 0</span>
  6035 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  6036 |     | <span class='neutral'>                mstore(pos, length)</span>
  6037 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  6038 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  6039 |     | <span class='neutral'>            }</span>
  6040 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  6041 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  6042 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  6043 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  6044 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  6045 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  6046 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
  6047 |     | <span class='neutral'>            // Selector of `log(bool,address,string,bool)`.</span>
  6048 |     | <span class='neutral'>            mstore(0x00, 0xe2bfd60b)</span>
  6049 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  6050 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  6051 |     | <span class='neutral'>            mstore(0x60, 0x80)</span>
  6052 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  6053 |     | <span class='neutral'>            writeString(0xa0, p2)</span>
  6054 |     | <span class='neutral'>        }</span>
  6055 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xc4);</span>
  6056 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  6057 |     | <span class='neutral'>        assembly {</span>
  6058 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  6059 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  6060 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  6061 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  6062 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  6063 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  6064 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
  6065 |     | <span class='neutral'>        }</span>
  6066 |     | <span class='neutral'>    }</span>
  6067 |     | <span class='neutral'></span>
  6068 |     | <span class='neutral'>    function log(bool p0, address p1, bytes32 p2, uint256 p3) internal pure {</span>
  6069 |     | <span class='neutral'>        bytes32 m0;</span>
  6070 |     | <span class='neutral'>        bytes32 m1;</span>
  6071 |     | <span class='neutral'>        bytes32 m2;</span>
  6072 |     | <span class='neutral'>        bytes32 m3;</span>
  6073 |     | <span class='neutral'>        bytes32 m4;</span>
  6074 |     | <span class='neutral'>        bytes32 m5;</span>
  6075 |     | <span class='neutral'>        bytes32 m6;</span>
  6076 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  6077 |     | <span class='neutral'>        assembly {</span>
  6078 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  6079 |     | <span class='neutral'>                let length := 0</span>
  6080 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  6081 |     | <span class='neutral'>                mstore(pos, length)</span>
  6082 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  6083 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  6084 |     | <span class='neutral'>            }</span>
  6085 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  6086 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  6087 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  6088 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  6089 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  6090 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  6091 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
  6092 |     | <span class='neutral'>            // Selector of `log(bool,address,string,uint256)`.</span>
  6093 |     | <span class='neutral'>            mstore(0x00, 0xc21f64c7)</span>
  6094 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  6095 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  6096 |     | <span class='neutral'>            mstore(0x60, 0x80)</span>
  6097 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  6098 |     | <span class='neutral'>            writeString(0xa0, p2)</span>
  6099 |     | <span class='neutral'>        }</span>
  6100 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xc4);</span>
  6101 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  6102 |     | <span class='neutral'>        assembly {</span>
  6103 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  6104 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  6105 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  6106 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  6107 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  6108 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  6109 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
  6110 |     | <span class='neutral'>        }</span>
  6111 |     | <span class='neutral'>    }</span>
  6112 |     | <span class='neutral'></span>
  6113 |     | <span class='neutral'>    function log(bool p0, address p1, bytes32 p2, bytes32 p3) internal pure {</span>
  6114 |     | <span class='neutral'>        bytes32 m0;</span>
  6115 |     | <span class='neutral'>        bytes32 m1;</span>
  6116 |     | <span class='neutral'>        bytes32 m2;</span>
  6117 |     | <span class='neutral'>        bytes32 m3;</span>
  6118 |     | <span class='neutral'>        bytes32 m4;</span>
  6119 |     | <span class='neutral'>        bytes32 m5;</span>
  6120 |     | <span class='neutral'>        bytes32 m6;</span>
  6121 |     | <span class='neutral'>        bytes32 m7;</span>
  6122 |     | <span class='neutral'>        bytes32 m8;</span>
  6123 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  6124 |     | <span class='neutral'>        assembly {</span>
  6125 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  6126 |     | <span class='neutral'>                let length := 0</span>
  6127 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  6128 |     | <span class='neutral'>                mstore(pos, length)</span>
  6129 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  6130 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  6131 |     | <span class='neutral'>            }</span>
  6132 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  6133 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  6134 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  6135 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  6136 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  6137 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  6138 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
  6139 |     | <span class='neutral'>            m7 := mload(0xe0)</span>
  6140 |     | <span class='neutral'>            m8 := mload(0x100)</span>
  6141 |     | <span class='neutral'>            // Selector of `log(bool,address,string,string)`.</span>
  6142 |     | <span class='neutral'>            mstore(0x00, 0xa73c1db6)</span>
  6143 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  6144 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  6145 |     | <span class='neutral'>            mstore(0x60, 0x80)</span>
  6146 |     | <span class='neutral'>            mstore(0x80, 0xc0)</span>
  6147 |     | <span class='neutral'>            writeString(0xa0, p2)</span>
  6148 |     | <span class='neutral'>            writeString(0xe0, p3)</span>
  6149 |     | <span class='neutral'>        }</span>
  6150 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x104);</span>
  6151 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  6152 |     | <span class='neutral'>        assembly {</span>
  6153 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  6154 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  6155 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  6156 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  6157 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  6158 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  6159 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
  6160 |     | <span class='neutral'>            mstore(0xe0, m7)</span>
  6161 |     | <span class='neutral'>            mstore(0x100, m8)</span>
  6162 |     | <span class='neutral'>        }</span>
  6163 |     | <span class='neutral'>    }</span>
  6164 |     | <span class='neutral'></span>
  6165 |     | <span class='neutral'>    function log(bool p0, bool p1, address p2, address p3) internal pure {</span>
  6166 |     | <span class='neutral'>        bytes32 m0;</span>
  6167 |     | <span class='neutral'>        bytes32 m1;</span>
  6168 |     | <span class='neutral'>        bytes32 m2;</span>
  6169 |     | <span class='neutral'>        bytes32 m3;</span>
  6170 |     | <span class='neutral'>        bytes32 m4;</span>
  6171 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  6172 |     | <span class='neutral'>        assembly {</span>
  6173 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  6174 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  6175 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  6176 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  6177 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  6178 |     | <span class='neutral'>            // Selector of `log(bool,bool,address,address)`.</span>
  6179 |     | <span class='neutral'>            mstore(0x00, 0xf4880ea4)</span>
  6180 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  6181 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  6182 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  6183 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  6184 |     | <span class='neutral'>        }</span>
  6185 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x84);</span>
  6186 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  6187 |     | <span class='neutral'>        assembly {</span>
  6188 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  6189 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  6190 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  6191 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  6192 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  6193 |     | <span class='neutral'>        }</span>
  6194 |     | <span class='neutral'>    }</span>
  6195 |     | <span class='neutral'></span>
  6196 |     | <span class='neutral'>    function log(bool p0, bool p1, address p2, bool p3) internal pure {</span>
  6197 |     | <span class='neutral'>        bytes32 m0;</span>
  6198 |     | <span class='neutral'>        bytes32 m1;</span>
  6199 |     | <span class='neutral'>        bytes32 m2;</span>
  6200 |     | <span class='neutral'>        bytes32 m3;</span>
  6201 |     | <span class='neutral'>        bytes32 m4;</span>
  6202 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  6203 |     | <span class='neutral'>        assembly {</span>
  6204 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  6205 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  6206 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  6207 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  6208 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  6209 |     | <span class='neutral'>            // Selector of `log(bool,bool,address,bool)`.</span>
  6210 |     | <span class='neutral'>            mstore(0x00, 0xc0a302d8)</span>
  6211 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  6212 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  6213 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  6214 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  6215 |     | <span class='neutral'>        }</span>
  6216 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x84);</span>
  6217 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  6218 |     | <span class='neutral'>        assembly {</span>
  6219 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  6220 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  6221 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  6222 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  6223 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  6224 |     | <span class='neutral'>        }</span>
  6225 |     | <span class='neutral'>    }</span>
  6226 |     | <span class='neutral'></span>
  6227 |     | <span class='neutral'>    function log(bool p0, bool p1, address p2, uint256 p3) internal pure {</span>
  6228 |     | <span class='neutral'>        bytes32 m0;</span>
  6229 |     | <span class='neutral'>        bytes32 m1;</span>
  6230 |     | <span class='neutral'>        bytes32 m2;</span>
  6231 |     | <span class='neutral'>        bytes32 m3;</span>
  6232 |     | <span class='neutral'>        bytes32 m4;</span>
  6233 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  6234 |     | <span class='neutral'>        assembly {</span>
  6235 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  6236 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  6237 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  6238 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  6239 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  6240 |     | <span class='neutral'>            // Selector of `log(bool,bool,address,uint256)`.</span>
  6241 |     | <span class='neutral'>            mstore(0x00, 0x4c123d57)</span>
  6242 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  6243 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  6244 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  6245 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  6246 |     | <span class='neutral'>        }</span>
  6247 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x84);</span>
  6248 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  6249 |     | <span class='neutral'>        assembly {</span>
  6250 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  6251 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  6252 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  6253 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  6254 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  6255 |     | <span class='neutral'>        }</span>
  6256 |     | <span class='neutral'>    }</span>
  6257 |     | <span class='neutral'></span>
  6258 |     | <span class='neutral'>    function log(bool p0, bool p1, address p2, bytes32 p3) internal pure {</span>
  6259 |     | <span class='neutral'>        bytes32 m0;</span>
  6260 |     | <span class='neutral'>        bytes32 m1;</span>
  6261 |     | <span class='neutral'>        bytes32 m2;</span>
  6262 |     | <span class='neutral'>        bytes32 m3;</span>
  6263 |     | <span class='neutral'>        bytes32 m4;</span>
  6264 |     | <span class='neutral'>        bytes32 m5;</span>
  6265 |     | <span class='neutral'>        bytes32 m6;</span>
  6266 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  6267 |     | <span class='neutral'>        assembly {</span>
  6268 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  6269 |     | <span class='neutral'>                let length := 0</span>
  6270 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  6271 |     | <span class='neutral'>                mstore(pos, length)</span>
  6272 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  6273 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  6274 |     | <span class='neutral'>            }</span>
  6275 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  6276 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  6277 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  6278 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  6279 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  6280 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  6281 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
  6282 |     | <span class='neutral'>            // Selector of `log(bool,bool,address,string)`.</span>
  6283 |     | <span class='neutral'>            mstore(0x00, 0xa0a47963)</span>
  6284 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  6285 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  6286 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  6287 |     | <span class='neutral'>            mstore(0x80, 0x80)</span>
  6288 |     | <span class='neutral'>            writeString(0xa0, p3)</span>
  6289 |     | <span class='neutral'>        }</span>
  6290 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xc4);</span>
  6291 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  6292 |     | <span class='neutral'>        assembly {</span>
  6293 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  6294 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  6295 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  6296 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  6297 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  6298 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  6299 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
  6300 |     | <span class='neutral'>        }</span>
  6301 |     | <span class='neutral'>    }</span>
  6302 |     | <span class='neutral'></span>
  6303 |     | <span class='neutral'>    function log(bool p0, bool p1, bool p2, address p3) internal pure {</span>
  6304 |     | <span class='neutral'>        bytes32 m0;</span>
  6305 |     | <span class='neutral'>        bytes32 m1;</span>
  6306 |     | <span class='neutral'>        bytes32 m2;</span>
  6307 |     | <span class='neutral'>        bytes32 m3;</span>
  6308 |     | <span class='neutral'>        bytes32 m4;</span>
  6309 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  6310 |     | <span class='neutral'>        assembly {</span>
  6311 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  6312 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  6313 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  6314 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  6315 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  6316 |     | <span class='neutral'>            // Selector of `log(bool,bool,bool,address)`.</span>
  6317 |     | <span class='neutral'>            mstore(0x00, 0x8c329b1a)</span>
  6318 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  6319 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  6320 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  6321 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  6322 |     | <span class='neutral'>        }</span>
  6323 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x84);</span>
  6324 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  6325 |     | <span class='neutral'>        assembly {</span>
  6326 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  6327 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  6328 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  6329 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  6330 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  6331 |     | <span class='neutral'>        }</span>
  6332 |     | <span class='neutral'>    }</span>
  6333 |     | <span class='neutral'></span>
  6334 |     | <span class='neutral'>    function log(bool p0, bool p1, bool p2, bool p3) internal pure {</span>
  6335 |     | <span class='neutral'>        bytes32 m0;</span>
  6336 |     | <span class='neutral'>        bytes32 m1;</span>
  6337 |     | <span class='neutral'>        bytes32 m2;</span>
  6338 |     | <span class='neutral'>        bytes32 m3;</span>
  6339 |     | <span class='neutral'>        bytes32 m4;</span>
  6340 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  6341 |     | <span class='neutral'>        assembly {</span>
  6342 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  6343 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  6344 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  6345 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  6346 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  6347 |     | <span class='neutral'>            // Selector of `log(bool,bool,bool,bool)`.</span>
  6348 |     | <span class='neutral'>            mstore(0x00, 0x3b2a5ce0)</span>
  6349 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  6350 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  6351 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  6352 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  6353 |     | <span class='neutral'>        }</span>
  6354 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x84);</span>
  6355 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  6356 |     | <span class='neutral'>        assembly {</span>
  6357 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  6358 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  6359 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  6360 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  6361 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  6362 |     | <span class='neutral'>        }</span>
  6363 |     | <span class='neutral'>    }</span>
  6364 |     | <span class='neutral'></span>
  6365 |     | <span class='neutral'>    function log(bool p0, bool p1, bool p2, uint256 p3) internal pure {</span>
  6366 |     | <span class='neutral'>        bytes32 m0;</span>
  6367 |     | <span class='neutral'>        bytes32 m1;</span>
  6368 |     | <span class='neutral'>        bytes32 m2;</span>
  6369 |     | <span class='neutral'>        bytes32 m3;</span>
  6370 |     | <span class='neutral'>        bytes32 m4;</span>
  6371 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  6372 |     | <span class='neutral'>        assembly {</span>
  6373 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  6374 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  6375 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  6376 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  6377 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  6378 |     | <span class='neutral'>            // Selector of `log(bool,bool,bool,uint256)`.</span>
  6379 |     | <span class='neutral'>            mstore(0x00, 0x6d7045c1)</span>
  6380 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  6381 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  6382 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  6383 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  6384 |     | <span class='neutral'>        }</span>
  6385 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x84);</span>
  6386 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  6387 |     | <span class='neutral'>        assembly {</span>
  6388 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  6389 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  6390 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  6391 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  6392 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  6393 |     | <span class='neutral'>        }</span>
  6394 |     | <span class='neutral'>    }</span>
  6395 |     | <span class='neutral'></span>
  6396 |     | <span class='neutral'>    function log(bool p0, bool p1, bool p2, bytes32 p3) internal pure {</span>
  6397 |     | <span class='neutral'>        bytes32 m0;</span>
  6398 |     | <span class='neutral'>        bytes32 m1;</span>
  6399 |     | <span class='neutral'>        bytes32 m2;</span>
  6400 |     | <span class='neutral'>        bytes32 m3;</span>
  6401 |     | <span class='neutral'>        bytes32 m4;</span>
  6402 |     | <span class='neutral'>        bytes32 m5;</span>
  6403 |     | <span class='neutral'>        bytes32 m6;</span>
  6404 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  6405 |     | <span class='neutral'>        assembly {</span>
  6406 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  6407 |     | <span class='neutral'>                let length := 0</span>
  6408 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  6409 |     | <span class='neutral'>                mstore(pos, length)</span>
  6410 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  6411 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  6412 |     | <span class='neutral'>            }</span>
  6413 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  6414 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  6415 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  6416 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  6417 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  6418 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  6419 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
  6420 |     | <span class='neutral'>            // Selector of `log(bool,bool,bool,string)`.</span>
  6421 |     | <span class='neutral'>            mstore(0x00, 0x2ae408d4)</span>
  6422 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  6423 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  6424 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  6425 |     | <span class='neutral'>            mstore(0x80, 0x80)</span>
  6426 |     | <span class='neutral'>            writeString(0xa0, p3)</span>
  6427 |     | <span class='neutral'>        }</span>
  6428 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xc4);</span>
  6429 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  6430 |     | <span class='neutral'>        assembly {</span>
  6431 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  6432 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  6433 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  6434 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  6435 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  6436 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  6437 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
  6438 |     | <span class='neutral'>        }</span>
  6439 |     | <span class='neutral'>    }</span>
  6440 |     | <span class='neutral'></span>
  6441 |     | <span class='neutral'>    function log(bool p0, bool p1, uint256 p2, address p3) internal pure {</span>
  6442 |     | <span class='neutral'>        bytes32 m0;</span>
  6443 |     | <span class='neutral'>        bytes32 m1;</span>
  6444 |     | <span class='neutral'>        bytes32 m2;</span>
  6445 |     | <span class='neutral'>        bytes32 m3;</span>
  6446 |     | <span class='neutral'>        bytes32 m4;</span>
  6447 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  6448 |     | <span class='neutral'>        assembly {</span>
  6449 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  6450 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  6451 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  6452 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  6453 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  6454 |     | <span class='neutral'>            // Selector of `log(bool,bool,uint256,address)`.</span>
  6455 |     | <span class='neutral'>            mstore(0x00, 0x54a7a9a0)</span>
  6456 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  6457 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  6458 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  6459 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  6460 |     | <span class='neutral'>        }</span>
  6461 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x84);</span>
  6462 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  6463 |     | <span class='neutral'>        assembly {</span>
  6464 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  6465 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  6466 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  6467 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  6468 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  6469 |     | <span class='neutral'>        }</span>
  6470 |     | <span class='neutral'>    }</span>
  6471 |     | <span class='neutral'></span>
  6472 |     | <span class='neutral'>    function log(bool p0, bool p1, uint256 p2, bool p3) internal pure {</span>
  6473 |     | <span class='neutral'>        bytes32 m0;</span>
  6474 |     | <span class='neutral'>        bytes32 m1;</span>
  6475 |     | <span class='neutral'>        bytes32 m2;</span>
  6476 |     | <span class='neutral'>        bytes32 m3;</span>
  6477 |     | <span class='neutral'>        bytes32 m4;</span>
  6478 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  6479 |     | <span class='neutral'>        assembly {</span>
  6480 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  6481 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  6482 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  6483 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  6484 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  6485 |     | <span class='neutral'>            // Selector of `log(bool,bool,uint256,bool)`.</span>
  6486 |     | <span class='neutral'>            mstore(0x00, 0x619e4d0e)</span>
  6487 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  6488 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  6489 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  6490 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  6491 |     | <span class='neutral'>        }</span>
  6492 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x84);</span>
  6493 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  6494 |     | <span class='neutral'>        assembly {</span>
  6495 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  6496 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  6497 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  6498 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  6499 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  6500 |     | <span class='neutral'>        }</span>
  6501 |     | <span class='neutral'>    }</span>
  6502 |     | <span class='neutral'></span>
  6503 |     | <span class='neutral'>    function log(bool p0, bool p1, uint256 p2, uint256 p3) internal pure {</span>
  6504 |     | <span class='neutral'>        bytes32 m0;</span>
  6505 |     | <span class='neutral'>        bytes32 m1;</span>
  6506 |     | <span class='neutral'>        bytes32 m2;</span>
  6507 |     | <span class='neutral'>        bytes32 m3;</span>
  6508 |     | <span class='neutral'>        bytes32 m4;</span>
  6509 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  6510 |     | <span class='neutral'>        assembly {</span>
  6511 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  6512 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  6513 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  6514 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  6515 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  6516 |     | <span class='neutral'>            // Selector of `log(bool,bool,uint256,uint256)`.</span>
  6517 |     | <span class='neutral'>            mstore(0x00, 0x0bb00eab)</span>
  6518 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  6519 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  6520 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  6521 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  6522 |     | <span class='neutral'>        }</span>
  6523 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x84);</span>
  6524 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  6525 |     | <span class='neutral'>        assembly {</span>
  6526 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  6527 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  6528 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  6529 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  6530 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  6531 |     | <span class='neutral'>        }</span>
  6532 |     | <span class='neutral'>    }</span>
  6533 |     | <span class='neutral'></span>
  6534 |     | <span class='neutral'>    function log(bool p0, bool p1, uint256 p2, bytes32 p3) internal pure {</span>
  6535 |     | <span class='neutral'>        bytes32 m0;</span>
  6536 |     | <span class='neutral'>        bytes32 m1;</span>
  6537 |     | <span class='neutral'>        bytes32 m2;</span>
  6538 |     | <span class='neutral'>        bytes32 m3;</span>
  6539 |     | <span class='neutral'>        bytes32 m4;</span>
  6540 |     | <span class='neutral'>        bytes32 m5;</span>
  6541 |     | <span class='neutral'>        bytes32 m6;</span>
  6542 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  6543 |     | <span class='neutral'>        assembly {</span>
  6544 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  6545 |     | <span class='neutral'>                let length := 0</span>
  6546 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  6547 |     | <span class='neutral'>                mstore(pos, length)</span>
  6548 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  6549 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  6550 |     | <span class='neutral'>            }</span>
  6551 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  6552 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  6553 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  6554 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  6555 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  6556 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  6557 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
  6558 |     | <span class='neutral'>            // Selector of `log(bool,bool,uint256,string)`.</span>
  6559 |     | <span class='neutral'>            mstore(0x00, 0x7dd4d0e0)</span>
  6560 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  6561 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  6562 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  6563 |     | <span class='neutral'>            mstore(0x80, 0x80)</span>
  6564 |     | <span class='neutral'>            writeString(0xa0, p3)</span>
  6565 |     | <span class='neutral'>        }</span>
  6566 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xc4);</span>
  6567 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  6568 |     | <span class='neutral'>        assembly {</span>
  6569 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  6570 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  6571 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  6572 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  6573 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  6574 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  6575 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
  6576 |     | <span class='neutral'>        }</span>
  6577 |     | <span class='neutral'>    }</span>
  6578 |     | <span class='neutral'></span>
  6579 |     | <span class='neutral'>    function log(bool p0, bool p1, bytes32 p2, address p3) internal pure {</span>
  6580 |     | <span class='neutral'>        bytes32 m0;</span>
  6581 |     | <span class='neutral'>        bytes32 m1;</span>
  6582 |     | <span class='neutral'>        bytes32 m2;</span>
  6583 |     | <span class='neutral'>        bytes32 m3;</span>
  6584 |     | <span class='neutral'>        bytes32 m4;</span>
  6585 |     | <span class='neutral'>        bytes32 m5;</span>
  6586 |     | <span class='neutral'>        bytes32 m6;</span>
  6587 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  6588 |     | <span class='neutral'>        assembly {</span>
  6589 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  6590 |     | <span class='neutral'>                let length := 0</span>
  6591 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  6592 |     | <span class='neutral'>                mstore(pos, length)</span>
  6593 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  6594 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  6595 |     | <span class='neutral'>            }</span>
  6596 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  6597 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  6598 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  6599 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  6600 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  6601 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  6602 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
  6603 |     | <span class='neutral'>            // Selector of `log(bool,bool,string,address)`.</span>
  6604 |     | <span class='neutral'>            mstore(0x00, 0xf9ad2b89)</span>
  6605 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  6606 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  6607 |     | <span class='neutral'>            mstore(0x60, 0x80)</span>
  6608 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  6609 |     | <span class='neutral'>            writeString(0xa0, p2)</span>
  6610 |     | <span class='neutral'>        }</span>
  6611 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xc4);</span>
  6612 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  6613 |     | <span class='neutral'>        assembly {</span>
  6614 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  6615 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  6616 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  6617 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  6618 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  6619 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  6620 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
  6621 |     | <span class='neutral'>        }</span>
  6622 |     | <span class='neutral'>    }</span>
  6623 |     | <span class='neutral'></span>
  6624 |     | <span class='neutral'>    function log(bool p0, bool p1, bytes32 p2, bool p3) internal pure {</span>
  6625 |     | <span class='neutral'>        bytes32 m0;</span>
  6626 |     | <span class='neutral'>        bytes32 m1;</span>
  6627 |     | <span class='neutral'>        bytes32 m2;</span>
  6628 |     | <span class='neutral'>        bytes32 m3;</span>
  6629 |     | <span class='neutral'>        bytes32 m4;</span>
  6630 |     | <span class='neutral'>        bytes32 m5;</span>
  6631 |     | <span class='neutral'>        bytes32 m6;</span>
  6632 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  6633 |     | <span class='neutral'>        assembly {</span>
  6634 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  6635 |     | <span class='neutral'>                let length := 0</span>
  6636 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  6637 |     | <span class='neutral'>                mstore(pos, length)</span>
  6638 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  6639 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  6640 |     | <span class='neutral'>            }</span>
  6641 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  6642 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  6643 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  6644 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  6645 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  6646 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  6647 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
  6648 |     | <span class='neutral'>            // Selector of `log(bool,bool,string,bool)`.</span>
  6649 |     | <span class='neutral'>            mstore(0x00, 0xb857163a)</span>
  6650 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  6651 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  6652 |     | <span class='neutral'>            mstore(0x60, 0x80)</span>
  6653 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  6654 |     | <span class='neutral'>            writeString(0xa0, p2)</span>
  6655 |     | <span class='neutral'>        }</span>
  6656 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xc4);</span>
  6657 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  6658 |     | <span class='neutral'>        assembly {</span>
  6659 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  6660 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  6661 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  6662 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  6663 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  6664 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  6665 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
  6666 |     | <span class='neutral'>        }</span>
  6667 |     | <span class='neutral'>    }</span>
  6668 |     | <span class='neutral'></span>
  6669 |     | <span class='neutral'>    function log(bool p0, bool p1, bytes32 p2, uint256 p3) internal pure {</span>
  6670 |     | <span class='neutral'>        bytes32 m0;</span>
  6671 |     | <span class='neutral'>        bytes32 m1;</span>
  6672 |     | <span class='neutral'>        bytes32 m2;</span>
  6673 |     | <span class='neutral'>        bytes32 m3;</span>
  6674 |     | <span class='neutral'>        bytes32 m4;</span>
  6675 |     | <span class='neutral'>        bytes32 m5;</span>
  6676 |     | <span class='neutral'>        bytes32 m6;</span>
  6677 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  6678 |     | <span class='neutral'>        assembly {</span>
  6679 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  6680 |     | <span class='neutral'>                let length := 0</span>
  6681 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  6682 |     | <span class='neutral'>                mstore(pos, length)</span>
  6683 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  6684 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  6685 |     | <span class='neutral'>            }</span>
  6686 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  6687 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  6688 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  6689 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  6690 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  6691 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  6692 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
  6693 |     | <span class='neutral'>            // Selector of `log(bool,bool,string,uint256)`.</span>
  6694 |     | <span class='neutral'>            mstore(0x00, 0xe3a9ca2f)</span>
  6695 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  6696 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  6697 |     | <span class='neutral'>            mstore(0x60, 0x80)</span>
  6698 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  6699 |     | <span class='neutral'>            writeString(0xa0, p2)</span>
  6700 |     | <span class='neutral'>        }</span>
  6701 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xc4);</span>
  6702 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  6703 |     | <span class='neutral'>        assembly {</span>
  6704 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  6705 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  6706 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  6707 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  6708 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  6709 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  6710 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
  6711 |     | <span class='neutral'>        }</span>
  6712 |     | <span class='neutral'>    }</span>
  6713 |     | <span class='neutral'></span>
  6714 |     | <span class='neutral'>    function log(bool p0, bool p1, bytes32 p2, bytes32 p3) internal pure {</span>
  6715 |     | <span class='neutral'>        bytes32 m0;</span>
  6716 |     | <span class='neutral'>        bytes32 m1;</span>
  6717 |     | <span class='neutral'>        bytes32 m2;</span>
  6718 |     | <span class='neutral'>        bytes32 m3;</span>
  6719 |     | <span class='neutral'>        bytes32 m4;</span>
  6720 |     | <span class='neutral'>        bytes32 m5;</span>
  6721 |     | <span class='neutral'>        bytes32 m6;</span>
  6722 |     | <span class='neutral'>        bytes32 m7;</span>
  6723 |     | <span class='neutral'>        bytes32 m8;</span>
  6724 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  6725 |     | <span class='neutral'>        assembly {</span>
  6726 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  6727 |     | <span class='neutral'>                let length := 0</span>
  6728 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  6729 |     | <span class='neutral'>                mstore(pos, length)</span>
  6730 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  6731 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  6732 |     | <span class='neutral'>            }</span>
  6733 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  6734 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  6735 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  6736 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  6737 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  6738 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  6739 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
  6740 |     | <span class='neutral'>            m7 := mload(0xe0)</span>
  6741 |     | <span class='neutral'>            m8 := mload(0x100)</span>
  6742 |     | <span class='neutral'>            // Selector of `log(bool,bool,string,string)`.</span>
  6743 |     | <span class='neutral'>            mstore(0x00, 0x6d1e8751)</span>
  6744 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  6745 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  6746 |     | <span class='neutral'>            mstore(0x60, 0x80)</span>
  6747 |     | <span class='neutral'>            mstore(0x80, 0xc0)</span>
  6748 |     | <span class='neutral'>            writeString(0xa0, p2)</span>
  6749 |     | <span class='neutral'>            writeString(0xe0, p3)</span>
  6750 |     | <span class='neutral'>        }</span>
  6751 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x104);</span>
  6752 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  6753 |     | <span class='neutral'>        assembly {</span>
  6754 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  6755 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  6756 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  6757 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  6758 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  6759 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  6760 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
  6761 |     | <span class='neutral'>            mstore(0xe0, m7)</span>
  6762 |     | <span class='neutral'>            mstore(0x100, m8)</span>
  6763 |     | <span class='neutral'>        }</span>
  6764 |     | <span class='neutral'>    }</span>
  6765 |     | <span class='neutral'></span>
  6766 |     | <span class='neutral'>    function log(bool p0, uint256 p1, address p2, address p3) internal pure {</span>
  6767 |     | <span class='neutral'>        bytes32 m0;</span>
  6768 |     | <span class='neutral'>        bytes32 m1;</span>
  6769 |     | <span class='neutral'>        bytes32 m2;</span>
  6770 |     | <span class='neutral'>        bytes32 m3;</span>
  6771 |     | <span class='neutral'>        bytes32 m4;</span>
  6772 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  6773 |     | <span class='neutral'>        assembly {</span>
  6774 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  6775 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  6776 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  6777 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  6778 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  6779 |     | <span class='neutral'>            // Selector of `log(bool,uint256,address,address)`.</span>
  6780 |     | <span class='neutral'>            mstore(0x00, 0x26f560a8)</span>
  6781 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  6782 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  6783 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  6784 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  6785 |     | <span class='neutral'>        }</span>
  6786 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x84);</span>
  6787 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  6788 |     | <span class='neutral'>        assembly {</span>
  6789 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  6790 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  6791 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  6792 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  6793 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  6794 |     | <span class='neutral'>        }</span>
  6795 |     | <span class='neutral'>    }</span>
  6796 |     | <span class='neutral'></span>
  6797 |     | <span class='neutral'>    function log(bool p0, uint256 p1, address p2, bool p3) internal pure {</span>
  6798 |     | <span class='neutral'>        bytes32 m0;</span>
  6799 |     | <span class='neutral'>        bytes32 m1;</span>
  6800 |     | <span class='neutral'>        bytes32 m2;</span>
  6801 |     | <span class='neutral'>        bytes32 m3;</span>
  6802 |     | <span class='neutral'>        bytes32 m4;</span>
  6803 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  6804 |     | <span class='neutral'>        assembly {</span>
  6805 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  6806 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  6807 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  6808 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  6809 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  6810 |     | <span class='neutral'>            // Selector of `log(bool,uint256,address,bool)`.</span>
  6811 |     | <span class='neutral'>            mstore(0x00, 0xb4c314ff)</span>
  6812 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  6813 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  6814 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  6815 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  6816 |     | <span class='neutral'>        }</span>
  6817 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x84);</span>
  6818 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  6819 |     | <span class='neutral'>        assembly {</span>
  6820 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  6821 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  6822 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  6823 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  6824 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  6825 |     | <span class='neutral'>        }</span>
  6826 |     | <span class='neutral'>    }</span>
  6827 |     | <span class='neutral'></span>
  6828 |     | <span class='neutral'>    function log(bool p0, uint256 p1, address p2, uint256 p3) internal pure {</span>
  6829 |     | <span class='neutral'>        bytes32 m0;</span>
  6830 |     | <span class='neutral'>        bytes32 m1;</span>
  6831 |     | <span class='neutral'>        bytes32 m2;</span>
  6832 |     | <span class='neutral'>        bytes32 m3;</span>
  6833 |     | <span class='neutral'>        bytes32 m4;</span>
  6834 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  6835 |     | <span class='neutral'>        assembly {</span>
  6836 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  6837 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  6838 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  6839 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  6840 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  6841 |     | <span class='neutral'>            // Selector of `log(bool,uint256,address,uint256)`.</span>
  6842 |     | <span class='neutral'>            mstore(0x00, 0x1537dc87)</span>
  6843 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  6844 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  6845 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  6846 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  6847 |     | <span class='neutral'>        }</span>
  6848 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x84);</span>
  6849 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  6850 |     | <span class='neutral'>        assembly {</span>
  6851 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  6852 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  6853 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  6854 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  6855 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  6856 |     | <span class='neutral'>        }</span>
  6857 |     | <span class='neutral'>    }</span>
  6858 |     | <span class='neutral'></span>
  6859 |     | <span class='neutral'>    function log(bool p0, uint256 p1, address p2, bytes32 p3) internal pure {</span>
  6860 |     | <span class='neutral'>        bytes32 m0;</span>
  6861 |     | <span class='neutral'>        bytes32 m1;</span>
  6862 |     | <span class='neutral'>        bytes32 m2;</span>
  6863 |     | <span class='neutral'>        bytes32 m3;</span>
  6864 |     | <span class='neutral'>        bytes32 m4;</span>
  6865 |     | <span class='neutral'>        bytes32 m5;</span>
  6866 |     | <span class='neutral'>        bytes32 m6;</span>
  6867 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  6868 |     | <span class='neutral'>        assembly {</span>
  6869 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  6870 |     | <span class='neutral'>                let length := 0</span>
  6871 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  6872 |     | <span class='neutral'>                mstore(pos, length)</span>
  6873 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  6874 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  6875 |     | <span class='neutral'>            }</span>
  6876 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  6877 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  6878 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  6879 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  6880 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  6881 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  6882 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
  6883 |     | <span class='neutral'>            // Selector of `log(bool,uint256,address,string)`.</span>
  6884 |     | <span class='neutral'>            mstore(0x00, 0x1bb3b09a)</span>
  6885 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  6886 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  6887 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  6888 |     | <span class='neutral'>            mstore(0x80, 0x80)</span>
  6889 |     | <span class='neutral'>            writeString(0xa0, p3)</span>
  6890 |     | <span class='neutral'>        }</span>
  6891 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xc4);</span>
  6892 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  6893 |     | <span class='neutral'>        assembly {</span>
  6894 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  6895 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  6896 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  6897 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  6898 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  6899 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  6900 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
  6901 |     | <span class='neutral'>        }</span>
  6902 |     | <span class='neutral'>    }</span>
  6903 |     | <span class='neutral'></span>
  6904 |     | <span class='neutral'>    function log(bool p0, uint256 p1, bool p2, address p3) internal pure {</span>
  6905 |     | <span class='neutral'>        bytes32 m0;</span>
  6906 |     | <span class='neutral'>        bytes32 m1;</span>
  6907 |     | <span class='neutral'>        bytes32 m2;</span>
  6908 |     | <span class='neutral'>        bytes32 m3;</span>
  6909 |     | <span class='neutral'>        bytes32 m4;</span>
  6910 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  6911 |     | <span class='neutral'>        assembly {</span>
  6912 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  6913 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  6914 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  6915 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  6916 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  6917 |     | <span class='neutral'>            // Selector of `log(bool,uint256,bool,address)`.</span>
  6918 |     | <span class='neutral'>            mstore(0x00, 0x9acd3616)</span>
  6919 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  6920 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  6921 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  6922 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  6923 |     | <span class='neutral'>        }</span>
  6924 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x84);</span>
  6925 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  6926 |     | <span class='neutral'>        assembly {</span>
  6927 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  6928 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  6929 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  6930 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  6931 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  6932 |     | <span class='neutral'>        }</span>
  6933 |     | <span class='neutral'>    }</span>
  6934 |     | <span class='neutral'></span>
  6935 |     | <span class='neutral'>    function log(bool p0, uint256 p1, bool p2, bool p3) internal pure {</span>
  6936 |     | <span class='neutral'>        bytes32 m0;</span>
  6937 |     | <span class='neutral'>        bytes32 m1;</span>
  6938 |     | <span class='neutral'>        bytes32 m2;</span>
  6939 |     | <span class='neutral'>        bytes32 m3;</span>
  6940 |     | <span class='neutral'>        bytes32 m4;</span>
  6941 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  6942 |     | <span class='neutral'>        assembly {</span>
  6943 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  6944 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  6945 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  6946 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  6947 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  6948 |     | <span class='neutral'>            // Selector of `log(bool,uint256,bool,bool)`.</span>
  6949 |     | <span class='neutral'>            mstore(0x00, 0xceb5f4d7)</span>
  6950 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  6951 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  6952 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  6953 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  6954 |     | <span class='neutral'>        }</span>
  6955 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x84);</span>
  6956 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  6957 |     | <span class='neutral'>        assembly {</span>
  6958 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  6959 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  6960 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  6961 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  6962 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  6963 |     | <span class='neutral'>        }</span>
  6964 |     | <span class='neutral'>    }</span>
  6965 |     | <span class='neutral'></span>
  6966 |     | <span class='neutral'>    function log(bool p0, uint256 p1, bool p2, uint256 p3) internal pure {</span>
  6967 |     | <span class='neutral'>        bytes32 m0;</span>
  6968 |     | <span class='neutral'>        bytes32 m1;</span>
  6969 |     | <span class='neutral'>        bytes32 m2;</span>
  6970 |     | <span class='neutral'>        bytes32 m3;</span>
  6971 |     | <span class='neutral'>        bytes32 m4;</span>
  6972 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  6973 |     | <span class='neutral'>        assembly {</span>
  6974 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  6975 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  6976 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  6977 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  6978 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  6979 |     | <span class='neutral'>            // Selector of `log(bool,uint256,bool,uint256)`.</span>
  6980 |     | <span class='neutral'>            mstore(0x00, 0x7f9bbca2)</span>
  6981 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  6982 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  6983 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  6984 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  6985 |     | <span class='neutral'>        }</span>
  6986 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x84);</span>
  6987 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  6988 |     | <span class='neutral'>        assembly {</span>
  6989 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  6990 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  6991 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  6992 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  6993 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  6994 |     | <span class='neutral'>        }</span>
  6995 |     | <span class='neutral'>    }</span>
  6996 |     | <span class='neutral'></span>
  6997 |     | <span class='neutral'>    function log(bool p0, uint256 p1, bool p2, bytes32 p3) internal pure {</span>
  6998 |     | <span class='neutral'>        bytes32 m0;</span>
  6999 |     | <span class='neutral'>        bytes32 m1;</span>
  7000 |     | <span class='neutral'>        bytes32 m2;</span>
  7001 |     | <span class='neutral'>        bytes32 m3;</span>
  7002 |     | <span class='neutral'>        bytes32 m4;</span>
  7003 |     | <span class='neutral'>        bytes32 m5;</span>
  7004 |     | <span class='neutral'>        bytes32 m6;</span>
  7005 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  7006 |     | <span class='neutral'>        assembly {</span>
  7007 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  7008 |     | <span class='neutral'>                let length := 0</span>
  7009 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  7010 |     | <span class='neutral'>                mstore(pos, length)</span>
  7011 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  7012 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  7013 |     | <span class='neutral'>            }</span>
  7014 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  7015 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  7016 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  7017 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  7018 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  7019 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  7020 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
  7021 |     | <span class='neutral'>            // Selector of `log(bool,uint256,bool,string)`.</span>
  7022 |     | <span class='neutral'>            mstore(0x00, 0x9143dbb1)</span>
  7023 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  7024 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  7025 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  7026 |     | <span class='neutral'>            mstore(0x80, 0x80)</span>
  7027 |     | <span class='neutral'>            writeString(0xa0, p3)</span>
  7028 |     | <span class='neutral'>        }</span>
  7029 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xc4);</span>
  7030 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  7031 |     | <span class='neutral'>        assembly {</span>
  7032 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  7033 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  7034 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  7035 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  7036 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  7037 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  7038 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
  7039 |     | <span class='neutral'>        }</span>
  7040 |     | <span class='neutral'>    }</span>
  7041 |     | <span class='neutral'></span>
  7042 |     | <span class='neutral'>    function log(bool p0, uint256 p1, uint256 p2, address p3) internal pure {</span>
  7043 |     | <span class='neutral'>        bytes32 m0;</span>
  7044 |     | <span class='neutral'>        bytes32 m1;</span>
  7045 |     | <span class='neutral'>        bytes32 m2;</span>
  7046 |     | <span class='neutral'>        bytes32 m3;</span>
  7047 |     | <span class='neutral'>        bytes32 m4;</span>
  7048 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  7049 |     | <span class='neutral'>        assembly {</span>
  7050 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  7051 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  7052 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  7053 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  7054 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  7055 |     | <span class='neutral'>            // Selector of `log(bool,uint256,uint256,address)`.</span>
  7056 |     | <span class='neutral'>            mstore(0x00, 0x00dd87b9)</span>
  7057 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  7058 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  7059 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  7060 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  7061 |     | <span class='neutral'>        }</span>
  7062 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x84);</span>
  7063 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  7064 |     | <span class='neutral'>        assembly {</span>
  7065 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  7066 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  7067 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  7068 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  7069 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  7070 |     | <span class='neutral'>        }</span>
  7071 |     | <span class='neutral'>    }</span>
  7072 |     | <span class='neutral'></span>
  7073 |     | <span class='neutral'>    function log(bool p0, uint256 p1, uint256 p2, bool p3) internal pure {</span>
  7074 |     | <span class='neutral'>        bytes32 m0;</span>
  7075 |     | <span class='neutral'>        bytes32 m1;</span>
  7076 |     | <span class='neutral'>        bytes32 m2;</span>
  7077 |     | <span class='neutral'>        bytes32 m3;</span>
  7078 |     | <span class='neutral'>        bytes32 m4;</span>
  7079 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  7080 |     | <span class='neutral'>        assembly {</span>
  7081 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  7082 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  7083 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  7084 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  7085 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  7086 |     | <span class='neutral'>            // Selector of `log(bool,uint256,uint256,bool)`.</span>
  7087 |     | <span class='neutral'>            mstore(0x00, 0xbe984353)</span>
  7088 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  7089 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  7090 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  7091 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  7092 |     | <span class='neutral'>        }</span>
  7093 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x84);</span>
  7094 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  7095 |     | <span class='neutral'>        assembly {</span>
  7096 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  7097 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  7098 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  7099 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  7100 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  7101 |     | <span class='neutral'>        }</span>
  7102 |     | <span class='neutral'>    }</span>
  7103 |     | <span class='neutral'></span>
  7104 |     | <span class='neutral'>    function log(bool p0, uint256 p1, uint256 p2, uint256 p3) internal pure {</span>
  7105 |     | <span class='neutral'>        bytes32 m0;</span>
  7106 |     | <span class='neutral'>        bytes32 m1;</span>
  7107 |     | <span class='neutral'>        bytes32 m2;</span>
  7108 |     | <span class='neutral'>        bytes32 m3;</span>
  7109 |     | <span class='neutral'>        bytes32 m4;</span>
  7110 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  7111 |     | <span class='neutral'>        assembly {</span>
  7112 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  7113 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  7114 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  7115 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  7116 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  7117 |     | <span class='neutral'>            // Selector of `log(bool,uint256,uint256,uint256)`.</span>
  7118 |     | <span class='neutral'>            mstore(0x00, 0x374bb4b2)</span>
  7119 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  7120 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  7121 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  7122 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  7123 |     | <span class='neutral'>        }</span>
  7124 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x84);</span>
  7125 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  7126 |     | <span class='neutral'>        assembly {</span>
  7127 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  7128 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  7129 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  7130 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  7131 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  7132 |     | <span class='neutral'>        }</span>
  7133 |     | <span class='neutral'>    }</span>
  7134 |     | <span class='neutral'></span>
  7135 |     | <span class='neutral'>    function log(bool p0, uint256 p1, uint256 p2, bytes32 p3) internal pure {</span>
  7136 |     | <span class='neutral'>        bytes32 m0;</span>
  7137 |     | <span class='neutral'>        bytes32 m1;</span>
  7138 |     | <span class='neutral'>        bytes32 m2;</span>
  7139 |     | <span class='neutral'>        bytes32 m3;</span>
  7140 |     | <span class='neutral'>        bytes32 m4;</span>
  7141 |     | <span class='neutral'>        bytes32 m5;</span>
  7142 |     | <span class='neutral'>        bytes32 m6;</span>
  7143 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  7144 |     | <span class='neutral'>        assembly {</span>
  7145 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  7146 |     | <span class='neutral'>                let length := 0</span>
  7147 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  7148 |     | <span class='neutral'>                mstore(pos, length)</span>
  7149 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  7150 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  7151 |     | <span class='neutral'>            }</span>
  7152 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  7153 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  7154 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  7155 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  7156 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  7157 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  7158 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
  7159 |     | <span class='neutral'>            // Selector of `log(bool,uint256,uint256,string)`.</span>
  7160 |     | <span class='neutral'>            mstore(0x00, 0x8e69fb5d)</span>
  7161 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  7162 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  7163 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  7164 |     | <span class='neutral'>            mstore(0x80, 0x80)</span>
  7165 |     | <span class='neutral'>            writeString(0xa0, p3)</span>
  7166 |     | <span class='neutral'>        }</span>
  7167 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xc4);</span>
  7168 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  7169 |     | <span class='neutral'>        assembly {</span>
  7170 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  7171 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  7172 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  7173 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  7174 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  7175 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  7176 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
  7177 |     | <span class='neutral'>        }</span>
  7178 |     | <span class='neutral'>    }</span>
  7179 |     | <span class='neutral'></span>
  7180 |     | <span class='neutral'>    function log(bool p0, uint256 p1, bytes32 p2, address p3) internal pure {</span>
  7181 |     | <span class='neutral'>        bytes32 m0;</span>
  7182 |     | <span class='neutral'>        bytes32 m1;</span>
  7183 |     | <span class='neutral'>        bytes32 m2;</span>
  7184 |     | <span class='neutral'>        bytes32 m3;</span>
  7185 |     | <span class='neutral'>        bytes32 m4;</span>
  7186 |     | <span class='neutral'>        bytes32 m5;</span>
  7187 |     | <span class='neutral'>        bytes32 m6;</span>
  7188 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  7189 |     | <span class='neutral'>        assembly {</span>
  7190 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  7191 |     | <span class='neutral'>                let length := 0</span>
  7192 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  7193 |     | <span class='neutral'>                mstore(pos, length)</span>
  7194 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  7195 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  7196 |     | <span class='neutral'>            }</span>
  7197 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  7198 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  7199 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  7200 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  7201 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  7202 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  7203 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
  7204 |     | <span class='neutral'>            // Selector of `log(bool,uint256,string,address)`.</span>
  7205 |     | <span class='neutral'>            mstore(0x00, 0xfedd1fff)</span>
  7206 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  7207 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  7208 |     | <span class='neutral'>            mstore(0x60, 0x80)</span>
  7209 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  7210 |     | <span class='neutral'>            writeString(0xa0, p2)</span>
  7211 |     | <span class='neutral'>        }</span>
  7212 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xc4);</span>
  7213 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  7214 |     | <span class='neutral'>        assembly {</span>
  7215 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  7216 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  7217 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  7218 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  7219 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  7220 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  7221 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
  7222 |     | <span class='neutral'>        }</span>
  7223 |     | <span class='neutral'>    }</span>
  7224 |     | <span class='neutral'></span>
  7225 |     | <span class='neutral'>    function log(bool p0, uint256 p1, bytes32 p2, bool p3) internal pure {</span>
  7226 |     | <span class='neutral'>        bytes32 m0;</span>
  7227 |     | <span class='neutral'>        bytes32 m1;</span>
  7228 |     | <span class='neutral'>        bytes32 m2;</span>
  7229 |     | <span class='neutral'>        bytes32 m3;</span>
  7230 |     | <span class='neutral'>        bytes32 m4;</span>
  7231 |     | <span class='neutral'>        bytes32 m5;</span>
  7232 |     | <span class='neutral'>        bytes32 m6;</span>
  7233 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  7234 |     | <span class='neutral'>        assembly {</span>
  7235 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  7236 |     | <span class='neutral'>                let length := 0</span>
  7237 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  7238 |     | <span class='neutral'>                mstore(pos, length)</span>
  7239 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  7240 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  7241 |     | <span class='neutral'>            }</span>
  7242 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  7243 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  7244 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  7245 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  7246 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  7247 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  7248 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
  7249 |     | <span class='neutral'>            // Selector of `log(bool,uint256,string,bool)`.</span>
  7250 |     | <span class='neutral'>            mstore(0x00, 0xe5e70b2b)</span>
  7251 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  7252 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  7253 |     | <span class='neutral'>            mstore(0x60, 0x80)</span>
  7254 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  7255 |     | <span class='neutral'>            writeString(0xa0, p2)</span>
  7256 |     | <span class='neutral'>        }</span>
  7257 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xc4);</span>
  7258 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  7259 |     | <span class='neutral'>        assembly {</span>
  7260 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  7261 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  7262 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  7263 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  7264 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  7265 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  7266 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
  7267 |     | <span class='neutral'>        }</span>
  7268 |     | <span class='neutral'>    }</span>
  7269 |     | <span class='neutral'></span>
  7270 |     | <span class='neutral'>    function log(bool p0, uint256 p1, bytes32 p2, uint256 p3) internal pure {</span>
  7271 |     | <span class='neutral'>        bytes32 m0;</span>
  7272 |     | <span class='neutral'>        bytes32 m1;</span>
  7273 |     | <span class='neutral'>        bytes32 m2;</span>
  7274 |     | <span class='neutral'>        bytes32 m3;</span>
  7275 |     | <span class='neutral'>        bytes32 m4;</span>
  7276 |     | <span class='neutral'>        bytes32 m5;</span>
  7277 |     | <span class='neutral'>        bytes32 m6;</span>
  7278 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  7279 |     | <span class='neutral'>        assembly {</span>
  7280 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  7281 |     | <span class='neutral'>                let length := 0</span>
  7282 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  7283 |     | <span class='neutral'>                mstore(pos, length)</span>
  7284 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  7285 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  7286 |     | <span class='neutral'>            }</span>
  7287 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  7288 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  7289 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  7290 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  7291 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  7292 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  7293 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
  7294 |     | <span class='neutral'>            // Selector of `log(bool,uint256,string,uint256)`.</span>
  7295 |     | <span class='neutral'>            mstore(0x00, 0x6a1199e2)</span>
  7296 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  7297 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  7298 |     | <span class='neutral'>            mstore(0x60, 0x80)</span>
  7299 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  7300 |     | <span class='neutral'>            writeString(0xa0, p2)</span>
  7301 |     | <span class='neutral'>        }</span>
  7302 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xc4);</span>
  7303 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  7304 |     | <span class='neutral'>        assembly {</span>
  7305 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  7306 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  7307 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  7308 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  7309 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  7310 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  7311 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
  7312 |     | <span class='neutral'>        }</span>
  7313 |     | <span class='neutral'>    }</span>
  7314 |     | <span class='neutral'></span>
  7315 |     | <span class='neutral'>    function log(bool p0, uint256 p1, bytes32 p2, bytes32 p3) internal pure {</span>
  7316 |     | <span class='neutral'>        bytes32 m0;</span>
  7317 |     | <span class='neutral'>        bytes32 m1;</span>
  7318 |     | <span class='neutral'>        bytes32 m2;</span>
  7319 |     | <span class='neutral'>        bytes32 m3;</span>
  7320 |     | <span class='neutral'>        bytes32 m4;</span>
  7321 |     | <span class='neutral'>        bytes32 m5;</span>
  7322 |     | <span class='neutral'>        bytes32 m6;</span>
  7323 |     | <span class='neutral'>        bytes32 m7;</span>
  7324 |     | <span class='neutral'>        bytes32 m8;</span>
  7325 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  7326 |     | <span class='neutral'>        assembly {</span>
  7327 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  7328 |     | <span class='neutral'>                let length := 0</span>
  7329 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  7330 |     | <span class='neutral'>                mstore(pos, length)</span>
  7331 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  7332 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  7333 |     | <span class='neutral'>            }</span>
  7334 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  7335 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  7336 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  7337 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  7338 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  7339 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  7340 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
  7341 |     | <span class='neutral'>            m7 := mload(0xe0)</span>
  7342 |     | <span class='neutral'>            m8 := mload(0x100)</span>
  7343 |     | <span class='neutral'>            // Selector of `log(bool,uint256,string,string)`.</span>
  7344 |     | <span class='neutral'>            mstore(0x00, 0xf5bc2249)</span>
  7345 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  7346 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  7347 |     | <span class='neutral'>            mstore(0x60, 0x80)</span>
  7348 |     | <span class='neutral'>            mstore(0x80, 0xc0)</span>
  7349 |     | <span class='neutral'>            writeString(0xa0, p2)</span>
  7350 |     | <span class='neutral'>            writeString(0xe0, p3)</span>
  7351 |     | <span class='neutral'>        }</span>
  7352 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x104);</span>
  7353 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  7354 |     | <span class='neutral'>        assembly {</span>
  7355 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  7356 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  7357 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  7358 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  7359 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  7360 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  7361 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
  7362 |     | <span class='neutral'>            mstore(0xe0, m7)</span>
  7363 |     | <span class='neutral'>            mstore(0x100, m8)</span>
  7364 |     | <span class='neutral'>        }</span>
  7365 |     | <span class='neutral'>    }</span>
  7366 |     | <span class='neutral'></span>
  7367 |     | <span class='neutral'>    function log(bool p0, bytes32 p1, address p2, address p3) internal pure {</span>
  7368 |     | <span class='neutral'>        bytes32 m0;</span>
  7369 |     | <span class='neutral'>        bytes32 m1;</span>
  7370 |     | <span class='neutral'>        bytes32 m2;</span>
  7371 |     | <span class='neutral'>        bytes32 m3;</span>
  7372 |     | <span class='neutral'>        bytes32 m4;</span>
  7373 |     | <span class='neutral'>        bytes32 m5;</span>
  7374 |     | <span class='neutral'>        bytes32 m6;</span>
  7375 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  7376 |     | <span class='neutral'>        assembly {</span>
  7377 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  7378 |     | <span class='neutral'>                let length := 0</span>
  7379 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  7380 |     | <span class='neutral'>                mstore(pos, length)</span>
  7381 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  7382 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  7383 |     | <span class='neutral'>            }</span>
  7384 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  7385 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  7386 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  7387 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  7388 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  7389 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  7390 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
  7391 |     | <span class='neutral'>            // Selector of `log(bool,string,address,address)`.</span>
  7392 |     | <span class='neutral'>            mstore(0x00, 0x2b2b18dc)</span>
  7393 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  7394 |     | <span class='neutral'>            mstore(0x40, 0x80)</span>
  7395 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  7396 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  7397 |     | <span class='neutral'>            writeString(0xa0, p1)</span>
  7398 |     | <span class='neutral'>        }</span>
  7399 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xc4);</span>
  7400 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  7401 |     | <span class='neutral'>        assembly {</span>
  7402 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  7403 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  7404 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  7405 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  7406 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  7407 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  7408 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
  7409 |     | <span class='neutral'>        }</span>
  7410 |     | <span class='neutral'>    }</span>
  7411 |     | <span class='neutral'></span>
  7412 |     | <span class='neutral'>    function log(bool p0, bytes32 p1, address p2, bool p3) internal pure {</span>
  7413 |     | <span class='neutral'>        bytes32 m0;</span>
  7414 |     | <span class='neutral'>        bytes32 m1;</span>
  7415 |     | <span class='neutral'>        bytes32 m2;</span>
  7416 |     | <span class='neutral'>        bytes32 m3;</span>
  7417 |     | <span class='neutral'>        bytes32 m4;</span>
  7418 |     | <span class='neutral'>        bytes32 m5;</span>
  7419 |     | <span class='neutral'>        bytes32 m6;</span>
  7420 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  7421 |     | <span class='neutral'>        assembly {</span>
  7422 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  7423 |     | <span class='neutral'>                let length := 0</span>
  7424 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  7425 |     | <span class='neutral'>                mstore(pos, length)</span>
  7426 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  7427 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  7428 |     | <span class='neutral'>            }</span>
  7429 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  7430 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  7431 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  7432 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  7433 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  7434 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  7435 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
  7436 |     | <span class='neutral'>            // Selector of `log(bool,string,address,bool)`.</span>
  7437 |     | <span class='neutral'>            mstore(0x00, 0x6dd434ca)</span>
  7438 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  7439 |     | <span class='neutral'>            mstore(0x40, 0x80)</span>
  7440 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  7441 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  7442 |     | <span class='neutral'>            writeString(0xa0, p1)</span>
  7443 |     | <span class='neutral'>        }</span>
  7444 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xc4);</span>
  7445 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  7446 |     | <span class='neutral'>        assembly {</span>
  7447 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  7448 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  7449 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  7450 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  7451 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  7452 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  7453 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
  7454 |     | <span class='neutral'>        }</span>
  7455 |     | <span class='neutral'>    }</span>
  7456 |     | <span class='neutral'></span>
  7457 |     | <span class='neutral'>    function log(bool p0, bytes32 p1, address p2, uint256 p3) internal pure {</span>
  7458 |     | <span class='neutral'>        bytes32 m0;</span>
  7459 |     | <span class='neutral'>        bytes32 m1;</span>
  7460 |     | <span class='neutral'>        bytes32 m2;</span>
  7461 |     | <span class='neutral'>        bytes32 m3;</span>
  7462 |     | <span class='neutral'>        bytes32 m4;</span>
  7463 |     | <span class='neutral'>        bytes32 m5;</span>
  7464 |     | <span class='neutral'>        bytes32 m6;</span>
  7465 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  7466 |     | <span class='neutral'>        assembly {</span>
  7467 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  7468 |     | <span class='neutral'>                let length := 0</span>
  7469 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  7470 |     | <span class='neutral'>                mstore(pos, length)</span>
  7471 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  7472 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  7473 |     | <span class='neutral'>            }</span>
  7474 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  7475 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  7476 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  7477 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  7478 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  7479 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  7480 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
  7481 |     | <span class='neutral'>            // Selector of `log(bool,string,address,uint256)`.</span>
  7482 |     | <span class='neutral'>            mstore(0x00, 0xa5cada94)</span>
  7483 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  7484 |     | <span class='neutral'>            mstore(0x40, 0x80)</span>
  7485 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  7486 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  7487 |     | <span class='neutral'>            writeString(0xa0, p1)</span>
  7488 |     | <span class='neutral'>        }</span>
  7489 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xc4);</span>
  7490 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  7491 |     | <span class='neutral'>        assembly {</span>
  7492 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  7493 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  7494 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  7495 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  7496 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  7497 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  7498 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
  7499 |     | <span class='neutral'>        }</span>
  7500 |     | <span class='neutral'>    }</span>
  7501 |     | <span class='neutral'></span>
  7502 |     | <span class='neutral'>    function log(bool p0, bytes32 p1, address p2, bytes32 p3) internal pure {</span>
  7503 |     | <span class='neutral'>        bytes32 m0;</span>
  7504 |     | <span class='neutral'>        bytes32 m1;</span>
  7505 |     | <span class='neutral'>        bytes32 m2;</span>
  7506 |     | <span class='neutral'>        bytes32 m3;</span>
  7507 |     | <span class='neutral'>        bytes32 m4;</span>
  7508 |     | <span class='neutral'>        bytes32 m5;</span>
  7509 |     | <span class='neutral'>        bytes32 m6;</span>
  7510 |     | <span class='neutral'>        bytes32 m7;</span>
  7511 |     | <span class='neutral'>        bytes32 m8;</span>
  7512 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  7513 |     | <span class='neutral'>        assembly {</span>
  7514 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  7515 |     | <span class='neutral'>                let length := 0</span>
  7516 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  7517 |     | <span class='neutral'>                mstore(pos, length)</span>
  7518 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  7519 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  7520 |     | <span class='neutral'>            }</span>
  7521 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  7522 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  7523 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  7524 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  7525 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  7526 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  7527 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
  7528 |     | <span class='neutral'>            m7 := mload(0xe0)</span>
  7529 |     | <span class='neutral'>            m8 := mload(0x100)</span>
  7530 |     | <span class='neutral'>            // Selector of `log(bool,string,address,string)`.</span>
  7531 |     | <span class='neutral'>            mstore(0x00, 0x12d6c788)</span>
  7532 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  7533 |     | <span class='neutral'>            mstore(0x40, 0x80)</span>
  7534 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  7535 |     | <span class='neutral'>            mstore(0x80, 0xc0)</span>
  7536 |     | <span class='neutral'>            writeString(0xa0, p1)</span>
  7537 |     | <span class='neutral'>            writeString(0xe0, p3)</span>
  7538 |     | <span class='neutral'>        }</span>
  7539 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x104);</span>
  7540 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  7541 |     | <span class='neutral'>        assembly {</span>
  7542 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  7543 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  7544 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  7545 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  7546 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  7547 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  7548 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
  7549 |     | <span class='neutral'>            mstore(0xe0, m7)</span>
  7550 |     | <span class='neutral'>            mstore(0x100, m8)</span>
  7551 |     | <span class='neutral'>        }</span>
  7552 |     | <span class='neutral'>    }</span>
  7553 |     | <span class='neutral'></span>
  7554 |     | <span class='neutral'>    function log(bool p0, bytes32 p1, bool p2, address p3) internal pure {</span>
  7555 |     | <span class='neutral'>        bytes32 m0;</span>
  7556 |     | <span class='neutral'>        bytes32 m1;</span>
  7557 |     | <span class='neutral'>        bytes32 m2;</span>
  7558 |     | <span class='neutral'>        bytes32 m3;</span>
  7559 |     | <span class='neutral'>        bytes32 m4;</span>
  7560 |     | <span class='neutral'>        bytes32 m5;</span>
  7561 |     | <span class='neutral'>        bytes32 m6;</span>
  7562 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  7563 |     | <span class='neutral'>        assembly {</span>
  7564 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  7565 |     | <span class='neutral'>                let length := 0</span>
  7566 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  7567 |     | <span class='neutral'>                mstore(pos, length)</span>
  7568 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  7569 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  7570 |     | <span class='neutral'>            }</span>
  7571 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  7572 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  7573 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  7574 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  7575 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  7576 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  7577 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
  7578 |     | <span class='neutral'>            // Selector of `log(bool,string,bool,address)`.</span>
  7579 |     | <span class='neutral'>            mstore(0x00, 0x538e06ab)</span>
  7580 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  7581 |     | <span class='neutral'>            mstore(0x40, 0x80)</span>
  7582 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  7583 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  7584 |     | <span class='neutral'>            writeString(0xa0, p1)</span>
  7585 |     | <span class='neutral'>        }</span>
  7586 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xc4);</span>
  7587 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  7588 |     | <span class='neutral'>        assembly {</span>
  7589 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  7590 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  7591 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  7592 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  7593 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  7594 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  7595 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
  7596 |     | <span class='neutral'>        }</span>
  7597 |     | <span class='neutral'>    }</span>
  7598 |     | <span class='neutral'></span>
  7599 |     | <span class='neutral'>    function log(bool p0, bytes32 p1, bool p2, bool p3) internal pure {</span>
  7600 |     | <span class='neutral'>        bytes32 m0;</span>
  7601 |     | <span class='neutral'>        bytes32 m1;</span>
  7602 |     | <span class='neutral'>        bytes32 m2;</span>
  7603 |     | <span class='neutral'>        bytes32 m3;</span>
  7604 |     | <span class='neutral'>        bytes32 m4;</span>
  7605 |     | <span class='neutral'>        bytes32 m5;</span>
  7606 |     | <span class='neutral'>        bytes32 m6;</span>
  7607 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  7608 |     | <span class='neutral'>        assembly {</span>
  7609 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  7610 |     | <span class='neutral'>                let length := 0</span>
  7611 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  7612 |     | <span class='neutral'>                mstore(pos, length)</span>
  7613 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  7614 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  7615 |     | <span class='neutral'>            }</span>
  7616 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  7617 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  7618 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  7619 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  7620 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  7621 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  7622 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
  7623 |     | <span class='neutral'>            // Selector of `log(bool,string,bool,bool)`.</span>
  7624 |     | <span class='neutral'>            mstore(0x00, 0xdc5e935b)</span>
  7625 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  7626 |     | <span class='neutral'>            mstore(0x40, 0x80)</span>
  7627 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  7628 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  7629 |     | <span class='neutral'>            writeString(0xa0, p1)</span>
  7630 |     | <span class='neutral'>        }</span>
  7631 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xc4);</span>
  7632 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  7633 |     | <span class='neutral'>        assembly {</span>
  7634 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  7635 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  7636 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  7637 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  7638 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  7639 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  7640 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
  7641 |     | <span class='neutral'>        }</span>
  7642 |     | <span class='neutral'>    }</span>
  7643 |     | <span class='neutral'></span>
  7644 |     | <span class='neutral'>    function log(bool p0, bytes32 p1, bool p2, uint256 p3) internal pure {</span>
  7645 |     | <span class='neutral'>        bytes32 m0;</span>
  7646 |     | <span class='neutral'>        bytes32 m1;</span>
  7647 |     | <span class='neutral'>        bytes32 m2;</span>
  7648 |     | <span class='neutral'>        bytes32 m3;</span>
  7649 |     | <span class='neutral'>        bytes32 m4;</span>
  7650 |     | <span class='neutral'>        bytes32 m5;</span>
  7651 |     | <span class='neutral'>        bytes32 m6;</span>
  7652 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  7653 |     | <span class='neutral'>        assembly {</span>
  7654 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  7655 |     | <span class='neutral'>                let length := 0</span>
  7656 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  7657 |     | <span class='neutral'>                mstore(pos, length)</span>
  7658 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  7659 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  7660 |     | <span class='neutral'>            }</span>
  7661 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  7662 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  7663 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  7664 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  7665 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  7666 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  7667 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
  7668 |     | <span class='neutral'>            // Selector of `log(bool,string,bool,uint256)`.</span>
  7669 |     | <span class='neutral'>            mstore(0x00, 0x1606a393)</span>
  7670 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  7671 |     | <span class='neutral'>            mstore(0x40, 0x80)</span>
  7672 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  7673 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  7674 |     | <span class='neutral'>            writeString(0xa0, p1)</span>
  7675 |     | <span class='neutral'>        }</span>
  7676 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xc4);</span>
  7677 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  7678 |     | <span class='neutral'>        assembly {</span>
  7679 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  7680 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  7681 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  7682 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  7683 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  7684 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  7685 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
  7686 |     | <span class='neutral'>        }</span>
  7687 |     | <span class='neutral'>    }</span>
  7688 |     | <span class='neutral'></span>
  7689 |     | <span class='neutral'>    function log(bool p0, bytes32 p1, bool p2, bytes32 p3) internal pure {</span>
  7690 |     | <span class='neutral'>        bytes32 m0;</span>
  7691 |     | <span class='neutral'>        bytes32 m1;</span>
  7692 |     | <span class='neutral'>        bytes32 m2;</span>
  7693 |     | <span class='neutral'>        bytes32 m3;</span>
  7694 |     | <span class='neutral'>        bytes32 m4;</span>
  7695 |     | <span class='neutral'>        bytes32 m5;</span>
  7696 |     | <span class='neutral'>        bytes32 m6;</span>
  7697 |     | <span class='neutral'>        bytes32 m7;</span>
  7698 |     | <span class='neutral'>        bytes32 m8;</span>
  7699 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  7700 |     | <span class='neutral'>        assembly {</span>
  7701 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  7702 |     | <span class='neutral'>                let length := 0</span>
  7703 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  7704 |     | <span class='neutral'>                mstore(pos, length)</span>
  7705 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  7706 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  7707 |     | <span class='neutral'>            }</span>
  7708 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  7709 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  7710 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  7711 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  7712 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  7713 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  7714 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
  7715 |     | <span class='neutral'>            m7 := mload(0xe0)</span>
  7716 |     | <span class='neutral'>            m8 := mload(0x100)</span>
  7717 |     | <span class='neutral'>            // Selector of `log(bool,string,bool,string)`.</span>
  7718 |     | <span class='neutral'>            mstore(0x00, 0x483d0416)</span>
  7719 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  7720 |     | <span class='neutral'>            mstore(0x40, 0x80)</span>
  7721 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  7722 |     | <span class='neutral'>            mstore(0x80, 0xc0)</span>
  7723 |     | <span class='neutral'>            writeString(0xa0, p1)</span>
  7724 |     | <span class='neutral'>            writeString(0xe0, p3)</span>
  7725 |     | <span class='neutral'>        }</span>
  7726 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x104);</span>
  7727 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  7728 |     | <span class='neutral'>        assembly {</span>
  7729 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  7730 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  7731 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  7732 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  7733 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  7734 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  7735 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
  7736 |     | <span class='neutral'>            mstore(0xe0, m7)</span>
  7737 |     | <span class='neutral'>            mstore(0x100, m8)</span>
  7738 |     | <span class='neutral'>        }</span>
  7739 |     | <span class='neutral'>    }</span>
  7740 |     | <span class='neutral'></span>
  7741 |     | <span class='neutral'>    function log(bool p0, bytes32 p1, uint256 p2, address p3) internal pure {</span>
  7742 |     | <span class='neutral'>        bytes32 m0;</span>
  7743 |     | <span class='neutral'>        bytes32 m1;</span>
  7744 |     | <span class='neutral'>        bytes32 m2;</span>
  7745 |     | <span class='neutral'>        bytes32 m3;</span>
  7746 |     | <span class='neutral'>        bytes32 m4;</span>
  7747 |     | <span class='neutral'>        bytes32 m5;</span>
  7748 |     | <span class='neutral'>        bytes32 m6;</span>
  7749 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  7750 |     | <span class='neutral'>        assembly {</span>
  7751 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  7752 |     | <span class='neutral'>                let length := 0</span>
  7753 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  7754 |     | <span class='neutral'>                mstore(pos, length)</span>
  7755 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  7756 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  7757 |     | <span class='neutral'>            }</span>
  7758 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  7759 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  7760 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  7761 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  7762 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  7763 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  7764 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
  7765 |     | <span class='neutral'>            // Selector of `log(bool,string,uint256,address)`.</span>
  7766 |     | <span class='neutral'>            mstore(0x00, 0x1596a1ce)</span>
  7767 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  7768 |     | <span class='neutral'>            mstore(0x40, 0x80)</span>
  7769 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  7770 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  7771 |     | <span class='neutral'>            writeString(0xa0, p1)</span>
  7772 |     | <span class='neutral'>        }</span>
  7773 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xc4);</span>
  7774 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  7775 |     | <span class='neutral'>        assembly {</span>
  7776 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  7777 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  7778 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  7779 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  7780 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  7781 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  7782 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
  7783 |     | <span class='neutral'>        }</span>
  7784 |     | <span class='neutral'>    }</span>
  7785 |     | <span class='neutral'></span>
  7786 |     | <span class='neutral'>    function log(bool p0, bytes32 p1, uint256 p2, bool p3) internal pure {</span>
  7787 |     | <span class='neutral'>        bytes32 m0;</span>
  7788 |     | <span class='neutral'>        bytes32 m1;</span>
  7789 |     | <span class='neutral'>        bytes32 m2;</span>
  7790 |     | <span class='neutral'>        bytes32 m3;</span>
  7791 |     | <span class='neutral'>        bytes32 m4;</span>
  7792 |     | <span class='neutral'>        bytes32 m5;</span>
  7793 |     | <span class='neutral'>        bytes32 m6;</span>
  7794 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  7795 |     | <span class='neutral'>        assembly {</span>
  7796 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  7797 |     | <span class='neutral'>                let length := 0</span>
  7798 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  7799 |     | <span class='neutral'>                mstore(pos, length)</span>
  7800 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  7801 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  7802 |     | <span class='neutral'>            }</span>
  7803 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  7804 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  7805 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  7806 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  7807 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  7808 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  7809 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
  7810 |     | <span class='neutral'>            // Selector of `log(bool,string,uint256,bool)`.</span>
  7811 |     | <span class='neutral'>            mstore(0x00, 0x6b0e5d53)</span>
  7812 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  7813 |     | <span class='neutral'>            mstore(0x40, 0x80)</span>
  7814 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  7815 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  7816 |     | <span class='neutral'>            writeString(0xa0, p1)</span>
  7817 |     | <span class='neutral'>        }</span>
  7818 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xc4);</span>
  7819 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  7820 |     | <span class='neutral'>        assembly {</span>
  7821 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  7822 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  7823 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  7824 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  7825 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  7826 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  7827 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
  7828 |     | <span class='neutral'>        }</span>
  7829 |     | <span class='neutral'>    }</span>
  7830 |     | <span class='neutral'></span>
  7831 |     | <span class='neutral'>    function log(bool p0, bytes32 p1, uint256 p2, uint256 p3) internal pure {</span>
  7832 |     | <span class='neutral'>        bytes32 m0;</span>
  7833 |     | <span class='neutral'>        bytes32 m1;</span>
  7834 |     | <span class='neutral'>        bytes32 m2;</span>
  7835 |     | <span class='neutral'>        bytes32 m3;</span>
  7836 |     | <span class='neutral'>        bytes32 m4;</span>
  7837 |     | <span class='neutral'>        bytes32 m5;</span>
  7838 |     | <span class='neutral'>        bytes32 m6;</span>
  7839 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  7840 |     | <span class='neutral'>        assembly {</span>
  7841 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  7842 |     | <span class='neutral'>                let length := 0</span>
  7843 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  7844 |     | <span class='neutral'>                mstore(pos, length)</span>
  7845 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  7846 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  7847 |     | <span class='neutral'>            }</span>
  7848 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  7849 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  7850 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  7851 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  7852 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  7853 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  7854 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
  7855 |     | <span class='neutral'>            // Selector of `log(bool,string,uint256,uint256)`.</span>
  7856 |     | <span class='neutral'>            mstore(0x00, 0x28863fcb)</span>
  7857 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  7858 |     | <span class='neutral'>            mstore(0x40, 0x80)</span>
  7859 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  7860 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  7861 |     | <span class='neutral'>            writeString(0xa0, p1)</span>
  7862 |     | <span class='neutral'>        }</span>
  7863 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xc4);</span>
  7864 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  7865 |     | <span class='neutral'>        assembly {</span>
  7866 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  7867 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  7868 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  7869 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  7870 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  7871 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  7872 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
  7873 |     | <span class='neutral'>        }</span>
  7874 |     | <span class='neutral'>    }</span>
  7875 |     | <span class='neutral'></span>
  7876 |     | <span class='neutral'>    function log(bool p0, bytes32 p1, uint256 p2, bytes32 p3) internal pure {</span>
  7877 |     | <span class='neutral'>        bytes32 m0;</span>
  7878 |     | <span class='neutral'>        bytes32 m1;</span>
  7879 |     | <span class='neutral'>        bytes32 m2;</span>
  7880 |     | <span class='neutral'>        bytes32 m3;</span>
  7881 |     | <span class='neutral'>        bytes32 m4;</span>
  7882 |     | <span class='neutral'>        bytes32 m5;</span>
  7883 |     | <span class='neutral'>        bytes32 m6;</span>
  7884 |     | <span class='neutral'>        bytes32 m7;</span>
  7885 |     | <span class='neutral'>        bytes32 m8;</span>
  7886 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  7887 |     | <span class='neutral'>        assembly {</span>
  7888 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  7889 |     | <span class='neutral'>                let length := 0</span>
  7890 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  7891 |     | <span class='neutral'>                mstore(pos, length)</span>
  7892 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  7893 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  7894 |     | <span class='neutral'>            }</span>
  7895 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  7896 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  7897 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  7898 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  7899 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  7900 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  7901 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
  7902 |     | <span class='neutral'>            m7 := mload(0xe0)</span>
  7903 |     | <span class='neutral'>            m8 := mload(0x100)</span>
  7904 |     | <span class='neutral'>            // Selector of `log(bool,string,uint256,string)`.</span>
  7905 |     | <span class='neutral'>            mstore(0x00, 0x1ad96de6)</span>
  7906 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  7907 |     | <span class='neutral'>            mstore(0x40, 0x80)</span>
  7908 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  7909 |     | <span class='neutral'>            mstore(0x80, 0xc0)</span>
  7910 |     | <span class='neutral'>            writeString(0xa0, p1)</span>
  7911 |     | <span class='neutral'>            writeString(0xe0, p3)</span>
  7912 |     | <span class='neutral'>        }</span>
  7913 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x104);</span>
  7914 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  7915 |     | <span class='neutral'>        assembly {</span>
  7916 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  7917 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  7918 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  7919 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  7920 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  7921 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  7922 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
  7923 |     | <span class='neutral'>            mstore(0xe0, m7)</span>
  7924 |     | <span class='neutral'>            mstore(0x100, m8)</span>
  7925 |     | <span class='neutral'>        }</span>
  7926 |     | <span class='neutral'>    }</span>
  7927 |     | <span class='neutral'></span>
  7928 |     | <span class='neutral'>    function log(bool p0, bytes32 p1, bytes32 p2, address p3) internal pure {</span>
  7929 |     | <span class='neutral'>        bytes32 m0;</span>
  7930 |     | <span class='neutral'>        bytes32 m1;</span>
  7931 |     | <span class='neutral'>        bytes32 m2;</span>
  7932 |     | <span class='neutral'>        bytes32 m3;</span>
  7933 |     | <span class='neutral'>        bytes32 m4;</span>
  7934 |     | <span class='neutral'>        bytes32 m5;</span>
  7935 |     | <span class='neutral'>        bytes32 m6;</span>
  7936 |     | <span class='neutral'>        bytes32 m7;</span>
  7937 |     | <span class='neutral'>        bytes32 m8;</span>
  7938 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  7939 |     | <span class='neutral'>        assembly {</span>
  7940 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  7941 |     | <span class='neutral'>                let length := 0</span>
  7942 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  7943 |     | <span class='neutral'>                mstore(pos, length)</span>
  7944 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  7945 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  7946 |     | <span class='neutral'>            }</span>
  7947 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  7948 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  7949 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  7950 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  7951 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  7952 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  7953 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
  7954 |     | <span class='neutral'>            m7 := mload(0xe0)</span>
  7955 |     | <span class='neutral'>            m8 := mload(0x100)</span>
  7956 |     | <span class='neutral'>            // Selector of `log(bool,string,string,address)`.</span>
  7957 |     | <span class='neutral'>            mstore(0x00, 0x97d394d8)</span>
  7958 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  7959 |     | <span class='neutral'>            mstore(0x40, 0x80)</span>
  7960 |     | <span class='neutral'>            mstore(0x60, 0xc0)</span>
  7961 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  7962 |     | <span class='neutral'>            writeString(0xa0, p1)</span>
  7963 |     | <span class='neutral'>            writeString(0xe0, p2)</span>
  7964 |     | <span class='neutral'>        }</span>
  7965 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x104);</span>
  7966 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  7967 |     | <span class='neutral'>        assembly {</span>
  7968 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  7969 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  7970 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  7971 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  7972 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  7973 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  7974 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
  7975 |     | <span class='neutral'>            mstore(0xe0, m7)</span>
  7976 |     | <span class='neutral'>            mstore(0x100, m8)</span>
  7977 |     | <span class='neutral'>        }</span>
  7978 |     | <span class='neutral'>    }</span>
  7979 |     | <span class='neutral'></span>
  7980 |     | <span class='neutral'>    function log(bool p0, bytes32 p1, bytes32 p2, bool p3) internal pure {</span>
  7981 |     | <span class='neutral'>        bytes32 m0;</span>
  7982 |     | <span class='neutral'>        bytes32 m1;</span>
  7983 |     | <span class='neutral'>        bytes32 m2;</span>
  7984 |     | <span class='neutral'>        bytes32 m3;</span>
  7985 |     | <span class='neutral'>        bytes32 m4;</span>
  7986 |     | <span class='neutral'>        bytes32 m5;</span>
  7987 |     | <span class='neutral'>        bytes32 m6;</span>
  7988 |     | <span class='neutral'>        bytes32 m7;</span>
  7989 |     | <span class='neutral'>        bytes32 m8;</span>
  7990 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  7991 |     | <span class='neutral'>        assembly {</span>
  7992 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  7993 |     | <span class='neutral'>                let length := 0</span>
  7994 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  7995 |     | <span class='neutral'>                mstore(pos, length)</span>
  7996 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  7997 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  7998 |     | <span class='neutral'>            }</span>
  7999 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  8000 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  8001 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  8002 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  8003 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  8004 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  8005 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
  8006 |     | <span class='neutral'>            m7 := mload(0xe0)</span>
  8007 |     | <span class='neutral'>            m8 := mload(0x100)</span>
  8008 |     | <span class='neutral'>            // Selector of `log(bool,string,string,bool)`.</span>
  8009 |     | <span class='neutral'>            mstore(0x00, 0x1e4b87e5)</span>
  8010 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  8011 |     | <span class='neutral'>            mstore(0x40, 0x80)</span>
  8012 |     | <span class='neutral'>            mstore(0x60, 0xc0)</span>
  8013 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  8014 |     | <span class='neutral'>            writeString(0xa0, p1)</span>
  8015 |     | <span class='neutral'>            writeString(0xe0, p2)</span>
  8016 |     | <span class='neutral'>        }</span>
  8017 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x104);</span>
  8018 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  8019 |     | <span class='neutral'>        assembly {</span>
  8020 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  8021 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  8022 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  8023 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  8024 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  8025 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  8026 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
  8027 |     | <span class='neutral'>            mstore(0xe0, m7)</span>
  8028 |     | <span class='neutral'>            mstore(0x100, m8)</span>
  8029 |     | <span class='neutral'>        }</span>
  8030 |     | <span class='neutral'>    }</span>
  8031 |     | <span class='neutral'></span>
  8032 |     | <span class='neutral'>    function log(bool p0, bytes32 p1, bytes32 p2, uint256 p3) internal pure {</span>
  8033 |     | <span class='neutral'>        bytes32 m0;</span>
  8034 |     | <span class='neutral'>        bytes32 m1;</span>
  8035 |     | <span class='neutral'>        bytes32 m2;</span>
  8036 |     | <span class='neutral'>        bytes32 m3;</span>
  8037 |     | <span class='neutral'>        bytes32 m4;</span>
  8038 |     | <span class='neutral'>        bytes32 m5;</span>
  8039 |     | <span class='neutral'>        bytes32 m6;</span>
  8040 |     | <span class='neutral'>        bytes32 m7;</span>
  8041 |     | <span class='neutral'>        bytes32 m8;</span>
  8042 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  8043 |     | <span class='neutral'>        assembly {</span>
  8044 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  8045 |     | <span class='neutral'>                let length := 0</span>
  8046 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  8047 |     | <span class='neutral'>                mstore(pos, length)</span>
  8048 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  8049 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  8050 |     | <span class='neutral'>            }</span>
  8051 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  8052 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  8053 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  8054 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  8055 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  8056 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  8057 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
  8058 |     | <span class='neutral'>            m7 := mload(0xe0)</span>
  8059 |     | <span class='neutral'>            m8 := mload(0x100)</span>
  8060 |     | <span class='neutral'>            // Selector of `log(bool,string,string,uint256)`.</span>
  8061 |     | <span class='neutral'>            mstore(0x00, 0x7be0c3eb)</span>
  8062 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  8063 |     | <span class='neutral'>            mstore(0x40, 0x80)</span>
  8064 |     | <span class='neutral'>            mstore(0x60, 0xc0)</span>
  8065 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  8066 |     | <span class='neutral'>            writeString(0xa0, p1)</span>
  8067 |     | <span class='neutral'>            writeString(0xe0, p2)</span>
  8068 |     | <span class='neutral'>        }</span>
  8069 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x104);</span>
  8070 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  8071 |     | <span class='neutral'>        assembly {</span>
  8072 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  8073 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  8074 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  8075 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  8076 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  8077 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  8078 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
  8079 |     | <span class='neutral'>            mstore(0xe0, m7)</span>
  8080 |     | <span class='neutral'>            mstore(0x100, m8)</span>
  8081 |     | <span class='neutral'>        }</span>
  8082 |     | <span class='neutral'>    }</span>
  8083 |     | <span class='neutral'></span>
  8084 |     | <span class='neutral'>    function log(bool p0, bytes32 p1, bytes32 p2, bytes32 p3) internal pure {</span>
  8085 |     | <span class='neutral'>        bytes32 m0;</span>
  8086 |     | <span class='neutral'>        bytes32 m1;</span>
  8087 |     | <span class='neutral'>        bytes32 m2;</span>
  8088 |     | <span class='neutral'>        bytes32 m3;</span>
  8089 |     | <span class='neutral'>        bytes32 m4;</span>
  8090 |     | <span class='neutral'>        bytes32 m5;</span>
  8091 |     | <span class='neutral'>        bytes32 m6;</span>
  8092 |     | <span class='neutral'>        bytes32 m7;</span>
  8093 |     | <span class='neutral'>        bytes32 m8;</span>
  8094 |     | <span class='neutral'>        bytes32 m9;</span>
  8095 |     | <span class='neutral'>        bytes32 m10;</span>
  8096 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  8097 |     | <span class='neutral'>        assembly {</span>
  8098 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  8099 |     | <span class='neutral'>                let length := 0</span>
  8100 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  8101 |     | <span class='neutral'>                mstore(pos, length)</span>
  8102 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  8103 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  8104 |     | <span class='neutral'>            }</span>
  8105 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  8106 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  8107 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  8108 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  8109 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  8110 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  8111 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
  8112 |     | <span class='neutral'>            m7 := mload(0xe0)</span>
  8113 |     | <span class='neutral'>            m8 := mload(0x100)</span>
  8114 |     | <span class='neutral'>            m9 := mload(0x120)</span>
  8115 |     | <span class='neutral'>            m10 := mload(0x140)</span>
  8116 |     | <span class='neutral'>            // Selector of `log(bool,string,string,string)`.</span>
  8117 |     | <span class='neutral'>            mstore(0x00, 0x1762e32a)</span>
  8118 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  8119 |     | <span class='neutral'>            mstore(0x40, 0x80)</span>
  8120 |     | <span class='neutral'>            mstore(0x60, 0xc0)</span>
  8121 |     | <span class='neutral'>            mstore(0x80, 0x100)</span>
  8122 |     | <span class='neutral'>            writeString(0xa0, p1)</span>
  8123 |     | <span class='neutral'>            writeString(0xe0, p2)</span>
  8124 |     | <span class='neutral'>            writeString(0x120, p3)</span>
  8125 |     | <span class='neutral'>        }</span>
  8126 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x144);</span>
  8127 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  8128 |     | <span class='neutral'>        assembly {</span>
  8129 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  8130 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  8131 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  8132 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  8133 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  8134 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  8135 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
  8136 |     | <span class='neutral'>            mstore(0xe0, m7)</span>
  8137 |     | <span class='neutral'>            mstore(0x100, m8)</span>
  8138 |     | <span class='neutral'>            mstore(0x120, m9)</span>
  8139 |     | <span class='neutral'>            mstore(0x140, m10)</span>
  8140 |     | <span class='neutral'>        }</span>
  8141 |     | <span class='neutral'>    }</span>
  8142 |     | <span class='neutral'></span>
  8143 |     | <span class='neutral'>    function log(uint256 p0, address p1, address p2, address p3) internal pure {</span>
  8144 |     | <span class='neutral'>        bytes32 m0;</span>
  8145 |     | <span class='neutral'>        bytes32 m1;</span>
  8146 |     | <span class='neutral'>        bytes32 m2;</span>
  8147 |     | <span class='neutral'>        bytes32 m3;</span>
  8148 |     | <span class='neutral'>        bytes32 m4;</span>
  8149 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  8150 |     | <span class='neutral'>        assembly {</span>
  8151 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  8152 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  8153 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  8154 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  8155 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  8156 |     | <span class='neutral'>            // Selector of `log(uint256,address,address,address)`.</span>
  8157 |     | <span class='neutral'>            mstore(0x00, 0x2488b414)</span>
  8158 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  8159 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  8160 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  8161 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  8162 |     | <span class='neutral'>        }</span>
  8163 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x84);</span>
  8164 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  8165 |     | <span class='neutral'>        assembly {</span>
  8166 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  8167 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  8168 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  8169 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  8170 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  8171 |     | <span class='neutral'>        }</span>
  8172 |     | <span class='neutral'>    }</span>
  8173 |     | <span class='neutral'></span>
  8174 |     | <span class='neutral'>    function log(uint256 p0, address p1, address p2, bool p3) internal pure {</span>
  8175 |     | <span class='neutral'>        bytes32 m0;</span>
  8176 |     | <span class='neutral'>        bytes32 m1;</span>
  8177 |     | <span class='neutral'>        bytes32 m2;</span>
  8178 |     | <span class='neutral'>        bytes32 m3;</span>
  8179 |     | <span class='neutral'>        bytes32 m4;</span>
  8180 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  8181 |     | <span class='neutral'>        assembly {</span>
  8182 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  8183 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  8184 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  8185 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  8186 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  8187 |     | <span class='neutral'>            // Selector of `log(uint256,address,address,bool)`.</span>
  8188 |     | <span class='neutral'>            mstore(0x00, 0x091ffaf5)</span>
  8189 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  8190 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  8191 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  8192 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  8193 |     | <span class='neutral'>        }</span>
  8194 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x84);</span>
  8195 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  8196 |     | <span class='neutral'>        assembly {</span>
  8197 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  8198 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  8199 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  8200 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  8201 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  8202 |     | <span class='neutral'>        }</span>
  8203 |     | <span class='neutral'>    }</span>
  8204 |     | <span class='neutral'></span>
  8205 |     | <span class='neutral'>    function log(uint256 p0, address p1, address p2, uint256 p3) internal pure {</span>
  8206 |     | <span class='neutral'>        bytes32 m0;</span>
  8207 |     | <span class='neutral'>        bytes32 m1;</span>
  8208 |     | <span class='neutral'>        bytes32 m2;</span>
  8209 |     | <span class='neutral'>        bytes32 m3;</span>
  8210 |     | <span class='neutral'>        bytes32 m4;</span>
  8211 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  8212 |     | <span class='neutral'>        assembly {</span>
  8213 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  8214 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  8215 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  8216 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  8217 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  8218 |     | <span class='neutral'>            // Selector of `log(uint256,address,address,uint256)`.</span>
  8219 |     | <span class='neutral'>            mstore(0x00, 0x736efbb6)</span>
  8220 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  8221 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  8222 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  8223 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  8224 |     | <span class='neutral'>        }</span>
  8225 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x84);</span>
  8226 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  8227 |     | <span class='neutral'>        assembly {</span>
  8228 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  8229 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  8230 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  8231 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  8232 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  8233 |     | <span class='neutral'>        }</span>
  8234 |     | <span class='neutral'>    }</span>
  8235 |     | <span class='neutral'></span>
  8236 |     | <span class='neutral'>    function log(uint256 p0, address p1, address p2, bytes32 p3) internal pure {</span>
  8237 |     | <span class='neutral'>        bytes32 m0;</span>
  8238 |     | <span class='neutral'>        bytes32 m1;</span>
  8239 |     | <span class='neutral'>        bytes32 m2;</span>
  8240 |     | <span class='neutral'>        bytes32 m3;</span>
  8241 |     | <span class='neutral'>        bytes32 m4;</span>
  8242 |     | <span class='neutral'>        bytes32 m5;</span>
  8243 |     | <span class='neutral'>        bytes32 m6;</span>
  8244 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  8245 |     | <span class='neutral'>        assembly {</span>
  8246 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  8247 |     | <span class='neutral'>                let length := 0</span>
  8248 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  8249 |     | <span class='neutral'>                mstore(pos, length)</span>
  8250 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  8251 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  8252 |     | <span class='neutral'>            }</span>
  8253 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  8254 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  8255 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  8256 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  8257 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  8258 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  8259 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
  8260 |     | <span class='neutral'>            // Selector of `log(uint256,address,address,string)`.</span>
  8261 |     | <span class='neutral'>            mstore(0x00, 0x031c6f73)</span>
  8262 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  8263 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  8264 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  8265 |     | <span class='neutral'>            mstore(0x80, 0x80)</span>
  8266 |     | <span class='neutral'>            writeString(0xa0, p3)</span>
  8267 |     | <span class='neutral'>        }</span>
  8268 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xc4);</span>
  8269 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  8270 |     | <span class='neutral'>        assembly {</span>
  8271 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  8272 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  8273 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  8274 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  8275 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  8276 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  8277 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
  8278 |     | <span class='neutral'>        }</span>
  8279 |     | <span class='neutral'>    }</span>
  8280 |     | <span class='neutral'></span>
  8281 |     | <span class='neutral'>    function log(uint256 p0, address p1, bool p2, address p3) internal pure {</span>
  8282 |     | <span class='neutral'>        bytes32 m0;</span>
  8283 |     | <span class='neutral'>        bytes32 m1;</span>
  8284 |     | <span class='neutral'>        bytes32 m2;</span>
  8285 |     | <span class='neutral'>        bytes32 m3;</span>
  8286 |     | <span class='neutral'>        bytes32 m4;</span>
  8287 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  8288 |     | <span class='neutral'>        assembly {</span>
  8289 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  8290 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  8291 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  8292 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  8293 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  8294 |     | <span class='neutral'>            // Selector of `log(uint256,address,bool,address)`.</span>
  8295 |     | <span class='neutral'>            mstore(0x00, 0xef72c513)</span>
  8296 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  8297 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  8298 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  8299 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  8300 |     | <span class='neutral'>        }</span>
  8301 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x84);</span>
  8302 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  8303 |     | <span class='neutral'>        assembly {</span>
  8304 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  8305 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  8306 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  8307 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  8308 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  8309 |     | <span class='neutral'>        }</span>
  8310 |     | <span class='neutral'>    }</span>
  8311 |     | <span class='neutral'></span>
  8312 |     | <span class='neutral'>    function log(uint256 p0, address p1, bool p2, bool p3) internal pure {</span>
  8313 |     | <span class='neutral'>        bytes32 m0;</span>
  8314 |     | <span class='neutral'>        bytes32 m1;</span>
  8315 |     | <span class='neutral'>        bytes32 m2;</span>
  8316 |     | <span class='neutral'>        bytes32 m3;</span>
  8317 |     | <span class='neutral'>        bytes32 m4;</span>
  8318 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  8319 |     | <span class='neutral'>        assembly {</span>
  8320 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  8321 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  8322 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  8323 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  8324 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  8325 |     | <span class='neutral'>            // Selector of `log(uint256,address,bool,bool)`.</span>
  8326 |     | <span class='neutral'>            mstore(0x00, 0xe351140f)</span>
  8327 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  8328 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  8329 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  8330 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  8331 |     | <span class='neutral'>        }</span>
  8332 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x84);</span>
  8333 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  8334 |     | <span class='neutral'>        assembly {</span>
  8335 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  8336 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  8337 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  8338 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  8339 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  8340 |     | <span class='neutral'>        }</span>
  8341 |     | <span class='neutral'>    }</span>
  8342 |     | <span class='neutral'></span>
  8343 |     | <span class='neutral'>    function log(uint256 p0, address p1, bool p2, uint256 p3) internal pure {</span>
  8344 |     | <span class='neutral'>        bytes32 m0;</span>
  8345 |     | <span class='neutral'>        bytes32 m1;</span>
  8346 |     | <span class='neutral'>        bytes32 m2;</span>
  8347 |     | <span class='neutral'>        bytes32 m3;</span>
  8348 |     | <span class='neutral'>        bytes32 m4;</span>
  8349 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  8350 |     | <span class='neutral'>        assembly {</span>
  8351 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  8352 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  8353 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  8354 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  8355 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  8356 |     | <span class='neutral'>            // Selector of `log(uint256,address,bool,uint256)`.</span>
  8357 |     | <span class='neutral'>            mstore(0x00, 0x5abd992a)</span>
  8358 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  8359 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  8360 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  8361 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  8362 |     | <span class='neutral'>        }</span>
  8363 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x84);</span>
  8364 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  8365 |     | <span class='neutral'>        assembly {</span>
  8366 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  8367 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  8368 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  8369 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  8370 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  8371 |     | <span class='neutral'>        }</span>
  8372 |     | <span class='neutral'>    }</span>
  8373 |     | <span class='neutral'></span>
  8374 |     | <span class='neutral'>    function log(uint256 p0, address p1, bool p2, bytes32 p3) internal pure {</span>
  8375 |     | <span class='neutral'>        bytes32 m0;</span>
  8376 |     | <span class='neutral'>        bytes32 m1;</span>
  8377 |     | <span class='neutral'>        bytes32 m2;</span>
  8378 |     | <span class='neutral'>        bytes32 m3;</span>
  8379 |     | <span class='neutral'>        bytes32 m4;</span>
  8380 |     | <span class='neutral'>        bytes32 m5;</span>
  8381 |     | <span class='neutral'>        bytes32 m6;</span>
  8382 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  8383 |     | <span class='neutral'>        assembly {</span>
  8384 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  8385 |     | <span class='neutral'>                let length := 0</span>
  8386 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  8387 |     | <span class='neutral'>                mstore(pos, length)</span>
  8388 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  8389 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  8390 |     | <span class='neutral'>            }</span>
  8391 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  8392 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  8393 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  8394 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  8395 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  8396 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  8397 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
  8398 |     | <span class='neutral'>            // Selector of `log(uint256,address,bool,string)`.</span>
  8399 |     | <span class='neutral'>            mstore(0x00, 0x90fb06aa)</span>
  8400 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  8401 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  8402 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  8403 |     | <span class='neutral'>            mstore(0x80, 0x80)</span>
  8404 |     | <span class='neutral'>            writeString(0xa0, p3)</span>
  8405 |     | <span class='neutral'>        }</span>
  8406 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xc4);</span>
  8407 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  8408 |     | <span class='neutral'>        assembly {</span>
  8409 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  8410 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  8411 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  8412 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  8413 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  8414 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  8415 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
  8416 |     | <span class='neutral'>        }</span>
  8417 |     | <span class='neutral'>    }</span>
  8418 |     | <span class='neutral'></span>
  8419 |     | <span class='neutral'>    function log(uint256 p0, address p1, uint256 p2, address p3) internal pure {</span>
  8420 |     | <span class='neutral'>        bytes32 m0;</span>
  8421 |     | <span class='neutral'>        bytes32 m1;</span>
  8422 |     | <span class='neutral'>        bytes32 m2;</span>
  8423 |     | <span class='neutral'>        bytes32 m3;</span>
  8424 |     | <span class='neutral'>        bytes32 m4;</span>
  8425 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  8426 |     | <span class='neutral'>        assembly {</span>
  8427 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  8428 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  8429 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  8430 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  8431 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  8432 |     | <span class='neutral'>            // Selector of `log(uint256,address,uint256,address)`.</span>
  8433 |     | <span class='neutral'>            mstore(0x00, 0x15c127b5)</span>
  8434 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  8435 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  8436 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  8437 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  8438 |     | <span class='neutral'>        }</span>
  8439 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x84);</span>
  8440 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  8441 |     | <span class='neutral'>        assembly {</span>
  8442 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  8443 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  8444 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  8445 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  8446 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  8447 |     | <span class='neutral'>        }</span>
  8448 |     | <span class='neutral'>    }</span>
  8449 |     | <span class='neutral'></span>
  8450 |     | <span class='neutral'>    function log(uint256 p0, address p1, uint256 p2, bool p3) internal pure {</span>
  8451 |     | <span class='neutral'>        bytes32 m0;</span>
  8452 |     | <span class='neutral'>        bytes32 m1;</span>
  8453 |     | <span class='neutral'>        bytes32 m2;</span>
  8454 |     | <span class='neutral'>        bytes32 m3;</span>
  8455 |     | <span class='neutral'>        bytes32 m4;</span>
  8456 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  8457 |     | <span class='neutral'>        assembly {</span>
  8458 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  8459 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  8460 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  8461 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  8462 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  8463 |     | <span class='neutral'>            // Selector of `log(uint256,address,uint256,bool)`.</span>
  8464 |     | <span class='neutral'>            mstore(0x00, 0x5f743a7c)</span>
  8465 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  8466 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  8467 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  8468 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  8469 |     | <span class='neutral'>        }</span>
  8470 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x84);</span>
  8471 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  8472 |     | <span class='neutral'>        assembly {</span>
  8473 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  8474 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  8475 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  8476 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  8477 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  8478 |     | <span class='neutral'>        }</span>
  8479 |     | <span class='neutral'>    }</span>
  8480 |     | <span class='neutral'></span>
  8481 |     | <span class='neutral'>    function log(uint256 p0, address p1, uint256 p2, uint256 p3) internal pure {</span>
  8482 |     | <span class='neutral'>        bytes32 m0;</span>
  8483 |     | <span class='neutral'>        bytes32 m1;</span>
  8484 |     | <span class='neutral'>        bytes32 m2;</span>
  8485 |     | <span class='neutral'>        bytes32 m3;</span>
  8486 |     | <span class='neutral'>        bytes32 m4;</span>
  8487 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  8488 |     | <span class='neutral'>        assembly {</span>
  8489 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  8490 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  8491 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  8492 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  8493 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  8494 |     | <span class='neutral'>            // Selector of `log(uint256,address,uint256,uint256)`.</span>
  8495 |     | <span class='neutral'>            mstore(0x00, 0x0c9cd9c1)</span>
  8496 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  8497 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  8498 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  8499 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  8500 |     | <span class='neutral'>        }</span>
  8501 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x84);</span>
  8502 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  8503 |     | <span class='neutral'>        assembly {</span>
  8504 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  8505 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  8506 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  8507 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  8508 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  8509 |     | <span class='neutral'>        }</span>
  8510 |     | <span class='neutral'>    }</span>
  8511 |     | <span class='neutral'></span>
  8512 |     | <span class='neutral'>    function log(uint256 p0, address p1, uint256 p2, bytes32 p3) internal pure {</span>
  8513 |     | <span class='neutral'>        bytes32 m0;</span>
  8514 |     | <span class='neutral'>        bytes32 m1;</span>
  8515 |     | <span class='neutral'>        bytes32 m2;</span>
  8516 |     | <span class='neutral'>        bytes32 m3;</span>
  8517 |     | <span class='neutral'>        bytes32 m4;</span>
  8518 |     | <span class='neutral'>        bytes32 m5;</span>
  8519 |     | <span class='neutral'>        bytes32 m6;</span>
  8520 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  8521 |     | <span class='neutral'>        assembly {</span>
  8522 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  8523 |     | <span class='neutral'>                let length := 0</span>
  8524 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  8525 |     | <span class='neutral'>                mstore(pos, length)</span>
  8526 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  8527 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  8528 |     | <span class='neutral'>            }</span>
  8529 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  8530 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  8531 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  8532 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  8533 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  8534 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  8535 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
  8536 |     | <span class='neutral'>            // Selector of `log(uint256,address,uint256,string)`.</span>
  8537 |     | <span class='neutral'>            mstore(0x00, 0xddb06521)</span>
  8538 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  8539 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  8540 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  8541 |     | <span class='neutral'>            mstore(0x80, 0x80)</span>
  8542 |     | <span class='neutral'>            writeString(0xa0, p3)</span>
  8543 |     | <span class='neutral'>        }</span>
  8544 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xc4);</span>
  8545 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  8546 |     | <span class='neutral'>        assembly {</span>
  8547 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  8548 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  8549 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  8550 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  8551 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  8552 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  8553 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
  8554 |     | <span class='neutral'>        }</span>
  8555 |     | <span class='neutral'>    }</span>
  8556 |     | <span class='neutral'></span>
  8557 |     | <span class='neutral'>    function log(uint256 p0, address p1, bytes32 p2, address p3) internal pure {</span>
  8558 |     | <span class='neutral'>        bytes32 m0;</span>
  8559 |     | <span class='neutral'>        bytes32 m1;</span>
  8560 |     | <span class='neutral'>        bytes32 m2;</span>
  8561 |     | <span class='neutral'>        bytes32 m3;</span>
  8562 |     | <span class='neutral'>        bytes32 m4;</span>
  8563 |     | <span class='neutral'>        bytes32 m5;</span>
  8564 |     | <span class='neutral'>        bytes32 m6;</span>
  8565 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  8566 |     | <span class='neutral'>        assembly {</span>
  8567 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  8568 |     | <span class='neutral'>                let length := 0</span>
  8569 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  8570 |     | <span class='neutral'>                mstore(pos, length)</span>
  8571 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  8572 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  8573 |     | <span class='neutral'>            }</span>
  8574 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  8575 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  8576 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  8577 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  8578 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  8579 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  8580 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
  8581 |     | <span class='neutral'>            // Selector of `log(uint256,address,string,address)`.</span>
  8582 |     | <span class='neutral'>            mstore(0x00, 0x9cba8fff)</span>
  8583 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  8584 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  8585 |     | <span class='neutral'>            mstore(0x60, 0x80)</span>
  8586 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  8587 |     | <span class='neutral'>            writeString(0xa0, p2)</span>
  8588 |     | <span class='neutral'>        }</span>
  8589 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xc4);</span>
  8590 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  8591 |     | <span class='neutral'>        assembly {</span>
  8592 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  8593 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  8594 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  8595 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  8596 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  8597 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  8598 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
  8599 |     | <span class='neutral'>        }</span>
  8600 |     | <span class='neutral'>    }</span>
  8601 |     | <span class='neutral'></span>
  8602 |     | <span class='neutral'>    function log(uint256 p0, address p1, bytes32 p2, bool p3) internal pure {</span>
  8603 |     | <span class='neutral'>        bytes32 m0;</span>
  8604 |     | <span class='neutral'>        bytes32 m1;</span>
  8605 |     | <span class='neutral'>        bytes32 m2;</span>
  8606 |     | <span class='neutral'>        bytes32 m3;</span>
  8607 |     | <span class='neutral'>        bytes32 m4;</span>
  8608 |     | <span class='neutral'>        bytes32 m5;</span>
  8609 |     | <span class='neutral'>        bytes32 m6;</span>
  8610 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  8611 |     | <span class='neutral'>        assembly {</span>
  8612 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  8613 |     | <span class='neutral'>                let length := 0</span>
  8614 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  8615 |     | <span class='neutral'>                mstore(pos, length)</span>
  8616 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  8617 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  8618 |     | <span class='neutral'>            }</span>
  8619 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  8620 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  8621 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  8622 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  8623 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  8624 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  8625 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
  8626 |     | <span class='neutral'>            // Selector of `log(uint256,address,string,bool)`.</span>
  8627 |     | <span class='neutral'>            mstore(0x00, 0xcc32ab07)</span>
  8628 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  8629 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  8630 |     | <span class='neutral'>            mstore(0x60, 0x80)</span>
  8631 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  8632 |     | <span class='neutral'>            writeString(0xa0, p2)</span>
  8633 |     | <span class='neutral'>        }</span>
  8634 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xc4);</span>
  8635 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  8636 |     | <span class='neutral'>        assembly {</span>
  8637 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  8638 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  8639 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  8640 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  8641 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  8642 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  8643 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
  8644 |     | <span class='neutral'>        }</span>
  8645 |     | <span class='neutral'>    }</span>
  8646 |     | <span class='neutral'></span>
  8647 |     | <span class='neutral'>    function log(uint256 p0, address p1, bytes32 p2, uint256 p3) internal pure {</span>
  8648 |     | <span class='neutral'>        bytes32 m0;</span>
  8649 |     | <span class='neutral'>        bytes32 m1;</span>
  8650 |     | <span class='neutral'>        bytes32 m2;</span>
  8651 |     | <span class='neutral'>        bytes32 m3;</span>
  8652 |     | <span class='neutral'>        bytes32 m4;</span>
  8653 |     | <span class='neutral'>        bytes32 m5;</span>
  8654 |     | <span class='neutral'>        bytes32 m6;</span>
  8655 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  8656 |     | <span class='neutral'>        assembly {</span>
  8657 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  8658 |     | <span class='neutral'>                let length := 0</span>
  8659 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  8660 |     | <span class='neutral'>                mstore(pos, length)</span>
  8661 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  8662 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  8663 |     | <span class='neutral'>            }</span>
  8664 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  8665 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  8666 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  8667 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  8668 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  8669 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  8670 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
  8671 |     | <span class='neutral'>            // Selector of `log(uint256,address,string,uint256)`.</span>
  8672 |     | <span class='neutral'>            mstore(0x00, 0x46826b5d)</span>
  8673 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  8674 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  8675 |     | <span class='neutral'>            mstore(0x60, 0x80)</span>
  8676 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  8677 |     | <span class='neutral'>            writeString(0xa0, p2)</span>
  8678 |     | <span class='neutral'>        }</span>
  8679 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xc4);</span>
  8680 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  8681 |     | <span class='neutral'>        assembly {</span>
  8682 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  8683 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  8684 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  8685 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  8686 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  8687 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  8688 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
  8689 |     | <span class='neutral'>        }</span>
  8690 |     | <span class='neutral'>    }</span>
  8691 |     | <span class='neutral'></span>
  8692 |     | <span class='neutral'>    function log(uint256 p0, address p1, bytes32 p2, bytes32 p3) internal pure {</span>
  8693 |     | <span class='neutral'>        bytes32 m0;</span>
  8694 |     | <span class='neutral'>        bytes32 m1;</span>
  8695 |     | <span class='neutral'>        bytes32 m2;</span>
  8696 |     | <span class='neutral'>        bytes32 m3;</span>
  8697 |     | <span class='neutral'>        bytes32 m4;</span>
  8698 |     | <span class='neutral'>        bytes32 m5;</span>
  8699 |     | <span class='neutral'>        bytes32 m6;</span>
  8700 |     | <span class='neutral'>        bytes32 m7;</span>
  8701 |     | <span class='neutral'>        bytes32 m8;</span>
  8702 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  8703 |     | <span class='neutral'>        assembly {</span>
  8704 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  8705 |     | <span class='neutral'>                let length := 0</span>
  8706 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  8707 |     | <span class='neutral'>                mstore(pos, length)</span>
  8708 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  8709 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  8710 |     | <span class='neutral'>            }</span>
  8711 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  8712 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  8713 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  8714 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  8715 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  8716 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  8717 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
  8718 |     | <span class='neutral'>            m7 := mload(0xe0)</span>
  8719 |     | <span class='neutral'>            m8 := mload(0x100)</span>
  8720 |     | <span class='neutral'>            // Selector of `log(uint256,address,string,string)`.</span>
  8721 |     | <span class='neutral'>            mstore(0x00, 0x3e128ca3)</span>
  8722 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  8723 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  8724 |     | <span class='neutral'>            mstore(0x60, 0x80)</span>
  8725 |     | <span class='neutral'>            mstore(0x80, 0xc0)</span>
  8726 |     | <span class='neutral'>            writeString(0xa0, p2)</span>
  8727 |     | <span class='neutral'>            writeString(0xe0, p3)</span>
  8728 |     | <span class='neutral'>        }</span>
  8729 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x104);</span>
  8730 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  8731 |     | <span class='neutral'>        assembly {</span>
  8732 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  8733 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  8734 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  8735 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  8736 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  8737 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  8738 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
  8739 |     | <span class='neutral'>            mstore(0xe0, m7)</span>
  8740 |     | <span class='neutral'>            mstore(0x100, m8)</span>
  8741 |     | <span class='neutral'>        }</span>
  8742 |     | <span class='neutral'>    }</span>
  8743 |     | <span class='neutral'></span>
  8744 |     | <span class='neutral'>    function log(uint256 p0, bool p1, address p2, address p3) internal pure {</span>
  8745 |     | <span class='neutral'>        bytes32 m0;</span>
  8746 |     | <span class='neutral'>        bytes32 m1;</span>
  8747 |     | <span class='neutral'>        bytes32 m2;</span>
  8748 |     | <span class='neutral'>        bytes32 m3;</span>
  8749 |     | <span class='neutral'>        bytes32 m4;</span>
  8750 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  8751 |     | <span class='neutral'>        assembly {</span>
  8752 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  8753 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  8754 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  8755 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  8756 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  8757 |     | <span class='neutral'>            // Selector of `log(uint256,bool,address,address)`.</span>
  8758 |     | <span class='neutral'>            mstore(0x00, 0xa1ef4cbb)</span>
  8759 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  8760 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  8761 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  8762 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  8763 |     | <span class='neutral'>        }</span>
  8764 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x84);</span>
  8765 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  8766 |     | <span class='neutral'>        assembly {</span>
  8767 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  8768 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  8769 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  8770 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  8771 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  8772 |     | <span class='neutral'>        }</span>
  8773 |     | <span class='neutral'>    }</span>
  8774 |     | <span class='neutral'></span>
  8775 |     | <span class='neutral'>    function log(uint256 p0, bool p1, address p2, bool p3) internal pure {</span>
  8776 |     | <span class='neutral'>        bytes32 m0;</span>
  8777 |     | <span class='neutral'>        bytes32 m1;</span>
  8778 |     | <span class='neutral'>        bytes32 m2;</span>
  8779 |     | <span class='neutral'>        bytes32 m3;</span>
  8780 |     | <span class='neutral'>        bytes32 m4;</span>
  8781 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  8782 |     | <span class='neutral'>        assembly {</span>
  8783 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  8784 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  8785 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  8786 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  8787 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  8788 |     | <span class='neutral'>            // Selector of `log(uint256,bool,address,bool)`.</span>
  8789 |     | <span class='neutral'>            mstore(0x00, 0x454d54a5)</span>
  8790 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  8791 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  8792 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  8793 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  8794 |     | <span class='neutral'>        }</span>
  8795 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x84);</span>
  8796 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  8797 |     | <span class='neutral'>        assembly {</span>
  8798 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  8799 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  8800 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  8801 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  8802 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  8803 |     | <span class='neutral'>        }</span>
  8804 |     | <span class='neutral'>    }</span>
  8805 |     | <span class='neutral'></span>
  8806 |     | <span class='neutral'>    function log(uint256 p0, bool p1, address p2, uint256 p3) internal pure {</span>
  8807 |     | <span class='neutral'>        bytes32 m0;</span>
  8808 |     | <span class='neutral'>        bytes32 m1;</span>
  8809 |     | <span class='neutral'>        bytes32 m2;</span>
  8810 |     | <span class='neutral'>        bytes32 m3;</span>
  8811 |     | <span class='neutral'>        bytes32 m4;</span>
  8812 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  8813 |     | <span class='neutral'>        assembly {</span>
  8814 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  8815 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  8816 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  8817 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  8818 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  8819 |     | <span class='neutral'>            // Selector of `log(uint256,bool,address,uint256)`.</span>
  8820 |     | <span class='neutral'>            mstore(0x00, 0x078287f5)</span>
  8821 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  8822 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  8823 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  8824 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  8825 |     | <span class='neutral'>        }</span>
  8826 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x84);</span>
  8827 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  8828 |     | <span class='neutral'>        assembly {</span>
  8829 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  8830 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  8831 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  8832 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  8833 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  8834 |     | <span class='neutral'>        }</span>
  8835 |     | <span class='neutral'>    }</span>
  8836 |     | <span class='neutral'></span>
  8837 |     | <span class='neutral'>    function log(uint256 p0, bool p1, address p2, bytes32 p3) internal pure {</span>
  8838 |     | <span class='neutral'>        bytes32 m0;</span>
  8839 |     | <span class='neutral'>        bytes32 m1;</span>
  8840 |     | <span class='neutral'>        bytes32 m2;</span>
  8841 |     | <span class='neutral'>        bytes32 m3;</span>
  8842 |     | <span class='neutral'>        bytes32 m4;</span>
  8843 |     | <span class='neutral'>        bytes32 m5;</span>
  8844 |     | <span class='neutral'>        bytes32 m6;</span>
  8845 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  8846 |     | <span class='neutral'>        assembly {</span>
  8847 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  8848 |     | <span class='neutral'>                let length := 0</span>
  8849 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  8850 |     | <span class='neutral'>                mstore(pos, length)</span>
  8851 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  8852 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  8853 |     | <span class='neutral'>            }</span>
  8854 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  8855 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  8856 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  8857 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  8858 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  8859 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  8860 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
  8861 |     | <span class='neutral'>            // Selector of `log(uint256,bool,address,string)`.</span>
  8862 |     | <span class='neutral'>            mstore(0x00, 0xade052c7)</span>
  8863 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  8864 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  8865 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  8866 |     | <span class='neutral'>            mstore(0x80, 0x80)</span>
  8867 |     | <span class='neutral'>            writeString(0xa0, p3)</span>
  8868 |     | <span class='neutral'>        }</span>
  8869 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xc4);</span>
  8870 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  8871 |     | <span class='neutral'>        assembly {</span>
  8872 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  8873 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  8874 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  8875 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  8876 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  8877 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  8878 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
  8879 |     | <span class='neutral'>        }</span>
  8880 |     | <span class='neutral'>    }</span>
  8881 |     | <span class='neutral'></span>
  8882 |     | <span class='neutral'>    function log(uint256 p0, bool p1, bool p2, address p3) internal pure {</span>
  8883 |     | <span class='neutral'>        bytes32 m0;</span>
  8884 |     | <span class='neutral'>        bytes32 m1;</span>
  8885 |     | <span class='neutral'>        bytes32 m2;</span>
  8886 |     | <span class='neutral'>        bytes32 m3;</span>
  8887 |     | <span class='neutral'>        bytes32 m4;</span>
  8888 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  8889 |     | <span class='neutral'>        assembly {</span>
  8890 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  8891 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  8892 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  8893 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  8894 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  8895 |     | <span class='neutral'>            // Selector of `log(uint256,bool,bool,address)`.</span>
  8896 |     | <span class='neutral'>            mstore(0x00, 0x69640b59)</span>
  8897 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  8898 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  8899 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  8900 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  8901 |     | <span class='neutral'>        }</span>
  8902 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x84);</span>
  8903 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  8904 |     | <span class='neutral'>        assembly {</span>
  8905 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  8906 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  8907 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  8908 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  8909 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  8910 |     | <span class='neutral'>        }</span>
  8911 |     | <span class='neutral'>    }</span>
  8912 |     | <span class='neutral'></span>
  8913 |     | <span class='neutral'>    function log(uint256 p0, bool p1, bool p2, bool p3) internal pure {</span>
  8914 |     | <span class='neutral'>        bytes32 m0;</span>
  8915 |     | <span class='neutral'>        bytes32 m1;</span>
  8916 |     | <span class='neutral'>        bytes32 m2;</span>
  8917 |     | <span class='neutral'>        bytes32 m3;</span>
  8918 |     | <span class='neutral'>        bytes32 m4;</span>
  8919 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  8920 |     | <span class='neutral'>        assembly {</span>
  8921 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  8922 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  8923 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  8924 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  8925 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  8926 |     | <span class='neutral'>            // Selector of `log(uint256,bool,bool,bool)`.</span>
  8927 |     | <span class='neutral'>            mstore(0x00, 0xb6f577a1)</span>
  8928 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  8929 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  8930 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  8931 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  8932 |     | <span class='neutral'>        }</span>
  8933 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x84);</span>
  8934 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  8935 |     | <span class='neutral'>        assembly {</span>
  8936 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  8937 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  8938 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  8939 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  8940 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  8941 |     | <span class='neutral'>        }</span>
  8942 |     | <span class='neutral'>    }</span>
  8943 |     | <span class='neutral'></span>
  8944 |     | <span class='neutral'>    function log(uint256 p0, bool p1, bool p2, uint256 p3) internal pure {</span>
  8945 |     | <span class='neutral'>        bytes32 m0;</span>
  8946 |     | <span class='neutral'>        bytes32 m1;</span>
  8947 |     | <span class='neutral'>        bytes32 m2;</span>
  8948 |     | <span class='neutral'>        bytes32 m3;</span>
  8949 |     | <span class='neutral'>        bytes32 m4;</span>
  8950 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  8951 |     | <span class='neutral'>        assembly {</span>
  8952 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  8953 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  8954 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  8955 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  8956 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  8957 |     | <span class='neutral'>            // Selector of `log(uint256,bool,bool,uint256)`.</span>
  8958 |     | <span class='neutral'>            mstore(0x00, 0x7464ce23)</span>
  8959 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  8960 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  8961 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  8962 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  8963 |     | <span class='neutral'>        }</span>
  8964 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x84);</span>
  8965 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  8966 |     | <span class='neutral'>        assembly {</span>
  8967 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  8968 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  8969 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  8970 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  8971 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  8972 |     | <span class='neutral'>        }</span>
  8973 |     | <span class='neutral'>    }</span>
  8974 |     | <span class='neutral'></span>
  8975 |     | <span class='neutral'>    function log(uint256 p0, bool p1, bool p2, bytes32 p3) internal pure {</span>
  8976 |     | <span class='neutral'>        bytes32 m0;</span>
  8977 |     | <span class='neutral'>        bytes32 m1;</span>
  8978 |     | <span class='neutral'>        bytes32 m2;</span>
  8979 |     | <span class='neutral'>        bytes32 m3;</span>
  8980 |     | <span class='neutral'>        bytes32 m4;</span>
  8981 |     | <span class='neutral'>        bytes32 m5;</span>
  8982 |     | <span class='neutral'>        bytes32 m6;</span>
  8983 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  8984 |     | <span class='neutral'>        assembly {</span>
  8985 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  8986 |     | <span class='neutral'>                let length := 0</span>
  8987 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  8988 |     | <span class='neutral'>                mstore(pos, length)</span>
  8989 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  8990 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  8991 |     | <span class='neutral'>            }</span>
  8992 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  8993 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  8994 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  8995 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  8996 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  8997 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  8998 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
  8999 |     | <span class='neutral'>            // Selector of `log(uint256,bool,bool,string)`.</span>
  9000 |     | <span class='neutral'>            mstore(0x00, 0xdddb9561)</span>
  9001 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  9002 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  9003 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  9004 |     | <span class='neutral'>            mstore(0x80, 0x80)</span>
  9005 |     | <span class='neutral'>            writeString(0xa0, p3)</span>
  9006 |     | <span class='neutral'>        }</span>
  9007 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xc4);</span>
  9008 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  9009 |     | <span class='neutral'>        assembly {</span>
  9010 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  9011 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  9012 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  9013 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  9014 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  9015 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  9016 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
  9017 |     | <span class='neutral'>        }</span>
  9018 |     | <span class='neutral'>    }</span>
  9019 |     | <span class='neutral'></span>
  9020 |     | <span class='neutral'>    function log(uint256 p0, bool p1, uint256 p2, address p3) internal pure {</span>
  9021 |     | <span class='neutral'>        bytes32 m0;</span>
  9022 |     | <span class='neutral'>        bytes32 m1;</span>
  9023 |     | <span class='neutral'>        bytes32 m2;</span>
  9024 |     | <span class='neutral'>        bytes32 m3;</span>
  9025 |     | <span class='neutral'>        bytes32 m4;</span>
  9026 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  9027 |     | <span class='neutral'>        assembly {</span>
  9028 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  9029 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  9030 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  9031 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  9032 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  9033 |     | <span class='neutral'>            // Selector of `log(uint256,bool,uint256,address)`.</span>
  9034 |     | <span class='neutral'>            mstore(0x00, 0x88cb6041)</span>
  9035 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  9036 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  9037 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  9038 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  9039 |     | <span class='neutral'>        }</span>
  9040 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x84);</span>
  9041 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  9042 |     | <span class='neutral'>        assembly {</span>
  9043 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  9044 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  9045 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  9046 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  9047 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  9048 |     | <span class='neutral'>        }</span>
  9049 |     | <span class='neutral'>    }</span>
  9050 |     | <span class='neutral'></span>
  9051 |     | <span class='neutral'>    function log(uint256 p0, bool p1, uint256 p2, bool p3) internal pure {</span>
  9052 |     | <span class='neutral'>        bytes32 m0;</span>
  9053 |     | <span class='neutral'>        bytes32 m1;</span>
  9054 |     | <span class='neutral'>        bytes32 m2;</span>
  9055 |     | <span class='neutral'>        bytes32 m3;</span>
  9056 |     | <span class='neutral'>        bytes32 m4;</span>
  9057 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  9058 |     | <span class='neutral'>        assembly {</span>
  9059 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  9060 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  9061 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  9062 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  9063 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  9064 |     | <span class='neutral'>            // Selector of `log(uint256,bool,uint256,bool)`.</span>
  9065 |     | <span class='neutral'>            mstore(0x00, 0x91a02e2a)</span>
  9066 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  9067 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  9068 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  9069 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  9070 |     | <span class='neutral'>        }</span>
  9071 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x84);</span>
  9072 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  9073 |     | <span class='neutral'>        assembly {</span>
  9074 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  9075 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  9076 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  9077 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  9078 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  9079 |     | <span class='neutral'>        }</span>
  9080 |     | <span class='neutral'>    }</span>
  9081 |     | <span class='neutral'></span>
  9082 |     | <span class='neutral'>    function log(uint256 p0, bool p1, uint256 p2, uint256 p3) internal pure {</span>
  9083 |     | <span class='neutral'>        bytes32 m0;</span>
  9084 |     | <span class='neutral'>        bytes32 m1;</span>
  9085 |     | <span class='neutral'>        bytes32 m2;</span>
  9086 |     | <span class='neutral'>        bytes32 m3;</span>
  9087 |     | <span class='neutral'>        bytes32 m4;</span>
  9088 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  9089 |     | <span class='neutral'>        assembly {</span>
  9090 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  9091 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  9092 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  9093 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  9094 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  9095 |     | <span class='neutral'>            // Selector of `log(uint256,bool,uint256,uint256)`.</span>
  9096 |     | <span class='neutral'>            mstore(0x00, 0xc6acc7a8)</span>
  9097 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  9098 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  9099 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  9100 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  9101 |     | <span class='neutral'>        }</span>
  9102 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x84);</span>
  9103 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  9104 |     | <span class='neutral'>        assembly {</span>
  9105 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  9106 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  9107 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  9108 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  9109 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  9110 |     | <span class='neutral'>        }</span>
  9111 |     | <span class='neutral'>    }</span>
  9112 |     | <span class='neutral'></span>
  9113 |     | <span class='neutral'>    function log(uint256 p0, bool p1, uint256 p2, bytes32 p3) internal pure {</span>
  9114 |     | <span class='neutral'>        bytes32 m0;</span>
  9115 |     | <span class='neutral'>        bytes32 m1;</span>
  9116 |     | <span class='neutral'>        bytes32 m2;</span>
  9117 |     | <span class='neutral'>        bytes32 m3;</span>
  9118 |     | <span class='neutral'>        bytes32 m4;</span>
  9119 |     | <span class='neutral'>        bytes32 m5;</span>
  9120 |     | <span class='neutral'>        bytes32 m6;</span>
  9121 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  9122 |     | <span class='neutral'>        assembly {</span>
  9123 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  9124 |     | <span class='neutral'>                let length := 0</span>
  9125 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  9126 |     | <span class='neutral'>                mstore(pos, length)</span>
  9127 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  9128 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  9129 |     | <span class='neutral'>            }</span>
  9130 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  9131 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  9132 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  9133 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  9134 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  9135 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  9136 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
  9137 |     | <span class='neutral'>            // Selector of `log(uint256,bool,uint256,string)`.</span>
  9138 |     | <span class='neutral'>            mstore(0x00, 0xde03e774)</span>
  9139 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  9140 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  9141 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  9142 |     | <span class='neutral'>            mstore(0x80, 0x80)</span>
  9143 |     | <span class='neutral'>            writeString(0xa0, p3)</span>
  9144 |     | <span class='neutral'>        }</span>
  9145 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xc4);</span>
  9146 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  9147 |     | <span class='neutral'>        assembly {</span>
  9148 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  9149 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  9150 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  9151 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  9152 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  9153 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  9154 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
  9155 |     | <span class='neutral'>        }</span>
  9156 |     | <span class='neutral'>    }</span>
  9157 |     | <span class='neutral'></span>
  9158 |     | <span class='neutral'>    function log(uint256 p0, bool p1, bytes32 p2, address p3) internal pure {</span>
  9159 |     | <span class='neutral'>        bytes32 m0;</span>
  9160 |     | <span class='neutral'>        bytes32 m1;</span>
  9161 |     | <span class='neutral'>        bytes32 m2;</span>
  9162 |     | <span class='neutral'>        bytes32 m3;</span>
  9163 |     | <span class='neutral'>        bytes32 m4;</span>
  9164 |     | <span class='neutral'>        bytes32 m5;</span>
  9165 |     | <span class='neutral'>        bytes32 m6;</span>
  9166 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  9167 |     | <span class='neutral'>        assembly {</span>
  9168 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  9169 |     | <span class='neutral'>                let length := 0</span>
  9170 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  9171 |     | <span class='neutral'>                mstore(pos, length)</span>
  9172 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  9173 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  9174 |     | <span class='neutral'>            }</span>
  9175 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  9176 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  9177 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  9178 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  9179 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  9180 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  9181 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
  9182 |     | <span class='neutral'>            // Selector of `log(uint256,bool,string,address)`.</span>
  9183 |     | <span class='neutral'>            mstore(0x00, 0xef529018)</span>
  9184 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  9185 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  9186 |     | <span class='neutral'>            mstore(0x60, 0x80)</span>
  9187 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  9188 |     | <span class='neutral'>            writeString(0xa0, p2)</span>
  9189 |     | <span class='neutral'>        }</span>
  9190 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xc4);</span>
  9191 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  9192 |     | <span class='neutral'>        assembly {</span>
  9193 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  9194 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  9195 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  9196 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  9197 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  9198 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  9199 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
  9200 |     | <span class='neutral'>        }</span>
  9201 |     | <span class='neutral'>    }</span>
  9202 |     | <span class='neutral'></span>
  9203 |     | <span class='neutral'>    function log(uint256 p0, bool p1, bytes32 p2, bool p3) internal pure {</span>
  9204 |     | <span class='neutral'>        bytes32 m0;</span>
  9205 |     | <span class='neutral'>        bytes32 m1;</span>
  9206 |     | <span class='neutral'>        bytes32 m2;</span>
  9207 |     | <span class='neutral'>        bytes32 m3;</span>
  9208 |     | <span class='neutral'>        bytes32 m4;</span>
  9209 |     | <span class='neutral'>        bytes32 m5;</span>
  9210 |     | <span class='neutral'>        bytes32 m6;</span>
  9211 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  9212 |     | <span class='neutral'>        assembly {</span>
  9213 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  9214 |     | <span class='neutral'>                let length := 0</span>
  9215 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  9216 |     | <span class='neutral'>                mstore(pos, length)</span>
  9217 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  9218 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  9219 |     | <span class='neutral'>            }</span>
  9220 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  9221 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  9222 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  9223 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  9224 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  9225 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  9226 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
  9227 |     | <span class='neutral'>            // Selector of `log(uint256,bool,string,bool)`.</span>
  9228 |     | <span class='neutral'>            mstore(0x00, 0xeb928d7f)</span>
  9229 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  9230 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  9231 |     | <span class='neutral'>            mstore(0x60, 0x80)</span>
  9232 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  9233 |     | <span class='neutral'>            writeString(0xa0, p2)</span>
  9234 |     | <span class='neutral'>        }</span>
  9235 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xc4);</span>
  9236 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  9237 |     | <span class='neutral'>        assembly {</span>
  9238 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  9239 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  9240 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  9241 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  9242 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  9243 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  9244 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
  9245 |     | <span class='neutral'>        }</span>
  9246 |     | <span class='neutral'>    }</span>
  9247 |     | <span class='neutral'></span>
  9248 |     | <span class='neutral'>    function log(uint256 p0, bool p1, bytes32 p2, uint256 p3) internal pure {</span>
  9249 |     | <span class='neutral'>        bytes32 m0;</span>
  9250 |     | <span class='neutral'>        bytes32 m1;</span>
  9251 |     | <span class='neutral'>        bytes32 m2;</span>
  9252 |     | <span class='neutral'>        bytes32 m3;</span>
  9253 |     | <span class='neutral'>        bytes32 m4;</span>
  9254 |     | <span class='neutral'>        bytes32 m5;</span>
  9255 |     | <span class='neutral'>        bytes32 m6;</span>
  9256 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  9257 |     | <span class='neutral'>        assembly {</span>
  9258 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  9259 |     | <span class='neutral'>                let length := 0</span>
  9260 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  9261 |     | <span class='neutral'>                mstore(pos, length)</span>
  9262 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  9263 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  9264 |     | <span class='neutral'>            }</span>
  9265 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  9266 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  9267 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  9268 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  9269 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  9270 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  9271 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
  9272 |     | <span class='neutral'>            // Selector of `log(uint256,bool,string,uint256)`.</span>
  9273 |     | <span class='neutral'>            mstore(0x00, 0x2c1d0746)</span>
  9274 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  9275 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  9276 |     | <span class='neutral'>            mstore(0x60, 0x80)</span>
  9277 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  9278 |     | <span class='neutral'>            writeString(0xa0, p2)</span>
  9279 |     | <span class='neutral'>        }</span>
  9280 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xc4);</span>
  9281 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  9282 |     | <span class='neutral'>        assembly {</span>
  9283 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  9284 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  9285 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  9286 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  9287 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  9288 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  9289 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
  9290 |     | <span class='neutral'>        }</span>
  9291 |     | <span class='neutral'>    }</span>
  9292 |     | <span class='neutral'></span>
  9293 |     | <span class='neutral'>    function log(uint256 p0, bool p1, bytes32 p2, bytes32 p3) internal pure {</span>
  9294 |     | <span class='neutral'>        bytes32 m0;</span>
  9295 |     | <span class='neutral'>        bytes32 m1;</span>
  9296 |     | <span class='neutral'>        bytes32 m2;</span>
  9297 |     | <span class='neutral'>        bytes32 m3;</span>
  9298 |     | <span class='neutral'>        bytes32 m4;</span>
  9299 |     | <span class='neutral'>        bytes32 m5;</span>
  9300 |     | <span class='neutral'>        bytes32 m6;</span>
  9301 |     | <span class='neutral'>        bytes32 m7;</span>
  9302 |     | <span class='neutral'>        bytes32 m8;</span>
  9303 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  9304 |     | <span class='neutral'>        assembly {</span>
  9305 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  9306 |     | <span class='neutral'>                let length := 0</span>
  9307 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  9308 |     | <span class='neutral'>                mstore(pos, length)</span>
  9309 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  9310 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  9311 |     | <span class='neutral'>            }</span>
  9312 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  9313 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  9314 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  9315 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  9316 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  9317 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  9318 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
  9319 |     | <span class='neutral'>            m7 := mload(0xe0)</span>
  9320 |     | <span class='neutral'>            m8 := mload(0x100)</span>
  9321 |     | <span class='neutral'>            // Selector of `log(uint256,bool,string,string)`.</span>
  9322 |     | <span class='neutral'>            mstore(0x00, 0x68c8b8bd)</span>
  9323 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  9324 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  9325 |     | <span class='neutral'>            mstore(0x60, 0x80)</span>
  9326 |     | <span class='neutral'>            mstore(0x80, 0xc0)</span>
  9327 |     | <span class='neutral'>            writeString(0xa0, p2)</span>
  9328 |     | <span class='neutral'>            writeString(0xe0, p3)</span>
  9329 |     | <span class='neutral'>        }</span>
  9330 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x104);</span>
  9331 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  9332 |     | <span class='neutral'>        assembly {</span>
  9333 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  9334 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  9335 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  9336 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  9337 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  9338 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  9339 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
  9340 |     | <span class='neutral'>            mstore(0xe0, m7)</span>
  9341 |     | <span class='neutral'>            mstore(0x100, m8)</span>
  9342 |     | <span class='neutral'>        }</span>
  9343 |     | <span class='neutral'>    }</span>
  9344 |     | <span class='neutral'></span>
  9345 |     | <span class='neutral'>    function log(uint256 p0, uint256 p1, address p2, address p3) internal pure {</span>
  9346 |     | <span class='neutral'>        bytes32 m0;</span>
  9347 |     | <span class='neutral'>        bytes32 m1;</span>
  9348 |     | <span class='neutral'>        bytes32 m2;</span>
  9349 |     | <span class='neutral'>        bytes32 m3;</span>
  9350 |     | <span class='neutral'>        bytes32 m4;</span>
  9351 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  9352 |     | <span class='neutral'>        assembly {</span>
  9353 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  9354 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  9355 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  9356 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  9357 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  9358 |     | <span class='neutral'>            // Selector of `log(uint256,uint256,address,address)`.</span>
  9359 |     | <span class='neutral'>            mstore(0x00, 0x56a5d1b1)</span>
  9360 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  9361 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  9362 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  9363 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  9364 |     | <span class='neutral'>        }</span>
  9365 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x84);</span>
  9366 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  9367 |     | <span class='neutral'>        assembly {</span>
  9368 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  9369 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  9370 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  9371 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  9372 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  9373 |     | <span class='neutral'>        }</span>
  9374 |     | <span class='neutral'>    }</span>
  9375 |     | <span class='neutral'></span>
  9376 |     | <span class='neutral'>    function log(uint256 p0, uint256 p1, address p2, bool p3) internal pure {</span>
  9377 |     | <span class='neutral'>        bytes32 m0;</span>
  9378 |     | <span class='neutral'>        bytes32 m1;</span>
  9379 |     | <span class='neutral'>        bytes32 m2;</span>
  9380 |     | <span class='neutral'>        bytes32 m3;</span>
  9381 |     | <span class='neutral'>        bytes32 m4;</span>
  9382 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  9383 |     | <span class='neutral'>        assembly {</span>
  9384 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  9385 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  9386 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  9387 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  9388 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  9389 |     | <span class='neutral'>            // Selector of `log(uint256,uint256,address,bool)`.</span>
  9390 |     | <span class='neutral'>            mstore(0x00, 0x15cac476)</span>
  9391 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  9392 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  9393 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  9394 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  9395 |     | <span class='neutral'>        }</span>
  9396 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x84);</span>
  9397 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  9398 |     | <span class='neutral'>        assembly {</span>
  9399 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  9400 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  9401 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  9402 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  9403 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  9404 |     | <span class='neutral'>        }</span>
  9405 |     | <span class='neutral'>    }</span>
  9406 |     | <span class='neutral'></span>
  9407 |     | <span class='neutral'>    function log(uint256 p0, uint256 p1, address p2, uint256 p3) internal pure {</span>
  9408 |     | <span class='neutral'>        bytes32 m0;</span>
  9409 |     | <span class='neutral'>        bytes32 m1;</span>
  9410 |     | <span class='neutral'>        bytes32 m2;</span>
  9411 |     | <span class='neutral'>        bytes32 m3;</span>
  9412 |     | <span class='neutral'>        bytes32 m4;</span>
  9413 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  9414 |     | <span class='neutral'>        assembly {</span>
  9415 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  9416 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  9417 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  9418 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  9419 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  9420 |     | <span class='neutral'>            // Selector of `log(uint256,uint256,address,uint256)`.</span>
  9421 |     | <span class='neutral'>            mstore(0x00, 0x88f6e4b2)</span>
  9422 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  9423 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  9424 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  9425 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  9426 |     | <span class='neutral'>        }</span>
  9427 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x84);</span>
  9428 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  9429 |     | <span class='neutral'>        assembly {</span>
  9430 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  9431 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  9432 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  9433 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  9434 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  9435 |     | <span class='neutral'>        }</span>
  9436 |     | <span class='neutral'>    }</span>
  9437 |     | <span class='neutral'></span>
  9438 |     | <span class='neutral'>    function log(uint256 p0, uint256 p1, address p2, bytes32 p3) internal pure {</span>
  9439 |     | <span class='neutral'>        bytes32 m0;</span>
  9440 |     | <span class='neutral'>        bytes32 m1;</span>
  9441 |     | <span class='neutral'>        bytes32 m2;</span>
  9442 |     | <span class='neutral'>        bytes32 m3;</span>
  9443 |     | <span class='neutral'>        bytes32 m4;</span>
  9444 |     | <span class='neutral'>        bytes32 m5;</span>
  9445 |     | <span class='neutral'>        bytes32 m6;</span>
  9446 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  9447 |     | <span class='neutral'>        assembly {</span>
  9448 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  9449 |     | <span class='neutral'>                let length := 0</span>
  9450 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  9451 |     | <span class='neutral'>                mstore(pos, length)</span>
  9452 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  9453 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  9454 |     | <span class='neutral'>            }</span>
  9455 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  9456 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  9457 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  9458 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  9459 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  9460 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  9461 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
  9462 |     | <span class='neutral'>            // Selector of `log(uint256,uint256,address,string)`.</span>
  9463 |     | <span class='neutral'>            mstore(0x00, 0x6cde40b8)</span>
  9464 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  9465 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  9466 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  9467 |     | <span class='neutral'>            mstore(0x80, 0x80)</span>
  9468 |     | <span class='neutral'>            writeString(0xa0, p3)</span>
  9469 |     | <span class='neutral'>        }</span>
  9470 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xc4);</span>
  9471 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  9472 |     | <span class='neutral'>        assembly {</span>
  9473 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  9474 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  9475 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  9476 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  9477 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  9478 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  9479 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
  9480 |     | <span class='neutral'>        }</span>
  9481 |     | <span class='neutral'>    }</span>
  9482 |     | <span class='neutral'></span>
  9483 |     | <span class='neutral'>    function log(uint256 p0, uint256 p1, bool p2, address p3) internal pure {</span>
  9484 |     | <span class='neutral'>        bytes32 m0;</span>
  9485 |     | <span class='neutral'>        bytes32 m1;</span>
  9486 |     | <span class='neutral'>        bytes32 m2;</span>
  9487 |     | <span class='neutral'>        bytes32 m3;</span>
  9488 |     | <span class='neutral'>        bytes32 m4;</span>
  9489 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  9490 |     | <span class='neutral'>        assembly {</span>
  9491 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  9492 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  9493 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  9494 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  9495 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  9496 |     | <span class='neutral'>            // Selector of `log(uint256,uint256,bool,address)`.</span>
  9497 |     | <span class='neutral'>            mstore(0x00, 0x9a816a83)</span>
  9498 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  9499 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  9500 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  9501 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  9502 |     | <span class='neutral'>        }</span>
  9503 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x84);</span>
  9504 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  9505 |     | <span class='neutral'>        assembly {</span>
  9506 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  9507 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  9508 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  9509 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  9510 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  9511 |     | <span class='neutral'>        }</span>
  9512 |     | <span class='neutral'>    }</span>
  9513 |     | <span class='neutral'></span>
  9514 |     | <span class='neutral'>    function log(uint256 p0, uint256 p1, bool p2, bool p3) internal pure {</span>
  9515 |     | <span class='neutral'>        bytes32 m0;</span>
  9516 |     | <span class='neutral'>        bytes32 m1;</span>
  9517 |     | <span class='neutral'>        bytes32 m2;</span>
  9518 |     | <span class='neutral'>        bytes32 m3;</span>
  9519 |     | <span class='neutral'>        bytes32 m4;</span>
  9520 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  9521 |     | <span class='neutral'>        assembly {</span>
  9522 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  9523 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  9524 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  9525 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  9526 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  9527 |     | <span class='neutral'>            // Selector of `log(uint256,uint256,bool,bool)`.</span>
  9528 |     | <span class='neutral'>            mstore(0x00, 0xab085ae6)</span>
  9529 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  9530 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  9531 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  9532 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  9533 |     | <span class='neutral'>        }</span>
  9534 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x84);</span>
  9535 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  9536 |     | <span class='neutral'>        assembly {</span>
  9537 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  9538 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  9539 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  9540 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  9541 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  9542 |     | <span class='neutral'>        }</span>
  9543 |     | <span class='neutral'>    }</span>
  9544 |     | <span class='neutral'></span>
  9545 |     | <span class='neutral'>    function log(uint256 p0, uint256 p1, bool p2, uint256 p3) internal pure {</span>
  9546 |     | <span class='neutral'>        bytes32 m0;</span>
  9547 |     | <span class='neutral'>        bytes32 m1;</span>
  9548 |     | <span class='neutral'>        bytes32 m2;</span>
  9549 |     | <span class='neutral'>        bytes32 m3;</span>
  9550 |     | <span class='neutral'>        bytes32 m4;</span>
  9551 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  9552 |     | <span class='neutral'>        assembly {</span>
  9553 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  9554 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  9555 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  9556 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  9557 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  9558 |     | <span class='neutral'>            // Selector of `log(uint256,uint256,bool,uint256)`.</span>
  9559 |     | <span class='neutral'>            mstore(0x00, 0xeb7f6fd2)</span>
  9560 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  9561 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  9562 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  9563 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  9564 |     | <span class='neutral'>        }</span>
  9565 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x84);</span>
  9566 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  9567 |     | <span class='neutral'>        assembly {</span>
  9568 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  9569 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  9570 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  9571 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  9572 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  9573 |     | <span class='neutral'>        }</span>
  9574 |     | <span class='neutral'>    }</span>
  9575 |     | <span class='neutral'></span>
  9576 |     | <span class='neutral'>    function log(uint256 p0, uint256 p1, bool p2, bytes32 p3) internal pure {</span>
  9577 |     | <span class='neutral'>        bytes32 m0;</span>
  9578 |     | <span class='neutral'>        bytes32 m1;</span>
  9579 |     | <span class='neutral'>        bytes32 m2;</span>
  9580 |     | <span class='neutral'>        bytes32 m3;</span>
  9581 |     | <span class='neutral'>        bytes32 m4;</span>
  9582 |     | <span class='neutral'>        bytes32 m5;</span>
  9583 |     | <span class='neutral'>        bytes32 m6;</span>
  9584 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  9585 |     | <span class='neutral'>        assembly {</span>
  9586 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  9587 |     | <span class='neutral'>                let length := 0</span>
  9588 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  9589 |     | <span class='neutral'>                mstore(pos, length)</span>
  9590 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  9591 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  9592 |     | <span class='neutral'>            }</span>
  9593 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  9594 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  9595 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  9596 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  9597 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  9598 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  9599 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
  9600 |     | <span class='neutral'>            // Selector of `log(uint256,uint256,bool,string)`.</span>
  9601 |     | <span class='neutral'>            mstore(0x00, 0xa5b4fc99)</span>
  9602 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  9603 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  9604 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  9605 |     | <span class='neutral'>            mstore(0x80, 0x80)</span>
  9606 |     | <span class='neutral'>            writeString(0xa0, p3)</span>
  9607 |     | <span class='neutral'>        }</span>
  9608 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xc4);</span>
  9609 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  9610 |     | <span class='neutral'>        assembly {</span>
  9611 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  9612 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  9613 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  9614 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  9615 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  9616 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  9617 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
  9618 |     | <span class='neutral'>        }</span>
  9619 |     | <span class='neutral'>    }</span>
  9620 |     | <span class='neutral'></span>
  9621 |     | <span class='neutral'>    function log(uint256 p0, uint256 p1, uint256 p2, address p3) internal pure {</span>
  9622 |     | <span class='neutral'>        bytes32 m0;</span>
  9623 |     | <span class='neutral'>        bytes32 m1;</span>
  9624 |     | <span class='neutral'>        bytes32 m2;</span>
  9625 |     | <span class='neutral'>        bytes32 m3;</span>
  9626 |     | <span class='neutral'>        bytes32 m4;</span>
  9627 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  9628 |     | <span class='neutral'>        assembly {</span>
  9629 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  9630 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  9631 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  9632 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  9633 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  9634 |     | <span class='neutral'>            // Selector of `log(uint256,uint256,uint256,address)`.</span>
  9635 |     | <span class='neutral'>            mstore(0x00, 0xfa8185af)</span>
  9636 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  9637 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  9638 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  9639 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  9640 |     | <span class='neutral'>        }</span>
  9641 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x84);</span>
  9642 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  9643 |     | <span class='neutral'>        assembly {</span>
  9644 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  9645 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  9646 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  9647 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  9648 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  9649 |     | <span class='neutral'>        }</span>
  9650 |     | <span class='neutral'>    }</span>
  9651 |     | <span class='neutral'></span>
  9652 |     | <span class='neutral'>    function log(uint256 p0, uint256 p1, uint256 p2, bool p3) internal pure {</span>
  9653 |     | <span class='neutral'>        bytes32 m0;</span>
  9654 |     | <span class='neutral'>        bytes32 m1;</span>
  9655 |     | <span class='neutral'>        bytes32 m2;</span>
  9656 |     | <span class='neutral'>        bytes32 m3;</span>
  9657 |     | <span class='neutral'>        bytes32 m4;</span>
  9658 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  9659 |     | <span class='neutral'>        assembly {</span>
  9660 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  9661 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  9662 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  9663 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  9664 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  9665 |     | <span class='neutral'>            // Selector of `log(uint256,uint256,uint256,bool)`.</span>
  9666 |     | <span class='neutral'>            mstore(0x00, 0xc598d185)</span>
  9667 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  9668 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  9669 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  9670 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  9671 |     | <span class='neutral'>        }</span>
  9672 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x84);</span>
  9673 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  9674 |     | <span class='neutral'>        assembly {</span>
  9675 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  9676 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  9677 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  9678 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  9679 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  9680 |     | <span class='neutral'>        }</span>
  9681 |     | <span class='neutral'>    }</span>
  9682 |     | <span class='neutral'></span>
  9683 |     | <span class='neutral'>    function log(uint256 p0, uint256 p1, uint256 p2, uint256 p3) internal pure {</span>
  9684 |     | <span class='neutral'>        bytes32 m0;</span>
  9685 |     | <span class='neutral'>        bytes32 m1;</span>
  9686 |     | <span class='neutral'>        bytes32 m2;</span>
  9687 |     | <span class='neutral'>        bytes32 m3;</span>
  9688 |     | <span class='neutral'>        bytes32 m4;</span>
  9689 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  9690 |     | <span class='neutral'>        assembly {</span>
  9691 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  9692 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  9693 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  9694 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  9695 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  9696 |     | <span class='neutral'>            // Selector of `log(uint256,uint256,uint256,uint256)`.</span>
  9697 |     | <span class='neutral'>            mstore(0x00, 0x193fb800)</span>
  9698 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  9699 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  9700 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  9701 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  9702 |     | <span class='neutral'>        }</span>
  9703 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x84);</span>
  9704 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  9705 |     | <span class='neutral'>        assembly {</span>
  9706 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  9707 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  9708 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  9709 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  9710 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  9711 |     | <span class='neutral'>        }</span>
  9712 |     | <span class='neutral'>    }</span>
  9713 |     | <span class='neutral'></span>
  9714 |     | <span class='neutral'>    function log(uint256 p0, uint256 p1, uint256 p2, bytes32 p3) internal pure {</span>
  9715 |     | <span class='neutral'>        bytes32 m0;</span>
  9716 |     | <span class='neutral'>        bytes32 m1;</span>
  9717 |     | <span class='neutral'>        bytes32 m2;</span>
  9718 |     | <span class='neutral'>        bytes32 m3;</span>
  9719 |     | <span class='neutral'>        bytes32 m4;</span>
  9720 |     | <span class='neutral'>        bytes32 m5;</span>
  9721 |     | <span class='neutral'>        bytes32 m6;</span>
  9722 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  9723 |     | <span class='neutral'>        assembly {</span>
  9724 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  9725 |     | <span class='neutral'>                let length := 0</span>
  9726 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  9727 |     | <span class='neutral'>                mstore(pos, length)</span>
  9728 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  9729 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  9730 |     | <span class='neutral'>            }</span>
  9731 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  9732 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  9733 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  9734 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  9735 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  9736 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  9737 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
  9738 |     | <span class='neutral'>            // Selector of `log(uint256,uint256,uint256,string)`.</span>
  9739 |     | <span class='neutral'>            mstore(0x00, 0x59cfcbe3)</span>
  9740 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  9741 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  9742 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  9743 |     | <span class='neutral'>            mstore(0x80, 0x80)</span>
  9744 |     | <span class='neutral'>            writeString(0xa0, p3)</span>
  9745 |     | <span class='neutral'>        }</span>
  9746 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xc4);</span>
  9747 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  9748 |     | <span class='neutral'>        assembly {</span>
  9749 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  9750 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  9751 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  9752 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  9753 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  9754 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  9755 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
  9756 |     | <span class='neutral'>        }</span>
  9757 |     | <span class='neutral'>    }</span>
  9758 |     | <span class='neutral'></span>
  9759 |     | <span class='neutral'>    function log(uint256 p0, uint256 p1, bytes32 p2, address p3) internal pure {</span>
  9760 |     | <span class='neutral'>        bytes32 m0;</span>
  9761 |     | <span class='neutral'>        bytes32 m1;</span>
  9762 |     | <span class='neutral'>        bytes32 m2;</span>
  9763 |     | <span class='neutral'>        bytes32 m3;</span>
  9764 |     | <span class='neutral'>        bytes32 m4;</span>
  9765 |     | <span class='neutral'>        bytes32 m5;</span>
  9766 |     | <span class='neutral'>        bytes32 m6;</span>
  9767 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  9768 |     | <span class='neutral'>        assembly {</span>
  9769 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  9770 |     | <span class='neutral'>                let length := 0</span>
  9771 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  9772 |     | <span class='neutral'>                mstore(pos, length)</span>
  9773 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  9774 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  9775 |     | <span class='neutral'>            }</span>
  9776 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  9777 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  9778 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  9779 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  9780 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  9781 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  9782 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
  9783 |     | <span class='neutral'>            // Selector of `log(uint256,uint256,string,address)`.</span>
  9784 |     | <span class='neutral'>            mstore(0x00, 0x42d21db7)</span>
  9785 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  9786 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  9787 |     | <span class='neutral'>            mstore(0x60, 0x80)</span>
  9788 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  9789 |     | <span class='neutral'>            writeString(0xa0, p2)</span>
  9790 |     | <span class='neutral'>        }</span>
  9791 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xc4);</span>
  9792 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  9793 |     | <span class='neutral'>        assembly {</span>
  9794 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  9795 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  9796 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  9797 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  9798 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  9799 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  9800 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
  9801 |     | <span class='neutral'>        }</span>
  9802 |     | <span class='neutral'>    }</span>
  9803 |     | <span class='neutral'></span>
  9804 |     | <span class='neutral'>    function log(uint256 p0, uint256 p1, bytes32 p2, bool p3) internal pure {</span>
  9805 |     | <span class='neutral'>        bytes32 m0;</span>
  9806 |     | <span class='neutral'>        bytes32 m1;</span>
  9807 |     | <span class='neutral'>        bytes32 m2;</span>
  9808 |     | <span class='neutral'>        bytes32 m3;</span>
  9809 |     | <span class='neutral'>        bytes32 m4;</span>
  9810 |     | <span class='neutral'>        bytes32 m5;</span>
  9811 |     | <span class='neutral'>        bytes32 m6;</span>
  9812 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  9813 |     | <span class='neutral'>        assembly {</span>
  9814 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  9815 |     | <span class='neutral'>                let length := 0</span>
  9816 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  9817 |     | <span class='neutral'>                mstore(pos, length)</span>
  9818 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  9819 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  9820 |     | <span class='neutral'>            }</span>
  9821 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  9822 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  9823 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  9824 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  9825 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  9826 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  9827 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
  9828 |     | <span class='neutral'>            // Selector of `log(uint256,uint256,string,bool)`.</span>
  9829 |     | <span class='neutral'>            mstore(0x00, 0x7af6ab25)</span>
  9830 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  9831 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  9832 |     | <span class='neutral'>            mstore(0x60, 0x80)</span>
  9833 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  9834 |     | <span class='neutral'>            writeString(0xa0, p2)</span>
  9835 |     | <span class='neutral'>        }</span>
  9836 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xc4);</span>
  9837 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  9838 |     | <span class='neutral'>        assembly {</span>
  9839 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  9840 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  9841 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  9842 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  9843 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  9844 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  9845 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
  9846 |     | <span class='neutral'>        }</span>
  9847 |     | <span class='neutral'>    }</span>
  9848 |     | <span class='neutral'></span>
  9849 |     | <span class='neutral'>    function log(uint256 p0, uint256 p1, bytes32 p2, uint256 p3) internal pure {</span>
  9850 |     | <span class='neutral'>        bytes32 m0;</span>
  9851 |     | <span class='neutral'>        bytes32 m1;</span>
  9852 |     | <span class='neutral'>        bytes32 m2;</span>
  9853 |     | <span class='neutral'>        bytes32 m3;</span>
  9854 |     | <span class='neutral'>        bytes32 m4;</span>
  9855 |     | <span class='neutral'>        bytes32 m5;</span>
  9856 |     | <span class='neutral'>        bytes32 m6;</span>
  9857 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  9858 |     | <span class='neutral'>        assembly {</span>
  9859 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  9860 |     | <span class='neutral'>                let length := 0</span>
  9861 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  9862 |     | <span class='neutral'>                mstore(pos, length)</span>
  9863 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  9864 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  9865 |     | <span class='neutral'>            }</span>
  9866 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  9867 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  9868 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  9869 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  9870 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  9871 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  9872 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
  9873 |     | <span class='neutral'>            // Selector of `log(uint256,uint256,string,uint256)`.</span>
  9874 |     | <span class='neutral'>            mstore(0x00, 0x5da297eb)</span>
  9875 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  9876 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  9877 |     | <span class='neutral'>            mstore(0x60, 0x80)</span>
  9878 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  9879 |     | <span class='neutral'>            writeString(0xa0, p2)</span>
  9880 |     | <span class='neutral'>        }</span>
  9881 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xc4);</span>
  9882 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  9883 |     | <span class='neutral'>        assembly {</span>
  9884 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  9885 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  9886 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  9887 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  9888 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  9889 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  9890 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
  9891 |     | <span class='neutral'>        }</span>
  9892 |     | <span class='neutral'>    }</span>
  9893 |     | <span class='neutral'></span>
  9894 |     | <span class='neutral'>    function log(uint256 p0, uint256 p1, bytes32 p2, bytes32 p3) internal pure {</span>
  9895 |     | <span class='neutral'>        bytes32 m0;</span>
  9896 |     | <span class='neutral'>        bytes32 m1;</span>
  9897 |     | <span class='neutral'>        bytes32 m2;</span>
  9898 |     | <span class='neutral'>        bytes32 m3;</span>
  9899 |     | <span class='neutral'>        bytes32 m4;</span>
  9900 |     | <span class='neutral'>        bytes32 m5;</span>
  9901 |     | <span class='neutral'>        bytes32 m6;</span>
  9902 |     | <span class='neutral'>        bytes32 m7;</span>
  9903 |     | <span class='neutral'>        bytes32 m8;</span>
  9904 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  9905 |     | <span class='neutral'>        assembly {</span>
  9906 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  9907 |     | <span class='neutral'>                let length := 0</span>
  9908 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  9909 |     | <span class='neutral'>                mstore(pos, length)</span>
  9910 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  9911 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  9912 |     | <span class='neutral'>            }</span>
  9913 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  9914 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  9915 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  9916 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  9917 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  9918 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  9919 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
  9920 |     | <span class='neutral'>            m7 := mload(0xe0)</span>
  9921 |     | <span class='neutral'>            m8 := mload(0x100)</span>
  9922 |     | <span class='neutral'>            // Selector of `log(uint256,uint256,string,string)`.</span>
  9923 |     | <span class='neutral'>            mstore(0x00, 0x27d8afd2)</span>
  9924 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  9925 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  9926 |     | <span class='neutral'>            mstore(0x60, 0x80)</span>
  9927 |     | <span class='neutral'>            mstore(0x80, 0xc0)</span>
  9928 |     | <span class='neutral'>            writeString(0xa0, p2)</span>
  9929 |     | <span class='neutral'>            writeString(0xe0, p3)</span>
  9930 |     | <span class='neutral'>        }</span>
  9931 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x104);</span>
  9932 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  9933 |     | <span class='neutral'>        assembly {</span>
  9934 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  9935 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  9936 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  9937 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  9938 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  9939 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  9940 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
  9941 |     | <span class='neutral'>            mstore(0xe0, m7)</span>
  9942 |     | <span class='neutral'>            mstore(0x100, m8)</span>
  9943 |     | <span class='neutral'>        }</span>
  9944 |     | <span class='neutral'>    }</span>
  9945 |     | <span class='neutral'></span>
  9946 |     | <span class='neutral'>    function log(uint256 p0, bytes32 p1, address p2, address p3) internal pure {</span>
  9947 |     | <span class='neutral'>        bytes32 m0;</span>
  9948 |     | <span class='neutral'>        bytes32 m1;</span>
  9949 |     | <span class='neutral'>        bytes32 m2;</span>
  9950 |     | <span class='neutral'>        bytes32 m3;</span>
  9951 |     | <span class='neutral'>        bytes32 m4;</span>
  9952 |     | <span class='neutral'>        bytes32 m5;</span>
  9953 |     | <span class='neutral'>        bytes32 m6;</span>
  9954 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  9955 |     | <span class='neutral'>        assembly {</span>
  9956 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  9957 |     | <span class='neutral'>                let length := 0</span>
  9958 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  9959 |     | <span class='neutral'>                mstore(pos, length)</span>
  9960 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  9961 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  9962 |     | <span class='neutral'>            }</span>
  9963 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  9964 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  9965 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  9966 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  9967 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  9968 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  9969 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
  9970 |     | <span class='neutral'>            // Selector of `log(uint256,string,address,address)`.</span>
  9971 |     | <span class='neutral'>            mstore(0x00, 0x6168ed61)</span>
  9972 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  9973 |     | <span class='neutral'>            mstore(0x40, 0x80)</span>
  9974 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  9975 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  9976 |     | <span class='neutral'>            writeString(0xa0, p1)</span>
  9977 |     | <span class='neutral'>        }</span>
  9978 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xc4);</span>
  9979 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  9980 |     | <span class='neutral'>        assembly {</span>
  9981 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  9982 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  9983 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  9984 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  9985 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  9986 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  9987 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
  9988 |     | <span class='neutral'>        }</span>
  9989 |     | <span class='neutral'>    }</span>
  9990 |     | <span class='neutral'></span>
  9991 |     | <span class='neutral'>    function log(uint256 p0, bytes32 p1, address p2, bool p3) internal pure {</span>
  9992 |     | <span class='neutral'>        bytes32 m0;</span>
  9993 |     | <span class='neutral'>        bytes32 m1;</span>
  9994 |     | <span class='neutral'>        bytes32 m2;</span>
  9995 |     | <span class='neutral'>        bytes32 m3;</span>
  9996 |     | <span class='neutral'>        bytes32 m4;</span>
  9997 |     | <span class='neutral'>        bytes32 m5;</span>
  9998 |     | <span class='neutral'>        bytes32 m6;</span>
  9999 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 10000 |     | <span class='neutral'>        assembly {</span>
 10001 |     | <span class='neutral'>            function writeString(pos, w) {</span>
 10002 |     | <span class='neutral'>                let length := 0</span>
 10003 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
 10004 |     | <span class='neutral'>                mstore(pos, length)</span>
 10005 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
 10006 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
 10007 |     | <span class='neutral'>            }</span>
 10008 |     | <span class='neutral'>            m0 := mload(0x00)</span>
 10009 |     | <span class='neutral'>            m1 := mload(0x20)</span>
 10010 |     | <span class='neutral'>            m2 := mload(0x40)</span>
 10011 |     | <span class='neutral'>            m3 := mload(0x60)</span>
 10012 |     | <span class='neutral'>            m4 := mload(0x80)</span>
 10013 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
 10014 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
 10015 |     | <span class='neutral'>            // Selector of `log(uint256,string,address,bool)`.</span>
 10016 |     | <span class='neutral'>            mstore(0x00, 0x90c30a56)</span>
 10017 |     | <span class='neutral'>            mstore(0x20, p0)</span>
 10018 |     | <span class='neutral'>            mstore(0x40, 0x80)</span>
 10019 |     | <span class='neutral'>            mstore(0x60, p2)</span>
 10020 |     | <span class='neutral'>            mstore(0x80, p3)</span>
 10021 |     | <span class='neutral'>            writeString(0xa0, p1)</span>
 10022 |     | <span class='neutral'>        }</span>
 10023 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xc4);</span>
 10024 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 10025 |     | <span class='neutral'>        assembly {</span>
 10026 |     | <span class='neutral'>            mstore(0x00, m0)</span>
 10027 |     | <span class='neutral'>            mstore(0x20, m1)</span>
 10028 |     | <span class='neutral'>            mstore(0x40, m2)</span>
 10029 |     | <span class='neutral'>            mstore(0x60, m3)</span>
 10030 |     | <span class='neutral'>            mstore(0x80, m4)</span>
 10031 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
 10032 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
 10033 |     | <span class='neutral'>        }</span>
 10034 |     | <span class='neutral'>    }</span>
 10035 |     | <span class='neutral'></span>
 10036 |     | <span class='neutral'>    function log(uint256 p0, bytes32 p1, address p2, uint256 p3) internal pure {</span>
 10037 |     | <span class='neutral'>        bytes32 m0;</span>
 10038 |     | <span class='neutral'>        bytes32 m1;</span>
 10039 |     | <span class='neutral'>        bytes32 m2;</span>
 10040 |     | <span class='neutral'>        bytes32 m3;</span>
 10041 |     | <span class='neutral'>        bytes32 m4;</span>
 10042 |     | <span class='neutral'>        bytes32 m5;</span>
 10043 |     | <span class='neutral'>        bytes32 m6;</span>
 10044 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 10045 |     | <span class='neutral'>        assembly {</span>
 10046 |     | <span class='neutral'>            function writeString(pos, w) {</span>
 10047 |     | <span class='neutral'>                let length := 0</span>
 10048 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
 10049 |     | <span class='neutral'>                mstore(pos, length)</span>
 10050 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
 10051 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
 10052 |     | <span class='neutral'>            }</span>
 10053 |     | <span class='neutral'>            m0 := mload(0x00)</span>
 10054 |     | <span class='neutral'>            m1 := mload(0x20)</span>
 10055 |     | <span class='neutral'>            m2 := mload(0x40)</span>
 10056 |     | <span class='neutral'>            m3 := mload(0x60)</span>
 10057 |     | <span class='neutral'>            m4 := mload(0x80)</span>
 10058 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
 10059 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
 10060 |     | <span class='neutral'>            // Selector of `log(uint256,string,address,uint256)`.</span>
 10061 |     | <span class='neutral'>            mstore(0x00, 0xe8d3018d)</span>
 10062 |     | <span class='neutral'>            mstore(0x20, p0)</span>
 10063 |     | <span class='neutral'>            mstore(0x40, 0x80)</span>
 10064 |     | <span class='neutral'>            mstore(0x60, p2)</span>
 10065 |     | <span class='neutral'>            mstore(0x80, p3)</span>
 10066 |     | <span class='neutral'>            writeString(0xa0, p1)</span>
 10067 |     | <span class='neutral'>        }</span>
 10068 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xc4);</span>
 10069 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 10070 |     | <span class='neutral'>        assembly {</span>
 10071 |     | <span class='neutral'>            mstore(0x00, m0)</span>
 10072 |     | <span class='neutral'>            mstore(0x20, m1)</span>
 10073 |     | <span class='neutral'>            mstore(0x40, m2)</span>
 10074 |     | <span class='neutral'>            mstore(0x60, m3)</span>
 10075 |     | <span class='neutral'>            mstore(0x80, m4)</span>
 10076 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
 10077 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
 10078 |     | <span class='neutral'>        }</span>
 10079 |     | <span class='neutral'>    }</span>
 10080 |     | <span class='neutral'></span>
 10081 |     | <span class='neutral'>    function log(uint256 p0, bytes32 p1, address p2, bytes32 p3) internal pure {</span>
 10082 |     | <span class='neutral'>        bytes32 m0;</span>
 10083 |     | <span class='neutral'>        bytes32 m1;</span>
 10084 |     | <span class='neutral'>        bytes32 m2;</span>
 10085 |     | <span class='neutral'>        bytes32 m3;</span>
 10086 |     | <span class='neutral'>        bytes32 m4;</span>
 10087 |     | <span class='neutral'>        bytes32 m5;</span>
 10088 |     | <span class='neutral'>        bytes32 m6;</span>
 10089 |     | <span class='neutral'>        bytes32 m7;</span>
 10090 |     | <span class='neutral'>        bytes32 m8;</span>
 10091 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 10092 |     | <span class='neutral'>        assembly {</span>
 10093 |     | <span class='neutral'>            function writeString(pos, w) {</span>
 10094 |     | <span class='neutral'>                let length := 0</span>
 10095 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
 10096 |     | <span class='neutral'>                mstore(pos, length)</span>
 10097 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
 10098 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
 10099 |     | <span class='neutral'>            }</span>
 10100 |     | <span class='neutral'>            m0 := mload(0x00)</span>
 10101 |     | <span class='neutral'>            m1 := mload(0x20)</span>
 10102 |     | <span class='neutral'>            m2 := mload(0x40)</span>
 10103 |     | <span class='neutral'>            m3 := mload(0x60)</span>
 10104 |     | <span class='neutral'>            m4 := mload(0x80)</span>
 10105 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
 10106 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
 10107 |     | <span class='neutral'>            m7 := mload(0xe0)</span>
 10108 |     | <span class='neutral'>            m8 := mload(0x100)</span>
 10109 |     | <span class='neutral'>            // Selector of `log(uint256,string,address,string)`.</span>
 10110 |     | <span class='neutral'>            mstore(0x00, 0x9c3adfa1)</span>
 10111 |     | <span class='neutral'>            mstore(0x20, p0)</span>
 10112 |     | <span class='neutral'>            mstore(0x40, 0x80)</span>
 10113 |     | <span class='neutral'>            mstore(0x60, p2)</span>
 10114 |     | <span class='neutral'>            mstore(0x80, 0xc0)</span>
 10115 |     | <span class='neutral'>            writeString(0xa0, p1)</span>
 10116 |     | <span class='neutral'>            writeString(0xe0, p3)</span>
 10117 |     | <span class='neutral'>        }</span>
 10118 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x104);</span>
 10119 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 10120 |     | <span class='neutral'>        assembly {</span>
 10121 |     | <span class='neutral'>            mstore(0x00, m0)</span>
 10122 |     | <span class='neutral'>            mstore(0x20, m1)</span>
 10123 |     | <span class='neutral'>            mstore(0x40, m2)</span>
 10124 |     | <span class='neutral'>            mstore(0x60, m3)</span>
 10125 |     | <span class='neutral'>            mstore(0x80, m4)</span>
 10126 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
 10127 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
 10128 |     | <span class='neutral'>            mstore(0xe0, m7)</span>
 10129 |     | <span class='neutral'>            mstore(0x100, m8)</span>
 10130 |     | <span class='neutral'>        }</span>
 10131 |     | <span class='neutral'>    }</span>
 10132 |     | <span class='neutral'></span>
 10133 |     | <span class='neutral'>    function log(uint256 p0, bytes32 p1, bool p2, address p3) internal pure {</span>
 10134 |     | <span class='neutral'>        bytes32 m0;</span>
 10135 |     | <span class='neutral'>        bytes32 m1;</span>
 10136 |     | <span class='neutral'>        bytes32 m2;</span>
 10137 |     | <span class='neutral'>        bytes32 m3;</span>
 10138 |     | <span class='neutral'>        bytes32 m4;</span>
 10139 |     | <span class='neutral'>        bytes32 m5;</span>
 10140 |     | <span class='neutral'>        bytes32 m6;</span>
 10141 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 10142 |     | <span class='neutral'>        assembly {</span>
 10143 |     | <span class='neutral'>            function writeString(pos, w) {</span>
 10144 |     | <span class='neutral'>                let length := 0</span>
 10145 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
 10146 |     | <span class='neutral'>                mstore(pos, length)</span>
 10147 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
 10148 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
 10149 |     | <span class='neutral'>            }</span>
 10150 |     | <span class='neutral'>            m0 := mload(0x00)</span>
 10151 |     | <span class='neutral'>            m1 := mload(0x20)</span>
 10152 |     | <span class='neutral'>            m2 := mload(0x40)</span>
 10153 |     | <span class='neutral'>            m3 := mload(0x60)</span>
 10154 |     | <span class='neutral'>            m4 := mload(0x80)</span>
 10155 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
 10156 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
 10157 |     | <span class='neutral'>            // Selector of `log(uint256,string,bool,address)`.</span>
 10158 |     | <span class='neutral'>            mstore(0x00, 0xae2ec581)</span>
 10159 |     | <span class='neutral'>            mstore(0x20, p0)</span>
 10160 |     | <span class='neutral'>            mstore(0x40, 0x80)</span>
 10161 |     | <span class='neutral'>            mstore(0x60, p2)</span>
 10162 |     | <span class='neutral'>            mstore(0x80, p3)</span>
 10163 |     | <span class='neutral'>            writeString(0xa0, p1)</span>
 10164 |     | <span class='neutral'>        }</span>
 10165 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xc4);</span>
 10166 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 10167 |     | <span class='neutral'>        assembly {</span>
 10168 |     | <span class='neutral'>            mstore(0x00, m0)</span>
 10169 |     | <span class='neutral'>            mstore(0x20, m1)</span>
 10170 |     | <span class='neutral'>            mstore(0x40, m2)</span>
 10171 |     | <span class='neutral'>            mstore(0x60, m3)</span>
 10172 |     | <span class='neutral'>            mstore(0x80, m4)</span>
 10173 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
 10174 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
 10175 |     | <span class='neutral'>        }</span>
 10176 |     | <span class='neutral'>    }</span>
 10177 |     | <span class='neutral'></span>
 10178 |     | <span class='neutral'>    function log(uint256 p0, bytes32 p1, bool p2, bool p3) internal pure {</span>
 10179 |     | <span class='neutral'>        bytes32 m0;</span>
 10180 |     | <span class='neutral'>        bytes32 m1;</span>
 10181 |     | <span class='neutral'>        bytes32 m2;</span>
 10182 |     | <span class='neutral'>        bytes32 m3;</span>
 10183 |     | <span class='neutral'>        bytes32 m4;</span>
 10184 |     | <span class='neutral'>        bytes32 m5;</span>
 10185 |     | <span class='neutral'>        bytes32 m6;</span>
 10186 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 10187 |     | <span class='neutral'>        assembly {</span>
 10188 |     | <span class='neutral'>            function writeString(pos, w) {</span>
 10189 |     | <span class='neutral'>                let length := 0</span>
 10190 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
 10191 |     | <span class='neutral'>                mstore(pos, length)</span>
 10192 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
 10193 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
 10194 |     | <span class='neutral'>            }</span>
 10195 |     | <span class='neutral'>            m0 := mload(0x00)</span>
 10196 |     | <span class='neutral'>            m1 := mload(0x20)</span>
 10197 |     | <span class='neutral'>            m2 := mload(0x40)</span>
 10198 |     | <span class='neutral'>            m3 := mload(0x60)</span>
 10199 |     | <span class='neutral'>            m4 := mload(0x80)</span>
 10200 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
 10201 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
 10202 |     | <span class='neutral'>            // Selector of `log(uint256,string,bool,bool)`.</span>
 10203 |     | <span class='neutral'>            mstore(0x00, 0xba535d9c)</span>
 10204 |     | <span class='neutral'>            mstore(0x20, p0)</span>
 10205 |     | <span class='neutral'>            mstore(0x40, 0x80)</span>
 10206 |     | <span class='neutral'>            mstore(0x60, p2)</span>
 10207 |     | <span class='neutral'>            mstore(0x80, p3)</span>
 10208 |     | <span class='neutral'>            writeString(0xa0, p1)</span>
 10209 |     | <span class='neutral'>        }</span>
 10210 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xc4);</span>
 10211 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 10212 |     | <span class='neutral'>        assembly {</span>
 10213 |     | <span class='neutral'>            mstore(0x00, m0)</span>
 10214 |     | <span class='neutral'>            mstore(0x20, m1)</span>
 10215 |     | <span class='neutral'>            mstore(0x40, m2)</span>
 10216 |     | <span class='neutral'>            mstore(0x60, m3)</span>
 10217 |     | <span class='neutral'>            mstore(0x80, m4)</span>
 10218 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
 10219 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
 10220 |     | <span class='neutral'>        }</span>
 10221 |     | <span class='neutral'>    }</span>
 10222 |     | <span class='neutral'></span>
 10223 |     | <span class='neutral'>    function log(uint256 p0, bytes32 p1, bool p2, uint256 p3) internal pure {</span>
 10224 |     | <span class='neutral'>        bytes32 m0;</span>
 10225 |     | <span class='neutral'>        bytes32 m1;</span>
 10226 |     | <span class='neutral'>        bytes32 m2;</span>
 10227 |     | <span class='neutral'>        bytes32 m3;</span>
 10228 |     | <span class='neutral'>        bytes32 m4;</span>
 10229 |     | <span class='neutral'>        bytes32 m5;</span>
 10230 |     | <span class='neutral'>        bytes32 m6;</span>
 10231 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 10232 |     | <span class='neutral'>        assembly {</span>
 10233 |     | <span class='neutral'>            function writeString(pos, w) {</span>
 10234 |     | <span class='neutral'>                let length := 0</span>
 10235 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
 10236 |     | <span class='neutral'>                mstore(pos, length)</span>
 10237 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
 10238 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
 10239 |     | <span class='neutral'>            }</span>
 10240 |     | <span class='neutral'>            m0 := mload(0x00)</span>
 10241 |     | <span class='neutral'>            m1 := mload(0x20)</span>
 10242 |     | <span class='neutral'>            m2 := mload(0x40)</span>
 10243 |     | <span class='neutral'>            m3 := mload(0x60)</span>
 10244 |     | <span class='neutral'>            m4 := mload(0x80)</span>
 10245 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
 10246 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
 10247 |     | <span class='neutral'>            // Selector of `log(uint256,string,bool,uint256)`.</span>
 10248 |     | <span class='neutral'>            mstore(0x00, 0xcf009880)</span>
 10249 |     | <span class='neutral'>            mstore(0x20, p0)</span>
 10250 |     | <span class='neutral'>            mstore(0x40, 0x80)</span>
 10251 |     | <span class='neutral'>            mstore(0x60, p2)</span>
 10252 |     | <span class='neutral'>            mstore(0x80, p3)</span>
 10253 |     | <span class='neutral'>            writeString(0xa0, p1)</span>
 10254 |     | <span class='neutral'>        }</span>
 10255 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xc4);</span>
 10256 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 10257 |     | <span class='neutral'>        assembly {</span>
 10258 |     | <span class='neutral'>            mstore(0x00, m0)</span>
 10259 |     | <span class='neutral'>            mstore(0x20, m1)</span>
 10260 |     | <span class='neutral'>            mstore(0x40, m2)</span>
 10261 |     | <span class='neutral'>            mstore(0x60, m3)</span>
 10262 |     | <span class='neutral'>            mstore(0x80, m4)</span>
 10263 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
 10264 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
 10265 |     | <span class='neutral'>        }</span>
 10266 |     | <span class='neutral'>    }</span>
 10267 |     | <span class='neutral'></span>
 10268 |     | <span class='neutral'>    function log(uint256 p0, bytes32 p1, bool p2, bytes32 p3) internal pure {</span>
 10269 |     | <span class='neutral'>        bytes32 m0;</span>
 10270 |     | <span class='neutral'>        bytes32 m1;</span>
 10271 |     | <span class='neutral'>        bytes32 m2;</span>
 10272 |     | <span class='neutral'>        bytes32 m3;</span>
 10273 |     | <span class='neutral'>        bytes32 m4;</span>
 10274 |     | <span class='neutral'>        bytes32 m5;</span>
 10275 |     | <span class='neutral'>        bytes32 m6;</span>
 10276 |     | <span class='neutral'>        bytes32 m7;</span>
 10277 |     | <span class='neutral'>        bytes32 m8;</span>
 10278 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 10279 |     | <span class='neutral'>        assembly {</span>
 10280 |     | <span class='neutral'>            function writeString(pos, w) {</span>
 10281 |     | <span class='neutral'>                let length := 0</span>
 10282 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
 10283 |     | <span class='neutral'>                mstore(pos, length)</span>
 10284 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
 10285 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
 10286 |     | <span class='neutral'>            }</span>
 10287 |     | <span class='neutral'>            m0 := mload(0x00)</span>
 10288 |     | <span class='neutral'>            m1 := mload(0x20)</span>
 10289 |     | <span class='neutral'>            m2 := mload(0x40)</span>
 10290 |     | <span class='neutral'>            m3 := mload(0x60)</span>
 10291 |     | <span class='neutral'>            m4 := mload(0x80)</span>
 10292 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
 10293 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
 10294 |     | <span class='neutral'>            m7 := mload(0xe0)</span>
 10295 |     | <span class='neutral'>            m8 := mload(0x100)</span>
 10296 |     | <span class='neutral'>            // Selector of `log(uint256,string,bool,string)`.</span>
 10297 |     | <span class='neutral'>            mstore(0x00, 0xd2d423cd)</span>
 10298 |     | <span class='neutral'>            mstore(0x20, p0)</span>
 10299 |     | <span class='neutral'>            mstore(0x40, 0x80)</span>
 10300 |     | <span class='neutral'>            mstore(0x60, p2)</span>
 10301 |     | <span class='neutral'>            mstore(0x80, 0xc0)</span>
 10302 |     | <span class='neutral'>            writeString(0xa0, p1)</span>
 10303 |     | <span class='neutral'>            writeString(0xe0, p3)</span>
 10304 |     | <span class='neutral'>        }</span>
 10305 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x104);</span>
 10306 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 10307 |     | <span class='neutral'>        assembly {</span>
 10308 |     | <span class='neutral'>            mstore(0x00, m0)</span>
 10309 |     | <span class='neutral'>            mstore(0x20, m1)</span>
 10310 |     | <span class='neutral'>            mstore(0x40, m2)</span>
 10311 |     | <span class='neutral'>            mstore(0x60, m3)</span>
 10312 |     | <span class='neutral'>            mstore(0x80, m4)</span>
 10313 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
 10314 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
 10315 |     | <span class='neutral'>            mstore(0xe0, m7)</span>
 10316 |     | <span class='neutral'>            mstore(0x100, m8)</span>
 10317 |     | <span class='neutral'>        }</span>
 10318 |     | <span class='neutral'>    }</span>
 10319 |     | <span class='neutral'></span>
 10320 |     | <span class='neutral'>    function log(uint256 p0, bytes32 p1, uint256 p2, address p3) internal pure {</span>
 10321 |     | <span class='neutral'>        bytes32 m0;</span>
 10322 |     | <span class='neutral'>        bytes32 m1;</span>
 10323 |     | <span class='neutral'>        bytes32 m2;</span>
 10324 |     | <span class='neutral'>        bytes32 m3;</span>
 10325 |     | <span class='neutral'>        bytes32 m4;</span>
 10326 |     | <span class='neutral'>        bytes32 m5;</span>
 10327 |     | <span class='neutral'>        bytes32 m6;</span>
 10328 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 10329 |     | <span class='neutral'>        assembly {</span>
 10330 |     | <span class='neutral'>            function writeString(pos, w) {</span>
 10331 |     | <span class='neutral'>                let length := 0</span>
 10332 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
 10333 |     | <span class='neutral'>                mstore(pos, length)</span>
 10334 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
 10335 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
 10336 |     | <span class='neutral'>            }</span>
 10337 |     | <span class='neutral'>            m0 := mload(0x00)</span>
 10338 |     | <span class='neutral'>            m1 := mload(0x20)</span>
 10339 |     | <span class='neutral'>            m2 := mload(0x40)</span>
 10340 |     | <span class='neutral'>            m3 := mload(0x60)</span>
 10341 |     | <span class='neutral'>            m4 := mload(0x80)</span>
 10342 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
 10343 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
 10344 |     | <span class='neutral'>            // Selector of `log(uint256,string,uint256,address)`.</span>
 10345 |     | <span class='neutral'>            mstore(0x00, 0x3b2279b4)</span>
 10346 |     | <span class='neutral'>            mstore(0x20, p0)</span>
 10347 |     | <span class='neutral'>            mstore(0x40, 0x80)</span>
 10348 |     | <span class='neutral'>            mstore(0x60, p2)</span>
 10349 |     | <span class='neutral'>            mstore(0x80, p3)</span>
 10350 |     | <span class='neutral'>            writeString(0xa0, p1)</span>
 10351 |     | <span class='neutral'>        }</span>
 10352 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xc4);</span>
 10353 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 10354 |     | <span class='neutral'>        assembly {</span>
 10355 |     | <span class='neutral'>            mstore(0x00, m0)</span>
 10356 |     | <span class='neutral'>            mstore(0x20, m1)</span>
 10357 |     | <span class='neutral'>            mstore(0x40, m2)</span>
 10358 |     | <span class='neutral'>            mstore(0x60, m3)</span>
 10359 |     | <span class='neutral'>            mstore(0x80, m4)</span>
 10360 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
 10361 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
 10362 |     | <span class='neutral'>        }</span>
 10363 |     | <span class='neutral'>    }</span>
 10364 |     | <span class='neutral'></span>
 10365 |     | <span class='neutral'>    function log(uint256 p0, bytes32 p1, uint256 p2, bool p3) internal pure {</span>
 10366 |     | <span class='neutral'>        bytes32 m0;</span>
 10367 |     | <span class='neutral'>        bytes32 m1;</span>
 10368 |     | <span class='neutral'>        bytes32 m2;</span>
 10369 |     | <span class='neutral'>        bytes32 m3;</span>
 10370 |     | <span class='neutral'>        bytes32 m4;</span>
 10371 |     | <span class='neutral'>        bytes32 m5;</span>
 10372 |     | <span class='neutral'>        bytes32 m6;</span>
 10373 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 10374 |     | <span class='neutral'>        assembly {</span>
 10375 |     | <span class='neutral'>            function writeString(pos, w) {</span>
 10376 |     | <span class='neutral'>                let length := 0</span>
 10377 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
 10378 |     | <span class='neutral'>                mstore(pos, length)</span>
 10379 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
 10380 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
 10381 |     | <span class='neutral'>            }</span>
 10382 |     | <span class='neutral'>            m0 := mload(0x00)</span>
 10383 |     | <span class='neutral'>            m1 := mload(0x20)</span>
 10384 |     | <span class='neutral'>            m2 := mload(0x40)</span>
 10385 |     | <span class='neutral'>            m3 := mload(0x60)</span>
 10386 |     | <span class='neutral'>            m4 := mload(0x80)</span>
 10387 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
 10388 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
 10389 |     | <span class='neutral'>            // Selector of `log(uint256,string,uint256,bool)`.</span>
 10390 |     | <span class='neutral'>            mstore(0x00, 0x691a8f74)</span>
 10391 |     | <span class='neutral'>            mstore(0x20, p0)</span>
 10392 |     | <span class='neutral'>            mstore(0x40, 0x80)</span>
 10393 |     | <span class='neutral'>            mstore(0x60, p2)</span>
 10394 |     | <span class='neutral'>            mstore(0x80, p3)</span>
 10395 |     | <span class='neutral'>            writeString(0xa0, p1)</span>
 10396 |     | <span class='neutral'>        }</span>
 10397 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xc4);</span>
 10398 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 10399 |     | <span class='neutral'>        assembly {</span>
 10400 |     | <span class='neutral'>            mstore(0x00, m0)</span>
 10401 |     | <span class='neutral'>            mstore(0x20, m1)</span>
 10402 |     | <span class='neutral'>            mstore(0x40, m2)</span>
 10403 |     | <span class='neutral'>            mstore(0x60, m3)</span>
 10404 |     | <span class='neutral'>            mstore(0x80, m4)</span>
 10405 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
 10406 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
 10407 |     | <span class='neutral'>        }</span>
 10408 |     | <span class='neutral'>    }</span>
 10409 |     | <span class='neutral'></span>
 10410 |     | <span class='neutral'>    function log(uint256 p0, bytes32 p1, uint256 p2, uint256 p3) internal pure {</span>
 10411 |     | <span class='neutral'>        bytes32 m0;</span>
 10412 |     | <span class='neutral'>        bytes32 m1;</span>
 10413 |     | <span class='neutral'>        bytes32 m2;</span>
 10414 |     | <span class='neutral'>        bytes32 m3;</span>
 10415 |     | <span class='neutral'>        bytes32 m4;</span>
 10416 |     | <span class='neutral'>        bytes32 m5;</span>
 10417 |     | <span class='neutral'>        bytes32 m6;</span>
 10418 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 10419 |     | <span class='neutral'>        assembly {</span>
 10420 |     | <span class='neutral'>            function writeString(pos, w) {</span>
 10421 |     | <span class='neutral'>                let length := 0</span>
 10422 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
 10423 |     | <span class='neutral'>                mstore(pos, length)</span>
 10424 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
 10425 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
 10426 |     | <span class='neutral'>            }</span>
 10427 |     | <span class='neutral'>            m0 := mload(0x00)</span>
 10428 |     | <span class='neutral'>            m1 := mload(0x20)</span>
 10429 |     | <span class='neutral'>            m2 := mload(0x40)</span>
 10430 |     | <span class='neutral'>            m3 := mload(0x60)</span>
 10431 |     | <span class='neutral'>            m4 := mload(0x80)</span>
 10432 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
 10433 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
 10434 |     | <span class='neutral'>            // Selector of `log(uint256,string,uint256,uint256)`.</span>
 10435 |     | <span class='neutral'>            mstore(0x00, 0x82c25b74)</span>
 10436 |     | <span class='neutral'>            mstore(0x20, p0)</span>
 10437 |     | <span class='neutral'>            mstore(0x40, 0x80)</span>
 10438 |     | <span class='neutral'>            mstore(0x60, p2)</span>
 10439 |     | <span class='neutral'>            mstore(0x80, p3)</span>
 10440 |     | <span class='neutral'>            writeString(0xa0, p1)</span>
 10441 |     | <span class='neutral'>        }</span>
 10442 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xc4);</span>
 10443 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 10444 |     | <span class='neutral'>        assembly {</span>
 10445 |     | <span class='neutral'>            mstore(0x00, m0)</span>
 10446 |     | <span class='neutral'>            mstore(0x20, m1)</span>
 10447 |     | <span class='neutral'>            mstore(0x40, m2)</span>
 10448 |     | <span class='neutral'>            mstore(0x60, m3)</span>
 10449 |     | <span class='neutral'>            mstore(0x80, m4)</span>
 10450 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
 10451 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
 10452 |     | <span class='neutral'>        }</span>
 10453 |     | <span class='neutral'>    }</span>
 10454 |     | <span class='neutral'></span>
 10455 |     | <span class='neutral'>    function log(uint256 p0, bytes32 p1, uint256 p2, bytes32 p3) internal pure {</span>
 10456 |     | <span class='neutral'>        bytes32 m0;</span>
 10457 |     | <span class='neutral'>        bytes32 m1;</span>
 10458 |     | <span class='neutral'>        bytes32 m2;</span>
 10459 |     | <span class='neutral'>        bytes32 m3;</span>
 10460 |     | <span class='neutral'>        bytes32 m4;</span>
 10461 |     | <span class='neutral'>        bytes32 m5;</span>
 10462 |     | <span class='neutral'>        bytes32 m6;</span>
 10463 |     | <span class='neutral'>        bytes32 m7;</span>
 10464 |     | <span class='neutral'>        bytes32 m8;</span>
 10465 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 10466 |     | <span class='neutral'>        assembly {</span>
 10467 |     | <span class='neutral'>            function writeString(pos, w) {</span>
 10468 |     | <span class='neutral'>                let length := 0</span>
 10469 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
 10470 |     | <span class='neutral'>                mstore(pos, length)</span>
 10471 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
 10472 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
 10473 |     | <span class='neutral'>            }</span>
 10474 |     | <span class='neutral'>            m0 := mload(0x00)</span>
 10475 |     | <span class='neutral'>            m1 := mload(0x20)</span>
 10476 |     | <span class='neutral'>            m2 := mload(0x40)</span>
 10477 |     | <span class='neutral'>            m3 := mload(0x60)</span>
 10478 |     | <span class='neutral'>            m4 := mload(0x80)</span>
 10479 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
 10480 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
 10481 |     | <span class='neutral'>            m7 := mload(0xe0)</span>
 10482 |     | <span class='neutral'>            m8 := mload(0x100)</span>
 10483 |     | <span class='neutral'>            // Selector of `log(uint256,string,uint256,string)`.</span>
 10484 |     | <span class='neutral'>            mstore(0x00, 0xb7b914ca)</span>
 10485 |     | <span class='neutral'>            mstore(0x20, p0)</span>
 10486 |     | <span class='neutral'>            mstore(0x40, 0x80)</span>
 10487 |     | <span class='neutral'>            mstore(0x60, p2)</span>
 10488 |     | <span class='neutral'>            mstore(0x80, 0xc0)</span>
 10489 |     | <span class='neutral'>            writeString(0xa0, p1)</span>
 10490 |     | <span class='neutral'>            writeString(0xe0, p3)</span>
 10491 |     | <span class='neutral'>        }</span>
 10492 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x104);</span>
 10493 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 10494 |     | <span class='neutral'>        assembly {</span>
 10495 |     | <span class='neutral'>            mstore(0x00, m0)</span>
 10496 |     | <span class='neutral'>            mstore(0x20, m1)</span>
 10497 |     | <span class='neutral'>            mstore(0x40, m2)</span>
 10498 |     | <span class='neutral'>            mstore(0x60, m3)</span>
 10499 |     | <span class='neutral'>            mstore(0x80, m4)</span>
 10500 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
 10501 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
 10502 |     | <span class='neutral'>            mstore(0xe0, m7)</span>
 10503 |     | <span class='neutral'>            mstore(0x100, m8)</span>
 10504 |     | <span class='neutral'>        }</span>
 10505 |     | <span class='neutral'>    }</span>
 10506 |     | <span class='neutral'></span>
 10507 |     | <span class='neutral'>    function log(uint256 p0, bytes32 p1, bytes32 p2, address p3) internal pure {</span>
 10508 |     | <span class='neutral'>        bytes32 m0;</span>
 10509 |     | <span class='neutral'>        bytes32 m1;</span>
 10510 |     | <span class='neutral'>        bytes32 m2;</span>
 10511 |     | <span class='neutral'>        bytes32 m3;</span>
 10512 |     | <span class='neutral'>        bytes32 m4;</span>
 10513 |     | <span class='neutral'>        bytes32 m5;</span>
 10514 |     | <span class='neutral'>        bytes32 m6;</span>
 10515 |     | <span class='neutral'>        bytes32 m7;</span>
 10516 |     | <span class='neutral'>        bytes32 m8;</span>
 10517 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 10518 |     | <span class='neutral'>        assembly {</span>
 10519 |     | <span class='neutral'>            function writeString(pos, w) {</span>
 10520 |     | <span class='neutral'>                let length := 0</span>
 10521 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
 10522 |     | <span class='neutral'>                mstore(pos, length)</span>
 10523 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
 10524 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
 10525 |     | <span class='neutral'>            }</span>
 10526 |     | <span class='neutral'>            m0 := mload(0x00)</span>
 10527 |     | <span class='neutral'>            m1 := mload(0x20)</span>
 10528 |     | <span class='neutral'>            m2 := mload(0x40)</span>
 10529 |     | <span class='neutral'>            m3 := mload(0x60)</span>
 10530 |     | <span class='neutral'>            m4 := mload(0x80)</span>
 10531 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
 10532 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
 10533 |     | <span class='neutral'>            m7 := mload(0xe0)</span>
 10534 |     | <span class='neutral'>            m8 := mload(0x100)</span>
 10535 |     | <span class='neutral'>            // Selector of `log(uint256,string,string,address)`.</span>
 10536 |     | <span class='neutral'>            mstore(0x00, 0xd583c602)</span>
 10537 |     | <span class='neutral'>            mstore(0x20, p0)</span>
 10538 |     | <span class='neutral'>            mstore(0x40, 0x80)</span>
 10539 |     | <span class='neutral'>            mstore(0x60, 0xc0)</span>
 10540 |     | <span class='neutral'>            mstore(0x80, p3)</span>
 10541 |     | <span class='neutral'>            writeString(0xa0, p1)</span>
 10542 |     | <span class='neutral'>            writeString(0xe0, p2)</span>
 10543 |     | <span class='neutral'>        }</span>
 10544 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x104);</span>
 10545 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 10546 |     | <span class='neutral'>        assembly {</span>
 10547 |     | <span class='neutral'>            mstore(0x00, m0)</span>
 10548 |     | <span class='neutral'>            mstore(0x20, m1)</span>
 10549 |     | <span class='neutral'>            mstore(0x40, m2)</span>
 10550 |     | <span class='neutral'>            mstore(0x60, m3)</span>
 10551 |     | <span class='neutral'>            mstore(0x80, m4)</span>
 10552 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
 10553 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
 10554 |     | <span class='neutral'>            mstore(0xe0, m7)</span>
 10555 |     | <span class='neutral'>            mstore(0x100, m8)</span>
 10556 |     | <span class='neutral'>        }</span>
 10557 |     | <span class='neutral'>    }</span>
 10558 |     | <span class='neutral'></span>
 10559 |     | <span class='neutral'>    function log(uint256 p0, bytes32 p1, bytes32 p2, bool p3) internal pure {</span>
 10560 |     | <span class='neutral'>        bytes32 m0;</span>
 10561 |     | <span class='neutral'>        bytes32 m1;</span>
 10562 |     | <span class='neutral'>        bytes32 m2;</span>
 10563 |     | <span class='neutral'>        bytes32 m3;</span>
 10564 |     | <span class='neutral'>        bytes32 m4;</span>
 10565 |     | <span class='neutral'>        bytes32 m5;</span>
 10566 |     | <span class='neutral'>        bytes32 m6;</span>
 10567 |     | <span class='neutral'>        bytes32 m7;</span>
 10568 |     | <span class='neutral'>        bytes32 m8;</span>
 10569 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 10570 |     | <span class='neutral'>        assembly {</span>
 10571 |     | <span class='neutral'>            function writeString(pos, w) {</span>
 10572 |     | <span class='neutral'>                let length := 0</span>
 10573 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
 10574 |     | <span class='neutral'>                mstore(pos, length)</span>
 10575 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
 10576 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
 10577 |     | <span class='neutral'>            }</span>
 10578 |     | <span class='neutral'>            m0 := mload(0x00)</span>
 10579 |     | <span class='neutral'>            m1 := mload(0x20)</span>
 10580 |     | <span class='neutral'>            m2 := mload(0x40)</span>
 10581 |     | <span class='neutral'>            m3 := mload(0x60)</span>
 10582 |     | <span class='neutral'>            m4 := mload(0x80)</span>
 10583 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
 10584 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
 10585 |     | <span class='neutral'>            m7 := mload(0xe0)</span>
 10586 |     | <span class='neutral'>            m8 := mload(0x100)</span>
 10587 |     | <span class='neutral'>            // Selector of `log(uint256,string,string,bool)`.</span>
 10588 |     | <span class='neutral'>            mstore(0x00, 0xb3a6b6bd)</span>
 10589 |     | <span class='neutral'>            mstore(0x20, p0)</span>
 10590 |     | <span class='neutral'>            mstore(0x40, 0x80)</span>
 10591 |     | <span class='neutral'>            mstore(0x60, 0xc0)</span>
 10592 |     | <span class='neutral'>            mstore(0x80, p3)</span>
 10593 |     | <span class='neutral'>            writeString(0xa0, p1)</span>
 10594 |     | <span class='neutral'>            writeString(0xe0, p2)</span>
 10595 |     | <span class='neutral'>        }</span>
 10596 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x104);</span>
 10597 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 10598 |     | <span class='neutral'>        assembly {</span>
 10599 |     | <span class='neutral'>            mstore(0x00, m0)</span>
 10600 |     | <span class='neutral'>            mstore(0x20, m1)</span>
 10601 |     | <span class='neutral'>            mstore(0x40, m2)</span>
 10602 |     | <span class='neutral'>            mstore(0x60, m3)</span>
 10603 |     | <span class='neutral'>            mstore(0x80, m4)</span>
 10604 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
 10605 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
 10606 |     | <span class='neutral'>            mstore(0xe0, m7)</span>
 10607 |     | <span class='neutral'>            mstore(0x100, m8)</span>
 10608 |     | <span class='neutral'>        }</span>
 10609 |     | <span class='neutral'>    }</span>
 10610 |     | <span class='neutral'></span>
 10611 |     | <span class='neutral'>    function log(uint256 p0, bytes32 p1, bytes32 p2, uint256 p3) internal pure {</span>
 10612 |     | <span class='neutral'>        bytes32 m0;</span>
 10613 |     | <span class='neutral'>        bytes32 m1;</span>
 10614 |     | <span class='neutral'>        bytes32 m2;</span>
 10615 |     | <span class='neutral'>        bytes32 m3;</span>
 10616 |     | <span class='neutral'>        bytes32 m4;</span>
 10617 |     | <span class='neutral'>        bytes32 m5;</span>
 10618 |     | <span class='neutral'>        bytes32 m6;</span>
 10619 |     | <span class='neutral'>        bytes32 m7;</span>
 10620 |     | <span class='neutral'>        bytes32 m8;</span>
 10621 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 10622 |     | <span class='neutral'>        assembly {</span>
 10623 |     | <span class='neutral'>            function writeString(pos, w) {</span>
 10624 |     | <span class='neutral'>                let length := 0</span>
 10625 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
 10626 |     | <span class='neutral'>                mstore(pos, length)</span>
 10627 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
 10628 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
 10629 |     | <span class='neutral'>            }</span>
 10630 |     | <span class='neutral'>            m0 := mload(0x00)</span>
 10631 |     | <span class='neutral'>            m1 := mload(0x20)</span>
 10632 |     | <span class='neutral'>            m2 := mload(0x40)</span>
 10633 |     | <span class='neutral'>            m3 := mload(0x60)</span>
 10634 |     | <span class='neutral'>            m4 := mload(0x80)</span>
 10635 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
 10636 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
 10637 |     | <span class='neutral'>            m7 := mload(0xe0)</span>
 10638 |     | <span class='neutral'>            m8 := mload(0x100)</span>
 10639 |     | <span class='neutral'>            // Selector of `log(uint256,string,string,uint256)`.</span>
 10640 |     | <span class='neutral'>            mstore(0x00, 0xb028c9bd)</span>
 10641 |     | <span class='neutral'>            mstore(0x20, p0)</span>
 10642 |     | <span class='neutral'>            mstore(0x40, 0x80)</span>
 10643 |     | <span class='neutral'>            mstore(0x60, 0xc0)</span>
 10644 |     | <span class='neutral'>            mstore(0x80, p3)</span>
 10645 |     | <span class='neutral'>            writeString(0xa0, p1)</span>
 10646 |     | <span class='neutral'>            writeString(0xe0, p2)</span>
 10647 |     | <span class='neutral'>        }</span>
 10648 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x104);</span>
 10649 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 10650 |     | <span class='neutral'>        assembly {</span>
 10651 |     | <span class='neutral'>            mstore(0x00, m0)</span>
 10652 |     | <span class='neutral'>            mstore(0x20, m1)</span>
 10653 |     | <span class='neutral'>            mstore(0x40, m2)</span>
 10654 |     | <span class='neutral'>            mstore(0x60, m3)</span>
 10655 |     | <span class='neutral'>            mstore(0x80, m4)</span>
 10656 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
 10657 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
 10658 |     | <span class='neutral'>            mstore(0xe0, m7)</span>
 10659 |     | <span class='neutral'>            mstore(0x100, m8)</span>
 10660 |     | <span class='neutral'>        }</span>
 10661 |     | <span class='neutral'>    }</span>
 10662 |     | <span class='neutral'></span>
 10663 |     | <span class='neutral'>    function log(uint256 p0, bytes32 p1, bytes32 p2, bytes32 p3) internal pure {</span>
 10664 |     | <span class='neutral'>        bytes32 m0;</span>
 10665 |     | <span class='neutral'>        bytes32 m1;</span>
 10666 |     | <span class='neutral'>        bytes32 m2;</span>
 10667 |     | <span class='neutral'>        bytes32 m3;</span>
 10668 |     | <span class='neutral'>        bytes32 m4;</span>
 10669 |     | <span class='neutral'>        bytes32 m5;</span>
 10670 |     | <span class='neutral'>        bytes32 m6;</span>
 10671 |     | <span class='neutral'>        bytes32 m7;</span>
 10672 |     | <span class='neutral'>        bytes32 m8;</span>
 10673 |     | <span class='neutral'>        bytes32 m9;</span>
 10674 |     | <span class='neutral'>        bytes32 m10;</span>
 10675 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 10676 |     | <span class='neutral'>        assembly {</span>
 10677 |     | <span class='neutral'>            function writeString(pos, w) {</span>
 10678 |     | <span class='neutral'>                let length := 0</span>
 10679 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
 10680 |     | <span class='neutral'>                mstore(pos, length)</span>
 10681 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
 10682 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
 10683 |     | <span class='neutral'>            }</span>
 10684 |     | <span class='neutral'>            m0 := mload(0x00)</span>
 10685 |     | <span class='neutral'>            m1 := mload(0x20)</span>
 10686 |     | <span class='neutral'>            m2 := mload(0x40)</span>
 10687 |     | <span class='neutral'>            m3 := mload(0x60)</span>
 10688 |     | <span class='neutral'>            m4 := mload(0x80)</span>
 10689 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
 10690 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
 10691 |     | <span class='neutral'>            m7 := mload(0xe0)</span>
 10692 |     | <span class='neutral'>            m8 := mload(0x100)</span>
 10693 |     | <span class='neutral'>            m9 := mload(0x120)</span>
 10694 |     | <span class='neutral'>            m10 := mload(0x140)</span>
 10695 |     | <span class='neutral'>            // Selector of `log(uint256,string,string,string)`.</span>
 10696 |     | <span class='neutral'>            mstore(0x00, 0x21ad0683)</span>
 10697 |     | <span class='neutral'>            mstore(0x20, p0)</span>
 10698 |     | <span class='neutral'>            mstore(0x40, 0x80)</span>
 10699 |     | <span class='neutral'>            mstore(0x60, 0xc0)</span>
 10700 |     | <span class='neutral'>            mstore(0x80, 0x100)</span>
 10701 |     | <span class='neutral'>            writeString(0xa0, p1)</span>
 10702 |     | <span class='neutral'>            writeString(0xe0, p2)</span>
 10703 |     | <span class='neutral'>            writeString(0x120, p3)</span>
 10704 |     | <span class='neutral'>        }</span>
 10705 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x144);</span>
 10706 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 10707 |     | <span class='neutral'>        assembly {</span>
 10708 |     | <span class='neutral'>            mstore(0x00, m0)</span>
 10709 |     | <span class='neutral'>            mstore(0x20, m1)</span>
 10710 |     | <span class='neutral'>            mstore(0x40, m2)</span>
 10711 |     | <span class='neutral'>            mstore(0x60, m3)</span>
 10712 |     | <span class='neutral'>            mstore(0x80, m4)</span>
 10713 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
 10714 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
 10715 |     | <span class='neutral'>            mstore(0xe0, m7)</span>
 10716 |     | <span class='neutral'>            mstore(0x100, m8)</span>
 10717 |     | <span class='neutral'>            mstore(0x120, m9)</span>
 10718 |     | <span class='neutral'>            mstore(0x140, m10)</span>
 10719 |     | <span class='neutral'>        }</span>
 10720 |     | <span class='neutral'>    }</span>
 10721 |     | <span class='neutral'></span>
 10722 |     | <span class='neutral'>    function log(bytes32 p0, address p1, address p2, address p3) internal pure {</span>
 10723 |     | <span class='neutral'>        bytes32 m0;</span>
 10724 |     | <span class='neutral'>        bytes32 m1;</span>
 10725 |     | <span class='neutral'>        bytes32 m2;</span>
 10726 |     | <span class='neutral'>        bytes32 m3;</span>
 10727 |     | <span class='neutral'>        bytes32 m4;</span>
 10728 |     | <span class='neutral'>        bytes32 m5;</span>
 10729 |     | <span class='neutral'>        bytes32 m6;</span>
 10730 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 10731 |     | <span class='neutral'>        assembly {</span>
 10732 |     | <span class='neutral'>            function writeString(pos, w) {</span>
 10733 |     | <span class='neutral'>                let length := 0</span>
 10734 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
 10735 |     | <span class='neutral'>                mstore(pos, length)</span>
 10736 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
 10737 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
 10738 |     | <span class='neutral'>            }</span>
 10739 |     | <span class='neutral'>            m0 := mload(0x00)</span>
 10740 |     | <span class='neutral'>            m1 := mload(0x20)</span>
 10741 |     | <span class='neutral'>            m2 := mload(0x40)</span>
 10742 |     | <span class='neutral'>            m3 := mload(0x60)</span>
 10743 |     | <span class='neutral'>            m4 := mload(0x80)</span>
 10744 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
 10745 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
 10746 |     | <span class='neutral'>            // Selector of `log(string,address,address,address)`.</span>
 10747 |     | <span class='neutral'>            mstore(0x00, 0xed8f28f6)</span>
 10748 |     | <span class='neutral'>            mstore(0x20, 0x80)</span>
 10749 |     | <span class='neutral'>            mstore(0x40, p1)</span>
 10750 |     | <span class='neutral'>            mstore(0x60, p2)</span>
 10751 |     | <span class='neutral'>            mstore(0x80, p3)</span>
 10752 |     | <span class='neutral'>            writeString(0xa0, p0)</span>
 10753 |     | <span class='neutral'>        }</span>
 10754 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xc4);</span>
 10755 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 10756 |     | <span class='neutral'>        assembly {</span>
 10757 |     | <span class='neutral'>            mstore(0x00, m0)</span>
 10758 |     | <span class='neutral'>            mstore(0x20, m1)</span>
 10759 |     | <span class='neutral'>            mstore(0x40, m2)</span>
 10760 |     | <span class='neutral'>            mstore(0x60, m3)</span>
 10761 |     | <span class='neutral'>            mstore(0x80, m4)</span>
 10762 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
 10763 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
 10764 |     | <span class='neutral'>        }</span>
 10765 |     | <span class='neutral'>    }</span>
 10766 |     | <span class='neutral'></span>
 10767 |     | <span class='neutral'>    function log(bytes32 p0, address p1, address p2, bool p3) internal pure {</span>
 10768 |     | <span class='neutral'>        bytes32 m0;</span>
 10769 |     | <span class='neutral'>        bytes32 m1;</span>
 10770 |     | <span class='neutral'>        bytes32 m2;</span>
 10771 |     | <span class='neutral'>        bytes32 m3;</span>
 10772 |     | <span class='neutral'>        bytes32 m4;</span>
 10773 |     | <span class='neutral'>        bytes32 m5;</span>
 10774 |     | <span class='neutral'>        bytes32 m6;</span>
 10775 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 10776 |     | <span class='neutral'>        assembly {</span>
 10777 |     | <span class='neutral'>            function writeString(pos, w) {</span>
 10778 |     | <span class='neutral'>                let length := 0</span>
 10779 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
 10780 |     | <span class='neutral'>                mstore(pos, length)</span>
 10781 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
 10782 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
 10783 |     | <span class='neutral'>            }</span>
 10784 |     | <span class='neutral'>            m0 := mload(0x00)</span>
 10785 |     | <span class='neutral'>            m1 := mload(0x20)</span>
 10786 |     | <span class='neutral'>            m2 := mload(0x40)</span>
 10787 |     | <span class='neutral'>            m3 := mload(0x60)</span>
 10788 |     | <span class='neutral'>            m4 := mload(0x80)</span>
 10789 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
 10790 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
 10791 |     | <span class='neutral'>            // Selector of `log(string,address,address,bool)`.</span>
 10792 |     | <span class='neutral'>            mstore(0x00, 0xb59dbd60)</span>
 10793 |     | <span class='neutral'>            mstore(0x20, 0x80)</span>
 10794 |     | <span class='neutral'>            mstore(0x40, p1)</span>
 10795 |     | <span class='neutral'>            mstore(0x60, p2)</span>
 10796 |     | <span class='neutral'>            mstore(0x80, p3)</span>
 10797 |     | <span class='neutral'>            writeString(0xa0, p0)</span>
 10798 |     | <span class='neutral'>        }</span>
 10799 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xc4);</span>
 10800 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 10801 |     | <span class='neutral'>        assembly {</span>
 10802 |     | <span class='neutral'>            mstore(0x00, m0)</span>
 10803 |     | <span class='neutral'>            mstore(0x20, m1)</span>
 10804 |     | <span class='neutral'>            mstore(0x40, m2)</span>
 10805 |     | <span class='neutral'>            mstore(0x60, m3)</span>
 10806 |     | <span class='neutral'>            mstore(0x80, m4)</span>
 10807 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
 10808 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
 10809 |     | <span class='neutral'>        }</span>
 10810 |     | <span class='neutral'>    }</span>
 10811 |     | <span class='neutral'></span>
 10812 |     | <span class='neutral'>    function log(bytes32 p0, address p1, address p2, uint256 p3) internal pure {</span>
 10813 |     | <span class='neutral'>        bytes32 m0;</span>
 10814 |     | <span class='neutral'>        bytes32 m1;</span>
 10815 |     | <span class='neutral'>        bytes32 m2;</span>
 10816 |     | <span class='neutral'>        bytes32 m3;</span>
 10817 |     | <span class='neutral'>        bytes32 m4;</span>
 10818 |     | <span class='neutral'>        bytes32 m5;</span>
 10819 |     | <span class='neutral'>        bytes32 m6;</span>
 10820 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 10821 |     | <span class='neutral'>        assembly {</span>
 10822 |     | <span class='neutral'>            function writeString(pos, w) {</span>
 10823 |     | <span class='neutral'>                let length := 0</span>
 10824 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
 10825 |     | <span class='neutral'>                mstore(pos, length)</span>
 10826 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
 10827 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
 10828 |     | <span class='neutral'>            }</span>
 10829 |     | <span class='neutral'>            m0 := mload(0x00)</span>
 10830 |     | <span class='neutral'>            m1 := mload(0x20)</span>
 10831 |     | <span class='neutral'>            m2 := mload(0x40)</span>
 10832 |     | <span class='neutral'>            m3 := mload(0x60)</span>
 10833 |     | <span class='neutral'>            m4 := mload(0x80)</span>
 10834 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
 10835 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
 10836 |     | <span class='neutral'>            // Selector of `log(string,address,address,uint256)`.</span>
 10837 |     | <span class='neutral'>            mstore(0x00, 0x8ef3f399)</span>
 10838 |     | <span class='neutral'>            mstore(0x20, 0x80)</span>
 10839 |     | <span class='neutral'>            mstore(0x40, p1)</span>
 10840 |     | <span class='neutral'>            mstore(0x60, p2)</span>
 10841 |     | <span class='neutral'>            mstore(0x80, p3)</span>
 10842 |     | <span class='neutral'>            writeString(0xa0, p0)</span>
 10843 |     | <span class='neutral'>        }</span>
 10844 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xc4);</span>
 10845 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 10846 |     | <span class='neutral'>        assembly {</span>
 10847 |     | <span class='neutral'>            mstore(0x00, m0)</span>
 10848 |     | <span class='neutral'>            mstore(0x20, m1)</span>
 10849 |     | <span class='neutral'>            mstore(0x40, m2)</span>
 10850 |     | <span class='neutral'>            mstore(0x60, m3)</span>
 10851 |     | <span class='neutral'>            mstore(0x80, m4)</span>
 10852 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
 10853 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
 10854 |     | <span class='neutral'>        }</span>
 10855 |     | <span class='neutral'>    }</span>
 10856 |     | <span class='neutral'></span>
 10857 |     | <span class='neutral'>    function log(bytes32 p0, address p1, address p2, bytes32 p3) internal pure {</span>
 10858 |     | <span class='neutral'>        bytes32 m0;</span>
 10859 |     | <span class='neutral'>        bytes32 m1;</span>
 10860 |     | <span class='neutral'>        bytes32 m2;</span>
 10861 |     | <span class='neutral'>        bytes32 m3;</span>
 10862 |     | <span class='neutral'>        bytes32 m4;</span>
 10863 |     | <span class='neutral'>        bytes32 m5;</span>
 10864 |     | <span class='neutral'>        bytes32 m6;</span>
 10865 |     | <span class='neutral'>        bytes32 m7;</span>
 10866 |     | <span class='neutral'>        bytes32 m8;</span>
 10867 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 10868 |     | <span class='neutral'>        assembly {</span>
 10869 |     | <span class='neutral'>            function writeString(pos, w) {</span>
 10870 |     | <span class='neutral'>                let length := 0</span>
 10871 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
 10872 |     | <span class='neutral'>                mstore(pos, length)</span>
 10873 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
 10874 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
 10875 |     | <span class='neutral'>            }</span>
 10876 |     | <span class='neutral'>            m0 := mload(0x00)</span>
 10877 |     | <span class='neutral'>            m1 := mload(0x20)</span>
 10878 |     | <span class='neutral'>            m2 := mload(0x40)</span>
 10879 |     | <span class='neutral'>            m3 := mload(0x60)</span>
 10880 |     | <span class='neutral'>            m4 := mload(0x80)</span>
 10881 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
 10882 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
 10883 |     | <span class='neutral'>            m7 := mload(0xe0)</span>
 10884 |     | <span class='neutral'>            m8 := mload(0x100)</span>
 10885 |     | <span class='neutral'>            // Selector of `log(string,address,address,string)`.</span>
 10886 |     | <span class='neutral'>            mstore(0x00, 0x800a1c67)</span>
 10887 |     | <span class='neutral'>            mstore(0x20, 0x80)</span>
 10888 |     | <span class='neutral'>            mstore(0x40, p1)</span>
 10889 |     | <span class='neutral'>            mstore(0x60, p2)</span>
 10890 |     | <span class='neutral'>            mstore(0x80, 0xc0)</span>
 10891 |     | <span class='neutral'>            writeString(0xa0, p0)</span>
 10892 |     | <span class='neutral'>            writeString(0xe0, p3)</span>
 10893 |     | <span class='neutral'>        }</span>
 10894 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x104);</span>
 10895 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 10896 |     | <span class='neutral'>        assembly {</span>
 10897 |     | <span class='neutral'>            mstore(0x00, m0)</span>
 10898 |     | <span class='neutral'>            mstore(0x20, m1)</span>
 10899 |     | <span class='neutral'>            mstore(0x40, m2)</span>
 10900 |     | <span class='neutral'>            mstore(0x60, m3)</span>
 10901 |     | <span class='neutral'>            mstore(0x80, m4)</span>
 10902 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
 10903 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
 10904 |     | <span class='neutral'>            mstore(0xe0, m7)</span>
 10905 |     | <span class='neutral'>            mstore(0x100, m8)</span>
 10906 |     | <span class='neutral'>        }</span>
 10907 |     | <span class='neutral'>    }</span>
 10908 |     | <span class='neutral'></span>
 10909 |     | <span class='neutral'>    function log(bytes32 p0, address p1, bool p2, address p3) internal pure {</span>
 10910 |     | <span class='neutral'>        bytes32 m0;</span>
 10911 |     | <span class='neutral'>        bytes32 m1;</span>
 10912 |     | <span class='neutral'>        bytes32 m2;</span>
 10913 |     | <span class='neutral'>        bytes32 m3;</span>
 10914 |     | <span class='neutral'>        bytes32 m4;</span>
 10915 |     | <span class='neutral'>        bytes32 m5;</span>
 10916 |     | <span class='neutral'>        bytes32 m6;</span>
 10917 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 10918 |     | <span class='neutral'>        assembly {</span>
 10919 |     | <span class='neutral'>            function writeString(pos, w) {</span>
 10920 |     | <span class='neutral'>                let length := 0</span>
 10921 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
 10922 |     | <span class='neutral'>                mstore(pos, length)</span>
 10923 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
 10924 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
 10925 |     | <span class='neutral'>            }</span>
 10926 |     | <span class='neutral'>            m0 := mload(0x00)</span>
 10927 |     | <span class='neutral'>            m1 := mload(0x20)</span>
 10928 |     | <span class='neutral'>            m2 := mload(0x40)</span>
 10929 |     | <span class='neutral'>            m3 := mload(0x60)</span>
 10930 |     | <span class='neutral'>            m4 := mload(0x80)</span>
 10931 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
 10932 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
 10933 |     | <span class='neutral'>            // Selector of `log(string,address,bool,address)`.</span>
 10934 |     | <span class='neutral'>            mstore(0x00, 0x223603bd)</span>
 10935 |     | <span class='neutral'>            mstore(0x20, 0x80)</span>
 10936 |     | <span class='neutral'>            mstore(0x40, p1)</span>
 10937 |     | <span class='neutral'>            mstore(0x60, p2)</span>
 10938 |     | <span class='neutral'>            mstore(0x80, p3)</span>
 10939 |     | <span class='neutral'>            writeString(0xa0, p0)</span>
 10940 |     | <span class='neutral'>        }</span>
 10941 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xc4);</span>
 10942 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 10943 |     | <span class='neutral'>        assembly {</span>
 10944 |     | <span class='neutral'>            mstore(0x00, m0)</span>
 10945 |     | <span class='neutral'>            mstore(0x20, m1)</span>
 10946 |     | <span class='neutral'>            mstore(0x40, m2)</span>
 10947 |     | <span class='neutral'>            mstore(0x60, m3)</span>
 10948 |     | <span class='neutral'>            mstore(0x80, m4)</span>
 10949 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
 10950 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
 10951 |     | <span class='neutral'>        }</span>
 10952 |     | <span class='neutral'>    }</span>
 10953 |     | <span class='neutral'></span>
 10954 |     | <span class='neutral'>    function log(bytes32 p0, address p1, bool p2, bool p3) internal pure {</span>
 10955 |     | <span class='neutral'>        bytes32 m0;</span>
 10956 |     | <span class='neutral'>        bytes32 m1;</span>
 10957 |     | <span class='neutral'>        bytes32 m2;</span>
 10958 |     | <span class='neutral'>        bytes32 m3;</span>
 10959 |     | <span class='neutral'>        bytes32 m4;</span>
 10960 |     | <span class='neutral'>        bytes32 m5;</span>
 10961 |     | <span class='neutral'>        bytes32 m6;</span>
 10962 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 10963 |     | <span class='neutral'>        assembly {</span>
 10964 |     | <span class='neutral'>            function writeString(pos, w) {</span>
 10965 |     | <span class='neutral'>                let length := 0</span>
 10966 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
 10967 |     | <span class='neutral'>                mstore(pos, length)</span>
 10968 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
 10969 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
 10970 |     | <span class='neutral'>            }</span>
 10971 |     | <span class='neutral'>            m0 := mload(0x00)</span>
 10972 |     | <span class='neutral'>            m1 := mload(0x20)</span>
 10973 |     | <span class='neutral'>            m2 := mload(0x40)</span>
 10974 |     | <span class='neutral'>            m3 := mload(0x60)</span>
 10975 |     | <span class='neutral'>            m4 := mload(0x80)</span>
 10976 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
 10977 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
 10978 |     | <span class='neutral'>            // Selector of `log(string,address,bool,bool)`.</span>
 10979 |     | <span class='neutral'>            mstore(0x00, 0x79884c2b)</span>
 10980 |     | <span class='neutral'>            mstore(0x20, 0x80)</span>
 10981 |     | <span class='neutral'>            mstore(0x40, p1)</span>
 10982 |     | <span class='neutral'>            mstore(0x60, p2)</span>
 10983 |     | <span class='neutral'>            mstore(0x80, p3)</span>
 10984 |     | <span class='neutral'>            writeString(0xa0, p0)</span>
 10985 |     | <span class='neutral'>        }</span>
 10986 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xc4);</span>
 10987 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 10988 |     | <span class='neutral'>        assembly {</span>
 10989 |     | <span class='neutral'>            mstore(0x00, m0)</span>
 10990 |     | <span class='neutral'>            mstore(0x20, m1)</span>
 10991 |     | <span class='neutral'>            mstore(0x40, m2)</span>
 10992 |     | <span class='neutral'>            mstore(0x60, m3)</span>
 10993 |     | <span class='neutral'>            mstore(0x80, m4)</span>
 10994 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
 10995 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
 10996 |     | <span class='neutral'>        }</span>
 10997 |     | <span class='neutral'>    }</span>
 10998 |     | <span class='neutral'></span>
 10999 |     | <span class='neutral'>    function log(bytes32 p0, address p1, bool p2, uint256 p3) internal pure {</span>
 11000 |     | <span class='neutral'>        bytes32 m0;</span>
 11001 |     | <span class='neutral'>        bytes32 m1;</span>
 11002 |     | <span class='neutral'>        bytes32 m2;</span>
 11003 |     | <span class='neutral'>        bytes32 m3;</span>
 11004 |     | <span class='neutral'>        bytes32 m4;</span>
 11005 |     | <span class='neutral'>        bytes32 m5;</span>
 11006 |     | <span class='neutral'>        bytes32 m6;</span>
 11007 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 11008 |     | <span class='neutral'>        assembly {</span>
 11009 |     | <span class='neutral'>            function writeString(pos, w) {</span>
 11010 |     | <span class='neutral'>                let length := 0</span>
 11011 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
 11012 |     | <span class='neutral'>                mstore(pos, length)</span>
 11013 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
 11014 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
 11015 |     | <span class='neutral'>            }</span>
 11016 |     | <span class='neutral'>            m0 := mload(0x00)</span>
 11017 |     | <span class='neutral'>            m1 := mload(0x20)</span>
 11018 |     | <span class='neutral'>            m2 := mload(0x40)</span>
 11019 |     | <span class='neutral'>            m3 := mload(0x60)</span>
 11020 |     | <span class='neutral'>            m4 := mload(0x80)</span>
 11021 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
 11022 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
 11023 |     | <span class='neutral'>            // Selector of `log(string,address,bool,uint256)`.</span>
 11024 |     | <span class='neutral'>            mstore(0x00, 0x3e9f866a)</span>
 11025 |     | <span class='neutral'>            mstore(0x20, 0x80)</span>
 11026 |     | <span class='neutral'>            mstore(0x40, p1)</span>
 11027 |     | <span class='neutral'>            mstore(0x60, p2)</span>
 11028 |     | <span class='neutral'>            mstore(0x80, p3)</span>
 11029 |     | <span class='neutral'>            writeString(0xa0, p0)</span>
 11030 |     | <span class='neutral'>        }</span>
 11031 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xc4);</span>
 11032 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 11033 |     | <span class='neutral'>        assembly {</span>
 11034 |     | <span class='neutral'>            mstore(0x00, m0)</span>
 11035 |     | <span class='neutral'>            mstore(0x20, m1)</span>
 11036 |     | <span class='neutral'>            mstore(0x40, m2)</span>
 11037 |     | <span class='neutral'>            mstore(0x60, m3)</span>
 11038 |     | <span class='neutral'>            mstore(0x80, m4)</span>
 11039 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
 11040 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
 11041 |     | <span class='neutral'>        }</span>
 11042 |     | <span class='neutral'>    }</span>
 11043 |     | <span class='neutral'></span>
 11044 |     | <span class='neutral'>    function log(bytes32 p0, address p1, bool p2, bytes32 p3) internal pure {</span>
 11045 |     | <span class='neutral'>        bytes32 m0;</span>
 11046 |     | <span class='neutral'>        bytes32 m1;</span>
 11047 |     | <span class='neutral'>        bytes32 m2;</span>
 11048 |     | <span class='neutral'>        bytes32 m3;</span>
 11049 |     | <span class='neutral'>        bytes32 m4;</span>
 11050 |     | <span class='neutral'>        bytes32 m5;</span>
 11051 |     | <span class='neutral'>        bytes32 m6;</span>
 11052 |     | <span class='neutral'>        bytes32 m7;</span>
 11053 |     | <span class='neutral'>        bytes32 m8;</span>
 11054 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 11055 |     | <span class='neutral'>        assembly {</span>
 11056 |     | <span class='neutral'>            function writeString(pos, w) {</span>
 11057 |     | <span class='neutral'>                let length := 0</span>
 11058 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
 11059 |     | <span class='neutral'>                mstore(pos, length)</span>
 11060 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
 11061 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
 11062 |     | <span class='neutral'>            }</span>
 11063 |     | <span class='neutral'>            m0 := mload(0x00)</span>
 11064 |     | <span class='neutral'>            m1 := mload(0x20)</span>
 11065 |     | <span class='neutral'>            m2 := mload(0x40)</span>
 11066 |     | <span class='neutral'>            m3 := mload(0x60)</span>
 11067 |     | <span class='neutral'>            m4 := mload(0x80)</span>
 11068 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
 11069 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
 11070 |     | <span class='neutral'>            m7 := mload(0xe0)</span>
 11071 |     | <span class='neutral'>            m8 := mload(0x100)</span>
 11072 |     | <span class='neutral'>            // Selector of `log(string,address,bool,string)`.</span>
 11073 |     | <span class='neutral'>            mstore(0x00, 0x0454c079)</span>
 11074 |     | <span class='neutral'>            mstore(0x20, 0x80)</span>
 11075 |     | <span class='neutral'>            mstore(0x40, p1)</span>
 11076 |     | <span class='neutral'>            mstore(0x60, p2)</span>
 11077 |     | <span class='neutral'>            mstore(0x80, 0xc0)</span>
 11078 |     | <span class='neutral'>            writeString(0xa0, p0)</span>
 11079 |     | <span class='neutral'>            writeString(0xe0, p3)</span>
 11080 |     | <span class='neutral'>        }</span>
 11081 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x104);</span>
 11082 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 11083 |     | <span class='neutral'>        assembly {</span>
 11084 |     | <span class='neutral'>            mstore(0x00, m0)</span>
 11085 |     | <span class='neutral'>            mstore(0x20, m1)</span>
 11086 |     | <span class='neutral'>            mstore(0x40, m2)</span>
 11087 |     | <span class='neutral'>            mstore(0x60, m3)</span>
 11088 |     | <span class='neutral'>            mstore(0x80, m4)</span>
 11089 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
 11090 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
 11091 |     | <span class='neutral'>            mstore(0xe0, m7)</span>
 11092 |     | <span class='neutral'>            mstore(0x100, m8)</span>
 11093 |     | <span class='neutral'>        }</span>
 11094 |     | <span class='neutral'>    }</span>
 11095 |     | <span class='neutral'></span>
 11096 |     | <span class='neutral'>    function log(bytes32 p0, address p1, uint256 p2, address p3) internal pure {</span>
 11097 |     | <span class='neutral'>        bytes32 m0;</span>
 11098 |     | <span class='neutral'>        bytes32 m1;</span>
 11099 |     | <span class='neutral'>        bytes32 m2;</span>
 11100 |     | <span class='neutral'>        bytes32 m3;</span>
 11101 |     | <span class='neutral'>        bytes32 m4;</span>
 11102 |     | <span class='neutral'>        bytes32 m5;</span>
 11103 |     | <span class='neutral'>        bytes32 m6;</span>
 11104 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 11105 |     | <span class='neutral'>        assembly {</span>
 11106 |     | <span class='neutral'>            function writeString(pos, w) {</span>
 11107 |     | <span class='neutral'>                let length := 0</span>
 11108 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
 11109 |     | <span class='neutral'>                mstore(pos, length)</span>
 11110 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
 11111 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
 11112 |     | <span class='neutral'>            }</span>
 11113 |     | <span class='neutral'>            m0 := mload(0x00)</span>
 11114 |     | <span class='neutral'>            m1 := mload(0x20)</span>
 11115 |     | <span class='neutral'>            m2 := mload(0x40)</span>
 11116 |     | <span class='neutral'>            m3 := mload(0x60)</span>
 11117 |     | <span class='neutral'>            m4 := mload(0x80)</span>
 11118 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
 11119 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
 11120 |     | <span class='neutral'>            // Selector of `log(string,address,uint256,address)`.</span>
 11121 |     | <span class='neutral'>            mstore(0x00, 0x63fb8bc5)</span>
 11122 |     | <span class='neutral'>            mstore(0x20, 0x80)</span>
 11123 |     | <span class='neutral'>            mstore(0x40, p1)</span>
 11124 |     | <span class='neutral'>            mstore(0x60, p2)</span>
 11125 |     | <span class='neutral'>            mstore(0x80, p3)</span>
 11126 |     | <span class='neutral'>            writeString(0xa0, p0)</span>
 11127 |     | <span class='neutral'>        }</span>
 11128 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xc4);</span>
 11129 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 11130 |     | <span class='neutral'>        assembly {</span>
 11131 |     | <span class='neutral'>            mstore(0x00, m0)</span>
 11132 |     | <span class='neutral'>            mstore(0x20, m1)</span>
 11133 |     | <span class='neutral'>            mstore(0x40, m2)</span>
 11134 |     | <span class='neutral'>            mstore(0x60, m3)</span>
 11135 |     | <span class='neutral'>            mstore(0x80, m4)</span>
 11136 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
 11137 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
 11138 |     | <span class='neutral'>        }</span>
 11139 |     | <span class='neutral'>    }</span>
 11140 |     | <span class='neutral'></span>
 11141 |     | <span class='neutral'>    function log(bytes32 p0, address p1, uint256 p2, bool p3) internal pure {</span>
 11142 |     | <span class='neutral'>        bytes32 m0;</span>
 11143 |     | <span class='neutral'>        bytes32 m1;</span>
 11144 |     | <span class='neutral'>        bytes32 m2;</span>
 11145 |     | <span class='neutral'>        bytes32 m3;</span>
 11146 |     | <span class='neutral'>        bytes32 m4;</span>
 11147 |     | <span class='neutral'>        bytes32 m5;</span>
 11148 |     | <span class='neutral'>        bytes32 m6;</span>
 11149 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 11150 |     | <span class='neutral'>        assembly {</span>
 11151 |     | <span class='neutral'>            function writeString(pos, w) {</span>
 11152 |     | <span class='neutral'>                let length := 0</span>
 11153 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
 11154 |     | <span class='neutral'>                mstore(pos, length)</span>
 11155 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
 11156 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
 11157 |     | <span class='neutral'>            }</span>
 11158 |     | <span class='neutral'>            m0 := mload(0x00)</span>
 11159 |     | <span class='neutral'>            m1 := mload(0x20)</span>
 11160 |     | <span class='neutral'>            m2 := mload(0x40)</span>
 11161 |     | <span class='neutral'>            m3 := mload(0x60)</span>
 11162 |     | <span class='neutral'>            m4 := mload(0x80)</span>
 11163 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
 11164 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
 11165 |     | <span class='neutral'>            // Selector of `log(string,address,uint256,bool)`.</span>
 11166 |     | <span class='neutral'>            mstore(0x00, 0xfc4845f0)</span>
 11167 |     | <span class='neutral'>            mstore(0x20, 0x80)</span>
 11168 |     | <span class='neutral'>            mstore(0x40, p1)</span>
 11169 |     | <span class='neutral'>            mstore(0x60, p2)</span>
 11170 |     | <span class='neutral'>            mstore(0x80, p3)</span>
 11171 |     | <span class='neutral'>            writeString(0xa0, p0)</span>
 11172 |     | <span class='neutral'>        }</span>
 11173 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xc4);</span>
 11174 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 11175 |     | <span class='neutral'>        assembly {</span>
 11176 |     | <span class='neutral'>            mstore(0x00, m0)</span>
 11177 |     | <span class='neutral'>            mstore(0x20, m1)</span>
 11178 |     | <span class='neutral'>            mstore(0x40, m2)</span>
 11179 |     | <span class='neutral'>            mstore(0x60, m3)</span>
 11180 |     | <span class='neutral'>            mstore(0x80, m4)</span>
 11181 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
 11182 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
 11183 |     | <span class='neutral'>        }</span>
 11184 |     | <span class='neutral'>    }</span>
 11185 |     | <span class='neutral'></span>
 11186 |     | <span class='neutral'>    function log(bytes32 p0, address p1, uint256 p2, uint256 p3) internal pure {</span>
 11187 |     | <span class='neutral'>        bytes32 m0;</span>
 11188 |     | <span class='neutral'>        bytes32 m1;</span>
 11189 |     | <span class='neutral'>        bytes32 m2;</span>
 11190 |     | <span class='neutral'>        bytes32 m3;</span>
 11191 |     | <span class='neutral'>        bytes32 m4;</span>
 11192 |     | <span class='neutral'>        bytes32 m5;</span>
 11193 |     | <span class='neutral'>        bytes32 m6;</span>
 11194 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 11195 |     | <span class='neutral'>        assembly {</span>
 11196 |     | <span class='neutral'>            function writeString(pos, w) {</span>
 11197 |     | <span class='neutral'>                let length := 0</span>
 11198 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
 11199 |     | <span class='neutral'>                mstore(pos, length)</span>
 11200 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
 11201 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
 11202 |     | <span class='neutral'>            }</span>
 11203 |     | <span class='neutral'>            m0 := mload(0x00)</span>
 11204 |     | <span class='neutral'>            m1 := mload(0x20)</span>
 11205 |     | <span class='neutral'>            m2 := mload(0x40)</span>
 11206 |     | <span class='neutral'>            m3 := mload(0x60)</span>
 11207 |     | <span class='neutral'>            m4 := mload(0x80)</span>
 11208 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
 11209 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
 11210 |     | <span class='neutral'>            // Selector of `log(string,address,uint256,uint256)`.</span>
 11211 |     | <span class='neutral'>            mstore(0x00, 0xf8f51b1e)</span>
 11212 |     | <span class='neutral'>            mstore(0x20, 0x80)</span>
 11213 |     | <span class='neutral'>            mstore(0x40, p1)</span>
 11214 |     | <span class='neutral'>            mstore(0x60, p2)</span>
 11215 |     | <span class='neutral'>            mstore(0x80, p3)</span>
 11216 |     | <span class='neutral'>            writeString(0xa0, p0)</span>
 11217 |     | <span class='neutral'>        }</span>
 11218 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xc4);</span>
 11219 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 11220 |     | <span class='neutral'>        assembly {</span>
 11221 |     | <span class='neutral'>            mstore(0x00, m0)</span>
 11222 |     | <span class='neutral'>            mstore(0x20, m1)</span>
 11223 |     | <span class='neutral'>            mstore(0x40, m2)</span>
 11224 |     | <span class='neutral'>            mstore(0x60, m3)</span>
 11225 |     | <span class='neutral'>            mstore(0x80, m4)</span>
 11226 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
 11227 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
 11228 |     | <span class='neutral'>        }</span>
 11229 |     | <span class='neutral'>    }</span>
 11230 |     | <span class='neutral'></span>
 11231 |     | <span class='neutral'>    function log(bytes32 p0, address p1, uint256 p2, bytes32 p3) internal pure {</span>
 11232 |     | <span class='neutral'>        bytes32 m0;</span>
 11233 |     | <span class='neutral'>        bytes32 m1;</span>
 11234 |     | <span class='neutral'>        bytes32 m2;</span>
 11235 |     | <span class='neutral'>        bytes32 m3;</span>
 11236 |     | <span class='neutral'>        bytes32 m4;</span>
 11237 |     | <span class='neutral'>        bytes32 m5;</span>
 11238 |     | <span class='neutral'>        bytes32 m6;</span>
 11239 |     | <span class='neutral'>        bytes32 m7;</span>
 11240 |     | <span class='neutral'>        bytes32 m8;</span>
 11241 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 11242 |     | <span class='neutral'>        assembly {</span>
 11243 |     | <span class='neutral'>            function writeString(pos, w) {</span>
 11244 |     | <span class='neutral'>                let length := 0</span>
 11245 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
 11246 |     | <span class='neutral'>                mstore(pos, length)</span>
 11247 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
 11248 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
 11249 |     | <span class='neutral'>            }</span>
 11250 |     | <span class='neutral'>            m0 := mload(0x00)</span>
 11251 |     | <span class='neutral'>            m1 := mload(0x20)</span>
 11252 |     | <span class='neutral'>            m2 := mload(0x40)</span>
 11253 |     | <span class='neutral'>            m3 := mload(0x60)</span>
 11254 |     | <span class='neutral'>            m4 := mload(0x80)</span>
 11255 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
 11256 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
 11257 |     | <span class='neutral'>            m7 := mload(0xe0)</span>
 11258 |     | <span class='neutral'>            m8 := mload(0x100)</span>
 11259 |     | <span class='neutral'>            // Selector of `log(string,address,uint256,string)`.</span>
 11260 |     | <span class='neutral'>            mstore(0x00, 0x5a477632)</span>
 11261 |     | <span class='neutral'>            mstore(0x20, 0x80)</span>
 11262 |     | <span class='neutral'>            mstore(0x40, p1)</span>
 11263 |     | <span class='neutral'>            mstore(0x60, p2)</span>
 11264 |     | <span class='neutral'>            mstore(0x80, 0xc0)</span>
 11265 |     | <span class='neutral'>            writeString(0xa0, p0)</span>
 11266 |     | <span class='neutral'>            writeString(0xe0, p3)</span>
 11267 |     | <span class='neutral'>        }</span>
 11268 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x104);</span>
 11269 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 11270 |     | <span class='neutral'>        assembly {</span>
 11271 |     | <span class='neutral'>            mstore(0x00, m0)</span>
 11272 |     | <span class='neutral'>            mstore(0x20, m1)</span>
 11273 |     | <span class='neutral'>            mstore(0x40, m2)</span>
 11274 |     | <span class='neutral'>            mstore(0x60, m3)</span>
 11275 |     | <span class='neutral'>            mstore(0x80, m4)</span>
 11276 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
 11277 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
 11278 |     | <span class='neutral'>            mstore(0xe0, m7)</span>
 11279 |     | <span class='neutral'>            mstore(0x100, m8)</span>
 11280 |     | <span class='neutral'>        }</span>
 11281 |     | <span class='neutral'>    }</span>
 11282 |     | <span class='neutral'></span>
 11283 |     | <span class='neutral'>    function log(bytes32 p0, address p1, bytes32 p2, address p3) internal pure {</span>
 11284 |     | <span class='neutral'>        bytes32 m0;</span>
 11285 |     | <span class='neutral'>        bytes32 m1;</span>
 11286 |     | <span class='neutral'>        bytes32 m2;</span>
 11287 |     | <span class='neutral'>        bytes32 m3;</span>
 11288 |     | <span class='neutral'>        bytes32 m4;</span>
 11289 |     | <span class='neutral'>        bytes32 m5;</span>
 11290 |     | <span class='neutral'>        bytes32 m6;</span>
 11291 |     | <span class='neutral'>        bytes32 m7;</span>
 11292 |     | <span class='neutral'>        bytes32 m8;</span>
 11293 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 11294 |     | <span class='neutral'>        assembly {</span>
 11295 |     | <span class='neutral'>            function writeString(pos, w) {</span>
 11296 |     | <span class='neutral'>                let length := 0</span>
 11297 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
 11298 |     | <span class='neutral'>                mstore(pos, length)</span>
 11299 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
 11300 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
 11301 |     | <span class='neutral'>            }</span>
 11302 |     | <span class='neutral'>            m0 := mload(0x00)</span>
 11303 |     | <span class='neutral'>            m1 := mload(0x20)</span>
 11304 |     | <span class='neutral'>            m2 := mload(0x40)</span>
 11305 |     | <span class='neutral'>            m3 := mload(0x60)</span>
 11306 |     | <span class='neutral'>            m4 := mload(0x80)</span>
 11307 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
 11308 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
 11309 |     | <span class='neutral'>            m7 := mload(0xe0)</span>
 11310 |     | <span class='neutral'>            m8 := mload(0x100)</span>
 11311 |     | <span class='neutral'>            // Selector of `log(string,address,string,address)`.</span>
 11312 |     | <span class='neutral'>            mstore(0x00, 0xaabc9a31)</span>
 11313 |     | <span class='neutral'>            mstore(0x20, 0x80)</span>
 11314 |     | <span class='neutral'>            mstore(0x40, p1)</span>
 11315 |     | <span class='neutral'>            mstore(0x60, 0xc0)</span>
 11316 |     | <span class='neutral'>            mstore(0x80, p3)</span>
 11317 |     | <span class='neutral'>            writeString(0xa0, p0)</span>
 11318 |     | <span class='neutral'>            writeString(0xe0, p2)</span>
 11319 |     | <span class='neutral'>        }</span>
 11320 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x104);</span>
 11321 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 11322 |     | <span class='neutral'>        assembly {</span>
 11323 |     | <span class='neutral'>            mstore(0x00, m0)</span>
 11324 |     | <span class='neutral'>            mstore(0x20, m1)</span>
 11325 |     | <span class='neutral'>            mstore(0x40, m2)</span>
 11326 |     | <span class='neutral'>            mstore(0x60, m3)</span>
 11327 |     | <span class='neutral'>            mstore(0x80, m4)</span>
 11328 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
 11329 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
 11330 |     | <span class='neutral'>            mstore(0xe0, m7)</span>
 11331 |     | <span class='neutral'>            mstore(0x100, m8)</span>
 11332 |     | <span class='neutral'>        }</span>
 11333 |     | <span class='neutral'>    }</span>
 11334 |     | <span class='neutral'></span>
 11335 |     | <span class='neutral'>    function log(bytes32 p0, address p1, bytes32 p2, bool p3) internal pure {</span>
 11336 |     | <span class='neutral'>        bytes32 m0;</span>
 11337 |     | <span class='neutral'>        bytes32 m1;</span>
 11338 |     | <span class='neutral'>        bytes32 m2;</span>
 11339 |     | <span class='neutral'>        bytes32 m3;</span>
 11340 |     | <span class='neutral'>        bytes32 m4;</span>
 11341 |     | <span class='neutral'>        bytes32 m5;</span>
 11342 |     | <span class='neutral'>        bytes32 m6;</span>
 11343 |     | <span class='neutral'>        bytes32 m7;</span>
 11344 |     | <span class='neutral'>        bytes32 m8;</span>
 11345 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 11346 |     | <span class='neutral'>        assembly {</span>
 11347 |     | <span class='neutral'>            function writeString(pos, w) {</span>
 11348 |     | <span class='neutral'>                let length := 0</span>
 11349 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
 11350 |     | <span class='neutral'>                mstore(pos, length)</span>
 11351 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
 11352 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
 11353 |     | <span class='neutral'>            }</span>
 11354 |     | <span class='neutral'>            m0 := mload(0x00)</span>
 11355 |     | <span class='neutral'>            m1 := mload(0x20)</span>
 11356 |     | <span class='neutral'>            m2 := mload(0x40)</span>
 11357 |     | <span class='neutral'>            m3 := mload(0x60)</span>
 11358 |     | <span class='neutral'>            m4 := mload(0x80)</span>
 11359 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
 11360 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
 11361 |     | <span class='neutral'>            m7 := mload(0xe0)</span>
 11362 |     | <span class='neutral'>            m8 := mload(0x100)</span>
 11363 |     | <span class='neutral'>            // Selector of `log(string,address,string,bool)`.</span>
 11364 |     | <span class='neutral'>            mstore(0x00, 0x5f15d28c)</span>
 11365 |     | <span class='neutral'>            mstore(0x20, 0x80)</span>
 11366 |     | <span class='neutral'>            mstore(0x40, p1)</span>
 11367 |     | <span class='neutral'>            mstore(0x60, 0xc0)</span>
 11368 |     | <span class='neutral'>            mstore(0x80, p3)</span>
 11369 |     | <span class='neutral'>            writeString(0xa0, p0)</span>
 11370 |     | <span class='neutral'>            writeString(0xe0, p2)</span>
 11371 |     | <span class='neutral'>        }</span>
 11372 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x104);</span>
 11373 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 11374 |     | <span class='neutral'>        assembly {</span>
 11375 |     | <span class='neutral'>            mstore(0x00, m0)</span>
 11376 |     | <span class='neutral'>            mstore(0x20, m1)</span>
 11377 |     | <span class='neutral'>            mstore(0x40, m2)</span>
 11378 |     | <span class='neutral'>            mstore(0x60, m3)</span>
 11379 |     | <span class='neutral'>            mstore(0x80, m4)</span>
 11380 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
 11381 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
 11382 |     | <span class='neutral'>            mstore(0xe0, m7)</span>
 11383 |     | <span class='neutral'>            mstore(0x100, m8)</span>
 11384 |     | <span class='neutral'>        }</span>
 11385 |     | <span class='neutral'>    }</span>
 11386 |     | <span class='neutral'></span>
 11387 |     | <span class='neutral'>    function log(bytes32 p0, address p1, bytes32 p2, uint256 p3) internal pure {</span>
 11388 |     | <span class='neutral'>        bytes32 m0;</span>
 11389 |     | <span class='neutral'>        bytes32 m1;</span>
 11390 |     | <span class='neutral'>        bytes32 m2;</span>
 11391 |     | <span class='neutral'>        bytes32 m3;</span>
 11392 |     | <span class='neutral'>        bytes32 m4;</span>
 11393 |     | <span class='neutral'>        bytes32 m5;</span>
 11394 |     | <span class='neutral'>        bytes32 m6;</span>
 11395 |     | <span class='neutral'>        bytes32 m7;</span>
 11396 |     | <span class='neutral'>        bytes32 m8;</span>
 11397 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 11398 |     | <span class='neutral'>        assembly {</span>
 11399 |     | <span class='neutral'>            function writeString(pos, w) {</span>
 11400 |     | <span class='neutral'>                let length := 0</span>
 11401 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
 11402 |     | <span class='neutral'>                mstore(pos, length)</span>
 11403 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
 11404 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
 11405 |     | <span class='neutral'>            }</span>
 11406 |     | <span class='neutral'>            m0 := mload(0x00)</span>
 11407 |     | <span class='neutral'>            m1 := mload(0x20)</span>
 11408 |     | <span class='neutral'>            m2 := mload(0x40)</span>
 11409 |     | <span class='neutral'>            m3 := mload(0x60)</span>
 11410 |     | <span class='neutral'>            m4 := mload(0x80)</span>
 11411 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
 11412 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
 11413 |     | <span class='neutral'>            m7 := mload(0xe0)</span>
 11414 |     | <span class='neutral'>            m8 := mload(0x100)</span>
 11415 |     | <span class='neutral'>            // Selector of `log(string,address,string,uint256)`.</span>
 11416 |     | <span class='neutral'>            mstore(0x00, 0x91d1112e)</span>
 11417 |     | <span class='neutral'>            mstore(0x20, 0x80)</span>
 11418 |     | <span class='neutral'>            mstore(0x40, p1)</span>
 11419 |     | <span class='neutral'>            mstore(0x60, 0xc0)</span>
 11420 |     | <span class='neutral'>            mstore(0x80, p3)</span>
 11421 |     | <span class='neutral'>            writeString(0xa0, p0)</span>
 11422 |     | <span class='neutral'>            writeString(0xe0, p2)</span>
 11423 |     | <span class='neutral'>        }</span>
 11424 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x104);</span>
 11425 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 11426 |     | <span class='neutral'>        assembly {</span>
 11427 |     | <span class='neutral'>            mstore(0x00, m0)</span>
 11428 |     | <span class='neutral'>            mstore(0x20, m1)</span>
 11429 |     | <span class='neutral'>            mstore(0x40, m2)</span>
 11430 |     | <span class='neutral'>            mstore(0x60, m3)</span>
 11431 |     | <span class='neutral'>            mstore(0x80, m4)</span>
 11432 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
 11433 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
 11434 |     | <span class='neutral'>            mstore(0xe0, m7)</span>
 11435 |     | <span class='neutral'>            mstore(0x100, m8)</span>
 11436 |     | <span class='neutral'>        }</span>
 11437 |     | <span class='neutral'>    }</span>
 11438 |     | <span class='neutral'></span>
 11439 |     | <span class='neutral'>    function log(bytes32 p0, address p1, bytes32 p2, bytes32 p3) internal pure {</span>
 11440 |     | <span class='neutral'>        bytes32 m0;</span>
 11441 |     | <span class='neutral'>        bytes32 m1;</span>
 11442 |     | <span class='neutral'>        bytes32 m2;</span>
 11443 |     | <span class='neutral'>        bytes32 m3;</span>
 11444 |     | <span class='neutral'>        bytes32 m4;</span>
 11445 |     | <span class='neutral'>        bytes32 m5;</span>
 11446 |     | <span class='neutral'>        bytes32 m6;</span>
 11447 |     | <span class='neutral'>        bytes32 m7;</span>
 11448 |     | <span class='neutral'>        bytes32 m8;</span>
 11449 |     | <span class='neutral'>        bytes32 m9;</span>
 11450 |     | <span class='neutral'>        bytes32 m10;</span>
 11451 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 11452 |     | <span class='neutral'>        assembly {</span>
 11453 |     | <span class='neutral'>            function writeString(pos, w) {</span>
 11454 |     | <span class='neutral'>                let length := 0</span>
 11455 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
 11456 |     | <span class='neutral'>                mstore(pos, length)</span>
 11457 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
 11458 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
 11459 |     | <span class='neutral'>            }</span>
 11460 |     | <span class='neutral'>            m0 := mload(0x00)</span>
 11461 |     | <span class='neutral'>            m1 := mload(0x20)</span>
 11462 |     | <span class='neutral'>            m2 := mload(0x40)</span>
 11463 |     | <span class='neutral'>            m3 := mload(0x60)</span>
 11464 |     | <span class='neutral'>            m4 := mload(0x80)</span>
 11465 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
 11466 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
 11467 |     | <span class='neutral'>            m7 := mload(0xe0)</span>
 11468 |     | <span class='neutral'>            m8 := mload(0x100)</span>
 11469 |     | <span class='neutral'>            m9 := mload(0x120)</span>
 11470 |     | <span class='neutral'>            m10 := mload(0x140)</span>
 11471 |     | <span class='neutral'>            // Selector of `log(string,address,string,string)`.</span>
 11472 |     | <span class='neutral'>            mstore(0x00, 0x245986f2)</span>
 11473 |     | <span class='neutral'>            mstore(0x20, 0x80)</span>
 11474 |     | <span class='neutral'>            mstore(0x40, p1)</span>
 11475 |     | <span class='neutral'>            mstore(0x60, 0xc0)</span>
 11476 |     | <span class='neutral'>            mstore(0x80, 0x100)</span>
 11477 |     | <span class='neutral'>            writeString(0xa0, p0)</span>
 11478 |     | <span class='neutral'>            writeString(0xe0, p2)</span>
 11479 |     | <span class='neutral'>            writeString(0x120, p3)</span>
 11480 |     | <span class='neutral'>        }</span>
 11481 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x144);</span>
 11482 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 11483 |     | <span class='neutral'>        assembly {</span>
 11484 |     | <span class='neutral'>            mstore(0x00, m0)</span>
 11485 |     | <span class='neutral'>            mstore(0x20, m1)</span>
 11486 |     | <span class='neutral'>            mstore(0x40, m2)</span>
 11487 |     | <span class='neutral'>            mstore(0x60, m3)</span>
 11488 |     | <span class='neutral'>            mstore(0x80, m4)</span>
 11489 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
 11490 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
 11491 |     | <span class='neutral'>            mstore(0xe0, m7)</span>
 11492 |     | <span class='neutral'>            mstore(0x100, m8)</span>
 11493 |     | <span class='neutral'>            mstore(0x120, m9)</span>
 11494 |     | <span class='neutral'>            mstore(0x140, m10)</span>
 11495 |     | <span class='neutral'>        }</span>
 11496 |     | <span class='neutral'>    }</span>
 11497 |     | <span class='neutral'></span>
 11498 |     | <span class='neutral'>    function log(bytes32 p0, bool p1, address p2, address p3) internal pure {</span>
 11499 |     | <span class='neutral'>        bytes32 m0;</span>
 11500 |     | <span class='neutral'>        bytes32 m1;</span>
 11501 |     | <span class='neutral'>        bytes32 m2;</span>
 11502 |     | <span class='neutral'>        bytes32 m3;</span>
 11503 |     | <span class='neutral'>        bytes32 m4;</span>
 11504 |     | <span class='neutral'>        bytes32 m5;</span>
 11505 |     | <span class='neutral'>        bytes32 m6;</span>
 11506 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 11507 |     | <span class='neutral'>        assembly {</span>
 11508 |     | <span class='neutral'>            function writeString(pos, w) {</span>
 11509 |     | <span class='neutral'>                let length := 0</span>
 11510 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
 11511 |     | <span class='neutral'>                mstore(pos, length)</span>
 11512 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
 11513 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
 11514 |     | <span class='neutral'>            }</span>
 11515 |     | <span class='neutral'>            m0 := mload(0x00)</span>
 11516 |     | <span class='neutral'>            m1 := mload(0x20)</span>
 11517 |     | <span class='neutral'>            m2 := mload(0x40)</span>
 11518 |     | <span class='neutral'>            m3 := mload(0x60)</span>
 11519 |     | <span class='neutral'>            m4 := mload(0x80)</span>
 11520 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
 11521 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
 11522 |     | <span class='neutral'>            // Selector of `log(string,bool,address,address)`.</span>
 11523 |     | <span class='neutral'>            mstore(0x00, 0x33e9dd1d)</span>
 11524 |     | <span class='neutral'>            mstore(0x20, 0x80)</span>
 11525 |     | <span class='neutral'>            mstore(0x40, p1)</span>
 11526 |     | <span class='neutral'>            mstore(0x60, p2)</span>
 11527 |     | <span class='neutral'>            mstore(0x80, p3)</span>
 11528 |     | <span class='neutral'>            writeString(0xa0, p0)</span>
 11529 |     | <span class='neutral'>        }</span>
 11530 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xc4);</span>
 11531 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 11532 |     | <span class='neutral'>        assembly {</span>
 11533 |     | <span class='neutral'>            mstore(0x00, m0)</span>
 11534 |     | <span class='neutral'>            mstore(0x20, m1)</span>
 11535 |     | <span class='neutral'>            mstore(0x40, m2)</span>
 11536 |     | <span class='neutral'>            mstore(0x60, m3)</span>
 11537 |     | <span class='neutral'>            mstore(0x80, m4)</span>
 11538 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
 11539 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
 11540 |     | <span class='neutral'>        }</span>
 11541 |     | <span class='neutral'>    }</span>
 11542 |     | <span class='neutral'></span>
 11543 |     | <span class='neutral'>    function log(bytes32 p0, bool p1, address p2, bool p3) internal pure {</span>
 11544 |     | <span class='neutral'>        bytes32 m0;</span>
 11545 |     | <span class='neutral'>        bytes32 m1;</span>
 11546 |     | <span class='neutral'>        bytes32 m2;</span>
 11547 |     | <span class='neutral'>        bytes32 m3;</span>
 11548 |     | <span class='neutral'>        bytes32 m4;</span>
 11549 |     | <span class='neutral'>        bytes32 m5;</span>
 11550 |     | <span class='neutral'>        bytes32 m6;</span>
 11551 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 11552 |     | <span class='neutral'>        assembly {</span>
 11553 |     | <span class='neutral'>            function writeString(pos, w) {</span>
 11554 |     | <span class='neutral'>                let length := 0</span>
 11555 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
 11556 |     | <span class='neutral'>                mstore(pos, length)</span>
 11557 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
 11558 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
 11559 |     | <span class='neutral'>            }</span>
 11560 |     | <span class='neutral'>            m0 := mload(0x00)</span>
 11561 |     | <span class='neutral'>            m1 := mload(0x20)</span>
 11562 |     | <span class='neutral'>            m2 := mload(0x40)</span>
 11563 |     | <span class='neutral'>            m3 := mload(0x60)</span>
 11564 |     | <span class='neutral'>            m4 := mload(0x80)</span>
 11565 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
 11566 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
 11567 |     | <span class='neutral'>            // Selector of `log(string,bool,address,bool)`.</span>
 11568 |     | <span class='neutral'>            mstore(0x00, 0x958c28c6)</span>
 11569 |     | <span class='neutral'>            mstore(0x20, 0x80)</span>
 11570 |     | <span class='neutral'>            mstore(0x40, p1)</span>
 11571 |     | <span class='neutral'>            mstore(0x60, p2)</span>
 11572 |     | <span class='neutral'>            mstore(0x80, p3)</span>
 11573 |     | <span class='neutral'>            writeString(0xa0, p0)</span>
 11574 |     | <span class='neutral'>        }</span>
 11575 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xc4);</span>
 11576 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 11577 |     | <span class='neutral'>        assembly {</span>
 11578 |     | <span class='neutral'>            mstore(0x00, m0)</span>
 11579 |     | <span class='neutral'>            mstore(0x20, m1)</span>
 11580 |     | <span class='neutral'>            mstore(0x40, m2)</span>
 11581 |     | <span class='neutral'>            mstore(0x60, m3)</span>
 11582 |     | <span class='neutral'>            mstore(0x80, m4)</span>
 11583 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
 11584 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
 11585 |     | <span class='neutral'>        }</span>
 11586 |     | <span class='neutral'>    }</span>
 11587 |     | <span class='neutral'></span>
 11588 |     | <span class='neutral'>    function log(bytes32 p0, bool p1, address p2, uint256 p3) internal pure {</span>
 11589 |     | <span class='neutral'>        bytes32 m0;</span>
 11590 |     | <span class='neutral'>        bytes32 m1;</span>
 11591 |     | <span class='neutral'>        bytes32 m2;</span>
 11592 |     | <span class='neutral'>        bytes32 m3;</span>
 11593 |     | <span class='neutral'>        bytes32 m4;</span>
 11594 |     | <span class='neutral'>        bytes32 m5;</span>
 11595 |     | <span class='neutral'>        bytes32 m6;</span>
 11596 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 11597 |     | <span class='neutral'>        assembly {</span>
 11598 |     | <span class='neutral'>            function writeString(pos, w) {</span>
 11599 |     | <span class='neutral'>                let length := 0</span>
 11600 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
 11601 |     | <span class='neutral'>                mstore(pos, length)</span>
 11602 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
 11603 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
 11604 |     | <span class='neutral'>            }</span>
 11605 |     | <span class='neutral'>            m0 := mload(0x00)</span>
 11606 |     | <span class='neutral'>            m1 := mload(0x20)</span>
 11607 |     | <span class='neutral'>            m2 := mload(0x40)</span>
 11608 |     | <span class='neutral'>            m3 := mload(0x60)</span>
 11609 |     | <span class='neutral'>            m4 := mload(0x80)</span>
 11610 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
 11611 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
 11612 |     | <span class='neutral'>            // Selector of `log(string,bool,address,uint256)`.</span>
 11613 |     | <span class='neutral'>            mstore(0x00, 0x5d08bb05)</span>
 11614 |     | <span class='neutral'>            mstore(0x20, 0x80)</span>
 11615 |     | <span class='neutral'>            mstore(0x40, p1)</span>
 11616 |     | <span class='neutral'>            mstore(0x60, p2)</span>
 11617 |     | <span class='neutral'>            mstore(0x80, p3)</span>
 11618 |     | <span class='neutral'>            writeString(0xa0, p0)</span>
 11619 |     | <span class='neutral'>        }</span>
 11620 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xc4);</span>
 11621 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 11622 |     | <span class='neutral'>        assembly {</span>
 11623 |     | <span class='neutral'>            mstore(0x00, m0)</span>
 11624 |     | <span class='neutral'>            mstore(0x20, m1)</span>
 11625 |     | <span class='neutral'>            mstore(0x40, m2)</span>
 11626 |     | <span class='neutral'>            mstore(0x60, m3)</span>
 11627 |     | <span class='neutral'>            mstore(0x80, m4)</span>
 11628 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
 11629 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
 11630 |     | <span class='neutral'>        }</span>
 11631 |     | <span class='neutral'>    }</span>
 11632 |     | <span class='neutral'></span>
 11633 |     | <span class='neutral'>    function log(bytes32 p0, bool p1, address p2, bytes32 p3) internal pure {</span>
 11634 |     | <span class='neutral'>        bytes32 m0;</span>
 11635 |     | <span class='neutral'>        bytes32 m1;</span>
 11636 |     | <span class='neutral'>        bytes32 m2;</span>
 11637 |     | <span class='neutral'>        bytes32 m3;</span>
 11638 |     | <span class='neutral'>        bytes32 m4;</span>
 11639 |     | <span class='neutral'>        bytes32 m5;</span>
 11640 |     | <span class='neutral'>        bytes32 m6;</span>
 11641 |     | <span class='neutral'>        bytes32 m7;</span>
 11642 |     | <span class='neutral'>        bytes32 m8;</span>
 11643 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 11644 |     | <span class='neutral'>        assembly {</span>
 11645 |     | <span class='neutral'>            function writeString(pos, w) {</span>
 11646 |     | <span class='neutral'>                let length := 0</span>
 11647 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
 11648 |     | <span class='neutral'>                mstore(pos, length)</span>
 11649 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
 11650 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
 11651 |     | <span class='neutral'>            }</span>
 11652 |     | <span class='neutral'>            m0 := mload(0x00)</span>
 11653 |     | <span class='neutral'>            m1 := mload(0x20)</span>
 11654 |     | <span class='neutral'>            m2 := mload(0x40)</span>
 11655 |     | <span class='neutral'>            m3 := mload(0x60)</span>
 11656 |     | <span class='neutral'>            m4 := mload(0x80)</span>
 11657 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
 11658 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
 11659 |     | <span class='neutral'>            m7 := mload(0xe0)</span>
 11660 |     | <span class='neutral'>            m8 := mload(0x100)</span>
 11661 |     | <span class='neutral'>            // Selector of `log(string,bool,address,string)`.</span>
 11662 |     | <span class='neutral'>            mstore(0x00, 0x2d8e33a4)</span>
 11663 |     | <span class='neutral'>            mstore(0x20, 0x80)</span>
 11664 |     | <span class='neutral'>            mstore(0x40, p1)</span>
 11665 |     | <span class='neutral'>            mstore(0x60, p2)</span>
 11666 |     | <span class='neutral'>            mstore(0x80, 0xc0)</span>
 11667 |     | <span class='neutral'>            writeString(0xa0, p0)</span>
 11668 |     | <span class='neutral'>            writeString(0xe0, p3)</span>
 11669 |     | <span class='neutral'>        }</span>
 11670 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x104);</span>
 11671 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 11672 |     | <span class='neutral'>        assembly {</span>
 11673 |     | <span class='neutral'>            mstore(0x00, m0)</span>
 11674 |     | <span class='neutral'>            mstore(0x20, m1)</span>
 11675 |     | <span class='neutral'>            mstore(0x40, m2)</span>
 11676 |     | <span class='neutral'>            mstore(0x60, m3)</span>
 11677 |     | <span class='neutral'>            mstore(0x80, m4)</span>
 11678 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
 11679 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
 11680 |     | <span class='neutral'>            mstore(0xe0, m7)</span>
 11681 |     | <span class='neutral'>            mstore(0x100, m8)</span>
 11682 |     | <span class='neutral'>        }</span>
 11683 |     | <span class='neutral'>    }</span>
 11684 |     | <span class='neutral'></span>
 11685 |     | <span class='neutral'>    function log(bytes32 p0, bool p1, bool p2, address p3) internal pure {</span>
 11686 |     | <span class='neutral'>        bytes32 m0;</span>
 11687 |     | <span class='neutral'>        bytes32 m1;</span>
 11688 |     | <span class='neutral'>        bytes32 m2;</span>
 11689 |     | <span class='neutral'>        bytes32 m3;</span>
 11690 |     | <span class='neutral'>        bytes32 m4;</span>
 11691 |     | <span class='neutral'>        bytes32 m5;</span>
 11692 |     | <span class='neutral'>        bytes32 m6;</span>
 11693 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 11694 |     | <span class='neutral'>        assembly {</span>
 11695 |     | <span class='neutral'>            function writeString(pos, w) {</span>
 11696 |     | <span class='neutral'>                let length := 0</span>
 11697 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
 11698 |     | <span class='neutral'>                mstore(pos, length)</span>
 11699 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
 11700 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
 11701 |     | <span class='neutral'>            }</span>
 11702 |     | <span class='neutral'>            m0 := mload(0x00)</span>
 11703 |     | <span class='neutral'>            m1 := mload(0x20)</span>
 11704 |     | <span class='neutral'>            m2 := mload(0x40)</span>
 11705 |     | <span class='neutral'>            m3 := mload(0x60)</span>
 11706 |     | <span class='neutral'>            m4 := mload(0x80)</span>
 11707 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
 11708 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
 11709 |     | <span class='neutral'>            // Selector of `log(string,bool,bool,address)`.</span>
 11710 |     | <span class='neutral'>            mstore(0x00, 0x7190a529)</span>
 11711 |     | <span class='neutral'>            mstore(0x20, 0x80)</span>
 11712 |     | <span class='neutral'>            mstore(0x40, p1)</span>
 11713 |     | <span class='neutral'>            mstore(0x60, p2)</span>
 11714 |     | <span class='neutral'>            mstore(0x80, p3)</span>
 11715 |     | <span class='neutral'>            writeString(0xa0, p0)</span>
 11716 |     | <span class='neutral'>        }</span>
 11717 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xc4);</span>
 11718 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 11719 |     | <span class='neutral'>        assembly {</span>
 11720 |     | <span class='neutral'>            mstore(0x00, m0)</span>
 11721 |     | <span class='neutral'>            mstore(0x20, m1)</span>
 11722 |     | <span class='neutral'>            mstore(0x40, m2)</span>
 11723 |     | <span class='neutral'>            mstore(0x60, m3)</span>
 11724 |     | <span class='neutral'>            mstore(0x80, m4)</span>
 11725 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
 11726 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
 11727 |     | <span class='neutral'>        }</span>
 11728 |     | <span class='neutral'>    }</span>
 11729 |     | <span class='neutral'></span>
 11730 |     | <span class='neutral'>    function log(bytes32 p0, bool p1, bool p2, bool p3) internal pure {</span>
 11731 |     | <span class='neutral'>        bytes32 m0;</span>
 11732 |     | <span class='neutral'>        bytes32 m1;</span>
 11733 |     | <span class='neutral'>        bytes32 m2;</span>
 11734 |     | <span class='neutral'>        bytes32 m3;</span>
 11735 |     | <span class='neutral'>        bytes32 m4;</span>
 11736 |     | <span class='neutral'>        bytes32 m5;</span>
 11737 |     | <span class='neutral'>        bytes32 m6;</span>
 11738 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 11739 |     | <span class='neutral'>        assembly {</span>
 11740 |     | <span class='neutral'>            function writeString(pos, w) {</span>
 11741 |     | <span class='neutral'>                let length := 0</span>
 11742 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
 11743 |     | <span class='neutral'>                mstore(pos, length)</span>
 11744 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
 11745 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
 11746 |     | <span class='neutral'>            }</span>
 11747 |     | <span class='neutral'>            m0 := mload(0x00)</span>
 11748 |     | <span class='neutral'>            m1 := mload(0x20)</span>
 11749 |     | <span class='neutral'>            m2 := mload(0x40)</span>
 11750 |     | <span class='neutral'>            m3 := mload(0x60)</span>
 11751 |     | <span class='neutral'>            m4 := mload(0x80)</span>
 11752 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
 11753 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
 11754 |     | <span class='neutral'>            // Selector of `log(string,bool,bool,bool)`.</span>
 11755 |     | <span class='neutral'>            mstore(0x00, 0x895af8c5)</span>
 11756 |     | <span class='neutral'>            mstore(0x20, 0x80)</span>
 11757 |     | <span class='neutral'>            mstore(0x40, p1)</span>
 11758 |     | <span class='neutral'>            mstore(0x60, p2)</span>
 11759 |     | <span class='neutral'>            mstore(0x80, p3)</span>
 11760 |     | <span class='neutral'>            writeString(0xa0, p0)</span>
 11761 |     | <span class='neutral'>        }</span>
 11762 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xc4);</span>
 11763 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 11764 |     | <span class='neutral'>        assembly {</span>
 11765 |     | <span class='neutral'>            mstore(0x00, m0)</span>
 11766 |     | <span class='neutral'>            mstore(0x20, m1)</span>
 11767 |     | <span class='neutral'>            mstore(0x40, m2)</span>
 11768 |     | <span class='neutral'>            mstore(0x60, m3)</span>
 11769 |     | <span class='neutral'>            mstore(0x80, m4)</span>
 11770 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
 11771 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
 11772 |     | <span class='neutral'>        }</span>
 11773 |     | <span class='neutral'>    }</span>
 11774 |     | <span class='neutral'></span>
 11775 |     | <span class='neutral'>    function log(bytes32 p0, bool p1, bool p2, uint256 p3) internal pure {</span>
 11776 |     | <span class='neutral'>        bytes32 m0;</span>
 11777 |     | <span class='neutral'>        bytes32 m1;</span>
 11778 |     | <span class='neutral'>        bytes32 m2;</span>
 11779 |     | <span class='neutral'>        bytes32 m3;</span>
 11780 |     | <span class='neutral'>        bytes32 m4;</span>
 11781 |     | <span class='neutral'>        bytes32 m5;</span>
 11782 |     | <span class='neutral'>        bytes32 m6;</span>
 11783 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 11784 |     | <span class='neutral'>        assembly {</span>
 11785 |     | <span class='neutral'>            function writeString(pos, w) {</span>
 11786 |     | <span class='neutral'>                let length := 0</span>
 11787 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
 11788 |     | <span class='neutral'>                mstore(pos, length)</span>
 11789 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
 11790 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
 11791 |     | <span class='neutral'>            }</span>
 11792 |     | <span class='neutral'>            m0 := mload(0x00)</span>
 11793 |     | <span class='neutral'>            m1 := mload(0x20)</span>
 11794 |     | <span class='neutral'>            m2 := mload(0x40)</span>
 11795 |     | <span class='neutral'>            m3 := mload(0x60)</span>
 11796 |     | <span class='neutral'>            m4 := mload(0x80)</span>
 11797 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
 11798 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
 11799 |     | <span class='neutral'>            // Selector of `log(string,bool,bool,uint256)`.</span>
 11800 |     | <span class='neutral'>            mstore(0x00, 0x8e3f78a9)</span>
 11801 |     | <span class='neutral'>            mstore(0x20, 0x80)</span>
 11802 |     | <span class='neutral'>            mstore(0x40, p1)</span>
 11803 |     | <span class='neutral'>            mstore(0x60, p2)</span>
 11804 |     | <span class='neutral'>            mstore(0x80, p3)</span>
 11805 |     | <span class='neutral'>            writeString(0xa0, p0)</span>
 11806 |     | <span class='neutral'>        }</span>
 11807 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xc4);</span>
 11808 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 11809 |     | <span class='neutral'>        assembly {</span>
 11810 |     | <span class='neutral'>            mstore(0x00, m0)</span>
 11811 |     | <span class='neutral'>            mstore(0x20, m1)</span>
 11812 |     | <span class='neutral'>            mstore(0x40, m2)</span>
 11813 |     | <span class='neutral'>            mstore(0x60, m3)</span>
 11814 |     | <span class='neutral'>            mstore(0x80, m4)</span>
 11815 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
 11816 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
 11817 |     | <span class='neutral'>        }</span>
 11818 |     | <span class='neutral'>    }</span>
 11819 |     | <span class='neutral'></span>
 11820 |     | <span class='neutral'>    function log(bytes32 p0, bool p1, bool p2, bytes32 p3) internal pure {</span>
 11821 |     | <span class='neutral'>        bytes32 m0;</span>
 11822 |     | <span class='neutral'>        bytes32 m1;</span>
 11823 |     | <span class='neutral'>        bytes32 m2;</span>
 11824 |     | <span class='neutral'>        bytes32 m3;</span>
 11825 |     | <span class='neutral'>        bytes32 m4;</span>
 11826 |     | <span class='neutral'>        bytes32 m5;</span>
 11827 |     | <span class='neutral'>        bytes32 m6;</span>
 11828 |     | <span class='neutral'>        bytes32 m7;</span>
 11829 |     | <span class='neutral'>        bytes32 m8;</span>
 11830 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 11831 |     | <span class='neutral'>        assembly {</span>
 11832 |     | <span class='neutral'>            function writeString(pos, w) {</span>
 11833 |     | <span class='neutral'>                let length := 0</span>
 11834 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
 11835 |     | <span class='neutral'>                mstore(pos, length)</span>
 11836 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
 11837 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
 11838 |     | <span class='neutral'>            }</span>
 11839 |     | <span class='neutral'>            m0 := mload(0x00)</span>
 11840 |     | <span class='neutral'>            m1 := mload(0x20)</span>
 11841 |     | <span class='neutral'>            m2 := mload(0x40)</span>
 11842 |     | <span class='neutral'>            m3 := mload(0x60)</span>
 11843 |     | <span class='neutral'>            m4 := mload(0x80)</span>
 11844 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
 11845 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
 11846 |     | <span class='neutral'>            m7 := mload(0xe0)</span>
 11847 |     | <span class='neutral'>            m8 := mload(0x100)</span>
 11848 |     | <span class='neutral'>            // Selector of `log(string,bool,bool,string)`.</span>
 11849 |     | <span class='neutral'>            mstore(0x00, 0x9d22d5dd)</span>
 11850 |     | <span class='neutral'>            mstore(0x20, 0x80)</span>
 11851 |     | <span class='neutral'>            mstore(0x40, p1)</span>
 11852 |     | <span class='neutral'>            mstore(0x60, p2)</span>
 11853 |     | <span class='neutral'>            mstore(0x80, 0xc0)</span>
 11854 |     | <span class='neutral'>            writeString(0xa0, p0)</span>
 11855 |     | <span class='neutral'>            writeString(0xe0, p3)</span>
 11856 |     | <span class='neutral'>        }</span>
 11857 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x104);</span>
 11858 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 11859 |     | <span class='neutral'>        assembly {</span>
 11860 |     | <span class='neutral'>            mstore(0x00, m0)</span>
 11861 |     | <span class='neutral'>            mstore(0x20, m1)</span>
 11862 |     | <span class='neutral'>            mstore(0x40, m2)</span>
 11863 |     | <span class='neutral'>            mstore(0x60, m3)</span>
 11864 |     | <span class='neutral'>            mstore(0x80, m4)</span>
 11865 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
 11866 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
 11867 |     | <span class='neutral'>            mstore(0xe0, m7)</span>
 11868 |     | <span class='neutral'>            mstore(0x100, m8)</span>
 11869 |     | <span class='neutral'>        }</span>
 11870 |     | <span class='neutral'>    }</span>
 11871 |     | <span class='neutral'></span>
 11872 |     | <span class='neutral'>    function log(bytes32 p0, bool p1, uint256 p2, address p3) internal pure {</span>
 11873 |     | <span class='neutral'>        bytes32 m0;</span>
 11874 |     | <span class='neutral'>        bytes32 m1;</span>
 11875 |     | <span class='neutral'>        bytes32 m2;</span>
 11876 |     | <span class='neutral'>        bytes32 m3;</span>
 11877 |     | <span class='neutral'>        bytes32 m4;</span>
 11878 |     | <span class='neutral'>        bytes32 m5;</span>
 11879 |     | <span class='neutral'>        bytes32 m6;</span>
 11880 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 11881 |     | <span class='neutral'>        assembly {</span>
 11882 |     | <span class='neutral'>            function writeString(pos, w) {</span>
 11883 |     | <span class='neutral'>                let length := 0</span>
 11884 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
 11885 |     | <span class='neutral'>                mstore(pos, length)</span>
 11886 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
 11887 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
 11888 |     | <span class='neutral'>            }</span>
 11889 |     | <span class='neutral'>            m0 := mload(0x00)</span>
 11890 |     | <span class='neutral'>            m1 := mload(0x20)</span>
 11891 |     | <span class='neutral'>            m2 := mload(0x40)</span>
 11892 |     | <span class='neutral'>            m3 := mload(0x60)</span>
 11893 |     | <span class='neutral'>            m4 := mload(0x80)</span>
 11894 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
 11895 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
 11896 |     | <span class='neutral'>            // Selector of `log(string,bool,uint256,address)`.</span>
 11897 |     | <span class='neutral'>            mstore(0x00, 0x935e09bf)</span>
 11898 |     | <span class='neutral'>            mstore(0x20, 0x80)</span>
 11899 |     | <span class='neutral'>            mstore(0x40, p1)</span>
 11900 |     | <span class='neutral'>            mstore(0x60, p2)</span>
 11901 |     | <span class='neutral'>            mstore(0x80, p3)</span>
 11902 |     | <span class='neutral'>            writeString(0xa0, p0)</span>
 11903 |     | <span class='neutral'>        }</span>
 11904 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xc4);</span>
 11905 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 11906 |     | <span class='neutral'>        assembly {</span>
 11907 |     | <span class='neutral'>            mstore(0x00, m0)</span>
 11908 |     | <span class='neutral'>            mstore(0x20, m1)</span>
 11909 |     | <span class='neutral'>            mstore(0x40, m2)</span>
 11910 |     | <span class='neutral'>            mstore(0x60, m3)</span>
 11911 |     | <span class='neutral'>            mstore(0x80, m4)</span>
 11912 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
 11913 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
 11914 |     | <span class='neutral'>        }</span>
 11915 |     | <span class='neutral'>    }</span>
 11916 |     | <span class='neutral'></span>
 11917 |     | <span class='neutral'>    function log(bytes32 p0, bool p1, uint256 p2, bool p3) internal pure {</span>
 11918 |     | <span class='neutral'>        bytes32 m0;</span>
 11919 |     | <span class='neutral'>        bytes32 m1;</span>
 11920 |     | <span class='neutral'>        bytes32 m2;</span>
 11921 |     | <span class='neutral'>        bytes32 m3;</span>
 11922 |     | <span class='neutral'>        bytes32 m4;</span>
 11923 |     | <span class='neutral'>        bytes32 m5;</span>
 11924 |     | <span class='neutral'>        bytes32 m6;</span>
 11925 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 11926 |     | <span class='neutral'>        assembly {</span>
 11927 |     | <span class='neutral'>            function writeString(pos, w) {</span>
 11928 |     | <span class='neutral'>                let length := 0</span>
 11929 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
 11930 |     | <span class='neutral'>                mstore(pos, length)</span>
 11931 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
 11932 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
 11933 |     | <span class='neutral'>            }</span>
 11934 |     | <span class='neutral'>            m0 := mload(0x00)</span>
 11935 |     | <span class='neutral'>            m1 := mload(0x20)</span>
 11936 |     | <span class='neutral'>            m2 := mload(0x40)</span>
 11937 |     | <span class='neutral'>            m3 := mload(0x60)</span>
 11938 |     | <span class='neutral'>            m4 := mload(0x80)</span>
 11939 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
 11940 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
 11941 |     | <span class='neutral'>            // Selector of `log(string,bool,uint256,bool)`.</span>
 11942 |     | <span class='neutral'>            mstore(0x00, 0x8af7cf8a)</span>
 11943 |     | <span class='neutral'>            mstore(0x20, 0x80)</span>
 11944 |     | <span class='neutral'>            mstore(0x40, p1)</span>
 11945 |     | <span class='neutral'>            mstore(0x60, p2)</span>
 11946 |     | <span class='neutral'>            mstore(0x80, p3)</span>
 11947 |     | <span class='neutral'>            writeString(0xa0, p0)</span>
 11948 |     | <span class='neutral'>        }</span>
 11949 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xc4);</span>
 11950 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 11951 |     | <span class='neutral'>        assembly {</span>
 11952 |     | <span class='neutral'>            mstore(0x00, m0)</span>
 11953 |     | <span class='neutral'>            mstore(0x20, m1)</span>
 11954 |     | <span class='neutral'>            mstore(0x40, m2)</span>
 11955 |     | <span class='neutral'>            mstore(0x60, m3)</span>
 11956 |     | <span class='neutral'>            mstore(0x80, m4)</span>
 11957 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
 11958 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
 11959 |     | <span class='neutral'>        }</span>
 11960 |     | <span class='neutral'>    }</span>
 11961 |     | <span class='neutral'></span>
 11962 |     | <span class='neutral'>    function log(bytes32 p0, bool p1, uint256 p2, uint256 p3) internal pure {</span>
 11963 |     | <span class='neutral'>        bytes32 m0;</span>
 11964 |     | <span class='neutral'>        bytes32 m1;</span>
 11965 |     | <span class='neutral'>        bytes32 m2;</span>
 11966 |     | <span class='neutral'>        bytes32 m3;</span>
 11967 |     | <span class='neutral'>        bytes32 m4;</span>
 11968 |     | <span class='neutral'>        bytes32 m5;</span>
 11969 |     | <span class='neutral'>        bytes32 m6;</span>
 11970 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 11971 |     | <span class='neutral'>        assembly {</span>
 11972 |     | <span class='neutral'>            function writeString(pos, w) {</span>
 11973 |     | <span class='neutral'>                let length := 0</span>
 11974 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
 11975 |     | <span class='neutral'>                mstore(pos, length)</span>
 11976 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
 11977 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
 11978 |     | <span class='neutral'>            }</span>
 11979 |     | <span class='neutral'>            m0 := mload(0x00)</span>
 11980 |     | <span class='neutral'>            m1 := mload(0x20)</span>
 11981 |     | <span class='neutral'>            m2 := mload(0x40)</span>
 11982 |     | <span class='neutral'>            m3 := mload(0x60)</span>
 11983 |     | <span class='neutral'>            m4 := mload(0x80)</span>
 11984 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
 11985 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
 11986 |     | <span class='neutral'>            // Selector of `log(string,bool,uint256,uint256)`.</span>
 11987 |     | <span class='neutral'>            mstore(0x00, 0x64b5bb67)</span>
 11988 |     | <span class='neutral'>            mstore(0x20, 0x80)</span>
 11989 |     | <span class='neutral'>            mstore(0x40, p1)</span>
 11990 |     | <span class='neutral'>            mstore(0x60, p2)</span>
 11991 |     | <span class='neutral'>            mstore(0x80, p3)</span>
 11992 |     | <span class='neutral'>            writeString(0xa0, p0)</span>
 11993 |     | <span class='neutral'>        }</span>
 11994 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xc4);</span>
 11995 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 11996 |     | <span class='neutral'>        assembly {</span>
 11997 |     | <span class='neutral'>            mstore(0x00, m0)</span>
 11998 |     | <span class='neutral'>            mstore(0x20, m1)</span>
 11999 |     | <span class='neutral'>            mstore(0x40, m2)</span>
 12000 |     | <span class='neutral'>            mstore(0x60, m3)</span>
 12001 |     | <span class='neutral'>            mstore(0x80, m4)</span>
 12002 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
 12003 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
 12004 |     | <span class='neutral'>        }</span>
 12005 |     | <span class='neutral'>    }</span>
 12006 |     | <span class='neutral'></span>
 12007 |     | <span class='neutral'>    function log(bytes32 p0, bool p1, uint256 p2, bytes32 p3) internal pure {</span>
 12008 |     | <span class='neutral'>        bytes32 m0;</span>
 12009 |     | <span class='neutral'>        bytes32 m1;</span>
 12010 |     | <span class='neutral'>        bytes32 m2;</span>
 12011 |     | <span class='neutral'>        bytes32 m3;</span>
 12012 |     | <span class='neutral'>        bytes32 m4;</span>
 12013 |     | <span class='neutral'>        bytes32 m5;</span>
 12014 |     | <span class='neutral'>        bytes32 m6;</span>
 12015 |     | <span class='neutral'>        bytes32 m7;</span>
 12016 |     | <span class='neutral'>        bytes32 m8;</span>
 12017 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 12018 |     | <span class='neutral'>        assembly {</span>
 12019 |     | <span class='neutral'>            function writeString(pos, w) {</span>
 12020 |     | <span class='neutral'>                let length := 0</span>
 12021 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
 12022 |     | <span class='neutral'>                mstore(pos, length)</span>
 12023 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
 12024 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
 12025 |     | <span class='neutral'>            }</span>
 12026 |     | <span class='neutral'>            m0 := mload(0x00)</span>
 12027 |     | <span class='neutral'>            m1 := mload(0x20)</span>
 12028 |     | <span class='neutral'>            m2 := mload(0x40)</span>
 12029 |     | <span class='neutral'>            m3 := mload(0x60)</span>
 12030 |     | <span class='neutral'>            m4 := mload(0x80)</span>
 12031 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
 12032 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
 12033 |     | <span class='neutral'>            m7 := mload(0xe0)</span>
 12034 |     | <span class='neutral'>            m8 := mload(0x100)</span>
 12035 |     | <span class='neutral'>            // Selector of `log(string,bool,uint256,string)`.</span>
 12036 |     | <span class='neutral'>            mstore(0x00, 0x742d6ee7)</span>
 12037 |     | <span class='neutral'>            mstore(0x20, 0x80)</span>
 12038 |     | <span class='neutral'>            mstore(0x40, p1)</span>
 12039 |     | <span class='neutral'>            mstore(0x60, p2)</span>
 12040 |     | <span class='neutral'>            mstore(0x80, 0xc0)</span>
 12041 |     | <span class='neutral'>            writeString(0xa0, p0)</span>
 12042 |     | <span class='neutral'>            writeString(0xe0, p3)</span>
 12043 |     | <span class='neutral'>        }</span>
 12044 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x104);</span>
 12045 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 12046 |     | <span class='neutral'>        assembly {</span>
 12047 |     | <span class='neutral'>            mstore(0x00, m0)</span>
 12048 |     | <span class='neutral'>            mstore(0x20, m1)</span>
 12049 |     | <span class='neutral'>            mstore(0x40, m2)</span>
 12050 |     | <span class='neutral'>            mstore(0x60, m3)</span>
 12051 |     | <span class='neutral'>            mstore(0x80, m4)</span>
 12052 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
 12053 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
 12054 |     | <span class='neutral'>            mstore(0xe0, m7)</span>
 12055 |     | <span class='neutral'>            mstore(0x100, m8)</span>
 12056 |     | <span class='neutral'>        }</span>
 12057 |     | <span class='neutral'>    }</span>
 12058 |     | <span class='neutral'></span>
 12059 |     | <span class='neutral'>    function log(bytes32 p0, bool p1, bytes32 p2, address p3) internal pure {</span>
 12060 |     | <span class='neutral'>        bytes32 m0;</span>
 12061 |     | <span class='neutral'>        bytes32 m1;</span>
 12062 |     | <span class='neutral'>        bytes32 m2;</span>
 12063 |     | <span class='neutral'>        bytes32 m3;</span>
 12064 |     | <span class='neutral'>        bytes32 m4;</span>
 12065 |     | <span class='neutral'>        bytes32 m5;</span>
 12066 |     | <span class='neutral'>        bytes32 m6;</span>
 12067 |     | <span class='neutral'>        bytes32 m7;</span>
 12068 |     | <span class='neutral'>        bytes32 m8;</span>
 12069 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 12070 |     | <span class='neutral'>        assembly {</span>
 12071 |     | <span class='neutral'>            function writeString(pos, w) {</span>
 12072 |     | <span class='neutral'>                let length := 0</span>
 12073 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
 12074 |     | <span class='neutral'>                mstore(pos, length)</span>
 12075 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
 12076 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
 12077 |     | <span class='neutral'>            }</span>
 12078 |     | <span class='neutral'>            m0 := mload(0x00)</span>
 12079 |     | <span class='neutral'>            m1 := mload(0x20)</span>
 12080 |     | <span class='neutral'>            m2 := mload(0x40)</span>
 12081 |     | <span class='neutral'>            m3 := mload(0x60)</span>
 12082 |     | <span class='neutral'>            m4 := mload(0x80)</span>
 12083 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
 12084 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
 12085 |     | <span class='neutral'>            m7 := mload(0xe0)</span>
 12086 |     | <span class='neutral'>            m8 := mload(0x100)</span>
 12087 |     | <span class='neutral'>            // Selector of `log(string,bool,string,address)`.</span>
 12088 |     | <span class='neutral'>            mstore(0x00, 0xe0625b29)</span>
 12089 |     | <span class='neutral'>            mstore(0x20, 0x80)</span>
 12090 |     | <span class='neutral'>            mstore(0x40, p1)</span>
 12091 |     | <span class='neutral'>            mstore(0x60, 0xc0)</span>
 12092 |     | <span class='neutral'>            mstore(0x80, p3)</span>
 12093 |     | <span class='neutral'>            writeString(0xa0, p0)</span>
 12094 |     | <span class='neutral'>            writeString(0xe0, p2)</span>
 12095 |     | <span class='neutral'>        }</span>
 12096 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x104);</span>
 12097 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 12098 |     | <span class='neutral'>        assembly {</span>
 12099 |     | <span class='neutral'>            mstore(0x00, m0)</span>
 12100 |     | <span class='neutral'>            mstore(0x20, m1)</span>
 12101 |     | <span class='neutral'>            mstore(0x40, m2)</span>
 12102 |     | <span class='neutral'>            mstore(0x60, m3)</span>
 12103 |     | <span class='neutral'>            mstore(0x80, m4)</span>
 12104 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
 12105 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
 12106 |     | <span class='neutral'>            mstore(0xe0, m7)</span>
 12107 |     | <span class='neutral'>            mstore(0x100, m8)</span>
 12108 |     | <span class='neutral'>        }</span>
 12109 |     | <span class='neutral'>    }</span>
 12110 |     | <span class='neutral'></span>
 12111 |     | <span class='neutral'>    function log(bytes32 p0, bool p1, bytes32 p2, bool p3) internal pure {</span>
 12112 |     | <span class='neutral'>        bytes32 m0;</span>
 12113 |     | <span class='neutral'>        bytes32 m1;</span>
 12114 |     | <span class='neutral'>        bytes32 m2;</span>
 12115 |     | <span class='neutral'>        bytes32 m3;</span>
 12116 |     | <span class='neutral'>        bytes32 m4;</span>
 12117 |     | <span class='neutral'>        bytes32 m5;</span>
 12118 |     | <span class='neutral'>        bytes32 m6;</span>
 12119 |     | <span class='neutral'>        bytes32 m7;</span>
 12120 |     | <span class='neutral'>        bytes32 m8;</span>
 12121 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 12122 |     | <span class='neutral'>        assembly {</span>
 12123 |     | <span class='neutral'>            function writeString(pos, w) {</span>
 12124 |     | <span class='neutral'>                let length := 0</span>
 12125 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
 12126 |     | <span class='neutral'>                mstore(pos, length)</span>
 12127 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
 12128 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
 12129 |     | <span class='neutral'>            }</span>
 12130 |     | <span class='neutral'>            m0 := mload(0x00)</span>
 12131 |     | <span class='neutral'>            m1 := mload(0x20)</span>
 12132 |     | <span class='neutral'>            m2 := mload(0x40)</span>
 12133 |     | <span class='neutral'>            m3 := mload(0x60)</span>
 12134 |     | <span class='neutral'>            m4 := mload(0x80)</span>
 12135 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
 12136 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
 12137 |     | <span class='neutral'>            m7 := mload(0xe0)</span>
 12138 |     | <span class='neutral'>            m8 := mload(0x100)</span>
 12139 |     | <span class='neutral'>            // Selector of `log(string,bool,string,bool)`.</span>
 12140 |     | <span class='neutral'>            mstore(0x00, 0x3f8a701d)</span>
 12141 |     | <span class='neutral'>            mstore(0x20, 0x80)</span>
 12142 |     | <span class='neutral'>            mstore(0x40, p1)</span>
 12143 |     | <span class='neutral'>            mstore(0x60, 0xc0)</span>
 12144 |     | <span class='neutral'>            mstore(0x80, p3)</span>
 12145 |     | <span class='neutral'>            writeString(0xa0, p0)</span>
 12146 |     | <span class='neutral'>            writeString(0xe0, p2)</span>
 12147 |     | <span class='neutral'>        }</span>
 12148 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x104);</span>
 12149 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 12150 |     | <span class='neutral'>        assembly {</span>
 12151 |     | <span class='neutral'>            mstore(0x00, m0)</span>
 12152 |     | <span class='neutral'>            mstore(0x20, m1)</span>
 12153 |     | <span class='neutral'>            mstore(0x40, m2)</span>
 12154 |     | <span class='neutral'>            mstore(0x60, m3)</span>
 12155 |     | <span class='neutral'>            mstore(0x80, m4)</span>
 12156 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
 12157 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
 12158 |     | <span class='neutral'>            mstore(0xe0, m7)</span>
 12159 |     | <span class='neutral'>            mstore(0x100, m8)</span>
 12160 |     | <span class='neutral'>        }</span>
 12161 |     | <span class='neutral'>    }</span>
 12162 |     | <span class='neutral'></span>
 12163 |     | <span class='neutral'>    function log(bytes32 p0, bool p1, bytes32 p2, uint256 p3) internal pure {</span>
 12164 |     | <span class='neutral'>        bytes32 m0;</span>
 12165 |     | <span class='neutral'>        bytes32 m1;</span>
 12166 |     | <span class='neutral'>        bytes32 m2;</span>
 12167 |     | <span class='neutral'>        bytes32 m3;</span>
 12168 |     | <span class='neutral'>        bytes32 m4;</span>
 12169 |     | <span class='neutral'>        bytes32 m5;</span>
 12170 |     | <span class='neutral'>        bytes32 m6;</span>
 12171 |     | <span class='neutral'>        bytes32 m7;</span>
 12172 |     | <span class='neutral'>        bytes32 m8;</span>
 12173 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 12174 |     | <span class='neutral'>        assembly {</span>
 12175 |     | <span class='neutral'>            function writeString(pos, w) {</span>
 12176 |     | <span class='neutral'>                let length := 0</span>
 12177 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
 12178 |     | <span class='neutral'>                mstore(pos, length)</span>
 12179 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
 12180 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
 12181 |     | <span class='neutral'>            }</span>
 12182 |     | <span class='neutral'>            m0 := mload(0x00)</span>
 12183 |     | <span class='neutral'>            m1 := mload(0x20)</span>
 12184 |     | <span class='neutral'>            m2 := mload(0x40)</span>
 12185 |     | <span class='neutral'>            m3 := mload(0x60)</span>
 12186 |     | <span class='neutral'>            m4 := mload(0x80)</span>
 12187 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
 12188 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
 12189 |     | <span class='neutral'>            m7 := mload(0xe0)</span>
 12190 |     | <span class='neutral'>            m8 := mload(0x100)</span>
 12191 |     | <span class='neutral'>            // Selector of `log(string,bool,string,uint256)`.</span>
 12192 |     | <span class='neutral'>            mstore(0x00, 0x24f91465)</span>
 12193 |     | <span class='neutral'>            mstore(0x20, 0x80)</span>
 12194 |     | <span class='neutral'>            mstore(0x40, p1)</span>
 12195 |     | <span class='neutral'>            mstore(0x60, 0xc0)</span>
 12196 |     | <span class='neutral'>            mstore(0x80, p3)</span>
 12197 |     | <span class='neutral'>            writeString(0xa0, p0)</span>
 12198 |     | <span class='neutral'>            writeString(0xe0, p2)</span>
 12199 |     | <span class='neutral'>        }</span>
 12200 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x104);</span>
 12201 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 12202 |     | <span class='neutral'>        assembly {</span>
 12203 |     | <span class='neutral'>            mstore(0x00, m0)</span>
 12204 |     | <span class='neutral'>            mstore(0x20, m1)</span>
 12205 |     | <span class='neutral'>            mstore(0x40, m2)</span>
 12206 |     | <span class='neutral'>            mstore(0x60, m3)</span>
 12207 |     | <span class='neutral'>            mstore(0x80, m4)</span>
 12208 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
 12209 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
 12210 |     | <span class='neutral'>            mstore(0xe0, m7)</span>
 12211 |     | <span class='neutral'>            mstore(0x100, m8)</span>
 12212 |     | <span class='neutral'>        }</span>
 12213 |     | <span class='neutral'>    }</span>
 12214 |     | <span class='neutral'></span>
 12215 |     | <span class='neutral'>    function log(bytes32 p0, bool p1, bytes32 p2, bytes32 p3) internal pure {</span>
 12216 |     | <span class='neutral'>        bytes32 m0;</span>
 12217 |     | <span class='neutral'>        bytes32 m1;</span>
 12218 |     | <span class='neutral'>        bytes32 m2;</span>
 12219 |     | <span class='neutral'>        bytes32 m3;</span>
 12220 |     | <span class='neutral'>        bytes32 m4;</span>
 12221 |     | <span class='neutral'>        bytes32 m5;</span>
 12222 |     | <span class='neutral'>        bytes32 m6;</span>
 12223 |     | <span class='neutral'>        bytes32 m7;</span>
 12224 |     | <span class='neutral'>        bytes32 m8;</span>
 12225 |     | <span class='neutral'>        bytes32 m9;</span>
 12226 |     | <span class='neutral'>        bytes32 m10;</span>
 12227 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 12228 |     | <span class='neutral'>        assembly {</span>
 12229 |     | <span class='neutral'>            function writeString(pos, w) {</span>
 12230 |     | <span class='neutral'>                let length := 0</span>
 12231 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
 12232 |     | <span class='neutral'>                mstore(pos, length)</span>
 12233 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
 12234 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
 12235 |     | <span class='neutral'>            }</span>
 12236 |     | <span class='neutral'>            m0 := mload(0x00)</span>
 12237 |     | <span class='neutral'>            m1 := mload(0x20)</span>
 12238 |     | <span class='neutral'>            m2 := mload(0x40)</span>
 12239 |     | <span class='neutral'>            m3 := mload(0x60)</span>
 12240 |     | <span class='neutral'>            m4 := mload(0x80)</span>
 12241 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
 12242 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
 12243 |     | <span class='neutral'>            m7 := mload(0xe0)</span>
 12244 |     | <span class='neutral'>            m8 := mload(0x100)</span>
 12245 |     | <span class='neutral'>            m9 := mload(0x120)</span>
 12246 |     | <span class='neutral'>            m10 := mload(0x140)</span>
 12247 |     | <span class='neutral'>            // Selector of `log(string,bool,string,string)`.</span>
 12248 |     | <span class='neutral'>            mstore(0x00, 0xa826caeb)</span>
 12249 |     | <span class='neutral'>            mstore(0x20, 0x80)</span>
 12250 |     | <span class='neutral'>            mstore(0x40, p1)</span>
 12251 |     | <span class='neutral'>            mstore(0x60, 0xc0)</span>
 12252 |     | <span class='neutral'>            mstore(0x80, 0x100)</span>
 12253 |     | <span class='neutral'>            writeString(0xa0, p0)</span>
 12254 |     | <span class='neutral'>            writeString(0xe0, p2)</span>
 12255 |     | <span class='neutral'>            writeString(0x120, p3)</span>
 12256 |     | <span class='neutral'>        }</span>
 12257 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x144);</span>
 12258 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 12259 |     | <span class='neutral'>        assembly {</span>
 12260 |     | <span class='neutral'>            mstore(0x00, m0)</span>
 12261 |     | <span class='neutral'>            mstore(0x20, m1)</span>
 12262 |     | <span class='neutral'>            mstore(0x40, m2)</span>
 12263 |     | <span class='neutral'>            mstore(0x60, m3)</span>
 12264 |     | <span class='neutral'>            mstore(0x80, m4)</span>
 12265 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
 12266 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
 12267 |     | <span class='neutral'>            mstore(0xe0, m7)</span>
 12268 |     | <span class='neutral'>            mstore(0x100, m8)</span>
 12269 |     | <span class='neutral'>            mstore(0x120, m9)</span>
 12270 |     | <span class='neutral'>            mstore(0x140, m10)</span>
 12271 |     | <span class='neutral'>        }</span>
 12272 |     | <span class='neutral'>    }</span>
 12273 |     | <span class='neutral'></span>
 12274 |     | <span class='neutral'>    function log(bytes32 p0, uint256 p1, address p2, address p3) internal pure {</span>
 12275 |     | <span class='neutral'>        bytes32 m0;</span>
 12276 |     | <span class='neutral'>        bytes32 m1;</span>
 12277 |     | <span class='neutral'>        bytes32 m2;</span>
 12278 |     | <span class='neutral'>        bytes32 m3;</span>
 12279 |     | <span class='neutral'>        bytes32 m4;</span>
 12280 |     | <span class='neutral'>        bytes32 m5;</span>
 12281 |     | <span class='neutral'>        bytes32 m6;</span>
 12282 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 12283 |     | <span class='neutral'>        assembly {</span>
 12284 |     | <span class='neutral'>            function writeString(pos, w) {</span>
 12285 |     | <span class='neutral'>                let length := 0</span>
 12286 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
 12287 |     | <span class='neutral'>                mstore(pos, length)</span>
 12288 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
 12289 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
 12290 |     | <span class='neutral'>            }</span>
 12291 |     | <span class='neutral'>            m0 := mload(0x00)</span>
 12292 |     | <span class='neutral'>            m1 := mload(0x20)</span>
 12293 |     | <span class='neutral'>            m2 := mload(0x40)</span>
 12294 |     | <span class='neutral'>            m3 := mload(0x60)</span>
 12295 |     | <span class='neutral'>            m4 := mload(0x80)</span>
 12296 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
 12297 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
 12298 |     | <span class='neutral'>            // Selector of `log(string,uint256,address,address)`.</span>
 12299 |     | <span class='neutral'>            mstore(0x00, 0x5ea2b7ae)</span>
 12300 |     | <span class='neutral'>            mstore(0x20, 0x80)</span>
 12301 |     | <span class='neutral'>            mstore(0x40, p1)</span>
 12302 |     | <span class='neutral'>            mstore(0x60, p2)</span>
 12303 |     | <span class='neutral'>            mstore(0x80, p3)</span>
 12304 |     | <span class='neutral'>            writeString(0xa0, p0)</span>
 12305 |     | <span class='neutral'>        }</span>
 12306 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xc4);</span>
 12307 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 12308 |     | <span class='neutral'>        assembly {</span>
 12309 |     | <span class='neutral'>            mstore(0x00, m0)</span>
 12310 |     | <span class='neutral'>            mstore(0x20, m1)</span>
 12311 |     | <span class='neutral'>            mstore(0x40, m2)</span>
 12312 |     | <span class='neutral'>            mstore(0x60, m3)</span>
 12313 |     | <span class='neutral'>            mstore(0x80, m4)</span>
 12314 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
 12315 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
 12316 |     | <span class='neutral'>        }</span>
 12317 |     | <span class='neutral'>    }</span>
 12318 |     | <span class='neutral'></span>
 12319 |     | <span class='neutral'>    function log(bytes32 p0, uint256 p1, address p2, bool p3) internal pure {</span>
 12320 |     | <span class='neutral'>        bytes32 m0;</span>
 12321 |     | <span class='neutral'>        bytes32 m1;</span>
 12322 |     | <span class='neutral'>        bytes32 m2;</span>
 12323 |     | <span class='neutral'>        bytes32 m3;</span>
 12324 |     | <span class='neutral'>        bytes32 m4;</span>
 12325 |     | <span class='neutral'>        bytes32 m5;</span>
 12326 |     | <span class='neutral'>        bytes32 m6;</span>
 12327 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 12328 |     | <span class='neutral'>        assembly {</span>
 12329 |     | <span class='neutral'>            function writeString(pos, w) {</span>
 12330 |     | <span class='neutral'>                let length := 0</span>
 12331 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
 12332 |     | <span class='neutral'>                mstore(pos, length)</span>
 12333 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
 12334 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
 12335 |     | <span class='neutral'>            }</span>
 12336 |     | <span class='neutral'>            m0 := mload(0x00)</span>
 12337 |     | <span class='neutral'>            m1 := mload(0x20)</span>
 12338 |     | <span class='neutral'>            m2 := mload(0x40)</span>
 12339 |     | <span class='neutral'>            m3 := mload(0x60)</span>
 12340 |     | <span class='neutral'>            m4 := mload(0x80)</span>
 12341 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
 12342 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
 12343 |     | <span class='neutral'>            // Selector of `log(string,uint256,address,bool)`.</span>
 12344 |     | <span class='neutral'>            mstore(0x00, 0x82112a42)</span>
 12345 |     | <span class='neutral'>            mstore(0x20, 0x80)</span>
 12346 |     | <span class='neutral'>            mstore(0x40, p1)</span>
 12347 |     | <span class='neutral'>            mstore(0x60, p2)</span>
 12348 |     | <span class='neutral'>            mstore(0x80, p3)</span>
 12349 |     | <span class='neutral'>            writeString(0xa0, p0)</span>
 12350 |     | <span class='neutral'>        }</span>
 12351 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xc4);</span>
 12352 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 12353 |     | <span class='neutral'>        assembly {</span>
 12354 |     | <span class='neutral'>            mstore(0x00, m0)</span>
 12355 |     | <span class='neutral'>            mstore(0x20, m1)</span>
 12356 |     | <span class='neutral'>            mstore(0x40, m2)</span>
 12357 |     | <span class='neutral'>            mstore(0x60, m3)</span>
 12358 |     | <span class='neutral'>            mstore(0x80, m4)</span>
 12359 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
 12360 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
 12361 |     | <span class='neutral'>        }</span>
 12362 |     | <span class='neutral'>    }</span>
 12363 |     | <span class='neutral'></span>
 12364 |     | <span class='neutral'>    function log(bytes32 p0, uint256 p1, address p2, uint256 p3) internal pure {</span>
 12365 |     | <span class='neutral'>        bytes32 m0;</span>
 12366 |     | <span class='neutral'>        bytes32 m1;</span>
 12367 |     | <span class='neutral'>        bytes32 m2;</span>
 12368 |     | <span class='neutral'>        bytes32 m3;</span>
 12369 |     | <span class='neutral'>        bytes32 m4;</span>
 12370 |     | <span class='neutral'>        bytes32 m5;</span>
 12371 |     | <span class='neutral'>        bytes32 m6;</span>
 12372 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 12373 |     | <span class='neutral'>        assembly {</span>
 12374 |     | <span class='neutral'>            function writeString(pos, w) {</span>
 12375 |     | <span class='neutral'>                let length := 0</span>
 12376 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
 12377 |     | <span class='neutral'>                mstore(pos, length)</span>
 12378 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
 12379 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
 12380 |     | <span class='neutral'>            }</span>
 12381 |     | <span class='neutral'>            m0 := mload(0x00)</span>
 12382 |     | <span class='neutral'>            m1 := mload(0x20)</span>
 12383 |     | <span class='neutral'>            m2 := mload(0x40)</span>
 12384 |     | <span class='neutral'>            m3 := mload(0x60)</span>
 12385 |     | <span class='neutral'>            m4 := mload(0x80)</span>
 12386 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
 12387 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
 12388 |     | <span class='neutral'>            // Selector of `log(string,uint256,address,uint256)`.</span>
 12389 |     | <span class='neutral'>            mstore(0x00, 0x4f04fdc6)</span>
 12390 |     | <span class='neutral'>            mstore(0x20, 0x80)</span>
 12391 |     | <span class='neutral'>            mstore(0x40, p1)</span>
 12392 |     | <span class='neutral'>            mstore(0x60, p2)</span>
 12393 |     | <span class='neutral'>            mstore(0x80, p3)</span>
 12394 |     | <span class='neutral'>            writeString(0xa0, p0)</span>
 12395 |     | <span class='neutral'>        }</span>
 12396 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xc4);</span>
 12397 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 12398 |     | <span class='neutral'>        assembly {</span>
 12399 |     | <span class='neutral'>            mstore(0x00, m0)</span>
 12400 |     | <span class='neutral'>            mstore(0x20, m1)</span>
 12401 |     | <span class='neutral'>            mstore(0x40, m2)</span>
 12402 |     | <span class='neutral'>            mstore(0x60, m3)</span>
 12403 |     | <span class='neutral'>            mstore(0x80, m4)</span>
 12404 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
 12405 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
 12406 |     | <span class='neutral'>        }</span>
 12407 |     | <span class='neutral'>    }</span>
 12408 |     | <span class='neutral'></span>
 12409 |     | <span class='neutral'>    function log(bytes32 p0, uint256 p1, address p2, bytes32 p3) internal pure {</span>
 12410 |     | <span class='neutral'>        bytes32 m0;</span>
 12411 |     | <span class='neutral'>        bytes32 m1;</span>
 12412 |     | <span class='neutral'>        bytes32 m2;</span>
 12413 |     | <span class='neutral'>        bytes32 m3;</span>
 12414 |     | <span class='neutral'>        bytes32 m4;</span>
 12415 |     | <span class='neutral'>        bytes32 m5;</span>
 12416 |     | <span class='neutral'>        bytes32 m6;</span>
 12417 |     | <span class='neutral'>        bytes32 m7;</span>
 12418 |     | <span class='neutral'>        bytes32 m8;</span>
 12419 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 12420 |     | <span class='neutral'>        assembly {</span>
 12421 |     | <span class='neutral'>            function writeString(pos, w) {</span>
 12422 |     | <span class='neutral'>                let length := 0</span>
 12423 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
 12424 |     | <span class='neutral'>                mstore(pos, length)</span>
 12425 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
 12426 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
 12427 |     | <span class='neutral'>            }</span>
 12428 |     | <span class='neutral'>            m0 := mload(0x00)</span>
 12429 |     | <span class='neutral'>            m1 := mload(0x20)</span>
 12430 |     | <span class='neutral'>            m2 := mload(0x40)</span>
 12431 |     | <span class='neutral'>            m3 := mload(0x60)</span>
 12432 |     | <span class='neutral'>            m4 := mload(0x80)</span>
 12433 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
 12434 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
 12435 |     | <span class='neutral'>            m7 := mload(0xe0)</span>
 12436 |     | <span class='neutral'>            m8 := mload(0x100)</span>
 12437 |     | <span class='neutral'>            // Selector of `log(string,uint256,address,string)`.</span>
 12438 |     | <span class='neutral'>            mstore(0x00, 0x9ffb2f93)</span>
 12439 |     | <span class='neutral'>            mstore(0x20, 0x80)</span>
 12440 |     | <span class='neutral'>            mstore(0x40, p1)</span>
 12441 |     | <span class='neutral'>            mstore(0x60, p2)</span>
 12442 |     | <span class='neutral'>            mstore(0x80, 0xc0)</span>
 12443 |     | <span class='neutral'>            writeString(0xa0, p0)</span>
 12444 |     | <span class='neutral'>            writeString(0xe0, p3)</span>
 12445 |     | <span class='neutral'>        }</span>
 12446 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x104);</span>
 12447 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 12448 |     | <span class='neutral'>        assembly {</span>
 12449 |     | <span class='neutral'>            mstore(0x00, m0)</span>
 12450 |     | <span class='neutral'>            mstore(0x20, m1)</span>
 12451 |     | <span class='neutral'>            mstore(0x40, m2)</span>
 12452 |     | <span class='neutral'>            mstore(0x60, m3)</span>
 12453 |     | <span class='neutral'>            mstore(0x80, m4)</span>
 12454 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
 12455 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
 12456 |     | <span class='neutral'>            mstore(0xe0, m7)</span>
 12457 |     | <span class='neutral'>            mstore(0x100, m8)</span>
 12458 |     | <span class='neutral'>        }</span>
 12459 |     | <span class='neutral'>    }</span>
 12460 |     | <span class='neutral'></span>
 12461 |     | <span class='neutral'>    function log(bytes32 p0, uint256 p1, bool p2, address p3) internal pure {</span>
 12462 |     | <span class='neutral'>        bytes32 m0;</span>
 12463 |     | <span class='neutral'>        bytes32 m1;</span>
 12464 |     | <span class='neutral'>        bytes32 m2;</span>
 12465 |     | <span class='neutral'>        bytes32 m3;</span>
 12466 |     | <span class='neutral'>        bytes32 m4;</span>
 12467 |     | <span class='neutral'>        bytes32 m5;</span>
 12468 |     | <span class='neutral'>        bytes32 m6;</span>
 12469 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 12470 |     | <span class='neutral'>        assembly {</span>
 12471 |     | <span class='neutral'>            function writeString(pos, w) {</span>
 12472 |     | <span class='neutral'>                let length := 0</span>
 12473 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
 12474 |     | <span class='neutral'>                mstore(pos, length)</span>
 12475 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
 12476 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
 12477 |     | <span class='neutral'>            }</span>
 12478 |     | <span class='neutral'>            m0 := mload(0x00)</span>
 12479 |     | <span class='neutral'>            m1 := mload(0x20)</span>
 12480 |     | <span class='neutral'>            m2 := mload(0x40)</span>
 12481 |     | <span class='neutral'>            m3 := mload(0x60)</span>
 12482 |     | <span class='neutral'>            m4 := mload(0x80)</span>
 12483 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
 12484 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
 12485 |     | <span class='neutral'>            // Selector of `log(string,uint256,bool,address)`.</span>
 12486 |     | <span class='neutral'>            mstore(0x00, 0xe0e95b98)</span>
 12487 |     | <span class='neutral'>            mstore(0x20, 0x80)</span>
 12488 |     | <span class='neutral'>            mstore(0x40, p1)</span>
 12489 |     | <span class='neutral'>            mstore(0x60, p2)</span>
 12490 |     | <span class='neutral'>            mstore(0x80, p3)</span>
 12491 |     | <span class='neutral'>            writeString(0xa0, p0)</span>
 12492 |     | <span class='neutral'>        }</span>
 12493 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xc4);</span>
 12494 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 12495 |     | <span class='neutral'>        assembly {</span>
 12496 |     | <span class='neutral'>            mstore(0x00, m0)</span>
 12497 |     | <span class='neutral'>            mstore(0x20, m1)</span>
 12498 |     | <span class='neutral'>            mstore(0x40, m2)</span>
 12499 |     | <span class='neutral'>            mstore(0x60, m3)</span>
 12500 |     | <span class='neutral'>            mstore(0x80, m4)</span>
 12501 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
 12502 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
 12503 |     | <span class='neutral'>        }</span>
 12504 |     | <span class='neutral'>    }</span>
 12505 |     | <span class='neutral'></span>
 12506 |     | <span class='neutral'>    function log(bytes32 p0, uint256 p1, bool p2, bool p3) internal pure {</span>
 12507 |     | <span class='neutral'>        bytes32 m0;</span>
 12508 |     | <span class='neutral'>        bytes32 m1;</span>
 12509 |     | <span class='neutral'>        bytes32 m2;</span>
 12510 |     | <span class='neutral'>        bytes32 m3;</span>
 12511 |     | <span class='neutral'>        bytes32 m4;</span>
 12512 |     | <span class='neutral'>        bytes32 m5;</span>
 12513 |     | <span class='neutral'>        bytes32 m6;</span>
 12514 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 12515 |     | <span class='neutral'>        assembly {</span>
 12516 |     | <span class='neutral'>            function writeString(pos, w) {</span>
 12517 |     | <span class='neutral'>                let length := 0</span>
 12518 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
 12519 |     | <span class='neutral'>                mstore(pos, length)</span>
 12520 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
 12521 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
 12522 |     | <span class='neutral'>            }</span>
 12523 |     | <span class='neutral'>            m0 := mload(0x00)</span>
 12524 |     | <span class='neutral'>            m1 := mload(0x20)</span>
 12525 |     | <span class='neutral'>            m2 := mload(0x40)</span>
 12526 |     | <span class='neutral'>            m3 := mload(0x60)</span>
 12527 |     | <span class='neutral'>            m4 := mload(0x80)</span>
 12528 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
 12529 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
 12530 |     | <span class='neutral'>            // Selector of `log(string,uint256,bool,bool)`.</span>
 12531 |     | <span class='neutral'>            mstore(0x00, 0x354c36d6)</span>
 12532 |     | <span class='neutral'>            mstore(0x20, 0x80)</span>
 12533 |     | <span class='neutral'>            mstore(0x40, p1)</span>
 12534 |     | <span class='neutral'>            mstore(0x60, p2)</span>
 12535 |     | <span class='neutral'>            mstore(0x80, p3)</span>
 12536 |     | <span class='neutral'>            writeString(0xa0, p0)</span>
 12537 |     | <span class='neutral'>        }</span>
 12538 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xc4);</span>
 12539 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 12540 |     | <span class='neutral'>        assembly {</span>
 12541 |     | <span class='neutral'>            mstore(0x00, m0)</span>
 12542 |     | <span class='neutral'>            mstore(0x20, m1)</span>
 12543 |     | <span class='neutral'>            mstore(0x40, m2)</span>
 12544 |     | <span class='neutral'>            mstore(0x60, m3)</span>
 12545 |     | <span class='neutral'>            mstore(0x80, m4)</span>
 12546 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
 12547 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
 12548 |     | <span class='neutral'>        }</span>
 12549 |     | <span class='neutral'>    }</span>
 12550 |     | <span class='neutral'></span>
 12551 |     | <span class='neutral'>    function log(bytes32 p0, uint256 p1, bool p2, uint256 p3) internal pure {</span>
 12552 |     | <span class='neutral'>        bytes32 m0;</span>
 12553 |     | <span class='neutral'>        bytes32 m1;</span>
 12554 |     | <span class='neutral'>        bytes32 m2;</span>
 12555 |     | <span class='neutral'>        bytes32 m3;</span>
 12556 |     | <span class='neutral'>        bytes32 m4;</span>
 12557 |     | <span class='neutral'>        bytes32 m5;</span>
 12558 |     | <span class='neutral'>        bytes32 m6;</span>
 12559 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 12560 |     | <span class='neutral'>        assembly {</span>
 12561 |     | <span class='neutral'>            function writeString(pos, w) {</span>
 12562 |     | <span class='neutral'>                let length := 0</span>
 12563 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
 12564 |     | <span class='neutral'>                mstore(pos, length)</span>
 12565 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
 12566 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
 12567 |     | <span class='neutral'>            }</span>
 12568 |     | <span class='neutral'>            m0 := mload(0x00)</span>
 12569 |     | <span class='neutral'>            m1 := mload(0x20)</span>
 12570 |     | <span class='neutral'>            m2 := mload(0x40)</span>
 12571 |     | <span class='neutral'>            m3 := mload(0x60)</span>
 12572 |     | <span class='neutral'>            m4 := mload(0x80)</span>
 12573 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
 12574 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
 12575 |     | <span class='neutral'>            // Selector of `log(string,uint256,bool,uint256)`.</span>
 12576 |     | <span class='neutral'>            mstore(0x00, 0xe41b6f6f)</span>
 12577 |     | <span class='neutral'>            mstore(0x20, 0x80)</span>
 12578 |     | <span class='neutral'>            mstore(0x40, p1)</span>
 12579 |     | <span class='neutral'>            mstore(0x60, p2)</span>
 12580 |     | <span class='neutral'>            mstore(0x80, p3)</span>
 12581 |     | <span class='neutral'>            writeString(0xa0, p0)</span>
 12582 |     | <span class='neutral'>        }</span>
 12583 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xc4);</span>
 12584 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 12585 |     | <span class='neutral'>        assembly {</span>
 12586 |     | <span class='neutral'>            mstore(0x00, m0)</span>
 12587 |     | <span class='neutral'>            mstore(0x20, m1)</span>
 12588 |     | <span class='neutral'>            mstore(0x40, m2)</span>
 12589 |     | <span class='neutral'>            mstore(0x60, m3)</span>
 12590 |     | <span class='neutral'>            mstore(0x80, m4)</span>
 12591 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
 12592 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
 12593 |     | <span class='neutral'>        }</span>
 12594 |     | <span class='neutral'>    }</span>
 12595 |     | <span class='neutral'></span>
 12596 |     | <span class='neutral'>    function log(bytes32 p0, uint256 p1, bool p2, bytes32 p3) internal pure {</span>
 12597 |     | <span class='neutral'>        bytes32 m0;</span>
 12598 |     | <span class='neutral'>        bytes32 m1;</span>
 12599 |     | <span class='neutral'>        bytes32 m2;</span>
 12600 |     | <span class='neutral'>        bytes32 m3;</span>
 12601 |     | <span class='neutral'>        bytes32 m4;</span>
 12602 |     | <span class='neutral'>        bytes32 m5;</span>
 12603 |     | <span class='neutral'>        bytes32 m6;</span>
 12604 |     | <span class='neutral'>        bytes32 m7;</span>
 12605 |     | <span class='neutral'>        bytes32 m8;</span>
 12606 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 12607 |     | <span class='neutral'>        assembly {</span>
 12608 |     | <span class='neutral'>            function writeString(pos, w) {</span>
 12609 |     | <span class='neutral'>                let length := 0</span>
 12610 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
 12611 |     | <span class='neutral'>                mstore(pos, length)</span>
 12612 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
 12613 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
 12614 |     | <span class='neutral'>            }</span>
 12615 |     | <span class='neutral'>            m0 := mload(0x00)</span>
 12616 |     | <span class='neutral'>            m1 := mload(0x20)</span>
 12617 |     | <span class='neutral'>            m2 := mload(0x40)</span>
 12618 |     | <span class='neutral'>            m3 := mload(0x60)</span>
 12619 |     | <span class='neutral'>            m4 := mload(0x80)</span>
 12620 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
 12621 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
 12622 |     | <span class='neutral'>            m7 := mload(0xe0)</span>
 12623 |     | <span class='neutral'>            m8 := mload(0x100)</span>
 12624 |     | <span class='neutral'>            // Selector of `log(string,uint256,bool,string)`.</span>
 12625 |     | <span class='neutral'>            mstore(0x00, 0xabf73a98)</span>
 12626 |     | <span class='neutral'>            mstore(0x20, 0x80)</span>
 12627 |     | <span class='neutral'>            mstore(0x40, p1)</span>
 12628 |     | <span class='neutral'>            mstore(0x60, p2)</span>
 12629 |     | <span class='neutral'>            mstore(0x80, 0xc0)</span>
 12630 |     | <span class='neutral'>            writeString(0xa0, p0)</span>
 12631 |     | <span class='neutral'>            writeString(0xe0, p3)</span>
 12632 |     | <span class='neutral'>        }</span>
 12633 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x104);</span>
 12634 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 12635 |     | <span class='neutral'>        assembly {</span>
 12636 |     | <span class='neutral'>            mstore(0x00, m0)</span>
 12637 |     | <span class='neutral'>            mstore(0x20, m1)</span>
 12638 |     | <span class='neutral'>            mstore(0x40, m2)</span>
 12639 |     | <span class='neutral'>            mstore(0x60, m3)</span>
 12640 |     | <span class='neutral'>            mstore(0x80, m4)</span>
 12641 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
 12642 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
 12643 |     | <span class='neutral'>            mstore(0xe0, m7)</span>
 12644 |     | <span class='neutral'>            mstore(0x100, m8)</span>
 12645 |     | <span class='neutral'>        }</span>
 12646 |     | <span class='neutral'>    }</span>
 12647 |     | <span class='neutral'></span>
 12648 |     | <span class='neutral'>    function log(bytes32 p0, uint256 p1, uint256 p2, address p3) internal pure {</span>
 12649 |     | <span class='neutral'>        bytes32 m0;</span>
 12650 |     | <span class='neutral'>        bytes32 m1;</span>
 12651 |     | <span class='neutral'>        bytes32 m2;</span>
 12652 |     | <span class='neutral'>        bytes32 m3;</span>
 12653 |     | <span class='neutral'>        bytes32 m4;</span>
 12654 |     | <span class='neutral'>        bytes32 m5;</span>
 12655 |     | <span class='neutral'>        bytes32 m6;</span>
 12656 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 12657 |     | <span class='neutral'>        assembly {</span>
 12658 |     | <span class='neutral'>            function writeString(pos, w) {</span>
 12659 |     | <span class='neutral'>                let length := 0</span>
 12660 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
 12661 |     | <span class='neutral'>                mstore(pos, length)</span>
 12662 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
 12663 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
 12664 |     | <span class='neutral'>            }</span>
 12665 |     | <span class='neutral'>            m0 := mload(0x00)</span>
 12666 |     | <span class='neutral'>            m1 := mload(0x20)</span>
 12667 |     | <span class='neutral'>            m2 := mload(0x40)</span>
 12668 |     | <span class='neutral'>            m3 := mload(0x60)</span>
 12669 |     | <span class='neutral'>            m4 := mload(0x80)</span>
 12670 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
 12671 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
 12672 |     | <span class='neutral'>            // Selector of `log(string,uint256,uint256,address)`.</span>
 12673 |     | <span class='neutral'>            mstore(0x00, 0xe21de278)</span>
 12674 |     | <span class='neutral'>            mstore(0x20, 0x80)</span>
 12675 |     | <span class='neutral'>            mstore(0x40, p1)</span>
 12676 |     | <span class='neutral'>            mstore(0x60, p2)</span>
 12677 |     | <span class='neutral'>            mstore(0x80, p3)</span>
 12678 |     | <span class='neutral'>            writeString(0xa0, p0)</span>
 12679 |     | <span class='neutral'>        }</span>
 12680 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xc4);</span>
 12681 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 12682 |     | <span class='neutral'>        assembly {</span>
 12683 |     | <span class='neutral'>            mstore(0x00, m0)</span>
 12684 |     | <span class='neutral'>            mstore(0x20, m1)</span>
 12685 |     | <span class='neutral'>            mstore(0x40, m2)</span>
 12686 |     | <span class='neutral'>            mstore(0x60, m3)</span>
 12687 |     | <span class='neutral'>            mstore(0x80, m4)</span>
 12688 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
 12689 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
 12690 |     | <span class='neutral'>        }</span>
 12691 |     | <span class='neutral'>    }</span>
 12692 |     | <span class='neutral'></span>
 12693 |     | <span class='neutral'>    function log(bytes32 p0, uint256 p1, uint256 p2, bool p3) internal pure {</span>
 12694 |     | <span class='neutral'>        bytes32 m0;</span>
 12695 |     | <span class='neutral'>        bytes32 m1;</span>
 12696 |     | <span class='neutral'>        bytes32 m2;</span>
 12697 |     | <span class='neutral'>        bytes32 m3;</span>
 12698 |     | <span class='neutral'>        bytes32 m4;</span>
 12699 |     | <span class='neutral'>        bytes32 m5;</span>
 12700 |     | <span class='neutral'>        bytes32 m6;</span>
 12701 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 12702 |     | <span class='neutral'>        assembly {</span>
 12703 |     | <span class='neutral'>            function writeString(pos, w) {</span>
 12704 |     | <span class='neutral'>                let length := 0</span>
 12705 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
 12706 |     | <span class='neutral'>                mstore(pos, length)</span>
 12707 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
 12708 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
 12709 |     | <span class='neutral'>            }</span>
 12710 |     | <span class='neutral'>            m0 := mload(0x00)</span>
 12711 |     | <span class='neutral'>            m1 := mload(0x20)</span>
 12712 |     | <span class='neutral'>            m2 := mload(0x40)</span>
 12713 |     | <span class='neutral'>            m3 := mload(0x60)</span>
 12714 |     | <span class='neutral'>            m4 := mload(0x80)</span>
 12715 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
 12716 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
 12717 |     | <span class='neutral'>            // Selector of `log(string,uint256,uint256,bool)`.</span>
 12718 |     | <span class='neutral'>            mstore(0x00, 0x7626db92)</span>
 12719 |     | <span class='neutral'>            mstore(0x20, 0x80)</span>
 12720 |     | <span class='neutral'>            mstore(0x40, p1)</span>
 12721 |     | <span class='neutral'>            mstore(0x60, p2)</span>
 12722 |     | <span class='neutral'>            mstore(0x80, p3)</span>
 12723 |     | <span class='neutral'>            writeString(0xa0, p0)</span>
 12724 |     | <span class='neutral'>        }</span>
 12725 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xc4);</span>
 12726 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 12727 |     | <span class='neutral'>        assembly {</span>
 12728 |     | <span class='neutral'>            mstore(0x00, m0)</span>
 12729 |     | <span class='neutral'>            mstore(0x20, m1)</span>
 12730 |     | <span class='neutral'>            mstore(0x40, m2)</span>
 12731 |     | <span class='neutral'>            mstore(0x60, m3)</span>
 12732 |     | <span class='neutral'>            mstore(0x80, m4)</span>
 12733 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
 12734 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
 12735 |     | <span class='neutral'>        }</span>
 12736 |     | <span class='neutral'>    }</span>
 12737 |     | <span class='neutral'></span>
 12738 |     | <span class='neutral'>    function log(bytes32 p0, uint256 p1, uint256 p2, uint256 p3) internal pure {</span>
 12739 |     | <span class='neutral'>        bytes32 m0;</span>
 12740 |     | <span class='neutral'>        bytes32 m1;</span>
 12741 |     | <span class='neutral'>        bytes32 m2;</span>
 12742 |     | <span class='neutral'>        bytes32 m3;</span>
 12743 |     | <span class='neutral'>        bytes32 m4;</span>
 12744 |     | <span class='neutral'>        bytes32 m5;</span>
 12745 |     | <span class='neutral'>        bytes32 m6;</span>
 12746 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 12747 |     | <span class='neutral'>        assembly {</span>
 12748 |     | <span class='neutral'>            function writeString(pos, w) {</span>
 12749 |     | <span class='neutral'>                let length := 0</span>
 12750 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
 12751 |     | <span class='neutral'>                mstore(pos, length)</span>
 12752 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
 12753 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
 12754 |     | <span class='neutral'>            }</span>
 12755 |     | <span class='neutral'>            m0 := mload(0x00)</span>
 12756 |     | <span class='neutral'>            m1 := mload(0x20)</span>
 12757 |     | <span class='neutral'>            m2 := mload(0x40)</span>
 12758 |     | <span class='neutral'>            m3 := mload(0x60)</span>
 12759 |     | <span class='neutral'>            m4 := mload(0x80)</span>
 12760 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
 12761 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
 12762 |     | <span class='neutral'>            // Selector of `log(string,uint256,uint256,uint256)`.</span>
 12763 |     | <span class='neutral'>            mstore(0x00, 0xa7a87853)</span>
 12764 |     | <span class='neutral'>            mstore(0x20, 0x80)</span>
 12765 |     | <span class='neutral'>            mstore(0x40, p1)</span>
 12766 |     | <span class='neutral'>            mstore(0x60, p2)</span>
 12767 |     | <span class='neutral'>            mstore(0x80, p3)</span>
 12768 |     | <span class='neutral'>            writeString(0xa0, p0)</span>
 12769 |     | <span class='neutral'>        }</span>
 12770 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xc4);</span>
 12771 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 12772 |     | <span class='neutral'>        assembly {</span>
 12773 |     | <span class='neutral'>            mstore(0x00, m0)</span>
 12774 |     | <span class='neutral'>            mstore(0x20, m1)</span>
 12775 |     | <span class='neutral'>            mstore(0x40, m2)</span>
 12776 |     | <span class='neutral'>            mstore(0x60, m3)</span>
 12777 |     | <span class='neutral'>            mstore(0x80, m4)</span>
 12778 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
 12779 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
 12780 |     | <span class='neutral'>        }</span>
 12781 |     | <span class='neutral'>    }</span>
 12782 |     | <span class='neutral'></span>
 12783 |     | <span class='neutral'>    function log(bytes32 p0, uint256 p1, uint256 p2, bytes32 p3) internal pure {</span>
 12784 |     | <span class='neutral'>        bytes32 m0;</span>
 12785 |     | <span class='neutral'>        bytes32 m1;</span>
 12786 |     | <span class='neutral'>        bytes32 m2;</span>
 12787 |     | <span class='neutral'>        bytes32 m3;</span>
 12788 |     | <span class='neutral'>        bytes32 m4;</span>
 12789 |     | <span class='neutral'>        bytes32 m5;</span>
 12790 |     | <span class='neutral'>        bytes32 m6;</span>
 12791 |     | <span class='neutral'>        bytes32 m7;</span>
 12792 |     | <span class='neutral'>        bytes32 m8;</span>
 12793 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 12794 |     | <span class='neutral'>        assembly {</span>
 12795 |     | <span class='neutral'>            function writeString(pos, w) {</span>
 12796 |     | <span class='neutral'>                let length := 0</span>
 12797 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
 12798 |     | <span class='neutral'>                mstore(pos, length)</span>
 12799 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
 12800 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
 12801 |     | <span class='neutral'>            }</span>
 12802 |     | <span class='neutral'>            m0 := mload(0x00)</span>
 12803 |     | <span class='neutral'>            m1 := mload(0x20)</span>
 12804 |     | <span class='neutral'>            m2 := mload(0x40)</span>
 12805 |     | <span class='neutral'>            m3 := mload(0x60)</span>
 12806 |     | <span class='neutral'>            m4 := mload(0x80)</span>
 12807 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
 12808 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
 12809 |     | <span class='neutral'>            m7 := mload(0xe0)</span>
 12810 |     | <span class='neutral'>            m8 := mload(0x100)</span>
 12811 |     | <span class='neutral'>            // Selector of `log(string,uint256,uint256,string)`.</span>
 12812 |     | <span class='neutral'>            mstore(0x00, 0x854b3496)</span>
 12813 |     | <span class='neutral'>            mstore(0x20, 0x80)</span>
 12814 |     | <span class='neutral'>            mstore(0x40, p1)</span>
 12815 |     | <span class='neutral'>            mstore(0x60, p2)</span>
 12816 |     | <span class='neutral'>            mstore(0x80, 0xc0)</span>
 12817 |     | <span class='neutral'>            writeString(0xa0, p0)</span>
 12818 |     | <span class='neutral'>            writeString(0xe0, p3)</span>
 12819 |     | <span class='neutral'>        }</span>
 12820 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x104);</span>
 12821 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 12822 |     | <span class='neutral'>        assembly {</span>
 12823 |     | <span class='neutral'>            mstore(0x00, m0)</span>
 12824 |     | <span class='neutral'>            mstore(0x20, m1)</span>
 12825 |     | <span class='neutral'>            mstore(0x40, m2)</span>
 12826 |     | <span class='neutral'>            mstore(0x60, m3)</span>
 12827 |     | <span class='neutral'>            mstore(0x80, m4)</span>
 12828 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
 12829 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
 12830 |     | <span class='neutral'>            mstore(0xe0, m7)</span>
 12831 |     | <span class='neutral'>            mstore(0x100, m8)</span>
 12832 |     | <span class='neutral'>        }</span>
 12833 |     | <span class='neutral'>    }</span>
 12834 |     | <span class='neutral'></span>
 12835 |     | <span class='neutral'>    function log(bytes32 p0, uint256 p1, bytes32 p2, address p3) internal pure {</span>
 12836 |     | <span class='neutral'>        bytes32 m0;</span>
 12837 |     | <span class='neutral'>        bytes32 m1;</span>
 12838 |     | <span class='neutral'>        bytes32 m2;</span>
 12839 |     | <span class='neutral'>        bytes32 m3;</span>
 12840 |     | <span class='neutral'>        bytes32 m4;</span>
 12841 |     | <span class='neutral'>        bytes32 m5;</span>
 12842 |     | <span class='neutral'>        bytes32 m6;</span>
 12843 |     | <span class='neutral'>        bytes32 m7;</span>
 12844 |     | <span class='neutral'>        bytes32 m8;</span>
 12845 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 12846 |     | <span class='neutral'>        assembly {</span>
 12847 |     | <span class='neutral'>            function writeString(pos, w) {</span>
 12848 |     | <span class='neutral'>                let length := 0</span>
 12849 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
 12850 |     | <span class='neutral'>                mstore(pos, length)</span>
 12851 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
 12852 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
 12853 |     | <span class='neutral'>            }</span>
 12854 |     | <span class='neutral'>            m0 := mload(0x00)</span>
 12855 |     | <span class='neutral'>            m1 := mload(0x20)</span>
 12856 |     | <span class='neutral'>            m2 := mload(0x40)</span>
 12857 |     | <span class='neutral'>            m3 := mload(0x60)</span>
 12858 |     | <span class='neutral'>            m4 := mload(0x80)</span>
 12859 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
 12860 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
 12861 |     | <span class='neutral'>            m7 := mload(0xe0)</span>
 12862 |     | <span class='neutral'>            m8 := mload(0x100)</span>
 12863 |     | <span class='neutral'>            // Selector of `log(string,uint256,string,address)`.</span>
 12864 |     | <span class='neutral'>            mstore(0x00, 0x7c4632a4)</span>
 12865 |     | <span class='neutral'>            mstore(0x20, 0x80)</span>
 12866 |     | <span class='neutral'>            mstore(0x40, p1)</span>
 12867 |     | <span class='neutral'>            mstore(0x60, 0xc0)</span>
 12868 |     | <span class='neutral'>            mstore(0x80, p3)</span>
 12869 |     | <span class='neutral'>            writeString(0xa0, p0)</span>
 12870 |     | <span class='neutral'>            writeString(0xe0, p2)</span>
 12871 |     | <span class='neutral'>        }</span>
 12872 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x104);</span>
 12873 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 12874 |     | <span class='neutral'>        assembly {</span>
 12875 |     | <span class='neutral'>            mstore(0x00, m0)</span>
 12876 |     | <span class='neutral'>            mstore(0x20, m1)</span>
 12877 |     | <span class='neutral'>            mstore(0x40, m2)</span>
 12878 |     | <span class='neutral'>            mstore(0x60, m3)</span>
 12879 |     | <span class='neutral'>            mstore(0x80, m4)</span>
 12880 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
 12881 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
 12882 |     | <span class='neutral'>            mstore(0xe0, m7)</span>
 12883 |     | <span class='neutral'>            mstore(0x100, m8)</span>
 12884 |     | <span class='neutral'>        }</span>
 12885 |     | <span class='neutral'>    }</span>
 12886 |     | <span class='neutral'></span>
 12887 |     | <span class='neutral'>    function log(bytes32 p0, uint256 p1, bytes32 p2, bool p3) internal pure {</span>
 12888 |     | <span class='neutral'>        bytes32 m0;</span>
 12889 |     | <span class='neutral'>        bytes32 m1;</span>
 12890 |     | <span class='neutral'>        bytes32 m2;</span>
 12891 |     | <span class='neutral'>        bytes32 m3;</span>
 12892 |     | <span class='neutral'>        bytes32 m4;</span>
 12893 |     | <span class='neutral'>        bytes32 m5;</span>
 12894 |     | <span class='neutral'>        bytes32 m6;</span>
 12895 |     | <span class='neutral'>        bytes32 m7;</span>
 12896 |     | <span class='neutral'>        bytes32 m8;</span>
 12897 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 12898 |     | <span class='neutral'>        assembly {</span>
 12899 |     | <span class='neutral'>            function writeString(pos, w) {</span>
 12900 |     | <span class='neutral'>                let length := 0</span>
 12901 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
 12902 |     | <span class='neutral'>                mstore(pos, length)</span>
 12903 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
 12904 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
 12905 |     | <span class='neutral'>            }</span>
 12906 |     | <span class='neutral'>            m0 := mload(0x00)</span>
 12907 |     | <span class='neutral'>            m1 := mload(0x20)</span>
 12908 |     | <span class='neutral'>            m2 := mload(0x40)</span>
 12909 |     | <span class='neutral'>            m3 := mload(0x60)</span>
 12910 |     | <span class='neutral'>            m4 := mload(0x80)</span>
 12911 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
 12912 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
 12913 |     | <span class='neutral'>            m7 := mload(0xe0)</span>
 12914 |     | <span class='neutral'>            m8 := mload(0x100)</span>
 12915 |     | <span class='neutral'>            // Selector of `log(string,uint256,string,bool)`.</span>
 12916 |     | <span class='neutral'>            mstore(0x00, 0x7d24491d)</span>
 12917 |     | <span class='neutral'>            mstore(0x20, 0x80)</span>
 12918 |     | <span class='neutral'>            mstore(0x40, p1)</span>
 12919 |     | <span class='neutral'>            mstore(0x60, 0xc0)</span>
 12920 |     | <span class='neutral'>            mstore(0x80, p3)</span>
 12921 |     | <span class='neutral'>            writeString(0xa0, p0)</span>
 12922 |     | <span class='neutral'>            writeString(0xe0, p2)</span>
 12923 |     | <span class='neutral'>        }</span>
 12924 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x104);</span>
 12925 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 12926 |     | <span class='neutral'>        assembly {</span>
 12927 |     | <span class='neutral'>            mstore(0x00, m0)</span>
 12928 |     | <span class='neutral'>            mstore(0x20, m1)</span>
 12929 |     | <span class='neutral'>            mstore(0x40, m2)</span>
 12930 |     | <span class='neutral'>            mstore(0x60, m3)</span>
 12931 |     | <span class='neutral'>            mstore(0x80, m4)</span>
 12932 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
 12933 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
 12934 |     | <span class='neutral'>            mstore(0xe0, m7)</span>
 12935 |     | <span class='neutral'>            mstore(0x100, m8)</span>
 12936 |     | <span class='neutral'>        }</span>
 12937 |     | <span class='neutral'>    }</span>
 12938 |     | <span class='neutral'></span>
 12939 |     | <span class='neutral'>    function log(bytes32 p0, uint256 p1, bytes32 p2, uint256 p3) internal pure {</span>
 12940 |     | <span class='neutral'>        bytes32 m0;</span>
 12941 |     | <span class='neutral'>        bytes32 m1;</span>
 12942 |     | <span class='neutral'>        bytes32 m2;</span>
 12943 |     | <span class='neutral'>        bytes32 m3;</span>
 12944 |     | <span class='neutral'>        bytes32 m4;</span>
 12945 |     | <span class='neutral'>        bytes32 m5;</span>
 12946 |     | <span class='neutral'>        bytes32 m6;</span>
 12947 |     | <span class='neutral'>        bytes32 m7;</span>
 12948 |     | <span class='neutral'>        bytes32 m8;</span>
 12949 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 12950 |     | <span class='neutral'>        assembly {</span>
 12951 |     | <span class='neutral'>            function writeString(pos, w) {</span>
 12952 |     | <span class='neutral'>                let length := 0</span>
 12953 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
 12954 |     | <span class='neutral'>                mstore(pos, length)</span>
 12955 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
 12956 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
 12957 |     | <span class='neutral'>            }</span>
 12958 |     | <span class='neutral'>            m0 := mload(0x00)</span>
 12959 |     | <span class='neutral'>            m1 := mload(0x20)</span>
 12960 |     | <span class='neutral'>            m2 := mload(0x40)</span>
 12961 |     | <span class='neutral'>            m3 := mload(0x60)</span>
 12962 |     | <span class='neutral'>            m4 := mload(0x80)</span>
 12963 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
 12964 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
 12965 |     | <span class='neutral'>            m7 := mload(0xe0)</span>
 12966 |     | <span class='neutral'>            m8 := mload(0x100)</span>
 12967 |     | <span class='neutral'>            // Selector of `log(string,uint256,string,uint256)`.</span>
 12968 |     | <span class='neutral'>            mstore(0x00, 0xc67ea9d1)</span>
 12969 |     | <span class='neutral'>            mstore(0x20, 0x80)</span>
 12970 |     | <span class='neutral'>            mstore(0x40, p1)</span>
 12971 |     | <span class='neutral'>            mstore(0x60, 0xc0)</span>
 12972 |     | <span class='neutral'>            mstore(0x80, p3)</span>
 12973 |     | <span class='neutral'>            writeString(0xa0, p0)</span>
 12974 |     | <span class='neutral'>            writeString(0xe0, p2)</span>
 12975 |     | <span class='neutral'>        }</span>
 12976 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x104);</span>
 12977 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 12978 |     | <span class='neutral'>        assembly {</span>
 12979 |     | <span class='neutral'>            mstore(0x00, m0)</span>
 12980 |     | <span class='neutral'>            mstore(0x20, m1)</span>
 12981 |     | <span class='neutral'>            mstore(0x40, m2)</span>
 12982 |     | <span class='neutral'>            mstore(0x60, m3)</span>
 12983 |     | <span class='neutral'>            mstore(0x80, m4)</span>
 12984 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
 12985 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
 12986 |     | <span class='neutral'>            mstore(0xe0, m7)</span>
 12987 |     | <span class='neutral'>            mstore(0x100, m8)</span>
 12988 |     | <span class='neutral'>        }</span>
 12989 |     | <span class='neutral'>    }</span>
 12990 |     | <span class='neutral'></span>
 12991 |     | <span class='neutral'>    function log(bytes32 p0, uint256 p1, bytes32 p2, bytes32 p3) internal pure {</span>
 12992 |     | <span class='neutral'>        bytes32 m0;</span>
 12993 |     | <span class='neutral'>        bytes32 m1;</span>
 12994 |     | <span class='neutral'>        bytes32 m2;</span>
 12995 |     | <span class='neutral'>        bytes32 m3;</span>
 12996 |     | <span class='neutral'>        bytes32 m4;</span>
 12997 |     | <span class='neutral'>        bytes32 m5;</span>
 12998 |     | <span class='neutral'>        bytes32 m6;</span>
 12999 |     | <span class='neutral'>        bytes32 m7;</span>
 13000 |     | <span class='neutral'>        bytes32 m8;</span>
 13001 |     | <span class='neutral'>        bytes32 m9;</span>
 13002 |     | <span class='neutral'>        bytes32 m10;</span>
 13003 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 13004 |     | <span class='neutral'>        assembly {</span>
 13005 |     | <span class='neutral'>            function writeString(pos, w) {</span>
 13006 |     | <span class='neutral'>                let length := 0</span>
 13007 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
 13008 |     | <span class='neutral'>                mstore(pos, length)</span>
 13009 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
 13010 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
 13011 |     | <span class='neutral'>            }</span>
 13012 |     | <span class='neutral'>            m0 := mload(0x00)</span>
 13013 |     | <span class='neutral'>            m1 := mload(0x20)</span>
 13014 |     | <span class='neutral'>            m2 := mload(0x40)</span>
 13015 |     | <span class='neutral'>            m3 := mload(0x60)</span>
 13016 |     | <span class='neutral'>            m4 := mload(0x80)</span>
 13017 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
 13018 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
 13019 |     | <span class='neutral'>            m7 := mload(0xe0)</span>
 13020 |     | <span class='neutral'>            m8 := mload(0x100)</span>
 13021 |     | <span class='neutral'>            m9 := mload(0x120)</span>
 13022 |     | <span class='neutral'>            m10 := mload(0x140)</span>
 13023 |     | <span class='neutral'>            // Selector of `log(string,uint256,string,string)`.</span>
 13024 |     | <span class='neutral'>            mstore(0x00, 0x5ab84e1f)</span>
 13025 |     | <span class='neutral'>            mstore(0x20, 0x80)</span>
 13026 |     | <span class='neutral'>            mstore(0x40, p1)</span>
 13027 |     | <span class='neutral'>            mstore(0x60, 0xc0)</span>
 13028 |     | <span class='neutral'>            mstore(0x80, 0x100)</span>
 13029 |     | <span class='neutral'>            writeString(0xa0, p0)</span>
 13030 |     | <span class='neutral'>            writeString(0xe0, p2)</span>
 13031 |     | <span class='neutral'>            writeString(0x120, p3)</span>
 13032 |     | <span class='neutral'>        }</span>
 13033 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x144);</span>
 13034 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 13035 |     | <span class='neutral'>        assembly {</span>
 13036 |     | <span class='neutral'>            mstore(0x00, m0)</span>
 13037 |     | <span class='neutral'>            mstore(0x20, m1)</span>
 13038 |     | <span class='neutral'>            mstore(0x40, m2)</span>
 13039 |     | <span class='neutral'>            mstore(0x60, m3)</span>
 13040 |     | <span class='neutral'>            mstore(0x80, m4)</span>
 13041 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
 13042 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
 13043 |     | <span class='neutral'>            mstore(0xe0, m7)</span>
 13044 |     | <span class='neutral'>            mstore(0x100, m8)</span>
 13045 |     | <span class='neutral'>            mstore(0x120, m9)</span>
 13046 |     | <span class='neutral'>            mstore(0x140, m10)</span>
 13047 |     | <span class='neutral'>        }</span>
 13048 |     | <span class='neutral'>    }</span>
 13049 |     | <span class='neutral'></span>
 13050 |     | <span class='neutral'>    function log(bytes32 p0, bytes32 p1, address p2, address p3) internal pure {</span>
 13051 |     | <span class='neutral'>        bytes32 m0;</span>
 13052 |     | <span class='neutral'>        bytes32 m1;</span>
 13053 |     | <span class='neutral'>        bytes32 m2;</span>
 13054 |     | <span class='neutral'>        bytes32 m3;</span>
 13055 |     | <span class='neutral'>        bytes32 m4;</span>
 13056 |     | <span class='neutral'>        bytes32 m5;</span>
 13057 |     | <span class='neutral'>        bytes32 m6;</span>
 13058 |     | <span class='neutral'>        bytes32 m7;</span>
 13059 |     | <span class='neutral'>        bytes32 m8;</span>
 13060 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 13061 |     | <span class='neutral'>        assembly {</span>
 13062 |     | <span class='neutral'>            function writeString(pos, w) {</span>
 13063 |     | <span class='neutral'>                let length := 0</span>
 13064 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
 13065 |     | <span class='neutral'>                mstore(pos, length)</span>
 13066 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
 13067 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
 13068 |     | <span class='neutral'>            }</span>
 13069 |     | <span class='neutral'>            m0 := mload(0x00)</span>
 13070 |     | <span class='neutral'>            m1 := mload(0x20)</span>
 13071 |     | <span class='neutral'>            m2 := mload(0x40)</span>
 13072 |     | <span class='neutral'>            m3 := mload(0x60)</span>
 13073 |     | <span class='neutral'>            m4 := mload(0x80)</span>
 13074 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
 13075 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
 13076 |     | <span class='neutral'>            m7 := mload(0xe0)</span>
 13077 |     | <span class='neutral'>            m8 := mload(0x100)</span>
 13078 |     | <span class='neutral'>            // Selector of `log(string,string,address,address)`.</span>
 13079 |     | <span class='neutral'>            mstore(0x00, 0x439c7bef)</span>
 13080 |     | <span class='neutral'>            mstore(0x20, 0x80)</span>
 13081 |     | <span class='neutral'>            mstore(0x40, 0xc0)</span>
 13082 |     | <span class='neutral'>            mstore(0x60, p2)</span>
 13083 |     | <span class='neutral'>            mstore(0x80, p3)</span>
 13084 |     | <span class='neutral'>            writeString(0xa0, p0)</span>
 13085 |     | <span class='neutral'>            writeString(0xe0, p1)</span>
 13086 |     | <span class='neutral'>        }</span>
 13087 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x104);</span>
 13088 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 13089 |     | <span class='neutral'>        assembly {</span>
 13090 |     | <span class='neutral'>            mstore(0x00, m0)</span>
 13091 |     | <span class='neutral'>            mstore(0x20, m1)</span>
 13092 |     | <span class='neutral'>            mstore(0x40, m2)</span>
 13093 |     | <span class='neutral'>            mstore(0x60, m3)</span>
 13094 |     | <span class='neutral'>            mstore(0x80, m4)</span>
 13095 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
 13096 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
 13097 |     | <span class='neutral'>            mstore(0xe0, m7)</span>
 13098 |     | <span class='neutral'>            mstore(0x100, m8)</span>
 13099 |     | <span class='neutral'>        }</span>
 13100 |     | <span class='neutral'>    }</span>
 13101 |     | <span class='neutral'></span>
 13102 |     | <span class='neutral'>    function log(bytes32 p0, bytes32 p1, address p2, bool p3) internal pure {</span>
 13103 |     | <span class='neutral'>        bytes32 m0;</span>
 13104 |     | <span class='neutral'>        bytes32 m1;</span>
 13105 |     | <span class='neutral'>        bytes32 m2;</span>
 13106 |     | <span class='neutral'>        bytes32 m3;</span>
 13107 |     | <span class='neutral'>        bytes32 m4;</span>
 13108 |     | <span class='neutral'>        bytes32 m5;</span>
 13109 |     | <span class='neutral'>        bytes32 m6;</span>
 13110 |     | <span class='neutral'>        bytes32 m7;</span>
 13111 |     | <span class='neutral'>        bytes32 m8;</span>
 13112 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 13113 |     | <span class='neutral'>        assembly {</span>
 13114 |     | <span class='neutral'>            function writeString(pos, w) {</span>
 13115 |     | <span class='neutral'>                let length := 0</span>
 13116 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
 13117 |     | <span class='neutral'>                mstore(pos, length)</span>
 13118 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
 13119 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
 13120 |     | <span class='neutral'>            }</span>
 13121 |     | <span class='neutral'>            m0 := mload(0x00)</span>
 13122 |     | <span class='neutral'>            m1 := mload(0x20)</span>
 13123 |     | <span class='neutral'>            m2 := mload(0x40)</span>
 13124 |     | <span class='neutral'>            m3 := mload(0x60)</span>
 13125 |     | <span class='neutral'>            m4 := mload(0x80)</span>
 13126 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
 13127 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
 13128 |     | <span class='neutral'>            m7 := mload(0xe0)</span>
 13129 |     | <span class='neutral'>            m8 := mload(0x100)</span>
 13130 |     | <span class='neutral'>            // Selector of `log(string,string,address,bool)`.</span>
 13131 |     | <span class='neutral'>            mstore(0x00, 0x5ccd4e37)</span>
 13132 |     | <span class='neutral'>            mstore(0x20, 0x80)</span>
 13133 |     | <span class='neutral'>            mstore(0x40, 0xc0)</span>
 13134 |     | <span class='neutral'>            mstore(0x60, p2)</span>
 13135 |     | <span class='neutral'>            mstore(0x80, p3)</span>
 13136 |     | <span class='neutral'>            writeString(0xa0, p0)</span>
 13137 |     | <span class='neutral'>            writeString(0xe0, p1)</span>
 13138 |     | <span class='neutral'>        }</span>
 13139 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x104);</span>
 13140 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 13141 |     | <span class='neutral'>        assembly {</span>
 13142 |     | <span class='neutral'>            mstore(0x00, m0)</span>
 13143 |     | <span class='neutral'>            mstore(0x20, m1)</span>
 13144 |     | <span class='neutral'>            mstore(0x40, m2)</span>
 13145 |     | <span class='neutral'>            mstore(0x60, m3)</span>
 13146 |     | <span class='neutral'>            mstore(0x80, m4)</span>
 13147 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
 13148 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
 13149 |     | <span class='neutral'>            mstore(0xe0, m7)</span>
 13150 |     | <span class='neutral'>            mstore(0x100, m8)</span>
 13151 |     | <span class='neutral'>        }</span>
 13152 |     | <span class='neutral'>    }</span>
 13153 |     | <span class='neutral'></span>
 13154 |     | <span class='neutral'>    function log(bytes32 p0, bytes32 p1, address p2, uint256 p3) internal pure {</span>
 13155 |     | <span class='neutral'>        bytes32 m0;</span>
 13156 |     | <span class='neutral'>        bytes32 m1;</span>
 13157 |     | <span class='neutral'>        bytes32 m2;</span>
 13158 |     | <span class='neutral'>        bytes32 m3;</span>
 13159 |     | <span class='neutral'>        bytes32 m4;</span>
 13160 |     | <span class='neutral'>        bytes32 m5;</span>
 13161 |     | <span class='neutral'>        bytes32 m6;</span>
 13162 |     | <span class='neutral'>        bytes32 m7;</span>
 13163 |     | <span class='neutral'>        bytes32 m8;</span>
 13164 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 13165 |     | <span class='neutral'>        assembly {</span>
 13166 |     | <span class='neutral'>            function writeString(pos, w) {</span>
 13167 |     | <span class='neutral'>                let length := 0</span>
 13168 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
 13169 |     | <span class='neutral'>                mstore(pos, length)</span>
 13170 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
 13171 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
 13172 |     | <span class='neutral'>            }</span>
 13173 |     | <span class='neutral'>            m0 := mload(0x00)</span>
 13174 |     | <span class='neutral'>            m1 := mload(0x20)</span>
 13175 |     | <span class='neutral'>            m2 := mload(0x40)</span>
 13176 |     | <span class='neutral'>            m3 := mload(0x60)</span>
 13177 |     | <span class='neutral'>            m4 := mload(0x80)</span>
 13178 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
 13179 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
 13180 |     | <span class='neutral'>            m7 := mload(0xe0)</span>
 13181 |     | <span class='neutral'>            m8 := mload(0x100)</span>
 13182 |     | <span class='neutral'>            // Selector of `log(string,string,address,uint256)`.</span>
 13183 |     | <span class='neutral'>            mstore(0x00, 0x7cc3c607)</span>
 13184 |     | <span class='neutral'>            mstore(0x20, 0x80)</span>
 13185 |     | <span class='neutral'>            mstore(0x40, 0xc0)</span>
 13186 |     | <span class='neutral'>            mstore(0x60, p2)</span>
 13187 |     | <span class='neutral'>            mstore(0x80, p3)</span>
 13188 |     | <span class='neutral'>            writeString(0xa0, p0)</span>
 13189 |     | <span class='neutral'>            writeString(0xe0, p1)</span>
 13190 |     | <span class='neutral'>        }</span>
 13191 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x104);</span>
 13192 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 13193 |     | <span class='neutral'>        assembly {</span>
 13194 |     | <span class='neutral'>            mstore(0x00, m0)</span>
 13195 |     | <span class='neutral'>            mstore(0x20, m1)</span>
 13196 |     | <span class='neutral'>            mstore(0x40, m2)</span>
 13197 |     | <span class='neutral'>            mstore(0x60, m3)</span>
 13198 |     | <span class='neutral'>            mstore(0x80, m4)</span>
 13199 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
 13200 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
 13201 |     | <span class='neutral'>            mstore(0xe0, m7)</span>
 13202 |     | <span class='neutral'>            mstore(0x100, m8)</span>
 13203 |     | <span class='neutral'>        }</span>
 13204 |     | <span class='neutral'>    }</span>
 13205 |     | <span class='neutral'></span>
 13206 |     | <span class='neutral'>    function log(bytes32 p0, bytes32 p1, address p2, bytes32 p3) internal pure {</span>
 13207 |     | <span class='neutral'>        bytes32 m0;</span>
 13208 |     | <span class='neutral'>        bytes32 m1;</span>
 13209 |     | <span class='neutral'>        bytes32 m2;</span>
 13210 |     | <span class='neutral'>        bytes32 m3;</span>
 13211 |     | <span class='neutral'>        bytes32 m4;</span>
 13212 |     | <span class='neutral'>        bytes32 m5;</span>
 13213 |     | <span class='neutral'>        bytes32 m6;</span>
 13214 |     | <span class='neutral'>        bytes32 m7;</span>
 13215 |     | <span class='neutral'>        bytes32 m8;</span>
 13216 |     | <span class='neutral'>        bytes32 m9;</span>
 13217 |     | <span class='neutral'>        bytes32 m10;</span>
 13218 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 13219 |     | <span class='neutral'>        assembly {</span>
 13220 |     | <span class='neutral'>            function writeString(pos, w) {</span>
 13221 |     | <span class='neutral'>                let length := 0</span>
 13222 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
 13223 |     | <span class='neutral'>                mstore(pos, length)</span>
 13224 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
 13225 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
 13226 |     | <span class='neutral'>            }</span>
 13227 |     | <span class='neutral'>            m0 := mload(0x00)</span>
 13228 |     | <span class='neutral'>            m1 := mload(0x20)</span>
 13229 |     | <span class='neutral'>            m2 := mload(0x40)</span>
 13230 |     | <span class='neutral'>            m3 := mload(0x60)</span>
 13231 |     | <span class='neutral'>            m4 := mload(0x80)</span>
 13232 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
 13233 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
 13234 |     | <span class='neutral'>            m7 := mload(0xe0)</span>
 13235 |     | <span class='neutral'>            m8 := mload(0x100)</span>
 13236 |     | <span class='neutral'>            m9 := mload(0x120)</span>
 13237 |     | <span class='neutral'>            m10 := mload(0x140)</span>
 13238 |     | <span class='neutral'>            // Selector of `log(string,string,address,string)`.</span>
 13239 |     | <span class='neutral'>            mstore(0x00, 0xeb1bff80)</span>
 13240 |     | <span class='neutral'>            mstore(0x20, 0x80)</span>
 13241 |     | <span class='neutral'>            mstore(0x40, 0xc0)</span>
 13242 |     | <span class='neutral'>            mstore(0x60, p2)</span>
 13243 |     | <span class='neutral'>            mstore(0x80, 0x100)</span>
 13244 |     | <span class='neutral'>            writeString(0xa0, p0)</span>
 13245 |     | <span class='neutral'>            writeString(0xe0, p1)</span>
 13246 |     | <span class='neutral'>            writeString(0x120, p3)</span>
 13247 |     | <span class='neutral'>        }</span>
 13248 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x144);</span>
 13249 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 13250 |     | <span class='neutral'>        assembly {</span>
 13251 |     | <span class='neutral'>            mstore(0x00, m0)</span>
 13252 |     | <span class='neutral'>            mstore(0x20, m1)</span>
 13253 |     | <span class='neutral'>            mstore(0x40, m2)</span>
 13254 |     | <span class='neutral'>            mstore(0x60, m3)</span>
 13255 |     | <span class='neutral'>            mstore(0x80, m4)</span>
 13256 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
 13257 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
 13258 |     | <span class='neutral'>            mstore(0xe0, m7)</span>
 13259 |     | <span class='neutral'>            mstore(0x100, m8)</span>
 13260 |     | <span class='neutral'>            mstore(0x120, m9)</span>
 13261 |     | <span class='neutral'>            mstore(0x140, m10)</span>
 13262 |     | <span class='neutral'>        }</span>
 13263 |     | <span class='neutral'>    }</span>
 13264 |     | <span class='neutral'></span>
 13265 |     | <span class='neutral'>    function log(bytes32 p0, bytes32 p1, bool p2, address p3) internal pure {</span>
 13266 |     | <span class='neutral'>        bytes32 m0;</span>
 13267 |     | <span class='neutral'>        bytes32 m1;</span>
 13268 |     | <span class='neutral'>        bytes32 m2;</span>
 13269 |     | <span class='neutral'>        bytes32 m3;</span>
 13270 |     | <span class='neutral'>        bytes32 m4;</span>
 13271 |     | <span class='neutral'>        bytes32 m5;</span>
 13272 |     | <span class='neutral'>        bytes32 m6;</span>
 13273 |     | <span class='neutral'>        bytes32 m7;</span>
 13274 |     | <span class='neutral'>        bytes32 m8;</span>
 13275 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 13276 |     | <span class='neutral'>        assembly {</span>
 13277 |     | <span class='neutral'>            function writeString(pos, w) {</span>
 13278 |     | <span class='neutral'>                let length := 0</span>
 13279 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
 13280 |     | <span class='neutral'>                mstore(pos, length)</span>
 13281 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
 13282 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
 13283 |     | <span class='neutral'>            }</span>
 13284 |     | <span class='neutral'>            m0 := mload(0x00)</span>
 13285 |     | <span class='neutral'>            m1 := mload(0x20)</span>
 13286 |     | <span class='neutral'>            m2 := mload(0x40)</span>
 13287 |     | <span class='neutral'>            m3 := mload(0x60)</span>
 13288 |     | <span class='neutral'>            m4 := mload(0x80)</span>
 13289 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
 13290 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
 13291 |     | <span class='neutral'>            m7 := mload(0xe0)</span>
 13292 |     | <span class='neutral'>            m8 := mload(0x100)</span>
 13293 |     | <span class='neutral'>            // Selector of `log(string,string,bool,address)`.</span>
 13294 |     | <span class='neutral'>            mstore(0x00, 0xc371c7db)</span>
 13295 |     | <span class='neutral'>            mstore(0x20, 0x80)</span>
 13296 |     | <span class='neutral'>            mstore(0x40, 0xc0)</span>
 13297 |     | <span class='neutral'>            mstore(0x60, p2)</span>
 13298 |     | <span class='neutral'>            mstore(0x80, p3)</span>
 13299 |     | <span class='neutral'>            writeString(0xa0, p0)</span>
 13300 |     | <span class='neutral'>            writeString(0xe0, p1)</span>
 13301 |     | <span class='neutral'>        }</span>
 13302 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x104);</span>
 13303 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 13304 |     | <span class='neutral'>        assembly {</span>
 13305 |     | <span class='neutral'>            mstore(0x00, m0)</span>
 13306 |     | <span class='neutral'>            mstore(0x20, m1)</span>
 13307 |     | <span class='neutral'>            mstore(0x40, m2)</span>
 13308 |     | <span class='neutral'>            mstore(0x60, m3)</span>
 13309 |     | <span class='neutral'>            mstore(0x80, m4)</span>
 13310 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
 13311 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
 13312 |     | <span class='neutral'>            mstore(0xe0, m7)</span>
 13313 |     | <span class='neutral'>            mstore(0x100, m8)</span>
 13314 |     | <span class='neutral'>        }</span>
 13315 |     | <span class='neutral'>    }</span>
 13316 |     | <span class='neutral'></span>
 13317 |     | <span class='neutral'>    function log(bytes32 p0, bytes32 p1, bool p2, bool p3) internal pure {</span>
 13318 |     | <span class='neutral'>        bytes32 m0;</span>
 13319 |     | <span class='neutral'>        bytes32 m1;</span>
 13320 |     | <span class='neutral'>        bytes32 m2;</span>
 13321 |     | <span class='neutral'>        bytes32 m3;</span>
 13322 |     | <span class='neutral'>        bytes32 m4;</span>
 13323 |     | <span class='neutral'>        bytes32 m5;</span>
 13324 |     | <span class='neutral'>        bytes32 m6;</span>
 13325 |     | <span class='neutral'>        bytes32 m7;</span>
 13326 |     | <span class='neutral'>        bytes32 m8;</span>
 13327 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 13328 |     | <span class='neutral'>        assembly {</span>
 13329 |     | <span class='neutral'>            function writeString(pos, w) {</span>
 13330 |     | <span class='neutral'>                let length := 0</span>
 13331 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
 13332 |     | <span class='neutral'>                mstore(pos, length)</span>
 13333 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
 13334 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
 13335 |     | <span class='neutral'>            }</span>
 13336 |     | <span class='neutral'>            m0 := mload(0x00)</span>
 13337 |     | <span class='neutral'>            m1 := mload(0x20)</span>
 13338 |     | <span class='neutral'>            m2 := mload(0x40)</span>
 13339 |     | <span class='neutral'>            m3 := mload(0x60)</span>
 13340 |     | <span class='neutral'>            m4 := mload(0x80)</span>
 13341 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
 13342 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
 13343 |     | <span class='neutral'>            m7 := mload(0xe0)</span>
 13344 |     | <span class='neutral'>            m8 := mload(0x100)</span>
 13345 |     | <span class='neutral'>            // Selector of `log(string,string,bool,bool)`.</span>
 13346 |     | <span class='neutral'>            mstore(0x00, 0x40785869)</span>
 13347 |     | <span class='neutral'>            mstore(0x20, 0x80)</span>
 13348 |     | <span class='neutral'>            mstore(0x40, 0xc0)</span>
 13349 |     | <span class='neutral'>            mstore(0x60, p2)</span>
 13350 |     | <span class='neutral'>            mstore(0x80, p3)</span>
 13351 |     | <span class='neutral'>            writeString(0xa0, p0)</span>
 13352 |     | <span class='neutral'>            writeString(0xe0, p1)</span>
 13353 |     | <span class='neutral'>        }</span>
 13354 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x104);</span>
 13355 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 13356 |     | <span class='neutral'>        assembly {</span>
 13357 |     | <span class='neutral'>            mstore(0x00, m0)</span>
 13358 |     | <span class='neutral'>            mstore(0x20, m1)</span>
 13359 |     | <span class='neutral'>            mstore(0x40, m2)</span>
 13360 |     | <span class='neutral'>            mstore(0x60, m3)</span>
 13361 |     | <span class='neutral'>            mstore(0x80, m4)</span>
 13362 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
 13363 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
 13364 |     | <span class='neutral'>            mstore(0xe0, m7)</span>
 13365 |     | <span class='neutral'>            mstore(0x100, m8)</span>
 13366 |     | <span class='neutral'>        }</span>
 13367 |     | <span class='neutral'>    }</span>
 13368 |     | <span class='neutral'></span>
 13369 |     | <span class='neutral'>    function log(bytes32 p0, bytes32 p1, bool p2, uint256 p3) internal pure {</span>
 13370 |     | <span class='neutral'>        bytes32 m0;</span>
 13371 |     | <span class='neutral'>        bytes32 m1;</span>
 13372 |     | <span class='neutral'>        bytes32 m2;</span>
 13373 |     | <span class='neutral'>        bytes32 m3;</span>
 13374 |     | <span class='neutral'>        bytes32 m4;</span>
 13375 |     | <span class='neutral'>        bytes32 m5;</span>
 13376 |     | <span class='neutral'>        bytes32 m6;</span>
 13377 |     | <span class='neutral'>        bytes32 m7;</span>
 13378 |     | <span class='neutral'>        bytes32 m8;</span>
 13379 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 13380 |     | <span class='neutral'>        assembly {</span>
 13381 |     | <span class='neutral'>            function writeString(pos, w) {</span>
 13382 |     | <span class='neutral'>                let length := 0</span>
 13383 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
 13384 |     | <span class='neutral'>                mstore(pos, length)</span>
 13385 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
 13386 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
 13387 |     | <span class='neutral'>            }</span>
 13388 |     | <span class='neutral'>            m0 := mload(0x00)</span>
 13389 |     | <span class='neutral'>            m1 := mload(0x20)</span>
 13390 |     | <span class='neutral'>            m2 := mload(0x40)</span>
 13391 |     | <span class='neutral'>            m3 := mload(0x60)</span>
 13392 |     | <span class='neutral'>            m4 := mload(0x80)</span>
 13393 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
 13394 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
 13395 |     | <span class='neutral'>            m7 := mload(0xe0)</span>
 13396 |     | <span class='neutral'>            m8 := mload(0x100)</span>
 13397 |     | <span class='neutral'>            // Selector of `log(string,string,bool,uint256)`.</span>
 13398 |     | <span class='neutral'>            mstore(0x00, 0xd6aefad2)</span>
 13399 |     | <span class='neutral'>            mstore(0x20, 0x80)</span>
 13400 |     | <span class='neutral'>            mstore(0x40, 0xc0)</span>
 13401 |     | <span class='neutral'>            mstore(0x60, p2)</span>
 13402 |     | <span class='neutral'>            mstore(0x80, p3)</span>
 13403 |     | <span class='neutral'>            writeString(0xa0, p0)</span>
 13404 |     | <span class='neutral'>            writeString(0xe0, p1)</span>
 13405 |     | <span class='neutral'>        }</span>
 13406 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x104);</span>
 13407 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 13408 |     | <span class='neutral'>        assembly {</span>
 13409 |     | <span class='neutral'>            mstore(0x00, m0)</span>
 13410 |     | <span class='neutral'>            mstore(0x20, m1)</span>
 13411 |     | <span class='neutral'>            mstore(0x40, m2)</span>
 13412 |     | <span class='neutral'>            mstore(0x60, m3)</span>
 13413 |     | <span class='neutral'>            mstore(0x80, m4)</span>
 13414 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
 13415 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
 13416 |     | <span class='neutral'>            mstore(0xe0, m7)</span>
 13417 |     | <span class='neutral'>            mstore(0x100, m8)</span>
 13418 |     | <span class='neutral'>        }</span>
 13419 |     | <span class='neutral'>    }</span>
 13420 |     | <span class='neutral'></span>
 13421 |     | <span class='neutral'>    function log(bytes32 p0, bytes32 p1, bool p2, bytes32 p3) internal pure {</span>
 13422 |     | <span class='neutral'>        bytes32 m0;</span>
 13423 |     | <span class='neutral'>        bytes32 m1;</span>
 13424 |     | <span class='neutral'>        bytes32 m2;</span>
 13425 |     | <span class='neutral'>        bytes32 m3;</span>
 13426 |     | <span class='neutral'>        bytes32 m4;</span>
 13427 |     | <span class='neutral'>        bytes32 m5;</span>
 13428 |     | <span class='neutral'>        bytes32 m6;</span>
 13429 |     | <span class='neutral'>        bytes32 m7;</span>
 13430 |     | <span class='neutral'>        bytes32 m8;</span>
 13431 |     | <span class='neutral'>        bytes32 m9;</span>
 13432 |     | <span class='neutral'>        bytes32 m10;</span>
 13433 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 13434 |     | <span class='neutral'>        assembly {</span>
 13435 |     | <span class='neutral'>            function writeString(pos, w) {</span>
 13436 |     | <span class='neutral'>                let length := 0</span>
 13437 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
 13438 |     | <span class='neutral'>                mstore(pos, length)</span>
 13439 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
 13440 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
 13441 |     | <span class='neutral'>            }</span>
 13442 |     | <span class='neutral'>            m0 := mload(0x00)</span>
 13443 |     | <span class='neutral'>            m1 := mload(0x20)</span>
 13444 |     | <span class='neutral'>            m2 := mload(0x40)</span>
 13445 |     | <span class='neutral'>            m3 := mload(0x60)</span>
 13446 |     | <span class='neutral'>            m4 := mload(0x80)</span>
 13447 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
 13448 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
 13449 |     | <span class='neutral'>            m7 := mload(0xe0)</span>
 13450 |     | <span class='neutral'>            m8 := mload(0x100)</span>
 13451 |     | <span class='neutral'>            m9 := mload(0x120)</span>
 13452 |     | <span class='neutral'>            m10 := mload(0x140)</span>
 13453 |     | <span class='neutral'>            // Selector of `log(string,string,bool,string)`.</span>
 13454 |     | <span class='neutral'>            mstore(0x00, 0x5e84b0ea)</span>
 13455 |     | <span class='neutral'>            mstore(0x20, 0x80)</span>
 13456 |     | <span class='neutral'>            mstore(0x40, 0xc0)</span>
 13457 |     | <span class='neutral'>            mstore(0x60, p2)</span>
 13458 |     | <span class='neutral'>            mstore(0x80, 0x100)</span>
 13459 |     | <span class='neutral'>            writeString(0xa0, p0)</span>
 13460 |     | <span class='neutral'>            writeString(0xe0, p1)</span>
 13461 |     | <span class='neutral'>            writeString(0x120, p3)</span>
 13462 |     | <span class='neutral'>        }</span>
 13463 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x144);</span>
 13464 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 13465 |     | <span class='neutral'>        assembly {</span>
 13466 |     | <span class='neutral'>            mstore(0x00, m0)</span>
 13467 |     | <span class='neutral'>            mstore(0x20, m1)</span>
 13468 |     | <span class='neutral'>            mstore(0x40, m2)</span>
 13469 |     | <span class='neutral'>            mstore(0x60, m3)</span>
 13470 |     | <span class='neutral'>            mstore(0x80, m4)</span>
 13471 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
 13472 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
 13473 |     | <span class='neutral'>            mstore(0xe0, m7)</span>
 13474 |     | <span class='neutral'>            mstore(0x100, m8)</span>
 13475 |     | <span class='neutral'>            mstore(0x120, m9)</span>
 13476 |     | <span class='neutral'>            mstore(0x140, m10)</span>
 13477 |     | <span class='neutral'>        }</span>
 13478 |     | <span class='neutral'>    }</span>
 13479 |     | <span class='neutral'></span>
 13480 |     | <span class='neutral'>    function log(bytes32 p0, bytes32 p1, uint256 p2, address p3) internal pure {</span>
 13481 |     | <span class='neutral'>        bytes32 m0;</span>
 13482 |     | <span class='neutral'>        bytes32 m1;</span>
 13483 |     | <span class='neutral'>        bytes32 m2;</span>
 13484 |     | <span class='neutral'>        bytes32 m3;</span>
 13485 |     | <span class='neutral'>        bytes32 m4;</span>
 13486 |     | <span class='neutral'>        bytes32 m5;</span>
 13487 |     | <span class='neutral'>        bytes32 m6;</span>
 13488 |     | <span class='neutral'>        bytes32 m7;</span>
 13489 |     | <span class='neutral'>        bytes32 m8;</span>
 13490 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 13491 |     | <span class='neutral'>        assembly {</span>
 13492 |     | <span class='neutral'>            function writeString(pos, w) {</span>
 13493 |     | <span class='neutral'>                let length := 0</span>
 13494 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
 13495 |     | <span class='neutral'>                mstore(pos, length)</span>
 13496 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
 13497 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
 13498 |     | <span class='neutral'>            }</span>
 13499 |     | <span class='neutral'>            m0 := mload(0x00)</span>
 13500 |     | <span class='neutral'>            m1 := mload(0x20)</span>
 13501 |     | <span class='neutral'>            m2 := mload(0x40)</span>
 13502 |     | <span class='neutral'>            m3 := mload(0x60)</span>
 13503 |     | <span class='neutral'>            m4 := mload(0x80)</span>
 13504 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
 13505 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
 13506 |     | <span class='neutral'>            m7 := mload(0xe0)</span>
 13507 |     | <span class='neutral'>            m8 := mload(0x100)</span>
 13508 |     | <span class='neutral'>            // Selector of `log(string,string,uint256,address)`.</span>
 13509 |     | <span class='neutral'>            mstore(0x00, 0x1023f7b2)</span>
 13510 |     | <span class='neutral'>            mstore(0x20, 0x80)</span>
 13511 |     | <span class='neutral'>            mstore(0x40, 0xc0)</span>
 13512 |     | <span class='neutral'>            mstore(0x60, p2)</span>
 13513 |     | <span class='neutral'>            mstore(0x80, p3)</span>
 13514 |     | <span class='neutral'>            writeString(0xa0, p0)</span>
 13515 |     | <span class='neutral'>            writeString(0xe0, p1)</span>
 13516 |     | <span class='neutral'>        }</span>
 13517 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x104);</span>
 13518 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 13519 |     | <span class='neutral'>        assembly {</span>
 13520 |     | <span class='neutral'>            mstore(0x00, m0)</span>
 13521 |     | <span class='neutral'>            mstore(0x20, m1)</span>
 13522 |     | <span class='neutral'>            mstore(0x40, m2)</span>
 13523 |     | <span class='neutral'>            mstore(0x60, m3)</span>
 13524 |     | <span class='neutral'>            mstore(0x80, m4)</span>
 13525 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
 13526 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
 13527 |     | <span class='neutral'>            mstore(0xe0, m7)</span>
 13528 |     | <span class='neutral'>            mstore(0x100, m8)</span>
 13529 |     | <span class='neutral'>        }</span>
 13530 |     | <span class='neutral'>    }</span>
 13531 |     | <span class='neutral'></span>
 13532 |     | <span class='neutral'>    function log(bytes32 p0, bytes32 p1, uint256 p2, bool p3) internal pure {</span>
 13533 |     | <span class='neutral'>        bytes32 m0;</span>
 13534 |     | <span class='neutral'>        bytes32 m1;</span>
 13535 |     | <span class='neutral'>        bytes32 m2;</span>
 13536 |     | <span class='neutral'>        bytes32 m3;</span>
 13537 |     | <span class='neutral'>        bytes32 m4;</span>
 13538 |     | <span class='neutral'>        bytes32 m5;</span>
 13539 |     | <span class='neutral'>        bytes32 m6;</span>
 13540 |     | <span class='neutral'>        bytes32 m7;</span>
 13541 |     | <span class='neutral'>        bytes32 m8;</span>
 13542 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 13543 |     | <span class='neutral'>        assembly {</span>
 13544 |     | <span class='neutral'>            function writeString(pos, w) {</span>
 13545 |     | <span class='neutral'>                let length := 0</span>
 13546 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
 13547 |     | <span class='neutral'>                mstore(pos, length)</span>
 13548 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
 13549 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
 13550 |     | <span class='neutral'>            }</span>
 13551 |     | <span class='neutral'>            m0 := mload(0x00)</span>
 13552 |     | <span class='neutral'>            m1 := mload(0x20)</span>
 13553 |     | <span class='neutral'>            m2 := mload(0x40)</span>
 13554 |     | <span class='neutral'>            m3 := mload(0x60)</span>
 13555 |     | <span class='neutral'>            m4 := mload(0x80)</span>
 13556 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
 13557 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
 13558 |     | <span class='neutral'>            m7 := mload(0xe0)</span>
 13559 |     | <span class='neutral'>            m8 := mload(0x100)</span>
 13560 |     | <span class='neutral'>            // Selector of `log(string,string,uint256,bool)`.</span>
 13561 |     | <span class='neutral'>            mstore(0x00, 0xc3a8a654)</span>
 13562 |     | <span class='neutral'>            mstore(0x20, 0x80)</span>
 13563 |     | <span class='neutral'>            mstore(0x40, 0xc0)</span>
 13564 |     | <span class='neutral'>            mstore(0x60, p2)</span>
 13565 |     | <span class='neutral'>            mstore(0x80, p3)</span>
 13566 |     | <span class='neutral'>            writeString(0xa0, p0)</span>
 13567 |     | <span class='neutral'>            writeString(0xe0, p1)</span>
 13568 |     | <span class='neutral'>        }</span>
 13569 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x104);</span>
 13570 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 13571 |     | <span class='neutral'>        assembly {</span>
 13572 |     | <span class='neutral'>            mstore(0x00, m0)</span>
 13573 |     | <span class='neutral'>            mstore(0x20, m1)</span>
 13574 |     | <span class='neutral'>            mstore(0x40, m2)</span>
 13575 |     | <span class='neutral'>            mstore(0x60, m3)</span>
 13576 |     | <span class='neutral'>            mstore(0x80, m4)</span>
 13577 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
 13578 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
 13579 |     | <span class='neutral'>            mstore(0xe0, m7)</span>
 13580 |     | <span class='neutral'>            mstore(0x100, m8)</span>
 13581 |     | <span class='neutral'>        }</span>
 13582 |     | <span class='neutral'>    }</span>
 13583 |     | <span class='neutral'></span>
 13584 |     | <span class='neutral'>    function log(bytes32 p0, bytes32 p1, uint256 p2, uint256 p3) internal pure {</span>
 13585 |     | <span class='neutral'>        bytes32 m0;</span>
 13586 |     | <span class='neutral'>        bytes32 m1;</span>
 13587 |     | <span class='neutral'>        bytes32 m2;</span>
 13588 |     | <span class='neutral'>        bytes32 m3;</span>
 13589 |     | <span class='neutral'>        bytes32 m4;</span>
 13590 |     | <span class='neutral'>        bytes32 m5;</span>
 13591 |     | <span class='neutral'>        bytes32 m6;</span>
 13592 |     | <span class='neutral'>        bytes32 m7;</span>
 13593 |     | <span class='neutral'>        bytes32 m8;</span>
 13594 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 13595 |     | <span class='neutral'>        assembly {</span>
 13596 |     | <span class='neutral'>            function writeString(pos, w) {</span>
 13597 |     | <span class='neutral'>                let length := 0</span>
 13598 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
 13599 |     | <span class='neutral'>                mstore(pos, length)</span>
 13600 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
 13601 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
 13602 |     | <span class='neutral'>            }</span>
 13603 |     | <span class='neutral'>            m0 := mload(0x00)</span>
 13604 |     | <span class='neutral'>            m1 := mload(0x20)</span>
 13605 |     | <span class='neutral'>            m2 := mload(0x40)</span>
 13606 |     | <span class='neutral'>            m3 := mload(0x60)</span>
 13607 |     | <span class='neutral'>            m4 := mload(0x80)</span>
 13608 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
 13609 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
 13610 |     | <span class='neutral'>            m7 := mload(0xe0)</span>
 13611 |     | <span class='neutral'>            m8 := mload(0x100)</span>
 13612 |     | <span class='neutral'>            // Selector of `log(string,string,uint256,uint256)`.</span>
 13613 |     | <span class='neutral'>            mstore(0x00, 0xf45d7d2c)</span>
 13614 |     | <span class='neutral'>            mstore(0x20, 0x80)</span>
 13615 |     | <span class='neutral'>            mstore(0x40, 0xc0)</span>
 13616 |     | <span class='neutral'>            mstore(0x60, p2)</span>
 13617 |     | <span class='neutral'>            mstore(0x80, p3)</span>
 13618 |     | <span class='neutral'>            writeString(0xa0, p0)</span>
 13619 |     | <span class='neutral'>            writeString(0xe0, p1)</span>
 13620 |     | <span class='neutral'>        }</span>
 13621 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x104);</span>
 13622 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 13623 |     | <span class='neutral'>        assembly {</span>
 13624 |     | <span class='neutral'>            mstore(0x00, m0)</span>
 13625 |     | <span class='neutral'>            mstore(0x20, m1)</span>
 13626 |     | <span class='neutral'>            mstore(0x40, m2)</span>
 13627 |     | <span class='neutral'>            mstore(0x60, m3)</span>
 13628 |     | <span class='neutral'>            mstore(0x80, m4)</span>
 13629 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
 13630 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
 13631 |     | <span class='neutral'>            mstore(0xe0, m7)</span>
 13632 |     | <span class='neutral'>            mstore(0x100, m8)</span>
 13633 |     | <span class='neutral'>        }</span>
 13634 |     | <span class='neutral'>    }</span>
 13635 |     | <span class='neutral'></span>
 13636 |     | <span class='neutral'>    function log(bytes32 p0, bytes32 p1, uint256 p2, bytes32 p3) internal pure {</span>
 13637 |     | <span class='neutral'>        bytes32 m0;</span>
 13638 |     | <span class='neutral'>        bytes32 m1;</span>
 13639 |     | <span class='neutral'>        bytes32 m2;</span>
 13640 |     | <span class='neutral'>        bytes32 m3;</span>
 13641 |     | <span class='neutral'>        bytes32 m4;</span>
 13642 |     | <span class='neutral'>        bytes32 m5;</span>
 13643 |     | <span class='neutral'>        bytes32 m6;</span>
 13644 |     | <span class='neutral'>        bytes32 m7;</span>
 13645 |     | <span class='neutral'>        bytes32 m8;</span>
 13646 |     | <span class='neutral'>        bytes32 m9;</span>
 13647 |     | <span class='neutral'>        bytes32 m10;</span>
 13648 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 13649 |     | <span class='neutral'>        assembly {</span>
 13650 |     | <span class='neutral'>            function writeString(pos, w) {</span>
 13651 |     | <span class='neutral'>                let length := 0</span>
 13652 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
 13653 |     | <span class='neutral'>                mstore(pos, length)</span>
 13654 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
 13655 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
 13656 |     | <span class='neutral'>            }</span>
 13657 |     | <span class='neutral'>            m0 := mload(0x00)</span>
 13658 |     | <span class='neutral'>            m1 := mload(0x20)</span>
 13659 |     | <span class='neutral'>            m2 := mload(0x40)</span>
 13660 |     | <span class='neutral'>            m3 := mload(0x60)</span>
 13661 |     | <span class='neutral'>            m4 := mload(0x80)</span>
 13662 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
 13663 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
 13664 |     | <span class='neutral'>            m7 := mload(0xe0)</span>
 13665 |     | <span class='neutral'>            m8 := mload(0x100)</span>
 13666 |     | <span class='neutral'>            m9 := mload(0x120)</span>
 13667 |     | <span class='neutral'>            m10 := mload(0x140)</span>
 13668 |     | <span class='neutral'>            // Selector of `log(string,string,uint256,string)`.</span>
 13669 |     | <span class='neutral'>            mstore(0x00, 0x5d1a971a)</span>
 13670 |     | <span class='neutral'>            mstore(0x20, 0x80)</span>
 13671 |     | <span class='neutral'>            mstore(0x40, 0xc0)</span>
 13672 |     | <span class='neutral'>            mstore(0x60, p2)</span>
 13673 |     | <span class='neutral'>            mstore(0x80, 0x100)</span>
 13674 |     | <span class='neutral'>            writeString(0xa0, p0)</span>
 13675 |     | <span class='neutral'>            writeString(0xe0, p1)</span>
 13676 |     | <span class='neutral'>            writeString(0x120, p3)</span>
 13677 |     | <span class='neutral'>        }</span>
 13678 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x144);</span>
 13679 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 13680 |     | <span class='neutral'>        assembly {</span>
 13681 |     | <span class='neutral'>            mstore(0x00, m0)</span>
 13682 |     | <span class='neutral'>            mstore(0x20, m1)</span>
 13683 |     | <span class='neutral'>            mstore(0x40, m2)</span>
 13684 |     | <span class='neutral'>            mstore(0x60, m3)</span>
 13685 |     | <span class='neutral'>            mstore(0x80, m4)</span>
 13686 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
 13687 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
 13688 |     | <span class='neutral'>            mstore(0xe0, m7)</span>
 13689 |     | <span class='neutral'>            mstore(0x100, m8)</span>
 13690 |     | <span class='neutral'>            mstore(0x120, m9)</span>
 13691 |     | <span class='neutral'>            mstore(0x140, m10)</span>
 13692 |     | <span class='neutral'>        }</span>
 13693 |     | <span class='neutral'>    }</span>
 13694 |     | <span class='neutral'></span>
 13695 |     | <span class='neutral'>    function log(bytes32 p0, bytes32 p1, bytes32 p2, address p3) internal pure {</span>
 13696 |     | <span class='neutral'>        bytes32 m0;</span>
 13697 |     | <span class='neutral'>        bytes32 m1;</span>
 13698 |     | <span class='neutral'>        bytes32 m2;</span>
 13699 |     | <span class='neutral'>        bytes32 m3;</span>
 13700 |     | <span class='neutral'>        bytes32 m4;</span>
 13701 |     | <span class='neutral'>        bytes32 m5;</span>
 13702 |     | <span class='neutral'>        bytes32 m6;</span>
 13703 |     | <span class='neutral'>        bytes32 m7;</span>
 13704 |     | <span class='neutral'>        bytes32 m8;</span>
 13705 |     | <span class='neutral'>        bytes32 m9;</span>
 13706 |     | <span class='neutral'>        bytes32 m10;</span>
 13707 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 13708 |     | <span class='neutral'>        assembly {</span>
 13709 |     | <span class='neutral'>            function writeString(pos, w) {</span>
 13710 |     | <span class='neutral'>                let length := 0</span>
 13711 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
 13712 |     | <span class='neutral'>                mstore(pos, length)</span>
 13713 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
 13714 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
 13715 |     | <span class='neutral'>            }</span>
 13716 |     | <span class='neutral'>            m0 := mload(0x00)</span>
 13717 |     | <span class='neutral'>            m1 := mload(0x20)</span>
 13718 |     | <span class='neutral'>            m2 := mload(0x40)</span>
 13719 |     | <span class='neutral'>            m3 := mload(0x60)</span>
 13720 |     | <span class='neutral'>            m4 := mload(0x80)</span>
 13721 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
 13722 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
 13723 |     | <span class='neutral'>            m7 := mload(0xe0)</span>
 13724 |     | <span class='neutral'>            m8 := mload(0x100)</span>
 13725 |     | <span class='neutral'>            m9 := mload(0x120)</span>
 13726 |     | <span class='neutral'>            m10 := mload(0x140)</span>
 13727 |     | <span class='neutral'>            // Selector of `log(string,string,string,address)`.</span>
 13728 |     | <span class='neutral'>            mstore(0x00, 0x6d572f44)</span>
 13729 |     | <span class='neutral'>            mstore(0x20, 0x80)</span>
 13730 |     | <span class='neutral'>            mstore(0x40, 0xc0)</span>
 13731 |     | <span class='neutral'>            mstore(0x60, 0x100)</span>
 13732 |     | <span class='neutral'>            mstore(0x80, p3)</span>
 13733 |     | <span class='neutral'>            writeString(0xa0, p0)</span>
 13734 |     | <span class='neutral'>            writeString(0xe0, p1)</span>
 13735 |     | <span class='neutral'>            writeString(0x120, p2)</span>
 13736 |     | <span class='neutral'>        }</span>
 13737 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x144);</span>
 13738 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 13739 |     | <span class='neutral'>        assembly {</span>
 13740 |     | <span class='neutral'>            mstore(0x00, m0)</span>
 13741 |     | <span class='neutral'>            mstore(0x20, m1)</span>
 13742 |     | <span class='neutral'>            mstore(0x40, m2)</span>
 13743 |     | <span class='neutral'>            mstore(0x60, m3)</span>
 13744 |     | <span class='neutral'>            mstore(0x80, m4)</span>
 13745 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
 13746 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
 13747 |     | <span class='neutral'>            mstore(0xe0, m7)</span>
 13748 |     | <span class='neutral'>            mstore(0x100, m8)</span>
 13749 |     | <span class='neutral'>            mstore(0x120, m9)</span>
 13750 |     | <span class='neutral'>            mstore(0x140, m10)</span>
 13751 |     | <span class='neutral'>        }</span>
 13752 |     | <span class='neutral'>    }</span>
 13753 |     | <span class='neutral'></span>
 13754 |     | <span class='neutral'>    function log(bytes32 p0, bytes32 p1, bytes32 p2, bool p3) internal pure {</span>
 13755 |     | <span class='neutral'>        bytes32 m0;</span>
 13756 |     | <span class='neutral'>        bytes32 m1;</span>
 13757 |     | <span class='neutral'>        bytes32 m2;</span>
 13758 |     | <span class='neutral'>        bytes32 m3;</span>
 13759 |     | <span class='neutral'>        bytes32 m4;</span>
 13760 |     | <span class='neutral'>        bytes32 m5;</span>
 13761 |     | <span class='neutral'>        bytes32 m6;</span>
 13762 |     | <span class='neutral'>        bytes32 m7;</span>
 13763 |     | <span class='neutral'>        bytes32 m8;</span>
 13764 |     | <span class='neutral'>        bytes32 m9;</span>
 13765 |     | <span class='neutral'>        bytes32 m10;</span>
 13766 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 13767 |     | <span class='neutral'>        assembly {</span>
 13768 |     | <span class='neutral'>            function writeString(pos, w) {</span>
 13769 |     | <span class='neutral'>                let length := 0</span>
 13770 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
 13771 |     | <span class='neutral'>                mstore(pos, length)</span>
 13772 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
 13773 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
 13774 |     | <span class='neutral'>            }</span>
 13775 |     | <span class='neutral'>            m0 := mload(0x00)</span>
 13776 |     | <span class='neutral'>            m1 := mload(0x20)</span>
 13777 |     | <span class='neutral'>            m2 := mload(0x40)</span>
 13778 |     | <span class='neutral'>            m3 := mload(0x60)</span>
 13779 |     | <span class='neutral'>            m4 := mload(0x80)</span>
 13780 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
 13781 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
 13782 |     | <span class='neutral'>            m7 := mload(0xe0)</span>
 13783 |     | <span class='neutral'>            m8 := mload(0x100)</span>
 13784 |     | <span class='neutral'>            m9 := mload(0x120)</span>
 13785 |     | <span class='neutral'>            m10 := mload(0x140)</span>
 13786 |     | <span class='neutral'>            // Selector of `log(string,string,string,bool)`.</span>
 13787 |     | <span class='neutral'>            mstore(0x00, 0x2c1754ed)</span>
 13788 |     | <span class='neutral'>            mstore(0x20, 0x80)</span>
 13789 |     | <span class='neutral'>            mstore(0x40, 0xc0)</span>
 13790 |     | <span class='neutral'>            mstore(0x60, 0x100)</span>
 13791 |     | <span class='neutral'>            mstore(0x80, p3)</span>
 13792 |     | <span class='neutral'>            writeString(0xa0, p0)</span>
 13793 |     | <span class='neutral'>            writeString(0xe0, p1)</span>
 13794 |     | <span class='neutral'>            writeString(0x120, p2)</span>
 13795 |     | <span class='neutral'>        }</span>
 13796 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x144);</span>
 13797 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 13798 |     | <span class='neutral'>        assembly {</span>
 13799 |     | <span class='neutral'>            mstore(0x00, m0)</span>
 13800 |     | <span class='neutral'>            mstore(0x20, m1)</span>
 13801 |     | <span class='neutral'>            mstore(0x40, m2)</span>
 13802 |     | <span class='neutral'>            mstore(0x60, m3)</span>
 13803 |     | <span class='neutral'>            mstore(0x80, m4)</span>
 13804 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
 13805 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
 13806 |     | <span class='neutral'>            mstore(0xe0, m7)</span>
 13807 |     | <span class='neutral'>            mstore(0x100, m8)</span>
 13808 |     | <span class='neutral'>            mstore(0x120, m9)</span>
 13809 |     | <span class='neutral'>            mstore(0x140, m10)</span>
 13810 |     | <span class='neutral'>        }</span>
 13811 |     | <span class='neutral'>    }</span>
 13812 |     | <span class='neutral'></span>
 13813 |     | <span class='neutral'>    function log(bytes32 p0, bytes32 p1, bytes32 p2, uint256 p3) internal pure {</span>
 13814 |     | <span class='neutral'>        bytes32 m0;</span>
 13815 |     | <span class='neutral'>        bytes32 m1;</span>
 13816 |     | <span class='neutral'>        bytes32 m2;</span>
 13817 |     | <span class='neutral'>        bytes32 m3;</span>
 13818 |     | <span class='neutral'>        bytes32 m4;</span>
 13819 |     | <span class='neutral'>        bytes32 m5;</span>
 13820 |     | <span class='neutral'>        bytes32 m6;</span>
 13821 |     | <span class='neutral'>        bytes32 m7;</span>
 13822 |     | <span class='neutral'>        bytes32 m8;</span>
 13823 |     | <span class='neutral'>        bytes32 m9;</span>
 13824 |     | <span class='neutral'>        bytes32 m10;</span>
 13825 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 13826 |     | <span class='neutral'>        assembly {</span>
 13827 |     | <span class='neutral'>            function writeString(pos, w) {</span>
 13828 |     | <span class='neutral'>                let length := 0</span>
 13829 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
 13830 |     | <span class='neutral'>                mstore(pos, length)</span>
 13831 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
 13832 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
 13833 |     | <span class='neutral'>            }</span>
 13834 |     | <span class='neutral'>            m0 := mload(0x00)</span>
 13835 |     | <span class='neutral'>            m1 := mload(0x20)</span>
 13836 |     | <span class='neutral'>            m2 := mload(0x40)</span>
 13837 |     | <span class='neutral'>            m3 := mload(0x60)</span>
 13838 |     | <span class='neutral'>            m4 := mload(0x80)</span>
 13839 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
 13840 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
 13841 |     | <span class='neutral'>            m7 := mload(0xe0)</span>
 13842 |     | <span class='neutral'>            m8 := mload(0x100)</span>
 13843 |     | <span class='neutral'>            m9 := mload(0x120)</span>
 13844 |     | <span class='neutral'>            m10 := mload(0x140)</span>
 13845 |     | <span class='neutral'>            // Selector of `log(string,string,string,uint256)`.</span>
 13846 |     | <span class='neutral'>            mstore(0x00, 0x8eafb02b)</span>
 13847 |     | <span class='neutral'>            mstore(0x20, 0x80)</span>
 13848 |     | <span class='neutral'>            mstore(0x40, 0xc0)</span>
 13849 |     | <span class='neutral'>            mstore(0x60, 0x100)</span>
 13850 |     | <span class='neutral'>            mstore(0x80, p3)</span>
 13851 |     | <span class='neutral'>            writeString(0xa0, p0)</span>
 13852 |     | <span class='neutral'>            writeString(0xe0, p1)</span>
 13853 |     | <span class='neutral'>            writeString(0x120, p2)</span>
 13854 |     | <span class='neutral'>        }</span>
 13855 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x144);</span>
 13856 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 13857 |     | <span class='neutral'>        assembly {</span>
 13858 |     | <span class='neutral'>            mstore(0x00, m0)</span>
 13859 |     | <span class='neutral'>            mstore(0x20, m1)</span>
 13860 |     | <span class='neutral'>            mstore(0x40, m2)</span>
 13861 |     | <span class='neutral'>            mstore(0x60, m3)</span>
 13862 |     | <span class='neutral'>            mstore(0x80, m4)</span>
 13863 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
 13864 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
 13865 |     | <span class='neutral'>            mstore(0xe0, m7)</span>
 13866 |     | <span class='neutral'>            mstore(0x100, m8)</span>
 13867 |     | <span class='neutral'>            mstore(0x120, m9)</span>
 13868 |     | <span class='neutral'>            mstore(0x140, m10)</span>
 13869 |     | <span class='neutral'>        }</span>
 13870 |     | <span class='neutral'>    }</span>
 13871 |     | <span class='neutral'></span>
 13872 |     | <span class='neutral'>    function log(bytes32 p0, bytes32 p1, bytes32 p2, bytes32 p3) internal pure {</span>
 13873 |     | <span class='neutral'>        bytes32 m0;</span>
 13874 |     | <span class='neutral'>        bytes32 m1;</span>
 13875 |     | <span class='neutral'>        bytes32 m2;</span>
 13876 |     | <span class='neutral'>        bytes32 m3;</span>
 13877 |     | <span class='neutral'>        bytes32 m4;</span>
 13878 |     | <span class='neutral'>        bytes32 m5;</span>
 13879 |     | <span class='neutral'>        bytes32 m6;</span>
 13880 |     | <span class='neutral'>        bytes32 m7;</span>
 13881 |     | <span class='neutral'>        bytes32 m8;</span>
 13882 |     | <span class='neutral'>        bytes32 m9;</span>
 13883 |     | <span class='neutral'>        bytes32 m10;</span>
 13884 |     | <span class='neutral'>        bytes32 m11;</span>
 13885 |     | <span class='neutral'>        bytes32 m12;</span>
 13886 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 13887 |     | <span class='neutral'>        assembly {</span>
 13888 |     | <span class='neutral'>            function writeString(pos, w) {</span>
 13889 |     | <span class='neutral'>                let length := 0</span>
 13890 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
 13891 |     | <span class='neutral'>                mstore(pos, length)</span>
 13892 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
 13893 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
 13894 |     | <span class='neutral'>            }</span>
 13895 |     | <span class='neutral'>            m0 := mload(0x00)</span>
 13896 |     | <span class='neutral'>            m1 := mload(0x20)</span>
 13897 |     | <span class='neutral'>            m2 := mload(0x40)</span>
 13898 |     | <span class='neutral'>            m3 := mload(0x60)</span>
 13899 |     | <span class='neutral'>            m4 := mload(0x80)</span>
 13900 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
 13901 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
 13902 |     | <span class='neutral'>            m7 := mload(0xe0)</span>
 13903 |     | <span class='neutral'>            m8 := mload(0x100)</span>
 13904 |     | <span class='neutral'>            m9 := mload(0x120)</span>
 13905 |     | <span class='neutral'>            m10 := mload(0x140)</span>
 13906 |     | <span class='neutral'>            m11 := mload(0x160)</span>
 13907 |     | <span class='neutral'>            m12 := mload(0x180)</span>
 13908 |     | <span class='neutral'>            // Selector of `log(string,string,string,string)`.</span>
 13909 |     | <span class='neutral'>            mstore(0x00, 0xde68f20a)</span>
 13910 |     | <span class='neutral'>            mstore(0x20, 0x80)</span>
 13911 |     | <span class='neutral'>            mstore(0x40, 0xc0)</span>
 13912 |     | <span class='neutral'>            mstore(0x60, 0x100)</span>
 13913 |     | <span class='neutral'>            mstore(0x80, 0x140)</span>
 13914 |     | <span class='neutral'>            writeString(0xa0, p0)</span>
 13915 |     | <span class='neutral'>            writeString(0xe0, p1)</span>
 13916 |     | <span class='neutral'>            writeString(0x120, p2)</span>
 13917 |     | <span class='neutral'>            writeString(0x160, p3)</span>
 13918 |     | <span class='neutral'>        }</span>
 13919 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x184);</span>
 13920 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 13921 |     | <span class='neutral'>        assembly {</span>
 13922 |     | <span class='neutral'>            mstore(0x00, m0)</span>
 13923 |     | <span class='neutral'>            mstore(0x20, m1)</span>
 13924 |     | <span class='neutral'>            mstore(0x40, m2)</span>
 13925 |     | <span class='neutral'>            mstore(0x60, m3)</span>
 13926 |     | <span class='neutral'>            mstore(0x80, m4)</span>
 13927 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
 13928 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
 13929 |     | <span class='neutral'>            mstore(0xe0, m7)</span>
 13930 |     | <span class='neutral'>            mstore(0x100, m8)</span>
 13931 |     | <span class='neutral'>            mstore(0x120, m9)</span>
 13932 |     | <span class='neutral'>            mstore(0x140, m10)</span>
 13933 |     | <span class='neutral'>            mstore(0x160, m11)</span>
 13934 |     | <span class='neutral'>            mstore(0x180, m12)</span>
 13935 |     | <span class='neutral'>        }</span>
 13936 |     | <span class='neutral'>    }</span>
 13937 |     | <span class='neutral'>}</span>
 13938 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/phantom/Documents/azemora/azemora-contracts/lib/openzeppelin-contracts/contracts/access/IAccessControl.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'>// OpenZeppelin Contracts (last updated v5.3.0) (access/IAccessControl.sol)</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>pragma solidity &gt;=0.8.4;</span>
   5 |     | <span class='neutral'></span>
   6 |     | <span class='neutral'>/**</span>
   7 |     | <span class='neutral'> * @dev External interface of AccessControl declared to support ERC-165 detection.</span>
   8 |     | <span class='neutral'> */</span>
   9 |     | <span class='neutral'>interface IAccessControl {</span>
  10 |     | <span class='neutral'>    /**</span>
  11 |     | <span class='neutral'>     * @dev The `account` is missing a role.</span>
  12 |     | <span class='neutral'>     */</span>
  13 |     | <span class='neutral'>    error AccessControlUnauthorizedAccount(address account, bytes32 neededRole);</span>
  14 |     | <span class='neutral'></span>
  15 |     | <span class='neutral'>    /**</span>
  16 |     | <span class='neutral'>     * @dev The caller of a function is not the expected one.</span>
  17 |     | <span class='neutral'>     *</span>
  18 |     | <span class='neutral'>     * NOTE: Don&#39;t confuse with {AccessControlUnauthorizedAccount}.</span>
  19 |     | <span class='neutral'>     */</span>
  20 |     | <span class='neutral'>    error AccessControlBadConfirmation();</span>
  21 |     | <span class='neutral'></span>
  22 |     | <span class='neutral'>    /**</span>
  23 |     | <span class='neutral'>     * @dev Emitted when `newAdminRole` is set as ``role``&#39;s admin role, replacing `previousAdminRole`</span>
  24 |     | <span class='neutral'>     *</span>
  25 |     | <span class='neutral'>     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite</span>
  26 |     | <span class='neutral'>     * {RoleAdminChanged} not being emitted to signal this.</span>
  27 |     | <span class='neutral'>     */</span>
  28 |     | <span class='neutral'>    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);</span>
  29 |     | <span class='neutral'></span>
  30 |     | <span class='neutral'>    /**</span>
  31 |     | <span class='neutral'>     * @dev Emitted when `account` is granted `role`.</span>
  32 |     | <span class='neutral'>     *</span>
  33 |     | <span class='neutral'>     * `sender` is the account that originated the contract call. This account bears the admin role (for the granted role).</span>
  34 |     | <span class='neutral'>     * Expected in cases where the role was granted using the internal {AccessControl-_grantRole}.</span>
  35 |     | <span class='neutral'>     */</span>
  36 |     | <span class='neutral'>    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);</span>
  37 |     | <span class='neutral'></span>
  38 |     | <span class='neutral'>    /**</span>
  39 |     | <span class='neutral'>     * @dev Emitted when `account` is revoked `role`.</span>
  40 |     | <span class='neutral'>     *</span>
  41 |     | <span class='neutral'>     * `sender` is the account that originated the contract call:</span>
  42 |     | <span class='neutral'>     *   - if using `revokeRole`, it is the admin role bearer</span>
  43 |     | <span class='neutral'>     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)</span>
  44 |     | <span class='neutral'>     */</span>
  45 |     | <span class='neutral'>    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);</span>
  46 |     | <span class='neutral'></span>
  47 |     | <span class='neutral'>    /**</span>
  48 |     | <span class='neutral'>     * @dev Returns `true` if `account` has been granted `role`.</span>
  49 |     | <span class='neutral'>     */</span>
  50 |     | <span class='neutral'>    function hasRole(bytes32 role, address account) external view returns (bool);</span>
  51 |     | <span class='neutral'></span>
  52 |     | <span class='neutral'>    /**</span>
  53 |     | <span class='neutral'>     * @dev Returns the admin role that controls `role`. See {grantRole} and</span>
  54 |     | <span class='neutral'>     * {revokeRole}.</span>
  55 |     | <span class='neutral'>     *</span>
  56 |     | <span class='neutral'>     * To change a role&#39;s admin, use {AccessControl-_setRoleAdmin}.</span>
  57 |     | <span class='neutral'>     */</span>
  58 |     | <span class='neutral'>    function getRoleAdmin(bytes32 role) external view returns (bytes32);</span>
  59 |     | <span class='neutral'></span>
  60 |     | <span class='neutral'>    /**</span>
  61 |     | <span class='neutral'>     * @dev Grants `role` to `account`.</span>
  62 |     | <span class='neutral'>     *</span>
  63 |     | <span class='neutral'>     * If `account` had not been already granted `role`, emits a {RoleGranted}</span>
  64 |     | <span class='neutral'>     * event.</span>
  65 |     | <span class='neutral'>     *</span>
  66 |     | <span class='neutral'>     * Requirements:</span>
  67 |     | <span class='neutral'>     *</span>
  68 |     | <span class='unexecuted'>     * - the caller must have ``role``&#39;s admin role.</span>
  69 |     | <span class='neutral'>     */</span>
  70 | *   | <span class='executed'>    function grantRole(bytes32 role, address account) external;</span>
  71 |     | <span class='neutral'></span>
  72 |     | <span class='neutral'>    /**</span>
  73 |     | <span class='neutral'>     * @dev Revokes `role` from `account`.</span>
  74 |     | <span class='neutral'>     *</span>
  75 |     | <span class='neutral'>     * If `account` had been granted `role`, emits a {RoleRevoked} event.</span>
  76 |     | <span class='neutral'>     *</span>
  77 |     | <span class='neutral'>     * Requirements:</span>
  78 |     | <span class='neutral'>     *</span>
  79 |     | <span class='neutral'>     * - the caller must have ``role``&#39;s admin role.</span>
  80 |     | <span class='neutral'>     */</span>
  81 |     | <span class='neutral'>    function revokeRole(bytes32 role, address account) external;</span>
  82 |     | <span class='neutral'></span>
  83 |     | <span class='neutral'>    /**</span>
  84 |     | <span class='neutral'>     * @dev Revokes `role` from the calling account.</span>
  85 |     | <span class='neutral'>     *</span>
  86 |     | <span class='neutral'>     * Roles are often managed via {grantRole} and {revokeRole}: this function&#39;s</span>
  87 |     | <span class='neutral'>     * purpose is to provide a mechanism for accounts to lose their privileges</span>
  88 | *   | <span class='executed'>     * if they are compromised (such as when a trusted device is misplaced).</span>
  89 |     | <span class='neutral'>     *</span>
  90 |     | <span class='neutral'>     * If the calling account had been granted `role`, emits a {RoleRevoked}</span>
  91 |     | <span class='neutral'>     * event.</span>
  92 |     | <span class='neutral'>     *</span>
  93 |     | <span class='neutral'>     * Requirements:</span>
  94 |     | <span class='neutral'>     *</span>
  95 |     | <span class='neutral'>     * - the caller must be `callerConfirmation`.</span>
  96 |     | <span class='neutral'>     */</span>
  97 | *   | <span class='executed'>    function renounceRole(bytes32 role, address callerConfirmation) external;</span>
  98 |     | <span class='neutral'>}</span>
  99 | *   | <span class='executed'></span>

</code>
<br />

<b>/home/phantom/Documents/azemora/azemora-contracts/lib/openzeppelin-contracts/contracts/governance/IGovernor.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'>// OpenZeppelin Contracts (last updated v5.3.0) (governance/IGovernor.sol)</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>pragma solidity &gt;=0.8.4;</span>
   5 |     | <span class='neutral'></span>
   6 |     | <span class='neutral'>import {IERC165} from &quot;../interfaces/IERC165.sol&quot;;</span>
   7 |     | <span class='neutral'>import {IERC6372} from &quot;../interfaces/IERC6372.sol&quot;;</span>
   8 |     | <span class='neutral'></span>
   9 |     | <span class='neutral'>/**</span>
  10 |     | <span class='neutral'> * @dev Interface of the {Governor} core.</span>
  11 |     | <span class='neutral'> *</span>
  12 |     | <span class='neutral'> * NOTE: Event parameters lack the `indexed` keyword for compatibility with GovernorBravo events.</span>
  13 |     | <span class='neutral'> * Making event parameters `indexed` affects how events are decoded, potentially breaking existing indexers.</span>
  14 |     | <span class='neutral'> */</span>
  15 |     | <span class='neutral'>interface IGovernor is IERC165, IERC6372 {</span>
  16 |     | <span class='neutral'>    enum ProposalState {</span>
  17 |     | <span class='neutral'>        Pending,</span>
  18 |     | <span class='neutral'>        Active,</span>
  19 |     | <span class='neutral'>        Canceled,</span>
  20 |     | <span class='neutral'>        Defeated,</span>
  21 |     | <span class='neutral'>        Succeeded,</span>
  22 |     | <span class='neutral'>        Queued,</span>
  23 |     | <span class='neutral'>        Expired,</span>
  24 |     | <span class='neutral'>        Executed</span>
  25 |     | <span class='neutral'>    }</span>
  26 |     | <span class='neutral'></span>
  27 |     | <span class='neutral'>    /**</span>
  28 |     | <span class='neutral'>     * @dev Empty proposal or a mismatch between the parameters length for a proposal call.</span>
  29 |     | <span class='neutral'>     */</span>
  30 |     | <span class='neutral'>    error GovernorInvalidProposalLength(uint256 targets, uint256 calldatas, uint256 values);</span>
  31 |     | <span class='neutral'></span>
  32 |     | <span class='neutral'>    /**</span>
  33 |     | <span class='neutral'>     * @dev The vote was already cast.</span>
  34 |     | <span class='neutral'>     */</span>
  35 |     | <span class='neutral'>    error GovernorAlreadyCastVote(address voter);</span>
  36 |     | <span class='neutral'></span>
  37 |     | <span class='neutral'>    /**</span>
  38 |     | <span class='neutral'>     * @dev Token deposits are disabled in this contract.</span>
  39 |     | <span class='neutral'>     */</span>
  40 |     | <span class='neutral'>    error GovernorDisabledDeposit();</span>
  41 |     | <span class='neutral'></span>
  42 |     | <span class='neutral'>    /**</span>
  43 |     | <span class='neutral'>     * @dev The `account` is not the governance executor.</span>
  44 |     | <span class='neutral'>     */</span>
  45 |     | <span class='neutral'>    error GovernorOnlyExecutor(address account);</span>
  46 |     | <span class='neutral'></span>
  47 |     | <span class='neutral'>    /**</span>
  48 |     | <span class='neutral'>     * @dev The `proposalId` doesn&#39;t exist.</span>
  49 |     | <span class='unexecuted'>     */</span>
  50 |     | <span class='neutral'>    error GovernorNonexistentProposal(uint256 proposalId);</span>
  51 |     | <span class='neutral'></span>
  52 |     | <span class='neutral'>    /**</span>
  53 |     | <span class='neutral'>     * @dev The current state of a proposal is not the required for performing an operation.</span>
  54 |     | <span class='neutral'>     * The `expectedStates` is a bitmap with the bits enabled for each ProposalState enum position</span>
  55 |     | <span class='neutral'>     * counting from right to left.</span>
  56 |     | <span class='neutral'>     *</span>
  57 |     | <span class='neutral'>     * NOTE: If `expectedState` is `bytes32(0)`, the proposal is expected to not be in any state (i.e. not exist).</span>
  58 |     | <span class='unexecuted'>     * This is the case when a proposal that is expected to be unset is already initiated (the proposal is duplicated).</span>
  59 |     | <span class='neutral'>     *</span>
  60 |     | <span class='neutral'>     * See {Governor-_encodeStateBitmap}.</span>
  61 |     | <span class='neutral'>     */</span>
  62 |     | <span class='unexecuted'>    error GovernorUnexpectedProposalState(uint256 proposalId, ProposalState current, bytes32 expectedStates);</span>
  63 |     | <span class='neutral'></span>
  64 |     | <span class='neutral'>    /**</span>
  65 |     | <span class='neutral'>     * @dev The voting period set is not a valid period.</span>
  66 |     | <span class='neutral'>     */</span>
  67 |     | <span class='neutral'>    error GovernorInvalidVotingPeriod(uint256 votingPeriod);</span>
  68 |     | <span class='neutral'></span>
  69 |     | <span class='neutral'>    /**</span>
  70 |     | <span class='neutral'>     * @dev The `proposer` does not have the required votes to create a proposal.</span>
  71 |     | <span class='neutral'>     */</span>
  72 |     | <span class='unexecuted'>    error GovernorInsufficientProposerVotes(address proposer, uint256 votes, uint256 threshold);</span>
  73 |     | <span class='neutral'></span>
  74 |     | <span class='neutral'>    /**</span>
  75 |     | <span class='neutral'>     * @dev The `proposer` is not allowed to create a proposal.</span>
  76 |     | <span class='neutral'>     */</span>
  77 |     | <span class='unexecuted'>    error GovernorRestrictedProposer(address proposer);</span>
  78 |     | <span class='neutral'></span>
  79 |     | <span class='neutral'>    /**</span>
  80 |     | <span class='unexecuted'>     * @dev The vote type used is not valid for the corresponding counting module.</span>
  81 |     | <span class='neutral'>     */</span>
  82 |     | <span class='neutral'>    error GovernorInvalidVoteType();</span>
  83 |     | <span class='neutral'></span>
  84 |     | <span class='neutral'>    /**</span>
  85 |     | <span class='unexecuted'>     * @dev The provided params buffer is not supported by the counting module.</span>
  86 |     | <span class='unexecuted'>     */</span>
  87 |     | <span class='neutral'>    error GovernorInvalidVoteParams();</span>
  88 |     | <span class='neutral'></span>
  89 |     | <span class='unexecuted'>    /**</span>
  90 |     | <span class='neutral'>     * @dev Queue operation is not implemented for this governor. Execute should be called directly.</span>
  91 |     | <span class='neutral'>     */</span>
  92 |     | <span class='neutral'>    error GovernorQueueNotImplemented();</span>
  93 |     | <span class='neutral'></span>
  94 |     | <span class='neutral'>    /**</span>
  95 |     | <span class='neutral'>     * @dev The proposal hasn&#39;t been queued yet.</span>
  96 |     | <span class='neutral'>     */</span>
  97 |     | <span class='neutral'>    error GovernorNotQueuedProposal(uint256 proposalId);</span>
  98 |     | <span class='neutral'></span>
  99 |     | <span class='neutral'>    /**</span>
 100 |     | <span class='neutral'>     * @dev The proposal has already been queued.</span>
 101 |     | <span class='neutral'>     */</span>
 102 |     | <span class='unexecuted'>    error GovernorAlreadyQueuedProposal(uint256 proposalId);</span>
 103 |     | <span class='neutral'></span>
 104 |     | <span class='neutral'>    /**</span>
 105 |     | <span class='unexecuted'>     * @dev The provided signature is not valid for the expected `voter`.</span>
 106 |     | <span class='neutral'>     * If the `voter` is a contract, the signature is not valid using {IERC1271-isValidSignature}.</span>
 107 |     | <span class='neutral'>     */</span>
 108 |     | <span class='unexecuted'>    error GovernorInvalidSignature(address voter);</span>
 109 |     | <span class='neutral'></span>
 110 |     | <span class='neutral'>    /**</span>
 111 |     | <span class='unexecuted'>     * @dev The given `account` is unable to cancel the proposal with given `proposalId`.</span>
 112 |     | <span class='neutral'>     */</span>
 113 |     | <span class='unexecuted'>    error GovernorUnableToCancel(uint256 proposalId, address account);</span>
 114 |     | <span class='neutral'></span>
 115 |     | <span class='neutral'>    /**</span>
 116 |     | <span class='unexecuted'>     * @dev Emitted when a proposal is created.</span>
 117 |     | <span class='neutral'>     */</span>
 118 |     | <span class='neutral'>    event ProposalCreated(</span>
 119 |     | <span class='neutral'>        uint256 proposalId,</span>
 120 |     | <span class='neutral'>        address proposer,</span>
 121 |     | <span class='neutral'>        address[] targets,</span>
 122 |     | <span class='unexecuted'>        uint256[] values,</span>
 123 |     | <span class='neutral'>        string[] signatures,</span>
 124 |     | <span class='unexecuted'>        bytes[] calldatas,</span>
 125 |     | <span class='unexecuted'>        uint256 voteStart,</span>
 126 |     | <span class='neutral'>        uint256 voteEnd,</span>
 127 |     | <span class='unexecuted'>        string description</span>
 128 |     | <span class='neutral'>    );</span>
 129 |     | <span class='neutral'></span>
 130 |     | <span class='neutral'>    /**</span>
 131 |     | <span class='unexecuted'>     * @dev Emitted when a proposal is queued.</span>
 132 |     | <span class='neutral'>     */</span>
 133 |     | <span class='neutral'>    event ProposalQueued(uint256 proposalId, uint256 etaSeconds);</span>
 134 |     | <span class='neutral'></span>
 135 |     | <span class='neutral'>    /**</span>
 136 |     | <span class='neutral'>     * @dev Emitted when a proposal is executed.</span>
 137 |     | <span class='neutral'>     */</span>
 138 |     | <span class='neutral'>    event ProposalExecuted(uint256 proposalId);</span>
 139 |     | <span class='neutral'></span>
 140 |     | <span class='neutral'>    /**</span>
 141 |     | <span class='neutral'>     * @dev Emitted when a proposal is canceled.</span>
 142 |     | <span class='neutral'>     */</span>
 143 |     | <span class='neutral'>    event ProposalCanceled(uint256 proposalId);</span>
 144 |     | <span class='neutral'></span>
 145 |     | <span class='neutral'>    /**</span>
 146 |     | <span class='neutral'>     * @dev Emitted when a vote is cast without params.</span>
 147 |     | <span class='neutral'>     *</span>
 148 |     | <span class='neutral'>     * Note: `support` values should be seen as buckets. Their interpretation depends on the voting module used.</span>
 149 |     | <span class='neutral'>     */</span>
 150 |     | <span class='neutral'>    event VoteCast(address indexed voter, uint256 proposalId, uint8 support, uint256 weight, string reason);</span>
 151 |     | <span class='neutral'></span>
 152 |     | <span class='neutral'>    /**</span>
 153 |     | <span class='neutral'>     * @dev Emitted when a vote is cast with params.</span>
 154 |     | <span class='neutral'>     *</span>
 155 |     | <span class='neutral'>     * Note: `support` values should be seen as buckets. Their interpretation depends on the voting module used.</span>
 156 |     | <span class='neutral'>     * `params` are additional encoded parameters. Their interpretation  also depends on the voting module used.</span>
 157 |     | <span class='neutral'>     */</span>
 158 |     | <span class='neutral'>    event VoteCastWithParams(</span>
 159 |     | <span class='neutral'>        address indexed voter,</span>
 160 |     | <span class='neutral'>        uint256 proposalId,</span>
 161 |     | <span class='neutral'>        uint8 support,</span>
 162 |     | <span class='neutral'>        uint256 weight,</span>
 163 |     | <span class='neutral'>        string reason,</span>
 164 |     | <span class='neutral'>        bytes params</span>
 165 |     | <span class='neutral'>    );</span>
 166 |     | <span class='neutral'></span>
 167 |     | <span class='neutral'>    /**</span>
 168 |     | <span class='neutral'>     * @notice module:core</span>
 169 |     | <span class='neutral'>     * @dev Name of the governor instance (used in building the EIP-712 domain separator).</span>
 170 |     | <span class='neutral'>     */</span>
 171 |     | <span class='neutral'>    function name() external view returns (string memory);</span>
 172 |     | <span class='neutral'></span>
 173 |     | <span class='neutral'>    /**</span>
 174 |     | <span class='neutral'>     * @notice module:core</span>
 175 |     | <span class='neutral'>     * @dev Version of the governor instance (used in building the EIP-712 domain separator). Default: &quot;1&quot;</span>
 176 |     | <span class='neutral'>     */</span>
 177 |     | <span class='neutral'>    function version() external view returns (string memory);</span>
 178 |     | <span class='neutral'></span>
 179 |     | <span class='neutral'>    /**</span>
 180 |     | <span class='neutral'>     * @notice module:voting</span>
 181 |     | <span class='neutral'>     * @dev A description of the possible `support` values for {castVote} and the way these votes are counted, meant to</span>
 182 |     | <span class='neutral'>     * be consumed by UIs to show correct vote options and interpret the results. The string is a URL-encoded sequence of</span>
 183 |     | <span class='neutral'>     * key-value pairs that each describe one aspect, for example `support=bravo&amp;quorum=for,abstain`.</span>
 184 |     | <span class='neutral'>     *</span>
 185 |     | <span class='neutral'>     * There are 2 standard keys: `support` and `quorum`.</span>
 186 |     | <span class='neutral'>     *</span>
 187 |     | <span class='neutral'>     * - `support=bravo` refers to the vote options 0 = Against, 1 = For, 2 = Abstain, as in `GovernorBravo`.</span>
 188 |     | <span class='neutral'>     * - `quorum=bravo` means that only For votes are counted towards quorum.</span>
 189 |     | <span class='neutral'>     * - `quorum=for,abstain` means that both For and Abstain votes are counted towards quorum.</span>
 190 |     | <span class='neutral'>     *</span>
 191 |     | <span class='neutral'>     * If a counting module makes use of encoded `params`, it should  include this under a `params` key with a unique</span>
 192 |     | <span class='neutral'>     * name that describes the behavior. For example:</span>
 193 |     | <span class='neutral'>     *</span>
 194 |     | <span class='neutral'>     * - `params=fractional` might refer to a scheme where votes are divided fractionally between for/against/abstain.</span>
 195 |     | <span class='neutral'>     * - `params=erc721` might refer to a scheme where specific NFTs are delegated to vote.</span>
 196 |     | <span class='neutral'>     *</span>
 197 |     | <span class='neutral'>     * NOTE: The string can be decoded by the standard</span>
 198 |     | <span class='neutral'>     * https://developer.mozilla.org/en-US/docs/Web/API/URLSearchParams[`URLSearchParams`]</span>
 199 |     | <span class='neutral'>     * JavaScript class.</span>
 200 |     | <span class='neutral'>     */</span>
 201 |     | <span class='neutral'>    // solhint-disable-next-line func-name-mixedcase</span>
 202 |     | <span class='neutral'>    function COUNTING_MODE() external view returns (string memory);</span>
 203 |     | <span class='neutral'></span>
 204 |     | <span class='neutral'>    /**</span>
 205 |     | <span class='neutral'>     * @notice module:core</span>
 206 |     | <span class='neutral'>     * @dev Hashing function used to (re)build the proposal id from the proposal details.</span>
 207 |     | <span class='neutral'>     *</span>
 208 |     | <span class='neutral'>     * NOTE: For all off-chain and external calls, use {getProposalId}.</span>
 209 |     | <span class='neutral'>     */</span>
 210 |     | <span class='neutral'>    function hashProposal(</span>
 211 |     | <span class='neutral'>        address[] memory targets,</span>
 212 |     | <span class='neutral'>        uint256[] memory values,</span>
 213 |     | <span class='neutral'>        bytes[] memory calldatas,</span>
 214 |     | <span class='neutral'>        bytes32 descriptionHash</span>
 215 |     | <span class='neutral'>    ) external pure returns (uint256);</span>
 216 |     | <span class='neutral'></span>
 217 |     | <span class='neutral'>    /**</span>
 218 |     | <span class='neutral'>     * @notice module:core</span>
 219 |     | <span class='neutral'>     * @dev Function used to get the proposal id from the proposal details.</span>
 220 |     | <span class='neutral'>     */</span>
 221 |     | <span class='neutral'>    function getProposalId(</span>
 222 |     | <span class='neutral'>        address[] memory targets,</span>
 223 |     | <span class='neutral'>        uint256[] memory values,</span>
 224 |     | <span class='neutral'>        bytes[] memory calldatas,</span>
 225 |     | <span class='neutral'>        bytes32 descriptionHash</span>
 226 |     | <span class='neutral'>    ) external view returns (uint256);</span>
 227 |     | <span class='neutral'></span>
 228 |     | <span class='neutral'>    /**</span>
 229 |     | <span class='neutral'>     * @notice module:core</span>
 230 |     | <span class='neutral'>     * @dev Current state of a proposal, following Compound&#39;s convention</span>
 231 |     | <span class='neutral'>     */</span>
 232 |     | <span class='neutral'>    function state(uint256 proposalId) external view returns (ProposalState);</span>
 233 |     | <span class='neutral'></span>
 234 |     | <span class='neutral'>    /**</span>
 235 |     | <span class='neutral'>     * @notice module:core</span>
 236 |     | <span class='neutral'>     * @dev The number of votes required in order for a voter to become a proposer.</span>
 237 |     | <span class='neutral'>     */</span>
 238 |     | <span class='neutral'>    function proposalThreshold() external view returns (uint256);</span>
 239 |     | <span class='neutral'></span>
 240 |     | <span class='neutral'>    /**</span>
 241 |     | <span class='neutral'>     * @notice module:core</span>
 242 |     | <span class='neutral'>     * @dev Timepoint used to retrieve user&#39;s votes and quorum. If using block number (as per Compound&#39;s Comp), the</span>
 243 |     | <span class='neutral'>     * snapshot is performed at the end of this block. Hence, voting for this proposal starts at the beginning of the</span>
 244 |     | <span class='neutral'>     * following block.</span>
 245 |     | <span class='neutral'>     */</span>
 246 |     | <span class='neutral'>    function proposalSnapshot(uint256 proposalId) external view returns (uint256);</span>
 247 |     | <span class='neutral'></span>
 248 |     | <span class='neutral'>    /**</span>
 249 |     | <span class='neutral'>     * @notice module:core</span>
 250 |     | <span class='neutral'>     * @dev Timepoint at which votes close. If using block number, votes close at the end of this block, so it is</span>
 251 |     | <span class='neutral'>     * possible to cast a vote during this block.</span>
 252 |     | <span class='neutral'>     */</span>
 253 |     | <span class='neutral'>    function proposalDeadline(uint256 proposalId) external view returns (uint256);</span>
 254 |     | <span class='neutral'></span>
 255 |     | <span class='neutral'>    /**</span>
 256 |     | <span class='neutral'>     * @notice module:core</span>
 257 |     | <span class='neutral'>     * @dev The account that created a proposal.</span>
 258 |     | <span class='neutral'>     */</span>
 259 |     | <span class='neutral'>    function proposalProposer(uint256 proposalId) external view returns (address);</span>
 260 |     | <span class='neutral'></span>
 261 |     | <span class='neutral'>    /**</span>
 262 |     | <span class='neutral'>     * @notice module:core</span>
 263 |     | <span class='neutral'>     * @dev The time when a queued proposal becomes executable (&quot;ETA&quot;). Unlike {proposalSnapshot} and</span>
 264 |     | <span class='neutral'>     * {proposalDeadline}, this doesn&#39;t use the governor clock, and instead relies on the executor&#39;s clock which may be</span>
 265 |     | <span class='neutral'>     * different. In most cases this will be a timestamp.</span>
 266 |     | <span class='neutral'>     */</span>
 267 |     | <span class='neutral'>    function proposalEta(uint256 proposalId) external view returns (uint256);</span>
 268 |     | <span class='neutral'></span>
 269 |     | <span class='neutral'>    /**</span>
 270 |     | <span class='neutral'>     * @notice module:core</span>
 271 |     | <span class='neutral'>     * @dev Whether a proposal needs to be queued before execution.</span>
 272 |     | <span class='neutral'>     */</span>
 273 |     | <span class='neutral'>    function proposalNeedsQueuing(uint256 proposalId) external view returns (bool);</span>
 274 |     | <span class='neutral'></span>
 275 |     | <span class='neutral'>    /**</span>
 276 |     | <span class='neutral'>     * @notice module:user-config</span>
 277 |     | <span class='neutral'>     * @dev Delay, between the proposal is created and the vote starts. The unit this duration is expressed in depends</span>
 278 |     | <span class='neutral'>     * on the clock (see ERC-6372) this contract uses.</span>
 279 |     | <span class='neutral'>     *</span>
 280 |     | <span class='neutral'>     * This can be increased to leave time for users to buy voting power, or delegate it, before the voting of a</span>
 281 |     | <span class='neutral'>     * proposal starts.</span>
 282 |     | <span class='neutral'>     *</span>
 283 |     | <span class='neutral'>     * NOTE: While this interface returns a uint256, timepoints are stored as uint48 following the ERC-6372 clock type.</span>
 284 |     | <span class='neutral'>     * Consequently this value must fit in a uint48 (when added to the current clock). See {IERC6372-clock}.</span>
 285 |     | <span class='neutral'>     */</span>
 286 |     | <span class='neutral'>    function votingDelay() external view returns (uint256);</span>
 287 |     | <span class='neutral'></span>
 288 |     | <span class='neutral'>    /**</span>
 289 |     | <span class='neutral'>     * @notice module:user-config</span>
 290 |     | <span class='neutral'>     * @dev Delay between the vote start and vote end. The unit this duration is expressed in depends on the clock</span>
 291 |     | <span class='neutral'>     * (see ERC-6372) this contract uses.</span>
 292 |     | <span class='neutral'>     *</span>
 293 |     | <span class='neutral'>     * NOTE: The {votingDelay} can delay the start of the vote. This must be considered when setting the voting</span>
 294 |     | <span class='neutral'>     * duration compared to the voting delay.</span>
 295 |     | <span class='neutral'>     *</span>
 296 |     | <span class='neutral'>     * NOTE: This value is stored when the proposal is submitted so that possible changes to the value do not affect</span>
 297 |     | <span class='neutral'>     * proposals that have already been submitted. The type used to save it is a uint32. Consequently, while this</span>
 298 |     | <span class='neutral'>     * interface returns a uint256, the value it returns should fit in a uint32.</span>
 299 |     | <span class='neutral'>     */</span>
 300 |     | <span class='neutral'>    function votingPeriod() external view returns (uint256);</span>
 301 |     | <span class='neutral'></span>
 302 |     | <span class='neutral'>    /**</span>
 303 |     | <span class='neutral'>     * @notice module:user-config</span>
 304 |     | <span class='neutral'>     * @dev Minimum number of cast voted required for a proposal to be successful.</span>
 305 |     | <span class='neutral'>     *</span>
 306 |     | <span class='neutral'>     * NOTE: The `timepoint` parameter corresponds to the snapshot used for counting vote. This allows to scale the</span>
 307 |     | <span class='neutral'>     * quorum depending on values such as the totalSupply of a token at this timepoint (see {ERC20Votes}).</span>
 308 |     | <span class='neutral'>     */</span>
 309 |     | <span class='neutral'>    function quorum(uint256 timepoint) external view returns (uint256);</span>
 310 |     | <span class='neutral'></span>
 311 |     | <span class='neutral'>    /**</span>
 312 |     | <span class='neutral'>     * @notice module:reputation</span>
 313 |     | <span class='neutral'>     * @dev Voting power of an `account` at a specific `timepoint`.</span>
 314 |     | <span class='neutral'>     *</span>
 315 |     | <span class='neutral'>     * Note: this can be implemented in a number of ways, for example by reading the delegated balance from one (or</span>
 316 |     | <span class='neutral'>     * multiple), {ERC20Votes} tokens.</span>
 317 |     | <span class='neutral'>     */</span>
 318 |     | <span class='neutral'>    function getVotes(address account, uint256 timepoint) external view returns (uint256);</span>
 319 |     | <span class='neutral'></span>
 320 |     | <span class='neutral'>    /**</span>
 321 |     | <span class='neutral'>     * @notice module:reputation</span>
 322 |     | <span class='neutral'>     * @dev Voting power of an `account` at a specific `timepoint` given additional encoded parameters.</span>
 323 |     | <span class='neutral'>     */</span>
 324 |     | <span class='neutral'>    function getVotesWithParams(</span>
 325 |     | <span class='neutral'>        address account,</span>
 326 |     | <span class='neutral'>        uint256 timepoint,</span>
 327 |     | <span class='neutral'>        bytes memory params</span>
 328 |     | <span class='neutral'>    ) external view returns (uint256);</span>
 329 |     | <span class='neutral'></span>
 330 |     | <span class='neutral'>    /**</span>
 331 |     | <span class='neutral'>     * @notice module:voting</span>
 332 |     | <span class='neutral'>     * @dev Returns whether `account` has cast a vote on `proposalId`.</span>
 333 |     | <span class='neutral'>     */</span>
 334 |     | <span class='neutral'>    function hasVoted(uint256 proposalId, address account) external view returns (bool);</span>
 335 |     | <span class='neutral'></span>
 336 |     | <span class='neutral'>    /**</span>
 337 |     | <span class='neutral'>     * @dev Create a new proposal. Vote start after a delay specified by {IGovernor-votingDelay} and lasts for a</span>
 338 |     | <span class='neutral'>     * duration specified by {IGovernor-votingPeriod}.</span>
 339 |     | <span class='neutral'>     *</span>
 340 |     | <span class='neutral'>     * Emits a {ProposalCreated} event.</span>
 341 |     | <span class='neutral'>     *</span>
 342 |     | <span class='neutral'>     * NOTE: The state of the Governor and `targets` may change between the proposal creation and its execution.</span>
 343 |     | <span class='neutral'>     * This may be the result of third party actions on the targeted contracts, or other governor proposals.</span>
 344 |     | <span class='neutral'>     * For example, the balance of this contract could be updated or its access control permissions may be modified,</span>
 345 |     | <span class='neutral'>     * possibly compromising the proposal&#39;s ability to execute successfully (e.g. the governor doesn&#39;t have enough</span>
 346 |     | <span class='neutral'>     * value to cover a proposal with multiple transfers).</span>
 347 |     | <span class='neutral'>     */</span>
 348 |     | <span class='neutral'>    function propose(</span>
 349 |     | <span class='neutral'>        address[] memory targets,</span>
 350 |     | <span class='neutral'>        uint256[] memory values,</span>
 351 |     | <span class='neutral'>        bytes[] memory calldatas,</span>
 352 |     | <span class='neutral'>        string memory description</span>
 353 |     | <span class='neutral'>    ) external returns (uint256 proposalId);</span>
 354 |     | <span class='neutral'></span>
 355 |     | <span class='neutral'>    /**</span>
 356 |     | <span class='neutral'>     * @dev Queue a proposal. Some governors require this step to be performed before execution can happen. If queuing</span>
 357 |     | <span class='neutral'>     * is not necessary, this function may revert.</span>
 358 |     | <span class='neutral'>     * Queuing a proposal requires the quorum to be reached, the vote to be successful, and the deadline to be reached.</span>
 359 |     | <span class='neutral'>     *</span>
 360 |     | <span class='neutral'>     * Emits a {ProposalQueued} event.</span>
 361 |     | <span class='neutral'>     */</span>
 362 |     | <span class='neutral'>    function queue(</span>
 363 |     | <span class='neutral'>        address[] memory targets,</span>
 364 |     | <span class='neutral'>        uint256[] memory values,</span>
 365 |     | <span class='neutral'>        bytes[] memory calldatas,</span>
 366 |     | <span class='neutral'>        bytes32 descriptionHash</span>
 367 |     | <span class='neutral'>    ) external returns (uint256 proposalId);</span>
 368 |     | <span class='neutral'></span>
 369 |     | <span class='neutral'>    /**</span>
 370 |     | <span class='neutral'>     * @dev Execute a successful proposal. This requires the quorum to be reached, the vote to be successful, and the</span>
 371 |     | <span class='neutral'>     * deadline to be reached. Depending on the governor it might also be required that the proposal was queued and</span>
 372 |     | <span class='neutral'>     * that some delay passed.</span>
 373 |     | <span class='neutral'>     *</span>
 374 |     | <span class='neutral'>     * Emits a {ProposalExecuted} event.</span>
 375 |     | <span class='neutral'>     *</span>
 376 |     | <span class='neutral'>     * NOTE: Some modules can modify the requirements for execution, for example by adding an additional timelock.</span>
 377 |     | <span class='neutral'>     */</span>
 378 |     | <span class='neutral'>    function execute(</span>
 379 |     | <span class='neutral'>        address[] memory targets,</span>
 380 |     | <span class='neutral'>        uint256[] memory values,</span>
 381 |     | <span class='neutral'>        bytes[] memory calldatas,</span>
 382 |     | <span class='neutral'>        bytes32 descriptionHash</span>
 383 |     | <span class='neutral'>    ) external payable returns (uint256 proposalId);</span>
 384 |     | <span class='neutral'></span>
 385 |     | <span class='neutral'>    /**</span>
 386 |     | <span class='neutral'>     * @dev Cancel a proposal. A proposal is cancellable by the proposer, but only while it is Pending state, i.e.</span>
 387 |     | <span class='neutral'>     * before the vote starts.</span>
 388 |     | <span class='neutral'>     *</span>
 389 |     | <span class='neutral'>     * Emits a {ProposalCanceled} event.</span>
 390 |     | <span class='neutral'>     */</span>
 391 |     | <span class='neutral'>    function cancel(</span>
 392 |     | <span class='neutral'>        address[] memory targets,</span>
 393 |     | <span class='neutral'>        uint256[] memory values,</span>
 394 |     | <span class='neutral'>        bytes[] memory calldatas,</span>
 395 |     | <span class='neutral'>        bytes32 descriptionHash</span>
 396 |     | <span class='neutral'>    ) external returns (uint256 proposalId);</span>
 397 |     | <span class='neutral'></span>
 398 |     | <span class='neutral'>    /**</span>
 399 |     | <span class='neutral'>     * @dev Cast a vote</span>
 400 |     | <span class='neutral'>     *</span>
 401 |     | <span class='neutral'>     * Emits a {VoteCast} event.</span>
 402 |     | <span class='neutral'>     */</span>
 403 |     | <span class='neutral'>    function castVote(uint256 proposalId, uint8 support) external returns (uint256 balance);</span>
 404 |     | <span class='neutral'></span>
 405 |     | <span class='neutral'>    /**</span>
 406 |     | <span class='neutral'>     * @dev Cast a vote with a reason</span>
 407 |     | <span class='neutral'>     *</span>
 408 |     | <span class='neutral'>     * Emits a {VoteCast} event.</span>
 409 |     | <span class='neutral'>     */</span>
 410 |     | <span class='neutral'>    function castVoteWithReason(</span>
 411 |     | <span class='neutral'>        uint256 proposalId,</span>
 412 |     | <span class='neutral'>        uint8 support,</span>
 413 |     | <span class='neutral'>        string calldata reason</span>
 414 |     | <span class='neutral'>    ) external returns (uint256 balance);</span>
 415 |     | <span class='neutral'></span>
 416 |     | <span class='neutral'>    /**</span>
 417 |     | <span class='neutral'>     * @dev Cast a vote with a reason and additional encoded parameters</span>
 418 |     | <span class='neutral'>     *</span>
 419 |     | <span class='neutral'>     * Emits a {VoteCast} or {VoteCastWithParams} event depending on the length of params.</span>
 420 |     | <span class='neutral'>     */</span>
 421 |     | <span class='neutral'>    function castVoteWithReasonAndParams(</span>
 422 |     | <span class='neutral'>        uint256 proposalId,</span>
 423 |     | <span class='neutral'>        uint8 support,</span>
 424 |     | <span class='neutral'>        string calldata reason,</span>
 425 |     | <span class='neutral'>        bytes memory params</span>
 426 |     | <span class='neutral'>    ) external returns (uint256 balance);</span>
 427 |     | <span class='neutral'></span>
 428 |     | <span class='neutral'>    /**</span>
 429 |     | <span class='neutral'>     * @dev Cast a vote using the voter&#39;s signature, including ERC-1271 signature support.</span>
 430 |     | <span class='neutral'>     *</span>
 431 |     | <span class='neutral'>     * Emits a {VoteCast} event.</span>
 432 |     | <span class='neutral'>     */</span>
 433 |     | <span class='neutral'>    function castVoteBySig(</span>
 434 |     | <span class='neutral'>        uint256 proposalId,</span>
 435 |     | <span class='neutral'>        uint8 support,</span>
 436 |     | <span class='neutral'>        address voter,</span>
 437 |     | <span class='neutral'>        bytes memory signature</span>
 438 |     | <span class='neutral'>    ) external returns (uint256 balance);</span>
 439 |     | <span class='neutral'></span>
 440 |     | <span class='neutral'>    /**</span>
 441 |     | <span class='neutral'>     * @dev Cast a vote with a reason and additional encoded parameters using the voter&#39;s signature,</span>
 442 |     | <span class='neutral'>     * including ERC-1271 signature support.</span>
 443 |     | <span class='neutral'>     *</span>
 444 |     | <span class='neutral'>     * Emits a {VoteCast} or {VoteCastWithParams} event depending on the length of params.</span>
 445 |     | <span class='neutral'>     */</span>
 446 |     | <span class='neutral'>    function castVoteWithReasonAndParamsBySig(</span>
 447 |     | <span class='neutral'>        uint256 proposalId,</span>
 448 |     | <span class='neutral'>        uint8 support,</span>
 449 |     | <span class='neutral'>        address voter,</span>
 450 |     | <span class='neutral'>        string calldata reason,</span>
 451 |     | <span class='neutral'>        bytes memory params,</span>
 452 |     | <span class='neutral'>        bytes memory signature</span>
 453 |     | <span class='neutral'>    ) external returns (uint256 balance);</span>
 454 |     | <span class='neutral'>}</span>
 455 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/phantom/Documents/azemora/azemora-contracts/lib/openzeppelin-contracts/contracts/governance/utils/IVotes.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>// OpenZeppelin Contracts (last updated v5.0.0) (governance/utils/IVotes.sol)</span>
  3 |     | <span class='neutral'>pragma solidity &gt;=0.8.4;</span>
  4 |     | <span class='neutral'></span>
  5 |     | <span class='neutral'>/**</span>
  6 |     | <span class='neutral'> * @dev Common interface for {ERC20Votes}, {ERC721Votes}, and other {Votes}-enabled contracts.</span>
  7 |     | <span class='neutral'> */</span>
  8 |     | <span class='neutral'>interface IVotes {</span>
  9 |     | <span class='neutral'>    /**</span>
 10 |     | <span class='neutral'>     * @dev The signature used has expired.</span>
 11 |     | <span class='neutral'>     */</span>
 12 |     | <span class='neutral'>    error VotesExpiredSignature(uint256 expiry);</span>
 13 |     | <span class='neutral'></span>
 14 |     | <span class='neutral'>    /**</span>
 15 |     | <span class='neutral'>     * @dev Emitted when an account changes their delegate.</span>
 16 |     | <span class='neutral'>     */</span>
 17 |     | <span class='neutral'>    event DelegateChanged(address indexed delegator, address indexed fromDelegate, address indexed toDelegate);</span>
 18 |     | <span class='neutral'></span>
 19 |     | <span class='neutral'>    /**</span>
 20 |     | <span class='neutral'>     * @dev Emitted when a token transfer or delegate change results in changes to a delegate&#39;s number of voting units.</span>
 21 |     | <span class='neutral'>     */</span>
 22 |     | <span class='neutral'>    event DelegateVotesChanged(address indexed delegate, uint256 previousVotes, uint256 newVotes);</span>
 23 |     | <span class='neutral'></span>
 24 |     | <span class='neutral'>    /**</span>
 25 |     | <span class='neutral'>     * @dev Returns the current amount of votes that `account` has.</span>
 26 |     | <span class='neutral'>     */</span>
 27 |     | <span class='neutral'>    function getVotes(address account) external view returns (uint256);</span>
 28 |     | <span class='neutral'></span>
 29 |     | <span class='neutral'>    /**</span>
 30 |     | <span class='neutral'>     * @dev Returns the amount of votes that `account` had at a specific moment in the past. If the `clock()` is</span>
 31 |     | <span class='neutral'>     * configured to use block numbers, this will return the value at the end of the corresponding block.</span>
 32 |     | <span class='neutral'>     */</span>
 33 |     | <span class='neutral'>    function getPastVotes(address account, uint256 timepoint) external view returns (uint256);</span>
 34 |     | <span class='neutral'></span>
 35 |     | <span class='neutral'>    /**</span>
 36 |     | <span class='neutral'>     * @dev Returns the total supply of votes available at a specific moment in the past. If the `clock()` is</span>
 37 |     | <span class='neutral'>     * configured to use block numbers, this will return the value at the end of the corresponding block.</span>
 38 |     | <span class='neutral'>     *</span>
 39 |     | <span class='neutral'>     * NOTE: This value is the sum of all available votes, which is not necessarily the sum of all delegated votes.</span>
 40 |     | <span class='neutral'>     * Votes that have not been delegated are still part of total supply, even though they would not participate in a</span>
 41 |     | <span class='neutral'>     * vote.</span>
 42 |     | <span class='neutral'>     */</span>
 43 |     | <span class='neutral'>    function getPastTotalSupply(uint256 timepoint) external view returns (uint256);</span>
 44 |     | <span class='neutral'></span>
 45 |     | <span class='neutral'>    /**</span>
 46 |     | <span class='neutral'>     * @dev Returns the delegate that `account` has chosen.</span>
 47 |     | <span class='neutral'>     */</span>
 48 |     | <span class='unexecuted'>    function delegates(address account) external view returns (address);</span>
 49 |     | <span class='neutral'></span>
 50 |     | <span class='neutral'>    /**</span>
 51 |     | <span class='unexecuted'>     * @dev Delegates votes from the sender to `delegatee`.</span>
 52 |     | <span class='neutral'>     */</span>
 53 |     | <span class='unexecuted'>    function delegate(address delegatee) external;</span>
 54 |     | <span class='neutral'></span>
 55 |     | <span class='neutral'>    /**</span>
 56 |     | <span class='unexecuted'>     * @dev Delegates votes from signer to `delegatee`.</span>
 57 |     | <span class='neutral'>     */</span>
 58 |     | <span class='neutral'>    function delegateBySig(address delegatee, uint256 nonce, uint256 expiry, uint8 v, bytes32 r, bytes32 s) external;</span>
 59 |     | <span class='neutral'>}</span>
 60 |     | <span class='unexecuted'></span>

</code>
<br />

<b>/home/phantom/Documents/azemora/azemora-contracts/lib/openzeppelin-contracts/contracts/interfaces/IERC1271.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>// OpenZeppelin Contracts (last updated v5.3.0) (interfaces/IERC1271.sol)</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>pragma solidity &gt;=0.5.0;</span>
  5 |     | <span class='neutral'></span>
  6 |     | <span class='neutral'>/**</span>
  7 |     | <span class='neutral'> * @dev Interface of the ERC-1271 standard signature validation method for</span>
  8 |     | <span class='neutral'> * contracts as defined in https://eips.ethereum.org/EIPS/eip-1271[ERC-1271].</span>
  9 |     | <span class='neutral'> */</span>
 10 |     | <span class='neutral'>interface IERC1271 {</span>
 11 |     | <span class='neutral'>    /**</span>
 12 |     | <span class='neutral'>     * @dev Should return whether the signature provided is valid for the provided data</span>
 13 |     | <span class='neutral'>     * @param hash      Hash of the data to be signed</span>
 14 |     | <span class='neutral'>     * @param signature Signature byte array associated with `hash`</span>
 15 |     | <span class='neutral'>     */</span>
 16 |     | <span class='neutral'>    function isValidSignature(bytes32 hash, bytes calldata signature) external view returns (bytes4 magicValue);</span>
 17 |     | <span class='neutral'>}</span>
 18 |     | <span class='unexecuted'></span>

</code>
<br />

<b>/home/phantom/Documents/azemora/azemora-contracts/lib/openzeppelin-contracts/contracts/interfaces/IERC165.sol</b>
<code>
 1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
 2 |     | <span class='neutral'>// OpenZeppelin Contracts (last updated v5.0.0) (interfaces/IERC165.sol)</span>
 3 |     | <span class='neutral'></span>
 4 |     | <span class='neutral'>pragma solidity &gt;=0.4.16;</span>
 5 |     | <span class='neutral'></span>
 6 |     | <span class='neutral'>import {IERC165} from &quot;../utils/introspection/IERC165.sol&quot;;</span>
 7 |     | <span class='unexecuted'></span>

</code>
<br />

<b>/home/phantom/Documents/azemora/azemora-contracts/lib/openzeppelin-contracts/contracts/interfaces/IERC1967.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>// OpenZeppelin Contracts (last updated v5.0.0) (interfaces/IERC1967.sol)</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>pragma solidity &gt;=0.4.11;</span>
  5 |     | <span class='neutral'></span>
  6 |     | <span class='neutral'>/**</span>
  7 |     | <span class='neutral'> * @dev ERC-1967: Proxy Storage Slots. This interface contains the events defined in the ERC.</span>
  8 |     | <span class='neutral'> */</span>
  9 |     | <span class='neutral'>interface IERC1967 {</span>
 10 |     | <span class='neutral'>    /**</span>
 11 |     | <span class='neutral'>     * @dev Emitted when the implementation is upgraded.</span>
 12 |     | <span class='neutral'>     */</span>
 13 |     | <span class='neutral'>    event Upgraded(address indexed implementation);</span>
 14 |     | <span class='neutral'></span>
 15 |     | <span class='neutral'>    /**</span>
 16 |     | <span class='neutral'>     * @dev Emitted when the admin account has changed.</span>
 17 |     | <span class='neutral'>     */</span>
 18 |     | <span class='neutral'>    event AdminChanged(address previousAdmin, address newAdmin);</span>
 19 |     | <span class='neutral'></span>
 20 |     | <span class='neutral'>    /**</span>
 21 |     | <span class='neutral'>     * @dev Emitted when the beacon is changed.</span>
 22 |     | <span class='neutral'>     */</span>
 23 |     | <span class='neutral'>    event BeaconUpgraded(address indexed beacon);</span>
 24 |     | <span class='neutral'>}</span>
 25 |     | <span class='unexecuted'></span>

</code>
<br />

<b>/home/phantom/Documents/azemora/azemora-contracts/lib/openzeppelin-contracts/contracts/interfaces/IERC5267.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>// OpenZeppelin Contracts (last updated v5.0.0) (interfaces/IERC5267.sol)</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>pragma solidity &gt;=0.4.16;</span>
  5 |     | <span class='neutral'></span>
  6 |     | <span class='neutral'>interface IERC5267 {</span>
  7 |     | <span class='neutral'>    /**</span>
  8 |     | <span class='neutral'>     * @dev MAY be emitted to signal that the domain could have changed.</span>
  9 |     | <span class='neutral'>     */</span>
 10 |     | <span class='neutral'>    event EIP712DomainChanged();</span>
 11 |     | <span class='neutral'></span>
 12 |     | <span class='neutral'>    /**</span>
 13 |     | <span class='neutral'>     * @dev returns the fields and values that describe the domain separator used by this contract for EIP-712</span>
 14 |     | <span class='neutral'>     * signature.</span>
 15 |     | <span class='neutral'>     */</span>
 16 |     | <span class='neutral'>    function eip712Domain()</span>
 17 |     | <span class='neutral'>        external</span>
 18 |     | <span class='neutral'>        view</span>
 19 |     | <span class='neutral'>        returns (</span>
 20 |     | <span class='neutral'>            bytes1 fields,</span>
 21 |     | <span class='neutral'>            string memory name,</span>
 22 |     | <span class='neutral'>            string memory version,</span>
 23 |     | <span class='neutral'>            uint256 chainId,</span>
 24 |     | <span class='neutral'>            address verifyingContract,</span>
 25 |     | <span class='neutral'>            bytes32 salt,</span>
 26 |     | <span class='neutral'>            uint256[] memory extensions</span>
 27 |     | <span class='neutral'>        );</span>
 28 |     | <span class='neutral'>}</span>
 29 |     | <span class='unexecuted'></span>

</code>
<br />

<b>/home/phantom/Documents/azemora/azemora-contracts/lib/openzeppelin-contracts/contracts/interfaces/IERC5805.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>// OpenZeppelin Contracts (last updated v5.0.0) (interfaces/IERC5805.sol)</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>pragma solidity &gt;=0.8.4;</span>
  5 |     | <span class='neutral'></span>
  6 |     | <span class='neutral'>import {IVotes} from &quot;../governance/utils/IVotes.sol&quot;;</span>
  7 |     | <span class='neutral'>import {IERC6372} from &quot;./IERC6372.sol&quot;;</span>
  8 |     | <span class='neutral'></span>
  9 |     | <span class='neutral'>interface IERC5805 is IERC6372, IVotes {}</span>
 10 |     | <span class='unexecuted'></span>

</code>
<br />

<b>/home/phantom/Documents/azemora/azemora-contracts/lib/openzeppelin-contracts/contracts/interfaces/IERC6372.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>// OpenZeppelin Contracts (last updated v5.0.0) (interfaces/IERC6372.sol)</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>pragma solidity &gt;=0.4.16;</span>
  5 |     | <span class='neutral'></span>
  6 |     | <span class='neutral'>interface IERC6372 {</span>
  7 |     | <span class='neutral'>    /**</span>
  8 |     | <span class='neutral'>     * @dev Clock used for flagging checkpoints. Can be overridden to implement timestamp based checkpoints (and voting).</span>
  9 |     | <span class='neutral'>     */</span>
 10 |     | <span class='neutral'>    function clock() external view returns (uint48);</span>
 11 |     | <span class='neutral'></span>
 12 |     | <span class='neutral'>    /**</span>
 13 |     | <span class='neutral'>     * @dev Description of the clock</span>
 14 |     | <span class='neutral'>     */</span>
 15 |     | <span class='neutral'>    // solhint-disable-next-line func-name-mixedcase</span>
 16 |     | <span class='neutral'>    function CLOCK_MODE() external view returns (string memory);</span>
 17 |     | <span class='neutral'>}</span>
 18 |     | <span class='unexecuted'></span>

</code>
<br />

<b>/home/phantom/Documents/azemora/azemora-contracts/lib/openzeppelin-contracts/contracts/interfaces/IERC7913.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'></span>
  3 |     | <span class='neutral'>pragma solidity &gt;=0.5.0;</span>
  4 |     | <span class='neutral'></span>
  5 |     | <span class='neutral'>/**</span>
  6 |     | <span class='neutral'> * @dev Signature verifier interface.</span>
  7 |     | <span class='neutral'> */</span>
  8 |     | <span class='neutral'>interface IERC7913SignatureVerifier {</span>
  9 |     | <span class='neutral'>    /**</span>
 10 |     | <span class='neutral'>     * @dev Verifies `signature` as a valid signature of `hash` by `key`.</span>
 11 |     | <span class='neutral'>     *</span>
 12 |     | <span class='neutral'>     * MUST return the bytes4 magic value IERC7913SignatureVerifier.verify.selector if the signature is valid.</span>
 13 |     | <span class='neutral'>     * SHOULD return 0xffffffff or revert if the signature is not valid.</span>
 14 |     | <span class='neutral'>     * SHOULD return 0xffffffff or revert if the key is empty</span>
 15 |     | <span class='neutral'>     */</span>
 16 |     | <span class='neutral'>    function verify(bytes calldata key, bytes32 hash, bytes calldata signature) external view returns (bytes4);</span>
 17 |     | <span class='neutral'>}</span>
 18 |     | <span class='unexecuted'></span>

</code>
<br />

<b>/home/phantom/Documents/azemora/azemora-contracts/lib/openzeppelin-contracts/contracts/interfaces/draft-IERC1822.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>// OpenZeppelin Contracts (last updated v5.1.0) (interfaces/draft-IERC1822.sol)</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>pragma solidity &gt;=0.4.16;</span>
  5 |     | <span class='neutral'></span>
  6 |     | <span class='neutral'>/**</span>
  7 |     | <span class='neutral'> * @dev ERC-1822: Universal Upgradeable Proxy Standard (UUPS) documents a method for upgradeability through a simplified</span>
  8 |     | <span class='neutral'> * proxy whose upgrades are fully controlled by the current implementation.</span>
  9 |     | <span class='neutral'> */</span>
 10 |     | <span class='neutral'>interface IERC1822Proxiable {</span>
 11 |     | <span class='neutral'>    /**</span>
 12 |     | <span class='neutral'>     * @dev Returns the storage slot that the proxiable contract assumes is being used to store the implementation</span>
 13 |     | <span class='neutral'>     * address.</span>
 14 |     | <span class='neutral'>     *</span>
 15 |     | <span class='neutral'>     * IMPORTANT: A proxy pointing at a proxiable contract should not be considered proxiable itself, because this risks</span>
 16 |     | <span class='neutral'>     * bricking a proxy that upgrades to it, by delegating to itself until out of gas. Thus it is critical that this</span>
 17 |     | <span class='neutral'>     * function revert if invoked through a proxy.</span>
 18 |     | <span class='neutral'>     */</span>
 19 |     | <span class='neutral'>    function proxiableUUID() external view returns (bytes32);</span>
 20 |     | <span class='neutral'>}</span>
 21 | *   | <span class='executed'></span>

</code>
<br />

<b>/home/phantom/Documents/azemora/azemora-contracts/lib/openzeppelin-contracts/contracts/interfaces/draft-IERC6093.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'>// OpenZeppelin Contracts (last updated v5.1.0) (interfaces/draft-IERC6093.sol)</span>
   3 |     | <span class='neutral'>pragma solidity &gt;=0.8.4;</span>
   4 |     | <span class='neutral'></span>
   5 |     | <span class='neutral'>/**</span>
   6 |     | <span class='neutral'> * @dev Standard ERC-20 Errors</span>
   7 |     | <span class='neutral'> * Interface of the https://eips.ethereum.org/EIPS/eip-6093[ERC-6093] custom errors for ERC-20 tokens.</span>
   8 |     | <span class='neutral'> */</span>
   9 |     | <span class='neutral'>interface IERC20Errors {</span>
  10 |     | <span class='neutral'>    /**</span>
  11 |     | <span class='neutral'>     * @dev Indicates an error related to the current `balance` of a `sender`. Used in transfers.</span>
  12 |     | <span class='neutral'>     * @param sender Address whose tokens are being transferred.</span>
  13 |     | <span class='neutral'>     * @param balance Current balance for the interacting account.</span>
  14 |     | <span class='neutral'>     * @param needed Minimum amount required to perform a transfer.</span>
  15 |     | <span class='neutral'>     */</span>
  16 |     | <span class='neutral'>    error ERC20InsufficientBalance(address sender, uint256 balance, uint256 needed);</span>
  17 |     | <span class='neutral'></span>
  18 |     | <span class='neutral'>    /**</span>
  19 |     | <span class='neutral'>     * @dev Indicates a failure with the token `sender`. Used in transfers.</span>
  20 |     | <span class='neutral'>     * @param sender Address whose tokens are being transferred.</span>
  21 |     | <span class='neutral'>     */</span>
  22 |     | <span class='neutral'>    error ERC20InvalidSender(address sender);</span>
  23 |     | <span class='neutral'></span>
  24 |     | <span class='neutral'>    /**</span>
  25 |     | <span class='neutral'>     * @dev Indicates a failure with the token `receiver`. Used in transfers.</span>
  26 |     | <span class='neutral'>     * @param receiver Address to which tokens are being transferred.</span>
  27 |     | <span class='neutral'>     */</span>
  28 |     | <span class='neutral'>    error ERC20InvalidReceiver(address receiver);</span>
  29 |     | <span class='neutral'></span>
  30 | *   | <span class='executed'>    /**</span>
  31 | *   | <span class='executed'>     * @dev Indicates a failure with the `spender`s `allowance`. Used in transfers.</span>
  32 |     | <span class='neutral'>     * @param spender Address that may be allowed to operate on tokens without being their owner.</span>
  33 |     | <span class='neutral'>     * @param allowance Amount of tokens a `spender` is allowed to operate with.</span>
  34 |     | <span class='neutral'>     * @param needed Minimum amount required to perform a transfer.</span>
  35 |     | <span class='neutral'>     */</span>
  36 |     | <span class='neutral'>    error ERC20InsufficientAllowance(address spender, uint256 allowance, uint256 needed);</span>
  37 |     | <span class='neutral'></span>
  38 |     | <span class='neutral'>    /**</span>
  39 |     | <span class='neutral'>     * @dev Indicates a failure with the `approver` of a token to be approved. Used in approvals.</span>
  40 |     | <span class='neutral'>     * @param approver Address initiating an approval operation.</span>
  41 |     | <span class='neutral'>     */</span>
  42 |     | <span class='neutral'>    error ERC20InvalidApprover(address approver);</span>
  43 |     | <span class='neutral'></span>
  44 |     | <span class='neutral'>    /**</span>
  45 |     | <span class='unexecuted'>     * @dev Indicates a failure with the `spender` to be approved. Used in approvals.</span>
  46 |     | <span class='neutral'>     * @param spender Address that may be allowed to operate on tokens without being their owner.</span>
  47 |     | <span class='neutral'>     */</span>
  48 |     | <span class='neutral'>    error ERC20InvalidSpender(address spender);</span>
  49 |     | <span class='neutral'>}</span>
  50 |     | <span class='neutral'></span>
  51 |     | <span class='neutral'>/**</span>
  52 |     | <span class='neutral'> * @dev Standard ERC-721 Errors</span>
  53 |     | <span class='neutral'> * Interface of the https://eips.ethereum.org/EIPS/eip-6093[ERC-6093] custom errors for ERC-721 tokens.</span>
  54 |     | <span class='neutral'> */</span>
  55 |     | <span class='neutral'>interface IERC721Errors {</span>
  56 |     | <span class='neutral'>    /**</span>
  57 |     | <span class='neutral'>     * @dev Indicates that an address can&#39;t be an owner. For example, `address(0)` is a forbidden owner in ERC-20.</span>
  58 |     | <span class='neutral'>     * Used in balance queries.</span>
  59 |     | <span class='neutral'>     * @param owner Address of the current owner of a token.</span>
  60 |     | <span class='neutral'>     */</span>
  61 |     | <span class='neutral'>    error ERC721InvalidOwner(address owner);</span>
  62 |     | <span class='neutral'></span>
  63 |     | <span class='neutral'>    /**</span>
  64 |     | <span class='neutral'>     * @dev Indicates a `tokenId` whose `owner` is the zero address.</span>
  65 |     | <span class='neutral'>     * @param tokenId Identifier number of a token.</span>
  66 |     | <span class='neutral'>     */</span>
  67 |     | <span class='unexecuted'>    error ERC721NonexistentToken(uint256 tokenId);</span>
  68 |     | <span class='neutral'></span>
  69 |     | <span class='neutral'>    /**</span>
  70 |     | <span class='neutral'>     * @dev Indicates an error related to the ownership over a particular token. Used in transfers.</span>
  71 |     | <span class='neutral'>     * @param sender Address whose tokens are being transferred.</span>
  72 |     | <span class='neutral'>     * @param tokenId Identifier number of a token.</span>
  73 |     | <span class='unexecuted'>     * @param owner Address of the current owner of a token.</span>
  74 |     | <span class='neutral'>     */</span>
  75 |     | <span class='unexecuted'>    error ERC721IncorrectOwner(address sender, uint256 tokenId, address owner);</span>
  76 |     | <span class='neutral'></span>
  77 |     | <span class='neutral'>    /**</span>
  78 |     | <span class='neutral'>     * @dev Indicates a failure with the token `sender`. Used in transfers.</span>
  79 |     | <span class='neutral'>     * @param sender Address whose tokens are being transferred.</span>
  80 |     | <span class='neutral'>     */</span>
  81 |     | <span class='neutral'>    error ERC721InvalidSender(address sender);</span>
  82 |     | <span class='neutral'></span>
  83 |     | <span class='neutral'>    /**</span>
  84 |     | <span class='neutral'>     * @dev Indicates a failure with the token `receiver`. Used in transfers.</span>
  85 |     | <span class='neutral'>     * @param receiver Address to which tokens are being transferred.</span>
  86 |     | <span class='neutral'>     */</span>
  87 |     | <span class='neutral'>    error ERC721InvalidReceiver(address receiver);</span>
  88 |     | <span class='neutral'></span>
  89 |     | <span class='neutral'>    /**</span>
  90 |     | <span class='neutral'>     * @dev Indicates a failure with the `operator`s approval. Used in transfers.</span>
  91 |     | <span class='neutral'>     * @param operator Address that may be allowed to operate on tokens without being their owner.</span>
  92 |     | <span class='unexecuted'>     * @param tokenId Identifier number of a token.</span>
  93 |     | <span class='neutral'>     */</span>
  94 |     | <span class='unexecuted'>    error ERC721InsufficientApproval(address operator, uint256 tokenId);</span>
  95 |     | <span class='neutral'></span>
  96 |     | <span class='neutral'>    /**</span>
  97 |     | <span class='neutral'>     * @dev Indicates a failure with the `approver` of a token to be approved. Used in approvals.</span>
  98 |     | <span class='neutral'>     * @param approver Address initiating an approval operation.</span>
  99 |     | <span class='neutral'>     */</span>
 100 |     | <span class='neutral'>    error ERC721InvalidApprover(address approver);</span>
 101 |     | <span class='neutral'></span>
 102 |     | <span class='neutral'>    /**</span>
 103 |     | <span class='neutral'>     * @dev Indicates a failure with the `operator` to be approved. Used in approvals.</span>
 104 | *   | <span class='executed'>     * @param operator Address that may be allowed to operate on tokens without being their owner.</span>
 105 |     | <span class='neutral'>     */</span>
 106 |     | <span class='unexecuted'>    error ERC721InvalidOperator(address operator);</span>
 107 |     | <span class='neutral'>}</span>
 108 |     | <span class='neutral'></span>
 109 |     | <span class='neutral'>/**</span>
 110 |     | <span class='unexecuted'> * @dev Standard ERC-1155 Errors</span>
 111 | *   | <span class='executed'> * Interface of the https://eips.ethereum.org/EIPS/eip-6093[ERC-6093] custom errors for ERC-1155 tokens.</span>
 112 |     | <span class='neutral'> */</span>
 113 |     | <span class='neutral'>interface IERC1155Errors {</span>
 114 |     | <span class='neutral'>    /**</span>
 115 |     | <span class='neutral'>     * @dev Indicates an error related to the current `balance` of a `sender`. Used in transfers.</span>
 116 |     | <span class='unexecuted'>     * @param sender Address whose tokens are being transferred.</span>
 117 |     | <span class='unexecuted'>     * @param balance Current balance for the interacting account.</span>
 118 |     | <span class='unexecuted'>     * @param needed Minimum amount required to perform a transfer.</span>
 119 |     | <span class='unexecuted'>     * @param tokenId Identifier number of a token.</span>
 120 |     | <span class='neutral'>     */</span>
 121 |     | <span class='unexecuted'>    error ERC1155InsufficientBalance(address sender, uint256 balance, uint256 needed, uint256 tokenId);</span>
 122 |     | <span class='neutral'></span>
 123 |     | <span class='neutral'>    /**</span>
 124 |     | <span class='unexecuted'>     * @dev Indicates a failure with the token `sender`. Used in transfers.</span>
 125 |     | <span class='unexecuted'>     * @param sender Address whose tokens are being transferred.</span>
 126 |     | <span class='unexecuted'>     */</span>
 127 |     | <span class='unexecuted'>    error ERC1155InvalidSender(address sender);</span>
 128 |     | <span class='neutral'></span>
 129 |     | <span class='neutral'>    /**</span>
 130 |     | <span class='unexecuted'>     * @dev Indicates a failure with the token `receiver`. Used in transfers.</span>
 131 |     | <span class='neutral'>     * @param receiver Address to which tokens are being transferred.</span>
 132 |     | <span class='neutral'>     */</span>
 133 |     | <span class='neutral'>    error ERC1155InvalidReceiver(address receiver);</span>
 134 |     | <span class='neutral'></span>
 135 |     | <span class='neutral'>    /**</span>
 136 |     | <span class='neutral'>     * @dev Indicates a failure with the `operator`s approval. Used in transfers.</span>
 137 |     | <span class='neutral'>     * @param operator Address that may be allowed to operate on tokens without being their owner.</span>
 138 |     | <span class='neutral'>     * @param owner Address of the current owner of a token.</span>
 139 |     | <span class='neutral'>     */</span>
 140 |     | <span class='neutral'>    error ERC1155MissingApprovalForAll(address operator, address owner);</span>
 141 |     | <span class='neutral'></span>
 142 |     | <span class='neutral'>    /**</span>
 143 |     | <span class='neutral'>     * @dev Indicates a failure with the `approver` of a token to be approved. Used in approvals.</span>
 144 |     | <span class='neutral'>     * @param approver Address initiating an approval operation.</span>
 145 |     | <span class='neutral'>     */</span>
 146 |     | <span class='neutral'>    error ERC1155InvalidApprover(address approver);</span>
 147 |     | <span class='neutral'></span>
 148 |     | <span class='neutral'>    /**</span>
 149 |     | <span class='neutral'>     * @dev Indicates a failure with the `operator` to be approved. Used in approvals.</span>
 150 |     | <span class='unexecuted'>     * @param operator Address that may be allowed to operate on tokens without being their owner.</span>
 151 |     | <span class='neutral'>     */</span>
 152 |     | <span class='unexecuted'>    error ERC1155InvalidOperator(address operator);</span>
 153 |     | <span class='neutral'></span>
 154 |     | <span class='neutral'>    /**</span>
 155 |     | <span class='unexecuted'>     * @dev Indicates an array length mismatch between ids and values in a safeBatchTransferFrom operation.</span>
 156 |     | <span class='unexecuted'>     * Used in batch transfers.</span>
 157 |     | <span class='unexecuted'>     * @param idsLength Length of the array of token identifiers</span>
 158 |     | <span class='unexecuted'>     * @param valuesLength Length of the array of token amounts</span>
 159 |     | <span class='neutral'>     */</span>
 160 |     | <span class='unexecuted'>    error ERC1155InvalidArrayLength(uint256 idsLength, uint256 valuesLength);</span>
 161 |     | <span class='neutral'>}</span>
 162 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/phantom/Documents/azemora/azemora-contracts/lib/openzeppelin-contracts/contracts/mocks/token/ERC20Mock.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>pragma solidity ^0.8.20;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>import {ERC20} from &quot;../../token/ERC20/ERC20.sol&quot;;</span>
  5 |     | <span class='neutral'></span>
  6 |     | <span class='neutral'>contract ERC20Mock is ERC20 {</span>
  7 |     | <span class='neutral'>    constructor() ERC20(&quot;ERC20Mock&quot;, &quot;E20M&quot;) {}</span>
  8 |     | <span class='neutral'></span>
  9 |     | <span class='neutral'>    function mint(address account, uint256 amount) external {</span>
 10 |     | <span class='neutral'>        _mint(account, amount);</span>
 11 |     | <span class='neutral'>    }</span>
 12 |     | <span class='neutral'></span>
 13 |     | <span class='neutral'>    function burn(address account, uint256 amount) external {</span>
 14 |     | <span class='neutral'>        _burn(account, amount);</span>
 15 |     | <span class='neutral'>    }</span>
 16 |     | <span class='neutral'>}</span>
 17 | *   | <span class='executed'></span>

</code>
<br />

<b>/home/phantom/Documents/azemora/azemora-contracts/lib/openzeppelin-contracts/contracts/proxy/ERC1967/ERC1967Proxy.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>// OpenZeppelin Contracts (last updated v5.2.0) (proxy/ERC1967/ERC1967Proxy.sol)</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>pragma solidity ^0.8.22;</span>
  5 |     | <span class='neutral'></span>
  6 |     | <span class='neutral'>import {Proxy} from &quot;../Proxy.sol&quot;;</span>
  7 |     | <span class='neutral'>import {ERC1967Utils} from &quot;./ERC1967Utils.sol&quot;;</span>
  8 |     | <span class='neutral'></span>
  9 |     | <span class='neutral'>/**</span>
 10 |     | <span class='neutral'> * @dev This contract implements an upgradeable proxy. It is upgradeable because calls are delegated to an</span>
 11 |     | <span class='neutral'> * implementation address that can be changed. This address is stored in storage in the location specified by</span>
 12 |     | <span class='neutral'> * https://eips.ethereum.org/EIPS/eip-1967[ERC-1967], so that it doesn&#39;t conflict with the storage layout of the</span>
 13 |     | <span class='neutral'> * implementation behind the proxy.</span>
 14 |     | <span class='neutral'> */</span>
 15 |     | <span class='neutral'>contract ERC1967Proxy is Proxy {</span>
 16 |     | <span class='neutral'>    /**</span>
 17 |     | <span class='neutral'>     * @dev Initializes the upgradeable proxy with an initial implementation specified by `implementation`.</span>
 18 |     | <span class='neutral'>     *</span>
 19 |     | <span class='neutral'>     * If `_data` is nonempty, it&#39;s used as data in a delegate call to `implementation`. This will typically be an</span>
 20 |     | <span class='neutral'>     * encoded function call, and allows initializing the storage of the proxy like a Solidity constructor.</span>
 21 |     | <span class='neutral'>     *</span>
 22 |     | <span class='unexecuted'>     * Requirements:</span>
 23 |     | <span class='neutral'>     *</span>
 24 |     | <span class='neutral'>     * - If `data` is empty, `msg.value` must be zero.</span>
 25 |     | <span class='neutral'>     */</span>
 26 |     | <span class='unexecuted'>    constructor(address implementation, bytes memory _data) payable {</span>
 27 |     | <span class='unexecuted'>        ERC1967Utils.upgradeToAndCall(implementation, _data);</span>
 28 |     | <span class='neutral'>    }</span>
 29 |     | <span class='neutral'></span>
 30 |     | <span class='unexecuted'>    /**</span>
 31 | *   | <span class='executed'>     * @dev Returns the current implementation address.</span>
 32 |     | <span class='neutral'>     *</span>
 33 |     | <span class='neutral'>     * TIP: To get this value clients can read directly from the storage slot shown below (specified by ERC-1967) using</span>
 34 | *   | <span class='executed'>     * the https://eth.wiki/json-rpc/API#eth_getstorageat[`eth_getStorageAt`] RPC call.</span>
 35 |     | <span class='neutral'>     * `0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc`</span>
 36 |     | <span class='neutral'>     */</span>
 37 |     | <span class='neutral'>    function _implementation() internal view virtual override returns (address) {</span>
 38 |     | <span class='unexecuted'>        return ERC1967Utils.getImplementation();</span>
 39 |     | <span class='neutral'>    }</span>
 40 |     | <span class='neutral'>}</span>
 41 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/phantom/Documents/azemora/azemora-contracts/lib/openzeppelin-contracts/contracts/proxy/ERC1967/ERC1967Utils.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'>// OpenZeppelin Contracts (last updated v5.2.0) (proxy/ERC1967/ERC1967Utils.sol)</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>pragma solidity ^0.8.21;</span>
   5 |     | <span class='neutral'></span>
   6 |     | <span class='neutral'>import {IBeacon} from &quot;../beacon/IBeacon.sol&quot;;</span>
   7 |     | <span class='neutral'>import {IERC1967} from &quot;../../interfaces/IERC1967.sol&quot;;</span>
   8 |     | <span class='neutral'>import {Address} from &quot;../../utils/Address.sol&quot;;</span>
   9 |     | <span class='neutral'>import {StorageSlot} from &quot;../../utils/StorageSlot.sol&quot;;</span>
  10 |     | <span class='neutral'></span>
  11 |     | <span class='neutral'>/**</span>
  12 |     | <span class='neutral'> * @dev This library provides getters and event emitting update functions for</span>
  13 |     | <span class='neutral'> * https://eips.ethereum.org/EIPS/eip-1967[ERC-1967] slots.</span>
  14 |     | <span class='neutral'> */</span>
  15 |     | <span class='neutral'>library ERC1967Utils {</span>
  16 |     | <span class='neutral'>    /**</span>
  17 |     | <span class='neutral'>     * @dev Storage slot with the address of the current implementation.</span>
  18 |     | <span class='neutral'>     * This is the keccak-256 hash of &quot;eip1967.proxy.implementation&quot; subtracted by 1.</span>
  19 |     | <span class='neutral'>     */</span>
  20 |     | <span class='neutral'>    // solhint-disable-next-line private-vars-leading-underscore</span>
  21 |     | <span class='neutral'>    bytes32 internal constant IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;</span>
  22 |     | <span class='neutral'></span>
  23 |     | <span class='neutral'>    /**</span>
  24 |     | <span class='neutral'>     * @dev The `implementation` of the proxy is invalid.</span>
  25 |     | <span class='neutral'>     */</span>
  26 |     | <span class='neutral'>    error ERC1967InvalidImplementation(address implementation);</span>
  27 |     | <span class='neutral'></span>
  28 |     | <span class='neutral'>    /**</span>
  29 |     | <span class='neutral'>     * @dev The `admin` of the proxy is invalid.</span>
  30 |     | <span class='neutral'>     */</span>
  31 |     | <span class='neutral'>    error ERC1967InvalidAdmin(address admin);</span>
  32 |     | <span class='neutral'></span>
  33 |     | <span class='neutral'>    /**</span>
  34 |     | <span class='neutral'>     * @dev The `beacon` of the proxy is invalid.</span>
  35 |     | <span class='neutral'>     */</span>
  36 |     | <span class='neutral'>    error ERC1967InvalidBeacon(address beacon);</span>
  37 |     | <span class='neutral'></span>
  38 |     | <span class='neutral'>    /**</span>
  39 |     | <span class='neutral'>     * @dev An upgrade function sees `msg.value &gt; 0` that may be lost.</span>
  40 |     | <span class='neutral'>     */</span>
  41 |     | <span class='neutral'>    error ERC1967NonPayable();</span>
  42 |     | <span class='neutral'></span>
  43 |     | <span class='neutral'>    /**</span>
  44 |     | <span class='neutral'>     * @dev Returns the current implementation address.</span>
  45 |     | <span class='neutral'>     */</span>
  46 |     | <span class='neutral'>    function getImplementation() internal view returns (address) {</span>
  47 |     | <span class='neutral'>        return StorageSlot.getAddressSlot(IMPLEMENTATION_SLOT).value;</span>
  48 |     | <span class='neutral'>    }</span>
  49 |     | <span class='neutral'></span>
  50 |     | <span class='neutral'>    /**</span>
  51 |     | <span class='neutral'>     * @dev Stores a new address in the ERC-1967 implementation slot.</span>
  52 |     | <span class='neutral'>     */</span>
  53 |     | <span class='neutral'>    function _setImplementation(address newImplementation) private {</span>
  54 |     | <span class='neutral'>        if (newImplementation.code.length == 0) {</span>
  55 |     | <span class='neutral'>            revert ERC1967InvalidImplementation(newImplementation);</span>
  56 |     | <span class='neutral'>        }</span>
  57 |     | <span class='neutral'>        StorageSlot.getAddressSlot(IMPLEMENTATION_SLOT).value = newImplementation;</span>
  58 |     | <span class='neutral'>    }</span>
  59 |     | <span class='neutral'></span>
  60 |     | <span class='neutral'>    /**</span>
  61 |     | <span class='neutral'>     * @dev Performs implementation upgrade with additional setup call if data is nonempty.</span>
  62 |     | <span class='unexecuted'>     * This function is payable only if the setup call is performed, otherwise `msg.value` is rejected</span>
  63 |     | <span class='neutral'>     * to avoid stuck value in the contract.</span>
  64 |     | <span class='neutral'>     *</span>
  65 |     | <span class='neutral'>     * Emits an {IERC1967-Upgraded} event.</span>
  66 |     | <span class='neutral'>     */</span>
  67 |     | <span class='unexecuted'>    function upgradeToAndCall(address newImplementation, bytes memory data) internal {</span>
  68 |     | <span class='unexecuted'>        _setImplementation(newImplementation);</span>
  69 |     | <span class='unexecuted'>        emit IERC1967.Upgraded(newImplementation);</span>
  70 |     | <span class='neutral'></span>
  71 |     | <span class='neutral'>        if (data.length &gt; 0) {</span>
  72 |     | <span class='neutral'>            Address.functionDelegateCall(newImplementation, data);</span>
  73 |     | <span class='neutral'>        } else {</span>
  74 |     | <span class='unexecuted'>            _checkNonPayable();</span>
  75 |     | <span class='neutral'>        }</span>
  76 |     | <span class='unexecuted'>    }</span>
  77 |     | <span class='neutral'></span>
  78 |     | <span class='neutral'>    /**</span>
  79 |     | <span class='unexecuted'>     * @dev Storage slot with the admin of the contract.</span>
  80 |     | <span class='unexecuted'>     * This is the keccak-256 hash of &quot;eip1967.proxy.admin&quot; subtracted by 1.</span>
  81 |     | <span class='neutral'>     */</span>
  82 |     | <span class='unexecuted'>    // solhint-disable-next-line private-vars-leading-underscore</span>
  83 |     | <span class='unexecuted'>    bytes32 internal constant ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;</span>
  84 |     | <span class='neutral'></span>
  85 |     | <span class='neutral'>    /**</span>
  86 |     | <span class='unexecuted'>     * @dev Returns the current admin.</span>
  87 |     | <span class='neutral'>     *</span>
  88 |     | <span class='unexecuted'>     * TIP: To get this value clients can read directly from the storage slot shown below (specified by ERC-1967) using</span>
  89 |     | <span class='neutral'>     * the https://eth.wiki/json-rpc/API#eth_getstorageat[`eth_getStorageAt`] RPC call.</span>
  90 |     | <span class='neutral'>     * `0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103`</span>
  91 |     | <span class='neutral'>     */</span>
  92 |     | <span class='neutral'>    function getAdmin() internal view returns (address) {</span>
  93 |     | <span class='neutral'>        return StorageSlot.getAddressSlot(ADMIN_SLOT).value;</span>
  94 |     | <span class='neutral'>    }</span>
  95 |     | <span class='neutral'></span>
  96 |     | <span class='neutral'>    /**</span>
  97 |     | <span class='neutral'>     * @dev Stores a new address in the ERC-1967 admin slot.</span>
  98 |     | <span class='neutral'>     */</span>
  99 |     | <span class='neutral'>    function _setAdmin(address newAdmin) private {</span>
 100 |     | <span class='neutral'>        if (newAdmin == address(0)) {</span>
 101 |     | <span class='neutral'>            revert ERC1967InvalidAdmin(address(0));</span>
 102 |     | <span class='neutral'>        }</span>
 103 |     | <span class='neutral'>        StorageSlot.getAddressSlot(ADMIN_SLOT).value = newAdmin;</span>
 104 |     | <span class='neutral'>    }</span>
 105 |     | <span class='neutral'></span>
 106 |     | <span class='neutral'>    /**</span>
 107 |     | <span class='unexecuted'>     * @dev Changes the admin of the proxy.</span>
 108 |     | <span class='neutral'>     *</span>
 109 |     | <span class='unexecuted'>     * Emits an {IERC1967-AdminChanged} event.</span>
 110 |     | <span class='neutral'>     */</span>
 111 |     | <span class='unexecuted'>    function changeAdmin(address newAdmin) internal {</span>
 112 |     | <span class='neutral'>        emit IERC1967.AdminChanged(getAdmin(), newAdmin);</span>
 113 |     | <span class='neutral'>        _setAdmin(newAdmin);</span>
 114 |     | <span class='neutral'>    }</span>
 115 |     | <span class='neutral'></span>
 116 |     | <span class='neutral'>    /**</span>
 117 |     | <span class='unexecuted'>     * @dev The storage slot of the UpgradeableBeacon contract which defines the implementation for this proxy.</span>
 118 |     | <span class='unexecuted'>     * This is the keccak-256 hash of &quot;eip1967.proxy.beacon&quot; subtracted by 1.</span>
 119 |     | <span class='neutral'>     */</span>
 120 |     | <span class='unexecuted'>    // solhint-disable-next-line private-vars-leading-underscore</span>
 121 |     | <span class='neutral'>    bytes32 internal constant BEACON_SLOT = 0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50;</span>
 122 |     | <span class='neutral'></span>
 123 |     | <span class='neutral'>    /**</span>
 124 |     | <span class='unexecuted'>     * @dev Returns the current beacon.</span>
 125 |     | <span class='neutral'>     */</span>
 126 |     | <span class='neutral'>    function getBeacon() internal view returns (address) {</span>
 127 |     | <span class='unexecuted'>        return StorageSlot.getAddressSlot(BEACON_SLOT).value;</span>
 128 |     | <span class='neutral'>    }</span>
 129 |     | <span class='neutral'></span>
 130 |     | <span class='unexecuted'>    /**</span>
 131 |     | <span class='neutral'>     * @dev Stores a new beacon in the ERC-1967 beacon slot.</span>
 132 |     | <span class='unexecuted'>     */</span>
 133 |     | <span class='neutral'>    function _setBeacon(address newBeacon) private {</span>
 134 |     | <span class='unexecuted'>        if (newBeacon.code.length == 0) {</span>
 135 |     | <span class='neutral'>            revert ERC1967InvalidBeacon(newBeacon);</span>
 136 |     | <span class='unexecuted'>        }</span>
 137 |     | <span class='neutral'></span>
 138 |     | <span class='neutral'>        StorageSlot.getAddressSlot(BEACON_SLOT).value = newBeacon;</span>
 139 |     | <span class='neutral'></span>
 140 |     | <span class='neutral'>        address beaconImplementation = IBeacon(newBeacon).implementation();</span>
 141 |     | <span class='neutral'>        if (beaconImplementation.code.length == 0) {</span>
 142 |     | <span class='neutral'>            revert ERC1967InvalidImplementation(beaconImplementation);</span>
 143 |     | <span class='neutral'>        }</span>
 144 |     | <span class='neutral'>    }</span>
 145 |     | <span class='neutral'></span>
 146 |     | <span class='neutral'>    /**</span>
 147 |     | <span class='unexecuted'>     * @dev Change the beacon and trigger a setup call if data is nonempty.</span>
 148 |     | <span class='unexecuted'>     * This function is payable only if the setup call is performed, otherwise `msg.value` is rejected</span>
 149 |     | <span class='unexecuted'>     * to avoid stuck value in the contract.</span>
 150 |     | <span class='neutral'>     *</span>
 151 |     | <span class='neutral'>     * Emits an {IERC1967-BeaconUpgraded} event.</span>
 152 |     | <span class='neutral'>     *</span>
 153 |     | <span class='neutral'>     * CAUTION: Invoking this function has no effect on an instance of {BeaconProxy} since v5, since</span>
 154 |     | <span class='neutral'>     * it uses an immutable beacon without looking at the value of the ERC-1967 beacon slot for</span>
 155 |     | <span class='neutral'>     * efficiency.</span>
 156 |     | <span class='neutral'>     */</span>
 157 |     | <span class='neutral'>    function upgradeBeaconToAndCall(address newBeacon, bytes memory data) internal {</span>
 158 |     | <span class='neutral'>        _setBeacon(newBeacon);</span>
 159 |     | <span class='neutral'>        emit IERC1967.BeaconUpgraded(newBeacon);</span>
 160 |     | <span class='neutral'></span>
 161 |     | <span class='neutral'>        if (data.length &gt; 0) {</span>
 162 |     | <span class='neutral'>            Address.functionDelegateCall(IBeacon(newBeacon).implementation(), data);</span>
 163 |     | <span class='neutral'>        } else {</span>
 164 |     | <span class='unexecuted'>            _checkNonPayable();</span>
 165 |     | <span class='neutral'>        }</span>
 166 |     | <span class='neutral'>    }</span>
 167 |     | <span class='neutral'></span>
 168 |     | <span class='neutral'>    /**</span>
 169 |     | <span class='unexecuted'>     * @dev Reverts if `msg.value` is not zero. It can be used to avoid `msg.value` stuck in the contract</span>
 170 |     | <span class='unexecuted'>     * if an upgrade doesn&#39;t perform an initialization call.</span>
 171 |     | <span class='unexecuted'>     */</span>
 172 |     | <span class='unexecuted'>    function _checkNonPayable() private {</span>
 173 |     | <span class='neutral'>        if (msg.value &gt; 0) {</span>
 174 |     | <span class='neutral'>            revert ERC1967NonPayable();</span>
 175 |     | <span class='neutral'>        }</span>
 176 |     | <span class='neutral'>    }</span>
 177 |     | <span class='neutral'>}</span>
 178 |     | <span class='unexecuted'></span>

</code>
<br />

<b>/home/phantom/Documents/azemora/azemora-contracts/lib/openzeppelin-contracts/contracts/proxy/Proxy.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>// OpenZeppelin Contracts (last updated v5.0.0) (proxy/Proxy.sol)</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>pragma solidity ^0.8.20;</span>
  5 |     | <span class='neutral'></span>
  6 |     | <span class='neutral'>/**</span>
  7 |     | <span class='neutral'> * @dev This abstract contract provides a fallback function that delegates all calls to another contract using the EVM</span>
  8 |     | <span class='neutral'> * instruction `delegatecall`. We refer to the second contract as the _implementation_ behind the proxy, and it has to</span>
  9 |     | <span class='neutral'> * be specified by overriding the virtual {_implementation} function.</span>
 10 |     | <span class='neutral'> *</span>
 11 |     | <span class='neutral'> * Additionally, delegation to the implementation can be triggered manually through the {_fallback} function, or to a</span>
 12 |     | <span class='neutral'> * different contract through the {_delegate} function.</span>
 13 |     | <span class='neutral'> *</span>
 14 |     | <span class='neutral'> * The success and return data of the delegated call will be returned back to the caller of the proxy.</span>
 15 |     | <span class='neutral'> */</span>
 16 |     | <span class='neutral'>abstract contract Proxy {</span>
 17 |     | <span class='neutral'>    /**</span>
 18 |     | <span class='neutral'>     * @dev Delegates the current call to `implementation`.</span>
 19 |     | <span class='neutral'>     *</span>
 20 |     | <span class='neutral'>     * This function does not return to its internal call site, it will return directly to the external caller.</span>
 21 |     | <span class='neutral'>     */</span>
 22 |     | <span class='neutral'>    function _delegate(address implementation) internal virtual {</span>
 23 |     | <span class='neutral'>        assembly {</span>
 24 |     | <span class='neutral'>            // Copy msg.data. We take full control of memory in this inline assembly</span>
 25 |     | <span class='neutral'>            // block because it will not return to Solidity code. We overwrite the</span>
 26 |     | <span class='neutral'>            // Solidity scratch pad at memory position 0.</span>
 27 |     | <span class='unexecuted'>            calldatacopy(0, 0, calldatasize())</span>
 28 |     | <span class='neutral'></span>
 29 |     | <span class='neutral'>            // Call the implementation.</span>
 30 |     | <span class='neutral'>            // out and outsize are 0 because we don&#39;t know the size yet.</span>
 31 |     | <span class='neutral'>            let result := delegatecall(gas(), implementation, 0, calldatasize(), 0, 0)</span>
 32 |     | <span class='neutral'></span>
 33 |     | <span class='neutral'>            // Copy the returned data.</span>
 34 |     | <span class='neutral'>            returndatacopy(0, 0, returndatasize())</span>
 35 |     | <span class='neutral'></span>
 36 |     | <span class='neutral'>            switch result</span>
 37 |     | <span class='neutral'>            // delegatecall returns 0 on error.</span>
 38 |     | <span class='neutral'>            case 0 {</span>
 39 |     | <span class='neutral'>                revert(0, returndatasize())</span>
 40 |     | <span class='neutral'>            }</span>
 41 |     | <span class='neutral'>            default {</span>
 42 |     | <span class='neutral'>                return(0, returndatasize())</span>
 43 |     | <span class='neutral'>            }</span>
 44 |     | <span class='unexecuted'>        }</span>
 45 |     | <span class='neutral'>    }</span>
 46 |     | <span class='neutral'></span>
 47 |     | <span class='neutral'>    /**</span>
 48 |     | <span class='unexecuted'>     * @dev This is a virtual function that should be overridden so it returns the address to which the fallback</span>
 49 |     | <span class='neutral'>     * function and {_fallback} should delegate.</span>
 50 |     | <span class='neutral'>     */</span>
 51 |     | <span class='unexecuted'>    function _implementation() internal view virtual returns (address);</span>
 52 |     | <span class='neutral'></span>
 53 |     | <span class='neutral'>    /**</span>
 54 |     | <span class='neutral'>     * @dev Delegates the current call to the address returned by `_implementation()`.</span>
 55 |     | <span class='neutral'>     *</span>
 56 |     | <span class='unexecuted'>     * This function does not return to its internal call site, it will return directly to the external caller.</span>
 57 |     | <span class='neutral'>     */</span>
 58 |     | <span class='unexecuted'>    function _fallback() internal virtual {</span>
 59 |     | <span class='unexecuted'>        _delegate(_implementation());</span>
 60 |     | <span class='neutral'>    }</span>
 61 |     | <span class='neutral'></span>
 62 |     | <span class='unexecuted'>    /**</span>
 63 |     | <span class='unexecuted'>     * @dev Fallback function that delegates calls to the address returned by `_implementation()`. Will run if no other</span>
 64 |     | <span class='unexecuted'>     * function in the contract matches the call data.</span>
 65 |     | <span class='unexecuted'>     */</span>
 66 |     | <span class='unexecuted'>    fallback() external payable virtual {</span>
 67 |     | <span class='unexecuted'>        _fallback();</span>
 68 |     | <span class='neutral'>    }</span>
 69 |     | <span class='neutral'>}</span>
 70 |     | <span class='unexecuted'></span>

</code>
<br />

<b>/home/phantom/Documents/azemora/azemora-contracts/lib/openzeppelin-contracts/contracts/proxy/beacon/IBeacon.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>// OpenZeppelin Contracts (last updated v5.0.0) (proxy/beacon/IBeacon.sol)</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>pragma solidity &gt;=0.4.16;</span>
  5 |     | <span class='neutral'></span>
  6 |     | <span class='neutral'>/**</span>
  7 |     | <span class='neutral'> * @dev This is the interface that {BeaconProxy} expects of its beacon.</span>
  8 |     | <span class='neutral'> */</span>
  9 |     | <span class='neutral'>interface IBeacon {</span>
 10 |     | <span class='neutral'>    /**</span>
 11 |     | <span class='neutral'>     * @dev Must return an address that can be used as a delegate call target.</span>
 12 |     | <span class='neutral'>     *</span>
 13 |     | <span class='neutral'>     * {UpgradeableBeacon} will check that this address is a contract.</span>
 14 |     | <span class='neutral'>     */</span>
 15 |     | <span class='neutral'>    function implementation() external view returns (address);</span>
 16 |     | <span class='neutral'>}</span>
 17 |     | <span class='unexecuted'></span>

</code>
<br />

<b>/home/phantom/Documents/azemora/azemora-contracts/lib/openzeppelin-contracts/contracts/token/ERC1155/IERC1155.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'>// OpenZeppelin Contracts (last updated v5.3.0) (token/ERC1155/IERC1155.sol)</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>pragma solidity &gt;=0.6.2;</span>
   5 |     | <span class='neutral'></span>
   6 |     | <span class='neutral'>import {IERC165} from &quot;../../utils/introspection/IERC165.sol&quot;;</span>
   7 |     | <span class='neutral'></span>
   8 |     | <span class='neutral'>/**</span>
   9 |     | <span class='neutral'> * @dev Required interface of an ERC-1155 compliant contract, as defined in the</span>
  10 |     | <span class='neutral'> * https://eips.ethereum.org/EIPS/eip-1155[ERC].</span>
  11 |     | <span class='neutral'> */</span>
  12 |     | <span class='neutral'>interface IERC1155 is IERC165 {</span>
  13 |     | <span class='neutral'>    /**</span>
  14 |     | <span class='neutral'>     * @dev Emitted when `value` amount of tokens of type `id` are transferred from `from` to `to` by `operator`.</span>
  15 |     | <span class='neutral'>     */</span>
  16 |     | <span class='neutral'>    event TransferSingle(address indexed operator, address indexed from, address indexed to, uint256 id, uint256 value);</span>
  17 |     | <span class='neutral'></span>
  18 |     | <span class='neutral'>    /**</span>
  19 |     | <span class='neutral'>     * @dev Equivalent to multiple {TransferSingle} events, where `operator`, `from` and `to` are the same for all</span>
  20 |     | <span class='neutral'>     * transfers.</span>
  21 |     | <span class='neutral'>     */</span>
  22 |     | <span class='neutral'>    event TransferBatch(</span>
  23 |     | <span class='neutral'>        address indexed operator,</span>
  24 |     | <span class='neutral'>        address indexed from,</span>
  25 |     | <span class='neutral'>        address indexed to,</span>
  26 |     | <span class='neutral'>        uint256[] ids,</span>
  27 |     | <span class='unexecuted'>        uint256[] values</span>
  28 |     | <span class='neutral'>    );</span>
  29 |     | <span class='neutral'></span>
  30 |     | <span class='neutral'>    /**</span>
  31 |     | <span class='unexecuted'>     * @dev Emitted when `account` grants or revokes permission to `operator` to transfer their tokens, according to</span>
  32 |     | <span class='neutral'>     * `approved`.</span>
  33 |     | <span class='neutral'>     */</span>
  34 |     | <span class='neutral'>    event ApprovalForAll(address indexed account, address indexed operator, bool approved);</span>
  35 |     | <span class='neutral'></span>
  36 |     | <span class='neutral'>    /**</span>
  37 |     | <span class='neutral'>     * @dev Emitted when the URI for token type `id` changes to `value`, if it is a non-programmatic URI.</span>
  38 |     | <span class='neutral'>     *</span>
  39 |     | <span class='neutral'>     * If an {URI} event was emitted for `id`, the standard</span>
  40 |     | <span class='neutral'>     * https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[guarantees] that `value` will equal the value</span>
  41 |     | <span class='neutral'>     * returned by {IERC1155MetadataURI-uri}.</span>
  42 |     | <span class='neutral'>     */</span>
  43 |     | <span class='neutral'>    event URI(string value, uint256 indexed id);</span>
  44 |     | <span class='neutral'></span>
  45 |     | <span class='neutral'>    /**</span>
  46 |     | <span class='neutral'>     * @dev Returns the value of tokens of token type `id` owned by `account`.</span>
  47 |     | <span class='neutral'>     */</span>
  48 |     | <span class='neutral'>    function balanceOf(address account, uint256 id) external view returns (uint256);</span>
  49 |     | <span class='neutral'></span>
  50 |     | <span class='neutral'>    /**</span>
  51 |     | <span class='neutral'>     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {balanceOf}.</span>
  52 |     | <span class='neutral'>     *</span>
  53 |     | <span class='neutral'>     * Requirements:</span>
  54 |     | <span class='neutral'>     *</span>
  55 |     | <span class='neutral'>     * - `accounts` and `ids` must have the same length.</span>
  56 |     | <span class='neutral'>     */</span>
  57 |     | <span class='neutral'>    function balanceOfBatch(</span>
  58 |     | <span class='neutral'>        address[] calldata accounts,</span>
  59 |     | <span class='neutral'>        uint256[] calldata ids</span>
  60 |     | <span class='neutral'>    ) external view returns (uint256[] memory);</span>
  61 |     | <span class='neutral'></span>
  62 |     | <span class='neutral'>    /**</span>
  63 |     | <span class='neutral'>     * @dev Grants or revokes permission to `operator` to transfer the caller&#39;s tokens, according to `approved`,</span>
  64 |     | <span class='neutral'>     *</span>
  65 |     | <span class='neutral'>     * Emits an {ApprovalForAll} event.</span>
  66 |     | <span class='neutral'>     *</span>
  67 |     | <span class='neutral'>     * Requirements:</span>
  68 |     | <span class='neutral'>     *</span>
  69 |     | <span class='neutral'>     * - `operator` cannot be the zero address.</span>
  70 |     | <span class='neutral'>     */</span>
  71 |     | <span class='neutral'>    function setApprovalForAll(address operator, bool approved) external;</span>
  72 |     | <span class='neutral'></span>
  73 |     | <span class='neutral'>    /**</span>
  74 |     | <span class='neutral'>     * @dev Returns true if `operator` is approved to transfer ``account``&#39;s tokens.</span>
  75 |     | <span class='neutral'>     *</span>
  76 |     | <span class='neutral'>     * See {setApprovalForAll}.</span>
  77 |     | <span class='neutral'>     */</span>
  78 |     | <span class='neutral'>    function isApprovedForAll(address account, address operator) external view returns (bool);</span>
  79 |     | <span class='neutral'></span>
  80 |     | <span class='neutral'>    /**</span>
  81 |     | <span class='neutral'>     * @dev Transfers a `value` amount of tokens of type `id` from `from` to `to`.</span>
  82 |     | <span class='neutral'>     *</span>
  83 |     | <span class='neutral'>     * WARNING: This function can potentially allow a reentrancy attack when transferring tokens</span>
  84 |     | <span class='neutral'>     * to an untrusted contract, when invoking {IERC1155Receiver-onERC1155Received} on the receiver.</span>
  85 |     | <span class='neutral'>     * Ensure to follow the checks-effects-interactions pattern and consider employing</span>
  86 |     | <span class='neutral'>     * reentrancy guards when interacting with untrusted contracts.</span>
  87 |     | <span class='neutral'>     *</span>
  88 |     | <span class='neutral'>     * Emits a {TransferSingle} event.</span>
  89 |     | <span class='neutral'>     *</span>
  90 |     | <span class='neutral'>     * Requirements:</span>
  91 |     | <span class='neutral'>     *</span>
  92 |     | <span class='neutral'>     * - `to` cannot be the zero address.</span>
  93 |     | <span class='neutral'>     * - If the caller is not `from`, it must have been approved to spend ``from``&#39;s tokens via {setApprovalForAll}.</span>
  94 |     | <span class='neutral'>     * - `from` must have a balance of tokens of type `id` of at least `value` amount.</span>
  95 |     | <span class='neutral'>     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the</span>
  96 |     | <span class='neutral'>     * acceptance magic value.</span>
  97 |     | <span class='neutral'>     */</span>
  98 |     | <span class='neutral'>    function safeTransferFrom(address from, address to, uint256 id, uint256 value, bytes calldata data) external;</span>
  99 |     | <span class='neutral'></span>
 100 |     | <span class='neutral'>    /**</span>
 101 |     | <span class='neutral'>     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {safeTransferFrom}.</span>
 102 |     | <span class='neutral'>     *</span>
 103 |     | <span class='neutral'>     * WARNING: This function can potentially allow a reentrancy attack when transferring tokens</span>
 104 |     | <span class='neutral'>     * to an untrusted contract, when invoking {IERC1155Receiver-onERC1155BatchReceived} on the receiver.</span>
 105 |     | <span class='neutral'>     * Ensure to follow the checks-effects-interactions pattern and consider employing</span>
 106 |     | <span class='neutral'>     * reentrancy guards when interacting with untrusted contracts.</span>
 107 |     | <span class='neutral'>     *</span>
 108 |     | <span class='neutral'>     * Emits either a {TransferSingle} or a {TransferBatch} event, depending on the length of the array arguments.</span>
 109 |     | <span class='neutral'>     *</span>
 110 |     | <span class='neutral'>     * Requirements:</span>
 111 |     | <span class='neutral'>     *</span>
 112 |     | <span class='neutral'>     * - `ids` and `values` must have the same length.</span>
 113 |     | <span class='neutral'>     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the</span>
 114 |     | <span class='neutral'>     * acceptance magic value.</span>
 115 |     | <span class='neutral'>     */</span>
 116 |     | <span class='neutral'>    function safeBatchTransferFrom(</span>
 117 |     | <span class='neutral'>        address from,</span>
 118 |     | <span class='neutral'>        address to,</span>
 119 |     | <span class='neutral'>        uint256[] calldata ids,</span>
 120 |     | <span class='neutral'>        uint256[] calldata values,</span>
 121 |     | <span class='neutral'>        bytes calldata data</span>
 122 |     | <span class='neutral'>    ) external;</span>
 123 |     | <span class='neutral'>}</span>
 124 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/phantom/Documents/azemora/azemora-contracts/lib/openzeppelin-contracts/contracts/token/ERC1155/IERC1155Receiver.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>// OpenZeppelin Contracts (last updated v5.1.0) (token/ERC1155/IERC1155Receiver.sol)</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>pragma solidity &gt;=0.6.2;</span>
  5 |     | <span class='neutral'></span>
  6 |     | <span class='neutral'>import {IERC165} from &quot;../../utils/introspection/IERC165.sol&quot;;</span>
  7 |     | <span class='neutral'></span>
  8 |     | <span class='neutral'>/**</span>
  9 |     | <span class='neutral'> * @dev Interface that must be implemented by smart contracts in order to receive</span>
 10 |     | <span class='neutral'> * ERC-1155 token transfers.</span>
 11 |     | <span class='neutral'> */</span>
 12 |     | <span class='neutral'>interface IERC1155Receiver is IERC165 {</span>
 13 |     | <span class='neutral'>    /**</span>
 14 |     | <span class='neutral'>     * @dev Handles the receipt of a single ERC-1155 token type. This function is</span>
 15 |     | <span class='neutral'>     * called at the end of a `safeTransferFrom` after the balance has been updated.</span>
 16 |     | <span class='neutral'>     *</span>
 17 |     | <span class='neutral'>     * NOTE: To accept the transfer, this must return</span>
 18 |     | <span class='neutral'>     * `bytes4(keccak256(&quot;onERC1155Received(address,address,uint256,uint256,bytes)&quot;))`</span>
 19 |     | <span class='neutral'>     * (i.e. 0xf23a6e61, or its own function selector).</span>
 20 |     | <span class='neutral'>     *</span>
 21 |     | <span class='neutral'>     * @param operator The address which initiated the transfer (i.e. msg.sender)</span>
 22 | *   | <span class='executed'>     * @param from The address which previously owned the token</span>
 23 |     | <span class='neutral'>     * @param id The ID of the token being transferred</span>
 24 | *   | <span class='executed'>     * @param value The amount of tokens being transferred</span>
 25 |     | <span class='unexecuted'>     * @param data Additional data with no specified format</span>
 26 |     | <span class='neutral'>     * @return `bytes4(keccak256(&quot;onERC1155Received(address,address,uint256,uint256,bytes)&quot;))` if transfer is allowed</span>
 27 |     | <span class='neutral'>     */</span>
 28 |     | <span class='neutral'>    function onERC1155Received(</span>
 29 |     | <span class='neutral'>        address operator,</span>
 30 |     | <span class='neutral'>        address from,</span>
 31 |     | <span class='neutral'>        uint256 id,</span>
 32 |     | <span class='neutral'>        uint256 value,</span>
 33 |     | <span class='neutral'>        bytes calldata data</span>
 34 |     | <span class='neutral'>    ) external returns (bytes4);</span>
 35 |     | <span class='neutral'></span>
 36 |     | <span class='neutral'>    /**</span>
 37 |     | <span class='neutral'>     * @dev Handles the receipt of a multiple ERC-1155 token types. This function</span>
 38 |     | <span class='neutral'>     * is called at the end of a `safeBatchTransferFrom` after the balances have</span>
 39 |     | <span class='neutral'>     * been updated.</span>
 40 |     | <span class='neutral'>     *</span>
 41 |     | <span class='neutral'>     * NOTE: To accept the transfer(s), this must return</span>
 42 |     | <span class='neutral'>     * `bytes4(keccak256(&quot;onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)&quot;))`</span>
 43 |     | <span class='neutral'>     * (i.e. 0xbc197c81, or its own function selector).</span>
 44 |     | <span class='neutral'>     *</span>
 45 |     | <span class='neutral'>     * @param operator The address which initiated the batch transfer (i.e. msg.sender)</span>
 46 |     | <span class='neutral'>     * @param from The address which previously owned the token</span>
 47 |     | <span class='neutral'>     * @param ids An array containing ids of each token being transferred (order and length must match values array)</span>
 48 |     | <span class='neutral'>     * @param values An array containing amounts of each token being transferred (order and length must match ids array)</span>
 49 |     | <span class='neutral'>     * @param data Additional data with no specified format</span>
 50 |     | <span class='neutral'>     * @return `bytes4(keccak256(&quot;onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)&quot;))` if transfer is allowed</span>
 51 |     | <span class='neutral'>     */</span>
 52 |     | <span class='neutral'>    function onERC1155BatchReceived(</span>
 53 |     | <span class='neutral'>        address operator,</span>
 54 |     | <span class='neutral'>        address from,</span>
 55 |     | <span class='neutral'>        uint256[] calldata ids,</span>
 56 |     | <span class='neutral'>        uint256[] calldata values,</span>
 57 |     | <span class='neutral'>        bytes calldata data</span>
 58 |     | <span class='neutral'>    ) external returns (bytes4);</span>
 59 |     | <span class='neutral'>}</span>
 60 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/phantom/Documents/azemora/azemora-contracts/lib/openzeppelin-contracts/contracts/token/ERC1155/extensions/IERC1155MetadataURI.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>// OpenZeppelin Contracts (last updated v5.1.0) (token/ERC1155/extensions/IERC1155MetadataURI.sol)</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>pragma solidity &gt;=0.6.2;</span>
  5 |     | <span class='neutral'></span>
  6 |     | <span class='neutral'>import {IERC1155} from &quot;../IERC1155.sol&quot;;</span>
  7 |     | <span class='neutral'></span>
  8 |     | <span class='neutral'>/**</span>
  9 |     | <span class='neutral'> * @dev Interface of the optional ERC1155MetadataExtension interface, as defined</span>
 10 |     | <span class='neutral'> * in the https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[ERC].</span>
 11 |     | <span class='neutral'> */</span>
 12 |     | <span class='neutral'>interface IERC1155MetadataURI is IERC1155 {</span>
 13 |     | <span class='neutral'>    /**</span>
 14 |     | <span class='neutral'>     * @dev Returns the URI for token type `id`.</span>
 15 |     | <span class='neutral'>     *</span>
 16 |     | <span class='neutral'>     * If the `\{id\}` substring is present in the URI, it must be replaced by</span>
 17 |     | <span class='neutral'>     * clients with the actual token type ID.</span>
 18 |     | <span class='neutral'>     */</span>
 19 |     | <span class='neutral'>    function uri(uint256 id) external view returns (string memory);</span>
 20 |     | <span class='neutral'>}</span>
 21 |     | <span class='unexecuted'></span>

</code>
<br />

<b>/home/phantom/Documents/azemora/azemora-contracts/lib/openzeppelin-contracts/contracts/token/ERC1155/utils/ERC1155Utils.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>// OpenZeppelin Contracts (last updated v5.3.0) (token/ERC1155/utils/ERC1155Utils.sol)</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>pragma solidity ^0.8.20;</span>
  5 |     | <span class='neutral'></span>
  6 |     | <span class='neutral'>import {IERC1155Receiver} from &quot;../IERC1155Receiver.sol&quot;;</span>
  7 |     | <span class='neutral'>import {IERC1155Errors} from &quot;../../../interfaces/draft-IERC6093.sol&quot;;</span>
  8 |     | <span class='neutral'></span>
  9 |     | <span class='neutral'>/**</span>
 10 |     | <span class='neutral'> * @dev Library that provide common ERC-1155 utility functions.</span>
 11 |     | <span class='neutral'> *</span>
 12 |     | <span class='neutral'> * See https://eips.ethereum.org/EIPS/eip-1155[ERC-1155].</span>
 13 |     | <span class='neutral'> *</span>
 14 |     | <span class='neutral'> * _Available since v5.1._</span>
 15 |     | <span class='neutral'> */</span>
 16 |     | <span class='neutral'>library ERC1155Utils {</span>
 17 |     | <span class='neutral'>    /**</span>
 18 |     | <span class='neutral'>     * @dev Performs an acceptance check for the provided `operator` by calling {IERC1155Receiver-onERC1155Received}</span>
 19 |     | <span class='neutral'>     * on the `to` address. The `operator` is generally the address that initiated the token transfer (i.e. `msg.sender`).</span>
 20 |     | <span class='neutral'>     *</span>
 21 |     | <span class='neutral'>     * The acceptance call is not executed and treated as a no-op if the target address doesn&#39;t contain code (i.e. an EOA).</span>
 22 |     | <span class='neutral'>     * Otherwise, the recipient must implement {IERC1155Receiver-onERC1155Received} and return the acceptance magic value to accept</span>
 23 |     | <span class='neutral'>     * the transfer.</span>
 24 |     | <span class='neutral'>     */</span>
 25 |     | <span class='neutral'>    function checkOnERC1155Received(</span>
 26 |     | <span class='neutral'>        address operator,</span>
 27 |     | <span class='neutral'>        address from,</span>
 28 |     | <span class='neutral'>        address to,</span>
 29 |     | <span class='neutral'>        uint256 id,</span>
 30 |     | <span class='neutral'>        uint256 value,</span>
 31 |     | <span class='neutral'>        bytes memory data</span>
 32 |     | <span class='neutral'>    ) internal {</span>
 33 |     | <span class='neutral'>        if (to.code.length &gt; 0) {</span>
 34 | *   | <span class='executed'>            try IERC1155Receiver(to).onERC1155Received(operator, from, id, value, data) returns (bytes4 response) {</span>
 35 |     | <span class='neutral'>                if (response != IERC1155Receiver.onERC1155Received.selector) {</span>
 36 |     | <span class='neutral'>                    // Tokens rejected</span>
 37 |     | <span class='neutral'>                    revert IERC1155Errors.ERC1155InvalidReceiver(to);</span>
 38 |     | <span class='neutral'>                }</span>
 39 |     | <span class='neutral'>            } catch (bytes memory reason) {</span>
 40 |     | <span class='neutral'>                if (reason.length == 0) {</span>
 41 |     | <span class='neutral'>                    // non-IERC1155Receiver implementer</span>
 42 |     | <span class='neutral'>                    revert IERC1155Errors.ERC1155InvalidReceiver(to);</span>
 43 |     | <span class='neutral'>                } else {</span>
 44 |     | <span class='neutral'>                    assembly (&quot;memory-safe&quot;) {</span>
 45 |     | <span class='neutral'>                        revert(add(reason, 0x20), mload(reason))</span>
 46 |     | <span class='neutral'>                    }</span>
 47 |     | <span class='neutral'>                }</span>
 48 |     | <span class='neutral'>            }</span>
 49 |     | <span class='neutral'>        }</span>
 50 |     | <span class='neutral'>    }</span>
 51 |     | <span class='neutral'></span>
 52 |     | <span class='neutral'>    /**</span>
 53 | *   | <span class='executed'>     * @dev Performs a batch acceptance check for the provided `operator` by calling {IERC1155Receiver-onERC1155BatchReceived}</span>
 54 |     | <span class='unexecuted'>     * on the `to` address. The `operator` is generally the address that initiated the token transfer (i.e. `msg.sender`).</span>
 55 |     | <span class='neutral'>     *</span>
 56 |     | <span class='neutral'>     * The acceptance call is not executed and treated as a no-op if the target address doesn&#39;t contain code (i.e. an EOA).</span>
 57 |     | <span class='neutral'>     * Otherwise, the recipient must implement {IERC1155Receiver-onERC1155Received} and return the acceptance magic value to accept</span>
 58 |     | <span class='unexecuted'>     * the transfer.</span>
 59 |     | <span class='neutral'>     */</span>
 60 |     | <span class='neutral'>    function checkOnERC1155BatchReceived(</span>
 61 |     | <span class='neutral'>        address operator,</span>
 62 |     | <span class='neutral'>        address from,</span>
 63 | *   | <span class='executed'>        address to,</span>
 64 |     | <span class='neutral'>        uint256[] memory ids,</span>
 65 |     | <span class='neutral'>        uint256[] memory values,</span>
 66 | *   | <span class='executed'>        bytes memory data</span>
 67 |     | <span class='neutral'>    ) internal {</span>
 68 |     | <span class='neutral'>        if (to.code.length &gt; 0) {</span>
 69 | *   | <span class='executed'>            try IERC1155Receiver(to).onERC1155BatchReceived(operator, from, ids, values, data) returns (</span>
 70 |     | <span class='neutral'>                bytes4 response</span>
 71 |     | <span class='unexecuted'>            ) {</span>
 72 |     | <span class='unexecuted'>                if (response != IERC1155Receiver.onERC1155BatchReceived.selector) {</span>
 73 |     | <span class='neutral'>                    // Tokens rejected</span>
 74 |     | <span class='neutral'>                    revert IERC1155Errors.ERC1155InvalidReceiver(to);</span>
 75 |     | <span class='neutral'>                }</span>
 76 |     | <span class='unexecuted'>            } catch (bytes memory reason) {</span>
 77 |     | <span class='neutral'>                if (reason.length == 0) {</span>
 78 |     | <span class='neutral'>                    // non-IERC1155Receiver implementer</span>
 79 |     | <span class='unexecuted'>                    revert IERC1155Errors.ERC1155InvalidReceiver(to);</span>
 80 |     | <span class='neutral'>                } else {</span>
 81 |     | <span class='neutral'>                    assembly (&quot;memory-safe&quot;) {</span>
 82 |     | <span class='unexecuted'>                        revert(add(reason, 0x20), mload(reason))</span>
 83 |     | <span class='neutral'>                    }</span>
 84 |     | <span class='neutral'>                }</span>
 85 |     | <span class='unexecuted'>            }</span>
 86 |     | <span class='neutral'>        }</span>
 87 |     | <span class='neutral'>    }</span>
 88 |     | <span class='neutral'>}</span>
 89 |     | <span class='unexecuted'></span>

</code>
<br />

<b>/home/phantom/Documents/azemora/azemora-contracts/lib/openzeppelin-contracts/contracts/token/ERC20/ERC20.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'>// OpenZeppelin Contracts (last updated v5.3.0) (token/ERC20/ERC20.sol)</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>pragma solidity ^0.8.20;</span>
   5 |     | <span class='neutral'></span>
   6 |     | <span class='neutral'>import {IERC20} from &quot;./IERC20.sol&quot;;</span>
   7 |     | <span class='neutral'>import {IERC20Metadata} from &quot;./extensions/IERC20Metadata.sol&quot;;</span>
   8 |     | <span class='neutral'>import {Context} from &quot;../../utils/Context.sol&quot;;</span>
   9 |     | <span class='neutral'>import {IERC20Errors} from &quot;../../interfaces/draft-IERC6093.sol&quot;;</span>
  10 |     | <span class='neutral'></span>
  11 |     | <span class='neutral'>/**</span>
  12 |     | <span class='neutral'> * @dev Implementation of the {IERC20} interface.</span>
  13 |     | <span class='neutral'> *</span>
  14 |     | <span class='neutral'> * This implementation is agnostic to the way tokens are created. This means</span>
  15 |     | <span class='neutral'> * that a supply mechanism has to be added in a derived contract using {_mint}.</span>
  16 |     | <span class='neutral'> *</span>
  17 |     | <span class='neutral'> * TIP: For a detailed writeup see our guide</span>
  18 |     | <span class='neutral'> * https://forum.openzeppelin.com/t/how-to-implement-erc20-supply-mechanisms/226[How</span>
  19 |     | <span class='neutral'> * to implement supply mechanisms].</span>
  20 |     | <span class='neutral'> *</span>
  21 |     | <span class='neutral'> * The default value of {decimals} is 18. To change this, you should override</span>
  22 |     | <span class='neutral'> * this function so it returns a different value.</span>
  23 |     | <span class='neutral'> *</span>
  24 |     | <span class='neutral'> * We have followed general OpenZeppelin Contracts guidelines: functions revert</span>
  25 |     | <span class='neutral'> * instead returning `false` on failure. This behavior is nonetheless</span>
  26 |     | <span class='neutral'> * conventional and does not conflict with the expectations of ERC-20</span>
  27 |     | <span class='neutral'> * applications.</span>
  28 |     | <span class='neutral'> */</span>
  29 |     | <span class='neutral'>abstract contract ERC20 is Context, IERC20, IERC20Metadata, IERC20Errors {</span>
  30 |     | <span class='neutral'>    mapping(address account =&gt; uint256) private _balances;</span>
  31 |     | <span class='neutral'></span>
  32 |     | <span class='neutral'>    mapping(address account =&gt; mapping(address spender =&gt; uint256)) private _allowances;</span>
  33 |     | <span class='neutral'></span>
  34 |     | <span class='neutral'>    uint256 private _totalSupply;</span>
  35 |     | <span class='neutral'></span>
  36 |     | <span class='neutral'>    string private _name;</span>
  37 |     | <span class='neutral'>    string private _symbol;</span>
  38 |     | <span class='neutral'></span>
  39 |     | <span class='neutral'>    /**</span>
  40 |     | <span class='neutral'>     * @dev Sets the values for {name} and {symbol}.</span>
  41 |     | <span class='neutral'>     *</span>
  42 |     | <span class='neutral'>     * Both values are immutable: they can only be set once during construction.</span>
  43 |     | <span class='neutral'>     */</span>
  44 |     | <span class='neutral'>    constructor(string memory name_, string memory symbol_) {</span>
  45 |     | <span class='neutral'>        _name = name_;</span>
  46 |     | <span class='neutral'>        _symbol = symbol_;</span>
  47 |     | <span class='neutral'>    }</span>
  48 |     | <span class='neutral'></span>
  49 |     | <span class='neutral'>    /**</span>
  50 |     | <span class='neutral'>     * @dev Returns the name of the token.</span>
  51 |     | <span class='neutral'>     */</span>
  52 |     | <span class='neutral'>    function name() public view virtual returns (string memory) {</span>
  53 |     | <span class='neutral'>        return _name;</span>
  54 |     | <span class='neutral'>    }</span>
  55 |     | <span class='neutral'></span>
  56 |     | <span class='neutral'>    /**</span>
  57 |     | <span class='neutral'>     * @dev Returns the symbol of the token, usually a shorter version of the</span>
  58 | *   | <span class='executed'>     * name.</span>
  59 |     | <span class='neutral'>     */</span>
  60 | *   | <span class='executed'>    function symbol() public view virtual returns (string memory) {</span>
  61 |     | <span class='neutral'>        return _symbol;</span>
  62 |     | <span class='neutral'>    }</span>
  63 |     | <span class='neutral'></span>
  64 |     | <span class='neutral'>    /**</span>
  65 |     | <span class='neutral'>     * @dev Returns the number of decimals used to get its user representation.</span>
  66 |     | <span class='neutral'>     * For example, if `decimals` equals `2`, a balance of `505` tokens should</span>
  67 |     | <span class='neutral'>     * be displayed to a user as `5.05` (`505 / 10 ** 2`).</span>
  68 |     | <span class='neutral'>     *</span>
  69 |     | <span class='neutral'>     * Tokens usually opt for a value of 18, imitating the relationship between</span>
  70 |     | <span class='neutral'>     * Ether and Wei. This is the default value returned by this function, unless</span>
  71 |     | <span class='neutral'>     * it&#39;s overridden.</span>
  72 |     | <span class='neutral'>     *</span>
  73 | *   | <span class='executed'>     * NOTE: This information is only used for _display_ purposes: it in</span>
  74 |     | <span class='neutral'>     * no way affects any of the arithmetic of the contract, including</span>
  75 |     | <span class='neutral'>     * {IERC20-balanceOf} and {IERC20-transfer}.</span>
  76 |     | <span class='neutral'>     */</span>
  77 | *   | <span class='executed'>    function decimals() public view virtual returns (uint8) {</span>
  78 | *   | <span class='executed'>        return 18;</span>
  79 |     | <span class='neutral'>    }</span>
  80 |     | <span class='neutral'></span>
  81 |     | <span class='neutral'>    /// @inheritdoc IERC20</span>
  82 | *   | <span class='executed'>    function totalSupply() public view virtual returns (uint256) {</span>
  83 |     | <span class='neutral'>        return _totalSupply;</span>
  84 |     | <span class='neutral'>    }</span>
  85 |     | <span class='neutral'></span>
  86 |     | <span class='neutral'>    /// @inheritdoc IERC20</span>
  87 |     | <span class='neutral'>    function balanceOf(address account) public view virtual returns (uint256) {</span>
  88 |     | <span class='neutral'>        return _balances[account];</span>
  89 |     | <span class='neutral'>    }</span>
  90 |     | <span class='neutral'></span>
  91 |     | <span class='neutral'>    /**</span>
  92 |     | <span class='neutral'>     * @dev See {IERC20-transfer}.</span>
  93 |     | <span class='neutral'>     *</span>
  94 |     | <span class='neutral'>     * Requirements:</span>
  95 |     | <span class='neutral'>     *</span>
  96 |     | <span class='neutral'>     * - `to` cannot be the zero address.</span>
  97 |     | <span class='neutral'>     * - the caller must have a balance of at least `value`.</span>
  98 |     | <span class='neutral'>     */</span>
  99 |     | <span class='neutral'>    function transfer(address to, uint256 value) public virtual returns (bool) {</span>
 100 |     | <span class='neutral'>        address owner = _msgSender();</span>
 101 | *   | <span class='executed'>        _transfer(owner, to, value);</span>
 102 |     | <span class='neutral'>        return true;</span>
 103 |     | <span class='neutral'>    }</span>
 104 |     | <span class='neutral'></span>
 105 | *   | <span class='executed'>    /// @inheritdoc IERC20</span>
 106 | *   | <span class='executed'>    function allowance(address owner, address spender) public view virtual returns (uint256) {</span>
 107 |     | <span class='neutral'>        return _allowances[owner][spender];</span>
 108 |     | <span class='neutral'>    }</span>
 109 |     | <span class='neutral'></span>
 110 |     | <span class='neutral'>    /**</span>
 111 |     | <span class='neutral'>     * @dev See {IERC20-approve}.</span>
 112 |     | <span class='neutral'>     *</span>
 113 | *   | <span class='executed'>     * NOTE: If `value` is the maximum `uint256`, the allowance is not updated on</span>
 114 |     | <span class='neutral'>     * `transferFrom`. This is semantically equivalent to an infinite approval.</span>
 115 |     | <span class='neutral'>     *</span>
 116 | *   | <span class='executed'>     * Requirements:</span>
 117 |     | <span class='neutral'>     *</span>
 118 | *   | <span class='executed'>     * - `spender` cannot be the zero address.</span>
 119 |     | <span class='neutral'>     */</span>
 120 |     | <span class='neutral'>    function approve(address spender, uint256 value) public virtual returns (bool) {</span>
 121 |     | <span class='neutral'>        address owner = _msgSender();</span>
 122 |     | <span class='neutral'>        _approve(owner, spender, value);</span>
 123 |     | <span class='neutral'>        return true;</span>
 124 |     | <span class='neutral'>    }</span>
 125 |     | <span class='neutral'></span>
 126 |     | <span class='neutral'>    /**</span>
 127 | *   | <span class='executed'>     * @dev See {IERC20-transferFrom}.</span>
 128 |     | <span class='neutral'>     *</span>
 129 |     | <span class='neutral'>     * Skips emitting an {Approval} event indicating an allowance update. This is not</span>
 130 |     | <span class='neutral'>     * required by the ERC. See {xref-ERC20-_approve-address-address-uint256-bool-}[_approve].</span>
 131 |     | <span class='neutral'>     *</span>
 132 |     | <span class='neutral'>     * NOTE: Does not update the allowance if the current allowance</span>
 133 |     | <span class='neutral'>     * is the maximum `uint256`.</span>
 134 |     | <span class='neutral'>     *</span>
 135 |     | <span class='neutral'>     * Requirements:</span>
 136 |     | <span class='neutral'>     *</span>
 137 |     | <span class='neutral'>     * - `from` and `to` cannot be the zero address.</span>
 138 |     | <span class='neutral'>     * - `from` must have a balance of at least `value`.</span>
 139 |     | <span class='neutral'>     * - the caller must have allowance for ``from``&#39;s tokens of at least</span>
 140 |     | <span class='neutral'>     * `value`.</span>
 141 |     | <span class='neutral'>     */</span>
 142 |     | <span class='neutral'>    function transferFrom(address from, address to, uint256 value) public virtual returns (bool) {</span>
 143 |     | <span class='neutral'>        address spender = _msgSender();</span>
 144 |     | <span class='neutral'>        _spendAllowance(from, spender, value);</span>
 145 |     | <span class='neutral'>        _transfer(from, to, value);</span>
 146 |     | <span class='neutral'>        return true;</span>
 147 |     | <span class='neutral'>    }</span>
 148 |     | <span class='neutral'></span>
 149 |     | <span class='neutral'>    /**</span>
 150 |     | <span class='neutral'>     * @dev Moves a `value` amount of tokens from `from` to `to`.</span>
 151 |     | <span class='neutral'>     *</span>
 152 |     | <span class='neutral'>     * This internal function is equivalent to {transfer}, and can be used to</span>
 153 |     | <span class='neutral'>     * e.g. implement automatic token fees, slashing mechanisms, etc.</span>
 154 |     | <span class='neutral'>     *</span>
 155 |     | <span class='neutral'>     * Emits a {Transfer} event.</span>
 156 |     | <span class='neutral'>     *</span>
 157 |     | <span class='neutral'>     * NOTE: This function is not virtual, {_update} should be overridden instead.</span>
 158 |     | <span class='neutral'>     */</span>
 159 |     | <span class='neutral'>    function _transfer(address from, address to, uint256 value) internal {</span>
 160 |     | <span class='neutral'>        if (from == address(0)) {</span>
 161 |     | <span class='neutral'>            revert ERC20InvalidSender(address(0));</span>
 162 |     | <span class='neutral'>        }</span>
 163 |     | <span class='neutral'>        if (to == address(0)) {</span>
 164 |     | <span class='neutral'>            revert ERC20InvalidReceiver(address(0));</span>
 165 |     | <span class='neutral'>        }</span>
 166 |     | <span class='neutral'>        _update(from, to, value);</span>
 167 |     | <span class='neutral'>    }</span>
 168 |     | <span class='neutral'></span>
 169 |     | <span class='neutral'>    /**</span>
 170 |     | <span class='neutral'>     * @dev Transfers a `value` amount of tokens from `from` to `to`, or alternatively mints (or burns) if `from`</span>
 171 |     | <span class='neutral'>     * (or `to`) is the zero address. All customizations to transfers, mints, and burns should be done by overriding</span>
 172 |     | <span class='neutral'>     * this function.</span>
 173 |     | <span class='neutral'>     *</span>
 174 |     | <span class='neutral'>     * Emits a {Transfer} event.</span>
 175 |     | <span class='neutral'>     */</span>
 176 |     | <span class='neutral'>    function _update(address from, address to, uint256 value) internal virtual {</span>
 177 |     | <span class='neutral'>        if (from == address(0)) {</span>
 178 |     | <span class='neutral'>            // Overflow check required: The rest of the code assumes that totalSupply never overflows</span>
 179 |     | <span class='neutral'>            _totalSupply += value;</span>
 180 |     | <span class='neutral'>        } else {</span>
 181 |     | <span class='neutral'>            uint256 fromBalance = _balances[from];</span>
 182 |     | <span class='neutral'>            if (fromBalance &lt; value) {</span>
 183 |     | <span class='neutral'>                revert ERC20InsufficientBalance(from, fromBalance, value);</span>
 184 |     | <span class='neutral'>            }</span>
 185 |     | <span class='neutral'>            unchecked {</span>
 186 |     | <span class='neutral'>                // Overflow not possible: value &lt;= fromBalance &lt;= totalSupply.</span>
 187 |     | <span class='neutral'>                _balances[from] = fromBalance - value;</span>
 188 |     | <span class='neutral'>            }</span>
 189 |     | <span class='neutral'>        }</span>
 190 |     | <span class='neutral'></span>
 191 |     | <span class='neutral'>        if (to == address(0)) {</span>
 192 |     | <span class='neutral'>            unchecked {</span>
 193 |     | <span class='neutral'>                // Overflow not possible: value &lt;= totalSupply or value &lt;= fromBalance &lt;= totalSupply.</span>
 194 |     | <span class='neutral'>                _totalSupply -= value;</span>
 195 |     | <span class='neutral'>            }</span>
 196 |     | <span class='neutral'>        } else {</span>
 197 |     | <span class='neutral'>            unchecked {</span>
 198 |     | <span class='neutral'>                // Overflow not possible: balance + value is at most totalSupply, which we know fits into a uint256.</span>
 199 |     | <span class='neutral'>                _balances[to] += value;</span>
 200 |     | <span class='neutral'>            }</span>
 201 |     | <span class='neutral'>        }</span>
 202 |     | <span class='neutral'></span>
 203 |     | <span class='neutral'>        emit Transfer(from, to, value);</span>
 204 |     | <span class='neutral'>    }</span>
 205 |     | <span class='neutral'></span>
 206 |     | <span class='neutral'>    /**</span>
 207 |     | <span class='neutral'>     * @dev Creates a `value` amount of tokens and assigns them to `account`, by transferring it from address(0).</span>
 208 |     | <span class='neutral'>     * Relies on the `_update` mechanism</span>
 209 |     | <span class='neutral'>     *</span>
 210 |     | <span class='neutral'>     * Emits a {Transfer} event with `from` set to the zero address.</span>
 211 |     | <span class='neutral'>     *</span>
 212 |     | <span class='neutral'>     * NOTE: This function is not virtual, {_update} should be overridden instead.</span>
 213 |     | <span class='neutral'>     */</span>
 214 |     | <span class='neutral'>    function _mint(address account, uint256 value) internal {</span>
 215 |     | <span class='neutral'>        if (account == address(0)) {</span>
 216 |     | <span class='neutral'>            revert ERC20InvalidReceiver(address(0));</span>
 217 |     | <span class='neutral'>        }</span>
 218 |     | <span class='neutral'>        _update(address(0), account, value);</span>
 219 |     | <span class='neutral'>    }</span>
 220 |     | <span class='neutral'></span>
 221 |     | <span class='neutral'>    /**</span>
 222 |     | <span class='neutral'>     * @dev Destroys a `value` amount of tokens from `account`, lowering the total supply.</span>
 223 |     | <span class='neutral'>     * Relies on the `_update` mechanism.</span>
 224 |     | <span class='neutral'>     *</span>
 225 |     | <span class='neutral'>     * Emits a {Transfer} event with `to` set to the zero address.</span>
 226 |     | <span class='neutral'>     *</span>
 227 |     | <span class='neutral'>     * NOTE: This function is not virtual, {_update} should be overridden instead</span>
 228 |     | <span class='neutral'>     */</span>
 229 |     | <span class='neutral'>    function _burn(address account, uint256 value) internal {</span>
 230 |     | <span class='neutral'>        if (account == address(0)) {</span>
 231 |     | <span class='neutral'>            revert ERC20InvalidSender(address(0));</span>
 232 |     | <span class='neutral'>        }</span>
 233 |     | <span class='neutral'>        _update(account, address(0), value);</span>
 234 |     | <span class='neutral'>    }</span>
 235 |     | <span class='neutral'></span>
 236 |     | <span class='neutral'>    /**</span>
 237 |     | <span class='neutral'>     * @dev Sets `value` as the allowance of `spender` over the `owner`&#39;s tokens.</span>
 238 |     | <span class='neutral'>     *</span>
 239 |     | <span class='neutral'>     * This internal function is equivalent to `approve`, and can be used to</span>
 240 |     | <span class='neutral'>     * e.g. set automatic allowances for certain subsystems, etc.</span>
 241 |     | <span class='neutral'>     *</span>
 242 |     | <span class='neutral'>     * Emits an {Approval} event.</span>
 243 |     | <span class='neutral'>     *</span>
 244 |     | <span class='neutral'>     * Requirements:</span>
 245 |     | <span class='neutral'>     *</span>
 246 |     | <span class='neutral'>     * - `owner` cannot be the zero address.</span>
 247 |     | <span class='neutral'>     * - `spender` cannot be the zero address.</span>
 248 |     | <span class='neutral'>     *</span>
 249 |     | <span class='neutral'>     * Overrides to this logic should be done to the variant with an additional `bool emitEvent` argument.</span>
 250 |     | <span class='neutral'>     */</span>
 251 |     | <span class='neutral'>    function _approve(address owner, address spender, uint256 value) internal {</span>
 252 |     | <span class='neutral'>        _approve(owner, spender, value, true);</span>
 253 |     | <span class='neutral'>    }</span>
 254 |     | <span class='neutral'></span>
 255 |     | <span class='neutral'>    /**</span>
 256 |     | <span class='neutral'>     * @dev Variant of {_approve} with an optional flag to enable or disable the {Approval} event.</span>
 257 |     | <span class='neutral'>     *</span>
 258 |     | <span class='neutral'>     * By default (when calling {_approve}) the flag is set to true. On the other hand, approval changes made by</span>
 259 |     | <span class='neutral'>     * `_spendAllowance` during the `transferFrom` operation set the flag to false. This saves gas by not emitting any</span>
 260 |     | <span class='neutral'>     * `Approval` event during `transferFrom` operations.</span>
 261 |     | <span class='neutral'>     *</span>
 262 |     | <span class='neutral'>     * Anyone who wishes to continue emitting `Approval` events on the`transferFrom` operation can force the flag to</span>
 263 |     | <span class='neutral'>     * true using the following override:</span>
 264 |     | <span class='neutral'>     *</span>
 265 |     | <span class='neutral'>     * ```solidity</span>
 266 |     | <span class='neutral'>     * function _approve(address owner, address spender, uint256 value, bool) internal virtual override {</span>
 267 |     | <span class='neutral'>     *     super._approve(owner, spender, value, true);</span>
 268 |     | <span class='neutral'>     * }</span>
 269 |     | <span class='neutral'>     * ```</span>
 270 |     | <span class='neutral'>     *</span>
 271 |     | <span class='neutral'>     * Requirements are the same as {_approve}.</span>
 272 |     | <span class='neutral'>     */</span>
 273 |     | <span class='neutral'>    function _approve(address owner, address spender, uint256 value, bool emitEvent) internal virtual {</span>
 274 |     | <span class='neutral'>        if (owner == address(0)) {</span>
 275 |     | <span class='neutral'>            revert ERC20InvalidApprover(address(0));</span>
 276 |     | <span class='neutral'>        }</span>
 277 |     | <span class='neutral'>        if (spender == address(0)) {</span>
 278 |     | <span class='neutral'>            revert ERC20InvalidSpender(address(0));</span>
 279 |     | <span class='neutral'>        }</span>
 280 |     | <span class='neutral'>        _allowances[owner][spender] = value;</span>
 281 |     | <span class='neutral'>        if (emitEvent) {</span>
 282 |     | <span class='neutral'>            emit Approval(owner, spender, value);</span>
 283 |     | <span class='neutral'>        }</span>
 284 |     | <span class='neutral'>    }</span>
 285 |     | <span class='neutral'></span>
 286 |     | <span class='neutral'>    /**</span>
 287 |     | <span class='neutral'>     * @dev Updates `owner`&#39;s allowance for `spender` based on spent `value`.</span>
 288 |     | <span class='neutral'>     *</span>
 289 |     | <span class='neutral'>     * Does not update the allowance value in case of infinite allowance.</span>
 290 |     | <span class='neutral'>     * Revert if not enough allowance is available.</span>
 291 |     | <span class='neutral'>     *</span>
 292 |     | <span class='neutral'>     * Does not emit an {Approval} event.</span>
 293 |     | <span class='neutral'>     */</span>
 294 |     | <span class='neutral'>    function _spendAllowance(address owner, address spender, uint256 value) internal virtual {</span>
 295 |     | <span class='neutral'>        uint256 currentAllowance = allowance(owner, spender);</span>
 296 |     | <span class='neutral'>        if (currentAllowance &lt; type(uint256).max) {</span>
 297 |     | <span class='neutral'>            if (currentAllowance &lt; value) {</span>
 298 |     | <span class='neutral'>                revert ERC20InsufficientAllowance(spender, currentAllowance, value);</span>
 299 |     | <span class='neutral'>            }</span>
 300 |     | <span class='neutral'>            unchecked {</span>
 301 |     | <span class='neutral'>                _approve(owner, spender, currentAllowance - value, false);</span>
 302 |     | <span class='neutral'>            }</span>
 303 |     | <span class='neutral'>        }</span>
 304 |     | <span class='neutral'>    }</span>
 305 |     | <span class='neutral'>}</span>
 306 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/phantom/Documents/azemora/azemora-contracts/lib/openzeppelin-contracts/contracts/token/ERC20/IERC20.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>// OpenZeppelin Contracts (last updated v5.1.0) (token/ERC20/IERC20.sol)</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>pragma solidity &gt;=0.4.16;</span>
  5 |     | <span class='neutral'></span>
  6 |     | <span class='neutral'>/**</span>
  7 |     | <span class='neutral'> * @dev Interface of the ERC-20 standard as defined in the ERC.</span>
  8 |     | <span class='neutral'> */</span>
  9 |     | <span class='neutral'>interface IERC20 {</span>
 10 |     | <span class='neutral'>    /**</span>
 11 |     | <span class='neutral'>     * @dev Emitted when `value` tokens are moved from one account (`from`) to</span>
 12 |     | <span class='neutral'>     * another (`to`).</span>
 13 |     | <span class='neutral'>     *</span>
 14 |     | <span class='neutral'>     * Note that `value` may be zero.</span>
 15 |     | <span class='neutral'>     */</span>
 16 |     | <span class='neutral'>    event Transfer(address indexed from, address indexed to, uint256 value);</span>
 17 |     | <span class='neutral'></span>
 18 |     | <span class='neutral'>    /**</span>
 19 |     | <span class='neutral'>     * @dev Emitted when the allowance of a `spender` for an `owner` is set by</span>
 20 |     | <span class='neutral'>     * a call to {approve}. `value` is the new allowance.</span>
 21 |     | <span class='neutral'>     */</span>
 22 |     | <span class='neutral'>    event Approval(address indexed owner, address indexed spender, uint256 value);</span>
 23 |     | <span class='neutral'></span>
 24 |     | <span class='neutral'>    /**</span>
 25 |     | <span class='neutral'>     * @dev Returns the value of tokens in existence.</span>
 26 |     | <span class='neutral'>     */</span>
 27 |     | <span class='neutral'>    function totalSupply() external view returns (uint256);</span>
 28 |     | <span class='neutral'></span>
 29 |     | <span class='neutral'>    /**</span>
 30 |     | <span class='neutral'>     * @dev Returns the value of tokens owned by `account`.</span>
 31 |     | <span class='neutral'>     */</span>
 32 |     | <span class='neutral'>    function balanceOf(address account) external view returns (uint256);</span>
 33 |     | <span class='neutral'></span>
 34 |     | <span class='neutral'>    /**</span>
 35 |     | <span class='neutral'>     * @dev Moves a `value` amount of tokens from the caller&#39;s account to `to`.</span>
 36 |     | <span class='neutral'>     *</span>
 37 |     | <span class='neutral'>     * Returns a boolean value indicating whether the operation succeeded.</span>
 38 |     | <span class='neutral'>     *</span>
 39 |     | <span class='neutral'>     * Emits a {Transfer} event.</span>
 40 |     | <span class='neutral'>     */</span>
 41 |     | <span class='neutral'>    function transfer(address to, uint256 value) external returns (bool);</span>
 42 |     | <span class='neutral'></span>
 43 |     | <span class='neutral'>    /**</span>
 44 |     | <span class='neutral'>     * @dev Returns the remaining number of tokens that `spender` will be</span>
 45 |     | <span class='neutral'>     * allowed to spend on behalf of `owner` through {transferFrom}. This is</span>
 46 |     | <span class='neutral'>     * zero by default.</span>
 47 |     | <span class='neutral'>     *</span>
 48 |     | <span class='neutral'>     * This value changes when {approve} or {transferFrom} are called.</span>
 49 |     | <span class='neutral'>     */</span>
 50 |     | <span class='neutral'>    function allowance(address owner, address spender) external view returns (uint256);</span>
 51 |     | <span class='neutral'></span>
 52 |     | <span class='neutral'>    /**</span>
 53 |     | <span class='neutral'>     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the</span>
 54 |     | <span class='neutral'>     * caller&#39;s tokens.</span>
 55 |     | <span class='neutral'>     *</span>
 56 |     | <span class='neutral'>     * Returns a boolean value indicating whether the operation succeeded.</span>
 57 |     | <span class='neutral'>     *</span>
 58 |     | <span class='neutral'>     * IMPORTANT: Beware that changing an allowance with this method brings the risk</span>
 59 |     | <span class='unexecuted'>     * that someone may use both the old and the new allowance by unfortunate</span>
 60 |     | <span class='neutral'>     * transaction ordering. One possible solution to mitigate this race</span>
 61 |     | <span class='neutral'>     * condition is to first reduce the spender&#39;s allowance to 0 and set the</span>
 62 |     | <span class='neutral'>     * desired value afterwards:</span>
 63 |     | <span class='neutral'>     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729</span>
 64 |     | <span class='neutral'>     *</span>
 65 |     | <span class='neutral'>     * Emits an {Approval} event.</span>
 66 |     | <span class='neutral'>     */</span>
 67 |     | <span class='neutral'>    function approve(address spender, uint256 value) external returns (bool);</span>
 68 |     | <span class='neutral'></span>
 69 |     | <span class='neutral'>    /**</span>
 70 |     | <span class='neutral'>     * @dev Moves a `value` amount of tokens from `from` to `to` using the</span>
 71 |     | <span class='neutral'>     * allowance mechanism. `value` is then deducted from the caller&#39;s</span>
 72 |     | <span class='neutral'>     * allowance.</span>
 73 |     | <span class='neutral'>     *</span>
 74 |     | <span class='unexecuted'>     * Returns a boolean value indicating whether the operation succeeded.</span>
 75 |     | <span class='neutral'>     *</span>
 76 |     | <span class='neutral'>     * Emits a {Transfer} event.</span>
 77 |     | <span class='neutral'>     */</span>
 78 |     | <span class='unexecuted'>    function transferFrom(address from, address to, uint256 value) external returns (bool);</span>
 79 |     | <span class='neutral'>}</span>
 80 |     | <span class='unexecuted'></span>

</code>
<br />

<b>/home/phantom/Documents/azemora/azemora-contracts/lib/openzeppelin-contracts/contracts/token/ERC20/extensions/IERC20Metadata.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>// OpenZeppelin Contracts (last updated v5.1.0) (token/ERC20/extensions/IERC20Metadata.sol)</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>pragma solidity &gt;=0.6.2;</span>
  5 |     | <span class='neutral'></span>
  6 |     | <span class='neutral'>import {IERC20} from &quot;../IERC20.sol&quot;;</span>
  7 |     | <span class='neutral'></span>
  8 |     | <span class='neutral'>/**</span>
  9 |     | <span class='neutral'> * @dev Interface for the optional metadata functions from the ERC-20 standard.</span>
 10 |     | <span class='neutral'> */</span>
 11 |     | <span class='neutral'>interface IERC20Metadata is IERC20 {</span>
 12 |     | <span class='neutral'>    /**</span>
 13 |     | <span class='neutral'>     * @dev Returns the name of the token.</span>
 14 |     | <span class='neutral'>     */</span>
 15 |     | <span class='neutral'>    function name() external view returns (string memory);</span>
 16 |     | <span class='neutral'></span>
 17 |     | <span class='neutral'>    /**</span>
 18 |     | <span class='neutral'>     * @dev Returns the symbol of the token.</span>
 19 |     | <span class='neutral'>     */</span>
 20 |     | <span class='neutral'>    function symbol() external view returns (string memory);</span>
 21 |     | <span class='neutral'></span>
 22 |     | <span class='neutral'>    /**</span>
 23 |     | <span class='neutral'>     * @dev Returns the decimals places of the token.</span>
 24 |     | <span class='neutral'>     */</span>
 25 |     | <span class='neutral'>    function decimals() external view returns (uint8);</span>
 26 |     | <span class='neutral'>}</span>
 27 |     | <span class='unexecuted'></span>

</code>
<br />

<b>/home/phantom/Documents/azemora/azemora-contracts/lib/openzeppelin-contracts/contracts/token/ERC20/extensions/IERC20Permit.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>// OpenZeppelin Contracts (last updated v5.1.0) (token/ERC20/extensions/IERC20Permit.sol)</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>pragma solidity &gt;=0.4.16;</span>
  5 |     | <span class='neutral'></span>
  6 |     | <span class='neutral'>/**</span>
  7 |     | <span class='neutral'> * @dev Interface of the ERC-20 Permit extension allowing approvals to be made via signatures, as defined in</span>
  8 |     | <span class='neutral'> * https://eips.ethereum.org/EIPS/eip-2612[ERC-2612].</span>
  9 |     | <span class='neutral'> *</span>
 10 |     | <span class='neutral'> * Adds the {permit} method, which can be used to change an account&#39;s ERC-20 allowance (see {IERC20-allowance}) by</span>
 11 |     | <span class='neutral'> * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn&#39;t</span>
 12 |     | <span class='neutral'> * need to send a transaction, and thus is not required to hold Ether at all.</span>
 13 |     | <span class='neutral'> *</span>
 14 |     | <span class='neutral'> * ==== Security Considerations</span>
 15 |     | <span class='neutral'> *</span>
 16 |     | <span class='neutral'> * There are two important considerations concerning the use of `permit`. The first is that a valid permit signature</span>
 17 |     | <span class='neutral'> * expresses an allowance, and it should not be assumed to convey additional meaning. In particular, it should not be</span>
 18 |     | <span class='neutral'> * considered as an intention to spend the allowance in any specific way. The second is that because permits have</span>
 19 |     | <span class='neutral'> * built-in replay protection and can be submitted by anyone, they can be frontrun. A protocol that uses permits should</span>
 20 |     | <span class='neutral'> * take this into consideration and allow a `permit` call to fail. Combining these two aspects, a pattern that may be</span>
 21 |     | <span class='neutral'> * generally recommended is:</span>
 22 |     | <span class='neutral'> *</span>
 23 |     | <span class='neutral'> * ```solidity</span>
 24 |     | <span class='neutral'> * function doThingWithPermit(..., uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s) public {</span>
 25 |     | <span class='neutral'> *     try token.permit(msg.sender, address(this), value, deadline, v, r, s) {} catch {}</span>
 26 |     | <span class='neutral'> *     doThing(..., value);</span>
 27 |     | <span class='neutral'> * }</span>
 28 |     | <span class='neutral'> *</span>
 29 |     | <span class='neutral'> * function doThing(..., uint256 value) public {</span>
 30 |     | <span class='neutral'> *     token.safeTransferFrom(msg.sender, address(this), value);</span>
 31 |     | <span class='neutral'> *     ...</span>
 32 |     | <span class='neutral'> * }</span>
 33 |     | <span class='neutral'> * ```</span>
 34 |     | <span class='neutral'> *</span>
 35 |     | <span class='neutral'> * Observe that: 1) `msg.sender` is used as the owner, leaving no ambiguity as to the signer intent, and 2) the use of</span>
 36 |     | <span class='neutral'> * `try/catch` allows the permit to fail and makes the code tolerant to frontrunning. (See also</span>
 37 |     | <span class='neutral'> * {SafeERC20-safeTransferFrom}).</span>
 38 |     | <span class='neutral'> *</span>
 39 |     | <span class='neutral'> * Additionally, note that smart contract wallets (such as Argent or Safe) are not able to produce permit signatures, so</span>
 40 |     | <span class='neutral'> * contracts should have entry points that don&#39;t rely on permit.</span>
 41 |     | <span class='neutral'> */</span>
 42 |     | <span class='neutral'>interface IERC20Permit {</span>
 43 |     | <span class='neutral'>    /**</span>
 44 |     | <span class='neutral'>     * @dev Sets `value` as the allowance of `spender` over ``owner``&#39;s tokens,</span>
 45 |     | <span class='neutral'>     * given ``owner``&#39;s signed approval.</span>
 46 |     | <span class='neutral'>     *</span>
 47 |     | <span class='neutral'>     * IMPORTANT: The same issues {IERC20-approve} has related to transaction</span>
 48 |     | <span class='neutral'>     * ordering also apply here.</span>
 49 |     | <span class='neutral'>     *</span>
 50 |     | <span class='neutral'>     * Emits an {Approval} event.</span>
 51 |     | <span class='neutral'>     *</span>
 52 |     | <span class='neutral'>     * Requirements:</span>
 53 |     | <span class='neutral'>     *</span>
 54 |     | <span class='neutral'>     * - `spender` cannot be the zero address.</span>
 55 |     | <span class='neutral'>     * - `deadline` must be a timestamp in the future.</span>
 56 |     | <span class='neutral'>     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`</span>
 57 |     | <span class='neutral'>     * over the EIP712-formatted function arguments.</span>
 58 |     | <span class='neutral'>     * - the signature must use ``owner``&#39;s current nonce (see {nonces}).</span>
 59 |     | <span class='neutral'>     *</span>
 60 |     | <span class='neutral'>     * For more information on the signature format, see the</span>
 61 |     | <span class='neutral'>     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP</span>
 62 |     | <span class='neutral'>     * section].</span>
 63 |     | <span class='neutral'>     *</span>
 64 |     | <span class='neutral'>     * CAUTION: See Security Considerations above.</span>
 65 |     | <span class='neutral'>     */</span>
 66 |     | <span class='neutral'>    function permit(</span>
 67 |     | <span class='neutral'>        address owner,</span>
 68 |     | <span class='neutral'>        address spender,</span>
 69 |     | <span class='neutral'>        uint256 value,</span>
 70 |     | <span class='neutral'>        uint256 deadline,</span>
 71 |     | <span class='neutral'>        uint8 v,</span>
 72 |     | <span class='neutral'>        bytes32 r,</span>
 73 |     | <span class='neutral'>        bytes32 s</span>
 74 |     | <span class='neutral'>    ) external;</span>
 75 |     | <span class='neutral'></span>
 76 |     | <span class='neutral'>    /**</span>
 77 |     | <span class='neutral'>     * @dev Returns the current nonce for `owner`. This value must be</span>
 78 |     | <span class='neutral'>     * included whenever a signature is generated for {permit}.</span>
 79 |     | <span class='neutral'>     *</span>
 80 |     | <span class='neutral'>     * Every successful call to {permit} increases ``owner``&#39;s nonce by one. This</span>
 81 |     | <span class='neutral'>     * prevents a signature from being used multiple times.</span>
 82 |     | <span class='neutral'>     */</span>
 83 |     | <span class='neutral'>    function nonces(address owner) external view returns (uint256);</span>
 84 |     | <span class='neutral'></span>
 85 |     | <span class='neutral'>    /**</span>
 86 |     | <span class='neutral'>     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.</span>
 87 |     | <span class='neutral'>     */</span>
 88 |     | <span class='neutral'>    // solhint-disable-next-line func-name-mixedcase</span>
 89 |     | <span class='neutral'>    function DOMAIN_SEPARATOR() external view returns (bytes32);</span>
 90 |     | <span class='neutral'>}</span>
 91 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/phantom/Documents/azemora/azemora-contracts/lib/openzeppelin-contracts/contracts/token/ERC721/IERC721Receiver.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>// OpenZeppelin Contracts (last updated v5.1.0) (token/ERC721/IERC721Receiver.sol)</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>pragma solidity &gt;=0.5.0;</span>
  5 |     | <span class='neutral'></span>
  6 |     | <span class='neutral'>/**</span>
  7 |     | <span class='neutral'> * @title ERC-721 token receiver interface</span>
  8 |     | <span class='neutral'> * @dev Interface for any contract that wants to support safeTransfers</span>
  9 |     | <span class='neutral'> * from ERC-721 asset contracts.</span>
 10 |     | <span class='neutral'> */</span>
 11 |     | <span class='neutral'>interface IERC721Receiver {</span>
 12 |     | <span class='neutral'>    /**</span>
 13 |     | <span class='neutral'>     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}</span>
 14 |     | <span class='neutral'>     * by `operator` from `from`, this function is called.</span>
 15 |     | <span class='neutral'>     *</span>
 16 |     | <span class='neutral'>     * It must return its Solidity selector to confirm the token transfer.</span>
 17 |     | <span class='neutral'>     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be</span>
 18 |     | <span class='neutral'>     * reverted.</span>
 19 |     | <span class='neutral'>     *</span>
 20 |     | <span class='neutral'>     * The selector can be obtained in Solidity with `IERC721Receiver.onERC721Received.selector`.</span>
 21 |     | <span class='neutral'>     */</span>
 22 |     | <span class='neutral'>    function onERC721Received(</span>
 23 |     | <span class='neutral'>        address operator,</span>
 24 |     | <span class='neutral'>        address from,</span>
 25 |     | <span class='neutral'>        uint256 tokenId,</span>
 26 |     | <span class='neutral'>        bytes calldata data</span>
 27 |     | <span class='neutral'>    ) external returns (bytes4);</span>
 28 |     | <span class='neutral'>}</span>
 29 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/phantom/Documents/azemora/azemora-contracts/lib/openzeppelin-contracts/contracts/utils/Address.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'>// OpenZeppelin Contracts (last updated v5.2.0) (utils/Address.sol)</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>pragma solidity ^0.8.20;</span>
   5 |     | <span class='neutral'></span>
   6 |     | <span class='neutral'>import {Errors} from &quot;./Errors.sol&quot;;</span>
   7 |     | <span class='neutral'></span>
   8 |     | <span class='neutral'>/**</span>
   9 |     | <span class='neutral'> * @dev Collection of functions related to the address type</span>
  10 |     | <span class='neutral'> */</span>
  11 |     | <span class='neutral'>library Address {</span>
  12 |     | <span class='neutral'>    /**</span>
  13 |     | <span class='neutral'>     * @dev There&#39;s no code at `target` (it is not a contract).</span>
  14 |     | <span class='neutral'>     */</span>
  15 |     | <span class='neutral'>    error AddressEmptyCode(address target);</span>
  16 |     | <span class='neutral'></span>
  17 |     | <span class='neutral'>    /**</span>
  18 |     | <span class='neutral'>     * @dev Replacement for Solidity&#39;s `transfer`: sends `amount` wei to</span>
  19 |     | <span class='neutral'>     * `recipient`, forwarding all available gas and reverting on errors.</span>
  20 |     | <span class='neutral'>     *</span>
  21 |     | <span class='neutral'>     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost</span>
  22 |     | <span class='neutral'>     * of certain opcodes, possibly making contracts go over the 2300 gas limit</span>
  23 |     | <span class='neutral'>     * imposed by `transfer`, making them unable to receive funds via</span>
  24 |     | <span class='neutral'>     * `transfer`. {sendValue} removes this limitation.</span>
  25 |     | <span class='neutral'>     *</span>
  26 |     | <span class='neutral'>     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].</span>
  27 |     | <span class='neutral'>     *</span>
  28 |     | <span class='neutral'>     * IMPORTANT: because control is transferred to `recipient`, care must be</span>
  29 |     | <span class='neutral'>     * taken to not create reentrancy vulnerabilities. Consider using</span>
  30 |     | <span class='neutral'>     * {ReentrancyGuard} or the</span>
  31 |     | <span class='neutral'>     * https://solidity.readthedocs.io/en/v0.8.20/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].</span>
  32 |     | <span class='neutral'>     */</span>
  33 |     | <span class='neutral'>    function sendValue(address payable recipient, uint256 amount) internal {</span>
  34 |     | <span class='neutral'>        if (address(this).balance &lt; amount) {</span>
  35 |     | <span class='neutral'>            revert Errors.InsufficientBalance(address(this).balance, amount);</span>
  36 |     | <span class='neutral'>        }</span>
  37 |     | <span class='neutral'></span>
  38 |     | <span class='neutral'>        (bool success, bytes memory returndata) = recipient.call{value: amount}(&quot;&quot;);</span>
  39 |     | <span class='neutral'>        if (!success) {</span>
  40 |     | <span class='neutral'>            _revert(returndata);</span>
  41 |     | <span class='neutral'>        }</span>
  42 |     | <span class='neutral'>    }</span>
  43 |     | <span class='neutral'></span>
  44 |     | <span class='neutral'>    /**</span>
  45 |     | <span class='neutral'>     * @dev Performs a Solidity function call using a low level `call`. A</span>
  46 |     | <span class='neutral'>     * plain `call` is an unsafe replacement for a function call: use this</span>
  47 |     | <span class='neutral'>     * function instead.</span>
  48 |     | <span class='neutral'>     *</span>
  49 |     | <span class='neutral'>     * If `target` reverts with a revert reason or custom error, it is bubbled</span>
  50 |     | <span class='neutral'>     * up by this function (like regular Solidity function calls). However, if</span>
  51 |     | <span class='neutral'>     * the call reverted with no returned reason, this function reverts with a</span>
  52 |     | <span class='neutral'>     * {Errors.FailedCall} error.</span>
  53 |     | <span class='neutral'>     *</span>
  54 |     | <span class='neutral'>     * Returns the raw returned data. To convert to the expected return value,</span>
  55 |     | <span class='neutral'>     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].</span>
  56 |     | <span class='neutral'>     *</span>
  57 |     | <span class='neutral'>     * Requirements:</span>
  58 |     | <span class='neutral'>     *</span>
  59 |     | <span class='neutral'>     * - `target` must be a contract.</span>
  60 |     | <span class='neutral'>     * - calling `target` with `data` must not revert.</span>
  61 |     | <span class='neutral'>     */</span>
  62 |     | <span class='neutral'>    function functionCall(address target, bytes memory data) internal returns (bytes memory) {</span>
  63 |     | <span class='neutral'>        return functionCallWithValue(target, data, 0);</span>
  64 |     | <span class='neutral'>    }</span>
  65 |     | <span class='neutral'></span>
  66 |     | <span class='neutral'>    /**</span>
  67 |     | <span class='neutral'>     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],</span>
  68 |     | <span class='neutral'>     * but also transferring `value` wei to `target`.</span>
  69 |     | <span class='neutral'>     *</span>
  70 |     | <span class='neutral'>     * Requirements:</span>
  71 |     | <span class='neutral'>     *</span>
  72 |     | <span class='neutral'>     * - the calling contract must have an ETH balance of at least `value`.</span>
  73 |     | <span class='neutral'>     * - the called Solidity function must be `payable`.</span>
  74 |     | <span class='neutral'>     */</span>
  75 |     | <span class='neutral'>    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {</span>
  76 |     | <span class='neutral'>        if (address(this).balance &lt; value) {</span>
  77 |     | <span class='neutral'>            revert Errors.InsufficientBalance(address(this).balance, value);</span>
  78 |     | <span class='neutral'>        }</span>
  79 |     | <span class='neutral'>        (bool success, bytes memory returndata) = target.call{value: value}(data);</span>
  80 |     | <span class='neutral'>        return verifyCallResultFromTarget(target, success, returndata);</span>
  81 |     | <span class='neutral'>    }</span>
  82 |     | <span class='neutral'></span>
  83 |     | <span class='neutral'>    /**</span>
  84 |     | <span class='neutral'>     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],</span>
  85 |     | <span class='neutral'>     * but performing a static call.</span>
  86 |     | <span class='neutral'>     */</span>
  87 |     | <span class='neutral'>    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {</span>
  88 |     | <span class='neutral'>        (bool success, bytes memory returndata) = target.staticcall(data);</span>
  89 |     | <span class='neutral'>        return verifyCallResultFromTarget(target, success, returndata);</span>
  90 |     | <span class='neutral'>    }</span>
  91 |     | <span class='neutral'></span>
  92 |     | <span class='neutral'>    /**</span>
  93 |     | <span class='neutral'>     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],</span>
  94 |     | <span class='neutral'>     * but performing a delegate call.</span>
  95 |     | <span class='neutral'>     */</span>
  96 |     | <span class='neutral'>    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {</span>
  97 |     | <span class='neutral'>        (bool success, bytes memory returndata) = target.delegatecall(data);</span>
  98 |     | <span class='neutral'>        return verifyCallResultFromTarget(target, success, returndata);</span>
  99 |     | <span class='neutral'>    }</span>
 100 |     | <span class='neutral'></span>
 101 |     | <span class='neutral'>    /**</span>
 102 |     | <span class='neutral'>     * @dev Tool to verify that a low level call to smart-contract was successful, and reverts if the target</span>
 103 |     | <span class='neutral'>     * was not a contract or bubbling up the revert reason (falling back to {Errors.FailedCall}) in case</span>
 104 |     | <span class='neutral'>     * of an unsuccessful call.</span>
 105 |     | <span class='neutral'>     */</span>
 106 |     | <span class='neutral'>    function verifyCallResultFromTarget(</span>
 107 |     | <span class='neutral'>        address target,</span>
 108 |     | <span class='neutral'>        bool success,</span>
 109 |     | <span class='neutral'>        bytes memory returndata</span>
 110 |     | <span class='neutral'>    ) internal view returns (bytes memory) {</span>
 111 |     | <span class='neutral'>        if (!success) {</span>
 112 |     | <span class='neutral'>            _revert(returndata);</span>
 113 |     | <span class='neutral'>        } else {</span>
 114 |     | <span class='neutral'>            // only check if target is a contract if the call was successful and the return data is empty</span>
 115 |     | <span class='neutral'>            // otherwise we already know that it was a contract</span>
 116 |     | <span class='neutral'>            if (returndata.length == 0 &amp;&amp; target.code.length == 0) {</span>
 117 |     | <span class='neutral'>                revert AddressEmptyCode(target);</span>
 118 |     | <span class='neutral'>            }</span>
 119 |     | <span class='neutral'>            return returndata;</span>
 120 |     | <span class='neutral'>        }</span>
 121 |     | <span class='neutral'>    }</span>
 122 |     | <span class='neutral'></span>
 123 |     | <span class='neutral'>    /**</span>
 124 |     | <span class='neutral'>     * @dev Tool to verify that a low level call was successful, and reverts if it wasn&#39;t, either by bubbling the</span>
 125 |     | <span class='neutral'>     * revert reason or with a default {Errors.FailedCall} error.</span>
 126 |     | <span class='neutral'>     */</span>
 127 |     | <span class='neutral'>    function verifyCallResult(bool success, bytes memory returndata) internal pure returns (bytes memory) {</span>
 128 |     | <span class='neutral'>        if (!success) {</span>
 129 |     | <span class='neutral'>            _revert(returndata);</span>
 130 |     | <span class='neutral'>        } else {</span>
 131 |     | <span class='neutral'>            return returndata;</span>
 132 |     | <span class='neutral'>        }</span>
 133 |     | <span class='neutral'>    }</span>
 134 |     | <span class='neutral'></span>
 135 |     | <span class='neutral'>    /**</span>
 136 |     | <span class='neutral'>     * @dev Reverts with returndata if present. Otherwise reverts with {Errors.FailedCall}.</span>
 137 |     | <span class='neutral'>     */</span>
 138 |     | <span class='neutral'>    function _revert(bytes memory returndata) private pure {</span>
 139 |     | <span class='neutral'>        // Look for revert reason and bubble it up if present</span>
 140 |     | <span class='neutral'>        if (returndata.length &gt; 0) {</span>
 141 |     | <span class='neutral'>            // The easiest way to bubble the revert reason is using memory via assembly</span>
 142 |     | <span class='neutral'>            assembly (&quot;memory-safe&quot;) {</span>
 143 |     | <span class='neutral'>                revert(add(returndata, 0x20), mload(returndata))</span>
 144 |     | <span class='neutral'>            }</span>
 145 |     | <span class='neutral'>        } else {</span>
 146 |     | <span class='neutral'>            revert Errors.FailedCall();</span>
 147 |     | <span class='neutral'>        }</span>
 148 |     | <span class='neutral'>    }</span>
 149 |     | <span class='neutral'>}</span>
 150 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/phantom/Documents/azemora/azemora-contracts/lib/openzeppelin-contracts/contracts/utils/Arrays.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'>// OpenZeppelin Contracts (last updated v5.3.0) (utils/Arrays.sol)</span>
   3 |     | <span class='neutral'>// This file was procedurally generated from scripts/generate/templates/Arrays.js.</span>
   4 |     | <span class='neutral'></span>
   5 |     | <span class='neutral'>pragma solidity ^0.8.20;</span>
   6 |     | <span class='neutral'></span>
   7 |     | <span class='neutral'>import {Comparators} from &quot;./Comparators.sol&quot;;</span>
   8 |     | <span class='neutral'>import {SlotDerivation} from &quot;./SlotDerivation.sol&quot;;</span>
   9 |     | <span class='neutral'>import {StorageSlot} from &quot;./StorageSlot.sol&quot;;</span>
  10 |     | <span class='neutral'>import {Math} from &quot;./math/Math.sol&quot;;</span>
  11 |     | <span class='neutral'></span>
  12 |     | <span class='neutral'>/**</span>
  13 |     | <span class='neutral'> * @dev Collection of functions related to array types.</span>
  14 |     | <span class='neutral'> */</span>
  15 |     | <span class='neutral'>library Arrays {</span>
  16 |     | <span class='neutral'>    using SlotDerivation for bytes32;</span>
  17 |     | <span class='neutral'>    using StorageSlot for bytes32;</span>
  18 |     | <span class='neutral'></span>
  19 |     | <span class='neutral'>    /**</span>
  20 |     | <span class='neutral'>     * @dev Sort an array of uint256 (in memory) following the provided comparator function.</span>
  21 |     | <span class='neutral'>     *</span>
  22 |     | <span class='neutral'>     * This function does the sorting &quot;in place&quot;, meaning that it overrides the input. The object is returned for</span>
  23 |     | <span class='neutral'>     * convenience, but that returned value can be discarded safely if the caller has a memory pointer to the array.</span>
  24 |     | <span class='neutral'>     *</span>
  25 |     | <span class='neutral'>     * NOTE: this function&#39;s cost is `O(n  log(n))` in average and `O(n)` in the worst case, with n the length of the</span>
  26 |     | <span class='neutral'>     * array. Using it in view functions that are executed through `eth_call` is safe, but one should be very careful</span>
  27 |     | <span class='neutral'>     * when executing this as part of a transaction. If the array being sorted is too large, the sort operation may</span>
  28 |     | <span class='neutral'>     * consume more gas than is available in a block, leading to potential DoS.</span>
  29 |     | <span class='neutral'>     *</span>
  30 |     | <span class='neutral'>     * IMPORTANT: Consider memory side-effects when using custom comparator functions that access memory in an unsafe way.</span>
  31 |     | <span class='neutral'>     */</span>
  32 |     | <span class='neutral'>    function sort(</span>
  33 |     | <span class='neutral'>        uint256[] memory array,</span>
  34 |     | <span class='neutral'>        function(uint256, uint256) pure returns (bool) comp</span>
  35 |     | <span class='neutral'>    ) internal pure returns (uint256[] memory) {</span>
  36 |     | <span class='neutral'>        _quickSort(_begin(array), _end(array), comp);</span>
  37 |     | <span class='neutral'>        return array;</span>
  38 |     | <span class='neutral'>    }</span>
  39 |     | <span class='neutral'></span>
  40 |     | <span class='neutral'>    /**</span>
  41 |     | <span class='neutral'>     * @dev Variant of {sort} that sorts an array of uint256 in increasing order.</span>
  42 |     | <span class='neutral'>     */</span>
  43 |     | <span class='neutral'>    function sort(uint256[] memory array) internal pure returns (uint256[] memory) {</span>
  44 |     | <span class='neutral'>        sort(array, Comparators.lt);</span>
  45 |     | <span class='neutral'>        return array;</span>
  46 |     | <span class='neutral'>    }</span>
  47 |     | <span class='neutral'></span>
  48 |     | <span class='neutral'>    /**</span>
  49 |     | <span class='neutral'>     * @dev Sort an array of address (in memory) following the provided comparator function.</span>
  50 |     | <span class='neutral'>     *</span>
  51 |     | <span class='neutral'>     * This function does the sorting &quot;in place&quot;, meaning that it overrides the input. The object is returned for</span>
  52 |     | <span class='neutral'>     * convenience, but that returned value can be discarded safely if the caller has a memory pointer to the array.</span>
  53 |     | <span class='neutral'>     *</span>
  54 |     | <span class='neutral'>     * NOTE: this function&#39;s cost is `O(n  log(n))` in average and `O(n)` in the worst case, with n the length of the</span>
  55 |     | <span class='neutral'>     * array. Using it in view functions that are executed through `eth_call` is safe, but one should be very careful</span>
  56 |     | <span class='neutral'>     * when executing this as part of a transaction. If the array being sorted is too large, the sort operation may</span>
  57 |     | <span class='neutral'>     * consume more gas than is available in a block, leading to potential DoS.</span>
  58 |     | <span class='neutral'>     *</span>
  59 |     | <span class='neutral'>     * IMPORTANT: Consider memory side-effects when using custom comparator functions that access memory in an unsafe way.</span>
  60 |     | <span class='neutral'>     */</span>
  61 |     | <span class='neutral'>    function sort(</span>
  62 |     | <span class='neutral'>        address[] memory array,</span>
  63 |     | <span class='neutral'>        function(address, address) pure returns (bool) comp</span>
  64 |     | <span class='neutral'>    ) internal pure returns (address[] memory) {</span>
  65 |     | <span class='neutral'>        sort(_castToUint256Array(array), _castToUint256Comp(comp));</span>
  66 |     | <span class='neutral'>        return array;</span>
  67 |     | <span class='neutral'>    }</span>
  68 |     | <span class='neutral'></span>
  69 |     | <span class='neutral'>    /**</span>
  70 |     | <span class='neutral'>     * @dev Variant of {sort} that sorts an array of address in increasing order.</span>
  71 |     | <span class='neutral'>     */</span>
  72 |     | <span class='neutral'>    function sort(address[] memory array) internal pure returns (address[] memory) {</span>
  73 |     | <span class='neutral'>        sort(_castToUint256Array(array), Comparators.lt);</span>
  74 |     | <span class='neutral'>        return array;</span>
  75 |     | <span class='neutral'>    }</span>
  76 |     | <span class='neutral'></span>
  77 |     | <span class='neutral'>    /**</span>
  78 |     | <span class='neutral'>     * @dev Sort an array of bytes32 (in memory) following the provided comparator function.</span>
  79 |     | <span class='neutral'>     *</span>
  80 |     | <span class='neutral'>     * This function does the sorting &quot;in place&quot;, meaning that it overrides the input. The object is returned for</span>
  81 |     | <span class='neutral'>     * convenience, but that returned value can be discarded safely if the caller has a memory pointer to the array.</span>
  82 |     | <span class='neutral'>     *</span>
  83 |     | <span class='neutral'>     * NOTE: this function&#39;s cost is `O(n  log(n))` in average and `O(n)` in the worst case, with n the length of the</span>
  84 |     | <span class='neutral'>     * array. Using it in view functions that are executed through `eth_call` is safe, but one should be very careful</span>
  85 |     | <span class='neutral'>     * when executing this as part of a transaction. If the array being sorted is too large, the sort operation may</span>
  86 |     | <span class='neutral'>     * consume more gas than is available in a block, leading to potential DoS.</span>
  87 |     | <span class='neutral'>     *</span>
  88 |     | <span class='neutral'>     * IMPORTANT: Consider memory side-effects when using custom comparator functions that access memory in an unsafe way.</span>
  89 |     | <span class='neutral'>     */</span>
  90 |     | <span class='neutral'>    function sort(</span>
  91 |     | <span class='neutral'>        bytes32[] memory array,</span>
  92 |     | <span class='neutral'>        function(bytes32, bytes32) pure returns (bool) comp</span>
  93 |     | <span class='neutral'>    ) internal pure returns (bytes32[] memory) {</span>
  94 |     | <span class='neutral'>        sort(_castToUint256Array(array), _castToUint256Comp(comp));</span>
  95 |     | <span class='neutral'>        return array;</span>
  96 |     | <span class='neutral'>    }</span>
  97 |     | <span class='neutral'></span>
  98 |     | <span class='neutral'>    /**</span>
  99 |     | <span class='neutral'>     * @dev Variant of {sort} that sorts an array of bytes32 in increasing order.</span>
 100 |     | <span class='neutral'>     */</span>
 101 |     | <span class='neutral'>    function sort(bytes32[] memory array) internal pure returns (bytes32[] memory) {</span>
 102 |     | <span class='neutral'>        sort(_castToUint256Array(array), Comparators.lt);</span>
 103 |     | <span class='neutral'>        return array;</span>
 104 |     | <span class='neutral'>    }</span>
 105 |     | <span class='neutral'></span>
 106 |     | <span class='neutral'>    /**</span>
 107 |     | <span class='neutral'>     * @dev Performs a quick sort of a segment of memory. The segment sorted starts at `begin` (inclusive), and stops</span>
 108 |     | <span class='neutral'>     * at end (exclusive). Sorting follows the `comp` comparator.</span>
 109 |     | <span class='neutral'>     *</span>
 110 |     | <span class='neutral'>     * Invariant: `begin &lt;= end`. This is the case when initially called by {sort} and is preserved in subcalls.</span>
 111 |     | <span class='neutral'>     *</span>
 112 |     | <span class='neutral'>     * IMPORTANT: Memory locations between `begin` and `end` are not validated/zeroed. This function should</span>
 113 |     | <span class='neutral'>     * be used only if the limits are within a memory array.</span>
 114 |     | <span class='neutral'>     */</span>
 115 |     | <span class='neutral'>    function _quickSort(uint256 begin, uint256 end, function(uint256, uint256) pure returns (bool) comp) private pure {</span>
 116 |     | <span class='neutral'>        unchecked {</span>
 117 |     | <span class='neutral'>            if (end - begin &lt; 0x40) return;</span>
 118 |     | <span class='neutral'></span>
 119 |     | <span class='neutral'>            // Use first element as pivot</span>
 120 |     | <span class='neutral'>            uint256 pivot = _mload(begin);</span>
 121 |     | <span class='neutral'>            // Position where the pivot should be at the end of the loop</span>
 122 |     | <span class='neutral'>            uint256 pos = begin;</span>
 123 |     | <span class='neutral'></span>
 124 |     | <span class='neutral'>            for (uint256 it = begin + 0x20; it &lt; end; it += 0x20) {</span>
 125 |     | <span class='neutral'>                if (comp(_mload(it), pivot)) {</span>
 126 |     | <span class='neutral'>                    // If the value stored at the iterator&#39;s position comes before the pivot, we increment the</span>
 127 |     | <span class='neutral'>                    // position of the pivot and move the value there.</span>
 128 |     | <span class='neutral'>                    pos += 0x20;</span>
 129 |     | <span class='neutral'>                    _swap(pos, it);</span>
 130 |     | <span class='neutral'>                }</span>
 131 |     | <span class='neutral'>            }</span>
 132 |     | <span class='neutral'></span>
 133 |     | <span class='neutral'>            _swap(begin, pos); // Swap pivot into place</span>
 134 |     | <span class='neutral'>            _quickSort(begin, pos, comp); // Sort the left side of the pivot</span>
 135 |     | <span class='neutral'>            _quickSort(pos + 0x20, end, comp); // Sort the right side of the pivot</span>
 136 |     | <span class='neutral'>        }</span>
 137 |     | <span class='neutral'>    }</span>
 138 |     | <span class='neutral'></span>
 139 |     | <span class='neutral'>    /**</span>
 140 |     | <span class='neutral'>     * @dev Pointer to the memory location of the first element of `array`.</span>
 141 |     | <span class='neutral'>     */</span>
 142 |     | <span class='neutral'>    function _begin(uint256[] memory array) private pure returns (uint256 ptr) {</span>
 143 |     | <span class='neutral'>        assembly (&quot;memory-safe&quot;) {</span>
 144 |     | <span class='neutral'>            ptr := add(array, 0x20)</span>
 145 |     | <span class='neutral'>        }</span>
 146 |     | <span class='neutral'>    }</span>
 147 |     | <span class='neutral'></span>
 148 |     | <span class='neutral'>    /**</span>
 149 |     | <span class='neutral'>     * @dev Pointer to the memory location of the first memory word (32bytes) after `array`. This is the memory word</span>
 150 |     | <span class='neutral'>     * that comes just after the last element of the array.</span>
 151 |     | <span class='neutral'>     */</span>
 152 |     | <span class='neutral'>    function _end(uint256[] memory array) private pure returns (uint256 ptr) {</span>
 153 |     | <span class='neutral'>        unchecked {</span>
 154 |     | <span class='neutral'>            return _begin(array) + array.length * 0x20;</span>
 155 |     | <span class='neutral'>        }</span>
 156 |     | <span class='neutral'>    }</span>
 157 |     | <span class='neutral'></span>
 158 |     | <span class='neutral'>    /**</span>
 159 |     | <span class='neutral'>     * @dev Load memory word (as a uint256) at location `ptr`.</span>
 160 |     | <span class='neutral'>     */</span>
 161 |     | <span class='neutral'>    function _mload(uint256 ptr) private pure returns (uint256 value) {</span>
 162 |     | <span class='neutral'>        assembly {</span>
 163 |     | <span class='neutral'>            value := mload(ptr)</span>
 164 |     | <span class='neutral'>        }</span>
 165 |     | <span class='neutral'>    }</span>
 166 |     | <span class='neutral'></span>
 167 |     | <span class='neutral'>    /**</span>
 168 |     | <span class='neutral'>     * @dev Swaps the elements memory location `ptr1` and `ptr2`.</span>
 169 |     | <span class='neutral'>     */</span>
 170 |     | <span class='neutral'>    function _swap(uint256 ptr1, uint256 ptr2) private pure {</span>
 171 |     | <span class='neutral'>        assembly {</span>
 172 |     | <span class='neutral'>            let value1 := mload(ptr1)</span>
 173 |     | <span class='neutral'>            let value2 := mload(ptr2)</span>
 174 |     | <span class='neutral'>            mstore(ptr1, value2)</span>
 175 |     | <span class='neutral'>            mstore(ptr2, value1)</span>
 176 |     | <span class='neutral'>        }</span>
 177 |     | <span class='neutral'>    }</span>
 178 |     | <span class='neutral'></span>
 179 |     | <span class='neutral'>    /// @dev Helper: low level cast address memory array to uint256 memory array</span>
 180 |     | <span class='neutral'>    function _castToUint256Array(address[] memory input) private pure returns (uint256[] memory output) {</span>
 181 |     | <span class='neutral'>        assembly {</span>
 182 |     | <span class='neutral'>            output := input</span>
 183 |     | <span class='neutral'>        }</span>
 184 |     | <span class='neutral'>    }</span>
 185 |     | <span class='neutral'></span>
 186 |     | <span class='neutral'>    /// @dev Helper: low level cast bytes32 memory array to uint256 memory array</span>
 187 |     | <span class='neutral'>    function _castToUint256Array(bytes32[] memory input) private pure returns (uint256[] memory output) {</span>
 188 |     | <span class='neutral'>        assembly {</span>
 189 |     | <span class='neutral'>            output := input</span>
 190 |     | <span class='neutral'>        }</span>
 191 |     | <span class='neutral'>    }</span>
 192 |     | <span class='neutral'></span>
 193 |     | <span class='neutral'>    /// @dev Helper: low level cast address comp function to uint256 comp function</span>
 194 |     | <span class='neutral'>    function _castToUint256Comp(</span>
 195 |     | <span class='neutral'>        function(address, address) pure returns (bool) input</span>
 196 |     | <span class='neutral'>    ) private pure returns (function(uint256, uint256) pure returns (bool) output) {</span>
 197 |     | <span class='neutral'>        assembly {</span>
 198 |     | <span class='neutral'>            output := input</span>
 199 |     | <span class='neutral'>        }</span>
 200 |     | <span class='neutral'>    }</span>
 201 |     | <span class='neutral'></span>
 202 |     | <span class='neutral'>    /// @dev Helper: low level cast bytes32 comp function to uint256 comp function</span>
 203 |     | <span class='neutral'>    function _castToUint256Comp(</span>
 204 |     | <span class='neutral'>        function(bytes32, bytes32) pure returns (bool) input</span>
 205 |     | <span class='neutral'>    ) private pure returns (function(uint256, uint256) pure returns (bool) output) {</span>
 206 |     | <span class='neutral'>        assembly {</span>
 207 |     | <span class='neutral'>            output := input</span>
 208 |     | <span class='neutral'>        }</span>
 209 |     | <span class='neutral'>    }</span>
 210 |     | <span class='neutral'></span>
 211 |     | <span class='neutral'>    /**</span>
 212 |     | <span class='neutral'>     * @dev Searches a sorted `array` and returns the first index that contains</span>
 213 |     | <span class='neutral'>     * a value greater or equal to `element`. If no such index exists (i.e. all</span>
 214 |     | <span class='neutral'>     * values in the array are strictly less than `element`), the array length is</span>
 215 |     | <span class='neutral'>     * returned. Time complexity O(log n).</span>
 216 |     | <span class='neutral'>     *</span>
 217 |     | <span class='neutral'>     * NOTE: The `array` is expected to be sorted in ascending order, and to</span>
 218 |     | <span class='neutral'>     * contain no repeated elements.</span>
 219 |     | <span class='neutral'>     *</span>
 220 |     | <span class='neutral'>     * IMPORTANT: Deprecated. This implementation behaves as {lowerBound} but lacks</span>
 221 |     | <span class='neutral'>     * support for repeated elements in the array. The {lowerBound} function should</span>
 222 |     | <span class='neutral'>     * be used instead.</span>
 223 |     | <span class='neutral'>     */</span>
 224 |     | <span class='neutral'>    function findUpperBound(uint256[] storage array, uint256 element) internal view returns (uint256) {</span>
 225 |     | <span class='neutral'>        uint256 low = 0;</span>
 226 |     | <span class='neutral'>        uint256 high = array.length;</span>
 227 |     | <span class='neutral'></span>
 228 |     | <span class='neutral'>        if (high == 0) {</span>
 229 |     | <span class='neutral'>            return 0;</span>
 230 |     | <span class='neutral'>        }</span>
 231 |     | <span class='neutral'></span>
 232 |     | <span class='neutral'>        while (low &lt; high) {</span>
 233 |     | <span class='neutral'>            uint256 mid = Math.average(low, high);</span>
 234 |     | <span class='neutral'></span>
 235 |     | <span class='neutral'>            // Note that mid will always be strictly less than high (i.e. it will be a valid array index)</span>
 236 |     | <span class='neutral'>            // because Math.average rounds towards zero (it does integer division with truncation).</span>
 237 |     | <span class='neutral'>            if (unsafeAccess(array, mid).value &gt; element) {</span>
 238 |     | <span class='neutral'>                high = mid;</span>
 239 |     | <span class='neutral'>            } else {</span>
 240 |     | <span class='neutral'>                low = mid + 1;</span>
 241 |     | <span class='neutral'>            }</span>
 242 |     | <span class='neutral'>        }</span>
 243 |     | <span class='neutral'></span>
 244 |     | <span class='neutral'>        // At this point `low` is the exclusive upper bound. We will return the inclusive upper bound.</span>
 245 |     | <span class='neutral'>        if (low &gt; 0 &amp;&amp; unsafeAccess(array, low - 1).value == element) {</span>
 246 |     | <span class='neutral'>            return low - 1;</span>
 247 |     | <span class='neutral'>        } else {</span>
 248 |     | <span class='neutral'>            return low;</span>
 249 |     | <span class='neutral'>        }</span>
 250 |     | <span class='neutral'>    }</span>
 251 |     | <span class='neutral'></span>
 252 |     | <span class='neutral'>    /**</span>
 253 |     | <span class='neutral'>     * @dev Searches an `array` sorted in ascending order and returns the first</span>
 254 |     | <span class='neutral'>     * index that contains a value greater or equal than `element`. If no such index</span>
 255 |     | <span class='neutral'>     * exists (i.e. all values in the array are strictly less than `element`), the array</span>
 256 |     | <span class='neutral'>     * length is returned. Time complexity O(log n).</span>
 257 |     | <span class='neutral'>     *</span>
 258 |     | <span class='neutral'>     * See C++&#39;s https://en.cppreference.com/w/cpp/algorithm/lower_bound[lower_bound].</span>
 259 |     | <span class='neutral'>     */</span>
 260 |     | <span class='neutral'>    function lowerBound(uint256[] storage array, uint256 element) internal view returns (uint256) {</span>
 261 |     | <span class='neutral'>        uint256 low = 0;</span>
 262 |     | <span class='neutral'>        uint256 high = array.length;</span>
 263 |     | <span class='neutral'></span>
 264 |     | <span class='neutral'>        if (high == 0) {</span>
 265 |     | <span class='neutral'>            return 0;</span>
 266 |     | <span class='neutral'>        }</span>
 267 |     | <span class='neutral'></span>
 268 |     | <span class='neutral'>        while (low &lt; high) {</span>
 269 |     | <span class='neutral'>            uint256 mid = Math.average(low, high);</span>
 270 |     | <span class='neutral'></span>
 271 |     | <span class='neutral'>            // Note that mid will always be strictly less than high (i.e. it will be a valid array index)</span>
 272 |     | <span class='neutral'>            // because Math.average rounds towards zero (it does integer division with truncation).</span>
 273 |     | <span class='neutral'>            if (unsafeAccess(array, mid).value &lt; element) {</span>
 274 |     | <span class='neutral'>                // this cannot overflow because mid &lt; high</span>
 275 |     | <span class='neutral'>                unchecked {</span>
 276 |     | <span class='neutral'>                    low = mid + 1;</span>
 277 |     | <span class='neutral'>                }</span>
 278 |     | <span class='neutral'>            } else {</span>
 279 |     | <span class='neutral'>                high = mid;</span>
 280 |     | <span class='neutral'>            }</span>
 281 |     | <span class='neutral'>        }</span>
 282 |     | <span class='neutral'></span>
 283 |     | <span class='neutral'>        return low;</span>
 284 |     | <span class='neutral'>    }</span>
 285 |     | <span class='neutral'></span>
 286 |     | <span class='neutral'>    /**</span>
 287 |     | <span class='neutral'>     * @dev Searches an `array` sorted in ascending order and returns the first</span>
 288 |     | <span class='neutral'>     * index that contains a value strictly greater than `element`. If no such index</span>
 289 |     | <span class='neutral'>     * exists (i.e. all values in the array are strictly less than `element`), the array</span>
 290 |     | <span class='neutral'>     * length is returned. Time complexity O(log n).</span>
 291 |     | <span class='neutral'>     *</span>
 292 |     | <span class='neutral'>     * See C++&#39;s https://en.cppreference.com/w/cpp/algorithm/upper_bound[upper_bound].</span>
 293 |     | <span class='neutral'>     */</span>
 294 |     | <span class='neutral'>    function upperBound(uint256[] storage array, uint256 element) internal view returns (uint256) {</span>
 295 |     | <span class='neutral'>        uint256 low = 0;</span>
 296 |     | <span class='neutral'>        uint256 high = array.length;</span>
 297 |     | <span class='neutral'></span>
 298 |     | <span class='neutral'>        if (high == 0) {</span>
 299 |     | <span class='neutral'>            return 0;</span>
 300 |     | <span class='neutral'>        }</span>
 301 |     | <span class='neutral'></span>
 302 |     | <span class='neutral'>        while (low &lt; high) {</span>
 303 |     | <span class='neutral'>            uint256 mid = Math.average(low, high);</span>
 304 |     | <span class='neutral'></span>
 305 |     | <span class='neutral'>            // Note that mid will always be strictly less than high (i.e. it will be a valid array index)</span>
 306 |     | <span class='neutral'>            // because Math.average rounds towards zero (it does integer division with truncation).</span>
 307 |     | <span class='neutral'>            if (unsafeAccess(array, mid).value &gt; element) {</span>
 308 |     | <span class='neutral'>                high = mid;</span>
 309 |     | <span class='neutral'>            } else {</span>
 310 |     | <span class='neutral'>                // this cannot overflow because mid &lt; high</span>
 311 |     | <span class='neutral'>                unchecked {</span>
 312 |     | <span class='neutral'>                    low = mid + 1;</span>
 313 |     | <span class='neutral'>                }</span>
 314 |     | <span class='neutral'>            }</span>
 315 |     | <span class='neutral'>        }</span>
 316 |     | <span class='neutral'></span>
 317 |     | <span class='neutral'>        return low;</span>
 318 |     | <span class='neutral'>    }</span>
 319 |     | <span class='neutral'></span>
 320 |     | <span class='neutral'>    /**</span>
 321 |     | <span class='neutral'>     * @dev Same as {lowerBound}, but with an array in memory.</span>
 322 |     | <span class='neutral'>     */</span>
 323 |     | <span class='neutral'>    function lowerBoundMemory(uint256[] memory array, uint256 element) internal pure returns (uint256) {</span>
 324 |     | <span class='neutral'>        uint256 low = 0;</span>
 325 |     | <span class='neutral'>        uint256 high = array.length;</span>
 326 |     | <span class='neutral'></span>
 327 |     | <span class='neutral'>        if (high == 0) {</span>
 328 |     | <span class='neutral'>            return 0;</span>
 329 |     | <span class='neutral'>        }</span>
 330 |     | <span class='neutral'></span>
 331 |     | <span class='neutral'>        while (low &lt; high) {</span>
 332 |     | <span class='neutral'>            uint256 mid = Math.average(low, high);</span>
 333 |     | <span class='neutral'></span>
 334 |     | <span class='neutral'>            // Note that mid will always be strictly less than high (i.e. it will be a valid array index)</span>
 335 |     | <span class='neutral'>            // because Math.average rounds towards zero (it does integer division with truncation).</span>
 336 |     | <span class='neutral'>            if (unsafeMemoryAccess(array, mid) &lt; element) {</span>
 337 |     | <span class='neutral'>                // this cannot overflow because mid &lt; high</span>
 338 |     | <span class='neutral'>                unchecked {</span>
 339 |     | <span class='neutral'>                    low = mid + 1;</span>
 340 |     | <span class='neutral'>                }</span>
 341 |     | <span class='neutral'>            } else {</span>
 342 |     | <span class='neutral'>                high = mid;</span>
 343 |     | <span class='neutral'>            }</span>
 344 |     | <span class='neutral'>        }</span>
 345 |     | <span class='neutral'></span>
 346 |     | <span class='neutral'>        return low;</span>
 347 |     | <span class='neutral'>    }</span>
 348 |     | <span class='neutral'></span>
 349 |     | <span class='neutral'>    /**</span>
 350 |     | <span class='neutral'>     * @dev Same as {upperBound}, but with an array in memory.</span>
 351 |     | <span class='neutral'>     */</span>
 352 |     | <span class='neutral'>    function upperBoundMemory(uint256[] memory array, uint256 element) internal pure returns (uint256) {</span>
 353 |     | <span class='neutral'>        uint256 low = 0;</span>
 354 |     | <span class='neutral'>        uint256 high = array.length;</span>
 355 |     | <span class='neutral'></span>
 356 |     | <span class='neutral'>        if (high == 0) {</span>
 357 |     | <span class='neutral'>            return 0;</span>
 358 |     | <span class='neutral'>        }</span>
 359 |     | <span class='neutral'></span>
 360 |     | <span class='neutral'>        while (low &lt; high) {</span>
 361 |     | <span class='neutral'>            uint256 mid = Math.average(low, high);</span>
 362 |     | <span class='neutral'></span>
 363 |     | <span class='neutral'>            // Note that mid will always be strictly less than high (i.e. it will be a valid array index)</span>
 364 |     | <span class='neutral'>            // because Math.average rounds towards zero (it does integer division with truncation).</span>
 365 |     | <span class='neutral'>            if (unsafeMemoryAccess(array, mid) &gt; element) {</span>
 366 |     | <span class='neutral'>                high = mid;</span>
 367 |     | <span class='neutral'>            } else {</span>
 368 |     | <span class='neutral'>                // this cannot overflow because mid &lt; high</span>
 369 |     | <span class='neutral'>                unchecked {</span>
 370 |     | <span class='neutral'>                    low = mid + 1;</span>
 371 |     | <span class='neutral'>                }</span>
 372 |     | <span class='neutral'>            }</span>
 373 |     | <span class='neutral'>        }</span>
 374 |     | <span class='neutral'></span>
 375 |     | <span class='neutral'>        return low;</span>
 376 |     | <span class='neutral'>    }</span>
 377 |     | <span class='neutral'></span>
 378 |     | <span class='neutral'>    /**</span>
 379 |     | <span class='neutral'>     * @dev Access an array in an &quot;unsafe&quot; way. Skips solidity &quot;index-out-of-range&quot; check.</span>
 380 |     | <span class='neutral'>     *</span>
 381 |     | <span class='neutral'>     * WARNING: Only use if you are certain `pos` is lower than the array length.</span>
 382 |     | <span class='neutral'>     */</span>
 383 |     | <span class='neutral'>    function unsafeAccess(address[] storage arr, uint256 pos) internal pure returns (StorageSlot.AddressSlot storage) {</span>
 384 |     | <span class='neutral'>        bytes32 slot;</span>
 385 |     | <span class='neutral'>        assembly (&quot;memory-safe&quot;) {</span>
 386 |     | <span class='neutral'>            slot := arr.slot</span>
 387 |     | <span class='neutral'>        }</span>
 388 |     | <span class='neutral'>        return slot.deriveArray().offset(pos).getAddressSlot();</span>
 389 |     | <span class='neutral'>    }</span>
 390 |     | <span class='neutral'></span>
 391 |     | <span class='neutral'>    /**</span>
 392 |     | <span class='neutral'>     * @dev Access an array in an &quot;unsafe&quot; way. Skips solidity &quot;index-out-of-range&quot; check.</span>
 393 |     | <span class='neutral'>     *</span>
 394 |     | <span class='neutral'>     * WARNING: Only use if you are certain `pos` is lower than the array length.</span>
 395 |     | <span class='neutral'>     */</span>
 396 |     | <span class='neutral'>    function unsafeAccess(bytes32[] storage arr, uint256 pos) internal pure returns (StorageSlot.Bytes32Slot storage) {</span>
 397 |     | <span class='neutral'>        bytes32 slot;</span>
 398 |     | <span class='neutral'>        assembly (&quot;memory-safe&quot;) {</span>
 399 |     | <span class='neutral'>            slot := arr.slot</span>
 400 |     | <span class='neutral'>        }</span>
 401 |     | <span class='neutral'>        return slot.deriveArray().offset(pos).getBytes32Slot();</span>
 402 |     | <span class='neutral'>    }</span>
 403 |     | <span class='neutral'></span>
 404 |     | <span class='neutral'>    /**</span>
 405 |     | <span class='neutral'>     * @dev Access an array in an &quot;unsafe&quot; way. Skips solidity &quot;index-out-of-range&quot; check.</span>
 406 |     | <span class='neutral'>     *</span>
 407 |     | <span class='neutral'>     * WARNING: Only use if you are certain `pos` is lower than the array length.</span>
 408 |     | <span class='neutral'>     */</span>
 409 |     | <span class='neutral'>    function unsafeAccess(uint256[] storage arr, uint256 pos) internal pure returns (StorageSlot.Uint256Slot storage) {</span>
 410 |     | <span class='neutral'>        bytes32 slot;</span>
 411 |     | <span class='neutral'>        assembly (&quot;memory-safe&quot;) {</span>
 412 |     | <span class='neutral'>            slot := arr.slot</span>
 413 |     | <span class='neutral'>        }</span>
 414 |     | <span class='neutral'>        return slot.deriveArray().offset(pos).getUint256Slot();</span>
 415 |     | <span class='neutral'>    }</span>
 416 |     | <span class='neutral'></span>
 417 |     | <span class='neutral'>    /**</span>
 418 |     | <span class='neutral'>     * @dev Access an array in an &quot;unsafe&quot; way. Skips solidity &quot;index-out-of-range&quot; check.</span>
 419 |     | <span class='neutral'>     *</span>
 420 |     | <span class='neutral'>     * WARNING: Only use if you are certain `pos` is lower than the array length.</span>
 421 |     | <span class='neutral'>     */</span>
 422 |     | <span class='neutral'>    function unsafeAccess(bytes[] storage arr, uint256 pos) internal pure returns (StorageSlot.BytesSlot storage) {</span>
 423 |     | <span class='neutral'>        bytes32 slot;</span>
 424 |     | <span class='neutral'>        assembly (&quot;memory-safe&quot;) {</span>
 425 |     | <span class='neutral'>            slot := arr.slot</span>
 426 |     | <span class='neutral'>        }</span>
 427 |     | <span class='neutral'>        return slot.deriveArray().offset(pos).getBytesSlot();</span>
 428 |     | <span class='neutral'>    }</span>
 429 |     | <span class='neutral'></span>
 430 |     | <span class='neutral'>    /**</span>
 431 |     | <span class='neutral'>     * @dev Access an array in an &quot;unsafe&quot; way. Skips solidity &quot;index-out-of-range&quot; check.</span>
 432 |     | <span class='neutral'>     *</span>
 433 |     | <span class='neutral'>     * WARNING: Only use if you are certain `pos` is lower than the array length.</span>
 434 |     | <span class='neutral'>     */</span>
 435 |     | <span class='neutral'>    function unsafeAccess(string[] storage arr, uint256 pos) internal pure returns (StorageSlot.StringSlot storage) {</span>
 436 |     | <span class='neutral'>        bytes32 slot;</span>
 437 |     | <span class='neutral'>        assembly (&quot;memory-safe&quot;) {</span>
 438 |     | <span class='neutral'>            slot := arr.slot</span>
 439 |     | <span class='neutral'>        }</span>
 440 |     | <span class='neutral'>        return slot.deriveArray().offset(pos).getStringSlot();</span>
 441 |     | <span class='neutral'>    }</span>
 442 |     | <span class='neutral'></span>
 443 |     | <span class='neutral'>    /**</span>
 444 |     | <span class='neutral'>     * @dev Access an array in an &quot;unsafe&quot; way. Skips solidity &quot;index-out-of-range&quot; check.</span>
 445 |     | <span class='neutral'>     *</span>
 446 |     | <span class='neutral'>     * WARNING: Only use if you are certain `pos` is lower than the array length.</span>
 447 |     | <span class='neutral'>     */</span>
 448 |     | <span class='neutral'>    function unsafeMemoryAccess(address[] memory arr, uint256 pos) internal pure returns (address res) {</span>
 449 |     | <span class='neutral'>        assembly {</span>
 450 |     | <span class='neutral'>            res := mload(add(add(arr, 0x20), mul(pos, 0x20)))</span>
 451 |     | <span class='neutral'>        }</span>
 452 |     | <span class='neutral'>    }</span>
 453 |     | <span class='neutral'></span>
 454 |     | <span class='neutral'>    /**</span>
 455 |     | <span class='neutral'>     * @dev Access an array in an &quot;unsafe&quot; way. Skips solidity &quot;index-out-of-range&quot; check.</span>
 456 |     | <span class='neutral'>     *</span>
 457 |     | <span class='neutral'>     * WARNING: Only use if you are certain `pos` is lower than the array length.</span>
 458 |     | <span class='neutral'>     */</span>
 459 |     | <span class='neutral'>    function unsafeMemoryAccess(bytes32[] memory arr, uint256 pos) internal pure returns (bytes32 res) {</span>
 460 |     | <span class='neutral'>        assembly {</span>
 461 |     | <span class='neutral'>            res := mload(add(add(arr, 0x20), mul(pos, 0x20)))</span>
 462 |     | <span class='neutral'>        }</span>
 463 |     | <span class='neutral'>    }</span>
 464 |     | <span class='neutral'></span>
 465 |     | <span class='neutral'>    /**</span>
 466 |     | <span class='neutral'>     * @dev Access an array in an &quot;unsafe&quot; way. Skips solidity &quot;index-out-of-range&quot; check.</span>
 467 |     | <span class='neutral'>     *</span>
 468 |     | <span class='neutral'>     * WARNING: Only use if you are certain `pos` is lower than the array length.</span>
 469 |     | <span class='neutral'>     */</span>
 470 |     | <span class='neutral'>    function unsafeMemoryAccess(uint256[] memory arr, uint256 pos) internal pure returns (uint256 res) {</span>
 471 |     | <span class='neutral'>        assembly {</span>
 472 |     | <span class='neutral'>            res := mload(add(add(arr, 0x20), mul(pos, 0x20)))</span>
 473 |     | <span class='neutral'>        }</span>
 474 |     | <span class='neutral'>    }</span>
 475 |     | <span class='neutral'></span>
 476 |     | <span class='neutral'>    /**</span>
 477 |     | <span class='neutral'>     * @dev Access an array in an &quot;unsafe&quot; way. Skips solidity &quot;index-out-of-range&quot; check.</span>
 478 |     | <span class='neutral'>     *</span>
 479 |     | <span class='neutral'>     * WARNING: Only use if you are certain `pos` is lower than the array length.</span>
 480 |     | <span class='neutral'>     */</span>
 481 |     | <span class='neutral'>    function unsafeMemoryAccess(bytes[] memory arr, uint256 pos) internal pure returns (bytes memory res) {</span>
 482 |     | <span class='neutral'>        assembly {</span>
 483 |     | <span class='neutral'>            res := mload(add(add(arr, 0x20), mul(pos, 0x20)))</span>
 484 |     | <span class='neutral'>        }</span>
 485 |     | <span class='neutral'>    }</span>
 486 |     | <span class='neutral'></span>
 487 |     | <span class='neutral'>    /**</span>
 488 |     | <span class='neutral'>     * @dev Access an array in an &quot;unsafe&quot; way. Skips solidity &quot;index-out-of-range&quot; check.</span>
 489 |     | <span class='neutral'>     *</span>
 490 |     | <span class='neutral'>     * WARNING: Only use if you are certain `pos` is lower than the array length.</span>
 491 |     | <span class='neutral'>     */</span>
 492 |     | <span class='neutral'>    function unsafeMemoryAccess(string[] memory arr, uint256 pos) internal pure returns (string memory res) {</span>
 493 |     | <span class='neutral'>        assembly {</span>
 494 |     | <span class='neutral'>            res := mload(add(add(arr, 0x20), mul(pos, 0x20)))</span>
 495 |     | <span class='neutral'>        }</span>
 496 |     | <span class='neutral'>    }</span>
 497 |     | <span class='neutral'></span>
 498 |     | <span class='neutral'>    /**</span>
 499 |     | <span class='neutral'>     * @dev Helper to set the length of a dynamic array. Directly writing to `.length` is forbidden.</span>
 500 |     | <span class='neutral'>     *</span>
 501 |     | <span class='neutral'>     * WARNING: this does not clear elements if length is reduced, of initialize elements if length is increased.</span>
 502 |     | <span class='neutral'>     */</span>
 503 |     | <span class='neutral'>    function unsafeSetLength(address[] storage array, uint256 len) internal {</span>
 504 |     | <span class='neutral'>        assembly (&quot;memory-safe&quot;) {</span>
 505 |     | <span class='neutral'>            sstore(array.slot, len)</span>
 506 |     | <span class='neutral'>        }</span>
 507 |     | <span class='neutral'>    }</span>
 508 |     | <span class='neutral'></span>
 509 |     | <span class='neutral'>    /**</span>
 510 |     | <span class='neutral'>     * @dev Helper to set the length of a dynamic array. Directly writing to `.length` is forbidden.</span>
 511 |     | <span class='neutral'>     *</span>
 512 |     | <span class='neutral'>     * WARNING: this does not clear elements if length is reduced, of initialize elements if length is increased.</span>
 513 |     | <span class='neutral'>     */</span>
 514 |     | <span class='neutral'>    function unsafeSetLength(bytes32[] storage array, uint256 len) internal {</span>
 515 |     | <span class='neutral'>        assembly (&quot;memory-safe&quot;) {</span>
 516 |     | <span class='neutral'>            sstore(array.slot, len)</span>
 517 |     | <span class='neutral'>        }</span>
 518 |     | <span class='neutral'>    }</span>
 519 |     | <span class='neutral'></span>
 520 |     | <span class='neutral'>    /**</span>
 521 |     | <span class='neutral'>     * @dev Helper to set the length of a dynamic array. Directly writing to `.length` is forbidden.</span>
 522 |     | <span class='neutral'>     *</span>
 523 |     | <span class='neutral'>     * WARNING: this does not clear elements if length is reduced, of initialize elements if length is increased.</span>
 524 |     | <span class='neutral'>     */</span>
 525 |     | <span class='neutral'>    function unsafeSetLength(uint256[] storage array, uint256 len) internal {</span>
 526 |     | <span class='neutral'>        assembly (&quot;memory-safe&quot;) {</span>
 527 |     | <span class='neutral'>            sstore(array.slot, len)</span>
 528 |     | <span class='neutral'>        }</span>
 529 |     | <span class='neutral'>    }</span>
 530 |     | <span class='neutral'></span>
 531 |     | <span class='neutral'>    /**</span>
 532 |     | <span class='neutral'>     * @dev Helper to set the length of a dynamic array. Directly writing to `.length` is forbidden.</span>
 533 |     | <span class='neutral'>     *</span>
 534 |     | <span class='neutral'>     * WARNING: this does not clear elements if length is reduced, of initialize elements if length is increased.</span>
 535 |     | <span class='neutral'>     */</span>
 536 |     | <span class='neutral'>    function unsafeSetLength(bytes[] storage array, uint256 len) internal {</span>
 537 |     | <span class='neutral'>        assembly (&quot;memory-safe&quot;) {</span>
 538 |     | <span class='neutral'>            sstore(array.slot, len)</span>
 539 |     | <span class='neutral'>        }</span>
 540 |     | <span class='neutral'>    }</span>
 541 |     | <span class='neutral'></span>
 542 |     | <span class='neutral'>    /**</span>
 543 |     | <span class='neutral'>     * @dev Helper to set the length of a dynamic array. Directly writing to `.length` is forbidden.</span>
 544 |     | <span class='neutral'>     *</span>
 545 |     | <span class='neutral'>     * WARNING: this does not clear elements if length is reduced, of initialize elements if length is increased.</span>
 546 |     | <span class='neutral'>     */</span>
 547 |     | <span class='neutral'>    function unsafeSetLength(string[] storage array, uint256 len) internal {</span>
 548 |     | <span class='neutral'>        assembly (&quot;memory-safe&quot;) {</span>
 549 |     | <span class='neutral'>            sstore(array.slot, len)</span>
 550 |     | <span class='neutral'>        }</span>
 551 |     | <span class='neutral'>    }</span>
 552 |     | <span class='neutral'>}</span>
 553 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/phantom/Documents/azemora/azemora-contracts/lib/openzeppelin-contracts/contracts/utils/Bytes.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'>// OpenZeppelin Contracts (last updated v5.2.0) (utils/Bytes.sol)</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>pragma solidity ^0.8.24;</span>
   5 |     | <span class='neutral'></span>
   6 |     | <span class='neutral'>import {Math} from &quot;./math/Math.sol&quot;;</span>
   7 |     | <span class='neutral'></span>
   8 |     | <span class='neutral'>/**</span>
   9 |     | <span class='neutral'> * @dev Bytes operations.</span>
  10 |     | <span class='neutral'> */</span>
  11 |     | <span class='neutral'>library Bytes {</span>
  12 |     | <span class='neutral'>    /**</span>
  13 |     | <span class='neutral'>     * @dev Forward search for `s` in `buffer`</span>
  14 |     | <span class='neutral'>     * * If `s` is present in the buffer, returns the index of the first instance</span>
  15 |     | <span class='neutral'>     * * If `s` is not present in the buffer, returns type(uint256).max</span>
  16 |     | <span class='neutral'>     *</span>
  17 |     | <span class='neutral'>     * NOTE: replicates the behavior of https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/indexOf[Javascript&#39;s `Array.indexOf`]</span>
  18 |     | <span class='neutral'>     */</span>
  19 |     | <span class='neutral'>    function indexOf(bytes memory buffer, bytes1 s) internal pure returns (uint256) {</span>
  20 |     | <span class='neutral'>        return indexOf(buffer, s, 0);</span>
  21 |     | <span class='neutral'>    }</span>
  22 |     | <span class='neutral'></span>
  23 |     | <span class='neutral'>    /**</span>
  24 |     | <span class='neutral'>     * @dev Forward search for `s` in `buffer` starting at position `pos`</span>
  25 |     | <span class='neutral'>     * * If `s` is present in the buffer (at or after `pos`), returns the index of the next instance</span>
  26 |     | <span class='neutral'>     * * If `s` is not present in the buffer (at or after `pos`), returns type(uint256).max</span>
  27 |     | <span class='neutral'>     *</span>
  28 |     | <span class='neutral'>     * NOTE: replicates the behavior of https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/indexOf[Javascript&#39;s `Array.indexOf`]</span>
  29 |     | <span class='neutral'>     */</span>
  30 |     | <span class='neutral'>    function indexOf(bytes memory buffer, bytes1 s, uint256 pos) internal pure returns (uint256) {</span>
  31 |     | <span class='neutral'>        uint256 length = buffer.length;</span>
  32 |     | <span class='neutral'>        for (uint256 i = pos; i &lt; length; ++i) {</span>
  33 |     | <span class='neutral'>            if (bytes1(_unsafeReadBytesOffset(buffer, i)) == s) {</span>
  34 |     | <span class='neutral'>                return i;</span>
  35 |     | <span class='neutral'>            }</span>
  36 |     | <span class='neutral'>        }</span>
  37 |     | <span class='neutral'>        return type(uint256).max;</span>
  38 |     | <span class='neutral'>    }</span>
  39 |     | <span class='neutral'></span>
  40 |     | <span class='neutral'>    /**</span>
  41 |     | <span class='neutral'>     * @dev Backward search for `s` in `buffer`</span>
  42 |     | <span class='neutral'>     * * If `s` is present in the buffer, returns the index of the last instance</span>
  43 |     | <span class='neutral'>     * * If `s` is not present in the buffer, returns type(uint256).max</span>
  44 |     | <span class='neutral'>     *</span>
  45 |     | <span class='neutral'>     * NOTE: replicates the behavior of https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/lastIndexOf[Javascript&#39;s `Array.lastIndexOf`]</span>
  46 |     | <span class='neutral'>     */</span>
  47 |     | <span class='neutral'>    function lastIndexOf(bytes memory buffer, bytes1 s) internal pure returns (uint256) {</span>
  48 |     | <span class='neutral'>        return lastIndexOf(buffer, s, type(uint256).max);</span>
  49 |     | <span class='neutral'>    }</span>
  50 |     | <span class='neutral'></span>
  51 |     | <span class='neutral'>    /**</span>
  52 |     | <span class='neutral'>     * @dev Backward search for `s` in `buffer` starting at position `pos`</span>
  53 |     | <span class='neutral'>     * * If `s` is present in the buffer (at or before `pos`), returns the index of the previous instance</span>
  54 |     | <span class='neutral'>     * * If `s` is not present in the buffer (at or before `pos`), returns type(uint256).max</span>
  55 |     | <span class='neutral'>     *</span>
  56 |     | <span class='neutral'>     * NOTE: replicates the behavior of https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/lastIndexOf[Javascript&#39;s `Array.lastIndexOf`]</span>
  57 |     | <span class='neutral'>     */</span>
  58 |     | <span class='neutral'>    function lastIndexOf(bytes memory buffer, bytes1 s, uint256 pos) internal pure returns (uint256) {</span>
  59 |     | <span class='neutral'>        unchecked {</span>
  60 |     | <span class='neutral'>            uint256 length = buffer.length;</span>
  61 |     | <span class='neutral'>            // NOTE here we cannot do `i = Math.min(pos + 1, length)` because `pos + 1` could overflow</span>
  62 |     | <span class='neutral'>            for (uint256 i = Math.min(pos, length - 1) + 1; i &gt; 0; --i) {</span>
  63 |     | <span class='neutral'>                if (bytes1(_unsafeReadBytesOffset(buffer, i - 1)) == s) {</span>
  64 |     | <span class='neutral'>                    return i - 1;</span>
  65 |     | <span class='neutral'>                }</span>
  66 |     | <span class='neutral'>            }</span>
  67 |     | <span class='neutral'>            return type(uint256).max;</span>
  68 |     | <span class='neutral'>        }</span>
  69 |     | <span class='neutral'>    }</span>
  70 |     | <span class='neutral'></span>
  71 |     | <span class='neutral'>    /**</span>
  72 |     | <span class='neutral'>     * @dev Copies the content of `buffer`, from `start` (included) to the end of `buffer` into a new bytes object in</span>
  73 |     | <span class='neutral'>     * memory.</span>
  74 |     | <span class='neutral'>     *</span>
  75 |     | <span class='neutral'>     * NOTE: replicates the behavior of https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/slice[Javascript&#39;s `Array.slice`]</span>
  76 |     | <span class='neutral'>     */</span>
  77 |     | <span class='neutral'>    function slice(bytes memory buffer, uint256 start) internal pure returns (bytes memory) {</span>
  78 |     | <span class='neutral'>        return slice(buffer, start, buffer.length);</span>
  79 |     | <span class='neutral'>    }</span>
  80 |     | <span class='neutral'></span>
  81 |     | <span class='neutral'>    /**</span>
  82 |     | <span class='neutral'>     * @dev Copies the content of `buffer`, from `start` (included) to `end` (excluded) into a new bytes object in</span>
  83 |     | <span class='neutral'>     * memory.</span>
  84 |     | <span class='neutral'>     *</span>
  85 |     | <span class='neutral'>     * NOTE: replicates the behavior of https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/slice[Javascript&#39;s `Array.slice`]</span>
  86 |     | <span class='neutral'>     */</span>
  87 |     | <span class='neutral'>    function slice(bytes memory buffer, uint256 start, uint256 end) internal pure returns (bytes memory) {</span>
  88 |     | <span class='neutral'>        // sanitize</span>
  89 |     | <span class='neutral'>        uint256 length = buffer.length;</span>
  90 |     | <span class='neutral'>        end = Math.min(end, length);</span>
  91 |     | <span class='neutral'>        start = Math.min(start, end);</span>
  92 |     | <span class='neutral'></span>
  93 |     | <span class='neutral'>        // allocate and copy</span>
  94 |     | <span class='neutral'>        bytes memory result = new bytes(end - start);</span>
  95 |     | <span class='neutral'>        assembly (&quot;memory-safe&quot;) {</span>
  96 |     | <span class='neutral'>            mcopy(add(result, 0x20), add(add(buffer, 0x20), start), sub(end, start))</span>
  97 |     | <span class='neutral'>        }</span>
  98 |     | <span class='neutral'></span>
  99 |     | <span class='neutral'>        return result;</span>
 100 |     | <span class='neutral'>    }</span>
 101 |     | <span class='neutral'></span>
 102 |     | <span class='neutral'>    /**</span>
 103 |     | <span class='neutral'>     * @dev Reads a bytes32 from a bytes array without bounds checking.</span>
 104 |     | <span class='neutral'>     *</span>
 105 |     | <span class='neutral'>     * NOTE: making this function internal would mean it could be used with memory unsafe offset, and marking the</span>
 106 |     | <span class='neutral'>     * assembly block as such would prevent some optimizations.</span>
 107 |     | <span class='neutral'>     */</span>
 108 |     | <span class='neutral'>    function _unsafeReadBytesOffset(bytes memory buffer, uint256 offset) private pure returns (bytes32 value) {</span>
 109 |     | <span class='neutral'>        // This is not memory safe in the general case, but all calls to this private function are within bounds.</span>
 110 |     | <span class='neutral'>        assembly (&quot;memory-safe&quot;) {</span>
 111 |     | <span class='neutral'>            value := mload(add(add(buffer, 0x20), offset))</span>
 112 |     | <span class='neutral'>        }</span>
 113 |     | <span class='neutral'>    }</span>
 114 |     | <span class='neutral'>}</span>
 115 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/phantom/Documents/azemora/azemora-contracts/lib/openzeppelin-contracts/contracts/utils/Comparators.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>// OpenZeppelin Contracts (last updated v5.1.0) (utils/Comparators.sol)</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>pragma solidity ^0.8.20;</span>
  5 |     | <span class='neutral'></span>
  6 |     | <span class='neutral'>/**</span>
  7 |     | <span class='neutral'> * @dev Provides a set of functions to compare values.</span>
  8 |     | <span class='neutral'> *</span>
  9 |     | <span class='neutral'> * _Available since v5.1._</span>
 10 |     | <span class='neutral'> */</span>
 11 |     | <span class='neutral'>library Comparators {</span>
 12 |     | <span class='neutral'>    function lt(uint256 a, uint256 b) internal pure returns (bool) {</span>
 13 |     | <span class='neutral'>        return a &lt; b;</span>
 14 |     | <span class='neutral'>    }</span>
 15 |     | <span class='neutral'></span>
 16 |     | <span class='neutral'>    function gt(uint256 a, uint256 b) internal pure returns (bool) {</span>
 17 |     | <span class='neutral'>        return a &gt; b;</span>
 18 |     | <span class='neutral'>    }</span>
 19 |     | <span class='neutral'>}</span>
 20 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/phantom/Documents/azemora/azemora-contracts/lib/openzeppelin-contracts/contracts/utils/Context.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>pragma solidity ^0.8.20;</span>
  5 |     | <span class='neutral'></span>
  6 |     | <span class='neutral'>/**</span>
  7 |     | <span class='neutral'> * @dev Provides information about the current execution context, including the</span>
  8 |     | <span class='neutral'> * sender of the transaction and its data. While these are generally available</span>
  9 |     | <span class='neutral'> * via msg.sender and msg.data, they should not be accessed in such a direct</span>
 10 |     | <span class='neutral'> * manner, since when dealing with meta-transactions the account sending and</span>
 11 |     | <span class='neutral'> * paying for execution may not be the actual sender (as far as an application</span>
 12 |     | <span class='neutral'> * is concerned).</span>
 13 |     | <span class='neutral'> *</span>
 14 |     | <span class='neutral'> * This contract is only required for intermediate, library-like contracts.</span>
 15 |     | <span class='neutral'> */</span>
 16 |     | <span class='neutral'>abstract contract Context {</span>
 17 |     | <span class='neutral'>    function _msgSender() internal view virtual returns (address) {</span>
 18 |     | <span class='neutral'>        return msg.sender;</span>
 19 |     | <span class='neutral'>    }</span>
 20 |     | <span class='neutral'></span>
 21 |     | <span class='neutral'>    function _msgData() internal view virtual returns (bytes calldata) {</span>
 22 |     | <span class='neutral'>        return msg.data;</span>
 23 |     | <span class='neutral'>    }</span>
 24 |     | <span class='neutral'></span>
 25 |     | <span class='neutral'>    function _contextSuffixLength() internal view virtual returns (uint256) {</span>
 26 |     | <span class='neutral'>        return 0;</span>
 27 |     | <span class='neutral'>    }</span>
 28 |     | <span class='neutral'>}</span>
 29 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/phantom/Documents/azemora/azemora-contracts/lib/openzeppelin-contracts/contracts/utils/Errors.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>// OpenZeppelin Contracts (last updated v5.1.0) (utils/Errors.sol)</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>pragma solidity ^0.8.20;</span>
  5 |     | <span class='neutral'></span>
  6 |     | <span class='neutral'>/**</span>
  7 |     | <span class='neutral'> * @dev Collection of common custom errors used in multiple contracts</span>
  8 |     | <span class='neutral'> *</span>
  9 |     | <span class='neutral'> * IMPORTANT: Backwards compatibility is not guaranteed in future versions of the library.</span>
 10 |     | <span class='neutral'> * It is recommended to avoid relying on the error API for critical functionality.</span>
 11 |     | <span class='neutral'> *</span>
 12 |     | <span class='neutral'> * _Available since v5.1._</span>
 13 |     | <span class='neutral'> */</span>
 14 |     | <span class='neutral'>library Errors {</span>
 15 |     | <span class='neutral'>    /**</span>
 16 |     | <span class='neutral'>     * @dev The ETH balance of the account is not enough to perform the operation.</span>
 17 |     | <span class='neutral'>     */</span>
 18 |     | <span class='neutral'>    error InsufficientBalance(uint256 balance, uint256 needed);</span>
 19 |     | <span class='neutral'></span>
 20 |     | <span class='neutral'>    /**</span>
 21 |     | <span class='neutral'>     * @dev A call to an address target failed. The target may have reverted.</span>
 22 |     | <span class='neutral'>     */</span>
 23 |     | <span class='neutral'>    error FailedCall();</span>
 24 |     | <span class='neutral'></span>
 25 |     | <span class='neutral'>    /**</span>
 26 |     | <span class='neutral'>     * @dev The deployment failed.</span>
 27 |     | <span class='neutral'>     */</span>
 28 |     | <span class='neutral'>    error FailedDeployment();</span>
 29 |     | <span class='neutral'></span>
 30 |     | <span class='neutral'>    /**</span>
 31 |     | <span class='neutral'>     * @dev A necessary precompile is missing.</span>
 32 |     | <span class='neutral'>     */</span>
 33 |     | <span class='neutral'>    error MissingPrecompile(address);</span>
 34 |     | <span class='neutral'>}</span>
 35 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/phantom/Documents/azemora/azemora-contracts/lib/openzeppelin-contracts/contracts/utils/Panic.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>// OpenZeppelin Contracts (last updated v5.1.0) (utils/Panic.sol)</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>pragma solidity ^0.8.20;</span>
  5 |     | <span class='neutral'></span>
  6 |     | <span class='neutral'>/**</span>
  7 |     | <span class='neutral'> * @dev Helper library for emitting standardized panic codes.</span>
  8 |     | <span class='neutral'> *</span>
  9 |     | <span class='neutral'> * ```solidity</span>
 10 |     | <span class='neutral'> * contract Example {</span>
 11 |     | <span class='neutral'> *      using Panic for uint256;</span>
 12 |     | <span class='neutral'> *</span>
 13 |     | <span class='neutral'> *      // Use any of the declared internal constants</span>
 14 |     | <span class='neutral'> *      function foo() { Panic.GENERIC.panic(); }</span>
 15 |     | <span class='neutral'> *</span>
 16 |     | <span class='neutral'> *      // Alternatively</span>
 17 |     | <span class='neutral'> *      function foo() { Panic.panic(Panic.GENERIC); }</span>
 18 |     | <span class='neutral'> * }</span>
 19 |     | <span class='neutral'> * ```</span>
 20 |     | <span class='neutral'> *</span>
 21 |     | <span class='neutral'> * Follows the list from https://github.com/ethereum/solidity/blob/v0.8.24/libsolutil/ErrorCodes.h[libsolutil].</span>
 22 |     | <span class='neutral'> *</span>
 23 |     | <span class='neutral'> * _Available since v5.1._</span>
 24 |     | <span class='neutral'> */</span>
 25 |     | <span class='neutral'>// slither-disable-next-line unused-state</span>
 26 |     | <span class='neutral'>library Panic {</span>
 27 |     | <span class='neutral'>    /// @dev generic / unspecified error</span>
 28 |     | <span class='neutral'>    uint256 internal constant GENERIC = 0x00;</span>
 29 |     | <span class='neutral'>    /// @dev used by the assert() builtin</span>
 30 |     | <span class='neutral'>    uint256 internal constant ASSERT = 0x01;</span>
 31 |     | <span class='neutral'>    /// @dev arithmetic underflow or overflow</span>
 32 |     | <span class='neutral'>    uint256 internal constant UNDER_OVERFLOW = 0x11;</span>
 33 |     | <span class='neutral'>    /// @dev division or modulo by zero</span>
 34 |     | <span class='neutral'>    uint256 internal constant DIVISION_BY_ZERO = 0x12;</span>
 35 |     | <span class='neutral'>    /// @dev enum conversion error</span>
 36 |     | <span class='neutral'>    uint256 internal constant ENUM_CONVERSION_ERROR = 0x21;</span>
 37 |     | <span class='neutral'>    /// @dev invalid encoding in storage</span>
 38 |     | <span class='neutral'>    uint256 internal constant STORAGE_ENCODING_ERROR = 0x22;</span>
 39 |     | <span class='neutral'>    /// @dev empty array pop</span>
 40 |     | <span class='neutral'>    uint256 internal constant EMPTY_ARRAY_POP = 0x31;</span>
 41 |     | <span class='neutral'>    /// @dev array out of bounds access</span>
 42 |     | <span class='neutral'>    uint256 internal constant ARRAY_OUT_OF_BOUNDS = 0x32;</span>
 43 |     | <span class='neutral'>    /// @dev resource error (too large allocation or too large array)</span>
 44 |     | <span class='neutral'>    uint256 internal constant RESOURCE_ERROR = 0x41;</span>
 45 |     | <span class='neutral'>    /// @dev calling invalid internal function</span>
 46 |     | <span class='neutral'>    uint256 internal constant INVALID_INTERNAL_FUNCTION = 0x51;</span>
 47 |     | <span class='neutral'></span>
 48 |     | <span class='neutral'>    /// @dev Reverts with a panic code. Recommended to use with</span>
 49 |     | <span class='neutral'>    /// the internal constants with predefined codes.</span>
 50 |     | <span class='neutral'>    function panic(uint256 code) internal pure {</span>
 51 |     | <span class='neutral'>        assembly (&quot;memory-safe&quot;) {</span>
 52 |     | <span class='neutral'>            mstore(0x00, 0x4e487b71)</span>
 53 |     | <span class='neutral'>            mstore(0x20, code)</span>
 54 |     | <span class='neutral'>            revert(0x1c, 0x24)</span>
 55 |     | <span class='neutral'>        }</span>
 56 |     | <span class='neutral'>    }</span>
 57 |     | <span class='neutral'>}</span>
 58 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/phantom/Documents/azemora/azemora-contracts/lib/openzeppelin-contracts/contracts/utils/SlotDerivation.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'>// OpenZeppelin Contracts (last updated v5.3.0) (utils/SlotDerivation.sol)</span>
   3 |     | <span class='neutral'>// This file was procedurally generated from scripts/generate/templates/SlotDerivation.js.</span>
   4 |     | <span class='neutral'></span>
   5 |     | <span class='neutral'>pragma solidity ^0.8.20;</span>
   6 |     | <span class='neutral'></span>
   7 |     | <span class='neutral'>/**</span>
   8 |     | <span class='neutral'> * @dev Library for computing storage (and transient storage) locations from namespaces and deriving slots</span>
   9 |     | <span class='neutral'> * corresponding to standard patterns. The derivation method for array and mapping matches the storage layout used by</span>
  10 |     | <span class='neutral'> * the solidity language / compiler.</span>
  11 |     | <span class='neutral'> *</span>
  12 |     | <span class='neutral'> * See https://docs.soliditylang.org/en/v0.8.20/internals/layout_in_storage.html#mappings-and-dynamic-arrays[Solidity docs for mappings and dynamic arrays.].</span>
  13 |     | <span class='neutral'> *</span>
  14 |     | <span class='neutral'> * Example usage:</span>
  15 |     | <span class='neutral'> * ```solidity</span>
  16 |     | <span class='neutral'> * contract Example {</span>
  17 |     | <span class='neutral'> *     // Add the library methods</span>
  18 |     | <span class='neutral'> *     using StorageSlot for bytes32;</span>
  19 |     | <span class='neutral'> *     using SlotDerivation for bytes32;</span>
  20 |     | <span class='neutral'> *</span>
  21 |     | <span class='neutral'> *     // Declare a namespace</span>
  22 |     | <span class='neutral'> *     string private constant _NAMESPACE = &quot;&lt;namespace&gt;&quot;; // eg. OpenZeppelin.Slot</span>
  23 |     | <span class='neutral'> *</span>
  24 |     | <span class='neutral'> *     function setValueInNamespace(uint256 key, address newValue) internal {</span>
  25 |     | <span class='neutral'> *         _NAMESPACE.erc7201Slot().deriveMapping(key).getAddressSlot().value = newValue;</span>
  26 |     | <span class='neutral'> *     }</span>
  27 |     | <span class='neutral'> *</span>
  28 |     | <span class='neutral'> *     function getValueInNamespace(uint256 key) internal view returns (address) {</span>
  29 |     | <span class='neutral'> *         return _NAMESPACE.erc7201Slot().deriveMapping(key).getAddressSlot().value;</span>
  30 |     | <span class='neutral'> *     }</span>
  31 |     | <span class='neutral'> * }</span>
  32 |     | <span class='neutral'> * ```</span>
  33 |     | <span class='neutral'> *</span>
  34 |     | <span class='neutral'> * TIP: Consider using this library along with {StorageSlot}.</span>
  35 |     | <span class='neutral'> *</span>
  36 |     | <span class='neutral'> * NOTE: This library provides a way to manipulate storage locations in a non-standard way. Tooling for checking</span>
  37 |     | <span class='neutral'> * upgrade safety will ignore the slots accessed through this library.</span>
  38 |     | <span class='neutral'> *</span>
  39 |     | <span class='neutral'> * _Available since v5.1._</span>
  40 |     | <span class='neutral'> */</span>
  41 |     | <span class='neutral'>library SlotDerivation {</span>
  42 |     | <span class='neutral'>    /**</span>
  43 |     | <span class='neutral'>     * @dev Derive an ERC-7201 slot from a string (namespace).</span>
  44 |     | <span class='neutral'>     */</span>
  45 |     | <span class='neutral'>    function erc7201Slot(string memory namespace) internal pure returns (bytes32 slot) {</span>
  46 |     | <span class='neutral'>        assembly (&quot;memory-safe&quot;) {</span>
  47 |     | <span class='neutral'>            mstore(0x00, sub(keccak256(add(namespace, 0x20), mload(namespace)), 1))</span>
  48 |     | <span class='neutral'>            slot := and(keccak256(0x00, 0x20), not(0xff))</span>
  49 |     | <span class='neutral'>        }</span>
  50 |     | <span class='neutral'>    }</span>
  51 |     | <span class='neutral'></span>
  52 |     | <span class='neutral'>    /**</span>
  53 |     | <span class='neutral'>     * @dev Add an offset to a slot to get the n-th element of a structure or an array.</span>
  54 |     | <span class='neutral'>     */</span>
  55 |     | <span class='neutral'>    function offset(bytes32 slot, uint256 pos) internal pure returns (bytes32 result) {</span>
  56 |     | <span class='neutral'>        unchecked {</span>
  57 |     | <span class='neutral'>            return bytes32(uint256(slot) + pos);</span>
  58 |     | <span class='neutral'>        }</span>
  59 |     | <span class='neutral'>    }</span>
  60 |     | <span class='neutral'></span>
  61 |     | <span class='neutral'>    /**</span>
  62 |     | <span class='neutral'>     * @dev Derive the location of the first element in an array from the slot where the length is stored.</span>
  63 |     | <span class='neutral'>     */</span>
  64 |     | <span class='neutral'>    function deriveArray(bytes32 slot) internal pure returns (bytes32 result) {</span>
  65 |     | <span class='neutral'>        assembly (&quot;memory-safe&quot;) {</span>
  66 |     | <span class='neutral'>            mstore(0x00, slot)</span>
  67 |     | <span class='neutral'>            result := keccak256(0x00, 0x20)</span>
  68 |     | <span class='neutral'>        }</span>
  69 |     | <span class='neutral'>    }</span>
  70 |     | <span class='neutral'></span>
  71 |     | <span class='neutral'>    /**</span>
  72 |     | <span class='neutral'>     * @dev Derive the location of a mapping element from the key.</span>
  73 |     | <span class='neutral'>     */</span>
  74 |     | <span class='neutral'>    function deriveMapping(bytes32 slot, address key) internal pure returns (bytes32 result) {</span>
  75 |     | <span class='neutral'>        assembly (&quot;memory-safe&quot;) {</span>
  76 |     | <span class='neutral'>            mstore(0x00, and(key, shr(96, not(0))))</span>
  77 |     | <span class='neutral'>            mstore(0x20, slot)</span>
  78 |     | <span class='neutral'>            result := keccak256(0x00, 0x40)</span>
  79 |     | <span class='neutral'>        }</span>
  80 |     | <span class='neutral'>    }</span>
  81 |     | <span class='neutral'></span>
  82 |     | <span class='neutral'>    /**</span>
  83 |     | <span class='neutral'>     * @dev Derive the location of a mapping element from the key.</span>
  84 |     | <span class='neutral'>     */</span>
  85 |     | <span class='neutral'>    function deriveMapping(bytes32 slot, bool key) internal pure returns (bytes32 result) {</span>
  86 |     | <span class='neutral'>        assembly (&quot;memory-safe&quot;) {</span>
  87 |     | <span class='neutral'>            mstore(0x00, iszero(iszero(key)))</span>
  88 |     | <span class='neutral'>            mstore(0x20, slot)</span>
  89 |     | <span class='neutral'>            result := keccak256(0x00, 0x40)</span>
  90 |     | <span class='neutral'>        }</span>
  91 |     | <span class='neutral'>    }</span>
  92 |     | <span class='neutral'></span>
  93 |     | <span class='neutral'>    /**</span>
  94 |     | <span class='neutral'>     * @dev Derive the location of a mapping element from the key.</span>
  95 |     | <span class='neutral'>     */</span>
  96 |     | <span class='neutral'>    function deriveMapping(bytes32 slot, bytes32 key) internal pure returns (bytes32 result) {</span>
  97 |     | <span class='neutral'>        assembly (&quot;memory-safe&quot;) {</span>
  98 |     | <span class='neutral'>            mstore(0x00, key)</span>
  99 |     | <span class='neutral'>            mstore(0x20, slot)</span>
 100 |     | <span class='neutral'>            result := keccak256(0x00, 0x40)</span>
 101 |     | <span class='neutral'>        }</span>
 102 |     | <span class='neutral'>    }</span>
 103 |     | <span class='neutral'></span>
 104 |     | <span class='neutral'>    /**</span>
 105 |     | <span class='neutral'>     * @dev Derive the location of a mapping element from the key.</span>
 106 |     | <span class='neutral'>     */</span>
 107 |     | <span class='neutral'>    function deriveMapping(bytes32 slot, uint256 key) internal pure returns (bytes32 result) {</span>
 108 |     | <span class='neutral'>        assembly (&quot;memory-safe&quot;) {</span>
 109 |     | <span class='neutral'>            mstore(0x00, key)</span>
 110 |     | <span class='neutral'>            mstore(0x20, slot)</span>
 111 |     | <span class='neutral'>            result := keccak256(0x00, 0x40)</span>
 112 |     | <span class='neutral'>        }</span>
 113 |     | <span class='neutral'>    }</span>
 114 |     | <span class='neutral'></span>
 115 |     | <span class='neutral'>    /**</span>
 116 |     | <span class='neutral'>     * @dev Derive the location of a mapping element from the key.</span>
 117 |     | <span class='neutral'>     */</span>
 118 |     | <span class='neutral'>    function deriveMapping(bytes32 slot, int256 key) internal pure returns (bytes32 result) {</span>
 119 |     | <span class='neutral'>        assembly (&quot;memory-safe&quot;) {</span>
 120 |     | <span class='neutral'>            mstore(0x00, key)</span>
 121 |     | <span class='neutral'>            mstore(0x20, slot)</span>
 122 |     | <span class='neutral'>            result := keccak256(0x00, 0x40)</span>
 123 |     | <span class='neutral'>        }</span>
 124 |     | <span class='neutral'>    }</span>
 125 |     | <span class='neutral'></span>
 126 |     | <span class='neutral'>    /**</span>
 127 |     | <span class='neutral'>     * @dev Derive the location of a mapping element from the key.</span>
 128 |     | <span class='neutral'>     */</span>
 129 |     | <span class='neutral'>    function deriveMapping(bytes32 slot, string memory key) internal pure returns (bytes32 result) {</span>
 130 |     | <span class='neutral'>        assembly (&quot;memory-safe&quot;) {</span>
 131 |     | <span class='neutral'>            let length := mload(key)</span>
 132 |     | <span class='neutral'>            let begin := add(key, 0x20)</span>
 133 |     | <span class='neutral'>            let end := add(begin, length)</span>
 134 |     | <span class='neutral'>            let cache := mload(end)</span>
 135 |     | <span class='neutral'>            mstore(end, slot)</span>
 136 |     | <span class='neutral'>            result := keccak256(begin, add(length, 0x20))</span>
 137 |     | <span class='neutral'>            mstore(end, cache)</span>
 138 |     | <span class='neutral'>        }</span>
 139 |     | <span class='neutral'>    }</span>
 140 |     | <span class='neutral'></span>
 141 |     | <span class='neutral'>    /**</span>
 142 |     | <span class='neutral'>     * @dev Derive the location of a mapping element from the key.</span>
 143 |     | <span class='neutral'>     */</span>
 144 |     | <span class='neutral'>    function deriveMapping(bytes32 slot, bytes memory key) internal pure returns (bytes32 result) {</span>
 145 |     | <span class='neutral'>        assembly (&quot;memory-safe&quot;) {</span>
 146 |     | <span class='neutral'>            let length := mload(key)</span>
 147 |     | <span class='neutral'>            let begin := add(key, 0x20)</span>
 148 |     | <span class='neutral'>            let end := add(begin, length)</span>
 149 |     | <span class='neutral'>            let cache := mload(end)</span>
 150 |     | <span class='neutral'>            mstore(end, slot)</span>
 151 |     | <span class='neutral'>            result := keccak256(begin, add(length, 0x20))</span>
 152 |     | <span class='neutral'>            mstore(end, cache)</span>
 153 |     | <span class='neutral'>        }</span>
 154 |     | <span class='neutral'>    }</span>
 155 |     | <span class='neutral'>}</span>
 156 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/phantom/Documents/azemora/azemora-contracts/lib/openzeppelin-contracts/contracts/utils/StorageSlot.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'>// OpenZeppelin Contracts (last updated v5.1.0) (utils/StorageSlot.sol)</span>
   3 |     | <span class='neutral'>// This file was procedurally generated from scripts/generate/templates/StorageSlot.js.</span>
   4 |     | <span class='neutral'></span>
   5 |     | <span class='neutral'>pragma solidity ^0.8.20;</span>
   6 |     | <span class='neutral'></span>
   7 |     | <span class='neutral'>/**</span>
   8 |     | <span class='neutral'> * @dev Library for reading and writing primitive types to specific storage slots.</span>
   9 |     | <span class='neutral'> *</span>
  10 |     | <span class='neutral'> * Storage slots are often used to avoid storage conflict when dealing with upgradeable contracts.</span>
  11 |     | <span class='neutral'> * This library helps with reading and writing to such slots without the need for inline assembly.</span>
  12 |     | <span class='neutral'> *</span>
  13 |     | <span class='neutral'> * The functions in this library return Slot structs that contain a `value` member that can be used to read or write.</span>
  14 |     | <span class='neutral'> *</span>
  15 |     | <span class='neutral'> * Example usage to set ERC-1967 implementation slot:</span>
  16 |     | <span class='neutral'> * ```solidity</span>
  17 |     | <span class='neutral'> * contract ERC1967 {</span>
  18 |     | <span class='neutral'> *     // Define the slot. Alternatively, use the SlotDerivation library to derive the slot.</span>
  19 |     | <span class='neutral'> *     bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;</span>
  20 |     | <span class='neutral'> *</span>
  21 |     | <span class='neutral'> *     function _getImplementation() internal view returns (address) {</span>
  22 |     | <span class='neutral'> *         return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;</span>
  23 |     | <span class='neutral'> *     }</span>
  24 |     | <span class='neutral'> *</span>
  25 |     | <span class='neutral'> *     function _setImplementation(address newImplementation) internal {</span>
  26 |     | <span class='neutral'> *         require(newImplementation.code.length &gt; 0);</span>
  27 |     | <span class='neutral'> *         StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;</span>
  28 |     | <span class='neutral'> *     }</span>
  29 |     | <span class='neutral'> * }</span>
  30 |     | <span class='neutral'> * ```</span>
  31 |     | <span class='neutral'> *</span>
  32 |     | <span class='neutral'> * TIP: Consider using this library along with {SlotDerivation}.</span>
  33 |     | <span class='neutral'> */</span>
  34 |     | <span class='neutral'>library StorageSlot {</span>
  35 |     | <span class='neutral'>    struct AddressSlot {</span>
  36 |     | <span class='neutral'>        address value;</span>
  37 |     | <span class='neutral'>    }</span>
  38 |     | <span class='neutral'></span>
  39 |     | <span class='neutral'>    struct BooleanSlot {</span>
  40 |     | <span class='neutral'>        bool value;</span>
  41 |     | <span class='neutral'>    }</span>
  42 |     | <span class='neutral'></span>
  43 |     | <span class='neutral'>    struct Bytes32Slot {</span>
  44 |     | <span class='neutral'>        bytes32 value;</span>
  45 |     | <span class='neutral'>    }</span>
  46 |     | <span class='neutral'></span>
  47 |     | <span class='neutral'>    struct Uint256Slot {</span>
  48 |     | <span class='neutral'>        uint256 value;</span>
  49 |     | <span class='neutral'>    }</span>
  50 |     | <span class='neutral'></span>
  51 |     | <span class='neutral'>    struct Int256Slot {</span>
  52 |     | <span class='neutral'>        int256 value;</span>
  53 |     | <span class='neutral'>    }</span>
  54 |     | <span class='neutral'></span>
  55 |     | <span class='neutral'>    struct StringSlot {</span>
  56 |     | <span class='neutral'>        string value;</span>
  57 |     | <span class='neutral'>    }</span>
  58 |     | <span class='neutral'></span>
  59 |     | <span class='neutral'>    struct BytesSlot {</span>
  60 |     | <span class='neutral'>        bytes value;</span>
  61 |     | <span class='neutral'>    }</span>
  62 |     | <span class='neutral'></span>
  63 |     | <span class='neutral'>    /**</span>
  64 |     | <span class='neutral'>     * @dev Returns an `AddressSlot` with member `value` located at `slot`.</span>
  65 |     | <span class='neutral'>     */</span>
  66 |     | <span class='neutral'>    function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {</span>
  67 |     | <span class='neutral'>        assembly (&quot;memory-safe&quot;) {</span>
  68 |     | <span class='neutral'>            r.slot := slot</span>
  69 |     | <span class='neutral'>        }</span>
  70 |     | <span class='neutral'>    }</span>
  71 |     | <span class='neutral'></span>
  72 |     | <span class='neutral'>    /**</span>
  73 |     | <span class='neutral'>     * @dev Returns a `BooleanSlot` with member `value` located at `slot`.</span>
  74 |     | <span class='neutral'>     */</span>
  75 |     | <span class='neutral'>    function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {</span>
  76 |     | <span class='neutral'>        assembly (&quot;memory-safe&quot;) {</span>
  77 |     | <span class='neutral'>            r.slot := slot</span>
  78 |     | <span class='neutral'>        }</span>
  79 |     | <span class='neutral'>    }</span>
  80 |     | <span class='neutral'></span>
  81 |     | <span class='neutral'>    /**</span>
  82 |     | <span class='neutral'>     * @dev Returns a `Bytes32Slot` with member `value` located at `slot`.</span>
  83 |     | <span class='neutral'>     */</span>
  84 |     | <span class='neutral'>    function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {</span>
  85 |     | <span class='neutral'>        assembly (&quot;memory-safe&quot;) {</span>
  86 |     | <span class='neutral'>            r.slot := slot</span>
  87 |     | <span class='neutral'>        }</span>
  88 |     | <span class='neutral'>    }</span>
  89 |     | <span class='neutral'></span>
  90 |     | <span class='neutral'>    /**</span>
  91 |     | <span class='neutral'>     * @dev Returns a `Uint256Slot` with member `value` located at `slot`.</span>
  92 |     | <span class='neutral'>     */</span>
  93 |     | <span class='neutral'>    function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {</span>
  94 |     | <span class='neutral'>        assembly (&quot;memory-safe&quot;) {</span>
  95 |     | <span class='neutral'>            r.slot := slot</span>
  96 |     | <span class='neutral'>        }</span>
  97 |     | <span class='neutral'>    }</span>
  98 |     | <span class='neutral'></span>
  99 |     | <span class='neutral'>    /**</span>
 100 |     | <span class='neutral'>     * @dev Returns a `Int256Slot` with member `value` located at `slot`.</span>
 101 |     | <span class='neutral'>     */</span>
 102 |     | <span class='neutral'>    function getInt256Slot(bytes32 slot) internal pure returns (Int256Slot storage r) {</span>
 103 |     | <span class='neutral'>        assembly (&quot;memory-safe&quot;) {</span>
 104 |     | <span class='neutral'>            r.slot := slot</span>
 105 |     | <span class='neutral'>        }</span>
 106 |     | <span class='neutral'>    }</span>
 107 |     | <span class='neutral'></span>
 108 |     | <span class='neutral'>    /**</span>
 109 |     | <span class='neutral'>     * @dev Returns a `StringSlot` with member `value` located at `slot`.</span>
 110 |     | <span class='neutral'>     */</span>
 111 |     | <span class='neutral'>    function getStringSlot(bytes32 slot) internal pure returns (StringSlot storage r) {</span>
 112 |     | <span class='neutral'>        assembly (&quot;memory-safe&quot;) {</span>
 113 |     | <span class='neutral'>            r.slot := slot</span>
 114 |     | <span class='neutral'>        }</span>
 115 |     | <span class='neutral'>    }</span>
 116 |     | <span class='neutral'></span>
 117 |     | <span class='neutral'>    /**</span>
 118 |     | <span class='neutral'>     * @dev Returns an `StringSlot` representation of the string storage pointer `store`.</span>
 119 |     | <span class='neutral'>     */</span>
 120 |     | <span class='neutral'>    function getStringSlot(string storage store) internal pure returns (StringSlot storage r) {</span>
 121 |     | <span class='neutral'>        assembly (&quot;memory-safe&quot;) {</span>
 122 |     | <span class='neutral'>            r.slot := store.slot</span>
 123 |     | <span class='neutral'>        }</span>
 124 |     | <span class='neutral'>    }</span>
 125 |     | <span class='neutral'></span>
 126 |     | <span class='neutral'>    /**</span>
 127 |     | <span class='neutral'>     * @dev Returns a `BytesSlot` with member `value` located at `slot`.</span>
 128 |     | <span class='neutral'>     */</span>
 129 |     | <span class='neutral'>    function getBytesSlot(bytes32 slot) internal pure returns (BytesSlot storage r) {</span>
 130 |     | <span class='neutral'>        assembly (&quot;memory-safe&quot;) {</span>
 131 |     | <span class='neutral'>            r.slot := slot</span>
 132 |     | <span class='neutral'>        }</span>
 133 |     | <span class='neutral'>    }</span>
 134 |     | <span class='neutral'></span>
 135 |     | <span class='neutral'>    /**</span>
 136 |     | <span class='neutral'>     * @dev Returns an `BytesSlot` representation of the bytes storage pointer `store`.</span>
 137 |     | <span class='neutral'>     */</span>
 138 |     | <span class='neutral'>    function getBytesSlot(bytes storage store) internal pure returns (BytesSlot storage r) {</span>
 139 |     | <span class='neutral'>        assembly (&quot;memory-safe&quot;) {</span>
 140 |     | <span class='neutral'>            r.slot := store.slot</span>
 141 |     | <span class='neutral'>        }</span>
 142 |     | <span class='neutral'>    }</span>
 143 |     | <span class='neutral'>}</span>
 144 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/phantom/Documents/azemora/azemora-contracts/lib/openzeppelin-contracts/contracts/utils/Strings.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'>// OpenZeppelin Contracts (last updated v5.3.0) (utils/Strings.sol)</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>pragma solidity ^0.8.20;</span>
   5 |     | <span class='neutral'></span>
   6 |     | <span class='neutral'>import {Math} from &quot;./math/Math.sol&quot;;</span>
   7 |     | <span class='neutral'>import {SafeCast} from &quot;./math/SafeCast.sol&quot;;</span>
   8 |     | <span class='neutral'>import {SignedMath} from &quot;./math/SignedMath.sol&quot;;</span>
   9 |     | <span class='neutral'></span>
  10 |     | <span class='neutral'>/**</span>
  11 |     | <span class='neutral'> * @dev String operations.</span>
  12 |     | <span class='neutral'> */</span>
  13 |     | <span class='neutral'>library Strings {</span>
  14 |     | <span class='neutral'>    using SafeCast for *;</span>
  15 |     | <span class='neutral'></span>
  16 |     | <span class='neutral'>    bytes16 private constant HEX_DIGITS = &quot;0123456789abcdef&quot;;</span>
  17 |     | <span class='neutral'>    uint8 private constant ADDRESS_LENGTH = 20;</span>
  18 |     | <span class='neutral'>    uint256 private constant SPECIAL_CHARS_LOOKUP =</span>
  19 |     | <span class='neutral'>        (1 &lt;&lt; 0x08) | // backspace</span>
  20 |     | <span class='neutral'>            (1 &lt;&lt; 0x09) | // tab</span>
  21 |     | <span class='neutral'>            (1 &lt;&lt; 0x0a) | // newline</span>
  22 |     | <span class='neutral'>            (1 &lt;&lt; 0x0c) | // form feed</span>
  23 |     | <span class='neutral'>            (1 &lt;&lt; 0x0d) | // carriage return</span>
  24 |     | <span class='neutral'>            (1 &lt;&lt; 0x22) | // double quote</span>
  25 |     | <span class='neutral'>            (1 &lt;&lt; 0x5c); // backslash</span>
  26 |     | <span class='neutral'></span>
  27 |     | <span class='neutral'>    /**</span>
  28 |     | <span class='neutral'>     * @dev The `value` string doesn&#39;t fit in the specified `length`.</span>
  29 |     | <span class='neutral'>     */</span>
  30 |     | <span class='neutral'>    error StringsInsufficientHexLength(uint256 value, uint256 length);</span>
  31 |     | <span class='neutral'></span>
  32 |     | <span class='neutral'>    /**</span>
  33 |     | <span class='neutral'>     * @dev The string being parsed contains characters that are not in scope of the given base.</span>
  34 |     | <span class='neutral'>     */</span>
  35 |     | <span class='neutral'>    error StringsInvalidChar();</span>
  36 |     | <span class='neutral'></span>
  37 |     | <span class='neutral'>    /**</span>
  38 |     | <span class='neutral'>     * @dev The string being parsed is not a properly formatted address.</span>
  39 |     | <span class='neutral'>     */</span>
  40 |     | <span class='neutral'>    error StringsInvalidAddressFormat();</span>
  41 |     | <span class='neutral'></span>
  42 |     | <span class='neutral'>    /**</span>
  43 |     | <span class='neutral'>     * @dev Converts a `uint256` to its ASCII `string` decimal representation.</span>
  44 |     | <span class='neutral'>     */</span>
  45 |     | <span class='neutral'>    function toString(uint256 value) internal pure returns (string memory) {</span>
  46 |     | <span class='neutral'>        unchecked {</span>
  47 |     | <span class='neutral'>            uint256 length = Math.log10(value) + 1;</span>
  48 |     | <span class='neutral'>            string memory buffer = new string(length);</span>
  49 |     | <span class='neutral'>            uint256 ptr;</span>
  50 |     | <span class='neutral'>            assembly (&quot;memory-safe&quot;) {</span>
  51 |     | <span class='neutral'>                ptr := add(add(buffer, 0x20), length)</span>
  52 |     | <span class='neutral'>            }</span>
  53 |     | <span class='neutral'>            while (true) {</span>
  54 |     | <span class='neutral'>                ptr--;</span>
  55 |     | <span class='neutral'>                assembly (&quot;memory-safe&quot;) {</span>
  56 |     | <span class='neutral'>                    mstore8(ptr, byte(mod(value, 10), HEX_DIGITS))</span>
  57 |     | <span class='neutral'>                }</span>
  58 |     | <span class='neutral'>                value /= 10;</span>
  59 |     | <span class='neutral'>                if (value == 0) break;</span>
  60 |     | <span class='neutral'>            }</span>
  61 |     | <span class='neutral'>            return buffer;</span>
  62 |     | <span class='neutral'>        }</span>
  63 |     | <span class='neutral'>    }</span>
  64 |     | <span class='neutral'></span>
  65 |     | <span class='neutral'>    /**</span>
  66 |     | <span class='neutral'>     * @dev Converts a `int256` to its ASCII `string` decimal representation.</span>
  67 |     | <span class='neutral'>     */</span>
  68 |     | <span class='neutral'>    function toStringSigned(int256 value) internal pure returns (string memory) {</span>
  69 |     | <span class='neutral'>        return string.concat(value &lt; 0 ? &quot;-&quot; : &quot;&quot;, toString(SignedMath.abs(value)));</span>
  70 |     | <span class='neutral'>    }</span>
  71 |     | <span class='neutral'></span>
  72 |     | <span class='neutral'>    /**</span>
  73 |     | <span class='neutral'>     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.</span>
  74 |     | <span class='neutral'>     */</span>
  75 |     | <span class='neutral'>    function toHexString(uint256 value) internal pure returns (string memory) {</span>
  76 |     | <span class='neutral'>        unchecked {</span>
  77 |     | <span class='neutral'>            return toHexString(value, Math.log256(value) + 1);</span>
  78 |     | <span class='neutral'>        }</span>
  79 |     | <span class='neutral'>    }</span>
  80 |     | <span class='neutral'></span>
  81 |     | <span class='neutral'>    /**</span>
  82 |     | <span class='neutral'>     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.</span>
  83 |     | <span class='neutral'>     */</span>
  84 |     | <span class='neutral'>    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {</span>
  85 |     | <span class='neutral'>        uint256 localValue = value;</span>
  86 |     | <span class='neutral'>        bytes memory buffer = new bytes(2 * length + 2);</span>
  87 |     | <span class='neutral'>        buffer[0] = &quot;0&quot;;</span>
  88 |     | <span class='neutral'>        buffer[1] = &quot;x&quot;;</span>
  89 |     | <span class='neutral'>        for (uint256 i = 2 * length + 1; i &gt; 1; --i) {</span>
  90 |     | <span class='neutral'>            buffer[i] = HEX_DIGITS[localValue &amp; 0xf];</span>
  91 |     | <span class='neutral'>            localValue &gt;&gt;= 4;</span>
  92 |     | <span class='neutral'>        }</span>
  93 |     | <span class='neutral'>        if (localValue != 0) {</span>
  94 |     | <span class='neutral'>            revert StringsInsufficientHexLength(value, length);</span>
  95 |     | <span class='neutral'>        }</span>
  96 |     | <span class='neutral'>        return string(buffer);</span>
  97 |     | <span class='neutral'>    }</span>
  98 |     | <span class='neutral'></span>
  99 |     | <span class='neutral'>    /**</span>
 100 |     | <span class='neutral'>     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal</span>
 101 |     | <span class='neutral'>     * representation.</span>
 102 |     | <span class='neutral'>     */</span>
 103 |     | <span class='neutral'>    function toHexString(address addr) internal pure returns (string memory) {</span>
 104 |     | <span class='neutral'>        return toHexString(uint256(uint160(addr)), ADDRESS_LENGTH);</span>
 105 |     | <span class='neutral'>    }</span>
 106 |     | <span class='neutral'></span>
 107 |     | <span class='neutral'>    /**</span>
 108 |     | <span class='neutral'>     * @dev Converts an `address` with fixed length of 20 bytes to its checksummed ASCII `string` hexadecimal</span>
 109 |     | <span class='neutral'>     * representation, according to EIP-55.</span>
 110 |     | <span class='neutral'>     */</span>
 111 |     | <span class='neutral'>    function toChecksumHexString(address addr) internal pure returns (string memory) {</span>
 112 |     | <span class='neutral'>        bytes memory buffer = bytes(toHexString(addr));</span>
 113 |     | <span class='neutral'></span>
 114 |     | <span class='neutral'>        // hash the hex part of buffer (skip length + 2 bytes, length 40)</span>
 115 |     | <span class='neutral'>        uint256 hashValue;</span>
 116 |     | <span class='neutral'>        assembly (&quot;memory-safe&quot;) {</span>
 117 |     | <span class='neutral'>            hashValue := shr(96, keccak256(add(buffer, 0x22), 40))</span>
 118 |     | <span class='neutral'>        }</span>
 119 |     | <span class='neutral'></span>
 120 |     | <span class='neutral'>        for (uint256 i = 41; i &gt; 1; --i) {</span>
 121 |     | <span class='neutral'>            // possible values for buffer[i] are 48 (0) to 57 (9) and 97 (a) to 102 (f)</span>
 122 |     | <span class='neutral'>            if (hashValue &amp; 0xf &gt; 7 &amp;&amp; uint8(buffer[i]) &gt; 96) {</span>
 123 |     | <span class='neutral'>                // case shift by xoring with 0x20</span>
 124 |     | <span class='neutral'>                buffer[i] ^= 0x20;</span>
 125 |     | <span class='neutral'>            }</span>
 126 |     | <span class='neutral'>            hashValue &gt;&gt;= 4;</span>
 127 |     | <span class='neutral'>        }</span>
 128 |     | <span class='neutral'>        return string(buffer);</span>
 129 |     | <span class='neutral'>    }</span>
 130 |     | <span class='neutral'></span>
 131 |     | <span class='neutral'>    /**</span>
 132 |     | <span class='neutral'>     * @dev Returns true if the two strings are equal.</span>
 133 |     | <span class='neutral'>     */</span>
 134 |     | <span class='neutral'>    function equal(string memory a, string memory b) internal pure returns (bool) {</span>
 135 |     | <span class='neutral'>        return bytes(a).length == bytes(b).length &amp;&amp; keccak256(bytes(a)) == keccak256(bytes(b));</span>
 136 |     | <span class='neutral'>    }</span>
 137 |     | <span class='neutral'></span>
 138 |     | <span class='neutral'>    /**</span>
 139 |     | <span class='neutral'>     * @dev Parse a decimal string and returns the value as a `uint256`.</span>
 140 |     | <span class='neutral'>     *</span>
 141 |     | <span class='neutral'>     * Requirements:</span>
 142 |     | <span class='neutral'>     * - The string must be formatted as `[0-9]*`</span>
 143 |     | <span class='neutral'>     * - The result must fit into an `uint256` type</span>
 144 |     | <span class='neutral'>     */</span>
 145 |     | <span class='neutral'>    function parseUint(string memory input) internal pure returns (uint256) {</span>
 146 |     | <span class='neutral'>        return parseUint(input, 0, bytes(input).length);</span>
 147 |     | <span class='neutral'>    }</span>
 148 |     | <span class='neutral'></span>
 149 |     | <span class='neutral'>    /**</span>
 150 |     | <span class='neutral'>     * @dev Variant of {parseUint-string} that parses a substring of `input` located between position `begin` (included) and</span>
 151 |     | <span class='neutral'>     * `end` (excluded).</span>
 152 |     | <span class='neutral'>     *</span>
 153 |     | <span class='neutral'>     * Requirements:</span>
 154 |     | <span class='neutral'>     * - The substring must be formatted as `[0-9]*`</span>
 155 |     | <span class='neutral'>     * - The result must fit into an `uint256` type</span>
 156 |     | <span class='neutral'>     */</span>
 157 |     | <span class='neutral'>    function parseUint(string memory input, uint256 begin, uint256 end) internal pure returns (uint256) {</span>
 158 |     | <span class='neutral'>        (bool success, uint256 value) = tryParseUint(input, begin, end);</span>
 159 |     | <span class='neutral'>        if (!success) revert StringsInvalidChar();</span>
 160 |     | <span class='neutral'>        return value;</span>
 161 |     | <span class='neutral'>    }</span>
 162 |     | <span class='neutral'></span>
 163 |     | <span class='neutral'>    /**</span>
 164 |     | <span class='neutral'>     * @dev Variant of {parseUint-string} that returns false if the parsing fails because of an invalid character.</span>
 165 |     | <span class='neutral'>     *</span>
 166 |     | <span class='neutral'>     * NOTE: This function will revert if the result does not fit in a `uint256`.</span>
 167 |     | <span class='neutral'>     */</span>
 168 |     | <span class='neutral'>    function tryParseUint(string memory input) internal pure returns (bool success, uint256 value) {</span>
 169 |     | <span class='neutral'>        return _tryParseUintUncheckedBounds(input, 0, bytes(input).length);</span>
 170 |     | <span class='neutral'>    }</span>
 171 |     | <span class='neutral'></span>
 172 |     | <span class='neutral'>    /**</span>
 173 |     | <span class='neutral'>     * @dev Variant of {parseUint-string-uint256-uint256} that returns false if the parsing fails because of an invalid</span>
 174 |     | <span class='neutral'>     * character.</span>
 175 |     | <span class='neutral'>     *</span>
 176 |     | <span class='neutral'>     * NOTE: This function will revert if the result does not fit in a `uint256`.</span>
 177 |     | <span class='neutral'>     */</span>
 178 |     | <span class='neutral'>    function tryParseUint(</span>
 179 |     | <span class='neutral'>        string memory input,</span>
 180 |     | <span class='neutral'>        uint256 begin,</span>
 181 |     | <span class='neutral'>        uint256 end</span>
 182 |     | <span class='neutral'>    ) internal pure returns (bool success, uint256 value) {</span>
 183 |     | <span class='neutral'>        if (end &gt; bytes(input).length || begin &gt; end) return (false, 0);</span>
 184 |     | <span class='neutral'>        return _tryParseUintUncheckedBounds(input, begin, end);</span>
 185 |     | <span class='neutral'>    }</span>
 186 |     | <span class='neutral'></span>
 187 |     | <span class='neutral'>    /**</span>
 188 |     | <span class='neutral'>     * @dev Implementation of {tryParseUint-string-uint256-uint256} that does not check bounds. Caller should make sure that</span>
 189 |     | <span class='neutral'>     * `begin &lt;= end &lt;= input.length`. Other inputs would result in undefined behavior.</span>
 190 |     | <span class='neutral'>     */</span>
 191 |     | <span class='neutral'>    function _tryParseUintUncheckedBounds(</span>
 192 |     | <span class='neutral'>        string memory input,</span>
 193 |     | <span class='neutral'>        uint256 begin,</span>
 194 |     | <span class='neutral'>        uint256 end</span>
 195 |     | <span class='neutral'>    ) private pure returns (bool success, uint256 value) {</span>
 196 |     | <span class='neutral'>        bytes memory buffer = bytes(input);</span>
 197 |     | <span class='neutral'></span>
 198 |     | <span class='neutral'>        uint256 result = 0;</span>
 199 |     | <span class='neutral'>        for (uint256 i = begin; i &lt; end; ++i) {</span>
 200 |     | <span class='neutral'>            uint8 chr = _tryParseChr(bytes1(_unsafeReadBytesOffset(buffer, i)));</span>
 201 |     | <span class='neutral'>            if (chr &gt; 9) return (false, 0);</span>
 202 |     | <span class='neutral'>            result *= 10;</span>
 203 |     | <span class='neutral'>            result += chr;</span>
 204 |     | <span class='neutral'>        }</span>
 205 |     | <span class='neutral'>        return (true, result);</span>
 206 |     | <span class='neutral'>    }</span>
 207 |     | <span class='neutral'></span>
 208 |     | <span class='neutral'>    /**</span>
 209 |     | <span class='neutral'>     * @dev Parse a decimal string and returns the value as a `int256`.</span>
 210 |     | <span class='neutral'>     *</span>
 211 |     | <span class='neutral'>     * Requirements:</span>
 212 |     | <span class='neutral'>     * - The string must be formatted as `[-+]?[0-9]*`</span>
 213 |     | <span class='neutral'>     * - The result must fit in an `int256` type.</span>
 214 |     | <span class='neutral'>     */</span>
 215 |     | <span class='neutral'>    function parseInt(string memory input) internal pure returns (int256) {</span>
 216 |     | <span class='neutral'>        return parseInt(input, 0, bytes(input).length);</span>
 217 |     | <span class='neutral'>    }</span>
 218 |     | <span class='neutral'></span>
 219 |     | <span class='neutral'>    /**</span>
 220 |     | <span class='neutral'>     * @dev Variant of {parseInt-string} that parses a substring of `input` located between position `begin` (included) and</span>
 221 |     | <span class='neutral'>     * `end` (excluded).</span>
 222 |     | <span class='neutral'>     *</span>
 223 |     | <span class='neutral'>     * Requirements:</span>
 224 |     | <span class='neutral'>     * - The substring must be formatted as `[-+]?[0-9]*`</span>
 225 |     | <span class='neutral'>     * - The result must fit in an `int256` type.</span>
 226 |     | <span class='neutral'>     */</span>
 227 |     | <span class='neutral'>    function parseInt(string memory input, uint256 begin, uint256 end) internal pure returns (int256) {</span>
 228 |     | <span class='neutral'>        (bool success, int256 value) = tryParseInt(input, begin, end);</span>
 229 |     | <span class='neutral'>        if (!success) revert StringsInvalidChar();</span>
 230 |     | <span class='neutral'>        return value;</span>
 231 |     | <span class='neutral'>    }</span>
 232 |     | <span class='neutral'></span>
 233 |     | <span class='neutral'>    /**</span>
 234 |     | <span class='neutral'>     * @dev Variant of {parseInt-string} that returns false if the parsing fails because of an invalid character or if</span>
 235 |     | <span class='neutral'>     * the result does not fit in a `int256`.</span>
 236 |     | <span class='neutral'>     *</span>
 237 |     | <span class='neutral'>     * NOTE: This function will revert if the absolute value of the result does not fit in a `uint256`.</span>
 238 |     | <span class='neutral'>     */</span>
 239 |     | <span class='neutral'>    function tryParseInt(string memory input) internal pure returns (bool success, int256 value) {</span>
 240 |     | <span class='neutral'>        return _tryParseIntUncheckedBounds(input, 0, bytes(input).length);</span>
 241 |     | <span class='neutral'>    }</span>
 242 |     | <span class='neutral'></span>
 243 |     | <span class='neutral'>    uint256 private constant ABS_MIN_INT256 = 2 ** 255;</span>
 244 |     | <span class='neutral'></span>
 245 |     | <span class='neutral'>    /**</span>
 246 |     | <span class='neutral'>     * @dev Variant of {parseInt-string-uint256-uint256} that returns false if the parsing fails because of an invalid</span>
 247 |     | <span class='neutral'>     * character or if the result does not fit in a `int256`.</span>
 248 |     | <span class='neutral'>     *</span>
 249 |     | <span class='neutral'>     * NOTE: This function will revert if the absolute value of the result does not fit in a `uint256`.</span>
 250 |     | <span class='neutral'>     */</span>
 251 |     | <span class='neutral'>    function tryParseInt(</span>
 252 |     | <span class='neutral'>        string memory input,</span>
 253 |     | <span class='neutral'>        uint256 begin,</span>
 254 |     | <span class='neutral'>        uint256 end</span>
 255 |     | <span class='neutral'>    ) internal pure returns (bool success, int256 value) {</span>
 256 |     | <span class='neutral'>        if (end &gt; bytes(input).length || begin &gt; end) return (false, 0);</span>
 257 |     | <span class='neutral'>        return _tryParseIntUncheckedBounds(input, begin, end);</span>
 258 |     | <span class='neutral'>    }</span>
 259 |     | <span class='neutral'></span>
 260 |     | <span class='neutral'>    /**</span>
 261 |     | <span class='neutral'>     * @dev Implementation of {tryParseInt-string-uint256-uint256} that does not check bounds. Caller should make sure that</span>
 262 |     | <span class='neutral'>     * `begin &lt;= end &lt;= input.length`. Other inputs would result in undefined behavior.</span>
 263 |     | <span class='neutral'>     */</span>
 264 |     | <span class='neutral'>    function _tryParseIntUncheckedBounds(</span>
 265 |     | <span class='neutral'>        string memory input,</span>
 266 |     | <span class='neutral'>        uint256 begin,</span>
 267 |     | <span class='neutral'>        uint256 end</span>
 268 |     | <span class='neutral'>    ) private pure returns (bool success, int256 value) {</span>
 269 |     | <span class='neutral'>        bytes memory buffer = bytes(input);</span>
 270 |     | <span class='neutral'></span>
 271 |     | <span class='neutral'>        // Check presence of a negative sign.</span>
 272 |     | <span class='neutral'>        bytes1 sign = begin == end ? bytes1(0) : bytes1(_unsafeReadBytesOffset(buffer, begin)); // don&#39;t do out-of-bound (possibly unsafe) read if sub-string is empty</span>
 273 |     | <span class='neutral'>        bool positiveSign = sign == bytes1(&quot;+&quot;);</span>
 274 |     | <span class='neutral'>        bool negativeSign = sign == bytes1(&quot;-&quot;);</span>
 275 |     | <span class='neutral'>        uint256 offset = (positiveSign || negativeSign).toUint();</span>
 276 |     | <span class='neutral'></span>
 277 |     | <span class='neutral'>        (bool absSuccess, uint256 absValue) = tryParseUint(input, begin + offset, end);</span>
 278 |     | <span class='neutral'></span>
 279 |     | <span class='neutral'>        if (absSuccess &amp;&amp; absValue &lt; ABS_MIN_INT256) {</span>
 280 |     | <span class='neutral'>            return (true, negativeSign ? -int256(absValue) : int256(absValue));</span>
 281 |     | <span class='neutral'>        } else if (absSuccess &amp;&amp; negativeSign &amp;&amp; absValue == ABS_MIN_INT256) {</span>
 282 |     | <span class='neutral'>            return (true, type(int256).min);</span>
 283 |     | <span class='neutral'>        } else return (false, 0);</span>
 284 |     | <span class='neutral'>    }</span>
 285 |     | <span class='neutral'></span>
 286 |     | <span class='neutral'>    /**</span>
 287 |     | <span class='neutral'>     * @dev Parse a hexadecimal string (with or without &quot;0x&quot; prefix), and returns the value as a `uint256`.</span>
 288 |     | <span class='neutral'>     *</span>
 289 |     | <span class='neutral'>     * Requirements:</span>
 290 |     | <span class='neutral'>     * - The string must be formatted as `(0x)?[0-9a-fA-F]*`</span>
 291 |     | <span class='neutral'>     * - The result must fit in an `uint256` type.</span>
 292 |     | <span class='neutral'>     */</span>
 293 |     | <span class='neutral'>    function parseHexUint(string memory input) internal pure returns (uint256) {</span>
 294 |     | <span class='neutral'>        return parseHexUint(input, 0, bytes(input).length);</span>
 295 |     | <span class='neutral'>    }</span>
 296 |     | <span class='neutral'></span>
 297 |     | <span class='neutral'>    /**</span>
 298 |     | <span class='neutral'>     * @dev Variant of {parseHexUint-string} that parses a substring of `input` located between position `begin` (included) and</span>
 299 |     | <span class='neutral'>     * `end` (excluded).</span>
 300 |     | <span class='neutral'>     *</span>
 301 |     | <span class='neutral'>     * Requirements:</span>
 302 |     | <span class='neutral'>     * - The substring must be formatted as `(0x)?[0-9a-fA-F]*`</span>
 303 |     | <span class='neutral'>     * - The result must fit in an `uint256` type.</span>
 304 |     | <span class='neutral'>     */</span>
 305 |     | <span class='neutral'>    function parseHexUint(string memory input, uint256 begin, uint256 end) internal pure returns (uint256) {</span>
 306 |     | <span class='neutral'>        (bool success, uint256 value) = tryParseHexUint(input, begin, end);</span>
 307 |     | <span class='neutral'>        if (!success) revert StringsInvalidChar();</span>
 308 |     | <span class='neutral'>        return value;</span>
 309 |     | <span class='neutral'>    }</span>
 310 |     | <span class='neutral'></span>
 311 |     | <span class='neutral'>    /**</span>
 312 |     | <span class='neutral'>     * @dev Variant of {parseHexUint-string} that returns false if the parsing fails because of an invalid character.</span>
 313 |     | <span class='neutral'>     *</span>
 314 |     | <span class='neutral'>     * NOTE: This function will revert if the result does not fit in a `uint256`.</span>
 315 |     | <span class='neutral'>     */</span>
 316 |     | <span class='neutral'>    function tryParseHexUint(string memory input) internal pure returns (bool success, uint256 value) {</span>
 317 |     | <span class='neutral'>        return _tryParseHexUintUncheckedBounds(input, 0, bytes(input).length);</span>
 318 |     | <span class='neutral'>    }</span>
 319 |     | <span class='neutral'></span>
 320 |     | <span class='neutral'>    /**</span>
 321 |     | <span class='neutral'>     * @dev Variant of {parseHexUint-string-uint256-uint256} that returns false if the parsing fails because of an</span>
 322 |     | <span class='neutral'>     * invalid character.</span>
 323 |     | <span class='neutral'>     *</span>
 324 |     | <span class='neutral'>     * NOTE: This function will revert if the result does not fit in a `uint256`.</span>
 325 |     | <span class='neutral'>     */</span>
 326 |     | <span class='neutral'>    function tryParseHexUint(</span>
 327 |     | <span class='neutral'>        string memory input,</span>
 328 |     | <span class='neutral'>        uint256 begin,</span>
 329 |     | <span class='neutral'>        uint256 end</span>
 330 |     | <span class='neutral'>    ) internal pure returns (bool success, uint256 value) {</span>
 331 |     | <span class='neutral'>        if (end &gt; bytes(input).length || begin &gt; end) return (false, 0);</span>
 332 |     | <span class='neutral'>        return _tryParseHexUintUncheckedBounds(input, begin, end);</span>
 333 |     | <span class='neutral'>    }</span>
 334 |     | <span class='neutral'></span>
 335 |     | <span class='neutral'>    /**</span>
 336 |     | <span class='neutral'>     * @dev Implementation of {tryParseHexUint-string-uint256-uint256} that does not check bounds. Caller should make sure that</span>
 337 |     | <span class='neutral'>     * `begin &lt;= end &lt;= input.length`. Other inputs would result in undefined behavior.</span>
 338 |     | <span class='neutral'>     */</span>
 339 |     | <span class='neutral'>    function _tryParseHexUintUncheckedBounds(</span>
 340 |     | <span class='neutral'>        string memory input,</span>
 341 |     | <span class='neutral'>        uint256 begin,</span>
 342 |     | <span class='neutral'>        uint256 end</span>
 343 |     | <span class='neutral'>    ) private pure returns (bool success, uint256 value) {</span>
 344 |     | <span class='neutral'>        bytes memory buffer = bytes(input);</span>
 345 |     | <span class='neutral'></span>
 346 |     | <span class='neutral'>        // skip 0x prefix if present</span>
 347 |     | <span class='neutral'>        bool hasPrefix = (end &gt; begin + 1) &amp;&amp; bytes2(_unsafeReadBytesOffset(buffer, begin)) == bytes2(&quot;0x&quot;); // don&#39;t do out-of-bound (possibly unsafe) read if sub-string is empty</span>
 348 |     | <span class='neutral'>        uint256 offset = hasPrefix.toUint() * 2;</span>
 349 |     | <span class='neutral'></span>
 350 |     | <span class='neutral'>        uint256 result = 0;</span>
 351 |     | <span class='neutral'>        for (uint256 i = begin + offset; i &lt; end; ++i) {</span>
 352 |     | <span class='neutral'>            uint8 chr = _tryParseChr(bytes1(_unsafeReadBytesOffset(buffer, i)));</span>
 353 |     | <span class='neutral'>            if (chr &gt; 15) return (false, 0);</span>
 354 |     | <span class='neutral'>            result *= 16;</span>
 355 |     | <span class='neutral'>            unchecked {</span>
 356 |     | <span class='neutral'>                // Multiplying by 16 is equivalent to a shift of 4 bits (with additional overflow check).</span>
 357 |     | <span class='neutral'>                // This guarantees that adding a value &lt; 16 will not cause an overflow, hence the unchecked.</span>
 358 |     | <span class='neutral'>                result += chr;</span>
 359 |     | <span class='neutral'>            }</span>
 360 |     | <span class='neutral'>        }</span>
 361 |     | <span class='neutral'>        return (true, result);</span>
 362 |     | <span class='neutral'>    }</span>
 363 |     | <span class='neutral'></span>
 364 |     | <span class='neutral'>    /**</span>
 365 |     | <span class='neutral'>     * @dev Parse a hexadecimal string (with or without &quot;0x&quot; prefix), and returns the value as an `address`.</span>
 366 |     | <span class='neutral'>     *</span>
 367 |     | <span class='neutral'>     * Requirements:</span>
 368 |     | <span class='neutral'>     * - The string must be formatted as `(0x)?[0-9a-fA-F]{40}`</span>
 369 |     | <span class='neutral'>     */</span>
 370 |     | <span class='neutral'>    function parseAddress(string memory input) internal pure returns (address) {</span>
 371 |     | <span class='neutral'>        return parseAddress(input, 0, bytes(input).length);</span>
 372 |     | <span class='neutral'>    }</span>
 373 |     | <span class='neutral'></span>
 374 |     | <span class='neutral'>    /**</span>
 375 |     | <span class='neutral'>     * @dev Variant of {parseAddress-string} that parses a substring of `input` located between position `begin` (included) and</span>
 376 |     | <span class='neutral'>     * `end` (excluded).</span>
 377 |     | <span class='neutral'>     *</span>
 378 |     | <span class='neutral'>     * Requirements:</span>
 379 |     | <span class='neutral'>     * - The substring must be formatted as `(0x)?[0-9a-fA-F]{40}`</span>
 380 |     | <span class='neutral'>     */</span>
 381 |     | <span class='neutral'>    function parseAddress(string memory input, uint256 begin, uint256 end) internal pure returns (address) {</span>
 382 |     | <span class='neutral'>        (bool success, address value) = tryParseAddress(input, begin, end);</span>
 383 |     | <span class='neutral'>        if (!success) revert StringsInvalidAddressFormat();</span>
 384 |     | <span class='neutral'>        return value;</span>
 385 |     | <span class='neutral'>    }</span>
 386 |     | <span class='neutral'></span>
 387 |     | <span class='neutral'>    /**</span>
 388 |     | <span class='neutral'>     * @dev Variant of {parseAddress-string} that returns false if the parsing fails because the input is not a properly</span>
 389 |     | <span class='neutral'>     * formatted address. See {parseAddress-string} requirements.</span>
 390 |     | <span class='neutral'>     */</span>
 391 |     | <span class='neutral'>    function tryParseAddress(string memory input) internal pure returns (bool success, address value) {</span>
 392 |     | <span class='neutral'>        return tryParseAddress(input, 0, bytes(input).length);</span>
 393 |     | <span class='neutral'>    }</span>
 394 |     | <span class='neutral'></span>
 395 |     | <span class='neutral'>    /**</span>
 396 |     | <span class='neutral'>     * @dev Variant of {parseAddress-string-uint256-uint256} that returns false if the parsing fails because input is not a properly</span>
 397 |     | <span class='neutral'>     * formatted address. See {parseAddress-string-uint256-uint256} requirements.</span>
 398 |     | <span class='neutral'>     */</span>
 399 |     | <span class='neutral'>    function tryParseAddress(</span>
 400 |     | <span class='neutral'>        string memory input,</span>
 401 |     | <span class='neutral'>        uint256 begin,</span>
 402 |     | <span class='neutral'>        uint256 end</span>
 403 |     | <span class='neutral'>    ) internal pure returns (bool success, address value) {</span>
 404 |     | <span class='neutral'>        if (end &gt; bytes(input).length || begin &gt; end) return (false, address(0));</span>
 405 |     | <span class='neutral'></span>
 406 |     | <span class='neutral'>        bool hasPrefix = (end &gt; begin + 1) &amp;&amp; bytes2(_unsafeReadBytesOffset(bytes(input), begin)) == bytes2(&quot;0x&quot;); // don&#39;t do out-of-bound (possibly unsafe) read if sub-string is empty</span>
 407 |     | <span class='neutral'>        uint256 expectedLength = 40 + hasPrefix.toUint() * 2;</span>
 408 |     | <span class='neutral'></span>
 409 |     | <span class='neutral'>        // check that input is the correct length</span>
 410 |     | <span class='neutral'>        if (end - begin == expectedLength) {</span>
 411 |     | <span class='neutral'>            // length guarantees that this does not overflow, and value is at most type(uint160).max</span>
 412 |     | <span class='neutral'>            (bool s, uint256 v) = _tryParseHexUintUncheckedBounds(input, begin, end);</span>
 413 |     | <span class='neutral'>            return (s, address(uint160(v)));</span>
 414 |     | <span class='neutral'>        } else {</span>
 415 |     | <span class='neutral'>            return (false, address(0));</span>
 416 |     | <span class='neutral'>        }</span>
 417 |     | <span class='neutral'>    }</span>
 418 |     | <span class='neutral'></span>
 419 |     | <span class='neutral'>    function _tryParseChr(bytes1 chr) private pure returns (uint8) {</span>
 420 |     | <span class='neutral'>        uint8 value = uint8(chr);</span>
 421 |     | <span class='neutral'></span>
 422 |     | <span class='neutral'>        // Try to parse `chr`:</span>
 423 |     | <span class='neutral'>        // - Case 1: [0-9]</span>
 424 |     | <span class='neutral'>        // - Case 2: [a-f]</span>
 425 |     | <span class='neutral'>        // - Case 3: [A-F]</span>
 426 |     | <span class='neutral'>        // - otherwise not supported</span>
 427 |     | <span class='neutral'>        unchecked {</span>
 428 |     | <span class='neutral'>            if (value &gt; 47 &amp;&amp; value &lt; 58) value -= 48;</span>
 429 |     | <span class='neutral'>            else if (value &gt; 96 &amp;&amp; value &lt; 103) value -= 87;</span>
 430 |     | <span class='neutral'>            else if (value &gt; 64 &amp;&amp; value &lt; 71) value -= 55;</span>
 431 |     | <span class='neutral'>            else return type(uint8).max;</span>
 432 |     | <span class='neutral'>        }</span>
 433 |     | <span class='neutral'></span>
 434 |     | <span class='neutral'>        return value;</span>
 435 |     | <span class='neutral'>    }</span>
 436 |     | <span class='neutral'></span>
 437 |     | <span class='neutral'>    /**</span>
 438 |     | <span class='neutral'>     * @dev Escape special characters in JSON strings. This can be useful to prevent JSON injection in NFT metadata.</span>
 439 |     | <span class='neutral'>     *</span>
 440 |     | <span class='neutral'>     * WARNING: This function should only be used in double quoted JSON strings. Single quotes are not escaped.</span>
 441 |     | <span class='neutral'>     *</span>
 442 |     | <span class='neutral'>     * NOTE: This function escapes all unicode characters, and not just the ones in ranges defined in section 2.5 of</span>
 443 |     | <span class='neutral'>     * RFC-4627 (U+0000 to U+001F, U+0022 and U+005C). ECMAScript&#39;s `JSON.parse` does recover escaped unicode</span>
 444 |     | <span class='neutral'>     * characters that are not in this range, but other tooling may provide different results.</span>
 445 |     | <span class='neutral'>     */</span>
 446 |     | <span class='neutral'>    function escapeJSON(string memory input) internal pure returns (string memory) {</span>
 447 |     | <span class='neutral'>        bytes memory buffer = bytes(input);</span>
 448 |     | <span class='neutral'>        bytes memory output = new bytes(2 * buffer.length); // worst case scenario</span>
 449 |     | <span class='neutral'>        uint256 outputLength = 0;</span>
 450 |     | <span class='neutral'></span>
 451 |     | <span class='neutral'>        for (uint256 i; i &lt; buffer.length; ++i) {</span>
 452 |     | <span class='neutral'>            bytes1 char = bytes1(_unsafeReadBytesOffset(buffer, i));</span>
 453 |     | <span class='neutral'>            if (((SPECIAL_CHARS_LOOKUP &amp; (1 &lt;&lt; uint8(char))) != 0)) {</span>
 454 |     | <span class='neutral'>                output[outputLength++] = &quot;\\&quot;;</span>
 455 |     | <span class='neutral'>                if (char == 0x08) output[outputLength++] = &quot;b&quot;;</span>
 456 |     | <span class='neutral'>                else if (char == 0x09) output[outputLength++] = &quot;t&quot;;</span>
 457 |     | <span class='neutral'>                else if (char == 0x0a) output[outputLength++] = &quot;n&quot;;</span>
 458 |     | <span class='neutral'>                else if (char == 0x0c) output[outputLength++] = &quot;f&quot;;</span>
 459 |     | <span class='neutral'>                else if (char == 0x0d) output[outputLength++] = &quot;r&quot;;</span>
 460 |     | <span class='neutral'>                else if (char == 0x5c) output[outputLength++] = &quot;\\&quot;;</span>
 461 |     | <span class='neutral'>                else if (char == 0x22) {</span>
 462 |     | <span class='neutral'>                    // solhint-disable-next-line quotes</span>
 463 |     | <span class='neutral'>                    output[outputLength++] = &#39;&quot;&#39;;</span>
 464 |     | <span class='neutral'>                }</span>
 465 |     | <span class='neutral'>            } else {</span>
 466 |     | <span class='neutral'>                output[outputLength++] = char;</span>
 467 |     | <span class='neutral'>            }</span>
 468 |     | <span class='neutral'>        }</span>
 469 |     | <span class='neutral'>        // write the actual length and deallocate unused memory</span>
 470 |     | <span class='neutral'>        assembly (&quot;memory-safe&quot;) {</span>
 471 |     | <span class='neutral'>            mstore(output, outputLength)</span>
 472 |     | <span class='neutral'>            mstore(0x40, add(output, shl(5, shr(5, add(outputLength, 63)))))</span>
 473 |     | <span class='neutral'>        }</span>
 474 |     | <span class='neutral'></span>
 475 |     | <span class='neutral'>        return string(output);</span>
 476 |     | <span class='neutral'>    }</span>
 477 |     | <span class='neutral'></span>
 478 |     | <span class='neutral'>    /**</span>
 479 |     | <span class='neutral'>     * @dev Reads a bytes32 from a bytes array without bounds checking.</span>
 480 |     | <span class='neutral'>     *</span>
 481 |     | <span class='neutral'>     * NOTE: making this function internal would mean it could be used with memory unsafe offset, and marking the</span>
 482 |     | <span class='neutral'>     * assembly block as such would prevent some optimizations.</span>
 483 |     | <span class='neutral'>     */</span>
 484 |     | <span class='neutral'>    function _unsafeReadBytesOffset(bytes memory buffer, uint256 offset) private pure returns (bytes32 value) {</span>
 485 |     | <span class='neutral'>        // This is not memory safe in the general case, but all calls to this private function are within bounds.</span>
 486 |     | <span class='neutral'>        assembly (&quot;memory-safe&quot;) {</span>
 487 |     | <span class='neutral'>            value := mload(add(add(buffer, 0x20), offset))</span>
 488 |     | <span class='neutral'>        }</span>
 489 |     | <span class='neutral'>    }</span>
 490 |     | <span class='neutral'>}</span>
 491 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/phantom/Documents/azemora/azemora-contracts/lib/openzeppelin-contracts/contracts/utils/cryptography/ECDSA.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
   2 | *   | <span class='executed'>// OpenZeppelin Contracts (last updated v5.1.0) (utils/cryptography/ECDSA.sol)</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>pragma solidity ^0.8.20;</span>
   5 |     | <span class='neutral'></span>
   6 |     | <span class='neutral'>/**</span>
   7 | *   | <span class='executed'> * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.</span>
   8 |     | <span class='neutral'> *</span>
   9 | *   | <span class='executed'> * These functions can be used to verify that a message was signed by the holder</span>
  10 |     | <span class='neutral'> * of the private keys of a given address.</span>
  11 |     | <span class='neutral'> */</span>
  12 |     | <span class='neutral'>library ECDSA {</span>
  13 |     | <span class='unexecuted'>    enum RecoverError {</span>
  14 |     | <span class='neutral'>        NoError,</span>
  15 |     | <span class='neutral'>        InvalidSignature,</span>
  16 |     | <span class='neutral'>        InvalidSignatureLength,</span>
  17 |     | <span class='neutral'>        InvalidSignatureS</span>
  18 |     | <span class='neutral'>    }</span>
  19 |     | <span class='neutral'></span>
  20 |     | <span class='neutral'>    /**</span>
  21 |     | <span class='neutral'>     * @dev The signature derives the `address(0)`.</span>
  22 |     | <span class='neutral'>     */</span>
  23 |     | <span class='neutral'>    error ECDSAInvalidSignature();</span>
  24 |     | <span class='neutral'></span>
  25 |     | <span class='neutral'>    /**</span>
  26 |     | <span class='neutral'>     * @dev The signature has an invalid length.</span>
  27 |     | <span class='neutral'>     */</span>
  28 |     | <span class='neutral'>    error ECDSAInvalidSignatureLength(uint256 length);</span>
  29 |     | <span class='neutral'></span>
  30 |     | <span class='neutral'>    /**</span>
  31 |     | <span class='neutral'>     * @dev The signature has an S value that is in the upper half order.</span>
  32 |     | <span class='neutral'>     */</span>
  33 |     | <span class='neutral'>    error ECDSAInvalidSignatureS(bytes32 s);</span>
  34 |     | <span class='neutral'></span>
  35 |     | <span class='neutral'>    /**</span>
  36 |     | <span class='neutral'>     * @dev Returns the address that signed a hashed message (`hash`) with `signature` or an error. This will not</span>
  37 |     | <span class='neutral'>     * return address(0) without also returning an error description. Errors are documented using an enum (error type)</span>
  38 |     | <span class='neutral'>     * and a bytes32 providing additional information about the error.</span>
  39 |     | <span class='neutral'>     *</span>
  40 |     | <span class='neutral'>     * If no error is returned, then the address can be used for verification purposes.</span>
  41 |     | <span class='neutral'>     *</span>
  42 |     | <span class='neutral'>     * The `ecrecover` EVM precompile allows for malleable (non-unique) signatures:</span>
  43 |     | <span class='neutral'>     * this function rejects them by requiring the `s` value to be in the lower</span>
  44 |     | <span class='neutral'>     * half order, and the `v` value to be either 27 or 28.</span>
  45 |     | <span class='neutral'>     *</span>
  46 |     | <span class='neutral'>     * IMPORTANT: `hash` _must_ be the result of a hash operation for the</span>
  47 |     | <span class='neutral'>     * verification to be secure: it is possible to craft signatures that</span>
  48 |     | <span class='neutral'>     * recover to arbitrary addresses for non-hashed data. A safe way to ensure</span>
  49 |     | <span class='neutral'>     * this is by receiving a hash of the original message (which may otherwise</span>
  50 |     | <span class='neutral'>     * be too long), and then calling {MessageHashUtils-toEthSignedMessageHash} on it.</span>
  51 |     | <span class='neutral'>     *</span>
  52 |     | <span class='neutral'>     * Documentation for signature generation:</span>
  53 |     | <span class='neutral'>     * - with https://web3js.readthedocs.io/en/v1.3.4/web3-eth-accounts.html#sign[Web3.js]</span>
  54 |     | <span class='neutral'>     * - with https://docs.ethers.io/v5/api/signer/#Signer-signMessage[ethers]</span>
  55 |     | <span class='neutral'>     */</span>
  56 |     | <span class='neutral'>    function tryRecover(</span>
  57 |     | <span class='neutral'>        bytes32 hash,</span>
  58 |     | <span class='neutral'>        bytes memory signature</span>
  59 |     | <span class='neutral'>    ) internal pure returns (address recovered, RecoverError err, bytes32 errArg) {</span>
  60 |     | <span class='neutral'>        if (signature.length == 65) {</span>
  61 |     | <span class='neutral'>            bytes32 r;</span>
  62 |     | <span class='neutral'>            bytes32 s;</span>
  63 |     | <span class='neutral'>            uint8 v;</span>
  64 |     | <span class='neutral'>            // ecrecover takes the signature parameters, and the only way to get them</span>
  65 |     | <span class='neutral'>            // currently is to use assembly.</span>
  66 |     | <span class='neutral'>            assembly (&quot;memory-safe&quot;) {</span>
  67 |     | <span class='neutral'>                r := mload(add(signature, 0x20))</span>
  68 |     | <span class='neutral'>                s := mload(add(signature, 0x40))</span>
  69 |     | <span class='neutral'>                v := byte(0, mload(add(signature, 0x60)))</span>
  70 |     | <span class='neutral'>            }</span>
  71 |     | <span class='neutral'>            return tryRecover(hash, v, r, s);</span>
  72 |     | <span class='neutral'>        } else {</span>
  73 |     | <span class='neutral'>            return (address(0), RecoverError.InvalidSignatureLength, bytes32(signature.length));</span>
  74 |     | <span class='neutral'>        }</span>
  75 |     | <span class='neutral'>    }</span>
  76 |     | <span class='neutral'></span>
  77 |     | <span class='neutral'>    /**</span>
  78 |     | <span class='neutral'>     * @dev Returns the address that signed a hashed message (`hash`) with</span>
  79 |     | <span class='neutral'>     * `signature`. This address can then be used for verification purposes.</span>
  80 |     | <span class='neutral'>     *</span>
  81 |     | <span class='neutral'>     * The `ecrecover` EVM precompile allows for malleable (non-unique) signatures:</span>
  82 |     | <span class='neutral'>     * this function rejects them by requiring the `s` value to be in the lower</span>
  83 |     | <span class='neutral'>     * half order, and the `v` value to be either 27 or 28.</span>
  84 |     | <span class='neutral'>     *</span>
  85 |     | <span class='neutral'>     * IMPORTANT: `hash` _must_ be the result of a hash operation for the</span>
  86 |     | <span class='neutral'>     * verification to be secure: it is possible to craft signatures that</span>
  87 |     | <span class='neutral'>     * recover to arbitrary addresses for non-hashed data. A safe way to ensure</span>
  88 |     | <span class='neutral'>     * this is by receiving a hash of the original message (which may otherwise</span>
  89 |     | <span class='neutral'>     * be too long), and then calling {MessageHashUtils-toEthSignedMessageHash} on it.</span>
  90 |     | <span class='neutral'>     */</span>
  91 |     | <span class='neutral'>    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {</span>
  92 |     | <span class='neutral'>        (address recovered, RecoverError error, bytes32 errorArg) = tryRecover(hash, signature);</span>
  93 |     | <span class='neutral'>        _throwError(error, errorArg);</span>
  94 |     | <span class='neutral'>        return recovered;</span>
  95 |     | <span class='neutral'>    }</span>
  96 |     | <span class='neutral'></span>
  97 |     | <span class='neutral'>    /**</span>
  98 |     | <span class='neutral'>     * @dev Overload of {ECDSA-tryRecover} that receives the `r` and `vs` short-signature fields separately.</span>
  99 |     | <span class='neutral'>     *</span>
 100 |     | <span class='neutral'>     * See https://eips.ethereum.org/EIPS/eip-2098[ERC-2098 short signatures]</span>
 101 |     | <span class='neutral'>     */</span>
 102 |     | <span class='neutral'>    function tryRecover(</span>
 103 |     | <span class='neutral'>        bytes32 hash,</span>
 104 |     | <span class='neutral'>        bytes32 r,</span>
 105 |     | <span class='neutral'>        bytes32 vs</span>
 106 |     | <span class='neutral'>    ) internal pure returns (address recovered, RecoverError err, bytes32 errArg) {</span>
 107 |     | <span class='neutral'>        unchecked {</span>
 108 |     | <span class='neutral'>            bytes32 s = vs &amp; bytes32(0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);</span>
 109 |     | <span class='neutral'>            // We do not check for an overflow here since the shift operation results in 0 or 1.</span>
 110 |     | <span class='neutral'>            uint8 v = uint8((uint256(vs) &gt;&gt; 255) + 27);</span>
 111 |     | <span class='neutral'>            return tryRecover(hash, v, r, s);</span>
 112 |     | <span class='neutral'>        }</span>
 113 |     | <span class='neutral'>    }</span>
 114 |     | <span class='neutral'></span>
 115 |     | <span class='neutral'>    /**</span>
 116 |     | <span class='neutral'>     * @dev Overload of {ECDSA-recover} that receives the `r and `vs` short-signature fields separately.</span>
 117 |     | <span class='neutral'>     */</span>
 118 |     | <span class='neutral'>    function recover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address) {</span>
 119 |     | <span class='neutral'>        (address recovered, RecoverError error, bytes32 errorArg) = tryRecover(hash, r, vs);</span>
 120 |     | <span class='neutral'>        _throwError(error, errorArg);</span>
 121 |     | <span class='neutral'>        return recovered;</span>
 122 |     | <span class='neutral'>    }</span>
 123 |     | <span class='neutral'></span>
 124 |     | <span class='neutral'>    /**</span>
 125 |     | <span class='neutral'>     * @dev Overload of {ECDSA-tryRecover} that receives the `v`,</span>
 126 |     | <span class='neutral'>     * `r` and `s` signature fields separately.</span>
 127 |     | <span class='neutral'>     */</span>
 128 |     | <span class='neutral'>    function tryRecover(</span>
 129 |     | <span class='neutral'>        bytes32 hash,</span>
 130 |     | <span class='neutral'>        uint8 v,</span>
 131 |     | <span class='neutral'>        bytes32 r,</span>
 132 |     | <span class='neutral'>        bytes32 s</span>
 133 |     | <span class='neutral'>    ) internal pure returns (address recovered, RecoverError err, bytes32 errArg) {</span>
 134 |     | <span class='neutral'>        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature</span>
 135 |     | <span class='neutral'>        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines</span>
 136 |     | <span class='neutral'>        // the valid range for s in (301): 0 &lt; s &lt; secp256k1n  2 + 1, and for v in (302): v  {27, 28}. Most</span>
 137 |     | <span class='neutral'>        // signatures from current libraries generate a unique signature with an s-value in the lower half order.</span>
 138 |     | <span class='neutral'>        //</span>
 139 |     | <span class='neutral'>        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value</span>
 140 |     | <span class='neutral'>        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or</span>
 141 |     | <span class='neutral'>        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept</span>
 142 |     | <span class='neutral'>        // these malleable signatures as well.</span>
 143 |     | <span class='neutral'>        if (uint256(s) &gt; 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {</span>
 144 |     | <span class='neutral'>            return (address(0), RecoverError.InvalidSignatureS, s);</span>
 145 |     | <span class='neutral'>        }</span>
 146 |     | <span class='neutral'></span>
 147 |     | <span class='neutral'>        // If the signature is valid (and not malleable), return the signer address</span>
 148 |     | <span class='neutral'>        address signer = ecrecover(hash, v, r, s);</span>
 149 |     | <span class='neutral'>        if (signer == address(0)) {</span>
 150 |     | <span class='neutral'>            return (address(0), RecoverError.InvalidSignature, bytes32(0));</span>
 151 |     | <span class='neutral'>        }</span>
 152 |     | <span class='neutral'></span>
 153 |     | <span class='neutral'>        return (signer, RecoverError.NoError, bytes32(0));</span>
 154 |     | <span class='neutral'>    }</span>
 155 |     | <span class='neutral'></span>
 156 |     | <span class='neutral'>    /**</span>
 157 |     | <span class='neutral'>     * @dev Overload of {ECDSA-recover} that receives the `v`,</span>
 158 |     | <span class='neutral'>     * `r` and `s` signature fields separately.</span>
 159 |     | <span class='neutral'>     */</span>
 160 |     | <span class='neutral'>    function recover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal pure returns (address) {</span>
 161 |     | <span class='neutral'>        (address recovered, RecoverError error, bytes32 errorArg) = tryRecover(hash, v, r, s);</span>
 162 |     | <span class='neutral'>        _throwError(error, errorArg);</span>
 163 |     | <span class='neutral'>        return recovered;</span>
 164 |     | <span class='neutral'>    }</span>
 165 |     | <span class='neutral'></span>
 166 |     | <span class='neutral'>    /**</span>
 167 |     | <span class='neutral'>     * @dev Optionally reverts with the corresponding custom error according to the `error` argument provided.</span>
 168 |     | <span class='neutral'>     */</span>
 169 |     | <span class='neutral'>    function _throwError(RecoverError error, bytes32 errorArg) private pure {</span>
 170 |     | <span class='neutral'>        if (error == RecoverError.NoError) {</span>
 171 |     | <span class='neutral'>            return; // no error: do nothing</span>
 172 |     | <span class='neutral'>        } else if (error == RecoverError.InvalidSignature) {</span>
 173 |     | <span class='neutral'>            revert ECDSAInvalidSignature();</span>
 174 |     | <span class='neutral'>        } else if (error == RecoverError.InvalidSignatureLength) {</span>
 175 |     | <span class='neutral'>            revert ECDSAInvalidSignatureLength(uint256(errorArg));</span>
 176 |     | <span class='neutral'>        } else if (error == RecoverError.InvalidSignatureS) {</span>
 177 |     | <span class='neutral'>            revert ECDSAInvalidSignatureS(errorArg);</span>
 178 |     | <span class='neutral'>        }</span>
 179 |     | <span class='neutral'>    }</span>
 180 |     | <span class='neutral'>}</span>
 181 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/phantom/Documents/azemora/azemora-contracts/lib/openzeppelin-contracts/contracts/utils/cryptography/MessageHashUtils.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'>// OpenZeppelin Contracts (last updated v5.3.0) (utils/cryptography/MessageHashUtils.sol)</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>pragma solidity ^0.8.20;</span>
   5 |     | <span class='neutral'></span>
   6 |     | <span class='neutral'>import {Strings} from &quot;../Strings.sol&quot;;</span>
   7 |     | <span class='neutral'></span>
   8 |     | <span class='neutral'>/**</span>
   9 |     | <span class='neutral'> * @dev Signature message hash utilities for producing digests to be consumed by {ECDSA} recovery or signing.</span>
  10 |     | <span class='neutral'> *</span>
  11 |     | <span class='neutral'> * The library provides methods for generating a hash of a message that conforms to the</span>
  12 |     | <span class='neutral'> * https://eips.ethereum.org/EIPS/eip-191[ERC-191] and https://eips.ethereum.org/EIPS/eip-712[EIP 712]</span>
  13 |     | <span class='neutral'> * specifications.</span>
  14 |     | <span class='neutral'> */</span>
  15 |     | <span class='neutral'>library MessageHashUtils {</span>
  16 |     | <span class='neutral'>    /**</span>
  17 | *   | <span class='executed'>     * @dev Returns the keccak256 digest of an ERC-191 signed data with version</span>
  18 |     | <span class='neutral'>     * `0x45` (`personal_sign` messages).</span>
  19 |     | <span class='neutral'>     *</span>
  20 |     | <span class='neutral'>     * The digest is calculated by prefixing a bytes32 `messageHash` with</span>
  21 |     | <span class='neutral'>     * `&quot;\x19Ethereum Signed Message:\n32&quot;` and hashing the result. It corresponds with the</span>
  22 |     | <span class='neutral'>     * hash signed when using the https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_sign[`eth_sign`] JSON-RPC method.</span>
  23 |     | <span class='neutral'>     *</span>
  24 | *   | <span class='executed'>     * NOTE: The `messageHash` parameter is intended to be the result of hashing a raw message with</span>
  25 | *   | <span class='executed'>     * keccak256, although any bytes32 value can be safely used because the final digest will</span>
  26 | *   | <span class='executed'>     * be re-hashed.</span>
  27 | *   | <span class='executed'>     *</span>
  28 |     | <span class='neutral'>     * See {ECDSA-recover}.</span>
  29 |     | <span class='neutral'>     */</span>
  30 |     | <span class='neutral'>    function toEthSignedMessageHash(bytes32 messageHash) internal pure returns (bytes32 digest) {</span>
  31 |     | <span class='neutral'>        assembly (&quot;memory-safe&quot;) {</span>
  32 |     | <span class='neutral'>            mstore(0x00, &quot;\x19Ethereum Signed Message:\n32&quot;) // 32 is the bytes-length of messageHash</span>
  33 |     | <span class='neutral'>            mstore(0x1c, messageHash) // 0x1c (28) is the length of the prefix</span>
  34 | *   | <span class='executed'>            digest := keccak256(0x00, 0x3c) // 0x3c is the length of the prefix (0x1c) + messageHash (0x20)</span>
  35 | *   | <span class='executed'>        }</span>
  36 | *   | <span class='executed'>    }</span>
  37 |     | <span class='neutral'></span>
  38 |     | <span class='neutral'>    /**</span>
  39 |     | <span class='neutral'>     * @dev Returns the keccak256 digest of an ERC-191 signed data with version</span>
  40 |     | <span class='neutral'>     * `0x45` (`personal_sign` messages).</span>
  41 |     | <span class='neutral'>     *</span>
  42 |     | <span class='neutral'>     * The digest is calculated by prefixing an arbitrary `message` with</span>
  43 |     | <span class='neutral'>     * `&quot;\x19Ethereum Signed Message:\n&quot; + len(message)` and hashing the result. It corresponds with the</span>
  44 |     | <span class='neutral'>     * hash signed when using the https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_sign[`eth_sign`] JSON-RPC method.</span>
  45 |     | <span class='neutral'>     *</span>
  46 |     | <span class='neutral'>     * See {ECDSA-recover}.</span>
  47 |     | <span class='neutral'>     */</span>
  48 |     | <span class='neutral'>    function toEthSignedMessageHash(bytes memory message) internal pure returns (bytes32) {</span>
  49 |     | <span class='neutral'>        return</span>
  50 |     | <span class='neutral'>            keccak256(bytes.concat(&quot;\x19Ethereum Signed Message:\n&quot;, bytes(Strings.toString(message.length)), message));</span>
  51 |     | <span class='neutral'>    }</span>
  52 |     | <span class='neutral'></span>
  53 |     | <span class='neutral'>    /**</span>
  54 |     | <span class='neutral'>     * @dev Returns the keccak256 digest of an ERC-191 signed data with version</span>
  55 |     | <span class='neutral'>     * `0x00` (data with intended validator).</span>
  56 |     | <span class='neutral'>     *</span>
  57 |     | <span class='neutral'>     * The digest is calculated by prefixing an arbitrary `data` with `&quot;\x19\x00&quot;` and the intended</span>
  58 |     | <span class='neutral'>     * `validator` address. Then hashing the result.</span>
  59 |     | <span class='neutral'>     *</span>
  60 |     | <span class='neutral'>     * See {ECDSA-recover}.</span>
  61 |     | <span class='neutral'>     */</span>
  62 |     | <span class='neutral'>    function toDataWithIntendedValidatorHash(address validator, bytes memory data) internal pure returns (bytes32) {</span>
  63 |     | <span class='neutral'>        return keccak256(abi.encodePacked(hex&quot;19_00&quot;, validator, data));</span>
  64 |     | <span class='neutral'>    }</span>
  65 |     | <span class='neutral'></span>
  66 |     | <span class='neutral'>    /**</span>
  67 |     | <span class='neutral'>     * @dev Variant of {toDataWithIntendedValidatorHash-address-bytes} optimized for cases where `data` is a bytes32.</span>
  68 |     | <span class='neutral'>     */</span>
  69 |     | <span class='neutral'>    function toDataWithIntendedValidatorHash(</span>
  70 |     | <span class='neutral'>        address validator,</span>
  71 |     | <span class='neutral'>        bytes32 messageHash</span>
  72 |     | <span class='neutral'>    ) internal pure returns (bytes32 digest) {</span>
  73 |     | <span class='neutral'>        assembly (&quot;memory-safe&quot;) {</span>
  74 |     | <span class='neutral'>            mstore(0x00, hex&quot;19_00&quot;)</span>
  75 |     | <span class='neutral'>            mstore(0x02, shl(96, validator))</span>
  76 |     | <span class='neutral'>            mstore(0x16, messageHash)</span>
  77 |     | <span class='neutral'>            digest := keccak256(0x00, 0x36)</span>
  78 |     | <span class='neutral'>        }</span>
  79 |     | <span class='neutral'>    }</span>
  80 |     | <span class='neutral'></span>
  81 |     | <span class='neutral'>    /**</span>
  82 |     | <span class='neutral'>     * @dev Returns the keccak256 digest of an EIP-712 typed data (ERC-191 version `0x01`).</span>
  83 |     | <span class='neutral'>     *</span>
  84 |     | <span class='neutral'>     * The digest is calculated from a `domainSeparator` and a `structHash`, by prefixing them with</span>
  85 |     | <span class='neutral'>     * `\x19\x01` and hashing the result. It corresponds to the hash signed by the</span>
  86 |     | <span class='neutral'>     * https://eips.ethereum.org/EIPS/eip-712[`eth_signTypedData`] JSON-RPC method as part of EIP-712.</span>
  87 |     | <span class='neutral'>     *</span>
  88 |     | <span class='neutral'>     * See {ECDSA-recover}.</span>
  89 |     | <span class='neutral'>     */</span>
  90 |     | <span class='neutral'>    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32 digest) {</span>
  91 |     | <span class='neutral'>        assembly (&quot;memory-safe&quot;) {</span>
  92 |     | <span class='neutral'>            let ptr := mload(0x40)</span>
  93 |     | <span class='neutral'>            mstore(ptr, hex&quot;19_01&quot;)</span>
  94 |     | <span class='neutral'>            mstore(add(ptr, 0x02), domainSeparator)</span>
  95 |     | <span class='neutral'>            mstore(add(ptr, 0x22), structHash)</span>
  96 |     | <span class='neutral'>            digest := keccak256(ptr, 0x42)</span>
  97 |     | <span class='neutral'>        }</span>
  98 |     | <span class='neutral'>    }</span>
  99 |     | <span class='neutral'>}</span>
 100 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/phantom/Documents/azemora/azemora-contracts/lib/openzeppelin-contracts/contracts/utils/cryptography/SignatureChecker.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'>// OpenZeppelin Contracts (last updated v5.1.0) (utils/cryptography/SignatureChecker.sol)</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>pragma solidity ^0.8.24;</span>
   5 |     | <span class='neutral'></span>
   6 |     | <span class='neutral'>import {ECDSA} from &quot;./ECDSA.sol&quot;;</span>
   7 |     | <span class='neutral'>import {IERC1271} from &quot;../../interfaces/IERC1271.sol&quot;;</span>
   8 |     | <span class='neutral'>import {IERC7913SignatureVerifier} from &quot;../../interfaces/IERC7913.sol&quot;;</span>
   9 |     | <span class='neutral'>import {Bytes} from &quot;../../utils/Bytes.sol&quot;;</span>
  10 |     | <span class='neutral'></span>
  11 |     | <span class='neutral'>/**</span>
  12 |     | <span class='neutral'> * @dev Signature verification helper that can be used instead of `ECDSA.recover` to seamlessly support:</span>
  13 |     | <span class='neutral'> *</span>
  14 |     | <span class='unexecuted'> * * ECDSA signatures from externally owned accounts (EOAs)</span>
  15 |     | <span class='neutral'> * * ERC-1271 signatures from smart contract wallets like Argent and Safe Wallet (previously Gnosis Safe)</span>
  16 |     | <span class='neutral'> * * ERC-7913 signatures from keys that do not have an Ethereum address of their own</span>
  17 |     | <span class='neutral'> *</span>
  18 | *   | <span class='executed'> * See https://eips.ethereum.org/EIPS/eip-1271[ERC-1271] and https://eips.ethereum.org/EIPS/eip-7913[ERC-7913].</span>
  19 |     | <span class='neutral'> */</span>
  20 |     | <span class='neutral'>library SignatureChecker {</span>
  21 |     | <span class='neutral'>    using Bytes for bytes;</span>
  22 |     | <span class='neutral'></span>
  23 |     | <span class='neutral'>    /**</span>
  24 |     | <span class='neutral'>     * @dev Checks if a signature is valid for a given signer and data hash. If the signer has code, the</span>
  25 |     | <span class='neutral'>     * signature is validated against it using ERC-1271, otherwise it&#39;s validated using `ECDSA.recover`.</span>
  26 |     | <span class='neutral'>     *</span>
  27 |     | <span class='neutral'>     * NOTE: Unlike ECDSA signatures, contract signatures are revocable, and the outcome of this function can thus</span>
  28 |     | <span class='neutral'>     * change through time. It could return true at block N and false at block N+1 (or the opposite).</span>
  29 |     | <span class='neutral'>     *</span>
  30 | *   | <span class='executed'>     * NOTE: For an extended version of this function that supports ERC-7913 signatures, see {isValidSignatureNow-bytes-bytes32-bytes-}.</span>
  31 |     | <span class='neutral'>     */</span>
  32 | *   | <span class='executed'>    function isValidSignatureNow(address signer, bytes32 hash, bytes memory signature) internal view returns (bool) {</span>
  33 |     | <span class='neutral'>        if (signer.code.length == 0) {</span>
  34 | *   | <span class='executed'>            (address recovered, ECDSA.RecoverError err, ) = ECDSA.tryRecover(hash, signature);</span>
  35 | *   | <span class='executed'>            return err == ECDSA.RecoverError.NoError &amp;&amp; recovered == signer;</span>
  36 |     | <span class='neutral'>        } else {</span>
  37 | *   | <span class='executed'>            return isValidERC1271SignatureNow(signer, hash, signature);</span>
  38 |     | <span class='neutral'>        }</span>
  39 |     | <span class='neutral'>    }</span>
  40 |     | <span class='neutral'></span>
  41 |     | <span class='neutral'>    /**</span>
  42 |     | <span class='neutral'>     * @dev Checks if a signature is valid for a given signer and data hash. The signature is validated</span>
  43 |     | <span class='neutral'>     * against the signer smart contract using ERC-1271.</span>
  44 |     | <span class='neutral'>     *</span>
  45 |     | <span class='neutral'>     * NOTE: Unlike ECDSA signatures, contract signatures are revocable, and the outcome of this function can thus</span>
  46 | *   | <span class='executed'>     * change through time. It could return true at block N and false at block N+1 (or the opposite).</span>
  47 |     | <span class='neutral'>     */</span>
  48 | *   | <span class='executed'>    function isValidERC1271SignatureNow(</span>
  49 | *   | <span class='executed'>        address signer,</span>
  50 | *   | <span class='executed'>        bytes32 hash,</span>
  51 |     | <span class='neutral'>        bytes memory signature</span>
  52 | *   | <span class='executed'>    ) internal view returns (bool) {</span>
  53 | *   | <span class='executed'>        (bool success, bytes memory result) = signer.staticcall(</span>
  54 |     | <span class='unexecuted'>            abi.encodeCall(IERC1271.isValidSignature, (hash, signature))</span>
  55 |     | <span class='neutral'>        );</span>
  56 |     | <span class='neutral'>        return (success &amp;&amp;</span>
  57 |     | <span class='neutral'>            result.length &gt;= 32 &amp;&amp;</span>
  58 |     | <span class='neutral'>            abi.decode(result, (bytes32)) == bytes32(IERC1271.isValidSignature.selector));</span>
  59 |     | <span class='neutral'>    }</span>
  60 |     | <span class='neutral'></span>
  61 |     | <span class='neutral'>    /**</span>
  62 |     | <span class='neutral'>     * @dev Verifies a signature for a given ERC-7913 signer and hash.</span>
  63 |     | <span class='neutral'>     *</span>
  64 |     | <span class='neutral'>     * The signer is a `bytes` object that is the concatenation of an address and optionally a key:</span>
  65 |     | <span class='neutral'>     * `verifier || key`. A signer must be at least 20 bytes long.</span>
  66 |     | <span class='neutral'>     *</span>
  67 |     | <span class='neutral'>     * Verification is done as follows:</span>
  68 |     | <span class='neutral'>     *</span>
  69 |     | <span class='neutral'>     * * If `signer.length &lt; 20`: verification fails</span>
  70 |     | <span class='neutral'>     * * If `signer.length == 20`: verification is done using {isValidSignatureNow}</span>
  71 |     | <span class='neutral'>     * * Otherwise: verification is done using {IERC7913SignatureVerifier}</span>
  72 |     | <span class='neutral'>     *</span>
  73 |     | <span class='neutral'>     * NOTE: Unlike ECDSA signatures, contract signatures are revocable, and the outcome of this function can thus</span>
  74 |     | <span class='neutral'>     * change through time. It could return true at block N and false at block N+1 (or the opposite).</span>
  75 |     | <span class='neutral'>     */</span>
  76 |     | <span class='neutral'>    function isValidSignatureNow(</span>
  77 |     | <span class='neutral'>        bytes memory signer,</span>
  78 |     | <span class='neutral'>        bytes32 hash,</span>
  79 |     | <span class='neutral'>        bytes memory signature</span>
  80 |     | <span class='neutral'>    ) internal view returns (bool) {</span>
  81 |     | <span class='neutral'>        if (signer.length &lt; 20) {</span>
  82 |     | <span class='neutral'>            return false;</span>
  83 |     | <span class='neutral'>        } else if (signer.length == 20) {</span>
  84 |     | <span class='neutral'>            return isValidSignatureNow(address(bytes20(signer)), hash, signature);</span>
  85 |     | <span class='neutral'>        } else {</span>
  86 |     | <span class='neutral'>            (bool success, bytes memory result) = address(bytes20(signer)).staticcall(</span>
  87 |     | <span class='neutral'>                abi.encodeCall(IERC7913SignatureVerifier.verify, (signer.slice(20), hash, signature))</span>
  88 |     | <span class='neutral'>            );</span>
  89 |     | <span class='neutral'>            return (success &amp;&amp;</span>
  90 |     | <span class='neutral'>                result.length &gt;= 32 &amp;&amp;</span>
  91 |     | <span class='neutral'>                abi.decode(result, (bytes32)) == bytes32(IERC7913SignatureVerifier.verify.selector));</span>
  92 |     | <span class='neutral'>        }</span>
  93 |     | <span class='neutral'>    }</span>
  94 |     | <span class='neutral'></span>
  95 |     | <span class='neutral'>    /**</span>
  96 |     | <span class='neutral'>     * @dev Verifies multiple ERC-7913 `signatures` for a given `hash` using a set of `signers`.</span>
  97 |     | <span class='neutral'>     * Returns `false` if the number of signers and signatures is not the same.</span>
  98 |     | <span class='neutral'>     *</span>
  99 |     | <span class='neutral'>     * The signers should be ordered by their `keccak256` hash to ensure efficient duplication check. Unordered</span>
 100 |     | <span class='neutral'>     * signers are supported, but the uniqueness check will be more expensive.</span>
 101 |     | <span class='neutral'>     *</span>
 102 |     | <span class='neutral'>     * NOTE: Unlike ECDSA signatures, contract signatures are revocable, and the outcome of this function can thus</span>
 103 |     | <span class='neutral'>     * change through time. It could return true at block N and false at block N+1 (or the opposite).</span>
 104 |     | <span class='neutral'>     */</span>
 105 |     | <span class='neutral'>    function areValidSignaturesNow(</span>
 106 |     | <span class='neutral'>        bytes32 hash,</span>
 107 |     | <span class='neutral'>        bytes[] memory signers,</span>
 108 |     | <span class='neutral'>        bytes[] memory signatures</span>
 109 |     | <span class='neutral'>    ) internal view returns (bool) {</span>
 110 |     | <span class='neutral'>        if (signers.length != signatures.length) return false;</span>
 111 |     | <span class='neutral'></span>
 112 |     | <span class='neutral'>        bytes32 lastId = bytes32(0);</span>
 113 |     | <span class='neutral'></span>
 114 |     | <span class='neutral'>        for (uint256 i = 0; i &lt; signers.length; ++i) {</span>
 115 |     | <span class='neutral'>            bytes memory signer = signers[i];</span>
 116 |     | <span class='neutral'></span>
 117 |     | <span class='neutral'>            // If one of the signatures is invalid, reject the batch</span>
 118 |     | <span class='neutral'>            if (!isValidSignatureNow(signer, hash, signatures[i])) return false;</span>
 119 |     | <span class='neutral'></span>
 120 |     | <span class='neutral'>            bytes32 id = keccak256(signer);</span>
 121 |     | <span class='neutral'>            // If the current signer ID is greater than all previous IDs, then this is a new signer.</span>
 122 |     | <span class='neutral'>            if (lastId &lt; id) {</span>
 123 |     | <span class='neutral'>                lastId = id;</span>
 124 |     | <span class='neutral'>            } else {</span>
 125 |     | <span class='neutral'>                // If this signer id is not greater than all the previous ones, verify that it is not a duplicate of a previous one</span>
 126 |     | <span class='neutral'>                // This loop is never executed if the signers are ordered by id.</span>
 127 |     | <span class='neutral'>                for (uint256 j = 0; j &lt; i; ++j) {</span>
 128 |     | <span class='neutral'>                    if (id == keccak256(signers[j])) return false;</span>
 129 |     | <span class='neutral'>                }</span>
 130 |     | <span class='neutral'>            }</span>
 131 |     | <span class='neutral'>        }</span>
 132 |     | <span class='neutral'></span>
 133 |     | <span class='neutral'>        return true;</span>
 134 |     | <span class='neutral'>    }</span>
 135 |     | <span class='neutral'>}</span>
 136 |     | <span class='unexecuted'></span>

</code>
<br />

<b>/home/phantom/Documents/azemora/azemora-contracts/lib/openzeppelin-contracts/contracts/utils/introspection/IERC165.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>// OpenZeppelin Contracts (last updated v5.1.0) (utils/introspection/IERC165.sol)</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>pragma solidity &gt;=0.4.16;</span>
  5 |     | <span class='neutral'></span>
  6 |     | <span class='neutral'>/**</span>
  7 |     | <span class='neutral'> * @dev Interface of the ERC-165 standard, as defined in the</span>
  8 |     | <span class='neutral'> * https://eips.ethereum.org/EIPS/eip-165[ERC].</span>
  9 |     | <span class='neutral'> *</span>
 10 |     | <span class='neutral'> * Implementers can declare support of contract interfaces, which can then be</span>
 11 |     | <span class='neutral'> * queried by others ({ERC165Checker}).</span>
 12 |     | <span class='neutral'> *</span>
 13 |     | <span class='neutral'> * For an implementation, see {ERC165}.</span>
 14 |     | <span class='neutral'> */</span>
 15 |     | <span class='neutral'>interface IERC165 {</span>
 16 |     | <span class='neutral'>    /**</span>
 17 |     | <span class='neutral'>     * @dev Returns true if this contract implements the interface defined by</span>
 18 |     | <span class='neutral'>     * `interfaceId`. See the corresponding</span>
 19 |     | <span class='neutral'>     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[ERC section]</span>
 20 |     | <span class='neutral'>     * to learn more about how these ids are created.</span>
 21 |     | <span class='neutral'>     *</span>
 22 |     | <span class='neutral'>     * This function call must use less than 30 000 gas.</span>
 23 |     | <span class='neutral'>     */</span>
 24 |     | <span class='neutral'>    function supportsInterface(bytes4 interfaceId) external view returns (bool);</span>
 25 |     | <span class='neutral'>}</span>
 26 | *   | <span class='executed'></span>

</code>
<br />

<b>/home/phantom/Documents/azemora/azemora-contracts/lib/openzeppelin-contracts/contracts/utils/math/Math.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'>// OpenZeppelin Contracts (last updated v5.3.0) (utils/math/Math.sol)</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>pragma solidity ^0.8.20;</span>
   5 |     | <span class='neutral'></span>
   6 |     | <span class='neutral'>import {Panic} from &quot;../Panic.sol&quot;;</span>
   7 |     | <span class='neutral'>import {SafeCast} from &quot;./SafeCast.sol&quot;;</span>
   8 |     | <span class='neutral'></span>
   9 |     | <span class='neutral'>/**</span>
  10 |     | <span class='neutral'> * @dev Standard math utilities missing in the Solidity language.</span>
  11 |     | <span class='neutral'> */</span>
  12 |     | <span class='neutral'>library Math {</span>
  13 |     | <span class='neutral'>    enum Rounding {</span>
  14 |     | <span class='neutral'>        Floor, // Toward negative infinity</span>
  15 |     | <span class='neutral'>        Ceil, // Toward positive infinity</span>
  16 |     | <span class='neutral'>        Trunc, // Toward zero</span>
  17 |     | <span class='neutral'>        Expand // Away from zero</span>
  18 |     | <span class='neutral'>    }</span>
  19 |     | <span class='neutral'></span>
  20 |     | <span class='neutral'>    /**</span>
  21 |     | <span class='neutral'>     * @dev Return the 512-bit addition of two uint256.</span>
  22 |     | <span class='neutral'>     *</span>
  23 |     | <span class='neutral'>     * The result is stored in two 256 variables such that sum = high * 2 + low.</span>
  24 |     | <span class='neutral'>     */</span>
  25 |     | <span class='neutral'>    function add512(uint256 a, uint256 b) internal pure returns (uint256 high, uint256 low) {</span>
  26 |     | <span class='neutral'>        assembly (&quot;memory-safe&quot;) {</span>
  27 |     | <span class='neutral'>            low := add(a, b)</span>
  28 |     | <span class='neutral'>            high := lt(low, a)</span>
  29 |     | <span class='neutral'>        }</span>
  30 |     | <span class='neutral'>    }</span>
  31 |     | <span class='neutral'></span>
  32 |     | <span class='neutral'>    /**</span>
  33 |     | <span class='neutral'>     * @dev Return the 512-bit multiplication of two uint256.</span>
  34 |     | <span class='neutral'>     *</span>
  35 |     | <span class='neutral'>     * The result is stored in two 256 variables such that product = high * 2 + low.</span>
  36 |     | <span class='neutral'>     */</span>
  37 |     | <span class='neutral'>    function mul512(uint256 a, uint256 b) internal pure returns (uint256 high, uint256 low) {</span>
  38 |     | <span class='neutral'>        // 512-bit multiply [high low] = x * y. Compute the product mod 2 and mod 2 - 1, then use</span>
  39 |     | <span class='neutral'>        // the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256</span>
  40 |     | <span class='neutral'>        // variables such that product = high * 2 + low.</span>
  41 |     | <span class='neutral'>        assembly (&quot;memory-safe&quot;) {</span>
  42 |     | <span class='neutral'>            let mm := mulmod(a, b, not(0))</span>
  43 |     | <span class='neutral'>            low := mul(a, b)</span>
  44 |     | <span class='neutral'>            high := sub(sub(mm, low), lt(mm, low))</span>
  45 |     | <span class='neutral'>        }</span>
  46 |     | <span class='neutral'>    }</span>
  47 |     | <span class='neutral'></span>
  48 |     | <span class='neutral'>    /**</span>
  49 |     | <span class='neutral'>     * @dev Returns the addition of two unsigned integers, with a success flag (no overflow).</span>
  50 |     | <span class='neutral'>     */</span>
  51 |     | <span class='neutral'>    function tryAdd(uint256 a, uint256 b) internal pure returns (bool success, uint256 result) {</span>
  52 |     | <span class='neutral'>        unchecked {</span>
  53 |     | <span class='neutral'>            uint256 c = a + b;</span>
  54 |     | <span class='neutral'>            success = c &gt;= a;</span>
  55 |     | <span class='neutral'>            result = c * SafeCast.toUint(success);</span>
  56 |     | <span class='neutral'>        }</span>
  57 |     | <span class='neutral'>    }</span>
  58 |     | <span class='neutral'></span>
  59 |     | <span class='neutral'>    /**</span>
  60 |     | <span class='neutral'>     * @dev Returns the subtraction of two unsigned integers, with a success flag (no overflow).</span>
  61 |     | <span class='neutral'>     */</span>
  62 |     | <span class='neutral'>    function trySub(uint256 a, uint256 b) internal pure returns (bool success, uint256 result) {</span>
  63 |     | <span class='neutral'>        unchecked {</span>
  64 |     | <span class='neutral'>            uint256 c = a - b;</span>
  65 |     | <span class='neutral'>            success = c &lt;= a;</span>
  66 |     | <span class='neutral'>            result = c * SafeCast.toUint(success);</span>
  67 |     | <span class='neutral'>        }</span>
  68 |     | <span class='neutral'>    }</span>
  69 |     | <span class='neutral'></span>
  70 |     | <span class='neutral'>    /**</span>
  71 |     | <span class='neutral'>     * @dev Returns the multiplication of two unsigned integers, with a success flag (no overflow).</span>
  72 |     | <span class='neutral'>     */</span>
  73 |     | <span class='neutral'>    function tryMul(uint256 a, uint256 b) internal pure returns (bool success, uint256 result) {</span>
  74 |     | <span class='neutral'>        unchecked {</span>
  75 |     | <span class='neutral'>            uint256 c = a * b;</span>
  76 |     | <span class='neutral'>            assembly (&quot;memory-safe&quot;) {</span>
  77 |     | <span class='neutral'>                // Only true when the multiplication doesn&#39;t overflow</span>
  78 |     | <span class='neutral'>                // (c / a == b) || (a == 0)</span>
  79 |     | <span class='neutral'>                success := or(eq(div(c, a), b), iszero(a))</span>
  80 |     | <span class='neutral'>            }</span>
  81 |     | <span class='neutral'>            // equivalent to: success ? c : 0</span>
  82 |     | <span class='neutral'>            result = c * SafeCast.toUint(success);</span>
  83 |     | <span class='neutral'>        }</span>
  84 |     | <span class='neutral'>    }</span>
  85 |     | <span class='neutral'></span>
  86 |     | <span class='neutral'>    /**</span>
  87 |     | <span class='neutral'>     * @dev Returns the division of two unsigned integers, with a success flag (no division by zero).</span>
  88 |     | <span class='neutral'>     */</span>
  89 |     | <span class='neutral'>    function tryDiv(uint256 a, uint256 b) internal pure returns (bool success, uint256 result) {</span>
  90 |     | <span class='neutral'>        unchecked {</span>
  91 |     | <span class='neutral'>            success = b &gt; 0;</span>
  92 |     | <span class='neutral'>            assembly (&quot;memory-safe&quot;) {</span>
  93 |     | <span class='neutral'>                // The `DIV` opcode returns zero when the denominator is 0.</span>
  94 |     | <span class='neutral'>                result := div(a, b)</span>
  95 |     | <span class='neutral'>            }</span>
  96 |     | <span class='neutral'>        }</span>
  97 |     | <span class='neutral'>    }</span>
  98 |     | <span class='neutral'></span>
  99 |     | <span class='neutral'>    /**</span>
 100 |     | <span class='neutral'>     * @dev Returns the remainder of dividing two unsigned integers, with a success flag (no division by zero).</span>
 101 |     | <span class='neutral'>     */</span>
 102 |     | <span class='neutral'>    function tryMod(uint256 a, uint256 b) internal pure returns (bool success, uint256 result) {</span>
 103 |     | <span class='neutral'>        unchecked {</span>
 104 |     | <span class='neutral'>            success = b &gt; 0;</span>
 105 |     | <span class='neutral'>            assembly (&quot;memory-safe&quot;) {</span>
 106 |     | <span class='neutral'>                // The `MOD` opcode returns zero when the denominator is 0.</span>
 107 |     | <span class='neutral'>                result := mod(a, b)</span>
 108 |     | <span class='neutral'>            }</span>
 109 |     | <span class='neutral'>        }</span>
 110 |     | <span class='neutral'>    }</span>
 111 |     | <span class='neutral'></span>
 112 |     | <span class='neutral'>    /**</span>
 113 |     | <span class='neutral'>     * @dev Unsigned saturating addition, bounds to `2 - 1` instead of overflowing.</span>
 114 |     | <span class='neutral'>     */</span>
 115 |     | <span class='neutral'>    function saturatingAdd(uint256 a, uint256 b) internal pure returns (uint256) {</span>
 116 |     | <span class='neutral'>        (bool success, uint256 result) = tryAdd(a, b);</span>
 117 |     | <span class='neutral'>        return ternary(success, result, type(uint256).max);</span>
 118 |     | <span class='neutral'>    }</span>
 119 |     | <span class='neutral'></span>
 120 |     | <span class='neutral'>    /**</span>
 121 |     | <span class='neutral'>     * @dev Unsigned saturating subtraction, bounds to zero instead of overflowing.</span>
 122 |     | <span class='neutral'>     */</span>
 123 |     | <span class='neutral'>    function saturatingSub(uint256 a, uint256 b) internal pure returns (uint256) {</span>
 124 |     | <span class='neutral'>        (, uint256 result) = trySub(a, b);</span>
 125 |     | <span class='neutral'>        return result;</span>
 126 |     | <span class='neutral'>    }</span>
 127 |     | <span class='neutral'></span>
 128 |     | <span class='neutral'>    /**</span>
 129 |     | <span class='neutral'>     * @dev Unsigned saturating multiplication, bounds to `2 - 1` instead of overflowing.</span>
 130 |     | <span class='neutral'>     */</span>
 131 |     | <span class='neutral'>    function saturatingMul(uint256 a, uint256 b) internal pure returns (uint256) {</span>
 132 |     | <span class='neutral'>        (bool success, uint256 result) = tryMul(a, b);</span>
 133 |     | <span class='neutral'>        return ternary(success, result, type(uint256).max);</span>
 134 |     | <span class='neutral'>    }</span>
 135 |     | <span class='neutral'></span>
 136 |     | <span class='neutral'>    /**</span>
 137 |     | <span class='neutral'>     * @dev Branchless ternary evaluation for `a ? b : c`. Gas costs are constant.</span>
 138 |     | <span class='neutral'>     *</span>
 139 |     | <span class='neutral'>     * IMPORTANT: This function may reduce bytecode size and consume less gas when used standalone.</span>
 140 |     | <span class='neutral'>     * However, the compiler may optimize Solidity ternary operations (i.e. `a ? b : c`) to only compute</span>
 141 |     | <span class='neutral'>     * one branch when needed, making this function more expensive.</span>
 142 |     | <span class='neutral'>     */</span>
 143 |     | <span class='neutral'>    function ternary(bool condition, uint256 a, uint256 b) internal pure returns (uint256) {</span>
 144 |     | <span class='neutral'>        unchecked {</span>
 145 |     | <span class='neutral'>            // branchless ternary works because:</span>
 146 |     | <span class='neutral'>            // b ^ (a ^ b) == a</span>
 147 |     | <span class='neutral'>            // b ^ 0 == b</span>
 148 |     | <span class='neutral'>            return b ^ ((a ^ b) * SafeCast.toUint(condition));</span>
 149 |     | <span class='neutral'>        }</span>
 150 |     | <span class='neutral'>    }</span>
 151 |     | <span class='neutral'></span>
 152 |     | <span class='neutral'>    /**</span>
 153 |     | <span class='neutral'>     * @dev Returns the largest of two numbers.</span>
 154 |     | <span class='neutral'>     */</span>
 155 |     | <span class='neutral'>    function max(uint256 a, uint256 b) internal pure returns (uint256) {</span>
 156 |     | <span class='neutral'>        return ternary(a &gt; b, a, b);</span>
 157 |     | <span class='neutral'>    }</span>
 158 |     | <span class='neutral'></span>
 159 |     | <span class='neutral'>    /**</span>
 160 |     | <span class='neutral'>     * @dev Returns the smallest of two numbers.</span>
 161 |     | <span class='neutral'>     */</span>
 162 |     | <span class='neutral'>    function min(uint256 a, uint256 b) internal pure returns (uint256) {</span>
 163 |     | <span class='neutral'>        return ternary(a &lt; b, a, b);</span>
 164 |     | <span class='neutral'>    }</span>
 165 |     | <span class='neutral'></span>
 166 |     | <span class='neutral'>    /**</span>
 167 |     | <span class='neutral'>     * @dev Returns the average of two numbers. The result is rounded towards</span>
 168 |     | <span class='neutral'>     * zero.</span>
 169 |     | <span class='neutral'>     */</span>
 170 |     | <span class='neutral'>    function average(uint256 a, uint256 b) internal pure returns (uint256) {</span>
 171 |     | <span class='neutral'>        // (a + b) / 2 can overflow.</span>
 172 |     | <span class='neutral'>        return (a &amp; b) + (a ^ b) / 2;</span>
 173 |     | <span class='neutral'>    }</span>
 174 |     | <span class='neutral'></span>
 175 |     | <span class='neutral'>    /**</span>
 176 |     | <span class='neutral'>     * @dev Returns the ceiling of the division of two numbers.</span>
 177 |     | <span class='neutral'>     *</span>
 178 |     | <span class='neutral'>     * This differs from standard division with `/` in that it rounds towards infinity instead</span>
 179 |     | <span class='neutral'>     * of rounding towards zero.</span>
 180 |     | <span class='neutral'>     */</span>
 181 |     | <span class='neutral'>    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {</span>
 182 |     | <span class='neutral'>        if (b == 0) {</span>
 183 |     | <span class='neutral'>            // Guarantee the same behavior as in a regular Solidity division.</span>
 184 |     | <span class='neutral'>            Panic.panic(Panic.DIVISION_BY_ZERO);</span>
 185 |     | <span class='neutral'>        }</span>
 186 |     | <span class='neutral'></span>
 187 |     | <span class='neutral'>        // The following calculation ensures accurate ceiling division without overflow.</span>
 188 |     | <span class='neutral'>        // Since a is non-zero, (a - 1) / b will not overflow.</span>
 189 |     | <span class='neutral'>        // The largest possible result occurs when (a - 1) / b is type(uint256).max,</span>
 190 |     | <span class='neutral'>        // but the largest value we can obtain is type(uint256).max - 1, which happens</span>
 191 |     | <span class='neutral'>        // when a = type(uint256).max and b = 1.</span>
 192 |     | <span class='neutral'>        unchecked {</span>
 193 |     | <span class='neutral'>            return SafeCast.toUint(a &gt; 0) * ((a - 1) / b + 1);</span>
 194 |     | <span class='neutral'>        }</span>
 195 |     | <span class='neutral'>    }</span>
 196 |     | <span class='neutral'></span>
 197 |     | <span class='neutral'>    /**</span>
 198 |     | <span class='neutral'>     * @dev Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or</span>
 199 |     | <span class='neutral'>     * denominator == 0.</span>
 200 |     | <span class='neutral'>     *</span>
 201 |     | <span class='neutral'>     * Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv) with further edits by</span>
 202 |     | <span class='neutral'>     * Uniswap Labs also under MIT license.</span>
 203 |     | <span class='neutral'>     */</span>
 204 |     | <span class='neutral'>    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {</span>
 205 |     | <span class='neutral'>        unchecked {</span>
 206 |     | <span class='neutral'>            (uint256 high, uint256 low) = mul512(x, y);</span>
 207 |     | <span class='neutral'></span>
 208 |     | <span class='neutral'>            // Handle non-overflow cases, 256 by 256 division.</span>
 209 |     | <span class='neutral'>            if (high == 0) {</span>
 210 |     | <span class='neutral'>                // Solidity will revert if denominator == 0, unlike the div opcode on its own.</span>
 211 |     | <span class='neutral'>                // The surrounding unchecked block does not change this fact.</span>
 212 |     | <span class='neutral'>                // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.</span>
 213 |     | <span class='neutral'>                return low / denominator;</span>
 214 |     | <span class='neutral'>            }</span>
 215 |     | <span class='neutral'></span>
 216 |     | <span class='neutral'>            // Make sure the result is less than 2. Also prevents denominator == 0.</span>
 217 |     | <span class='neutral'>            if (denominator &lt;= high) {</span>
 218 |     | <span class='neutral'>                Panic.panic(ternary(denominator == 0, Panic.DIVISION_BY_ZERO, Panic.UNDER_OVERFLOW));</span>
 219 |     | <span class='neutral'>            }</span>
 220 |     | <span class='neutral'></span>
 221 |     | <span class='neutral'>            ///////////////////////////////////////////////</span>
 222 |     | <span class='neutral'>            // 512 by 256 division.</span>
 223 |     | <span class='neutral'>            ///////////////////////////////////////////////</span>
 224 |     | <span class='neutral'></span>
 225 |     | <span class='neutral'>            // Make division exact by subtracting the remainder from [high low].</span>
 226 |     | <span class='neutral'>            uint256 remainder;</span>
 227 |     | <span class='neutral'>            assembly (&quot;memory-safe&quot;) {</span>
 228 |     | <span class='neutral'>                // Compute remainder using mulmod.</span>
 229 |     | <span class='neutral'>                remainder := mulmod(x, y, denominator)</span>
 230 |     | <span class='neutral'></span>
 231 |     | <span class='neutral'>                // Subtract 256 bit number from 512 bit number.</span>
 232 |     | <span class='neutral'>                high := sub(high, gt(remainder, low))</span>
 233 |     | <span class='neutral'>                low := sub(low, remainder)</span>
 234 |     | <span class='neutral'>            }</span>
 235 |     | <span class='neutral'></span>
 236 |     | <span class='neutral'>            // Factor powers of two out of denominator and compute largest power of two divisor of denominator.</span>
 237 |     | <span class='neutral'>            // Always &gt;= 1. See https://cs.stackexchange.com/q/138556/92363.</span>
 238 |     | <span class='neutral'></span>
 239 |     | <span class='neutral'>            uint256 twos = denominator &amp; (0 - denominator);</span>
 240 |     | <span class='neutral'>            assembly (&quot;memory-safe&quot;) {</span>
 241 |     | <span class='neutral'>                // Divide denominator by twos.</span>
 242 |     | <span class='neutral'>                denominator := div(denominator, twos)</span>
 243 |     | <span class='neutral'></span>
 244 |     | <span class='neutral'>                // Divide [high low] by twos.</span>
 245 |     | <span class='neutral'>                low := div(low, twos)</span>
 246 |     | <span class='neutral'></span>
 247 |     | <span class='neutral'>                // Flip twos such that it is 2 / twos. If twos is zero, then it becomes one.</span>
 248 |     | <span class='neutral'>                twos := add(div(sub(0, twos), twos), 1)</span>
 249 |     | <span class='neutral'>            }</span>
 250 |     | <span class='neutral'></span>
 251 |     | <span class='neutral'>            // Shift in bits from high into low.</span>
 252 |     | <span class='neutral'>            low |= high * twos;</span>
 253 |     | <span class='neutral'></span>
 254 |     | <span class='neutral'>            // Invert denominator mod 2. Now that denominator is an odd number, it has an inverse modulo 2 such</span>
 255 |     | <span class='neutral'>            // that denominator * inv  1 mod 2. Compute the inverse by starting with a seed that is correct for</span>
 256 |     | <span class='neutral'>            // four bits. That is, denominator * inv  1 mod 2.</span>
 257 |     | <span class='neutral'>            uint256 inverse = (3 * denominator) ^ 2;</span>
 258 |     | <span class='neutral'></span>
 259 |     | <span class='neutral'>            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel&#39;s lifting lemma, this also</span>
 260 |     | <span class='neutral'>            // works in modular arithmetic, doubling the correct bits in each step.</span>
 261 |     | <span class='neutral'>            inverse *= 2 - denominator * inverse; // inverse mod 2</span>
 262 |     | <span class='neutral'>            inverse *= 2 - denominator * inverse; // inverse mod 2</span>
 263 |     | <span class='neutral'>            inverse *= 2 - denominator * inverse; // inverse mod 2</span>
 264 |     | <span class='neutral'>            inverse *= 2 - denominator * inverse; // inverse mod 2</span>
 265 |     | <span class='neutral'>            inverse *= 2 - denominator * inverse; // inverse mod 2</span>
 266 |     | <span class='neutral'>            inverse *= 2 - denominator * inverse; // inverse mod 2</span>
 267 |     | <span class='neutral'></span>
 268 |     | <span class='neutral'>            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.</span>
 269 |     | <span class='neutral'>            // This will give us the correct result modulo 2. Since the preconditions guarantee that the outcome is</span>
 270 |     | <span class='neutral'>            // less than 2, this is the final result. We don&#39;t need to compute the high bits of the result and high</span>
 271 |     | <span class='neutral'>            // is no longer required.</span>
 272 |     | <span class='neutral'>            result = low * inverse;</span>
 273 |     | <span class='neutral'>            return result;</span>
 274 |     | <span class='neutral'>        }</span>
 275 |     | <span class='neutral'>    }</span>
 276 |     | <span class='neutral'></span>
 277 |     | <span class='neutral'>    /**</span>
 278 |     | <span class='neutral'>     * @dev Calculates x * y / denominator with full precision, following the selected rounding direction.</span>
 279 |     | <span class='neutral'>     */</span>
 280 |     | <span class='neutral'>    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {</span>
 281 |     | <span class='neutral'>        return mulDiv(x, y, denominator) + SafeCast.toUint(unsignedRoundsUp(rounding) &amp;&amp; mulmod(x, y, denominator) &gt; 0);</span>
 282 |     | <span class='neutral'>    }</span>
 283 |     | <span class='neutral'></span>
 284 |     | <span class='neutral'>    /**</span>
 285 |     | <span class='neutral'>     * @dev Calculates floor(x * y &gt;&gt; n) with full precision. Throws if result overflows a uint256.</span>
 286 |     | <span class='neutral'>     */</span>
 287 |     | <span class='neutral'>    function mulShr(uint256 x, uint256 y, uint8 n) internal pure returns (uint256 result) {</span>
 288 |     | <span class='neutral'>        unchecked {</span>
 289 |     | <span class='neutral'>            (uint256 high, uint256 low) = mul512(x, y);</span>
 290 |     | <span class='neutral'>            if (high &gt;= 1 &lt;&lt; n) {</span>
 291 |     | <span class='neutral'>                Panic.panic(Panic.UNDER_OVERFLOW);</span>
 292 |     | <span class='neutral'>            }</span>
 293 |     | <span class='neutral'>            return (high &lt;&lt; (256 - n)) | (low &gt;&gt; n);</span>
 294 |     | <span class='neutral'>        }</span>
 295 |     | <span class='neutral'>    }</span>
 296 |     | <span class='neutral'></span>
 297 |     | <span class='neutral'>    /**</span>
 298 |     | <span class='neutral'>     * @dev Calculates x * y &gt;&gt; n with full precision, following the selected rounding direction.</span>
 299 |     | <span class='neutral'>     */</span>
 300 |     | <span class='neutral'>    function mulShr(uint256 x, uint256 y, uint8 n, Rounding rounding) internal pure returns (uint256) {</span>
 301 |     | <span class='neutral'>        return mulShr(x, y, n) + SafeCast.toUint(unsignedRoundsUp(rounding) &amp;&amp; mulmod(x, y, 1 &lt;&lt; n) &gt; 0);</span>
 302 |     | <span class='neutral'>    }</span>
 303 |     | <span class='neutral'></span>
 304 |     | <span class='neutral'>    /**</span>
 305 |     | <span class='neutral'>     * @dev Calculate the modular multiplicative inverse of a number in Z/nZ.</span>
 306 |     | <span class='neutral'>     *</span>
 307 |     | <span class='neutral'>     * If n is a prime, then Z/nZ is a field. In that case all elements are inversible, except 0.</span>
 308 |     | <span class='neutral'>     * If n is not a prime, then Z/nZ is not a field, and some elements might not be inversible.</span>
 309 |     | <span class='neutral'>     *</span>
 310 |     | <span class='neutral'>     * If the input value is not inversible, 0 is returned.</span>
 311 |     | <span class='neutral'>     *</span>
 312 |     | <span class='neutral'>     * NOTE: If you know for sure that n is (big) a prime, it may be cheaper to use Fermat&#39;s little theorem and get the</span>
 313 |     | <span class='neutral'>     * inverse using `Math.modExp(a, n - 2, n)`. See {invModPrime}.</span>
 314 |     | <span class='neutral'>     */</span>
 315 |     | <span class='neutral'>    function invMod(uint256 a, uint256 n) internal pure returns (uint256) {</span>
 316 |     | <span class='neutral'>        unchecked {</span>
 317 |     | <span class='neutral'>            if (n == 0) return 0;</span>
 318 |     | <span class='neutral'></span>
 319 |     | <span class='neutral'>            // The inverse modulo is calculated using the Extended Euclidean Algorithm (iterative version)</span>
 320 |     | <span class='neutral'>            // Used to compute integers x and y such that: ax + ny = gcd(a, n).</span>
 321 |     | <span class='neutral'>            // When the gcd is 1, then the inverse of a modulo n exists and it&#39;s x.</span>
 322 |     | <span class='neutral'>            // ax + ny = 1</span>
 323 |     | <span class='neutral'>            // ax = 1 + (-y)n</span>
 324 |     | <span class='neutral'>            // ax  1 (mod n) # x is the inverse of a modulo n</span>
 325 |     | <span class='neutral'></span>
 326 |     | <span class='neutral'>            // If the remainder is 0 the gcd is n right away.</span>
 327 |     | <span class='neutral'>            uint256 remainder = a % n;</span>
 328 |     | <span class='neutral'>            uint256 gcd = n;</span>
 329 |     | <span class='neutral'></span>
 330 |     | <span class='neutral'>            // Therefore the initial coefficients are:</span>
 331 |     | <span class='neutral'>            // ax + ny = gcd(a, n) = n</span>
 332 |     | <span class='neutral'>            // 0a + 1n = n</span>
 333 |     | <span class='neutral'>            int256 x = 0;</span>
 334 |     | <span class='neutral'>            int256 y = 1;</span>
 335 |     | <span class='neutral'></span>
 336 |     | <span class='neutral'>            while (remainder != 0) {</span>
 337 |     | <span class='neutral'>                uint256 quotient = gcd / remainder;</span>
 338 |     | <span class='neutral'></span>
 339 |     | <span class='neutral'>                (gcd, remainder) = (</span>
 340 |     | <span class='neutral'>                    // The old remainder is the next gcd to try.</span>
 341 |     | <span class='neutral'>                    remainder,</span>
 342 |     | <span class='neutral'>                    // Compute the next remainder.</span>
 343 |     | <span class='neutral'>                    // Can&#39;t overflow given that (a % gcd) * (gcd // (a % gcd)) &lt;= gcd</span>
 344 |     | <span class='neutral'>                    // where gcd is at most n (capped to type(uint256).max)</span>
 345 |     | <span class='neutral'>                    gcd - remainder * quotient</span>
 346 |     | <span class='neutral'>                );</span>
 347 |     | <span class='neutral'></span>
 348 |     | <span class='neutral'>                (x, y) = (</span>
 349 |     | <span class='neutral'>                    // Increment the coefficient of a.</span>
 350 |     | <span class='neutral'>                    y,</span>
 351 |     | <span class='neutral'>                    // Decrement the coefficient of n.</span>
 352 |     | <span class='neutral'>                    // Can overflow, but the result is casted to uint256 so that the</span>
 353 |     | <span class='neutral'>                    // next value of y is &quot;wrapped around&quot; to a value between 0 and n - 1.</span>
 354 |     | <span class='neutral'>                    x - y * int256(quotient)</span>
 355 |     | <span class='neutral'>                );</span>
 356 |     | <span class='neutral'>            }</span>
 357 |     | <span class='neutral'></span>
 358 |     | <span class='neutral'>            if (gcd != 1) return 0; // No inverse exists.</span>
 359 |     | <span class='neutral'>            return ternary(x &lt; 0, n - uint256(-x), uint256(x)); // Wrap the result if it&#39;s negative.</span>
 360 |     | <span class='neutral'>        }</span>
 361 |     | <span class='neutral'>    }</span>
 362 |     | <span class='neutral'></span>
 363 |     | <span class='neutral'>    /**</span>
 364 |     | <span class='neutral'>     * @dev Variant of {invMod}. More efficient, but only works if `p` is known to be a prime greater than `2`.</span>
 365 |     | <span class='neutral'>     *</span>
 366 |     | <span class='neutral'>     * From https://en.wikipedia.org/wiki/Fermat%27s_little_theorem[Fermat&#39;s little theorem], we know that if p is</span>
 367 |     | <span class='neutral'>     * prime, then `a**(p-1)  1 mod p`. As a consequence, we have `a * a**(p-2)  1 mod p`, which means that</span>
 368 |     | <span class='neutral'>     * `a**(p-2)` is the modular multiplicative inverse of a in Fp.</span>
 369 |     | <span class='neutral'>     *</span>
 370 |     | <span class='neutral'>     * NOTE: this function does NOT check that `p` is a prime greater than `2`.</span>
 371 |     | <span class='neutral'>     */</span>
 372 |     | <span class='neutral'>    function invModPrime(uint256 a, uint256 p) internal view returns (uint256) {</span>
 373 |     | <span class='neutral'>        unchecked {</span>
 374 |     | <span class='neutral'>            return Math.modExp(a, p - 2, p);</span>
 375 |     | <span class='neutral'>        }</span>
 376 |     | <span class='neutral'>    }</span>
 377 |     | <span class='neutral'></span>
 378 |     | <span class='neutral'>    /**</span>
 379 |     | <span class='neutral'>     * @dev Returns the modular exponentiation of the specified base, exponent and modulus (b ** e % m)</span>
 380 |     | <span class='neutral'>     *</span>
 381 |     | <span class='neutral'>     * Requirements:</span>
 382 |     | <span class='neutral'>     * - modulus can&#39;t be zero</span>
 383 |     | <span class='neutral'>     * - underlying staticcall to precompile must succeed</span>
 384 |     | <span class='neutral'>     *</span>
 385 |     | <span class='neutral'>     * IMPORTANT: The result is only valid if the underlying call succeeds. When using this function, make</span>
 386 |     | <span class='neutral'>     * sure the chain you&#39;re using it on supports the precompiled contract for modular exponentiation</span>
 387 |     | <span class='neutral'>     * at address 0x05 as specified in https://eips.ethereum.org/EIPS/eip-198[EIP-198]. Otherwise,</span>
 388 |     | <span class='neutral'>     * the underlying function will succeed given the lack of a revert, but the result may be incorrectly</span>
 389 |     | <span class='neutral'>     * interpreted as 0.</span>
 390 |     | <span class='neutral'>     */</span>
 391 |     | <span class='neutral'>    function modExp(uint256 b, uint256 e, uint256 m) internal view returns (uint256) {</span>
 392 |     | <span class='neutral'>        (bool success, uint256 result) = tryModExp(b, e, m);</span>
 393 |     | <span class='neutral'>        if (!success) {</span>
 394 |     | <span class='neutral'>            Panic.panic(Panic.DIVISION_BY_ZERO);</span>
 395 |     | <span class='neutral'>        }</span>
 396 |     | <span class='neutral'>        return result;</span>
 397 |     | <span class='neutral'>    }</span>
 398 |     | <span class='neutral'></span>
 399 |     | <span class='neutral'>    /**</span>
 400 |     | <span class='neutral'>     * @dev Returns the modular exponentiation of the specified base, exponent and modulus (b ** e % m).</span>
 401 |     | <span class='neutral'>     * It includes a success flag indicating if the operation succeeded. Operation will be marked as failed if trying</span>
 402 |     | <span class='neutral'>     * to operate modulo 0 or if the underlying precompile reverted.</span>
 403 |     | <span class='neutral'>     *</span>
 404 |     | <span class='neutral'>     * IMPORTANT: The result is only valid if the success flag is true. When using this function, make sure the chain</span>
 405 |     | <span class='neutral'>     * you&#39;re using it on supports the precompiled contract for modular exponentiation at address 0x05 as specified in</span>
 406 |     | <span class='neutral'>     * https://eips.ethereum.org/EIPS/eip-198[EIP-198]. Otherwise, the underlying function will succeed given the lack</span>
 407 |     | <span class='neutral'>     * of a revert, but the result may be incorrectly interpreted as 0.</span>
 408 |     | <span class='neutral'>     */</span>
 409 |     | <span class='neutral'>    function tryModExp(uint256 b, uint256 e, uint256 m) internal view returns (bool success, uint256 result) {</span>
 410 |     | <span class='neutral'>        if (m == 0) return (false, 0);</span>
 411 |     | <span class='neutral'>        assembly (&quot;memory-safe&quot;) {</span>
 412 |     | <span class='neutral'>            let ptr := mload(0x40)</span>
 413 |     | <span class='neutral'>            // | Offset    | Content    | Content (Hex)                                                      |</span>
 414 |     | <span class='neutral'>            // |-----------|------------|--------------------------------------------------------------------|</span>
 415 |     | <span class='neutral'>            // | 0x00:0x1f | size of b  | 0x0000000000000000000000000000000000000000000000000000000000000020 |</span>
 416 |     | <span class='neutral'>            // | 0x20:0x3f | size of e  | 0x0000000000000000000000000000000000000000000000000000000000000020 |</span>
 417 |     | <span class='neutral'>            // | 0x40:0x5f | size of m  | 0x0000000000000000000000000000000000000000000000000000000000000020 |</span>
 418 |     | <span class='neutral'>            // | 0x60:0x7f | value of b | 0x&lt;.............................................................b&gt; |</span>
 419 |     | <span class='neutral'>            // | 0x80:0x9f | value of e | 0x&lt;.............................................................e&gt; |</span>
 420 |     | <span class='neutral'>            // | 0xa0:0xbf | value of m | 0x&lt;.............................................................m&gt; |</span>
 421 |     | <span class='neutral'>            mstore(ptr, 0x20)</span>
 422 |     | <span class='neutral'>            mstore(add(ptr, 0x20), 0x20)</span>
 423 |     | <span class='neutral'>            mstore(add(ptr, 0x40), 0x20)</span>
 424 |     | <span class='neutral'>            mstore(add(ptr, 0x60), b)</span>
 425 |     | <span class='neutral'>            mstore(add(ptr, 0x80), e)</span>
 426 |     | <span class='neutral'>            mstore(add(ptr, 0xa0), m)</span>
 427 |     | <span class='neutral'></span>
 428 |     | <span class='neutral'>            // Given the result &lt; m, it&#39;s guaranteed to fit in 32 bytes,</span>
 429 |     | <span class='neutral'>            // so we can use the memory scratch space located at offset 0.</span>
 430 |     | <span class='neutral'>            success := staticcall(gas(), 0x05, ptr, 0xc0, 0x00, 0x20)</span>
 431 |     | <span class='neutral'>            result := mload(0x00)</span>
 432 |     | <span class='neutral'>        }</span>
 433 |     | <span class='neutral'>    }</span>
 434 |     | <span class='neutral'></span>
 435 |     | <span class='neutral'>    /**</span>
 436 |     | <span class='neutral'>     * @dev Variant of {modExp} that supports inputs of arbitrary length.</span>
 437 |     | <span class='neutral'>     */</span>
 438 |     | <span class='neutral'>    function modExp(bytes memory b, bytes memory e, bytes memory m) internal view returns (bytes memory) {</span>
 439 |     | <span class='neutral'>        (bool success, bytes memory result) = tryModExp(b, e, m);</span>
 440 |     | <span class='neutral'>        if (!success) {</span>
 441 |     | <span class='neutral'>            Panic.panic(Panic.DIVISION_BY_ZERO);</span>
 442 |     | <span class='neutral'>        }</span>
 443 |     | <span class='neutral'>        return result;</span>
 444 |     | <span class='neutral'>    }</span>
 445 |     | <span class='neutral'></span>
 446 |     | <span class='neutral'>    /**</span>
 447 |     | <span class='neutral'>     * @dev Variant of {tryModExp} that supports inputs of arbitrary length.</span>
 448 |     | <span class='neutral'>     */</span>
 449 |     | <span class='neutral'>    function tryModExp(</span>
 450 |     | <span class='neutral'>        bytes memory b,</span>
 451 |     | <span class='neutral'>        bytes memory e,</span>
 452 |     | <span class='neutral'>        bytes memory m</span>
 453 |     | <span class='neutral'>    ) internal view returns (bool success, bytes memory result) {</span>
 454 |     | <span class='neutral'>        if (_zeroBytes(m)) return (false, new bytes(0));</span>
 455 |     | <span class='neutral'></span>
 456 |     | <span class='neutral'>        uint256 mLen = m.length;</span>
 457 |     | <span class='neutral'></span>
 458 |     | <span class='neutral'>        // Encode call args in result and move the free memory pointer</span>
 459 |     | <span class='neutral'>        result = abi.encodePacked(b.length, e.length, mLen, b, e, m);</span>
 460 |     | <span class='neutral'></span>
 461 |     | <span class='neutral'>        assembly (&quot;memory-safe&quot;) {</span>
 462 |     | <span class='neutral'>            let dataPtr := add(result, 0x20)</span>
 463 |     | <span class='neutral'>            // Write result on top of args to avoid allocating extra memory.</span>
 464 |     | <span class='neutral'>            success := staticcall(gas(), 0x05, dataPtr, mload(result), dataPtr, mLen)</span>
 465 |     | <span class='neutral'>            // Overwrite the length.</span>
 466 |     | <span class='neutral'>            // result.length &gt; returndatasize() is guaranteed because returndatasize() == m.length</span>
 467 |     | <span class='neutral'>            mstore(result, mLen)</span>
 468 |     | <span class='neutral'>            // Set the memory pointer after the returned data.</span>
 469 |     | <span class='neutral'>            mstore(0x40, add(dataPtr, mLen))</span>
 470 |     | <span class='neutral'>        }</span>
 471 |     | <span class='neutral'>    }</span>
 472 |     | <span class='neutral'></span>
 473 |     | <span class='neutral'>    /**</span>
 474 |     | <span class='neutral'>     * @dev Returns whether the provided byte array is zero.</span>
 475 |     | <span class='neutral'>     */</span>
 476 |     | <span class='neutral'>    function _zeroBytes(bytes memory byteArray) private pure returns (bool) {</span>
 477 |     | <span class='neutral'>        for (uint256 i = 0; i &lt; byteArray.length; ++i) {</span>
 478 |     | <span class='neutral'>            if (byteArray[i] != 0) {</span>
 479 |     | <span class='neutral'>                return false;</span>
 480 |     | <span class='neutral'>            }</span>
 481 |     | <span class='neutral'>        }</span>
 482 |     | <span class='neutral'>        return true;</span>
 483 |     | <span class='neutral'>    }</span>
 484 |     | <span class='neutral'></span>
 485 |     | <span class='neutral'>    /**</span>
 486 |     | <span class='neutral'>     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded</span>
 487 |     | <span class='neutral'>     * towards zero.</span>
 488 |     | <span class='neutral'>     *</span>
 489 |     | <span class='neutral'>     * This method is based on Newton&#39;s method for computing square roots; the algorithm is restricted to only</span>
 490 |     | <span class='neutral'>     * using integer operations.</span>
 491 |     | <span class='neutral'>     */</span>
 492 |     | <span class='neutral'>    function sqrt(uint256 a) internal pure returns (uint256) {</span>
 493 |     | <span class='neutral'>        unchecked {</span>
 494 |     | <span class='neutral'>            // Take care of easy edge cases when a == 0 or a == 1</span>
 495 |     | <span class='neutral'>            if (a &lt;= 1) {</span>
 496 |     | <span class='neutral'>                return a;</span>
 497 |     | <span class='neutral'>            }</span>
 498 |     | <span class='neutral'></span>
 499 |     | <span class='neutral'>            // In this function, we use Newton&#39;s method to get a root of `f(x) := x - a`. It involves building a</span>
 500 |     | <span class='neutral'>            // sequence x_n that converges toward sqrt(a). For each iteration x_n, we also define the error between</span>
 501 |     | <span class='neutral'>            // the current value as `_n = | x_n - sqrt(a) |`.</span>
 502 |     | <span class='neutral'>            //</span>
 503 |     | <span class='neutral'>            // For our first estimation, we consider `e` the smallest power of 2 which is bigger than the square root</span>
 504 |     | <span class='neutral'>            // of the target. (i.e. `2**(e-1)  sqrt(a) &lt; 2**e`). We know that `e  128` because `(2) = 2` is</span>
 505 |     | <span class='neutral'>            // bigger than any uint256.</span>
 506 |     | <span class='neutral'>            //</span>
 507 |     | <span class='neutral'>            // By noticing that</span>
 508 |     | <span class='neutral'>            // `2**(e-1)  sqrt(a) &lt; 2**e  (2**(e-1))  a &lt; (2**e)  2**(2*e-2)  a &lt; 2**(2*e)`</span>
 509 |     | <span class='neutral'>            // we can deduce that `e - 1` is `log2(a) / 2`. We can thus compute `x_n = 2**(e-1)` using a method similar</span>
 510 |     | <span class='neutral'>            // to the msb function.</span>
 511 |     | <span class='neutral'>            uint256 aa = a;</span>
 512 |     | <span class='neutral'>            uint256 xn = 1;</span>
 513 |     | <span class='neutral'></span>
 514 |     | <span class='neutral'>            if (aa &gt;= (1 &lt;&lt; 128)) {</span>
 515 |     | <span class='neutral'>                aa &gt;&gt;= 128;</span>
 516 |     | <span class='neutral'>                xn &lt;&lt;= 64;</span>
 517 |     | <span class='neutral'>            }</span>
 518 |     | <span class='neutral'>            if (aa &gt;= (1 &lt;&lt; 64)) {</span>
 519 |     | <span class='neutral'>                aa &gt;&gt;= 64;</span>
 520 |     | <span class='neutral'>                xn &lt;&lt;= 32;</span>
 521 |     | <span class='neutral'>            }</span>
 522 |     | <span class='neutral'>            if (aa &gt;= (1 &lt;&lt; 32)) {</span>
 523 |     | <span class='neutral'>                aa &gt;&gt;= 32;</span>
 524 |     | <span class='neutral'>                xn &lt;&lt;= 16;</span>
 525 |     | <span class='neutral'>            }</span>
 526 |     | <span class='neutral'>            if (aa &gt;= (1 &lt;&lt; 16)) {</span>
 527 |     | <span class='neutral'>                aa &gt;&gt;= 16;</span>
 528 |     | <span class='neutral'>                xn &lt;&lt;= 8;</span>
 529 |     | <span class='neutral'>            }</span>
 530 |     | <span class='neutral'>            if (aa &gt;= (1 &lt;&lt; 8)) {</span>
 531 |     | <span class='neutral'>                aa &gt;&gt;= 8;</span>
 532 |     | <span class='neutral'>                xn &lt;&lt;= 4;</span>
 533 |     | <span class='neutral'>            }</span>
 534 |     | <span class='neutral'>            if (aa &gt;= (1 &lt;&lt; 4)) {</span>
 535 |     | <span class='neutral'>                aa &gt;&gt;= 4;</span>
 536 |     | <span class='neutral'>                xn &lt;&lt;= 2;</span>
 537 |     | <span class='neutral'>            }</span>
 538 |     | <span class='neutral'>            if (aa &gt;= (1 &lt;&lt; 2)) {</span>
 539 |     | <span class='neutral'>                xn &lt;&lt;= 1;</span>
 540 |     | <span class='neutral'>            }</span>
 541 |     | <span class='neutral'></span>
 542 |     | <span class='neutral'>            // We now have x_n such that `x_n = 2**(e-1)  sqrt(a) &lt; 2**e = 2 * x_n`. This implies _n  2**(e-1).</span>
 543 |     | <span class='neutral'>            //</span>
 544 |     | <span class='neutral'>            // We can refine our estimation by noticing that the middle of that interval minimizes the error.</span>
 545 |     | <span class='neutral'>            // If we move x_n to equal 2**(e-1) + 2**(e-2), then we reduce the error to _n  2**(e-2).</span>
 546 |     | <span class='neutral'>            // This is going to be our x_0 (and _0)</span>
 547 |     | <span class='neutral'>            xn = (3 * xn) &gt;&gt; 1; // _0 := | x_0 - sqrt(a) |  2**(e-2)</span>
 548 |     | <span class='neutral'></span>
 549 |     | <span class='neutral'>            // From here, Newton&#39;s method give us:</span>
 550 |     | <span class='neutral'>            // x_{n+1} = (x_n + a / x_n) / 2</span>
 551 |     | <span class='neutral'>            //</span>
 552 |     | <span class='neutral'>            // One should note that:</span>
 553 |     | <span class='neutral'>            // x_{n+1} - a = ((x_n + a / x_n) / 2) - a</span>
 554 |     | <span class='neutral'>            //              = ((x_n + a) / (2 * x_n)) - a</span>
 555 |     | <span class='neutral'>            //              = (x_n + 2 * a * x_n + a) / (4 * x_n) - a</span>
 556 |     | <span class='neutral'>            //              = (x_n + 2 * a * x_n + a - 4 * a * x_n) / (4 * x_n)</span>
 557 |     | <span class='neutral'>            //              = (x_n - 2 * a * x_n + a) / (4 * x_n)</span>
 558 |     | <span class='neutral'>            //              = (x_n - a) / (2 * x_n)</span>
 559 |     | <span class='neutral'>            //              = ((x_n - a) / (2 * x_n))</span>
 560 |     | <span class='neutral'>            //               0</span>
 561 |     | <span class='neutral'>            // Which proves that for all n  1, sqrt(a)  x_n</span>
 562 |     | <span class='neutral'>            //</span>
 563 |     | <span class='neutral'>            // This gives us the proof of quadratic convergence of the sequence:</span>
 564 |     | <span class='neutral'>            // _{n+1} = | x_{n+1} - sqrt(a) |</span>
 565 |     | <span class='neutral'>            //         = | (x_n + a / x_n) / 2 - sqrt(a) |</span>
 566 |     | <span class='neutral'>            //         = | (x_n + a - 2*x_n*sqrt(a)) / (2 * x_n) |</span>
 567 |     | <span class='neutral'>            //         = | (x_n - sqrt(a)) / (2 * x_n) |</span>
 568 |     | <span class='neutral'>            //         = | _n / (2 * x_n) |</span>
 569 |     | <span class='neutral'>            //         = _n / | (2 * x_n) |</span>
 570 |     | <span class='neutral'>            //</span>
 571 |     | <span class='neutral'>            // For the first iteration, we have a special case where x_0 is known:</span>
 572 |     | <span class='neutral'>            // _1 = _0 / | (2 * x_0) |</span>
 573 |     | <span class='neutral'>            //      (2**(e-2)) / (2 * (2**(e-1) + 2**(e-2)))</span>
 574 |     | <span class='neutral'>            //      2**(2*e-4) / (3 * 2**(e-1))</span>
 575 |     | <span class='neutral'>            //      2**(e-3) / 3</span>
 576 |     | <span class='neutral'>            //      2**(e-3-log2(3))</span>
 577 |     | <span class='neutral'>            //      2**(e-4.5)</span>
 578 |     | <span class='neutral'>            //</span>
 579 |     | <span class='neutral'>            // For the following iterations, we use the fact that, 2**(e-1)  sqrt(a)  x_n:</span>
 580 |     | <span class='neutral'>            // _{n+1} = _n / | (2 * x_n) |</span>
 581 |     | <span class='neutral'>            //          (2**(e-k)) / (2 * 2**(e-1))</span>
 582 |     | <span class='neutral'>            //          2**(2*e-2*k) / 2**e</span>
 583 |     | <span class='neutral'>            //          2**(e-2*k)</span>
 584 |     | <span class='neutral'>            xn = (xn + a / xn) &gt;&gt; 1; // _1 := | x_1 - sqrt(a) |  2**(e-4.5)  -- special case, see above</span>
 585 |     | <span class='neutral'>            xn = (xn + a / xn) &gt;&gt; 1; // _2 := | x_2 - sqrt(a) |  2**(e-9)    -- general case with k = 4.5</span>
 586 |     | <span class='neutral'>            xn = (xn + a / xn) &gt;&gt; 1; // _3 := | x_3 - sqrt(a) |  2**(e-18)   -- general case with k = 9</span>
 587 |     | <span class='neutral'>            xn = (xn + a / xn) &gt;&gt; 1; // _4 := | x_4 - sqrt(a) |  2**(e-36)   -- general case with k = 18</span>
 588 |     | <span class='neutral'>            xn = (xn + a / xn) &gt;&gt; 1; // _5 := | x_5 - sqrt(a) |  2**(e-72)   -- general case with k = 36</span>
 589 |     | <span class='neutral'>            xn = (xn + a / xn) &gt;&gt; 1; // _6 := | x_6 - sqrt(a) |  2**(e-144)  -- general case with k = 72</span>
 590 |     | <span class='neutral'></span>
 591 |     | <span class='neutral'>            // Because e  128 (as discussed during the first estimation phase), we know have reached a precision</span>
 592 |     | <span class='neutral'>            // _6  2**(e-144) &lt; 1. Given we&#39;re operating on integers, then we can ensure that xn is now either</span>
 593 |     | <span class='neutral'>            // sqrt(a) or sqrt(a) + 1.</span>
 594 |     | <span class='neutral'>            return xn - SafeCast.toUint(xn &gt; a / xn);</span>
 595 |     | <span class='neutral'>        }</span>
 596 |     | <span class='neutral'>    }</span>
 597 |     | <span class='neutral'></span>
 598 |     | <span class='neutral'>    /**</span>
 599 |     | <span class='neutral'>     * @dev Calculates sqrt(a), following the selected rounding direction.</span>
 600 |     | <span class='neutral'>     */</span>
 601 |     | <span class='neutral'>    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {</span>
 602 |     | <span class='neutral'>        unchecked {</span>
 603 |     | <span class='neutral'>            uint256 result = sqrt(a);</span>
 604 |     | <span class='neutral'>            return result + SafeCast.toUint(unsignedRoundsUp(rounding) &amp;&amp; result * result &lt; a);</span>
 605 |     | <span class='neutral'>        }</span>
 606 |     | <span class='neutral'>    }</span>
 607 |     | <span class='neutral'></span>
 608 |     | <span class='neutral'>    /**</span>
 609 |     | <span class='neutral'>     * @dev Return the log in base 2 of a positive value rounded towards zero.</span>
 610 |     | <span class='neutral'>     * Returns 0 if given 0.</span>
 611 |     | <span class='neutral'>     */</span>
 612 |     | <span class='neutral'>    function log2(uint256 x) internal pure returns (uint256 r) {</span>
 613 |     | <span class='neutral'>        // If value has upper 128 bits set, log2 result is at least 128</span>
 614 |     | <span class='neutral'>        r = SafeCast.toUint(x &gt; 0xffffffffffffffffffffffffffffffff) &lt;&lt; 7;</span>
 615 |     | <span class='neutral'>        // If upper 64 bits of 128-bit half set, add 64 to result</span>
 616 |     | <span class='neutral'>        r |= SafeCast.toUint((x &gt;&gt; r) &gt; 0xffffffffffffffff) &lt;&lt; 6;</span>
 617 |     | <span class='neutral'>        // If upper 32 bits of 64-bit half set, add 32 to result</span>
 618 |     | <span class='neutral'>        r |= SafeCast.toUint((x &gt;&gt; r) &gt; 0xffffffff) &lt;&lt; 5;</span>
 619 |     | <span class='neutral'>        // If upper 16 bits of 32-bit half set, add 16 to result</span>
 620 |     | <span class='neutral'>        r |= SafeCast.toUint((x &gt;&gt; r) &gt; 0xffff) &lt;&lt; 4;</span>
 621 |     | <span class='neutral'>        // If upper 8 bits of 16-bit half set, add 8 to result</span>
 622 |     | <span class='neutral'>        r |= SafeCast.toUint((x &gt;&gt; r) &gt; 0xff) &lt;&lt; 3;</span>
 623 |     | <span class='neutral'>        // If upper 4 bits of 8-bit half set, add 4 to result</span>
 624 |     | <span class='neutral'>        r |= SafeCast.toUint((x &gt;&gt; r) &gt; 0xf) &lt;&lt; 2;</span>
 625 |     | <span class='neutral'></span>
 626 |     | <span class='neutral'>        // Shifts value right by the current result and use it as an index into this lookup table:</span>
 627 |     | <span class='neutral'>        //</span>
 628 |     | <span class='neutral'>        // | x (4 bits) |  index  | table[index] = MSB position |</span>
 629 |     | <span class='neutral'>        // |------------|---------|-----------------------------|</span>
 630 |     | <span class='neutral'>        // |    0000    |    0    |        table[0] = 0         |</span>
 631 |     | <span class='neutral'>        // |    0001    |    1    |        table[1] = 0         |</span>
 632 |     | <span class='neutral'>        // |    0010    |    2    |        table[2] = 1         |</span>
 633 |     | <span class='neutral'>        // |    0011    |    3    |        table[3] = 1         |</span>
 634 |     | <span class='neutral'>        // |    0100    |    4    |        table[4] = 2         |</span>
 635 |     | <span class='neutral'>        // |    0101    |    5    |        table[5] = 2         |</span>
 636 |     | <span class='neutral'>        // |    0110    |    6    |        table[6] = 2         |</span>
 637 |     | <span class='neutral'>        // |    0111    |    7    |        table[7] = 2         |</span>
 638 |     | <span class='neutral'>        // |    1000    |    8    |        table[8] = 3         |</span>
 639 |     | <span class='neutral'>        // |    1001    |    9    |        table[9] = 3         |</span>
 640 |     | <span class='neutral'>        // |    1010    |   10    |        table[10] = 3        |</span>
 641 |     | <span class='neutral'>        // |    1011    |   11    |        table[11] = 3        |</span>
 642 |     | <span class='neutral'>        // |    1100    |   12    |        table[12] = 3        |</span>
 643 |     | <span class='neutral'>        // |    1101    |   13    |        table[13] = 3        |</span>
 644 |     | <span class='neutral'>        // |    1110    |   14    |        table[14] = 3        |</span>
 645 |     | <span class='neutral'>        // |    1111    |   15    |        table[15] = 3        |</span>
 646 |     | <span class='neutral'>        //</span>
 647 |     | <span class='neutral'>        // The lookup table is represented as a 32-byte value with the MSB positions for 0-15 in the last 16 bytes.</span>
 648 |     | <span class='neutral'>        assembly (&quot;memory-safe&quot;) {</span>
 649 |     | <span class='neutral'>            r := or(r, byte(shr(r, x), 0x0000010102020202030303030303030300000000000000000000000000000000))</span>
 650 |     | <span class='neutral'>        }</span>
 651 |     | <span class='neutral'>    }</span>
 652 |     | <span class='neutral'></span>
 653 |     | <span class='neutral'>    /**</span>
 654 |     | <span class='neutral'>     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.</span>
 655 |     | <span class='neutral'>     * Returns 0 if given 0.</span>
 656 |     | <span class='neutral'>     */</span>
 657 |     | <span class='neutral'>    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {</span>
 658 |     | <span class='neutral'>        unchecked {</span>
 659 |     | <span class='neutral'>            uint256 result = log2(value);</span>
 660 |     | <span class='neutral'>            return result + SafeCast.toUint(unsignedRoundsUp(rounding) &amp;&amp; 1 &lt;&lt; result &lt; value);</span>
 661 |     | <span class='neutral'>        }</span>
 662 |     | <span class='neutral'>    }</span>
 663 |     | <span class='neutral'></span>
 664 |     | <span class='neutral'>    /**</span>
 665 |     | <span class='neutral'>     * @dev Return the log in base 10 of a positive value rounded towards zero.</span>
 666 |     | <span class='neutral'>     * Returns 0 if given 0.</span>
 667 |     | <span class='neutral'>     */</span>
 668 |     | <span class='neutral'>    function log10(uint256 value) internal pure returns (uint256) {</span>
 669 |     | <span class='neutral'>        uint256 result = 0;</span>
 670 |     | <span class='neutral'>        unchecked {</span>
 671 |     | <span class='neutral'>            if (value &gt;= 10 ** 64) {</span>
 672 |     | <span class='neutral'>                value /= 10 ** 64;</span>
 673 |     | <span class='neutral'>                result += 64;</span>
 674 |     | <span class='neutral'>            }</span>
 675 |     | <span class='neutral'>            if (value &gt;= 10 ** 32) {</span>
 676 |     | <span class='neutral'>                value /= 10 ** 32;</span>
 677 |     | <span class='neutral'>                result += 32;</span>
 678 |     | <span class='neutral'>            }</span>
 679 |     | <span class='neutral'>            if (value &gt;= 10 ** 16) {</span>
 680 |     | <span class='neutral'>                value /= 10 ** 16;</span>
 681 |     | <span class='neutral'>                result += 16;</span>
 682 |     | <span class='neutral'>            }</span>
 683 |     | <span class='neutral'>            if (value &gt;= 10 ** 8) {</span>
 684 |     | <span class='neutral'>                value /= 10 ** 8;</span>
 685 |     | <span class='neutral'>                result += 8;</span>
 686 |     | <span class='neutral'>            }</span>
 687 |     | <span class='neutral'>            if (value &gt;= 10 ** 4) {</span>
 688 |     | <span class='neutral'>                value /= 10 ** 4;</span>
 689 |     | <span class='neutral'>                result += 4;</span>
 690 |     | <span class='neutral'>            }</span>
 691 |     | <span class='neutral'>            if (value &gt;= 10 ** 2) {</span>
 692 |     | <span class='neutral'>                value /= 10 ** 2;</span>
 693 |     | <span class='neutral'>                result += 2;</span>
 694 |     | <span class='neutral'>            }</span>
 695 |     | <span class='neutral'>            if (value &gt;= 10 ** 1) {</span>
 696 |     | <span class='neutral'>                result += 1;</span>
 697 |     | <span class='neutral'>            }</span>
 698 |     | <span class='neutral'>        }</span>
 699 |     | <span class='neutral'>        return result;</span>
 700 |     | <span class='neutral'>    }</span>
 701 |     | <span class='neutral'></span>
 702 |     | <span class='neutral'>    /**</span>
 703 |     | <span class='neutral'>     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.</span>
 704 |     | <span class='neutral'>     * Returns 0 if given 0.</span>
 705 |     | <span class='neutral'>     */</span>
 706 |     | <span class='neutral'>    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {</span>
 707 |     | <span class='neutral'>        unchecked {</span>
 708 |     | <span class='neutral'>            uint256 result = log10(value);</span>
 709 |     | <span class='neutral'>            return result + SafeCast.toUint(unsignedRoundsUp(rounding) &amp;&amp; 10 ** result &lt; value);</span>
 710 |     | <span class='neutral'>        }</span>
 711 |     | <span class='neutral'>    }</span>
 712 |     | <span class='neutral'></span>
 713 |     | <span class='neutral'>    /**</span>
 714 |     | <span class='neutral'>     * @dev Return the log in base 256 of a positive value rounded towards zero.</span>
 715 |     | <span class='neutral'>     * Returns 0 if given 0.</span>
 716 |     | <span class='neutral'>     *</span>
 717 |     | <span class='neutral'>     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.</span>
 718 |     | <span class='neutral'>     */</span>
 719 |     | <span class='neutral'>    function log256(uint256 x) internal pure returns (uint256 r) {</span>
 720 |     | <span class='neutral'>        // If value has upper 128 bits set, log2 result is at least 128</span>
 721 |     | <span class='neutral'>        r = SafeCast.toUint(x &gt; 0xffffffffffffffffffffffffffffffff) &lt;&lt; 7;</span>
 722 |     | <span class='neutral'>        // If upper 64 bits of 128-bit half set, add 64 to result</span>
 723 |     | <span class='neutral'>        r |= SafeCast.toUint((x &gt;&gt; r) &gt; 0xffffffffffffffff) &lt;&lt; 6;</span>
 724 |     | <span class='neutral'>        // If upper 32 bits of 64-bit half set, add 32 to result</span>
 725 |     | <span class='neutral'>        r |= SafeCast.toUint((x &gt;&gt; r) &gt; 0xffffffff) &lt;&lt; 5;</span>
 726 |     | <span class='neutral'>        // If upper 16 bits of 32-bit half set, add 16 to result</span>
 727 |     | <span class='neutral'>        r |= SafeCast.toUint((x &gt;&gt; r) &gt; 0xffff) &lt;&lt; 4;</span>
 728 |     | <span class='neutral'>        // Add 1 if upper 8 bits of 16-bit half set, and divide accumulated result by 8</span>
 729 |     | <span class='neutral'>        return (r &gt;&gt; 3) | SafeCast.toUint((x &gt;&gt; r) &gt; 0xff);</span>
 730 |     | <span class='neutral'>    }</span>
 731 |     | <span class='neutral'></span>
 732 |     | <span class='neutral'>    /**</span>
 733 |     | <span class='neutral'>     * @dev Return the log in base 256, following the selected rounding direction, of a positive value.</span>
 734 |     | <span class='neutral'>     * Returns 0 if given 0.</span>
 735 |     | <span class='neutral'>     */</span>
 736 |     | <span class='neutral'>    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {</span>
 737 |     | <span class='neutral'>        unchecked {</span>
 738 |     | <span class='neutral'>            uint256 result = log256(value);</span>
 739 |     | <span class='neutral'>            return result + SafeCast.toUint(unsignedRoundsUp(rounding) &amp;&amp; 1 &lt;&lt; (result &lt;&lt; 3) &lt; value);</span>
 740 |     | <span class='neutral'>        }</span>
 741 |     | <span class='neutral'>    }</span>
 742 |     | <span class='neutral'></span>
 743 |     | <span class='neutral'>    /**</span>
 744 |     | <span class='neutral'>     * @dev Returns whether a provided rounding mode is considered rounding up for unsigned integers.</span>
 745 |     | <span class='neutral'>     */</span>
 746 |     | <span class='neutral'>    function unsignedRoundsUp(Rounding rounding) internal pure returns (bool) {</span>
 747 |     | <span class='neutral'>        return uint8(rounding) % 2 == 1;</span>
 748 |     | <span class='neutral'>    }</span>
 749 |     | <span class='neutral'>}</span>
 750 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/phantom/Documents/azemora/azemora-contracts/lib/openzeppelin-contracts/contracts/utils/math/SafeCast.sol</b>
<code>
    1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
    2 |     | <span class='neutral'>// OpenZeppelin Contracts (last updated v5.1.0) (utils/math/SafeCast.sol)</span>
    3 |     | <span class='neutral'>// This file was procedurally generated from scripts/generate/templates/SafeCast.js.</span>
    4 |     | <span class='neutral'></span>
    5 |     | <span class='neutral'>pragma solidity ^0.8.20;</span>
    6 |     | <span class='neutral'></span>
    7 |     | <span class='neutral'>/**</span>
    8 |     | <span class='neutral'> * @dev Wrappers over Solidity&#39;s uintXX/intXX/bool casting operators with added overflow</span>
    9 |     | <span class='neutral'> * checks.</span>
   10 |     | <span class='neutral'> *</span>
   11 |     | <span class='neutral'> * Downcasting from uint256/int256 in Solidity does not revert on overflow. This can</span>
   12 |     | <span class='neutral'> * easily result in undesired exploitation or bugs, since developers usually</span>
   13 |     | <span class='neutral'> * assume that overflows raise errors. `SafeCast` restores this intuition by</span>
   14 |     | <span class='neutral'> * reverting the transaction when such an operation overflows.</span>
   15 |     | <span class='neutral'> *</span>
   16 |     | <span class='neutral'> * Using this library instead of the unchecked operations eliminates an entire</span>
   17 |     | <span class='neutral'> * class of bugs, so it&#39;s recommended to use it always.</span>
   18 |     | <span class='neutral'> */</span>
   19 |     | <span class='neutral'>library SafeCast {</span>
   20 |     | <span class='neutral'>    /**</span>
   21 |     | <span class='neutral'>     * @dev Value doesn&#39;t fit in an uint of `bits` size.</span>
   22 |     | <span class='neutral'>     */</span>
   23 |     | <span class='neutral'>    error SafeCastOverflowedUintDowncast(uint8 bits, uint256 value);</span>
   24 |     | <span class='neutral'></span>
   25 |     | <span class='neutral'>    /**</span>
   26 |     | <span class='neutral'>     * @dev An int value doesn&#39;t fit in an uint of `bits` size.</span>
   27 |     | <span class='neutral'>     */</span>
   28 |     | <span class='neutral'>    error SafeCastOverflowedIntToUint(int256 value);</span>
   29 |     | <span class='neutral'></span>
   30 |     | <span class='neutral'>    /**</span>
   31 |     | <span class='neutral'>     * @dev Value doesn&#39;t fit in an int of `bits` size.</span>
   32 |     | <span class='neutral'>     */</span>
   33 |     | <span class='neutral'>    error SafeCastOverflowedIntDowncast(uint8 bits, int256 value);</span>
   34 |     | <span class='neutral'></span>
   35 |     | <span class='neutral'>    /**</span>
   36 |     | <span class='neutral'>     * @dev An uint value doesn&#39;t fit in an int of `bits` size.</span>
   37 |     | <span class='neutral'>     */</span>
   38 |     | <span class='neutral'>    error SafeCastOverflowedUintToInt(uint256 value);</span>
   39 |     | <span class='neutral'></span>
   40 |     | <span class='neutral'>    /**</span>
   41 |     | <span class='neutral'>     * @dev Returns the downcasted uint248 from uint256, reverting on</span>
   42 |     | <span class='neutral'>     * overflow (when the input is greater than largest uint248).</span>
   43 |     | <span class='neutral'>     *</span>
   44 |     | <span class='neutral'>     * Counterpart to Solidity&#39;s `uint248` operator.</span>
   45 |     | <span class='neutral'>     *</span>
   46 |     | <span class='neutral'>     * Requirements:</span>
   47 |     | <span class='neutral'>     *</span>
   48 |     | <span class='neutral'>     * - input must fit into 248 bits</span>
   49 |     | <span class='neutral'>     */</span>
   50 |     | <span class='neutral'>    function toUint248(uint256 value) internal pure returns (uint248) {</span>
   51 |     | <span class='neutral'>        if (value &gt; type(uint248).max) {</span>
   52 |     | <span class='neutral'>            revert SafeCastOverflowedUintDowncast(248, value);</span>
   53 |     | <span class='neutral'>        }</span>
   54 |     | <span class='neutral'>        return uint248(value);</span>
   55 |     | <span class='neutral'>    }</span>
   56 |     | <span class='neutral'></span>
   57 |     | <span class='neutral'>    /**</span>
   58 |     | <span class='neutral'>     * @dev Returns the downcasted uint240 from uint256, reverting on</span>
   59 |     | <span class='neutral'>     * overflow (when the input is greater than largest uint240).</span>
   60 |     | <span class='neutral'>     *</span>
   61 |     | <span class='neutral'>     * Counterpart to Solidity&#39;s `uint240` operator.</span>
   62 |     | <span class='neutral'>     *</span>
   63 |     | <span class='neutral'>     * Requirements:</span>
   64 |     | <span class='neutral'>     *</span>
   65 |     | <span class='neutral'>     * - input must fit into 240 bits</span>
   66 |     | <span class='neutral'>     */</span>
   67 |     | <span class='neutral'>    function toUint240(uint256 value) internal pure returns (uint240) {</span>
   68 |     | <span class='neutral'>        if (value &gt; type(uint240).max) {</span>
   69 |     | <span class='neutral'>            revert SafeCastOverflowedUintDowncast(240, value);</span>
   70 |     | <span class='neutral'>        }</span>
   71 |     | <span class='neutral'>        return uint240(value);</span>
   72 |     | <span class='neutral'>    }</span>
   73 |     | <span class='neutral'></span>
   74 |     | <span class='neutral'>    /**</span>
   75 |     | <span class='neutral'>     * @dev Returns the downcasted uint232 from uint256, reverting on</span>
   76 |     | <span class='neutral'>     * overflow (when the input is greater than largest uint232).</span>
   77 |     | <span class='neutral'>     *</span>
   78 |     | <span class='neutral'>     * Counterpart to Solidity&#39;s `uint232` operator.</span>
   79 |     | <span class='neutral'>     *</span>
   80 |     | <span class='neutral'>     * Requirements:</span>
   81 |     | <span class='neutral'>     *</span>
   82 |     | <span class='neutral'>     * - input must fit into 232 bits</span>
   83 |     | <span class='neutral'>     */</span>
   84 |     | <span class='neutral'>    function toUint232(uint256 value) internal pure returns (uint232) {</span>
   85 |     | <span class='neutral'>        if (value &gt; type(uint232).max) {</span>
   86 |     | <span class='neutral'>            revert SafeCastOverflowedUintDowncast(232, value);</span>
   87 |     | <span class='neutral'>        }</span>
   88 |     | <span class='neutral'>        return uint232(value);</span>
   89 |     | <span class='neutral'>    }</span>
   90 |     | <span class='neutral'></span>
   91 |     | <span class='neutral'>    /**</span>
   92 |     | <span class='neutral'>     * @dev Returns the downcasted uint224 from uint256, reverting on</span>
   93 |     | <span class='neutral'>     * overflow (when the input is greater than largest uint224).</span>
   94 |     | <span class='neutral'>     *</span>
   95 |     | <span class='neutral'>     * Counterpart to Solidity&#39;s `uint224` operator.</span>
   96 |     | <span class='neutral'>     *</span>
   97 |     | <span class='neutral'>     * Requirements:</span>
   98 |     | <span class='neutral'>     *</span>
   99 |     | <span class='neutral'>     * - input must fit into 224 bits</span>
  100 |     | <span class='neutral'>     */</span>
  101 |     | <span class='neutral'>    function toUint224(uint256 value) internal pure returns (uint224) {</span>
  102 |     | <span class='neutral'>        if (value &gt; type(uint224).max) {</span>
  103 |     | <span class='neutral'>            revert SafeCastOverflowedUintDowncast(224, value);</span>
  104 |     | <span class='neutral'>        }</span>
  105 |     | <span class='neutral'>        return uint224(value);</span>
  106 |     | <span class='neutral'>    }</span>
  107 |     | <span class='neutral'></span>
  108 |     | <span class='neutral'>    /**</span>
  109 |     | <span class='neutral'>     * @dev Returns the downcasted uint216 from uint256, reverting on</span>
  110 |     | <span class='neutral'>     * overflow (when the input is greater than largest uint216).</span>
  111 |     | <span class='neutral'>     *</span>
  112 |     | <span class='neutral'>     * Counterpart to Solidity&#39;s `uint216` operator.</span>
  113 |     | <span class='neutral'>     *</span>
  114 |     | <span class='neutral'>     * Requirements:</span>
  115 |     | <span class='neutral'>     *</span>
  116 |     | <span class='neutral'>     * - input must fit into 216 bits</span>
  117 |     | <span class='neutral'>     */</span>
  118 |     | <span class='neutral'>    function toUint216(uint256 value) internal pure returns (uint216) {</span>
  119 |     | <span class='neutral'>        if (value &gt; type(uint216).max) {</span>
  120 |     | <span class='neutral'>            revert SafeCastOverflowedUintDowncast(216, value);</span>
  121 |     | <span class='neutral'>        }</span>
  122 |     | <span class='neutral'>        return uint216(value);</span>
  123 |     | <span class='neutral'>    }</span>
  124 |     | <span class='neutral'></span>
  125 |     | <span class='neutral'>    /**</span>
  126 |     | <span class='neutral'>     * @dev Returns the downcasted uint208 from uint256, reverting on</span>
  127 |     | <span class='neutral'>     * overflow (when the input is greater than largest uint208).</span>
  128 |     | <span class='neutral'>     *</span>
  129 |     | <span class='neutral'>     * Counterpart to Solidity&#39;s `uint208` operator.</span>
  130 |     | <span class='neutral'>     *</span>
  131 |     | <span class='neutral'>     * Requirements:</span>
  132 |     | <span class='neutral'>     *</span>
  133 |     | <span class='neutral'>     * - input must fit into 208 bits</span>
  134 |     | <span class='neutral'>     */</span>
  135 |     | <span class='neutral'>    function toUint208(uint256 value) internal pure returns (uint208) {</span>
  136 |     | <span class='neutral'>        if (value &gt; type(uint208).max) {</span>
  137 |     | <span class='neutral'>            revert SafeCastOverflowedUintDowncast(208, value);</span>
  138 |     | <span class='neutral'>        }</span>
  139 |     | <span class='neutral'>        return uint208(value);</span>
  140 |     | <span class='neutral'>    }</span>
  141 |     | <span class='neutral'></span>
  142 |     | <span class='neutral'>    /**</span>
  143 |     | <span class='neutral'>     * @dev Returns the downcasted uint200 from uint256, reverting on</span>
  144 |     | <span class='neutral'>     * overflow (when the input is greater than largest uint200).</span>
  145 |     | <span class='neutral'>     *</span>
  146 |     | <span class='neutral'>     * Counterpart to Solidity&#39;s `uint200` operator.</span>
  147 |     | <span class='neutral'>     *</span>
  148 |     | <span class='neutral'>     * Requirements:</span>
  149 |     | <span class='neutral'>     *</span>
  150 |     | <span class='neutral'>     * - input must fit into 200 bits</span>
  151 |     | <span class='neutral'>     */</span>
  152 |     | <span class='neutral'>    function toUint200(uint256 value) internal pure returns (uint200) {</span>
  153 |     | <span class='neutral'>        if (value &gt; type(uint200).max) {</span>
  154 |     | <span class='neutral'>            revert SafeCastOverflowedUintDowncast(200, value);</span>
  155 |     | <span class='neutral'>        }</span>
  156 |     | <span class='neutral'>        return uint200(value);</span>
  157 |     | <span class='neutral'>    }</span>
  158 |     | <span class='neutral'></span>
  159 |     | <span class='neutral'>    /**</span>
  160 |     | <span class='neutral'>     * @dev Returns the downcasted uint192 from uint256, reverting on</span>
  161 |     | <span class='neutral'>     * overflow (when the input is greater than largest uint192).</span>
  162 |     | <span class='neutral'>     *</span>
  163 |     | <span class='neutral'>     * Counterpart to Solidity&#39;s `uint192` operator.</span>
  164 |     | <span class='neutral'>     *</span>
  165 |     | <span class='neutral'>     * Requirements:</span>
  166 |     | <span class='neutral'>     *</span>
  167 |     | <span class='neutral'>     * - input must fit into 192 bits</span>
  168 |     | <span class='neutral'>     */</span>
  169 |     | <span class='neutral'>    function toUint192(uint256 value) internal pure returns (uint192) {</span>
  170 |     | <span class='neutral'>        if (value &gt; type(uint192).max) {</span>
  171 |     | <span class='neutral'>            revert SafeCastOverflowedUintDowncast(192, value);</span>
  172 |     | <span class='neutral'>        }</span>
  173 |     | <span class='neutral'>        return uint192(value);</span>
  174 |     | <span class='neutral'>    }</span>
  175 |     | <span class='neutral'></span>
  176 |     | <span class='neutral'>    /**</span>
  177 |     | <span class='neutral'>     * @dev Returns the downcasted uint184 from uint256, reverting on</span>
  178 |     | <span class='neutral'>     * overflow (when the input is greater than largest uint184).</span>
  179 |     | <span class='neutral'>     *</span>
  180 |     | <span class='neutral'>     * Counterpart to Solidity&#39;s `uint184` operator.</span>
  181 |     | <span class='neutral'>     *</span>
  182 |     | <span class='neutral'>     * Requirements:</span>
  183 |     | <span class='neutral'>     *</span>
  184 |     | <span class='neutral'>     * - input must fit into 184 bits</span>
  185 |     | <span class='neutral'>     */</span>
  186 |     | <span class='neutral'>    function toUint184(uint256 value) internal pure returns (uint184) {</span>
  187 |     | <span class='neutral'>        if (value &gt; type(uint184).max) {</span>
  188 |     | <span class='neutral'>            revert SafeCastOverflowedUintDowncast(184, value);</span>
  189 |     | <span class='neutral'>        }</span>
  190 |     | <span class='neutral'>        return uint184(value);</span>
  191 |     | <span class='neutral'>    }</span>
  192 |     | <span class='neutral'></span>
  193 |     | <span class='neutral'>    /**</span>
  194 |     | <span class='neutral'>     * @dev Returns the downcasted uint176 from uint256, reverting on</span>
  195 |     | <span class='neutral'>     * overflow (when the input is greater than largest uint176).</span>
  196 |     | <span class='neutral'>     *</span>
  197 |     | <span class='neutral'>     * Counterpart to Solidity&#39;s `uint176` operator.</span>
  198 |     | <span class='neutral'>     *</span>
  199 |     | <span class='neutral'>     * Requirements:</span>
  200 |     | <span class='neutral'>     *</span>
  201 |     | <span class='neutral'>     * - input must fit into 176 bits</span>
  202 |     | <span class='neutral'>     */</span>
  203 |     | <span class='neutral'>    function toUint176(uint256 value) internal pure returns (uint176) {</span>
  204 |     | <span class='neutral'>        if (value &gt; type(uint176).max) {</span>
  205 |     | <span class='neutral'>            revert SafeCastOverflowedUintDowncast(176, value);</span>
  206 |     | <span class='neutral'>        }</span>
  207 |     | <span class='neutral'>        return uint176(value);</span>
  208 |     | <span class='neutral'>    }</span>
  209 |     | <span class='neutral'></span>
  210 |     | <span class='neutral'>    /**</span>
  211 |     | <span class='neutral'>     * @dev Returns the downcasted uint168 from uint256, reverting on</span>
  212 |     | <span class='neutral'>     * overflow (when the input is greater than largest uint168).</span>
  213 |     | <span class='neutral'>     *</span>
  214 |     | <span class='neutral'>     * Counterpart to Solidity&#39;s `uint168` operator.</span>
  215 |     | <span class='neutral'>     *</span>
  216 |     | <span class='neutral'>     * Requirements:</span>
  217 |     | <span class='neutral'>     *</span>
  218 |     | <span class='neutral'>     * - input must fit into 168 bits</span>
  219 |     | <span class='neutral'>     */</span>
  220 |     | <span class='neutral'>    function toUint168(uint256 value) internal pure returns (uint168) {</span>
  221 |     | <span class='neutral'>        if (value &gt; type(uint168).max) {</span>
  222 |     | <span class='neutral'>            revert SafeCastOverflowedUintDowncast(168, value);</span>
  223 |     | <span class='neutral'>        }</span>
  224 |     | <span class='neutral'>        return uint168(value);</span>
  225 |     | <span class='neutral'>    }</span>
  226 |     | <span class='neutral'></span>
  227 |     | <span class='neutral'>    /**</span>
  228 |     | <span class='neutral'>     * @dev Returns the downcasted uint160 from uint256, reverting on</span>
  229 |     | <span class='neutral'>     * overflow (when the input is greater than largest uint160).</span>
  230 |     | <span class='neutral'>     *</span>
  231 |     | <span class='neutral'>     * Counterpart to Solidity&#39;s `uint160` operator.</span>
  232 |     | <span class='neutral'>     *</span>
  233 |     | <span class='neutral'>     * Requirements:</span>
  234 |     | <span class='neutral'>     *</span>
  235 |     | <span class='neutral'>     * - input must fit into 160 bits</span>
  236 |     | <span class='neutral'>     */</span>
  237 |     | <span class='neutral'>    function toUint160(uint256 value) internal pure returns (uint160) {</span>
  238 |     | <span class='neutral'>        if (value &gt; type(uint160).max) {</span>
  239 |     | <span class='neutral'>            revert SafeCastOverflowedUintDowncast(160, value);</span>
  240 |     | <span class='neutral'>        }</span>
  241 |     | <span class='neutral'>        return uint160(value);</span>
  242 |     | <span class='neutral'>    }</span>
  243 |     | <span class='neutral'></span>
  244 |     | <span class='neutral'>    /**</span>
  245 |     | <span class='neutral'>     * @dev Returns the downcasted uint152 from uint256, reverting on</span>
  246 |     | <span class='neutral'>     * overflow (when the input is greater than largest uint152).</span>
  247 |     | <span class='neutral'>     *</span>
  248 |     | <span class='neutral'>     * Counterpart to Solidity&#39;s `uint152` operator.</span>
  249 |     | <span class='neutral'>     *</span>
  250 |     | <span class='neutral'>     * Requirements:</span>
  251 |     | <span class='neutral'>     *</span>
  252 |     | <span class='neutral'>     * - input must fit into 152 bits</span>
  253 |     | <span class='neutral'>     */</span>
  254 |     | <span class='neutral'>    function toUint152(uint256 value) internal pure returns (uint152) {</span>
  255 |     | <span class='neutral'>        if (value &gt; type(uint152).max) {</span>
  256 |     | <span class='neutral'>            revert SafeCastOverflowedUintDowncast(152, value);</span>
  257 |     | <span class='neutral'>        }</span>
  258 |     | <span class='neutral'>        return uint152(value);</span>
  259 |     | <span class='neutral'>    }</span>
  260 |     | <span class='neutral'></span>
  261 |     | <span class='neutral'>    /**</span>
  262 |     | <span class='neutral'>     * @dev Returns the downcasted uint144 from uint256, reverting on</span>
  263 |     | <span class='neutral'>     * overflow (when the input is greater than largest uint144).</span>
  264 |     | <span class='neutral'>     *</span>
  265 |     | <span class='neutral'>     * Counterpart to Solidity&#39;s `uint144` operator.</span>
  266 |     | <span class='neutral'>     *</span>
  267 |     | <span class='neutral'>     * Requirements:</span>
  268 |     | <span class='neutral'>     *</span>
  269 |     | <span class='neutral'>     * - input must fit into 144 bits</span>
  270 |     | <span class='neutral'>     */</span>
  271 |     | <span class='neutral'>    function toUint144(uint256 value) internal pure returns (uint144) {</span>
  272 |     | <span class='neutral'>        if (value &gt; type(uint144).max) {</span>
  273 |     | <span class='neutral'>            revert SafeCastOverflowedUintDowncast(144, value);</span>
  274 |     | <span class='neutral'>        }</span>
  275 |     | <span class='neutral'>        return uint144(value);</span>
  276 |     | <span class='neutral'>    }</span>
  277 |     | <span class='neutral'></span>
  278 |     | <span class='neutral'>    /**</span>
  279 |     | <span class='neutral'>     * @dev Returns the downcasted uint136 from uint256, reverting on</span>
  280 |     | <span class='neutral'>     * overflow (when the input is greater than largest uint136).</span>
  281 |     | <span class='neutral'>     *</span>
  282 |     | <span class='neutral'>     * Counterpart to Solidity&#39;s `uint136` operator.</span>
  283 |     | <span class='neutral'>     *</span>
  284 |     | <span class='neutral'>     * Requirements:</span>
  285 |     | <span class='neutral'>     *</span>
  286 |     | <span class='neutral'>     * - input must fit into 136 bits</span>
  287 |     | <span class='neutral'>     */</span>
  288 |     | <span class='neutral'>    function toUint136(uint256 value) internal pure returns (uint136) {</span>
  289 |     | <span class='neutral'>        if (value &gt; type(uint136).max) {</span>
  290 |     | <span class='neutral'>            revert SafeCastOverflowedUintDowncast(136, value);</span>
  291 |     | <span class='neutral'>        }</span>
  292 |     | <span class='neutral'>        return uint136(value);</span>
  293 |     | <span class='neutral'>    }</span>
  294 |     | <span class='neutral'></span>
  295 |     | <span class='neutral'>    /**</span>
  296 |     | <span class='neutral'>     * @dev Returns the downcasted uint128 from uint256, reverting on</span>
  297 |     | <span class='neutral'>     * overflow (when the input is greater than largest uint128).</span>
  298 |     | <span class='neutral'>     *</span>
  299 |     | <span class='neutral'>     * Counterpart to Solidity&#39;s `uint128` operator.</span>
  300 |     | <span class='neutral'>     *</span>
  301 |     | <span class='neutral'>     * Requirements:</span>
  302 |     | <span class='neutral'>     *</span>
  303 |     | <span class='neutral'>     * - input must fit into 128 bits</span>
  304 |     | <span class='neutral'>     */</span>
  305 |     | <span class='neutral'>    function toUint128(uint256 value) internal pure returns (uint128) {</span>
  306 |     | <span class='neutral'>        if (value &gt; type(uint128).max) {</span>
  307 |     | <span class='neutral'>            revert SafeCastOverflowedUintDowncast(128, value);</span>
  308 |     | <span class='neutral'>        }</span>
  309 |     | <span class='neutral'>        return uint128(value);</span>
  310 |     | <span class='neutral'>    }</span>
  311 |     | <span class='neutral'></span>
  312 |     | <span class='neutral'>    /**</span>
  313 |     | <span class='neutral'>     * @dev Returns the downcasted uint120 from uint256, reverting on</span>
  314 |     | <span class='neutral'>     * overflow (when the input is greater than largest uint120).</span>
  315 |     | <span class='neutral'>     *</span>
  316 |     | <span class='neutral'>     * Counterpart to Solidity&#39;s `uint120` operator.</span>
  317 |     | <span class='neutral'>     *</span>
  318 |     | <span class='neutral'>     * Requirements:</span>
  319 |     | <span class='neutral'>     *</span>
  320 |     | <span class='neutral'>     * - input must fit into 120 bits</span>
  321 |     | <span class='neutral'>     */</span>
  322 |     | <span class='neutral'>    function toUint120(uint256 value) internal pure returns (uint120) {</span>
  323 |     | <span class='neutral'>        if (value &gt; type(uint120).max) {</span>
  324 |     | <span class='neutral'>            revert SafeCastOverflowedUintDowncast(120, value);</span>
  325 |     | <span class='neutral'>        }</span>
  326 |     | <span class='neutral'>        return uint120(value);</span>
  327 |     | <span class='neutral'>    }</span>
  328 |     | <span class='neutral'></span>
  329 |     | <span class='neutral'>    /**</span>
  330 |     | <span class='neutral'>     * @dev Returns the downcasted uint112 from uint256, reverting on</span>
  331 |     | <span class='neutral'>     * overflow (when the input is greater than largest uint112).</span>
  332 |     | <span class='neutral'>     *</span>
  333 |     | <span class='neutral'>     * Counterpart to Solidity&#39;s `uint112` operator.</span>
  334 |     | <span class='neutral'>     *</span>
  335 |     | <span class='neutral'>     * Requirements:</span>
  336 |     | <span class='neutral'>     *</span>
  337 |     | <span class='neutral'>     * - input must fit into 112 bits</span>
  338 |     | <span class='neutral'>     */</span>
  339 |     | <span class='neutral'>    function toUint112(uint256 value) internal pure returns (uint112) {</span>
  340 |     | <span class='neutral'>        if (value &gt; type(uint112).max) {</span>
  341 |     | <span class='neutral'>            revert SafeCastOverflowedUintDowncast(112, value);</span>
  342 |     | <span class='neutral'>        }</span>
  343 |     | <span class='neutral'>        return uint112(value);</span>
  344 |     | <span class='neutral'>    }</span>
  345 |     | <span class='neutral'></span>
  346 |     | <span class='neutral'>    /**</span>
  347 |     | <span class='neutral'>     * @dev Returns the downcasted uint104 from uint256, reverting on</span>
  348 |     | <span class='neutral'>     * overflow (when the input is greater than largest uint104).</span>
  349 |     | <span class='neutral'>     *</span>
  350 |     | <span class='neutral'>     * Counterpart to Solidity&#39;s `uint104` operator.</span>
  351 |     | <span class='neutral'>     *</span>
  352 |     | <span class='neutral'>     * Requirements:</span>
  353 |     | <span class='neutral'>     *</span>
  354 |     | <span class='neutral'>     * - input must fit into 104 bits</span>
  355 |     | <span class='neutral'>     */</span>
  356 |     | <span class='neutral'>    function toUint104(uint256 value) internal pure returns (uint104) {</span>
  357 |     | <span class='neutral'>        if (value &gt; type(uint104).max) {</span>
  358 |     | <span class='neutral'>            revert SafeCastOverflowedUintDowncast(104, value);</span>
  359 |     | <span class='neutral'>        }</span>
  360 |     | <span class='neutral'>        return uint104(value);</span>
  361 |     | <span class='neutral'>    }</span>
  362 |     | <span class='neutral'></span>
  363 |     | <span class='neutral'>    /**</span>
  364 |     | <span class='neutral'>     * @dev Returns the downcasted uint96 from uint256, reverting on</span>
  365 |     | <span class='neutral'>     * overflow (when the input is greater than largest uint96).</span>
  366 |     | <span class='neutral'>     *</span>
  367 |     | <span class='neutral'>     * Counterpart to Solidity&#39;s `uint96` operator.</span>
  368 |     | <span class='neutral'>     *</span>
  369 |     | <span class='neutral'>     * Requirements:</span>
  370 |     | <span class='neutral'>     *</span>
  371 |     | <span class='neutral'>     * - input must fit into 96 bits</span>
  372 |     | <span class='neutral'>     */</span>
  373 |     | <span class='neutral'>    function toUint96(uint256 value) internal pure returns (uint96) {</span>
  374 |     | <span class='neutral'>        if (value &gt; type(uint96).max) {</span>
  375 |     | <span class='neutral'>            revert SafeCastOverflowedUintDowncast(96, value);</span>
  376 |     | <span class='neutral'>        }</span>
  377 |     | <span class='neutral'>        return uint96(value);</span>
  378 |     | <span class='neutral'>    }</span>
  379 |     | <span class='neutral'></span>
  380 |     | <span class='neutral'>    /**</span>
  381 |     | <span class='neutral'>     * @dev Returns the downcasted uint88 from uint256, reverting on</span>
  382 |     | <span class='neutral'>     * overflow (when the input is greater than largest uint88).</span>
  383 |     | <span class='neutral'>     *</span>
  384 |     | <span class='neutral'>     * Counterpart to Solidity&#39;s `uint88` operator.</span>
  385 |     | <span class='neutral'>     *</span>
  386 |     | <span class='neutral'>     * Requirements:</span>
  387 |     | <span class='neutral'>     *</span>
  388 |     | <span class='neutral'>     * - input must fit into 88 bits</span>
  389 |     | <span class='neutral'>     */</span>
  390 |     | <span class='neutral'>    function toUint88(uint256 value) internal pure returns (uint88) {</span>
  391 |     | <span class='neutral'>        if (value &gt; type(uint88).max) {</span>
  392 |     | <span class='neutral'>            revert SafeCastOverflowedUintDowncast(88, value);</span>
  393 |     | <span class='neutral'>        }</span>
  394 |     | <span class='neutral'>        return uint88(value);</span>
  395 |     | <span class='neutral'>    }</span>
  396 |     | <span class='neutral'></span>
  397 |     | <span class='neutral'>    /**</span>
  398 |     | <span class='neutral'>     * @dev Returns the downcasted uint80 from uint256, reverting on</span>
  399 |     | <span class='neutral'>     * overflow (when the input is greater than largest uint80).</span>
  400 |     | <span class='neutral'>     *</span>
  401 |     | <span class='neutral'>     * Counterpart to Solidity&#39;s `uint80` operator.</span>
  402 |     | <span class='neutral'>     *</span>
  403 |     | <span class='neutral'>     * Requirements:</span>
  404 |     | <span class='neutral'>     *</span>
  405 |     | <span class='neutral'>     * - input must fit into 80 bits</span>
  406 |     | <span class='neutral'>     */</span>
  407 |     | <span class='neutral'>    function toUint80(uint256 value) internal pure returns (uint80) {</span>
  408 |     | <span class='neutral'>        if (value &gt; type(uint80).max) {</span>
  409 |     | <span class='neutral'>            revert SafeCastOverflowedUintDowncast(80, value);</span>
  410 |     | <span class='neutral'>        }</span>
  411 |     | <span class='neutral'>        return uint80(value);</span>
  412 |     | <span class='neutral'>    }</span>
  413 |     | <span class='neutral'></span>
  414 |     | <span class='neutral'>    /**</span>
  415 |     | <span class='neutral'>     * @dev Returns the downcasted uint72 from uint256, reverting on</span>
  416 |     | <span class='neutral'>     * overflow (when the input is greater than largest uint72).</span>
  417 |     | <span class='neutral'>     *</span>
  418 |     | <span class='neutral'>     * Counterpart to Solidity&#39;s `uint72` operator.</span>
  419 |     | <span class='neutral'>     *</span>
  420 |     | <span class='neutral'>     * Requirements:</span>
  421 |     | <span class='neutral'>     *</span>
  422 |     | <span class='neutral'>     * - input must fit into 72 bits</span>
  423 |     | <span class='neutral'>     */</span>
  424 |     | <span class='neutral'>    function toUint72(uint256 value) internal pure returns (uint72) {</span>
  425 |     | <span class='neutral'>        if (value &gt; type(uint72).max) {</span>
  426 |     | <span class='neutral'>            revert SafeCastOverflowedUintDowncast(72, value);</span>
  427 |     | <span class='neutral'>        }</span>
  428 |     | <span class='neutral'>        return uint72(value);</span>
  429 |     | <span class='neutral'>    }</span>
  430 |     | <span class='neutral'></span>
  431 |     | <span class='neutral'>    /**</span>
  432 |     | <span class='neutral'>     * @dev Returns the downcasted uint64 from uint256, reverting on</span>
  433 |     | <span class='neutral'>     * overflow (when the input is greater than largest uint64).</span>
  434 |     | <span class='neutral'>     *</span>
  435 |     | <span class='neutral'>     * Counterpart to Solidity&#39;s `uint64` operator.</span>
  436 |     | <span class='neutral'>     *</span>
  437 |     | <span class='neutral'>     * Requirements:</span>
  438 |     | <span class='neutral'>     *</span>
  439 |     | <span class='neutral'>     * - input must fit into 64 bits</span>
  440 |     | <span class='neutral'>     */</span>
  441 |     | <span class='neutral'>    function toUint64(uint256 value) internal pure returns (uint64) {</span>
  442 |     | <span class='neutral'>        if (value &gt; type(uint64).max) {</span>
  443 |     | <span class='neutral'>            revert SafeCastOverflowedUintDowncast(64, value);</span>
  444 |     | <span class='neutral'>        }</span>
  445 |     | <span class='neutral'>        return uint64(value);</span>
  446 |     | <span class='neutral'>    }</span>
  447 |     | <span class='neutral'></span>
  448 |     | <span class='neutral'>    /**</span>
  449 |     | <span class='neutral'>     * @dev Returns the downcasted uint56 from uint256, reverting on</span>
  450 |     | <span class='neutral'>     * overflow (when the input is greater than largest uint56).</span>
  451 |     | <span class='neutral'>     *</span>
  452 |     | <span class='neutral'>     * Counterpart to Solidity&#39;s `uint56` operator.</span>
  453 |     | <span class='neutral'>     *</span>
  454 |     | <span class='neutral'>     * Requirements:</span>
  455 |     | <span class='neutral'>     *</span>
  456 |     | <span class='neutral'>     * - input must fit into 56 bits</span>
  457 |     | <span class='neutral'>     */</span>
  458 |     | <span class='neutral'>    function toUint56(uint256 value) internal pure returns (uint56) {</span>
  459 |     | <span class='neutral'>        if (value &gt; type(uint56).max) {</span>
  460 |     | <span class='neutral'>            revert SafeCastOverflowedUintDowncast(56, value);</span>
  461 |     | <span class='neutral'>        }</span>
  462 |     | <span class='neutral'>        return uint56(value);</span>
  463 |     | <span class='neutral'>    }</span>
  464 |     | <span class='neutral'></span>
  465 |     | <span class='neutral'>    /**</span>
  466 |     | <span class='neutral'>     * @dev Returns the downcasted uint48 from uint256, reverting on</span>
  467 |     | <span class='neutral'>     * overflow (when the input is greater than largest uint48).</span>
  468 |     | <span class='neutral'>     *</span>
  469 |     | <span class='neutral'>     * Counterpart to Solidity&#39;s `uint48` operator.</span>
  470 |     | <span class='neutral'>     *</span>
  471 |     | <span class='neutral'>     * Requirements:</span>
  472 |     | <span class='neutral'>     *</span>
  473 |     | <span class='neutral'>     * - input must fit into 48 bits</span>
  474 |     | <span class='neutral'>     */</span>
  475 |     | <span class='neutral'>    function toUint48(uint256 value) internal pure returns (uint48) {</span>
  476 |     | <span class='neutral'>        if (value &gt; type(uint48).max) {</span>
  477 |     | <span class='neutral'>            revert SafeCastOverflowedUintDowncast(48, value);</span>
  478 |     | <span class='neutral'>        }</span>
  479 |     | <span class='neutral'>        return uint48(value);</span>
  480 |     | <span class='neutral'>    }</span>
  481 |     | <span class='neutral'></span>
  482 |     | <span class='neutral'>    /**</span>
  483 |     | <span class='neutral'>     * @dev Returns the downcasted uint40 from uint256, reverting on</span>
  484 |     | <span class='neutral'>     * overflow (when the input is greater than largest uint40).</span>
  485 |     | <span class='neutral'>     *</span>
  486 |     | <span class='neutral'>     * Counterpart to Solidity&#39;s `uint40` operator.</span>
  487 |     | <span class='neutral'>     *</span>
  488 |     | <span class='neutral'>     * Requirements:</span>
  489 |     | <span class='neutral'>     *</span>
  490 |     | <span class='neutral'>     * - input must fit into 40 bits</span>
  491 |     | <span class='neutral'>     */</span>
  492 |     | <span class='neutral'>    function toUint40(uint256 value) internal pure returns (uint40) {</span>
  493 |     | <span class='neutral'>        if (value &gt; type(uint40).max) {</span>
  494 |     | <span class='neutral'>            revert SafeCastOverflowedUintDowncast(40, value);</span>
  495 |     | <span class='neutral'>        }</span>
  496 |     | <span class='neutral'>        return uint40(value);</span>
  497 |     | <span class='neutral'>    }</span>
  498 |     | <span class='neutral'></span>
  499 |     | <span class='neutral'>    /**</span>
  500 |     | <span class='neutral'>     * @dev Returns the downcasted uint32 from uint256, reverting on</span>
  501 |     | <span class='neutral'>     * overflow (when the input is greater than largest uint32).</span>
  502 |     | <span class='neutral'>     *</span>
  503 |     | <span class='neutral'>     * Counterpart to Solidity&#39;s `uint32` operator.</span>
  504 |     | <span class='neutral'>     *</span>
  505 |     | <span class='neutral'>     * Requirements:</span>
  506 |     | <span class='neutral'>     *</span>
  507 |     | <span class='neutral'>     * - input must fit into 32 bits</span>
  508 |     | <span class='neutral'>     */</span>
  509 |     | <span class='neutral'>    function toUint32(uint256 value) internal pure returns (uint32) {</span>
  510 |     | <span class='neutral'>        if (value &gt; type(uint32).max) {</span>
  511 |     | <span class='neutral'>            revert SafeCastOverflowedUintDowncast(32, value);</span>
  512 |     | <span class='neutral'>        }</span>
  513 |     | <span class='neutral'>        return uint32(value);</span>
  514 |     | <span class='neutral'>    }</span>
  515 |     | <span class='neutral'></span>
  516 |     | <span class='neutral'>    /**</span>
  517 |     | <span class='neutral'>     * @dev Returns the downcasted uint24 from uint256, reverting on</span>
  518 |     | <span class='neutral'>     * overflow (when the input is greater than largest uint24).</span>
  519 |     | <span class='neutral'>     *</span>
  520 |     | <span class='neutral'>     * Counterpart to Solidity&#39;s `uint24` operator.</span>
  521 |     | <span class='neutral'>     *</span>
  522 |     | <span class='neutral'>     * Requirements:</span>
  523 |     | <span class='neutral'>     *</span>
  524 |     | <span class='neutral'>     * - input must fit into 24 bits</span>
  525 |     | <span class='neutral'>     */</span>
  526 |     | <span class='neutral'>    function toUint24(uint256 value) internal pure returns (uint24) {</span>
  527 |     | <span class='neutral'>        if (value &gt; type(uint24).max) {</span>
  528 |     | <span class='neutral'>            revert SafeCastOverflowedUintDowncast(24, value);</span>
  529 |     | <span class='neutral'>        }</span>
  530 |     | <span class='neutral'>        return uint24(value);</span>
  531 |     | <span class='neutral'>    }</span>
  532 |     | <span class='neutral'></span>
  533 |     | <span class='neutral'>    /**</span>
  534 |     | <span class='neutral'>     * @dev Returns the downcasted uint16 from uint256, reverting on</span>
  535 |     | <span class='neutral'>     * overflow (when the input is greater than largest uint16).</span>
  536 |     | <span class='neutral'>     *</span>
  537 |     | <span class='neutral'>     * Counterpart to Solidity&#39;s `uint16` operator.</span>
  538 |     | <span class='neutral'>     *</span>
  539 |     | <span class='neutral'>     * Requirements:</span>
  540 |     | <span class='neutral'>     *</span>
  541 |     | <span class='neutral'>     * - input must fit into 16 bits</span>
  542 |     | <span class='neutral'>     */</span>
  543 |     | <span class='neutral'>    function toUint16(uint256 value) internal pure returns (uint16) {</span>
  544 |     | <span class='neutral'>        if (value &gt; type(uint16).max) {</span>
  545 |     | <span class='neutral'>            revert SafeCastOverflowedUintDowncast(16, value);</span>
  546 |     | <span class='neutral'>        }</span>
  547 |     | <span class='neutral'>        return uint16(value);</span>
  548 |     | <span class='neutral'>    }</span>
  549 |     | <span class='neutral'></span>
  550 |     | <span class='neutral'>    /**</span>
  551 |     | <span class='neutral'>     * @dev Returns the downcasted uint8 from uint256, reverting on</span>
  552 |     | <span class='neutral'>     * overflow (when the input is greater than largest uint8).</span>
  553 |     | <span class='neutral'>     *</span>
  554 |     | <span class='neutral'>     * Counterpart to Solidity&#39;s `uint8` operator.</span>
  555 |     | <span class='neutral'>     *</span>
  556 |     | <span class='neutral'>     * Requirements:</span>
  557 |     | <span class='neutral'>     *</span>
  558 |     | <span class='neutral'>     * - input must fit into 8 bits</span>
  559 |     | <span class='neutral'>     */</span>
  560 |     | <span class='neutral'>    function toUint8(uint256 value) internal pure returns (uint8) {</span>
  561 |     | <span class='neutral'>        if (value &gt; type(uint8).max) {</span>
  562 |     | <span class='neutral'>            revert SafeCastOverflowedUintDowncast(8, value);</span>
  563 |     | <span class='neutral'>        }</span>
  564 |     | <span class='neutral'>        return uint8(value);</span>
  565 |     | <span class='neutral'>    }</span>
  566 |     | <span class='neutral'></span>
  567 |     | <span class='neutral'>    /**</span>
  568 |     | <span class='neutral'>     * @dev Converts a signed int256 into an unsigned uint256.</span>
  569 |     | <span class='neutral'>     *</span>
  570 |     | <span class='neutral'>     * Requirements:</span>
  571 |     | <span class='neutral'>     *</span>
  572 |     | <span class='neutral'>     * - input must be greater than or equal to 0.</span>
  573 |     | <span class='neutral'>     */</span>
  574 |     | <span class='neutral'>    function toUint256(int256 value) internal pure returns (uint256) {</span>
  575 |     | <span class='neutral'>        if (value &lt; 0) {</span>
  576 |     | <span class='neutral'>            revert SafeCastOverflowedIntToUint(value);</span>
  577 |     | <span class='neutral'>        }</span>
  578 |     | <span class='neutral'>        return uint256(value);</span>
  579 |     | <span class='neutral'>    }</span>
  580 |     | <span class='neutral'></span>
  581 |     | <span class='neutral'>    /**</span>
  582 |     | <span class='neutral'>     * @dev Returns the downcasted int248 from int256, reverting on</span>
  583 |     | <span class='neutral'>     * overflow (when the input is less than smallest int248 or</span>
  584 |     | <span class='neutral'>     * greater than largest int248).</span>
  585 |     | <span class='neutral'>     *</span>
  586 |     | <span class='neutral'>     * Counterpart to Solidity&#39;s `int248` operator.</span>
  587 |     | <span class='neutral'>     *</span>
  588 |     | <span class='neutral'>     * Requirements:</span>
  589 |     | <span class='neutral'>     *</span>
  590 |     | <span class='neutral'>     * - input must fit into 248 bits</span>
  591 |     | <span class='neutral'>     */</span>
  592 |     | <span class='neutral'>    function toInt248(int256 value) internal pure returns (int248 downcasted) {</span>
  593 |     | <span class='neutral'>        downcasted = int248(value);</span>
  594 |     | <span class='neutral'>        if (downcasted != value) {</span>
  595 |     | <span class='neutral'>            revert SafeCastOverflowedIntDowncast(248, value);</span>
  596 |     | <span class='neutral'>        }</span>
  597 |     | <span class='neutral'>    }</span>
  598 |     | <span class='neutral'></span>
  599 |     | <span class='neutral'>    /**</span>
  600 |     | <span class='neutral'>     * @dev Returns the downcasted int240 from int256, reverting on</span>
  601 |     | <span class='neutral'>     * overflow (when the input is less than smallest int240 or</span>
  602 |     | <span class='neutral'>     * greater than largest int240).</span>
  603 |     | <span class='neutral'>     *</span>
  604 |     | <span class='neutral'>     * Counterpart to Solidity&#39;s `int240` operator.</span>
  605 |     | <span class='neutral'>     *</span>
  606 |     | <span class='neutral'>     * Requirements:</span>
  607 |     | <span class='neutral'>     *</span>
  608 |     | <span class='neutral'>     * - input must fit into 240 bits</span>
  609 |     | <span class='neutral'>     */</span>
  610 |     | <span class='neutral'>    function toInt240(int256 value) internal pure returns (int240 downcasted) {</span>
  611 |     | <span class='neutral'>        downcasted = int240(value);</span>
  612 |     | <span class='neutral'>        if (downcasted != value) {</span>
  613 |     | <span class='neutral'>            revert SafeCastOverflowedIntDowncast(240, value);</span>
  614 |     | <span class='neutral'>        }</span>
  615 |     | <span class='neutral'>    }</span>
  616 |     | <span class='neutral'></span>
  617 |     | <span class='neutral'>    /**</span>
  618 |     | <span class='neutral'>     * @dev Returns the downcasted int232 from int256, reverting on</span>
  619 |     | <span class='neutral'>     * overflow (when the input is less than smallest int232 or</span>
  620 |     | <span class='neutral'>     * greater than largest int232).</span>
  621 |     | <span class='neutral'>     *</span>
  622 |     | <span class='neutral'>     * Counterpart to Solidity&#39;s `int232` operator.</span>
  623 |     | <span class='neutral'>     *</span>
  624 |     | <span class='neutral'>     * Requirements:</span>
  625 |     | <span class='neutral'>     *</span>
  626 |     | <span class='neutral'>     * - input must fit into 232 bits</span>
  627 |     | <span class='neutral'>     */</span>
  628 |     | <span class='neutral'>    function toInt232(int256 value) internal pure returns (int232 downcasted) {</span>
  629 |     | <span class='neutral'>        downcasted = int232(value);</span>
  630 |     | <span class='neutral'>        if (downcasted != value) {</span>
  631 |     | <span class='neutral'>            revert SafeCastOverflowedIntDowncast(232, value);</span>
  632 |     | <span class='neutral'>        }</span>
  633 |     | <span class='neutral'>    }</span>
  634 |     | <span class='neutral'></span>
  635 |     | <span class='neutral'>    /**</span>
  636 |     | <span class='neutral'>     * @dev Returns the downcasted int224 from int256, reverting on</span>
  637 |     | <span class='neutral'>     * overflow (when the input is less than smallest int224 or</span>
  638 |     | <span class='neutral'>     * greater than largest int224).</span>
  639 |     | <span class='neutral'>     *</span>
  640 |     | <span class='neutral'>     * Counterpart to Solidity&#39;s `int224` operator.</span>
  641 |     | <span class='neutral'>     *</span>
  642 |     | <span class='neutral'>     * Requirements:</span>
  643 |     | <span class='neutral'>     *</span>
  644 |     | <span class='neutral'>     * - input must fit into 224 bits</span>
  645 |     | <span class='neutral'>     */</span>
  646 |     | <span class='neutral'>    function toInt224(int256 value) internal pure returns (int224 downcasted) {</span>
  647 |     | <span class='neutral'>        downcasted = int224(value);</span>
  648 |     | <span class='neutral'>        if (downcasted != value) {</span>
  649 |     | <span class='neutral'>            revert SafeCastOverflowedIntDowncast(224, value);</span>
  650 |     | <span class='neutral'>        }</span>
  651 |     | <span class='neutral'>    }</span>
  652 |     | <span class='neutral'></span>
  653 |     | <span class='neutral'>    /**</span>
  654 |     | <span class='neutral'>     * @dev Returns the downcasted int216 from int256, reverting on</span>
  655 |     | <span class='neutral'>     * overflow (when the input is less than smallest int216 or</span>
  656 |     | <span class='neutral'>     * greater than largest int216).</span>
  657 |     | <span class='neutral'>     *</span>
  658 |     | <span class='neutral'>     * Counterpart to Solidity&#39;s `int216` operator.</span>
  659 |     | <span class='neutral'>     *</span>
  660 |     | <span class='neutral'>     * Requirements:</span>
  661 |     | <span class='neutral'>     *</span>
  662 |     | <span class='neutral'>     * - input must fit into 216 bits</span>
  663 |     | <span class='neutral'>     */</span>
  664 |     | <span class='neutral'>    function toInt216(int256 value) internal pure returns (int216 downcasted) {</span>
  665 |     | <span class='neutral'>        downcasted = int216(value);</span>
  666 |     | <span class='neutral'>        if (downcasted != value) {</span>
  667 |     | <span class='neutral'>            revert SafeCastOverflowedIntDowncast(216, value);</span>
  668 |     | <span class='neutral'>        }</span>
  669 |     | <span class='neutral'>    }</span>
  670 |     | <span class='neutral'></span>
  671 |     | <span class='neutral'>    /**</span>
  672 |     | <span class='neutral'>     * @dev Returns the downcasted int208 from int256, reverting on</span>
  673 |     | <span class='neutral'>     * overflow (when the input is less than smallest int208 or</span>
  674 |     | <span class='neutral'>     * greater than largest int208).</span>
  675 |     | <span class='neutral'>     *</span>
  676 |     | <span class='neutral'>     * Counterpart to Solidity&#39;s `int208` operator.</span>
  677 |     | <span class='neutral'>     *</span>
  678 |     | <span class='neutral'>     * Requirements:</span>
  679 |     | <span class='neutral'>     *</span>
  680 |     | <span class='neutral'>     * - input must fit into 208 bits</span>
  681 |     | <span class='neutral'>     */</span>
  682 |     | <span class='neutral'>    function toInt208(int256 value) internal pure returns (int208 downcasted) {</span>
  683 |     | <span class='neutral'>        downcasted = int208(value);</span>
  684 |     | <span class='neutral'>        if (downcasted != value) {</span>
  685 |     | <span class='neutral'>            revert SafeCastOverflowedIntDowncast(208, value);</span>
  686 |     | <span class='neutral'>        }</span>
  687 |     | <span class='neutral'>    }</span>
  688 |     | <span class='neutral'></span>
  689 |     | <span class='neutral'>    /**</span>
  690 |     | <span class='neutral'>     * @dev Returns the downcasted int200 from int256, reverting on</span>
  691 |     | <span class='neutral'>     * overflow (when the input is less than smallest int200 or</span>
  692 |     | <span class='neutral'>     * greater than largest int200).</span>
  693 |     | <span class='neutral'>     *</span>
  694 |     | <span class='neutral'>     * Counterpart to Solidity&#39;s `int200` operator.</span>
  695 |     | <span class='neutral'>     *</span>
  696 |     | <span class='neutral'>     * Requirements:</span>
  697 |     | <span class='neutral'>     *</span>
  698 |     | <span class='neutral'>     * - input must fit into 200 bits</span>
  699 |     | <span class='neutral'>     */</span>
  700 |     | <span class='neutral'>    function toInt200(int256 value) internal pure returns (int200 downcasted) {</span>
  701 |     | <span class='neutral'>        downcasted = int200(value);</span>
  702 |     | <span class='neutral'>        if (downcasted != value) {</span>
  703 |     | <span class='neutral'>            revert SafeCastOverflowedIntDowncast(200, value);</span>
  704 |     | <span class='neutral'>        }</span>
  705 |     | <span class='neutral'>    }</span>
  706 |     | <span class='neutral'></span>
  707 |     | <span class='neutral'>    /**</span>
  708 |     | <span class='neutral'>     * @dev Returns the downcasted int192 from int256, reverting on</span>
  709 |     | <span class='neutral'>     * overflow (when the input is less than smallest int192 or</span>
  710 |     | <span class='neutral'>     * greater than largest int192).</span>
  711 |     | <span class='neutral'>     *</span>
  712 |     | <span class='neutral'>     * Counterpart to Solidity&#39;s `int192` operator.</span>
  713 |     | <span class='neutral'>     *</span>
  714 |     | <span class='neutral'>     * Requirements:</span>
  715 |     | <span class='neutral'>     *</span>
  716 |     | <span class='neutral'>     * - input must fit into 192 bits</span>
  717 |     | <span class='neutral'>     */</span>
  718 |     | <span class='neutral'>    function toInt192(int256 value) internal pure returns (int192 downcasted) {</span>
  719 |     | <span class='neutral'>        downcasted = int192(value);</span>
  720 |     | <span class='neutral'>        if (downcasted != value) {</span>
  721 |     | <span class='neutral'>            revert SafeCastOverflowedIntDowncast(192, value);</span>
  722 |     | <span class='neutral'>        }</span>
  723 |     | <span class='neutral'>    }</span>
  724 |     | <span class='neutral'></span>
  725 |     | <span class='neutral'>    /**</span>
  726 |     | <span class='neutral'>     * @dev Returns the downcasted int184 from int256, reverting on</span>
  727 |     | <span class='neutral'>     * overflow (when the input is less than smallest int184 or</span>
  728 |     | <span class='neutral'>     * greater than largest int184).</span>
  729 |     | <span class='neutral'>     *</span>
  730 |     | <span class='neutral'>     * Counterpart to Solidity&#39;s `int184` operator.</span>
  731 |     | <span class='neutral'>     *</span>
  732 |     | <span class='neutral'>     * Requirements:</span>
  733 |     | <span class='neutral'>     *</span>
  734 |     | <span class='neutral'>     * - input must fit into 184 bits</span>
  735 |     | <span class='neutral'>     */</span>
  736 |     | <span class='neutral'>    function toInt184(int256 value) internal pure returns (int184 downcasted) {</span>
  737 |     | <span class='neutral'>        downcasted = int184(value);</span>
  738 |     | <span class='neutral'>        if (downcasted != value) {</span>
  739 |     | <span class='neutral'>            revert SafeCastOverflowedIntDowncast(184, value);</span>
  740 |     | <span class='neutral'>        }</span>
  741 |     | <span class='neutral'>    }</span>
  742 |     | <span class='neutral'></span>
  743 |     | <span class='neutral'>    /**</span>
  744 |     | <span class='neutral'>     * @dev Returns the downcasted int176 from int256, reverting on</span>
  745 |     | <span class='neutral'>     * overflow (when the input is less than smallest int176 or</span>
  746 |     | <span class='neutral'>     * greater than largest int176).</span>
  747 |     | <span class='neutral'>     *</span>
  748 |     | <span class='neutral'>     * Counterpart to Solidity&#39;s `int176` operator.</span>
  749 |     | <span class='neutral'>     *</span>
  750 |     | <span class='neutral'>     * Requirements:</span>
  751 |     | <span class='neutral'>     *</span>
  752 |     | <span class='neutral'>     * - input must fit into 176 bits</span>
  753 |     | <span class='neutral'>     */</span>
  754 |     | <span class='neutral'>    function toInt176(int256 value) internal pure returns (int176 downcasted) {</span>
  755 |     | <span class='neutral'>        downcasted = int176(value);</span>
  756 |     | <span class='neutral'>        if (downcasted != value) {</span>
  757 |     | <span class='neutral'>            revert SafeCastOverflowedIntDowncast(176, value);</span>
  758 |     | <span class='neutral'>        }</span>
  759 |     | <span class='neutral'>    }</span>
  760 |     | <span class='neutral'></span>
  761 |     | <span class='neutral'>    /**</span>
  762 |     | <span class='neutral'>     * @dev Returns the downcasted int168 from int256, reverting on</span>
  763 |     | <span class='neutral'>     * overflow (when the input is less than smallest int168 or</span>
  764 |     | <span class='neutral'>     * greater than largest int168).</span>
  765 |     | <span class='neutral'>     *</span>
  766 |     | <span class='neutral'>     * Counterpart to Solidity&#39;s `int168` operator.</span>
  767 |     | <span class='neutral'>     *</span>
  768 |     | <span class='neutral'>     * Requirements:</span>
  769 |     | <span class='neutral'>     *</span>
  770 |     | <span class='neutral'>     * - input must fit into 168 bits</span>
  771 |     | <span class='neutral'>     */</span>
  772 |     | <span class='neutral'>    function toInt168(int256 value) internal pure returns (int168 downcasted) {</span>
  773 |     | <span class='neutral'>        downcasted = int168(value);</span>
  774 |     | <span class='neutral'>        if (downcasted != value) {</span>
  775 |     | <span class='neutral'>            revert SafeCastOverflowedIntDowncast(168, value);</span>
  776 |     | <span class='neutral'>        }</span>
  777 |     | <span class='neutral'>    }</span>
  778 |     | <span class='neutral'></span>
  779 |     | <span class='neutral'>    /**</span>
  780 |     | <span class='neutral'>     * @dev Returns the downcasted int160 from int256, reverting on</span>
  781 |     | <span class='neutral'>     * overflow (when the input is less than smallest int160 or</span>
  782 |     | <span class='neutral'>     * greater than largest int160).</span>
  783 |     | <span class='neutral'>     *</span>
  784 |     | <span class='neutral'>     * Counterpart to Solidity&#39;s `int160` operator.</span>
  785 |     | <span class='neutral'>     *</span>
  786 |     | <span class='neutral'>     * Requirements:</span>
  787 |     | <span class='neutral'>     *</span>
  788 |     | <span class='neutral'>     * - input must fit into 160 bits</span>
  789 |     | <span class='neutral'>     */</span>
  790 |     | <span class='neutral'>    function toInt160(int256 value) internal pure returns (int160 downcasted) {</span>
  791 |     | <span class='neutral'>        downcasted = int160(value);</span>
  792 |     | <span class='neutral'>        if (downcasted != value) {</span>
  793 |     | <span class='neutral'>            revert SafeCastOverflowedIntDowncast(160, value);</span>
  794 |     | <span class='neutral'>        }</span>
  795 |     | <span class='neutral'>    }</span>
  796 |     | <span class='neutral'></span>
  797 |     | <span class='neutral'>    /**</span>
  798 |     | <span class='neutral'>     * @dev Returns the downcasted int152 from int256, reverting on</span>
  799 |     | <span class='neutral'>     * overflow (when the input is less than smallest int152 or</span>
  800 |     | <span class='neutral'>     * greater than largest int152).</span>
  801 |     | <span class='neutral'>     *</span>
  802 |     | <span class='neutral'>     * Counterpart to Solidity&#39;s `int152` operator.</span>
  803 |     | <span class='neutral'>     *</span>
  804 |     | <span class='neutral'>     * Requirements:</span>
  805 |     | <span class='neutral'>     *</span>
  806 |     | <span class='neutral'>     * - input must fit into 152 bits</span>
  807 |     | <span class='neutral'>     */</span>
  808 |     | <span class='neutral'>    function toInt152(int256 value) internal pure returns (int152 downcasted) {</span>
  809 |     | <span class='neutral'>        downcasted = int152(value);</span>
  810 |     | <span class='neutral'>        if (downcasted != value) {</span>
  811 |     | <span class='neutral'>            revert SafeCastOverflowedIntDowncast(152, value);</span>
  812 |     | <span class='neutral'>        }</span>
  813 |     | <span class='neutral'>    }</span>
  814 |     | <span class='neutral'></span>
  815 |     | <span class='neutral'>    /**</span>
  816 |     | <span class='neutral'>     * @dev Returns the downcasted int144 from int256, reverting on</span>
  817 |     | <span class='neutral'>     * overflow (when the input is less than smallest int144 or</span>
  818 |     | <span class='neutral'>     * greater than largest int144).</span>
  819 |     | <span class='neutral'>     *</span>
  820 |     | <span class='neutral'>     * Counterpart to Solidity&#39;s `int144` operator.</span>
  821 |     | <span class='neutral'>     *</span>
  822 |     | <span class='neutral'>     * Requirements:</span>
  823 |     | <span class='neutral'>     *</span>
  824 |     | <span class='neutral'>     * - input must fit into 144 bits</span>
  825 |     | <span class='neutral'>     */</span>
  826 |     | <span class='neutral'>    function toInt144(int256 value) internal pure returns (int144 downcasted) {</span>
  827 |     | <span class='neutral'>        downcasted = int144(value);</span>
  828 |     | <span class='neutral'>        if (downcasted != value) {</span>
  829 |     | <span class='neutral'>            revert SafeCastOverflowedIntDowncast(144, value);</span>
  830 |     | <span class='neutral'>        }</span>
  831 |     | <span class='neutral'>    }</span>
  832 |     | <span class='neutral'></span>
  833 |     | <span class='neutral'>    /**</span>
  834 |     | <span class='neutral'>     * @dev Returns the downcasted int136 from int256, reverting on</span>
  835 |     | <span class='neutral'>     * overflow (when the input is less than smallest int136 or</span>
  836 |     | <span class='neutral'>     * greater than largest int136).</span>
  837 |     | <span class='neutral'>     *</span>
  838 |     | <span class='neutral'>     * Counterpart to Solidity&#39;s `int136` operator.</span>
  839 |     | <span class='neutral'>     *</span>
  840 |     | <span class='neutral'>     * Requirements:</span>
  841 |     | <span class='neutral'>     *</span>
  842 |     | <span class='neutral'>     * - input must fit into 136 bits</span>
  843 |     | <span class='neutral'>     */</span>
  844 |     | <span class='neutral'>    function toInt136(int256 value) internal pure returns (int136 downcasted) {</span>
  845 |     | <span class='neutral'>        downcasted = int136(value);</span>
  846 |     | <span class='neutral'>        if (downcasted != value) {</span>
  847 |     | <span class='neutral'>            revert SafeCastOverflowedIntDowncast(136, value);</span>
  848 |     | <span class='neutral'>        }</span>
  849 |     | <span class='neutral'>    }</span>
  850 |     | <span class='neutral'></span>
  851 |     | <span class='neutral'>    /**</span>
  852 |     | <span class='neutral'>     * @dev Returns the downcasted int128 from int256, reverting on</span>
  853 |     | <span class='neutral'>     * overflow (when the input is less than smallest int128 or</span>
  854 |     | <span class='neutral'>     * greater than largest int128).</span>
  855 |     | <span class='neutral'>     *</span>
  856 |     | <span class='neutral'>     * Counterpart to Solidity&#39;s `int128` operator.</span>
  857 |     | <span class='neutral'>     *</span>
  858 |     | <span class='neutral'>     * Requirements:</span>
  859 |     | <span class='neutral'>     *</span>
  860 |     | <span class='neutral'>     * - input must fit into 128 bits</span>
  861 |     | <span class='neutral'>     */</span>
  862 |     | <span class='neutral'>    function toInt128(int256 value) internal pure returns (int128 downcasted) {</span>
  863 |     | <span class='neutral'>        downcasted = int128(value);</span>
  864 |     | <span class='neutral'>        if (downcasted != value) {</span>
  865 |     | <span class='neutral'>            revert SafeCastOverflowedIntDowncast(128, value);</span>
  866 |     | <span class='neutral'>        }</span>
  867 |     | <span class='neutral'>    }</span>
  868 |     | <span class='neutral'></span>
  869 |     | <span class='neutral'>    /**</span>
  870 |     | <span class='neutral'>     * @dev Returns the downcasted int120 from int256, reverting on</span>
  871 |     | <span class='neutral'>     * overflow (when the input is less than smallest int120 or</span>
  872 |     | <span class='neutral'>     * greater than largest int120).</span>
  873 |     | <span class='neutral'>     *</span>
  874 |     | <span class='neutral'>     * Counterpart to Solidity&#39;s `int120` operator.</span>
  875 |     | <span class='neutral'>     *</span>
  876 |     | <span class='neutral'>     * Requirements:</span>
  877 |     | <span class='neutral'>     *</span>
  878 |     | <span class='neutral'>     * - input must fit into 120 bits</span>
  879 |     | <span class='neutral'>     */</span>
  880 |     | <span class='neutral'>    function toInt120(int256 value) internal pure returns (int120 downcasted) {</span>
  881 |     | <span class='neutral'>        downcasted = int120(value);</span>
  882 |     | <span class='neutral'>        if (downcasted != value) {</span>
  883 |     | <span class='neutral'>            revert SafeCastOverflowedIntDowncast(120, value);</span>
  884 |     | <span class='neutral'>        }</span>
  885 |     | <span class='neutral'>    }</span>
  886 |     | <span class='neutral'></span>
  887 |     | <span class='neutral'>    /**</span>
  888 |     | <span class='neutral'>     * @dev Returns the downcasted int112 from int256, reverting on</span>
  889 |     | <span class='neutral'>     * overflow (when the input is less than smallest int112 or</span>
  890 |     | <span class='neutral'>     * greater than largest int112).</span>
  891 |     | <span class='neutral'>     *</span>
  892 |     | <span class='neutral'>     * Counterpart to Solidity&#39;s `int112` operator.</span>
  893 |     | <span class='neutral'>     *</span>
  894 |     | <span class='neutral'>     * Requirements:</span>
  895 |     | <span class='neutral'>     *</span>
  896 |     | <span class='neutral'>     * - input must fit into 112 bits</span>
  897 |     | <span class='neutral'>     */</span>
  898 |     | <span class='neutral'>    function toInt112(int256 value) internal pure returns (int112 downcasted) {</span>
  899 |     | <span class='neutral'>        downcasted = int112(value);</span>
  900 |     | <span class='neutral'>        if (downcasted != value) {</span>
  901 |     | <span class='neutral'>            revert SafeCastOverflowedIntDowncast(112, value);</span>
  902 |     | <span class='neutral'>        }</span>
  903 |     | <span class='neutral'>    }</span>
  904 |     | <span class='neutral'></span>
  905 |     | <span class='neutral'>    /**</span>
  906 |     | <span class='neutral'>     * @dev Returns the downcasted int104 from int256, reverting on</span>
  907 |     | <span class='neutral'>     * overflow (when the input is less than smallest int104 or</span>
  908 |     | <span class='neutral'>     * greater than largest int104).</span>
  909 |     | <span class='neutral'>     *</span>
  910 |     | <span class='neutral'>     * Counterpart to Solidity&#39;s `int104` operator.</span>
  911 |     | <span class='neutral'>     *</span>
  912 |     | <span class='neutral'>     * Requirements:</span>
  913 |     | <span class='neutral'>     *</span>
  914 |     | <span class='neutral'>     * - input must fit into 104 bits</span>
  915 |     | <span class='neutral'>     */</span>
  916 |     | <span class='neutral'>    function toInt104(int256 value) internal pure returns (int104 downcasted) {</span>
  917 |     | <span class='neutral'>        downcasted = int104(value);</span>
  918 |     | <span class='neutral'>        if (downcasted != value) {</span>
  919 |     | <span class='neutral'>            revert SafeCastOverflowedIntDowncast(104, value);</span>
  920 |     | <span class='neutral'>        }</span>
  921 |     | <span class='neutral'>    }</span>
  922 |     | <span class='neutral'></span>
  923 |     | <span class='neutral'>    /**</span>
  924 |     | <span class='neutral'>     * @dev Returns the downcasted int96 from int256, reverting on</span>
  925 |     | <span class='neutral'>     * overflow (when the input is less than smallest int96 or</span>
  926 |     | <span class='neutral'>     * greater than largest int96).</span>
  927 |     | <span class='neutral'>     *</span>
  928 |     | <span class='neutral'>     * Counterpart to Solidity&#39;s `int96` operator.</span>
  929 |     | <span class='neutral'>     *</span>
  930 |     | <span class='neutral'>     * Requirements:</span>
  931 |     | <span class='neutral'>     *</span>
  932 |     | <span class='neutral'>     * - input must fit into 96 bits</span>
  933 |     | <span class='neutral'>     */</span>
  934 |     | <span class='neutral'>    function toInt96(int256 value) internal pure returns (int96 downcasted) {</span>
  935 |     | <span class='neutral'>        downcasted = int96(value);</span>
  936 |     | <span class='neutral'>        if (downcasted != value) {</span>
  937 |     | <span class='neutral'>            revert SafeCastOverflowedIntDowncast(96, value);</span>
  938 |     | <span class='neutral'>        }</span>
  939 |     | <span class='neutral'>    }</span>
  940 |     | <span class='neutral'></span>
  941 |     | <span class='neutral'>    /**</span>
  942 |     | <span class='neutral'>     * @dev Returns the downcasted int88 from int256, reverting on</span>
  943 |     | <span class='neutral'>     * overflow (when the input is less than smallest int88 or</span>
  944 |     | <span class='neutral'>     * greater than largest int88).</span>
  945 |     | <span class='neutral'>     *</span>
  946 |     | <span class='neutral'>     * Counterpart to Solidity&#39;s `int88` operator.</span>
  947 |     | <span class='neutral'>     *</span>
  948 |     | <span class='neutral'>     * Requirements:</span>
  949 |     | <span class='neutral'>     *</span>
  950 |     | <span class='neutral'>     * - input must fit into 88 bits</span>
  951 |     | <span class='neutral'>     */</span>
  952 |     | <span class='neutral'>    function toInt88(int256 value) internal pure returns (int88 downcasted) {</span>
  953 |     | <span class='neutral'>        downcasted = int88(value);</span>
  954 |     | <span class='neutral'>        if (downcasted != value) {</span>
  955 |     | <span class='neutral'>            revert SafeCastOverflowedIntDowncast(88, value);</span>
  956 |     | <span class='neutral'>        }</span>
  957 |     | <span class='neutral'>    }</span>
  958 |     | <span class='neutral'></span>
  959 |     | <span class='neutral'>    /**</span>
  960 |     | <span class='neutral'>     * @dev Returns the downcasted int80 from int256, reverting on</span>
  961 |     | <span class='neutral'>     * overflow (when the input is less than smallest int80 or</span>
  962 |     | <span class='neutral'>     * greater than largest int80).</span>
  963 |     | <span class='neutral'>     *</span>
  964 |     | <span class='neutral'>     * Counterpart to Solidity&#39;s `int80` operator.</span>
  965 |     | <span class='neutral'>     *</span>
  966 |     | <span class='neutral'>     * Requirements:</span>
  967 |     | <span class='neutral'>     *</span>
  968 |     | <span class='neutral'>     * - input must fit into 80 bits</span>
  969 |     | <span class='neutral'>     */</span>
  970 |     | <span class='neutral'>    function toInt80(int256 value) internal pure returns (int80 downcasted) {</span>
  971 |     | <span class='neutral'>        downcasted = int80(value);</span>
  972 |     | <span class='neutral'>        if (downcasted != value) {</span>
  973 |     | <span class='neutral'>            revert SafeCastOverflowedIntDowncast(80, value);</span>
  974 |     | <span class='neutral'>        }</span>
  975 |     | <span class='neutral'>    }</span>
  976 |     | <span class='neutral'></span>
  977 |     | <span class='neutral'>    /**</span>
  978 |     | <span class='neutral'>     * @dev Returns the downcasted int72 from int256, reverting on</span>
  979 |     | <span class='neutral'>     * overflow (when the input is less than smallest int72 or</span>
  980 |     | <span class='neutral'>     * greater than largest int72).</span>
  981 |     | <span class='neutral'>     *</span>
  982 |     | <span class='neutral'>     * Counterpart to Solidity&#39;s `int72` operator.</span>
  983 |     | <span class='neutral'>     *</span>
  984 |     | <span class='neutral'>     * Requirements:</span>
  985 |     | <span class='neutral'>     *</span>
  986 |     | <span class='neutral'>     * - input must fit into 72 bits</span>
  987 |     | <span class='neutral'>     */</span>
  988 |     | <span class='neutral'>    function toInt72(int256 value) internal pure returns (int72 downcasted) {</span>
  989 |     | <span class='neutral'>        downcasted = int72(value);</span>
  990 |     | <span class='neutral'>        if (downcasted != value) {</span>
  991 |     | <span class='neutral'>            revert SafeCastOverflowedIntDowncast(72, value);</span>
  992 |     | <span class='neutral'>        }</span>
  993 |     | <span class='neutral'>    }</span>
  994 |     | <span class='neutral'></span>
  995 |     | <span class='neutral'>    /**</span>
  996 |     | <span class='neutral'>     * @dev Returns the downcasted int64 from int256, reverting on</span>
  997 |     | <span class='neutral'>     * overflow (when the input is less than smallest int64 or</span>
  998 |     | <span class='neutral'>     * greater than largest int64).</span>
  999 |     | <span class='neutral'>     *</span>
 1000 |     | <span class='neutral'>     * Counterpart to Solidity&#39;s `int64` operator.</span>
 1001 |     | <span class='neutral'>     *</span>
 1002 |     | <span class='neutral'>     * Requirements:</span>
 1003 |     | <span class='neutral'>     *</span>
 1004 |     | <span class='neutral'>     * - input must fit into 64 bits</span>
 1005 |     | <span class='neutral'>     */</span>
 1006 |     | <span class='neutral'>    function toInt64(int256 value) internal pure returns (int64 downcasted) {</span>
 1007 |     | <span class='neutral'>        downcasted = int64(value);</span>
 1008 |     | <span class='neutral'>        if (downcasted != value) {</span>
 1009 |     | <span class='neutral'>            revert SafeCastOverflowedIntDowncast(64, value);</span>
 1010 |     | <span class='neutral'>        }</span>
 1011 |     | <span class='neutral'>    }</span>
 1012 |     | <span class='neutral'></span>
 1013 |     | <span class='neutral'>    /**</span>
 1014 |     | <span class='neutral'>     * @dev Returns the downcasted int56 from int256, reverting on</span>
 1015 |     | <span class='neutral'>     * overflow (when the input is less than smallest int56 or</span>
 1016 |     | <span class='neutral'>     * greater than largest int56).</span>
 1017 |     | <span class='neutral'>     *</span>
 1018 |     | <span class='neutral'>     * Counterpart to Solidity&#39;s `int56` operator.</span>
 1019 |     | <span class='neutral'>     *</span>
 1020 |     | <span class='neutral'>     * Requirements:</span>
 1021 |     | <span class='neutral'>     *</span>
 1022 |     | <span class='neutral'>     * - input must fit into 56 bits</span>
 1023 |     | <span class='neutral'>     */</span>
 1024 |     | <span class='neutral'>    function toInt56(int256 value) internal pure returns (int56 downcasted) {</span>
 1025 |     | <span class='neutral'>        downcasted = int56(value);</span>
 1026 |     | <span class='neutral'>        if (downcasted != value) {</span>
 1027 |     | <span class='neutral'>            revert SafeCastOverflowedIntDowncast(56, value);</span>
 1028 |     | <span class='neutral'>        }</span>
 1029 |     | <span class='neutral'>    }</span>
 1030 |     | <span class='neutral'></span>
 1031 |     | <span class='neutral'>    /**</span>
 1032 |     | <span class='neutral'>     * @dev Returns the downcasted int48 from int256, reverting on</span>
 1033 |     | <span class='neutral'>     * overflow (when the input is less than smallest int48 or</span>
 1034 |     | <span class='neutral'>     * greater than largest int48).</span>
 1035 |     | <span class='neutral'>     *</span>
 1036 |     | <span class='neutral'>     * Counterpart to Solidity&#39;s `int48` operator.</span>
 1037 |     | <span class='neutral'>     *</span>
 1038 |     | <span class='neutral'>     * Requirements:</span>
 1039 |     | <span class='neutral'>     *</span>
 1040 |     | <span class='neutral'>     * - input must fit into 48 bits</span>
 1041 |     | <span class='neutral'>     */</span>
 1042 |     | <span class='neutral'>    function toInt48(int256 value) internal pure returns (int48 downcasted) {</span>
 1043 |     | <span class='neutral'>        downcasted = int48(value);</span>
 1044 |     | <span class='neutral'>        if (downcasted != value) {</span>
 1045 |     | <span class='neutral'>            revert SafeCastOverflowedIntDowncast(48, value);</span>
 1046 |     | <span class='neutral'>        }</span>
 1047 |     | <span class='neutral'>    }</span>
 1048 |     | <span class='neutral'></span>
 1049 |     | <span class='neutral'>    /**</span>
 1050 |     | <span class='neutral'>     * @dev Returns the downcasted int40 from int256, reverting on</span>
 1051 |     | <span class='neutral'>     * overflow (when the input is less than smallest int40 or</span>
 1052 |     | <span class='neutral'>     * greater than largest int40).</span>
 1053 |     | <span class='neutral'>     *</span>
 1054 |     | <span class='neutral'>     * Counterpart to Solidity&#39;s `int40` operator.</span>
 1055 |     | <span class='neutral'>     *</span>
 1056 |     | <span class='neutral'>     * Requirements:</span>
 1057 |     | <span class='neutral'>     *</span>
 1058 |     | <span class='neutral'>     * - input must fit into 40 bits</span>
 1059 |     | <span class='neutral'>     */</span>
 1060 |     | <span class='neutral'>    function toInt40(int256 value) internal pure returns (int40 downcasted) {</span>
 1061 |     | <span class='neutral'>        downcasted = int40(value);</span>
 1062 |     | <span class='neutral'>        if (downcasted != value) {</span>
 1063 |     | <span class='neutral'>            revert SafeCastOverflowedIntDowncast(40, value);</span>
 1064 |     | <span class='neutral'>        }</span>
 1065 |     | <span class='neutral'>    }</span>
 1066 |     | <span class='neutral'></span>
 1067 |     | <span class='neutral'>    /**</span>
 1068 |     | <span class='neutral'>     * @dev Returns the downcasted int32 from int256, reverting on</span>
 1069 |     | <span class='neutral'>     * overflow (when the input is less than smallest int32 or</span>
 1070 |     | <span class='neutral'>     * greater than largest int32).</span>
 1071 |     | <span class='neutral'>     *</span>
 1072 |     | <span class='neutral'>     * Counterpart to Solidity&#39;s `int32` operator.</span>
 1073 |     | <span class='neutral'>     *</span>
 1074 |     | <span class='neutral'>     * Requirements:</span>
 1075 |     | <span class='neutral'>     *</span>
 1076 |     | <span class='neutral'>     * - input must fit into 32 bits</span>
 1077 |     | <span class='neutral'>     */</span>
 1078 |     | <span class='neutral'>    function toInt32(int256 value) internal pure returns (int32 downcasted) {</span>
 1079 |     | <span class='neutral'>        downcasted = int32(value);</span>
 1080 |     | <span class='neutral'>        if (downcasted != value) {</span>
 1081 |     | <span class='neutral'>            revert SafeCastOverflowedIntDowncast(32, value);</span>
 1082 |     | <span class='neutral'>        }</span>
 1083 |     | <span class='neutral'>    }</span>
 1084 |     | <span class='neutral'></span>
 1085 |     | <span class='neutral'>    /**</span>
 1086 |     | <span class='neutral'>     * @dev Returns the downcasted int24 from int256, reverting on</span>
 1087 |     | <span class='neutral'>     * overflow (when the input is less than smallest int24 or</span>
 1088 |     | <span class='neutral'>     * greater than largest int24).</span>
 1089 |     | <span class='neutral'>     *</span>
 1090 |     | <span class='neutral'>     * Counterpart to Solidity&#39;s `int24` operator.</span>
 1091 |     | <span class='neutral'>     *</span>
 1092 |     | <span class='neutral'>     * Requirements:</span>
 1093 |     | <span class='neutral'>     *</span>
 1094 |     | <span class='neutral'>     * - input must fit into 24 bits</span>
 1095 |     | <span class='neutral'>     */</span>
 1096 |     | <span class='neutral'>    function toInt24(int256 value) internal pure returns (int24 downcasted) {</span>
 1097 |     | <span class='neutral'>        downcasted = int24(value);</span>
 1098 |     | <span class='neutral'>        if (downcasted != value) {</span>
 1099 |     | <span class='neutral'>            revert SafeCastOverflowedIntDowncast(24, value);</span>
 1100 |     | <span class='neutral'>        }</span>
 1101 |     | <span class='neutral'>    }</span>
 1102 |     | <span class='neutral'></span>
 1103 |     | <span class='neutral'>    /**</span>
 1104 |     | <span class='neutral'>     * @dev Returns the downcasted int16 from int256, reverting on</span>
 1105 |     | <span class='neutral'>     * overflow (when the input is less than smallest int16 or</span>
 1106 |     | <span class='neutral'>     * greater than largest int16).</span>
 1107 |     | <span class='neutral'>     *</span>
 1108 |     | <span class='neutral'>     * Counterpart to Solidity&#39;s `int16` operator.</span>
 1109 |     | <span class='neutral'>     *</span>
 1110 |     | <span class='neutral'>     * Requirements:</span>
 1111 |     | <span class='neutral'>     *</span>
 1112 |     | <span class='neutral'>     * - input must fit into 16 bits</span>
 1113 |     | <span class='neutral'>     */</span>
 1114 |     | <span class='neutral'>    function toInt16(int256 value) internal pure returns (int16 downcasted) {</span>
 1115 |     | <span class='neutral'>        downcasted = int16(value);</span>
 1116 |     | <span class='neutral'>        if (downcasted != value) {</span>
 1117 |     | <span class='neutral'>            revert SafeCastOverflowedIntDowncast(16, value);</span>
 1118 |     | <span class='neutral'>        }</span>
 1119 |     | <span class='neutral'>    }</span>
 1120 |     | <span class='neutral'></span>
 1121 |     | <span class='neutral'>    /**</span>
 1122 |     | <span class='neutral'>     * @dev Returns the downcasted int8 from int256, reverting on</span>
 1123 |     | <span class='neutral'>     * overflow (when the input is less than smallest int8 or</span>
 1124 |     | <span class='neutral'>     * greater than largest int8).</span>
 1125 |     | <span class='neutral'>     *</span>
 1126 |     | <span class='neutral'>     * Counterpart to Solidity&#39;s `int8` operator.</span>
 1127 |     | <span class='neutral'>     *</span>
 1128 |     | <span class='neutral'>     * Requirements:</span>
 1129 |     | <span class='neutral'>     *</span>
 1130 |     | <span class='neutral'>     * - input must fit into 8 bits</span>
 1131 |     | <span class='neutral'>     */</span>
 1132 |     | <span class='neutral'>    function toInt8(int256 value) internal pure returns (int8 downcasted) {</span>
 1133 |     | <span class='neutral'>        downcasted = int8(value);</span>
 1134 |     | <span class='neutral'>        if (downcasted != value) {</span>
 1135 |     | <span class='neutral'>            revert SafeCastOverflowedIntDowncast(8, value);</span>
 1136 |     | <span class='neutral'>        }</span>
 1137 |     | <span class='neutral'>    }</span>
 1138 |     | <span class='neutral'></span>
 1139 |     | <span class='neutral'>    /**</span>
 1140 |     | <span class='neutral'>     * @dev Converts an unsigned uint256 into a signed int256.</span>
 1141 |     | <span class='neutral'>     *</span>
 1142 |     | <span class='neutral'>     * Requirements:</span>
 1143 |     | <span class='neutral'>     *</span>
 1144 |     | <span class='neutral'>     * - input must be less than or equal to maxInt256.</span>
 1145 |     | <span class='neutral'>     */</span>
 1146 |     | <span class='neutral'>    function toInt256(uint256 value) internal pure returns (int256) {</span>
 1147 |     | <span class='neutral'>        // Note: Unsafe cast below is okay because `type(int256).max` is guaranteed to be positive</span>
 1148 |     | <span class='neutral'>        if (value &gt; uint256(type(int256).max)) {</span>
 1149 |     | <span class='neutral'>            revert SafeCastOverflowedUintToInt(value);</span>
 1150 |     | <span class='neutral'>        }</span>
 1151 |     | <span class='neutral'>        return int256(value);</span>
 1152 |     | <span class='neutral'>    }</span>
 1153 |     | <span class='neutral'></span>
 1154 |     | <span class='neutral'>    /**</span>
 1155 |     | <span class='neutral'>     * @dev Cast a boolean (false or true) to a uint256 (0 or 1) with no jump.</span>
 1156 |     | <span class='neutral'>     */</span>
 1157 |     | <span class='neutral'>    function toUint(bool b) internal pure returns (uint256 u) {</span>
 1158 |     | <span class='neutral'>        assembly (&quot;memory-safe&quot;) {</span>
 1159 |     | <span class='neutral'>            u := iszero(iszero(b))</span>
 1160 |     | <span class='neutral'>        }</span>
 1161 |     | <span class='neutral'>    }</span>
 1162 |     | <span class='neutral'>}</span>
 1163 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/phantom/Documents/azemora/azemora-contracts/lib/openzeppelin-contracts/contracts/utils/math/SignedMath.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>// OpenZeppelin Contracts (last updated v5.1.0) (utils/math/SignedMath.sol)</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>pragma solidity ^0.8.20;</span>
  5 |     | <span class='neutral'></span>
  6 |     | <span class='neutral'>import {SafeCast} from &quot;./SafeCast.sol&quot;;</span>
  7 |     | <span class='neutral'></span>
  8 |     | <span class='neutral'>/**</span>
  9 |     | <span class='neutral'> * @dev Standard signed math utilities missing in the Solidity language.</span>
 10 |     | <span class='neutral'> */</span>
 11 |     | <span class='neutral'>library SignedMath {</span>
 12 |     | <span class='neutral'>    /**</span>
 13 |     | <span class='neutral'>     * @dev Branchless ternary evaluation for `a ? b : c`. Gas costs are constant.</span>
 14 |     | <span class='neutral'>     *</span>
 15 |     | <span class='neutral'>     * IMPORTANT: This function may reduce bytecode size and consume less gas when used standalone.</span>
 16 |     | <span class='neutral'>     * However, the compiler may optimize Solidity ternary operations (i.e. `a ? b : c`) to only compute</span>
 17 |     | <span class='neutral'>     * one branch when needed, making this function more expensive.</span>
 18 |     | <span class='neutral'>     */</span>
 19 |     | <span class='neutral'>    function ternary(bool condition, int256 a, int256 b) internal pure returns (int256) {</span>
 20 |     | <span class='neutral'>        unchecked {</span>
 21 |     | <span class='neutral'>            // branchless ternary works because:</span>
 22 |     | <span class='neutral'>            // b ^ (a ^ b) == a</span>
 23 |     | <span class='neutral'>            // b ^ 0 == b</span>
 24 |     | <span class='neutral'>            return b ^ ((a ^ b) * int256(SafeCast.toUint(condition)));</span>
 25 |     | <span class='neutral'>        }</span>
 26 |     | <span class='neutral'>    }</span>
 27 |     | <span class='neutral'></span>
 28 |     | <span class='neutral'>    /**</span>
 29 |     | <span class='neutral'>     * @dev Returns the largest of two signed numbers.</span>
 30 |     | <span class='neutral'>     */</span>
 31 |     | <span class='neutral'>    function max(int256 a, int256 b) internal pure returns (int256) {</span>
 32 |     | <span class='neutral'>        return ternary(a &gt; b, a, b);</span>
 33 |     | <span class='neutral'>    }</span>
 34 |     | <span class='neutral'></span>
 35 |     | <span class='neutral'>    /**</span>
 36 |     | <span class='neutral'>     * @dev Returns the smallest of two signed numbers.</span>
 37 |     | <span class='neutral'>     */</span>
 38 |     | <span class='neutral'>    function min(int256 a, int256 b) internal pure returns (int256) {</span>
 39 |     | <span class='neutral'>        return ternary(a &lt; b, a, b);</span>
 40 |     | <span class='neutral'>    }</span>
 41 |     | <span class='neutral'></span>
 42 |     | <span class='neutral'>    /**</span>
 43 |     | <span class='neutral'>     * @dev Returns the average of two signed numbers without overflow.</span>
 44 |     | <span class='neutral'>     * The result is rounded towards zero.</span>
 45 |     | <span class='neutral'>     */</span>
 46 |     | <span class='neutral'>    function average(int256 a, int256 b) internal pure returns (int256) {</span>
 47 |     | <span class='neutral'>        // Formula from the book &quot;Hacker&#39;s Delight&quot;</span>
 48 |     | <span class='neutral'>        int256 x = (a &amp; b) + ((a ^ b) &gt;&gt; 1);</span>
 49 |     | <span class='neutral'>        return x + (int256(uint256(x) &gt;&gt; 255) &amp; (a ^ b));</span>
 50 |     | <span class='neutral'>    }</span>
 51 |     | <span class='neutral'></span>
 52 |     | <span class='neutral'>    /**</span>
 53 |     | <span class='neutral'>     * @dev Returns the absolute unsigned value of a signed value.</span>
 54 |     | <span class='neutral'>     */</span>
 55 |     | <span class='neutral'>    function abs(int256 n) internal pure returns (uint256) {</span>
 56 |     | <span class='neutral'>        unchecked {</span>
 57 |     | <span class='neutral'>            // Formula from the &quot;Bit Twiddling Hacks&quot; by Sean Eron Anderson.</span>
 58 |     | <span class='neutral'>            // Since `n` is a signed integer, the generated bytecode will use the SAR opcode to perform the right shift,</span>
 59 |     | <span class='neutral'>            // taking advantage of the most significant (or &quot;sign&quot; bit) in two&#39;s complement representation.</span>
 60 |     | <span class='neutral'>            // This opcode adds new most significant bits set to the value of the previous most significant bit. As a result,</span>
 61 |     | <span class='neutral'>            // the mask will either be `bytes32(0)` (if n is positive) or `~bytes32(0)` (if n is negative).</span>
 62 |     | <span class='neutral'>            int256 mask = n &gt;&gt; 255;</span>
 63 |     | <span class='neutral'></span>
 64 |     | <span class='neutral'>            // A `bytes32(0)` mask leaves the input unchanged, while a `~bytes32(0)` mask complements it.</span>
 65 |     | <span class='neutral'>            return uint256((n + mask) ^ mask);</span>
 66 |     | <span class='neutral'>        }</span>
 67 |     | <span class='neutral'>    }</span>
 68 |     | <span class='neutral'>}</span>
 69 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/phantom/Documents/azemora/azemora-contracts/lib/openzeppelin-contracts/contracts/utils/structs/Checkpoints.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'>// OpenZeppelin Contracts (last updated v5.3.0) (utils/structs/Checkpoints.sol)</span>
   3 |     | <span class='neutral'>// This file was procedurally generated from scripts/generate/templates/Checkpoints.js.</span>
   4 |     | <span class='neutral'></span>
   5 |     | <span class='neutral'>pragma solidity ^0.8.20;</span>
   6 |     | <span class='neutral'></span>
   7 |     | <span class='neutral'>import {Math} from &quot;../math/Math.sol&quot;;</span>
   8 |     | <span class='neutral'></span>
   9 |     | <span class='neutral'>/**</span>
  10 |     | <span class='neutral'> * @dev This library defines the `Trace*` struct, for checkpointing values as they change at different points in</span>
  11 |     | <span class='neutral'> * time, and later looking up past values by block number. See {Votes} as an example.</span>
  12 |     | <span class='neutral'> *</span>
  13 |     | <span class='neutral'> * To create a history of checkpoints define a variable type `Checkpoints.Trace*` in your contract, and store a new</span>
  14 |     | <span class='neutral'> * checkpoint for the current transaction block using the {push} function.</span>
  15 |     | <span class='neutral'> */</span>
  16 |     | <span class='neutral'>library Checkpoints {</span>
  17 |     | <span class='neutral'>    /**</span>
  18 |     | <span class='neutral'>     * @dev A value was attempted to be inserted on a past checkpoint.</span>
  19 |     | <span class='neutral'>     */</span>
  20 |     | <span class='neutral'>    error CheckpointUnorderedInsertion();</span>
  21 |     | <span class='neutral'></span>
  22 |     | <span class='neutral'>    struct Trace224 {</span>
  23 |     | <span class='neutral'>        Checkpoint224[] _checkpoints;</span>
  24 |     | <span class='neutral'>    }</span>
  25 |     | <span class='neutral'></span>
  26 |     | <span class='neutral'>    struct Checkpoint224 {</span>
  27 |     | <span class='neutral'>        uint32 _key;</span>
  28 |     | <span class='neutral'>        uint224 _value;</span>
  29 |     | <span class='neutral'>    }</span>
  30 |     | <span class='neutral'></span>
  31 |     | <span class='neutral'>    /**</span>
  32 |     | <span class='neutral'>     * @dev Pushes a (`key`, `value`) pair into a Trace224 so that it is stored as the checkpoint.</span>
  33 |     | <span class='neutral'>     *</span>
  34 |     | <span class='neutral'>     * Returns previous value and new value.</span>
  35 |     | <span class='neutral'>     *</span>
  36 |     | <span class='neutral'>     * IMPORTANT: Never accept `key` as a user input, since an arbitrary `type(uint32).max` key set will disable the</span>
  37 |     | <span class='neutral'>     * library.</span>
  38 |     | <span class='neutral'>     */</span>
  39 |     | <span class='neutral'>    function push(</span>
  40 |     | <span class='neutral'>        Trace224 storage self,</span>
  41 |     | <span class='neutral'>        uint32 key,</span>
  42 |     | <span class='neutral'>        uint224 value</span>
  43 |     | <span class='neutral'>    ) internal returns (uint224 oldValue, uint224 newValue) {</span>
  44 |     | <span class='neutral'>        return _insert(self._checkpoints, key, value);</span>
  45 |     | <span class='neutral'>    }</span>
  46 |     | <span class='neutral'></span>
  47 |     | <span class='neutral'>    /**</span>
  48 |     | <span class='neutral'>     * @dev Returns the value in the first (oldest) checkpoint with key greater or equal than the search key, or zero if</span>
  49 |     | <span class='neutral'>     * there is none.</span>
  50 |     | <span class='neutral'>     */</span>
  51 |     | <span class='neutral'>    function lowerLookup(Trace224 storage self, uint32 key) internal view returns (uint224) {</span>
  52 |     | <span class='neutral'>        uint256 len = self._checkpoints.length;</span>
  53 |     | <span class='neutral'>        uint256 pos = _lowerBinaryLookup(self._checkpoints, key, 0, len);</span>
  54 |     | <span class='neutral'>        return pos == len ? 0 : _unsafeAccess(self._checkpoints, pos)._value;</span>
  55 |     | <span class='neutral'>    }</span>
  56 |     | <span class='neutral'></span>
  57 |     | <span class='neutral'>    /**</span>
  58 |     | <span class='neutral'>     * @dev Returns the value in the last (most recent) checkpoint with key lower or equal than the search key, or zero</span>
  59 |     | <span class='neutral'>     * if there is none.</span>
  60 |     | <span class='neutral'>     */</span>
  61 |     | <span class='neutral'>    function upperLookup(Trace224 storage self, uint32 key) internal view returns (uint224) {</span>
  62 |     | <span class='neutral'>        uint256 len = self._checkpoints.length;</span>
  63 |     | <span class='neutral'>        uint256 pos = _upperBinaryLookup(self._checkpoints, key, 0, len);</span>
  64 |     | <span class='neutral'>        return pos == 0 ? 0 : _unsafeAccess(self._checkpoints, pos - 1)._value;</span>
  65 |     | <span class='neutral'>    }</span>
  66 |     | <span class='neutral'></span>
  67 |     | <span class='neutral'>    /**</span>
  68 |     | <span class='neutral'>     * @dev Returns the value in the last (most recent) checkpoint with key lower or equal than the search key, or zero</span>
  69 |     | <span class='neutral'>     * if there is none.</span>
  70 |     | <span class='neutral'>     *</span>
  71 |     | <span class='neutral'>     * NOTE: This is a variant of {upperLookup} that is optimized to find &quot;recent&quot; checkpoint (checkpoints with high</span>
  72 |     | <span class='neutral'>     * keys).</span>
  73 |     | <span class='neutral'>     */</span>
  74 |     | <span class='neutral'>    function upperLookupRecent(Trace224 storage self, uint32 key) internal view returns (uint224) {</span>
  75 |     | <span class='neutral'>        uint256 len = self._checkpoints.length;</span>
  76 |     | <span class='neutral'></span>
  77 |     | <span class='neutral'>        uint256 low = 0;</span>
  78 |     | <span class='neutral'>        uint256 high = len;</span>
  79 |     | <span class='neutral'></span>
  80 |     | <span class='neutral'>        if (len &gt; 5) {</span>
  81 |     | <span class='neutral'>            uint256 mid = len - Math.sqrt(len);</span>
  82 |     | <span class='neutral'>            if (key &lt; _unsafeAccess(self._checkpoints, mid)._key) {</span>
  83 |     | <span class='neutral'>                high = mid;</span>
  84 |     | <span class='neutral'>            } else {</span>
  85 |     | <span class='neutral'>                low = mid + 1;</span>
  86 |     | <span class='neutral'>            }</span>
  87 |     | <span class='neutral'>        }</span>
  88 |     | <span class='neutral'></span>
  89 |     | <span class='neutral'>        uint256 pos = _upperBinaryLookup(self._checkpoints, key, low, high);</span>
  90 |     | <span class='neutral'></span>
  91 |     | <span class='neutral'>        return pos == 0 ? 0 : _unsafeAccess(self._checkpoints, pos - 1)._value;</span>
  92 |     | <span class='neutral'>    }</span>
  93 |     | <span class='neutral'></span>
  94 |     | <span class='neutral'>    /**</span>
  95 |     | <span class='neutral'>     * @dev Returns the value in the most recent checkpoint, or zero if there are no checkpoints.</span>
  96 |     | <span class='neutral'>     */</span>
  97 |     | <span class='neutral'>    function latest(Trace224 storage self) internal view returns (uint224) {</span>
  98 |     | <span class='neutral'>        uint256 pos = self._checkpoints.length;</span>
  99 |     | <span class='neutral'>        return pos == 0 ? 0 : _unsafeAccess(self._checkpoints, pos - 1)._value;</span>
 100 |     | <span class='neutral'>    }</span>
 101 |     | <span class='neutral'></span>
 102 |     | <span class='neutral'>    /**</span>
 103 |     | <span class='neutral'>     * @dev Returns whether there is a checkpoint in the structure (i.e. it is not empty), and if so the key and value</span>
 104 |     | <span class='neutral'>     * in the most recent checkpoint.</span>
 105 |     | <span class='neutral'>     */</span>
 106 |     | <span class='neutral'>    function latestCheckpoint(Trace224 storage self) internal view returns (bool exists, uint32 _key, uint224 _value) {</span>
 107 |     | <span class='neutral'>        uint256 pos = self._checkpoints.length;</span>
 108 |     | <span class='neutral'>        if (pos == 0) {</span>
 109 |     | <span class='neutral'>            return (false, 0, 0);</span>
 110 |     | <span class='neutral'>        } else {</span>
 111 |     | <span class='neutral'>            Checkpoint224 storage ckpt = _unsafeAccess(self._checkpoints, pos - 1);</span>
 112 |     | <span class='neutral'>            return (true, ckpt._key, ckpt._value);</span>
 113 |     | <span class='neutral'>        }</span>
 114 |     | <span class='neutral'>    }</span>
 115 |     | <span class='neutral'></span>
 116 |     | <span class='neutral'>    /**</span>
 117 |     | <span class='neutral'>     * @dev Returns the number of checkpoints.</span>
 118 |     | <span class='neutral'>     */</span>
 119 |     | <span class='neutral'>    function length(Trace224 storage self) internal view returns (uint256) {</span>
 120 |     | <span class='neutral'>        return self._checkpoints.length;</span>
 121 |     | <span class='neutral'>    }</span>
 122 |     | <span class='neutral'></span>
 123 |     | <span class='neutral'>    /**</span>
 124 |     | <span class='neutral'>     * @dev Returns checkpoint at given position.</span>
 125 |     | <span class='neutral'>     */</span>
 126 |     | <span class='neutral'>    function at(Trace224 storage self, uint32 pos) internal view returns (Checkpoint224 memory) {</span>
 127 |     | <span class='neutral'>        return self._checkpoints[pos];</span>
 128 |     | <span class='neutral'>    }</span>
 129 |     | <span class='neutral'></span>
 130 |     | <span class='neutral'>    /**</span>
 131 |     | <span class='neutral'>     * @dev Pushes a (`key`, `value`) pair into an ordered list of checkpoints, either by inserting a new checkpoint,</span>
 132 |     | <span class='neutral'>     * or by updating the last one.</span>
 133 |     | <span class='neutral'>     */</span>
 134 |     | <span class='neutral'>    function _insert(</span>
 135 |     | <span class='neutral'>        Checkpoint224[] storage self,</span>
 136 |     | <span class='neutral'>        uint32 key,</span>
 137 |     | <span class='neutral'>        uint224 value</span>
 138 |     | <span class='neutral'>    ) private returns (uint224 oldValue, uint224 newValue) {</span>
 139 |     | <span class='neutral'>        uint256 pos = self.length;</span>
 140 |     | <span class='neutral'></span>
 141 |     | <span class='neutral'>        if (pos &gt; 0) {</span>
 142 |     | <span class='neutral'>            Checkpoint224 storage last = _unsafeAccess(self, pos - 1);</span>
 143 |     | <span class='neutral'>            uint32 lastKey = last._key;</span>
 144 |     | <span class='neutral'>            uint224 lastValue = last._value;</span>
 145 |     | <span class='neutral'></span>
 146 |     | <span class='neutral'>            // Checkpoint keys must be non-decreasing.</span>
 147 |     | <span class='neutral'>            if (lastKey &gt; key) {</span>
 148 |     | <span class='neutral'>                revert CheckpointUnorderedInsertion();</span>
 149 |     | <span class='neutral'>            }</span>
 150 |     | <span class='neutral'></span>
 151 |     | <span class='neutral'>            // Update or push new checkpoint</span>
 152 |     | <span class='neutral'>            if (lastKey == key) {</span>
 153 |     | <span class='neutral'>                last._value = value;</span>
 154 |     | <span class='neutral'>            } else {</span>
 155 |     | <span class='neutral'>                self.push(Checkpoint224({_key: key, _value: value}));</span>
 156 |     | <span class='neutral'>            }</span>
 157 |     | <span class='neutral'>            return (lastValue, value);</span>
 158 |     | <span class='neutral'>        } else {</span>
 159 |     | <span class='neutral'>            self.push(Checkpoint224({_key: key, _value: value}));</span>
 160 |     | <span class='neutral'>            return (0, value);</span>
 161 |     | <span class='neutral'>        }</span>
 162 |     | <span class='neutral'>    }</span>
 163 |     | <span class='neutral'></span>
 164 |     | <span class='neutral'>    /**</span>
 165 |     | <span class='neutral'>     * @dev Return the index of the first (oldest) checkpoint with key strictly bigger than the search key, or `high`</span>
 166 |     | <span class='neutral'>     * if there is none. `low` and `high` define a section where to do the search, with inclusive `low` and exclusive</span>
 167 |     | <span class='neutral'>     * `high`.</span>
 168 |     | <span class='neutral'>     *</span>
 169 |     | <span class='neutral'>     * WARNING: `high` should not be greater than the array&#39;s length.</span>
 170 |     | <span class='neutral'>     */</span>
 171 |     | <span class='neutral'>    function _upperBinaryLookup(</span>
 172 |     | <span class='neutral'>        Checkpoint224[] storage self,</span>
 173 |     | <span class='neutral'>        uint32 key,</span>
 174 |     | <span class='neutral'>        uint256 low,</span>
 175 |     | <span class='neutral'>        uint256 high</span>
 176 |     | <span class='neutral'>    ) private view returns (uint256) {</span>
 177 |     | <span class='neutral'>        while (low &lt; high) {</span>
 178 |     | <span class='neutral'>            uint256 mid = Math.average(low, high);</span>
 179 |     | <span class='neutral'>            if (_unsafeAccess(self, mid)._key &gt; key) {</span>
 180 |     | <span class='neutral'>                high = mid;</span>
 181 |     | <span class='neutral'>            } else {</span>
 182 |     | <span class='neutral'>                low = mid + 1;</span>
 183 |     | <span class='neutral'>            }</span>
 184 |     | <span class='neutral'>        }</span>
 185 |     | <span class='neutral'>        return high;</span>
 186 |     | <span class='neutral'>    }</span>
 187 |     | <span class='neutral'></span>
 188 |     | <span class='neutral'>    /**</span>
 189 |     | <span class='neutral'>     * @dev Return the index of the first (oldest) checkpoint with key greater or equal than the search key, or `high`</span>
 190 |     | <span class='neutral'>     * if there is none. `low` and `high` define a section where to do the search, with inclusive `low` and exclusive</span>
 191 |     | <span class='neutral'>     * `high`.</span>
 192 |     | <span class='neutral'>     *</span>
 193 |     | <span class='neutral'>     * WARNING: `high` should not be greater than the array&#39;s length.</span>
 194 |     | <span class='neutral'>     */</span>
 195 |     | <span class='neutral'>    function _lowerBinaryLookup(</span>
 196 |     | <span class='neutral'>        Checkpoint224[] storage self,</span>
 197 |     | <span class='neutral'>        uint32 key,</span>
 198 |     | <span class='neutral'>        uint256 low,</span>
 199 |     | <span class='neutral'>        uint256 high</span>
 200 |     | <span class='neutral'>    ) private view returns (uint256) {</span>
 201 |     | <span class='neutral'>        while (low &lt; high) {</span>
 202 |     | <span class='neutral'>            uint256 mid = Math.average(low, high);</span>
 203 |     | <span class='neutral'>            if (_unsafeAccess(self, mid)._key &lt; key) {</span>
 204 |     | <span class='neutral'>                low = mid + 1;</span>
 205 |     | <span class='neutral'>            } else {</span>
 206 |     | <span class='neutral'>                high = mid;</span>
 207 |     | <span class='neutral'>            }</span>
 208 |     | <span class='neutral'>        }</span>
 209 |     | <span class='neutral'>        return high;</span>
 210 |     | <span class='neutral'>    }</span>
 211 |     | <span class='neutral'></span>
 212 |     | <span class='neutral'>    /**</span>
 213 |     | <span class='neutral'>     * @dev Access an element of the array without performing bounds check. The position is assumed to be within bounds.</span>
 214 |     | <span class='neutral'>     */</span>
 215 |     | <span class='neutral'>    function _unsafeAccess(</span>
 216 |     | <span class='neutral'>        Checkpoint224[] storage self,</span>
 217 |     | <span class='neutral'>        uint256 pos</span>
 218 |     | <span class='neutral'>    ) private pure returns (Checkpoint224 storage result) {</span>
 219 |     | <span class='neutral'>        assembly {</span>
 220 |     | <span class='neutral'>            mstore(0, self.slot)</span>
 221 |     | <span class='neutral'>            result.slot := add(keccak256(0, 0x20), pos)</span>
 222 |     | <span class='neutral'>        }</span>
 223 |     | <span class='neutral'>    }</span>
 224 |     | <span class='neutral'></span>
 225 |     | <span class='neutral'>    struct Trace208 {</span>
 226 |     | <span class='neutral'>        Checkpoint208[] _checkpoints;</span>
 227 |     | <span class='neutral'>    }</span>
 228 |     | <span class='neutral'></span>
 229 |     | <span class='neutral'>    struct Checkpoint208 {</span>
 230 |     | <span class='neutral'>        uint48 _key;</span>
 231 |     | <span class='neutral'>        uint208 _value;</span>
 232 |     | <span class='neutral'>    }</span>
 233 |     | <span class='neutral'></span>
 234 |     | <span class='neutral'>    /**</span>
 235 |     | <span class='neutral'>     * @dev Pushes a (`key`, `value`) pair into a Trace208 so that it is stored as the checkpoint.</span>
 236 |     | <span class='neutral'>     *</span>
 237 |     | <span class='neutral'>     * Returns previous value and new value.</span>
 238 |     | <span class='neutral'>     *</span>
 239 |     | <span class='neutral'>     * IMPORTANT: Never accept `key` as a user input, since an arbitrary `type(uint48).max` key set will disable the</span>
 240 |     | <span class='neutral'>     * library.</span>
 241 |     | <span class='neutral'>     */</span>
 242 |     | <span class='neutral'>    function push(</span>
 243 |     | <span class='neutral'>        Trace208 storage self,</span>
 244 |     | <span class='neutral'>        uint48 key,</span>
 245 |     | <span class='neutral'>        uint208 value</span>
 246 |     | <span class='neutral'>    ) internal returns (uint208 oldValue, uint208 newValue) {</span>
 247 |     | <span class='neutral'>        return _insert(self._checkpoints, key, value);</span>
 248 |     | <span class='neutral'>    }</span>
 249 |     | <span class='neutral'></span>
 250 |     | <span class='neutral'>    /**</span>
 251 |     | <span class='neutral'>     * @dev Returns the value in the first (oldest) checkpoint with key greater or equal than the search key, or zero if</span>
 252 |     | <span class='neutral'>     * there is none.</span>
 253 |     | <span class='neutral'>     */</span>
 254 |     | <span class='neutral'>    function lowerLookup(Trace208 storage self, uint48 key) internal view returns (uint208) {</span>
 255 |     | <span class='neutral'>        uint256 len = self._checkpoints.length;</span>
 256 |     | <span class='neutral'>        uint256 pos = _lowerBinaryLookup(self._checkpoints, key, 0, len);</span>
 257 |     | <span class='neutral'>        return pos == len ? 0 : _unsafeAccess(self._checkpoints, pos)._value;</span>
 258 |     | <span class='neutral'>    }</span>
 259 |     | <span class='neutral'></span>
 260 |     | <span class='neutral'>    /**</span>
 261 |     | <span class='neutral'>     * @dev Returns the value in the last (most recent) checkpoint with key lower or equal than the search key, or zero</span>
 262 |     | <span class='neutral'>     * if there is none.</span>
 263 |     | <span class='neutral'>     */</span>
 264 |     | <span class='neutral'>    function upperLookup(Trace208 storage self, uint48 key) internal view returns (uint208) {</span>
 265 |     | <span class='neutral'>        uint256 len = self._checkpoints.length;</span>
 266 |     | <span class='neutral'>        uint256 pos = _upperBinaryLookup(self._checkpoints, key, 0, len);</span>
 267 |     | <span class='neutral'>        return pos == 0 ? 0 : _unsafeAccess(self._checkpoints, pos - 1)._value;</span>
 268 |     | <span class='neutral'>    }</span>
 269 |     | <span class='neutral'></span>
 270 |     | <span class='neutral'>    /**</span>
 271 |     | <span class='neutral'>     * @dev Returns the value in the last (most recent) checkpoint with key lower or equal than the search key, or zero</span>
 272 |     | <span class='neutral'>     * if there is none.</span>
 273 |     | <span class='neutral'>     *</span>
 274 |     | <span class='neutral'>     * NOTE: This is a variant of {upperLookup} that is optimized to find &quot;recent&quot; checkpoint (checkpoints with high</span>
 275 |     | <span class='neutral'>     * keys).</span>
 276 |     | <span class='neutral'>     */</span>
 277 |     | <span class='neutral'>    function upperLookupRecent(Trace208 storage self, uint48 key) internal view returns (uint208) {</span>
 278 |     | <span class='neutral'>        uint256 len = self._checkpoints.length;</span>
 279 |     | <span class='neutral'></span>
 280 |     | <span class='neutral'>        uint256 low = 0;</span>
 281 |     | <span class='neutral'>        uint256 high = len;</span>
 282 |     | <span class='neutral'></span>
 283 |     | <span class='neutral'>        if (len &gt; 5) {</span>
 284 |     | <span class='neutral'>            uint256 mid = len - Math.sqrt(len);</span>
 285 |     | <span class='neutral'>            if (key &lt; _unsafeAccess(self._checkpoints, mid)._key) {</span>
 286 |     | <span class='neutral'>                high = mid;</span>
 287 |     | <span class='neutral'>            } else {</span>
 288 |     | <span class='neutral'>                low = mid + 1;</span>
 289 |     | <span class='neutral'>            }</span>
 290 |     | <span class='neutral'>        }</span>
 291 |     | <span class='neutral'></span>
 292 |     | <span class='neutral'>        uint256 pos = _upperBinaryLookup(self._checkpoints, key, low, high);</span>
 293 |     | <span class='neutral'></span>
 294 |     | <span class='neutral'>        return pos == 0 ? 0 : _unsafeAccess(self._checkpoints, pos - 1)._value;</span>
 295 |     | <span class='neutral'>    }</span>
 296 |     | <span class='neutral'></span>
 297 |     | <span class='neutral'>    /**</span>
 298 |     | <span class='neutral'>     * @dev Returns the value in the most recent checkpoint, or zero if there are no checkpoints.</span>
 299 |     | <span class='neutral'>     */</span>
 300 |     | <span class='neutral'>    function latest(Trace208 storage self) internal view returns (uint208) {</span>
 301 |     | <span class='neutral'>        uint256 pos = self._checkpoints.length;</span>
 302 |     | <span class='neutral'>        return pos == 0 ? 0 : _unsafeAccess(self._checkpoints, pos - 1)._value;</span>
 303 |     | <span class='neutral'>    }</span>
 304 |     | <span class='neutral'></span>
 305 |     | <span class='neutral'>    /**</span>
 306 |     | <span class='neutral'>     * @dev Returns whether there is a checkpoint in the structure (i.e. it is not empty), and if so the key and value</span>
 307 |     | <span class='neutral'>     * in the most recent checkpoint.</span>
 308 |     | <span class='neutral'>     */</span>
 309 |     | <span class='neutral'>    function latestCheckpoint(Trace208 storage self) internal view returns (bool exists, uint48 _key, uint208 _value) {</span>
 310 |     | <span class='neutral'>        uint256 pos = self._checkpoints.length;</span>
 311 |     | <span class='neutral'>        if (pos == 0) {</span>
 312 |     | <span class='neutral'>            return (false, 0, 0);</span>
 313 |     | <span class='neutral'>        } else {</span>
 314 |     | <span class='neutral'>            Checkpoint208 storage ckpt = _unsafeAccess(self._checkpoints, pos - 1);</span>
 315 |     | <span class='neutral'>            return (true, ckpt._key, ckpt._value);</span>
 316 |     | <span class='neutral'>        }</span>
 317 |     | <span class='neutral'>    }</span>
 318 |     | <span class='neutral'></span>
 319 |     | <span class='neutral'>    /**</span>
 320 |     | <span class='neutral'>     * @dev Returns the number of checkpoints.</span>
 321 |     | <span class='neutral'>     */</span>
 322 |     | <span class='neutral'>    function length(Trace208 storage self) internal view returns (uint256) {</span>
 323 |     | <span class='neutral'>        return self._checkpoints.length;</span>
 324 |     | <span class='neutral'>    }</span>
 325 |     | <span class='neutral'></span>
 326 |     | <span class='neutral'>    /**</span>
 327 |     | <span class='neutral'>     * @dev Returns checkpoint at given position.</span>
 328 |     | <span class='neutral'>     */</span>
 329 |     | <span class='neutral'>    function at(Trace208 storage self, uint32 pos) internal view returns (Checkpoint208 memory) {</span>
 330 |     | <span class='neutral'>        return self._checkpoints[pos];</span>
 331 |     | <span class='neutral'>    }</span>
 332 |     | <span class='neutral'></span>
 333 |     | <span class='neutral'>    /**</span>
 334 |     | <span class='neutral'>     * @dev Pushes a (`key`, `value`) pair into an ordered list of checkpoints, either by inserting a new checkpoint,</span>
 335 |     | <span class='neutral'>     * or by updating the last one.</span>
 336 |     | <span class='neutral'>     */</span>
 337 |     | <span class='neutral'>    function _insert(</span>
 338 |     | <span class='neutral'>        Checkpoint208[] storage self,</span>
 339 |     | <span class='neutral'>        uint48 key,</span>
 340 |     | <span class='neutral'>        uint208 value</span>
 341 |     | <span class='neutral'>    ) private returns (uint208 oldValue, uint208 newValue) {</span>
 342 |     | <span class='neutral'>        uint256 pos = self.length;</span>
 343 |     | <span class='neutral'></span>
 344 |     | <span class='neutral'>        if (pos &gt; 0) {</span>
 345 |     | <span class='neutral'>            Checkpoint208 storage last = _unsafeAccess(self, pos - 1);</span>
 346 |     | <span class='neutral'>            uint48 lastKey = last._key;</span>
 347 |     | <span class='neutral'>            uint208 lastValue = last._value;</span>
 348 |     | <span class='neutral'></span>
 349 |     | <span class='neutral'>            // Checkpoint keys must be non-decreasing.</span>
 350 |     | <span class='neutral'>            if (lastKey &gt; key) {</span>
 351 |     | <span class='neutral'>                revert CheckpointUnorderedInsertion();</span>
 352 |     | <span class='neutral'>            }</span>
 353 |     | <span class='neutral'></span>
 354 |     | <span class='neutral'>            // Update or push new checkpoint</span>
 355 |     | <span class='neutral'>            if (lastKey == key) {</span>
 356 |     | <span class='neutral'>                last._value = value;</span>
 357 |     | <span class='neutral'>            } else {</span>
 358 |     | <span class='neutral'>                self.push(Checkpoint208({_key: key, _value: value}));</span>
 359 |     | <span class='neutral'>            }</span>
 360 |     | <span class='neutral'>            return (lastValue, value);</span>
 361 |     | <span class='neutral'>        } else {</span>
 362 |     | <span class='neutral'>            self.push(Checkpoint208({_key: key, _value: value}));</span>
 363 |     | <span class='neutral'>            return (0, value);</span>
 364 |     | <span class='neutral'>        }</span>
 365 |     | <span class='neutral'>    }</span>
 366 |     | <span class='neutral'></span>
 367 |     | <span class='neutral'>    /**</span>
 368 |     | <span class='neutral'>     * @dev Return the index of the first (oldest) checkpoint with key strictly bigger than the search key, or `high`</span>
 369 |     | <span class='neutral'>     * if there is none. `low` and `high` define a section where to do the search, with inclusive `low` and exclusive</span>
 370 |     | <span class='neutral'>     * `high`.</span>
 371 |     | <span class='neutral'>     *</span>
 372 |     | <span class='neutral'>     * WARNING: `high` should not be greater than the array&#39;s length.</span>
 373 |     | <span class='neutral'>     */</span>
 374 |     | <span class='neutral'>    function _upperBinaryLookup(</span>
 375 |     | <span class='neutral'>        Checkpoint208[] storage self,</span>
 376 |     | <span class='neutral'>        uint48 key,</span>
 377 |     | <span class='neutral'>        uint256 low,</span>
 378 |     | <span class='neutral'>        uint256 high</span>
 379 |     | <span class='neutral'>    ) private view returns (uint256) {</span>
 380 |     | <span class='neutral'>        while (low &lt; high) {</span>
 381 |     | <span class='neutral'>            uint256 mid = Math.average(low, high);</span>
 382 |     | <span class='neutral'>            if (_unsafeAccess(self, mid)._key &gt; key) {</span>
 383 |     | <span class='neutral'>                high = mid;</span>
 384 |     | <span class='neutral'>            } else {</span>
 385 |     | <span class='neutral'>                low = mid + 1;</span>
 386 |     | <span class='neutral'>            }</span>
 387 |     | <span class='neutral'>        }</span>
 388 |     | <span class='neutral'>        return high;</span>
 389 |     | <span class='neutral'>    }</span>
 390 |     | <span class='neutral'></span>
 391 |     | <span class='neutral'>    /**</span>
 392 |     | <span class='neutral'>     * @dev Return the index of the first (oldest) checkpoint with key greater or equal than the search key, or `high`</span>
 393 |     | <span class='neutral'>     * if there is none. `low` and `high` define a section where to do the search, with inclusive `low` and exclusive</span>
 394 |     | <span class='neutral'>     * `high`.</span>
 395 |     | <span class='neutral'>     *</span>
 396 |     | <span class='neutral'>     * WARNING: `high` should not be greater than the array&#39;s length.</span>
 397 |     | <span class='neutral'>     */</span>
 398 |     | <span class='neutral'>    function _lowerBinaryLookup(</span>
 399 |     | <span class='neutral'>        Checkpoint208[] storage self,</span>
 400 |     | <span class='neutral'>        uint48 key,</span>
 401 |     | <span class='neutral'>        uint256 low,</span>
 402 |     | <span class='neutral'>        uint256 high</span>
 403 |     | <span class='neutral'>    ) private view returns (uint256) {</span>
 404 |     | <span class='neutral'>        while (low &lt; high) {</span>
 405 |     | <span class='neutral'>            uint256 mid = Math.average(low, high);</span>
 406 |     | <span class='neutral'>            if (_unsafeAccess(self, mid)._key &lt; key) {</span>
 407 |     | <span class='neutral'>                low = mid + 1;</span>
 408 |     | <span class='neutral'>            } else {</span>
 409 |     | <span class='neutral'>                high = mid;</span>
 410 |     | <span class='neutral'>            }</span>
 411 |     | <span class='neutral'>        }</span>
 412 |     | <span class='neutral'>        return high;</span>
 413 |     | <span class='neutral'>    }</span>
 414 |     | <span class='neutral'></span>
 415 |     | <span class='neutral'>    /**</span>
 416 |     | <span class='neutral'>     * @dev Access an element of the array without performing bounds check. The position is assumed to be within bounds.</span>
 417 |     | <span class='neutral'>     */</span>
 418 |     | <span class='neutral'>    function _unsafeAccess(</span>
 419 |     | <span class='neutral'>        Checkpoint208[] storage self,</span>
 420 |     | <span class='neutral'>        uint256 pos</span>
 421 |     | <span class='neutral'>    ) private pure returns (Checkpoint208 storage result) {</span>
 422 |     | <span class='neutral'>        assembly {</span>
 423 |     | <span class='neutral'>            mstore(0, self.slot)</span>
 424 |     | <span class='neutral'>            result.slot := add(keccak256(0, 0x20), pos)</span>
 425 |     | <span class='neutral'>        }</span>
 426 |     | <span class='neutral'>    }</span>
 427 |     | <span class='neutral'></span>
 428 |     | <span class='neutral'>    struct Trace160 {</span>
 429 |     | <span class='neutral'>        Checkpoint160[] _checkpoints;</span>
 430 |     | <span class='neutral'>    }</span>
 431 |     | <span class='neutral'></span>
 432 |     | <span class='neutral'>    struct Checkpoint160 {</span>
 433 |     | <span class='neutral'>        uint96 _key;</span>
 434 |     | <span class='neutral'>        uint160 _value;</span>
 435 |     | <span class='neutral'>    }</span>
 436 |     | <span class='neutral'></span>
 437 |     | <span class='neutral'>    /**</span>
 438 |     | <span class='neutral'>     * @dev Pushes a (`key`, `value`) pair into a Trace160 so that it is stored as the checkpoint.</span>
 439 |     | <span class='neutral'>     *</span>
 440 |     | <span class='neutral'>     * Returns previous value and new value.</span>
 441 |     | <span class='neutral'>     *</span>
 442 |     | <span class='neutral'>     * IMPORTANT: Never accept `key` as a user input, since an arbitrary `type(uint96).max` key set will disable the</span>
 443 |     | <span class='neutral'>     * library.</span>
 444 |     | <span class='neutral'>     */</span>
 445 |     | <span class='neutral'>    function push(</span>
 446 |     | <span class='neutral'>        Trace160 storage self,</span>
 447 |     | <span class='neutral'>        uint96 key,</span>
 448 |     | <span class='neutral'>        uint160 value</span>
 449 |     | <span class='neutral'>    ) internal returns (uint160 oldValue, uint160 newValue) {</span>
 450 |     | <span class='neutral'>        return _insert(self._checkpoints, key, value);</span>
 451 |     | <span class='neutral'>    }</span>
 452 |     | <span class='neutral'></span>
 453 |     | <span class='neutral'>    /**</span>
 454 |     | <span class='neutral'>     * @dev Returns the value in the first (oldest) checkpoint with key greater or equal than the search key, or zero if</span>
 455 |     | <span class='neutral'>     * there is none.</span>
 456 |     | <span class='neutral'>     */</span>
 457 |     | <span class='neutral'>    function lowerLookup(Trace160 storage self, uint96 key) internal view returns (uint160) {</span>
 458 |     | <span class='neutral'>        uint256 len = self._checkpoints.length;</span>
 459 |     | <span class='neutral'>        uint256 pos = _lowerBinaryLookup(self._checkpoints, key, 0, len);</span>
 460 |     | <span class='neutral'>        return pos == len ? 0 : _unsafeAccess(self._checkpoints, pos)._value;</span>
 461 |     | <span class='neutral'>    }</span>
 462 |     | <span class='neutral'></span>
 463 |     | <span class='neutral'>    /**</span>
 464 |     | <span class='neutral'>     * @dev Returns the value in the last (most recent) checkpoint with key lower or equal than the search key, or zero</span>
 465 |     | <span class='neutral'>     * if there is none.</span>
 466 |     | <span class='neutral'>     */</span>
 467 |     | <span class='neutral'>    function upperLookup(Trace160 storage self, uint96 key) internal view returns (uint160) {</span>
 468 |     | <span class='neutral'>        uint256 len = self._checkpoints.length;</span>
 469 |     | <span class='neutral'>        uint256 pos = _upperBinaryLookup(self._checkpoints, key, 0, len);</span>
 470 |     | <span class='neutral'>        return pos == 0 ? 0 : _unsafeAccess(self._checkpoints, pos - 1)._value;</span>
 471 |     | <span class='neutral'>    }</span>
 472 |     | <span class='neutral'></span>
 473 |     | <span class='neutral'>    /**</span>
 474 |     | <span class='neutral'>     * @dev Returns the value in the last (most recent) checkpoint with key lower or equal than the search key, or zero</span>
 475 |     | <span class='neutral'>     * if there is none.</span>
 476 |     | <span class='neutral'>     *</span>
 477 |     | <span class='neutral'>     * NOTE: This is a variant of {upperLookup} that is optimized to find &quot;recent&quot; checkpoint (checkpoints with high</span>
 478 |     | <span class='neutral'>     * keys).</span>
 479 |     | <span class='neutral'>     */</span>
 480 |     | <span class='neutral'>    function upperLookupRecent(Trace160 storage self, uint96 key) internal view returns (uint160) {</span>
 481 |     | <span class='neutral'>        uint256 len = self._checkpoints.length;</span>
 482 |     | <span class='neutral'></span>
 483 |     | <span class='neutral'>        uint256 low = 0;</span>
 484 |     | <span class='neutral'>        uint256 high = len;</span>
 485 |     | <span class='neutral'></span>
 486 |     | <span class='neutral'>        if (len &gt; 5) {</span>
 487 |     | <span class='neutral'>            uint256 mid = len - Math.sqrt(len);</span>
 488 |     | <span class='neutral'>            if (key &lt; _unsafeAccess(self._checkpoints, mid)._key) {</span>
 489 |     | <span class='neutral'>                high = mid;</span>
 490 |     | <span class='neutral'>            } else {</span>
 491 |     | <span class='neutral'>                low = mid + 1;</span>
 492 |     | <span class='neutral'>            }</span>
 493 |     | <span class='neutral'>        }</span>
 494 |     | <span class='neutral'></span>
 495 |     | <span class='neutral'>        uint256 pos = _upperBinaryLookup(self._checkpoints, key, low, high);</span>
 496 |     | <span class='neutral'></span>
 497 |     | <span class='neutral'>        return pos == 0 ? 0 : _unsafeAccess(self._checkpoints, pos - 1)._value;</span>
 498 |     | <span class='neutral'>    }</span>
 499 |     | <span class='neutral'></span>
 500 |     | <span class='neutral'>    /**</span>
 501 |     | <span class='neutral'>     * @dev Returns the value in the most recent checkpoint, or zero if there are no checkpoints.</span>
 502 |     | <span class='neutral'>     */</span>
 503 |     | <span class='neutral'>    function latest(Trace160 storage self) internal view returns (uint160) {</span>
 504 |     | <span class='neutral'>        uint256 pos = self._checkpoints.length;</span>
 505 |     | <span class='neutral'>        return pos == 0 ? 0 : _unsafeAccess(self._checkpoints, pos - 1)._value;</span>
 506 |     | <span class='neutral'>    }</span>
 507 |     | <span class='neutral'></span>
 508 |     | <span class='neutral'>    /**</span>
 509 |     | <span class='neutral'>     * @dev Returns whether there is a checkpoint in the structure (i.e. it is not empty), and if so the key and value</span>
 510 |     | <span class='neutral'>     * in the most recent checkpoint.</span>
 511 |     | <span class='neutral'>     */</span>
 512 |     | <span class='neutral'>    function latestCheckpoint(Trace160 storage self) internal view returns (bool exists, uint96 _key, uint160 _value) {</span>
 513 |     | <span class='neutral'>        uint256 pos = self._checkpoints.length;</span>
 514 |     | <span class='neutral'>        if (pos == 0) {</span>
 515 |     | <span class='neutral'>            return (false, 0, 0);</span>
 516 |     | <span class='neutral'>        } else {</span>
 517 |     | <span class='neutral'>            Checkpoint160 storage ckpt = _unsafeAccess(self._checkpoints, pos - 1);</span>
 518 |     | <span class='neutral'>            return (true, ckpt._key, ckpt._value);</span>
 519 |     | <span class='neutral'>        }</span>
 520 |     | <span class='neutral'>    }</span>
 521 |     | <span class='neutral'></span>
 522 |     | <span class='neutral'>    /**</span>
 523 |     | <span class='neutral'>     * @dev Returns the number of checkpoints.</span>
 524 |     | <span class='neutral'>     */</span>
 525 |     | <span class='neutral'>    function length(Trace160 storage self) internal view returns (uint256) {</span>
 526 |     | <span class='neutral'>        return self._checkpoints.length;</span>
 527 |     | <span class='neutral'>    }</span>
 528 |     | <span class='neutral'></span>
 529 |     | <span class='neutral'>    /**</span>
 530 |     | <span class='neutral'>     * @dev Returns checkpoint at given position.</span>
 531 |     | <span class='neutral'>     */</span>
 532 |     | <span class='neutral'>    function at(Trace160 storage self, uint32 pos) internal view returns (Checkpoint160 memory) {</span>
 533 |     | <span class='neutral'>        return self._checkpoints[pos];</span>
 534 |     | <span class='neutral'>    }</span>
 535 |     | <span class='neutral'></span>
 536 |     | <span class='neutral'>    /**</span>
 537 |     | <span class='neutral'>     * @dev Pushes a (`key`, `value`) pair into an ordered list of checkpoints, either by inserting a new checkpoint,</span>
 538 |     | <span class='neutral'>     * or by updating the last one.</span>
 539 |     | <span class='neutral'>     */</span>
 540 |     | <span class='neutral'>    function _insert(</span>
 541 |     | <span class='neutral'>        Checkpoint160[] storage self,</span>
 542 |     | <span class='neutral'>        uint96 key,</span>
 543 |     | <span class='neutral'>        uint160 value</span>
 544 |     | <span class='neutral'>    ) private returns (uint160 oldValue, uint160 newValue) {</span>
 545 |     | <span class='neutral'>        uint256 pos = self.length;</span>
 546 |     | <span class='neutral'></span>
 547 |     | <span class='neutral'>        if (pos &gt; 0) {</span>
 548 |     | <span class='neutral'>            Checkpoint160 storage last = _unsafeAccess(self, pos - 1);</span>
 549 |     | <span class='neutral'>            uint96 lastKey = last._key;</span>
 550 |     | <span class='neutral'>            uint160 lastValue = last._value;</span>
 551 |     | <span class='neutral'></span>
 552 |     | <span class='neutral'>            // Checkpoint keys must be non-decreasing.</span>
 553 |     | <span class='neutral'>            if (lastKey &gt; key) {</span>
 554 |     | <span class='neutral'>                revert CheckpointUnorderedInsertion();</span>
 555 |     | <span class='neutral'>            }</span>
 556 |     | <span class='neutral'></span>
 557 |     | <span class='neutral'>            // Update or push new checkpoint</span>
 558 |     | <span class='neutral'>            if (lastKey == key) {</span>
 559 |     | <span class='neutral'>                last._value = value;</span>
 560 |     | <span class='neutral'>            } else {</span>
 561 |     | <span class='neutral'>                self.push(Checkpoint160({_key: key, _value: value}));</span>
 562 |     | <span class='neutral'>            }</span>
 563 |     | <span class='neutral'>            return (lastValue, value);</span>
 564 |     | <span class='neutral'>        } else {</span>
 565 |     | <span class='neutral'>            self.push(Checkpoint160({_key: key, _value: value}));</span>
 566 |     | <span class='neutral'>            return (0, value);</span>
 567 |     | <span class='neutral'>        }</span>
 568 |     | <span class='neutral'>    }</span>
 569 |     | <span class='neutral'></span>
 570 |     | <span class='neutral'>    /**</span>
 571 |     | <span class='neutral'>     * @dev Return the index of the first (oldest) checkpoint with key strictly bigger than the search key, or `high`</span>
 572 |     | <span class='neutral'>     * if there is none. `low` and `high` define a section where to do the search, with inclusive `low` and exclusive</span>
 573 |     | <span class='neutral'>     * `high`.</span>
 574 |     | <span class='neutral'>     *</span>
 575 |     | <span class='neutral'>     * WARNING: `high` should not be greater than the array&#39;s length.</span>
 576 |     | <span class='neutral'>     */</span>
 577 |     | <span class='neutral'>    function _upperBinaryLookup(</span>
 578 |     | <span class='neutral'>        Checkpoint160[] storage self,</span>
 579 |     | <span class='neutral'>        uint96 key,</span>
 580 |     | <span class='neutral'>        uint256 low,</span>
 581 |     | <span class='neutral'>        uint256 high</span>
 582 |     | <span class='neutral'>    ) private view returns (uint256) {</span>
 583 |     | <span class='neutral'>        while (low &lt; high) {</span>
 584 |     | <span class='neutral'>            uint256 mid = Math.average(low, high);</span>
 585 |     | <span class='neutral'>            if (_unsafeAccess(self, mid)._key &gt; key) {</span>
 586 |     | <span class='neutral'>                high = mid;</span>
 587 |     | <span class='neutral'>            } else {</span>
 588 |     | <span class='neutral'>                low = mid + 1;</span>
 589 |     | <span class='neutral'>            }</span>
 590 |     | <span class='neutral'>        }</span>
 591 |     | <span class='neutral'>        return high;</span>
 592 |     | <span class='neutral'>    }</span>
 593 |     | <span class='neutral'></span>
 594 |     | <span class='neutral'>    /**</span>
 595 |     | <span class='neutral'>     * @dev Return the index of the first (oldest) checkpoint with key greater or equal than the search key, or `high`</span>
 596 |     | <span class='neutral'>     * if there is none. `low` and `high` define a section where to do the search, with inclusive `low` and exclusive</span>
 597 |     | <span class='neutral'>     * `high`.</span>
 598 |     | <span class='neutral'>     *</span>
 599 |     | <span class='neutral'>     * WARNING: `high` should not be greater than the array&#39;s length.</span>
 600 |     | <span class='neutral'>     */</span>
 601 |     | <span class='neutral'>    function _lowerBinaryLookup(</span>
 602 |     | <span class='neutral'>        Checkpoint160[] storage self,</span>
 603 |     | <span class='neutral'>        uint96 key,</span>
 604 |     | <span class='neutral'>        uint256 low,</span>
 605 |     | <span class='neutral'>        uint256 high</span>
 606 |     | <span class='neutral'>    ) private view returns (uint256) {</span>
 607 |     | <span class='neutral'>        while (low &lt; high) {</span>
 608 |     | <span class='neutral'>            uint256 mid = Math.average(low, high);</span>
 609 |     | <span class='neutral'>            if (_unsafeAccess(self, mid)._key &lt; key) {</span>
 610 |     | <span class='neutral'>                low = mid + 1;</span>
 611 |     | <span class='neutral'>            } else {</span>
 612 |     | <span class='neutral'>                high = mid;</span>
 613 |     | <span class='neutral'>            }</span>
 614 |     | <span class='neutral'>        }</span>
 615 |     | <span class='neutral'>        return high;</span>
 616 |     | <span class='neutral'>    }</span>
 617 |     | <span class='neutral'></span>
 618 |     | <span class='neutral'>    /**</span>
 619 |     | <span class='neutral'>     * @dev Access an element of the array without performing bounds check. The position is assumed to be within bounds.</span>
 620 |     | <span class='neutral'>     */</span>
 621 |     | <span class='neutral'>    function _unsafeAccess(</span>
 622 |     | <span class='neutral'>        Checkpoint160[] storage self,</span>
 623 |     | <span class='neutral'>        uint256 pos</span>
 624 |     | <span class='neutral'>    ) private pure returns (Checkpoint160 storage result) {</span>
 625 |     | <span class='neutral'>        assembly {</span>
 626 |     | <span class='neutral'>            mstore(0, self.slot)</span>
 627 |     | <span class='neutral'>            result.slot := add(keccak256(0, 0x20), pos)</span>
 628 |     | <span class='neutral'>        }</span>
 629 |     | <span class='neutral'>    }</span>
 630 |     | <span class='neutral'>}</span>
 631 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/phantom/Documents/azemora/azemora-contracts/lib/openzeppelin-contracts/contracts/utils/structs/DoubleEndedQueue.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'>// OpenZeppelin Contracts (last updated v5.1.0) (utils/structs/DoubleEndedQueue.sol)</span>
   3 |     | <span class='neutral'>pragma solidity ^0.8.20;</span>
   4 |     | <span class='neutral'></span>
   5 |     | <span class='neutral'>import {Panic} from &quot;../Panic.sol&quot;;</span>
   6 |     | <span class='neutral'></span>
   7 |     | <span class='neutral'>/**</span>
   8 |     | <span class='neutral'> * @dev A sequence of items with the ability to efficiently push and pop items (i.e. insert and remove) on both ends of</span>
   9 |     | <span class='neutral'> * the sequence (called front and back). Among other access patterns, it can be used to implement efficient LIFO and</span>
  10 |     | <span class='unexecuted'> * FIFO queues. Storage use is optimized, and all operations are O(1) constant time. This includes {clear}, given that</span>
  11 |     | <span class='neutral'> * the existing queue contents are left in storage.</span>
  12 |     | <span class='neutral'> *</span>
  13 |     | <span class='neutral'> * The struct is called `Bytes32Deque`. Other types can be cast to and from `bytes32`. This data structure can only be</span>
  14 |     | <span class='neutral'> * used in storage, and not in memory.</span>
  15 |     | <span class='neutral'> * ```solidity</span>
  16 |     | <span class='neutral'> * DoubleEndedQueue.Bytes32Deque queue;</span>
  17 |     | <span class='neutral'> * ```</span>
  18 |     | <span class='neutral'> */</span>
  19 |     | <span class='neutral'>library DoubleEndedQueue {</span>
  20 |     | <span class='neutral'>    /**</span>
  21 |     | <span class='neutral'>     * @dev Indices are 128 bits so begin and end are packed in a single storage slot for efficient access.</span>
  22 |     | <span class='neutral'>     *</span>
  23 | *   | <span class='executed'>     * Struct members have an underscore prefix indicating that they are &quot;private&quot; and should not be read or written to</span>
  24 | *   | <span class='executed'>     * directly. Use the functions provided below instead. Modifying the struct manually may violate assumptions and</span>
  25 | *   | <span class='executed'>     * lead to unexpected behavior.</span>
  26 | *   | <span class='executed'>     *</span>
  27 | *   | <span class='executed'>     * The first item is at data[begin] and the last item is at data[end - 1]. This range can wrap around.</span>
  28 | *   | <span class='executed'>     */</span>
  29 | *   | <span class='executed'>    struct Bytes32Deque {</span>
  30 |     | <span class='neutral'>        uint128 _begin;</span>
  31 |     | <span class='neutral'>        uint128 _end;</span>
  32 |     | <span class='neutral'>        mapping(uint128 index =&gt; bytes32) _data;</span>
  33 |     | <span class='unexecuted'>    }</span>
  34 |     | <span class='neutral'></span>
  35 |     | <span class='neutral'>    /**</span>
  36 |     | <span class='neutral'>     * @dev Inserts an item at the end of the queue.</span>
  37 |     | <span class='neutral'>     *</span>
  38 | *   | <span class='executed'>     * Reverts with {Panic-RESOURCE_ERROR} if the queue is full.</span>
  39 | *   | <span class='executed'>     */</span>
  40 |     | <span class='neutral'>    function pushBack(Bytes32Deque storage deque, bytes32 value) internal {</span>
  41 | *   | <span class='executed'>        unchecked {</span>
  42 |     | <span class='neutral'>            uint128 backIndex = deque._end;</span>
  43 |     | <span class='neutral'>            if (backIndex + 1 == deque._begin) Panic.panic(Panic.RESOURCE_ERROR);</span>
  44 |     | <span class='unexecuted'>            deque._data[backIndex] = value;</span>
  45 |     | <span class='neutral'>            deque._end = backIndex + 1;</span>
  46 |     | <span class='neutral'>        }</span>
  47 |     | <span class='neutral'>    }</span>
  48 |     | <span class='neutral'></span>
  49 |     | <span class='neutral'>    /**</span>
  50 |     | <span class='neutral'>     * @dev Removes the item at the end of the queue and returns it.</span>
  51 |     | <span class='neutral'>     *</span>
  52 |     | <span class='neutral'>     * Reverts with {Panic-EMPTY_ARRAY_POP} if the queue is empty.</span>
  53 |     | <span class='neutral'>     */</span>
  54 |     | <span class='neutral'>    function popBack(Bytes32Deque storage deque) internal returns (bytes32 value) {</span>
  55 |     | <span class='neutral'>        unchecked {</span>
  56 |     | <span class='neutral'>            uint128 backIndex = deque._end;</span>
  57 |     | <span class='neutral'>            if (backIndex == deque._begin) Panic.panic(Panic.EMPTY_ARRAY_POP);</span>
  58 |     | <span class='neutral'>            --backIndex;</span>
  59 |     | <span class='neutral'>            value = deque._data[backIndex];</span>
  60 |     | <span class='neutral'>            delete deque._data[backIndex];</span>
  61 |     | <span class='neutral'>            deque._end = backIndex;</span>
  62 |     | <span class='neutral'>        }</span>
  63 |     | <span class='neutral'>    }</span>
  64 |     | <span class='neutral'></span>
  65 |     | <span class='neutral'>    /**</span>
  66 |     | <span class='unexecuted'>     * @dev Inserts an item at the beginning of the queue.</span>
  67 |     | <span class='neutral'>     *</span>
  68 |     | <span class='neutral'>     * Reverts with {Panic-RESOURCE_ERROR} if the queue is full.</span>
  69 |     | <span class='neutral'>     */</span>
  70 |     | <span class='neutral'>    function pushFront(Bytes32Deque storage deque, bytes32 value) internal {</span>
  71 |     | <span class='unexecuted'>        unchecked {</span>
  72 |     | <span class='unexecuted'>            uint128 frontIndex = deque._begin - 1;</span>
  73 |     | <span class='unexecuted'>            if (frontIndex == deque._end) Panic.panic(Panic.RESOURCE_ERROR);</span>
  74 |     | <span class='neutral'>            deque._data[frontIndex] = value;</span>
  75 |     | <span class='unexecuted'>            deque._begin = frontIndex;</span>
  76 |     | <span class='neutral'>        }</span>
  77 |     | <span class='neutral'>    }</span>
  78 |     | <span class='neutral'></span>
  79 |     | <span class='neutral'>    /**</span>
  80 |     | <span class='neutral'>     * @dev Removes the item at the beginning of the queue and returns it.</span>
  81 |     | <span class='neutral'>     *</span>
  82 |     | <span class='unexecuted'>     * Reverts with {Panic-EMPTY_ARRAY_POP} if the queue is empty.</span>
  83 |     | <span class='neutral'>     */</span>
  84 |     | <span class='neutral'>    function popFront(Bytes32Deque storage deque) internal returns (bytes32 value) {</span>
  85 |     | <span class='neutral'>        unchecked {</span>
  86 |     | <span class='neutral'>            uint128 frontIndex = deque._begin;</span>
  87 |     | <span class='neutral'>            if (frontIndex == deque._end) Panic.panic(Panic.EMPTY_ARRAY_POP);</span>
  88 |     | <span class='neutral'>            value = deque._data[frontIndex];</span>
  89 |     | <span class='neutral'>            delete deque._data[frontIndex];</span>
  90 |     | <span class='neutral'>            deque._begin = frontIndex + 1;</span>
  91 |     | <span class='neutral'>        }</span>
  92 |     | <span class='neutral'>    }</span>
  93 |     | <span class='neutral'></span>
  94 |     | <span class='neutral'>    /**</span>
  95 |     | <span class='neutral'>     * @dev Returns the item at the beginning of the queue.</span>
  96 |     | <span class='neutral'>     *</span>
  97 |     | <span class='neutral'>     * Reverts with {Panic-ARRAY_OUT_OF_BOUNDS} if the queue is empty.</span>
  98 |     | <span class='neutral'>     */</span>
  99 |     | <span class='neutral'>    function front(Bytes32Deque storage deque) internal view returns (bytes32 value) {</span>
 100 |     | <span class='neutral'>        if (empty(deque)) Panic.panic(Panic.ARRAY_OUT_OF_BOUNDS);</span>
 101 |     | <span class='neutral'>        return deque._data[deque._begin];</span>
 102 |     | <span class='neutral'>    }</span>
 103 |     | <span class='neutral'></span>
 104 |     | <span class='neutral'>    /**</span>
 105 |     | <span class='neutral'>     * @dev Returns the item at the end of the queue.</span>
 106 |     | <span class='neutral'>     *</span>
 107 |     | <span class='neutral'>     * Reverts with {Panic-ARRAY_OUT_OF_BOUNDS} if the queue is empty.</span>
 108 |     | <span class='neutral'>     */</span>
 109 |     | <span class='neutral'>    function back(Bytes32Deque storage deque) internal view returns (bytes32 value) {</span>
 110 |     | <span class='neutral'>        if (empty(deque)) Panic.panic(Panic.ARRAY_OUT_OF_BOUNDS);</span>
 111 |     | <span class='neutral'>        unchecked {</span>
 112 |     | <span class='neutral'>            return deque._data[deque._end - 1];</span>
 113 |     | <span class='neutral'>        }</span>
 114 |     | <span class='neutral'>    }</span>
 115 |     | <span class='neutral'></span>
 116 |     | <span class='neutral'>    /**</span>
 117 |     | <span class='neutral'>     * @dev Return the item at a position in the queue given by `index`, with the first item at 0 and last item at</span>
 118 |     | <span class='neutral'>     * `length(deque) - 1`.</span>
 119 |     | <span class='neutral'>     *</span>
 120 |     | <span class='neutral'>     * Reverts with {Panic-ARRAY_OUT_OF_BOUNDS} if the index is out of bounds.</span>
 121 |     | <span class='neutral'>     */</span>
 122 |     | <span class='neutral'>    function at(Bytes32Deque storage deque, uint256 index) internal view returns (bytes32 value) {</span>
 123 |     | <span class='neutral'>        if (index &gt;= length(deque)) Panic.panic(Panic.ARRAY_OUT_OF_BOUNDS);</span>
 124 |     | <span class='neutral'>        // By construction, length is a uint128, so the check above ensures that index can be safely downcast to uint128</span>
 125 |     | <span class='neutral'>        unchecked {</span>
 126 |     | <span class='neutral'>            return deque._data[deque._begin + uint128(index)];</span>
 127 |     | <span class='neutral'>        }</span>
 128 |     | <span class='neutral'>    }</span>
 129 |     | <span class='neutral'></span>
 130 |     | <span class='neutral'>    /**</span>
 131 |     | <span class='neutral'>     * @dev Resets the queue back to being empty.</span>
 132 |     | <span class='neutral'>     *</span>
 133 |     | <span class='neutral'>     * NOTE: The current items are left behind in storage. This does not affect the functioning of the queue, but misses</span>
 134 |     | <span class='neutral'>     * out on potential gas refunds.</span>
 135 |     | <span class='neutral'>     */</span>
 136 |     | <span class='neutral'>    function clear(Bytes32Deque storage deque) internal {</span>
 137 |     | <span class='neutral'>        deque._begin = 0;</span>
 138 |     | <span class='neutral'>        deque._end = 0;</span>
 139 |     | <span class='neutral'>    }</span>
 140 |     | <span class='neutral'></span>
 141 |     | <span class='neutral'>    /**</span>
 142 |     | <span class='neutral'>     * @dev Returns the number of items in the queue.</span>
 143 |     | <span class='neutral'>     */</span>
 144 |     | <span class='neutral'>    function length(Bytes32Deque storage deque) internal view returns (uint256) {</span>
 145 |     | <span class='neutral'>        unchecked {</span>
 146 |     | <span class='neutral'>            return uint256(deque._end - deque._begin);</span>
 147 |     | <span class='neutral'>        }</span>
 148 |     | <span class='neutral'>    }</span>
 149 |     | <span class='neutral'></span>
 150 |     | <span class='neutral'>    /**</span>
 151 |     | <span class='neutral'>     * @dev Returns true if the queue is empty.</span>
 152 |     | <span class='neutral'>     */</span>
 153 |     | <span class='neutral'>    function empty(Bytes32Deque storage deque) internal view returns (bool) {</span>
 154 |     | <span class='neutral'>        return deque._end == deque._begin;</span>
 155 |     | <span class='neutral'>    }</span>
 156 |     | <span class='neutral'>}</span>
 157 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/phantom/Documents/azemora/azemora-contracts/lib/openzeppelin-contracts/contracts/utils/types/Time.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'>// OpenZeppelin Contracts (last updated v5.1.0) (utils/types/Time.sol)</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>pragma solidity ^0.8.20;</span>
   5 |     | <span class='neutral'></span>
   6 |     | <span class='neutral'>import {Math} from &quot;../math/Math.sol&quot;;</span>
   7 |     | <span class='neutral'>import {SafeCast} from &quot;../math/SafeCast.sol&quot;;</span>
   8 |     | <span class='neutral'></span>
   9 |     | <span class='neutral'>/**</span>
  10 |     | <span class='neutral'> * @dev This library provides helpers for manipulating time-related objects.</span>
  11 |     | <span class='neutral'> *</span>
  12 |     | <span class='neutral'> * It uses the following types:</span>
  13 |     | <span class='neutral'> * - `uint48` for timepoints</span>
  14 |     | <span class='neutral'> * - `uint32` for durations</span>
  15 |     | <span class='neutral'> *</span>
  16 |     | <span class='neutral'> * While the library doesn&#39;t provide specific types for timepoints and duration, it does provide:</span>
  17 |     | <span class='neutral'> * - a `Delay` type to represent duration that can be programmed to change value automatically at a given point</span>
  18 |     | <span class='neutral'> * - additional helper functions</span>
  19 |     | <span class='neutral'> */</span>
  20 |     | <span class='neutral'>library Time {</span>
  21 |     | <span class='neutral'>    using Time for *;</span>
  22 |     | <span class='neutral'></span>
  23 |     | <span class='neutral'>    /**</span>
  24 |     | <span class='neutral'>     * @dev Get the block timestamp as a Timepoint.</span>
  25 |     | <span class='neutral'>     */</span>
  26 |     | <span class='neutral'>    function timestamp() internal view returns (uint48) {</span>
  27 |     | <span class='neutral'>        return SafeCast.toUint48(block.timestamp);</span>
  28 |     | <span class='neutral'>    }</span>
  29 |     | <span class='neutral'></span>
  30 |     | <span class='neutral'>    /**</span>
  31 |     | <span class='neutral'>     * @dev Get the block number as a Timepoint.</span>
  32 |     | <span class='neutral'>     */</span>
  33 |     | <span class='neutral'>    function blockNumber() internal view returns (uint48) {</span>
  34 |     | <span class='neutral'>        return SafeCast.toUint48(block.number);</span>
  35 |     | <span class='neutral'>    }</span>
  36 |     | <span class='neutral'></span>
  37 |     | <span class='neutral'>    // ==================================================== Delay =====================================================</span>
  38 |     | <span class='neutral'>    /**</span>
  39 |     | <span class='neutral'>     * @dev A `Delay` is a uint32 duration that can be programmed to change value automatically at a given point in the</span>
  40 |     | <span class='neutral'>     * future. The &quot;effect&quot; timepoint describes when the transitions happens from the &quot;old&quot; value to the &quot;new&quot; value.</span>
  41 |     | <span class='neutral'>     * This allows updating the delay applied to some operation while keeping some guarantees.</span>
  42 |     | <span class='neutral'>     *</span>
  43 | *   | <span class='executed'>     * In particular, the {update} function guarantees that if the delay is reduced, the old delay still applies for</span>
  44 | *   | <span class='executed'>     * some time. For example if the delay is currently 7 days to do an upgrade, the admin should not be able to set</span>
  45 | *   | <span class='executed'>     * the delay to 0 and upgrade immediately. If the admin wants to reduce the delay, the old delay (7 days) should</span>
  46 |     | <span class='neutral'>     * still apply for some time.</span>
  47 |     | <span class='neutral'>     *</span>
  48 |     | <span class='neutral'>     *</span>
  49 |     | <span class='unexecuted'>     * The `Delay` type is 112 bits long, and packs the following:</span>
  50 |     | <span class='neutral'>     *</span>
  51 |     | <span class='neutral'>     * ```</span>
  52 |     | <span class='unexecuted'>     *   | [uint48]: effect date (timepoint)</span>
  53 |     | <span class='unexecuted'>     *   |           | [uint32]: value before (duration)</span>
  54 |     | <span class='neutral'>     *                      [uint32]: value after (duration)</span>
  55 |     | <span class='neutral'>     * 0xAAAAAAAAAAAABBBBBBBBCCCCCCCC</span>
  56 |     | <span class='neutral'>     * ```</span>
  57 |     | <span class='neutral'>     *</span>
  58 |     | <span class='neutral'>     * NOTE: The {get} and {withUpdate} functions operate using timestamps. Block number based delays are not currently</span>
  59 |     | <span class='neutral'>     * supported.</span>
  60 |     | <span class='neutral'>     */</span>
  61 |     | <span class='neutral'>    type Delay is uint112;</span>
  62 |     | <span class='neutral'></span>
  63 |     | <span class='neutral'>    /**</span>
  64 |     | <span class='neutral'>     * @dev Wrap a duration into a Delay to add the one-step &quot;update in the future&quot; feature</span>
  65 |     | <span class='neutral'>     */</span>
  66 |     | <span class='neutral'>    function toDelay(uint32 duration) internal pure returns (Delay) {</span>
  67 |     | <span class='neutral'>        return Delay.wrap(duration);</span>
  68 |     | <span class='neutral'>    }</span>
  69 |     | <span class='neutral'></span>
  70 |     | <span class='neutral'>    /**</span>
  71 |     | <span class='unexecuted'>     * @dev Get the value at a given timepoint plus the pending value and effect timepoint if there is a scheduled</span>
  72 | *   | <span class='executed'>     * change after this timepoint. If the effect timepoint is 0, then the pending value should not be considered.</span>
  73 |     | <span class='neutral'>     */</span>
  74 |     | <span class='unexecuted'>    function _getFullAt(</span>
  75 |     | <span class='neutral'>        Delay self,</span>
  76 | *   | <span class='executed'>        uint48 timepoint</span>
  77 | *   | <span class='executed'>    ) private pure returns (uint32 valueBefore, uint32 valueAfter, uint48 effect) {</span>
  78 | *   | <span class='executed'>        (valueBefore, valueAfter, effect) = self.unpack();</span>
  79 |     | <span class='neutral'>        return effect &lt;= timepoint ? (valueAfter, 0, 0) : (valueBefore, valueAfter, effect);</span>
  80 |     | <span class='neutral'>    }</span>
  81 |     | <span class='neutral'></span>
  82 |     | <span class='neutral'>    /**</span>
  83 |     | <span class='unexecuted'>     * @dev Get the current value plus the pending value and effect timepoint if there is a scheduled change. If the</span>
  84 |     | <span class='unexecuted'>     * effect timepoint is 0, then the pending value should not be considered.</span>
  85 |     | <span class='unexecuted'>     */</span>
  86 |     | <span class='unexecuted'>    function getFull(Delay self) internal view returns (uint32 valueBefore, uint32 valueAfter, uint48 effect) {</span>
  87 |     | <span class='unexecuted'>        return _getFullAt(self, timestamp());</span>
  88 |     | <span class='neutral'>    }</span>
  89 |     | <span class='neutral'></span>
  90 | *   | <span class='executed'>    /**</span>
  91 |     | <span class='neutral'>     * @dev Get the current value.</span>
  92 |     | <span class='neutral'>     */</span>
  93 |     | <span class='neutral'>    function get(Delay self) internal view returns (uint32) {</span>
  94 |     | <span class='neutral'>        (uint32 delay, , ) = self.getFull();</span>
  95 |     | <span class='neutral'>        return delay;</span>
  96 |     | <span class='neutral'>    }</span>
  97 |     | <span class='neutral'></span>
  98 |     | <span class='neutral'>    /**</span>
  99 |     | <span class='neutral'>     * @dev Update a Delay object so that it takes a new duration after a timepoint that is automatically computed to</span>
 100 | *   | <span class='executed'>     * enforce the old delay at the moment of the update. Returns the updated Delay object and the timestamp when the</span>
 101 |     | <span class='neutral'>     * new delay becomes effective.</span>
 102 |     | <span class='neutral'>     */</span>
 103 | *   | <span class='executed'>    function withUpdate(</span>
 104 | *   | <span class='executed'>        Delay self,</span>
 105 | *   | <span class='executed'>        uint32 newValue,</span>
 106 |     | <span class='neutral'>        uint32 minSetback</span>
 107 |     | <span class='neutral'>    ) internal view returns (Delay updatedDelay, uint48 effect) {</span>
 108 |     | <span class='neutral'>        uint32 value = self.get();</span>
 109 |     | <span class='neutral'>        uint32 setback = uint32(Math.max(minSetback, value &gt; newValue ? value - newValue : 0));</span>
 110 |     | <span class='neutral'>        effect = timestamp() + setback;</span>
 111 |     | <span class='neutral'>        return (pack(value, newValue, effect), effect);</span>
 112 |     | <span class='neutral'>    }</span>
 113 |     | <span class='neutral'></span>
 114 |     | <span class='neutral'>    /**</span>
 115 |     | <span class='neutral'>     * @dev Split a delay into its components: valueBefore, valueAfter and effect (transition timepoint).</span>
 116 |     | <span class='neutral'>     */</span>
 117 |     | <span class='neutral'>    function unpack(Delay self) internal pure returns (uint32 valueBefore, uint32 valueAfter, uint48 effect) {</span>
 118 | *   | <span class='executed'>        uint112 raw = Delay.unwrap(self);</span>
 119 |     | <span class='neutral'></span>
 120 |     | <span class='neutral'>        valueAfter = uint32(raw);</span>
 121 | *   | <span class='executed'>        valueBefore = uint32(raw &gt;&gt; 32);</span>
 122 |     | <span class='neutral'>        effect = uint48(raw &gt;&gt; 64);</span>
 123 |     | <span class='neutral'></span>
 124 | *   | <span class='executed'>        return (valueBefore, valueAfter, effect);</span>
 125 |     | <span class='neutral'>    }</span>
 126 |     | <span class='neutral'></span>
 127 | *   | <span class='executed'>    /**</span>
 128 | *   | <span class='executed'>     * @dev pack the components into a Delay object.</span>
 129 |     | <span class='neutral'>     */</span>
 130 |     | <span class='neutral'>    function pack(uint32 valueBefore, uint32 valueAfter, uint48 effect) internal pure returns (Delay) {</span>
 131 |     | <span class='neutral'>        return Delay.wrap((uint112(effect) &lt;&lt; 64) | (uint112(valueBefore) &lt;&lt; 32) | uint112(valueAfter));</span>
 132 |     | <span class='neutral'>    }</span>
 133 |     | <span class='neutral'>}</span>
 134 | *   | <span class='executed'></span>

</code>
<br />

<b>/home/phantom/Documents/azemora/azemora-contracts/lib/openzeppelin-contracts-upgradeable/contracts/access/AccessControlUpgradeable.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'>// OpenZeppelin Contracts (last updated v5.3.0) (access/AccessControl.sol)</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>pragma solidity ^0.8.20;</span>
   5 |     | <span class='neutral'></span>
   6 |     | <span class='neutral'>import {IAccessControl} from &quot;@openzeppelin/contracts/access/IAccessControl.sol&quot;;</span>
   7 |     | <span class='neutral'>import {ContextUpgradeable} from &quot;../utils/ContextUpgradeable.sol&quot;;</span>
   8 |     | <span class='neutral'>import {IERC165} from &quot;@openzeppelin/contracts/utils/introspection/IERC165.sol&quot;;</span>
   9 |     | <span class='neutral'>import {ERC165Upgradeable} from &quot;../utils/introspection/ERC165Upgradeable.sol&quot;;</span>
  10 |     | <span class='neutral'>import {Initializable} from &quot;../proxy/utils/Initializable.sol&quot;;</span>
  11 |     | <span class='neutral'></span>
  12 |     | <span class='neutral'>/**</span>
  13 |     | <span class='neutral'> * @dev Contract module that allows children to implement role-based access</span>
  14 |     | <span class='neutral'> * control mechanisms. This is a lightweight version that doesn&#39;t allow enumerating role</span>
  15 |     | <span class='neutral'> * members except through off-chain means by accessing the contract event logs. Some</span>
  16 |     | <span class='neutral'> * applications may benefit from on-chain enumerability, for those cases see</span>
  17 |     | <span class='neutral'> * {AccessControlEnumerable}.</span>
  18 |     | <span class='neutral'> *</span>
  19 |     | <span class='neutral'> * Roles are referred to by their `bytes32` identifier. These should be exposed</span>
  20 |     | <span class='neutral'> * in the external API and be unique. The best way to achieve this is by</span>
  21 |     | <span class='neutral'> * using `public constant` hash digests:</span>
  22 |     | <span class='neutral'> *</span>
  23 |     | <span class='neutral'> * ```solidity</span>
  24 |     | <span class='neutral'> * bytes32 public constant MY_ROLE = keccak256(&quot;MY_ROLE&quot;);</span>
  25 |     | <span class='neutral'> * ```</span>
  26 |     | <span class='neutral'> *</span>
  27 |     | <span class='neutral'> * Roles can be used to represent a set of permissions. To restrict access to a</span>
  28 |     | <span class='neutral'> * function call, use {hasRole}:</span>
  29 |     | <span class='neutral'> *</span>
  30 |     | <span class='neutral'> * ```solidity</span>
  31 |     | <span class='neutral'> * function foo() public {</span>
  32 |     | <span class='neutral'> *     require(hasRole(MY_ROLE, msg.sender));</span>
  33 |     | <span class='neutral'> *     ...</span>
  34 |     | <span class='neutral'> * }</span>
  35 |     | <span class='neutral'> * ```</span>
  36 |     | <span class='neutral'> *</span>
  37 |     | <span class='neutral'> * Roles can be granted and revoked dynamically via the {grantRole} and</span>
  38 |     | <span class='neutral'> * {revokeRole} functions. Each role has an associated admin role, and only</span>
  39 |     | <span class='neutral'> * accounts that have a role&#39;s admin role can call {grantRole} and {revokeRole}.</span>
  40 |     | <span class='neutral'> *</span>
  41 |     | <span class='neutral'> * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means</span>
  42 |     | <span class='neutral'> * that only accounts with this role will be able to grant or revoke other</span>
  43 |     | <span class='neutral'> * roles. More complex role relationships can be created by using</span>
  44 |     | <span class='neutral'> * {_setRoleAdmin}.</span>
  45 |     | <span class='neutral'> *</span>
  46 |     | <span class='neutral'> * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to</span>
  47 |     | <span class='neutral'> * grant and revoke this role. Extra precautions should be taken to secure</span>
  48 |     | <span class='neutral'> * accounts that have been granted it. We recommend using {AccessControlDefaultAdminRules}</span>
  49 |     | <span class='neutral'> * to enforce additional security measures for this role.</span>
  50 |     | <span class='neutral'> */</span>
  51 |     | <span class='neutral'>abstract contract AccessControlUpgradeable is Initializable, ContextUpgradeable, IAccessControl, ERC165Upgradeable {</span>
  52 |     | <span class='neutral'>    struct RoleData {</span>
  53 |     | <span class='neutral'>        mapping(address account =&gt; bool) hasRole;</span>
  54 |     | <span class='neutral'>        bytes32 adminRole;</span>
  55 |     | <span class='neutral'>    }</span>
  56 |     | <span class='neutral'></span>
  57 |     | <span class='neutral'>    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;</span>
  58 |     | <span class='neutral'></span>
  59 |     | <span class='neutral'></span>
  60 |     | <span class='neutral'>    /// @custom:storage-location erc7201:openzeppelin.storage.AccessControl</span>
  61 |     | <span class='neutral'>    struct AccessControlStorage {</span>
  62 |     | <span class='neutral'>        mapping(bytes32 role =&gt; RoleData) _roles;</span>
  63 |     | <span class='neutral'>    }</span>
  64 |     | <span class='neutral'></span>
  65 |     | <span class='neutral'>    // keccak256(abi.encode(uint256(keccak256(&quot;openzeppelin.storage.AccessControl&quot;)) - 1)) &amp; ~bytes32(uint256(0xff))</span>
  66 |     | <span class='neutral'>    bytes32 private constant AccessControlStorageLocation = 0x02dd7bc7dec4dceedda775e58dd541e08a116c6c53815c0bd028192f7b626800;</span>
  67 |     | <span class='neutral'></span>
  68 |     | <span class='neutral'>    function _getAccessControlStorage() private pure returns (AccessControlStorage storage $) {</span>
  69 |     | <span class='neutral'>        assembly {</span>
  70 |     | <span class='neutral'>            $.slot := AccessControlStorageLocation</span>
  71 |     | <span class='neutral'>        }</span>
  72 |     | <span class='neutral'>    }</span>
  73 |     | <span class='neutral'></span>
  74 |     | <span class='neutral'>    /**</span>
  75 |     | <span class='neutral'>     * @dev Modifier that checks that an account has a specific role. Reverts</span>
  76 |     | <span class='neutral'>     * with an {AccessControlUnauthorizedAccount} error including the required role.</span>
  77 |     | <span class='neutral'>     */</span>
  78 |     | <span class='neutral'>    modifier onlyRole(bytes32 role) {</span>
  79 |     | <span class='neutral'>        _checkRole(role);</span>
  80 |     | <span class='neutral'>        _;</span>
  81 |     | <span class='neutral'>    }</span>
  82 |     | <span class='neutral'></span>
  83 |     | <span class='neutral'>    function __AccessControl_init() internal onlyInitializing {</span>
  84 |     | <span class='neutral'>    }</span>
  85 |     | <span class='neutral'></span>
  86 |     | <span class='neutral'>    function __AccessControl_init_unchained() internal onlyInitializing {</span>
  87 |     | <span class='neutral'>    }</span>
  88 |     | <span class='neutral'>    /// @inheritdoc IERC165</span>
  89 |     | <span class='neutral'>    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {</span>
  90 |     | <span class='neutral'>        return interfaceId == type(IAccessControl).interfaceId || super.supportsInterface(interfaceId);</span>
  91 |     | <span class='neutral'>    }</span>
  92 |     | <span class='neutral'></span>
  93 |     | <span class='neutral'>    /**</span>
  94 |     | <span class='neutral'>     * @dev Returns `true` if `account` has been granted `role`.</span>
  95 |     | <span class='neutral'>     */</span>
  96 |     | <span class='neutral'>    function hasRole(bytes32 role, address account) public view virtual returns (bool) {</span>
  97 |     | <span class='neutral'>        AccessControlStorage storage $ = _getAccessControlStorage();</span>
  98 |     | <span class='neutral'>        return $._roles[role].hasRole[account];</span>
  99 |     | <span class='neutral'>    }</span>
 100 |     | <span class='neutral'></span>
 101 |     | <span class='neutral'>    /**</span>
 102 |     | <span class='neutral'>     * @dev Reverts with an {AccessControlUnauthorizedAccount} error if `_msgSender()`</span>
 103 |     | <span class='neutral'>     * is missing `role`. Overriding this function changes the behavior of the {onlyRole} modifier.</span>
 104 |     | <span class='neutral'>     */</span>
 105 |     | <span class='neutral'>    function _checkRole(bytes32 role) internal view virtual {</span>
 106 |     | <span class='neutral'>        _checkRole(role, _msgSender());</span>
 107 |     | <span class='neutral'>    }</span>
 108 |     | <span class='neutral'></span>
 109 |     | <span class='neutral'>    /**</span>
 110 |     | <span class='neutral'>     * @dev Reverts with an {AccessControlUnauthorizedAccount} error if `account`</span>
 111 |     | <span class='neutral'>     * is missing `role`.</span>
 112 |     | <span class='neutral'>     */</span>
 113 |     | <span class='neutral'>    function _checkRole(bytes32 role, address account) internal view virtual {</span>
 114 |     | <span class='neutral'>        if (!hasRole(role, account)) {</span>
 115 |     | <span class='neutral'>            revert AccessControlUnauthorizedAccount(account, role);</span>
 116 |     | <span class='neutral'>        }</span>
 117 |     | <span class='neutral'>    }</span>
 118 |     | <span class='neutral'></span>
 119 |     | <span class='neutral'>    /**</span>
 120 |     | <span class='neutral'>     * @dev Returns the admin role that controls `role`. See {grantRole} and</span>
 121 |     | <span class='neutral'>     * {revokeRole}.</span>
 122 |     | <span class='neutral'>     *</span>
 123 |     | <span class='neutral'>     * To change a role&#39;s admin, use {_setRoleAdmin}.</span>
 124 |     | <span class='neutral'>     */</span>
 125 |     | <span class='neutral'>    function getRoleAdmin(bytes32 role) public view virtual returns (bytes32) {</span>
 126 |     | <span class='neutral'>        AccessControlStorage storage $ = _getAccessControlStorage();</span>
 127 |     | <span class='neutral'>        return $._roles[role].adminRole;</span>
 128 |     | <span class='neutral'>    }</span>
 129 |     | <span class='neutral'></span>
 130 |     | <span class='neutral'>    /**</span>
 131 |     | <span class='neutral'>     * @dev Grants `role` to `account`.</span>
 132 |     | <span class='neutral'>     *</span>
 133 |     | <span class='neutral'>     * If `account` had not been already granted `role`, emits a {RoleGranted}</span>
 134 |     | <span class='neutral'>     * event.</span>
 135 |     | <span class='neutral'>     *</span>
 136 |     | <span class='neutral'>     * Requirements:</span>
 137 |     | <span class='neutral'>     *</span>
 138 |     | <span class='neutral'>     * - the caller must have ``role``&#39;s admin role.</span>
 139 |     | <span class='neutral'>     *</span>
 140 |     | <span class='neutral'>     * May emit a {RoleGranted} event.</span>
 141 |     | <span class='neutral'>     */</span>
 142 |     | <span class='neutral'>    function grantRole(bytes32 role, address account) public virtual onlyRole(getRoleAdmin(role)) {</span>
 143 |     | <span class='neutral'>        _grantRole(role, account);</span>
 144 |     | <span class='neutral'>    }</span>
 145 |     | <span class='neutral'></span>
 146 |     | <span class='neutral'>    /**</span>
 147 |     | <span class='neutral'>     * @dev Revokes `role` from `account`.</span>
 148 |     | <span class='neutral'>     *</span>
 149 |     | <span class='neutral'>     * If `account` had been granted `role`, emits a {RoleRevoked} event.</span>
 150 |     | <span class='neutral'>     *</span>
 151 |     | <span class='neutral'>     * Requirements:</span>
 152 |     | <span class='neutral'>     *</span>
 153 |     | <span class='neutral'>     * - the caller must have ``role``&#39;s admin role.</span>
 154 |     | <span class='neutral'>     *</span>
 155 |     | <span class='neutral'>     * May emit a {RoleRevoked} event.</span>
 156 |     | <span class='neutral'>     */</span>
 157 |     | <span class='neutral'>    function revokeRole(bytes32 role, address account) public virtual onlyRole(getRoleAdmin(role)) {</span>
 158 |     | <span class='neutral'>        _revokeRole(role, account);</span>
 159 |     | <span class='neutral'>    }</span>
 160 |     | <span class='neutral'></span>
 161 |     | <span class='neutral'>    /**</span>
 162 |     | <span class='neutral'>     * @dev Revokes `role` from the calling account.</span>
 163 |     | <span class='neutral'>     *</span>
 164 |     | <span class='neutral'>     * Roles are often managed via {grantRole} and {revokeRole}: this function&#39;s</span>
 165 |     | <span class='neutral'>     * purpose is to provide a mechanism for accounts to lose their privileges</span>
 166 |     | <span class='neutral'>     * if they are compromised (such as when a trusted device is misplaced).</span>
 167 |     | <span class='neutral'>     *</span>
 168 |     | <span class='neutral'>     * If the calling account had been revoked `role`, emits a {RoleRevoked}</span>
 169 |     | <span class='neutral'>     * event.</span>
 170 |     | <span class='neutral'>     *</span>
 171 |     | <span class='neutral'>     * Requirements:</span>
 172 |     | <span class='neutral'>     *</span>
 173 |     | <span class='neutral'>     * - the caller must be `callerConfirmation`.</span>
 174 |     | <span class='neutral'>     *</span>
 175 |     | <span class='neutral'>     * May emit a {RoleRevoked} event.</span>
 176 |     | <span class='neutral'>     */</span>
 177 |     | <span class='neutral'>    function renounceRole(bytes32 role, address callerConfirmation) public virtual {</span>
 178 |     | <span class='neutral'>        if (callerConfirmation != _msgSender()) {</span>
 179 |     | <span class='neutral'>            revert AccessControlBadConfirmation();</span>
 180 |     | <span class='neutral'>        }</span>
 181 |     | <span class='neutral'></span>
 182 |     | <span class='neutral'>        _revokeRole(role, callerConfirmation);</span>
 183 |     | <span class='neutral'>    }</span>
 184 |     | <span class='neutral'></span>
 185 |     | <span class='neutral'>    /**</span>
 186 |     | <span class='neutral'>     * @dev Sets `adminRole` as ``role``&#39;s admin role.</span>
 187 |     | <span class='neutral'>     *</span>
 188 |     | <span class='neutral'>     * Emits a {RoleAdminChanged} event.</span>
 189 |     | <span class='neutral'>     */</span>
 190 |     | <span class='neutral'>    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {</span>
 191 |     | <span class='neutral'>        AccessControlStorage storage $ = _getAccessControlStorage();</span>
 192 |     | <span class='neutral'>        bytes32 previousAdminRole = getRoleAdmin(role);</span>
 193 |     | <span class='neutral'>        $._roles[role].adminRole = adminRole;</span>
 194 |     | <span class='neutral'>        emit RoleAdminChanged(role, previousAdminRole, adminRole);</span>
 195 |     | <span class='neutral'>    }</span>
 196 |     | <span class='neutral'></span>
 197 |     | <span class='neutral'>    /**</span>
 198 |     | <span class='neutral'>     * @dev Attempts to grant `role` to `account` and returns a boolean indicating if `role` was granted.</span>
 199 |     | <span class='neutral'>     *</span>
 200 |     | <span class='neutral'>     * Internal function without access restriction.</span>
 201 |     | <span class='neutral'>     *</span>
 202 |     | <span class='neutral'>     * May emit a {RoleGranted} event.</span>
 203 |     | <span class='neutral'>     */</span>
 204 |     | <span class='neutral'>    function _grantRole(bytes32 role, address account) internal virtual returns (bool) {</span>
 205 |     | <span class='neutral'>        AccessControlStorage storage $ = _getAccessControlStorage();</span>
 206 |     | <span class='neutral'>        if (!hasRole(role, account)) {</span>
 207 |     | <span class='neutral'>            $._roles[role].hasRole[account] = true;</span>
 208 |     | <span class='neutral'>            emit RoleGranted(role, account, _msgSender());</span>
 209 |     | <span class='neutral'>            return true;</span>
 210 |     | <span class='neutral'>        } else {</span>
 211 |     | <span class='neutral'>            return false;</span>
 212 |     | <span class='neutral'>        }</span>
 213 |     | <span class='neutral'>    }</span>
 214 |     | <span class='neutral'></span>
 215 |     | <span class='neutral'>    /**</span>
 216 |     | <span class='neutral'>     * @dev Attempts to revoke `role` from `account` and returns a boolean indicating if `role` was revoked.</span>
 217 |     | <span class='neutral'>     *</span>
 218 |     | <span class='neutral'>     * Internal function without access restriction.</span>
 219 |     | <span class='neutral'>     *</span>
 220 |     | <span class='neutral'>     * May emit a {RoleRevoked} event.</span>
 221 |     | <span class='neutral'>     */</span>
 222 |     | <span class='neutral'>    function _revokeRole(bytes32 role, address account) internal virtual returns (bool) {</span>
 223 |     | <span class='neutral'>        AccessControlStorage storage $ = _getAccessControlStorage();</span>
 224 |     | <span class='neutral'>        if (hasRole(role, account)) {</span>
 225 |     | <span class='neutral'>            $._roles[role].hasRole[account] = false;</span>
 226 |     | <span class='neutral'>            emit RoleRevoked(role, account, _msgSender());</span>
 227 |     | <span class='neutral'>            return true;</span>
 228 |     | <span class='neutral'>        } else {</span>
 229 |     | <span class='neutral'>            return false;</span>
 230 |     | <span class='neutral'>        }</span>
 231 |     | <span class='neutral'>    }</span>
 232 |     | <span class='neutral'>}</span>
 233 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/phantom/Documents/azemora/azemora-contracts/lib/openzeppelin-contracts-upgradeable/contracts/access/OwnableUpgradeable.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'>// OpenZeppelin Contracts (last updated v5.0.0) (access/Ownable.sol)</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>pragma solidity ^0.8.20;</span>
   5 |     | <span class='neutral'></span>
   6 |     | <span class='neutral'>import {ContextUpgradeable} from &quot;../utils/ContextUpgradeable.sol&quot;;</span>
   7 |     | <span class='neutral'>import {Initializable} from &quot;../proxy/utils/Initializable.sol&quot;;</span>
   8 |     | <span class='neutral'></span>
   9 |     | <span class='neutral'>/**</span>
  10 |     | <span class='neutral'> * @dev Contract module which provides a basic access control mechanism, where</span>
  11 |     | <span class='neutral'> * there is an account (an owner) that can be granted exclusive access to</span>
  12 |     | <span class='neutral'> * specific functions.</span>
  13 |     | <span class='neutral'> *</span>
  14 |     | <span class='neutral'> * The initial owner is set to the address provided by the deployer. This can</span>
  15 |     | <span class='neutral'> * later be changed with {transferOwnership}.</span>
  16 |     | <span class='neutral'> *</span>
  17 |     | <span class='neutral'> * This module is used through inheritance. It will make available the modifier</span>
  18 |     | <span class='neutral'> * `onlyOwner`, which can be applied to your functions to restrict their use to</span>
  19 |     | <span class='neutral'> * the owner.</span>
  20 |     | <span class='neutral'> */</span>
  21 |     | <span class='neutral'>abstract contract OwnableUpgradeable is Initializable, ContextUpgradeable {</span>
  22 |     | <span class='neutral'>    /// @custom:storage-location erc7201:openzeppelin.storage.Ownable</span>
  23 |     | <span class='neutral'>    struct OwnableStorage {</span>
  24 |     | <span class='neutral'>        address _owner;</span>
  25 |     | <span class='neutral'>    }</span>
  26 |     | <span class='neutral'></span>
  27 |     | <span class='neutral'>    // keccak256(abi.encode(uint256(keccak256(&quot;openzeppelin.storage.Ownable&quot;)) - 1)) &amp; ~bytes32(uint256(0xff))</span>
  28 |     | <span class='neutral'>    bytes32 private constant OwnableStorageLocation = 0x9016d09d72d40fdae2fd8ceac6b6234c7706214fd39c1cd1e609a0528c199300;</span>
  29 |     | <span class='neutral'></span>
  30 |     | <span class='neutral'>    function _getOwnableStorage() private pure returns (OwnableStorage storage $) {</span>
  31 |     | <span class='neutral'>        assembly {</span>
  32 |     | <span class='neutral'>            $.slot := OwnableStorageLocation</span>
  33 |     | <span class='neutral'>        }</span>
  34 |     | <span class='neutral'>    }</span>
  35 |     | <span class='neutral'></span>
  36 |     | <span class='neutral'>    /**</span>
  37 |     | <span class='neutral'>     * @dev The caller account is not authorized to perform an operation.</span>
  38 |     | <span class='neutral'>     */</span>
  39 |     | <span class='neutral'>    error OwnableUnauthorizedAccount(address account);</span>
  40 |     | <span class='neutral'></span>
  41 |     | <span class='neutral'>    /**</span>
  42 |     | <span class='neutral'>     * @dev The owner is not a valid owner account. (eg. `address(0)`)</span>
  43 |     | <span class='neutral'>     */</span>
  44 |     | <span class='neutral'>    error OwnableInvalidOwner(address owner);</span>
  45 |     | <span class='neutral'></span>
  46 |     | <span class='neutral'>    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);</span>
  47 |     | <span class='neutral'></span>
  48 |     | <span class='neutral'>    /**</span>
  49 |     | <span class='neutral'>     * @dev Initializes the contract setting the address provided by the deployer as the initial owner.</span>
  50 |     | <span class='neutral'>     */</span>
  51 |     | <span class='neutral'>    function __Ownable_init(address initialOwner) internal onlyInitializing {</span>
  52 |     | <span class='neutral'>        __Ownable_init_unchained(initialOwner);</span>
  53 |     | <span class='neutral'>    }</span>
  54 |     | <span class='neutral'></span>
  55 |     | <span class='neutral'>    function __Ownable_init_unchained(address initialOwner) internal onlyInitializing {</span>
  56 |     | <span class='neutral'>        if (initialOwner == address(0)) {</span>
  57 |     | <span class='neutral'>            revert OwnableInvalidOwner(address(0));</span>
  58 |     | <span class='neutral'>        }</span>
  59 |     | <span class='neutral'>        _transferOwnership(initialOwner);</span>
  60 |     | <span class='neutral'>    }</span>
  61 |     | <span class='neutral'></span>
  62 |     | <span class='neutral'>    /**</span>
  63 |     | <span class='neutral'>     * @dev Throws if called by any account other than the owner.</span>
  64 |     | <span class='neutral'>     */</span>
  65 |     | <span class='neutral'>    modifier onlyOwner() {</span>
  66 |     | <span class='neutral'>        _checkOwner();</span>
  67 |     | <span class='neutral'>        _;</span>
  68 |     | <span class='neutral'>    }</span>
  69 |     | <span class='neutral'></span>
  70 |     | <span class='neutral'>    /**</span>
  71 |     | <span class='neutral'>     * @dev Returns the address of the current owner.</span>
  72 |     | <span class='neutral'>     */</span>
  73 |     | <span class='neutral'>    function owner() public view virtual returns (address) {</span>
  74 |     | <span class='neutral'>        OwnableStorage storage $ = _getOwnableStorage();</span>
  75 |     | <span class='neutral'>        return $._owner;</span>
  76 |     | <span class='neutral'>    }</span>
  77 |     | <span class='neutral'></span>
  78 |     | <span class='neutral'>    /**</span>
  79 |     | <span class='neutral'>     * @dev Throws if the sender is not the owner.</span>
  80 |     | <span class='neutral'>     */</span>
  81 |     | <span class='neutral'>    function _checkOwner() internal view virtual {</span>
  82 |     | <span class='neutral'>        if (owner() != _msgSender()) {</span>
  83 |     | <span class='neutral'>            revert OwnableUnauthorizedAccount(_msgSender());</span>
  84 |     | <span class='neutral'>        }</span>
  85 |     | <span class='neutral'>    }</span>
  86 |     | <span class='neutral'></span>
  87 |     | <span class='neutral'>    /**</span>
  88 |     | <span class='neutral'>     * @dev Leaves the contract without owner. It will not be possible to call</span>
  89 |     | <span class='neutral'>     * `onlyOwner` functions. Can only be called by the current owner.</span>
  90 |     | <span class='neutral'>     *</span>
  91 |     | <span class='neutral'>     * NOTE: Renouncing ownership will leave the contract without an owner,</span>
  92 |     | <span class='neutral'>     * thereby disabling any functionality that is only available to the owner.</span>
  93 |     | <span class='neutral'>     */</span>
  94 |     | <span class='neutral'>    function renounceOwnership() public virtual onlyOwner {</span>
  95 |     | <span class='neutral'>        _transferOwnership(address(0));</span>
  96 |     | <span class='neutral'>    }</span>
  97 |     | <span class='neutral'></span>
  98 |     | <span class='neutral'>    /**</span>
  99 |     | <span class='neutral'>     * @dev Transfers ownership of the contract to a new account (`newOwner`).</span>
 100 |     | <span class='neutral'>     * Can only be called by the current owner.</span>
 101 |     | <span class='neutral'>     */</span>
 102 |     | <span class='neutral'>    function transferOwnership(address newOwner) public virtual onlyOwner {</span>
 103 |     | <span class='neutral'>        if (newOwner == address(0)) {</span>
 104 |     | <span class='neutral'>            revert OwnableInvalidOwner(address(0));</span>
 105 |     | <span class='neutral'>        }</span>
 106 |     | <span class='neutral'>        _transferOwnership(newOwner);</span>
 107 |     | <span class='neutral'>    }</span>
 108 |     | <span class='neutral'></span>
 109 |     | <span class='neutral'>    /**</span>
 110 |     | <span class='neutral'>     * @dev Transfers ownership of the contract to a new account (`newOwner`).</span>
 111 |     | <span class='neutral'>     * Internal function without access restriction.</span>
 112 |     | <span class='neutral'>     */</span>
 113 |     | <span class='neutral'>    function _transferOwnership(address newOwner) internal virtual {</span>
 114 |     | <span class='neutral'>        OwnableStorage storage $ = _getOwnableStorage();</span>
 115 |     | <span class='neutral'>        address oldOwner = $._owner;</span>
 116 |     | <span class='neutral'>        $._owner = newOwner;</span>
 117 |     | <span class='neutral'>        emit OwnershipTransferred(oldOwner, newOwner);</span>
 118 |     | <span class='neutral'>    }</span>
 119 |     | <span class='neutral'>}</span>
 120 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/phantom/Documents/azemora/azemora-contracts/lib/openzeppelin-contracts-upgradeable/contracts/governance/GovernorUpgradeable.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'>// OpenZeppelin Contracts (last updated v5.3.0) (governance/Governor.sol)</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>pragma solidity ^0.8.24;</span>
   5 |     | <span class='neutral'></span>
   6 |     | <span class='neutral'>import {IERC721Receiver} from &quot;@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol&quot;;</span>
   7 |     | <span class='neutral'>import {IERC1155Receiver} from &quot;@openzeppelin/contracts/token/ERC1155/IERC1155Receiver.sol&quot;;</span>
   8 |     | <span class='neutral'>import {EIP712Upgradeable} from &quot;../utils/cryptography/EIP712Upgradeable.sol&quot;;</span>
   9 |     | <span class='neutral'>import {SignatureChecker} from &quot;@openzeppelin/contracts/utils/cryptography/SignatureChecker.sol&quot;;</span>
  10 |     | <span class='neutral'>import {IERC165} from &quot;@openzeppelin/contracts/utils/introspection/IERC165.sol&quot;;</span>
  11 |     | <span class='neutral'>import {ERC165Upgradeable} from &quot;../utils/introspection/ERC165Upgradeable.sol&quot;;</span>
  12 |     | <span class='neutral'>import {SafeCast} from &quot;@openzeppelin/contracts/utils/math/SafeCast.sol&quot;;</span>
  13 |     | <span class='neutral'>import {DoubleEndedQueue} from &quot;@openzeppelin/contracts/utils/structs/DoubleEndedQueue.sol&quot;;</span>
  14 |     | <span class='neutral'>import {Address} from &quot;@openzeppelin/contracts/utils/Address.sol&quot;;</span>
  15 |     | <span class='neutral'>import {ContextUpgradeable} from &quot;../utils/ContextUpgradeable.sol&quot;;</span>
  16 |     | <span class='neutral'>import {NoncesUpgradeable} from &quot;../utils/NoncesUpgradeable.sol&quot;;</span>
  17 |     | <span class='neutral'>import {Strings} from &quot;@openzeppelin/contracts/utils/Strings.sol&quot;;</span>
  18 |     | <span class='neutral'>import {IGovernor} from &quot;@openzeppelin/contracts/governance/IGovernor.sol&quot;;</span>
  19 |     | <span class='neutral'>import {IERC6372} from &quot;@openzeppelin/contracts/interfaces/IERC6372.sol&quot;;</span>
  20 |     | <span class='neutral'>import {Initializable} from &quot;../proxy/utils/Initializable.sol&quot;;</span>
  21 |     | <span class='neutral'></span>
  22 |     | <span class='neutral'>/**</span>
  23 |     | <span class='neutral'> * @dev Core of the governance system, designed to be extended through various modules.</span>
  24 |     | <span class='neutral'> *</span>
  25 |     | <span class='neutral'> * This contract is abstract and requires several functions to be implemented in various modules:</span>
  26 |     | <span class='neutral'> *</span>
  27 |     | <span class='neutral'> * - A counting module must implement {_quorumReached}, {_voteSucceeded} and {_countVote}</span>
  28 |     | <span class='neutral'> * - A voting module must implement {_getVotes}</span>
  29 |     | <span class='neutral'> * - Additionally, {votingPeriod}, {votingDelay}, and {quorum} must also be implemented</span>
  30 |     | <span class='neutral'> */</span>
  31 |     | <span class='neutral'>abstract contract GovernorUpgradeable is Initializable, ContextUpgradeable, ERC165Upgradeable, EIP712Upgradeable, NoncesUpgradeable, IGovernor, IERC721Receiver, IERC1155Receiver {</span>
  32 |     | <span class='neutral'>    using DoubleEndedQueue for DoubleEndedQueue.Bytes32Deque;</span>
  33 |     | <span class='neutral'></span>
  34 |     | <span class='neutral'>    bytes32 public constant BALLOT_TYPEHASH =</span>
  35 |     | <span class='neutral'>        keccak256(&quot;Ballot(uint256 proposalId,uint8 support,address voter,uint256 nonce)&quot;);</span>
  36 |     | <span class='neutral'>    bytes32 public constant EXTENDED_BALLOT_TYPEHASH =</span>
  37 |     | <span class='neutral'>        keccak256(</span>
  38 |     | <span class='neutral'>            &quot;ExtendedBallot(uint256 proposalId,uint8 support,address voter,uint256 nonce,string reason,bytes params)&quot;</span>
  39 |     | <span class='neutral'>        );</span>
  40 |     | <span class='neutral'></span>
  41 |     | <span class='neutral'>    struct ProposalCore {</span>
  42 |     | <span class='neutral'>        address proposer;</span>
  43 |     | <span class='neutral'>        uint48 voteStart;</span>
  44 |     | <span class='neutral'>        uint32 voteDuration;</span>
  45 |     | <span class='neutral'>        bool executed;</span>
  46 |     | <span class='neutral'>        bool canceled;</span>
  47 |     | <span class='neutral'>        uint48 etaSeconds;</span>
  48 |     | <span class='neutral'>    }</span>
  49 |     | <span class='neutral'></span>
  50 |     | <span class='neutral'>    bytes32 private constant ALL_PROPOSAL_STATES_BITMAP = bytes32((2 ** (uint8(type(ProposalState).max) + 1)) - 1);</span>
  51 |     | <span class='neutral'>    /// @custom:storage-location erc7201:openzeppelin.storage.Governor</span>
  52 |     | <span class='neutral'>    struct GovernorStorage {</span>
  53 |     | <span class='neutral'>        string _name;</span>
  54 |     | <span class='neutral'></span>
  55 |     | <span class='neutral'>        mapping(uint256 proposalId =&gt; ProposalCore) _proposals;</span>
  56 |     | <span class='neutral'></span>
  57 |     | <span class='neutral'>        // This queue keeps track of the governor operating on itself. Calls to functions protected by the {onlyGovernance}</span>
  58 |     | <span class='neutral'>        // modifier needs to be whitelisted in this queue. Whitelisting is set in {execute}, consumed by the</span>
  59 |     | <span class='neutral'>        // {onlyGovernance} modifier and eventually reset after {_executeOperations} completes. This ensures that the</span>
  60 |     | <span class='neutral'>        // execution of {onlyGovernance} protected calls can only be achieved through successful proposals.</span>
  61 |     | <span class='neutral'>        DoubleEndedQueue.Bytes32Deque _governanceCall;</span>
  62 |     | <span class='neutral'>    }</span>
  63 |     | <span class='neutral'></span>
  64 |     | <span class='neutral'>    // keccak256(abi.encode(uint256(keccak256(&quot;openzeppelin.storage.Governor&quot;)) - 1)) &amp; ~bytes32(uint256(0xff))</span>
  65 |     | <span class='neutral'>    bytes32 private constant GovernorStorageLocation = 0x7c712897014dbe49c045ef1299aa2d5f9e67e48eea4403efa21f1e0f3ac0cb00;</span>
  66 |     | <span class='neutral'></span>
  67 |     | <span class='neutral'>    function _getGovernorStorage() private pure returns (GovernorStorage storage $) {</span>
  68 |     | <span class='neutral'>        assembly {</span>
  69 |     | <span class='neutral'>            $.slot := GovernorStorageLocation</span>
  70 |     | <span class='neutral'>        }</span>
  71 |     | <span class='neutral'>    }</span>
  72 |     | <span class='neutral'></span>
  73 |     | <span class='neutral'>    /**</span>
  74 |     | <span class='neutral'>     * @dev Restricts a function so it can only be executed through governance proposals. For example, governance</span>
  75 |     | <span class='neutral'>     * parameter setters in {GovernorSettings} are protected using this modifier.</span>
  76 |     | <span class='neutral'>     *</span>
  77 |     | <span class='neutral'>     * The governance executing address may be different from the Governor&#39;s own address, for example it could be a</span>
  78 |     | <span class='neutral'>     * timelock. This can be customized by modules by overriding {_executor}. The executor is only able to invoke these</span>
  79 |     | <span class='neutral'>     * functions during the execution of the governor&#39;s {execute} function, and not under any other circumstances. Thus,</span>
  80 |     | <span class='neutral'>     * for example, additional timelock proposers are not able to change governance parameters without going through the</span>
  81 |     | <span class='neutral'>     * governance protocol (since v4.6).</span>
  82 |     | <span class='neutral'>     */</span>
  83 |     | <span class='neutral'>    modifier onlyGovernance() {</span>
  84 |     | <span class='neutral'>        _checkGovernance();</span>
  85 |     | <span class='neutral'>        _;</span>
  86 |     | <span class='neutral'>    }</span>
  87 |     | <span class='neutral'></span>
  88 |     | <span class='neutral'>    /**</span>
  89 |     | <span class='neutral'>     * @dev Sets the value for {name} and {version}</span>
  90 |     | <span class='neutral'>     */</span>
  91 |     | <span class='neutral'>    function __Governor_init(string memory name_) internal onlyInitializing {</span>
  92 |     | <span class='neutral'>        __EIP712_init_unchained(name_, version());</span>
  93 |     | <span class='neutral'>        __Governor_init_unchained(name_);</span>
  94 |     | <span class='neutral'>    }</span>
  95 |     | <span class='neutral'></span>
  96 |     | <span class='neutral'>    function __Governor_init_unchained(string memory name_) internal onlyInitializing {</span>
  97 |     | <span class='neutral'>        GovernorStorage storage $ = _getGovernorStorage();</span>
  98 |     | <span class='neutral'>        $._name = name_;</span>
  99 |     | <span class='neutral'>    }</span>
 100 |     | <span class='neutral'></span>
 101 |     | <span class='neutral'>    /**</span>
 102 |     | <span class='neutral'>     * @dev Function to receive ETH that will be handled by the governor (disabled if executor is a third party contract)</span>
 103 |     | <span class='neutral'>     */</span>
 104 |     | <span class='neutral'>    receive() external payable virtual {</span>
 105 |     | <span class='neutral'>        if (_executor() != address(this)) {</span>
 106 |     | <span class='neutral'>            revert GovernorDisabledDeposit();</span>
 107 |     | <span class='neutral'>        }</span>
 108 |     | <span class='neutral'>    }</span>
 109 |     | <span class='neutral'></span>
 110 |     | <span class='neutral'>    /// @inheritdoc IERC165</span>
 111 |     | <span class='neutral'>    function supportsInterface(bytes4 interfaceId) public view virtual override(IERC165, ERC165Upgradeable) returns (bool) {</span>
 112 |     | <span class='neutral'>        return</span>
 113 |     | <span class='neutral'>            interfaceId == type(IGovernor).interfaceId ||</span>
 114 |     | <span class='neutral'>            interfaceId == type(IGovernor).interfaceId ^ IGovernor.getProposalId.selector ||</span>
 115 |     | <span class='neutral'>            interfaceId == type(IERC1155Receiver).interfaceId ||</span>
 116 |     | <span class='neutral'>            super.supportsInterface(interfaceId);</span>
 117 |     | <span class='neutral'>    }</span>
 118 |     | <span class='neutral'></span>
 119 |     | <span class='neutral'>    /// @inheritdoc IGovernor</span>
 120 |     | <span class='neutral'>    function name() public view virtual returns (string memory) {</span>
 121 |     | <span class='neutral'>        GovernorStorage storage $ = _getGovernorStorage();</span>
 122 |     | <span class='neutral'>        return $._name;</span>
 123 |     | <span class='neutral'>    }</span>
 124 |     | <span class='neutral'></span>
 125 |     | <span class='neutral'>    /// @inheritdoc IGovernor</span>
 126 |     | <span class='neutral'>    function version() public view virtual returns (string memory) {</span>
 127 |     | <span class='neutral'>        return &quot;1&quot;;</span>
 128 |     | <span class='neutral'>    }</span>
 129 |     | <span class='neutral'></span>
 130 |     | <span class='neutral'>    /**</span>
 131 |     | <span class='neutral'>     * @dev See {IGovernor-hashProposal}.</span>
 132 |     | <span class='neutral'>     *</span>
 133 |     | <span class='neutral'>     * The proposal id is produced by hashing the ABI encoded `targets` array, the `values` array, the `calldatas` array</span>
 134 |     | <span class='neutral'>     * and the descriptionHash (bytes32 which itself is the keccak256 hash of the description string). This proposal id</span>
 135 |     | <span class='neutral'>     * can be produced from the proposal data which is part of the {ProposalCreated} event. It can even be computed in</span>
 136 |     | <span class='neutral'>     * advance, before the proposal is submitted.</span>
 137 |     | <span class='neutral'>     *</span>
 138 |     | <span class='neutral'>     * Note that the chainId and the governor address are not part of the proposal id computation. Consequently, the</span>
 139 |     | <span class='neutral'>     * same proposal (with same operation and same description) will have the same id if submitted on multiple governors</span>
 140 |     | <span class='neutral'>     * across multiple networks. This also means that in order to execute the same operation twice (on the same</span>
 141 |     | <span class='neutral'>     * governor) the proposer will have to change the description in order to avoid proposal id conflicts.</span>
 142 |     | <span class='neutral'>     */</span>
 143 |     | <span class='neutral'>    function hashProposal(</span>
 144 |     | <span class='neutral'>        address[] memory targets,</span>
 145 |     | <span class='neutral'>        uint256[] memory values,</span>
 146 |     | <span class='neutral'>        bytes[] memory calldatas,</span>
 147 |     | <span class='neutral'>        bytes32 descriptionHash</span>
 148 |     | <span class='neutral'>    ) public pure virtual returns (uint256) {</span>
 149 |     | <span class='neutral'>        return uint256(keccak256(abi.encode(targets, values, calldatas, descriptionHash)));</span>
 150 |     | <span class='neutral'>    }</span>
 151 |     | <span class='neutral'></span>
 152 |     | <span class='neutral'>    /// @inheritdoc IGovernor</span>
 153 |     | <span class='neutral'>    function getProposalId(</span>
 154 |     | <span class='neutral'>        address[] memory targets,</span>
 155 |     | <span class='neutral'>        uint256[] memory values,</span>
 156 |     | <span class='neutral'>        bytes[] memory calldatas,</span>
 157 |     | <span class='neutral'>        bytes32 descriptionHash</span>
 158 |     | <span class='neutral'>    ) public view virtual returns (uint256) {</span>
 159 |     | <span class='neutral'>        return hashProposal(targets, values, calldatas, descriptionHash);</span>
 160 |     | <span class='neutral'>    }</span>
 161 |     | <span class='neutral'></span>
 162 |     | <span class='neutral'>    /// @inheritdoc IGovernor</span>
 163 |     | <span class='neutral'>    function state(uint256 proposalId) public view virtual returns (ProposalState) {</span>
 164 |     | <span class='neutral'>        GovernorStorage storage $ = _getGovernorStorage();</span>
 165 |     | <span class='neutral'>        // We read the struct fields into the stack at once so Solidity emits a single SLOAD</span>
 166 |     | <span class='neutral'>        ProposalCore storage proposal = $._proposals[proposalId];</span>
 167 |     | <span class='neutral'>        bool proposalExecuted = proposal.executed;</span>
 168 |     | <span class='neutral'>        bool proposalCanceled = proposal.canceled;</span>
 169 |     | <span class='neutral'></span>
 170 |     | <span class='neutral'>        if (proposalExecuted) {</span>
 171 |     | <span class='neutral'>            return ProposalState.Executed;</span>
 172 |     | <span class='neutral'>        }</span>
 173 |     | <span class='neutral'></span>
 174 |     | <span class='neutral'>        if (proposalCanceled) {</span>
 175 |     | <span class='neutral'>            return ProposalState.Canceled;</span>
 176 |     | <span class='neutral'>        }</span>
 177 |     | <span class='neutral'></span>
 178 |     | <span class='neutral'>        uint256 snapshot = proposalSnapshot(proposalId);</span>
 179 |     | <span class='neutral'></span>
 180 |     | <span class='neutral'>        if (snapshot == 0) {</span>
 181 |     | <span class='neutral'>            revert GovernorNonexistentProposal(proposalId);</span>
 182 |     | <span class='neutral'>        }</span>
 183 |     | <span class='neutral'></span>
 184 |     | <span class='neutral'>        uint256 currentTimepoint = clock();</span>
 185 |     | <span class='neutral'></span>
 186 |     | <span class='neutral'>        if (snapshot &gt;= currentTimepoint) {</span>
 187 |     | <span class='neutral'>            return ProposalState.Pending;</span>
 188 |     | <span class='neutral'>        }</span>
 189 |     | <span class='neutral'></span>
 190 |     | <span class='neutral'>        uint256 deadline = proposalDeadline(proposalId);</span>
 191 |     | <span class='neutral'></span>
 192 |     | <span class='neutral'>        if (deadline &gt;= currentTimepoint) {</span>
 193 |     | <span class='neutral'>            return ProposalState.Active;</span>
 194 |     | <span class='neutral'>        } else if (!_quorumReached(proposalId) || !_voteSucceeded(proposalId)) {</span>
 195 |     | <span class='neutral'>            return ProposalState.Defeated;</span>
 196 |     | <span class='neutral'>        } else if (proposalEta(proposalId) == 0) {</span>
 197 |     | <span class='neutral'>            return ProposalState.Succeeded;</span>
 198 |     | <span class='neutral'>        } else {</span>
 199 |     | <span class='neutral'>            return ProposalState.Queued;</span>
 200 |     | <span class='neutral'>        }</span>
 201 |     | <span class='neutral'>    }</span>
 202 |     | <span class='neutral'></span>
 203 |     | <span class='neutral'>    /// @inheritdoc IGovernor</span>
 204 |     | <span class='neutral'>    function proposalThreshold() public view virtual returns (uint256) {</span>
 205 |     | <span class='neutral'>        return 0;</span>
 206 |     | <span class='neutral'>    }</span>
 207 |     | <span class='neutral'></span>
 208 |     | <span class='neutral'>    /// @inheritdoc IGovernor</span>
 209 |     | <span class='neutral'>    function proposalSnapshot(uint256 proposalId) public view virtual returns (uint256) {</span>
 210 |     | <span class='neutral'>        GovernorStorage storage $ = _getGovernorStorage();</span>
 211 |     | <span class='neutral'>        return $._proposals[proposalId].voteStart;</span>
 212 |     | <span class='neutral'>    }</span>
 213 |     | <span class='neutral'></span>
 214 |     | <span class='neutral'>    /// @inheritdoc IGovernor</span>
 215 |     | <span class='neutral'>    function proposalDeadline(uint256 proposalId) public view virtual returns (uint256) {</span>
 216 |     | <span class='neutral'>        GovernorStorage storage $ = _getGovernorStorage();</span>
 217 |     | <span class='neutral'>        return $._proposals[proposalId].voteStart + $._proposals[proposalId].voteDuration;</span>
 218 |     | <span class='neutral'>    }</span>
 219 |     | <span class='neutral'></span>
 220 |     | <span class='neutral'>    /// @inheritdoc IGovernor</span>
 221 |     | <span class='neutral'>    function proposalProposer(uint256 proposalId) public view virtual returns (address) {</span>
 222 |     | <span class='neutral'>        GovernorStorage storage $ = _getGovernorStorage();</span>
 223 |     | <span class='neutral'>        return $._proposals[proposalId].proposer;</span>
 224 |     | <span class='neutral'>    }</span>
 225 |     | <span class='neutral'></span>
 226 |     | <span class='neutral'>    /// @inheritdoc IGovernor</span>
 227 |     | <span class='neutral'>    function proposalEta(uint256 proposalId) public view virtual returns (uint256) {</span>
 228 |     | <span class='neutral'>        GovernorStorage storage $ = _getGovernorStorage();</span>
 229 |     | <span class='neutral'>        return $._proposals[proposalId].etaSeconds;</span>
 230 |     | <span class='neutral'>    }</span>
 231 |     | <span class='neutral'></span>
 232 |     | <span class='neutral'>    /// @inheritdoc IGovernor</span>
 233 |     | <span class='neutral'>    function proposalNeedsQueuing(uint256) public view virtual returns (bool) {</span>
 234 |     | <span class='neutral'>        return false;</span>
 235 |     | <span class='neutral'>    }</span>
 236 |     | <span class='neutral'></span>
 237 |     | <span class='neutral'>    /**</span>
 238 |     | <span class='neutral'>     * @dev Reverts if the `msg.sender` is not the executor. In case the executor is not this contract</span>
 239 |     | <span class='neutral'>     * itself, the function reverts if `msg.data` is not whitelisted as a result of an {execute}</span>
 240 |     | <span class='neutral'>     * operation. See {onlyGovernance}.</span>
 241 |     | <span class='neutral'>     */</span>
 242 |     | <span class='neutral'>    function _checkGovernance() internal virtual {</span>
 243 |     | <span class='neutral'>        GovernorStorage storage $ = _getGovernorStorage();</span>
 244 |     | <span class='neutral'>        if (_executor() != _msgSender()) {</span>
 245 |     | <span class='neutral'>            revert GovernorOnlyExecutor(_msgSender());</span>
 246 |     | <span class='neutral'>        }</span>
 247 |     | <span class='neutral'>        if (_executor() != address(this)) {</span>
 248 |     | <span class='neutral'>            bytes32 msgDataHash = keccak256(_msgData());</span>
 249 |     | <span class='neutral'>            // loop until popping the expected operation - throw if deque is empty (operation not authorized)</span>
 250 |     | <span class='neutral'>            while ($._governanceCall.popFront() != msgDataHash) {}</span>
 251 |     | <span class='neutral'>        }</span>
 252 |     | <span class='neutral'>    }</span>
 253 |     | <span class='neutral'></span>
 254 |     | <span class='neutral'>    /**</span>
 255 |     | <span class='neutral'>     * @dev Amount of votes already cast passes the threshold limit.</span>
 256 |     | <span class='neutral'>     */</span>
 257 |     | <span class='neutral'>    function _quorumReached(uint256 proposalId) internal view virtual returns (bool);</span>
 258 |     | <span class='neutral'></span>
 259 |     | <span class='neutral'>    /**</span>
 260 |     | <span class='neutral'>     * @dev Is the proposal successful or not.</span>
 261 |     | <span class='neutral'>     */</span>
 262 |     | <span class='neutral'>    function _voteSucceeded(uint256 proposalId) internal view virtual returns (bool);</span>
 263 |     | <span class='neutral'></span>
 264 |     | <span class='neutral'>    /**</span>
 265 |     | <span class='neutral'>     * @dev Get the voting weight of `account` at a specific `timepoint`, for a vote as described by `params`.</span>
 266 |     | <span class='neutral'>     */</span>
 267 |     | <span class='neutral'>    function _getVotes(address account, uint256 timepoint, bytes memory params) internal view virtual returns (uint256);</span>
 268 |     | <span class='neutral'></span>
 269 |     | <span class='neutral'>    /**</span>
 270 |     | <span class='neutral'>     * @dev Register a vote for `proposalId` by `account` with a given `support`, voting `weight` and voting `params`.</span>
 271 |     | <span class='neutral'>     *</span>
 272 |     | <span class='neutral'>     * Note: Support is generic and can represent various things depending on the voting system used.</span>
 273 |     | <span class='neutral'>     */</span>
 274 |     | <span class='neutral'>    function _countVote(</span>
 275 |     | <span class='neutral'>        uint256 proposalId,</span>
 276 |     | <span class='neutral'>        address account,</span>
 277 |     | <span class='neutral'>        uint8 support,</span>
 278 |     | <span class='neutral'>        uint256 totalWeight,</span>
 279 |     | <span class='neutral'>        bytes memory params</span>
 280 |     | <span class='neutral'>    ) internal virtual returns (uint256);</span>
 281 |     | <span class='neutral'></span>
 282 |     | <span class='neutral'>    /**</span>
 283 |     | <span class='neutral'>     * @dev Hook that should be called every time the tally for a proposal is updated.</span>
 284 |     | <span class='neutral'>     *</span>
 285 |     | <span class='neutral'>     * Note: This function must run successfully. Reverts will result in the bricking of governance</span>
 286 |     | <span class='neutral'>     */</span>
 287 |     | <span class='neutral'>    function _tallyUpdated(uint256 proposalId) internal virtual {}</span>
 288 |     | <span class='neutral'></span>
 289 |     | <span class='neutral'>    /**</span>
 290 |     | <span class='neutral'>     * @dev Default additional encoded parameters used by castVote methods that don&#39;t include them</span>
 291 |     | <span class='neutral'>     *</span>
 292 |     | <span class='neutral'>     * Note: Should be overridden by specific implementations to use an appropriate value, the</span>
 293 |     | <span class='neutral'>     * meaning of the additional params, in the context of that implementation</span>
 294 |     | <span class='neutral'>     */</span>
 295 |     | <span class='neutral'>    function _defaultParams() internal view virtual returns (bytes memory) {</span>
 296 |     | <span class='neutral'>        return &quot;&quot;;</span>
 297 |     | <span class='neutral'>    }</span>
 298 |     | <span class='neutral'></span>
 299 |     | <span class='neutral'>    /**</span>
 300 |     | <span class='neutral'>     * @dev See {IGovernor-propose}. This function has opt-in frontrunning protection, described in {_isValidDescriptionForProposer}.</span>
 301 |     | <span class='neutral'>     */</span>
 302 |     | <span class='neutral'>    function propose(</span>
 303 |     | <span class='neutral'>        address[] memory targets,</span>
 304 |     | <span class='neutral'>        uint256[] memory values,</span>
 305 |     | <span class='neutral'>        bytes[] memory calldatas,</span>
 306 |     | <span class='neutral'>        string memory description</span>
 307 |     | <span class='neutral'>    ) public virtual returns (uint256) {</span>
 308 |     | <span class='neutral'>        address proposer = _msgSender();</span>
 309 |     | <span class='neutral'></span>
 310 |     | <span class='neutral'>        // check description restriction</span>
 311 |     | <span class='neutral'>        if (!_isValidDescriptionForProposer(proposer, description)) {</span>
 312 |     | <span class='neutral'>            revert GovernorRestrictedProposer(proposer);</span>
 313 |     | <span class='neutral'>        }</span>
 314 |     | <span class='neutral'></span>
 315 |     | <span class='neutral'>        // check proposal threshold</span>
 316 |     | <span class='neutral'>        uint256 votesThreshold = proposalThreshold();</span>
 317 |     | <span class='neutral'>        if (votesThreshold &gt; 0) {</span>
 318 |     | <span class='neutral'>            uint256 proposerVotes = getVotes(proposer, clock() - 1);</span>
 319 |     | <span class='neutral'>            if (proposerVotes &lt; votesThreshold) {</span>
 320 |     | <span class='neutral'>                revert GovernorInsufficientProposerVotes(proposer, proposerVotes, votesThreshold);</span>
 321 |     | <span class='neutral'>            }</span>
 322 |     | <span class='neutral'>        }</span>
 323 |     | <span class='neutral'></span>
 324 |     | <span class='neutral'>        return _propose(targets, values, calldatas, description, proposer);</span>
 325 |     | <span class='neutral'>    }</span>
 326 |     | <span class='neutral'></span>
 327 |     | <span class='neutral'>    /**</span>
 328 |     | <span class='neutral'>     * @dev Internal propose mechanism. Can be overridden to add more logic on proposal creation.</span>
 329 |     | <span class='neutral'>     *</span>
 330 |     | <span class='neutral'>     * Emits a {IGovernor-ProposalCreated} event.</span>
 331 |     | <span class='neutral'>     */</span>
 332 |     | <span class='neutral'>    function _propose(</span>
 333 |     | <span class='neutral'>        address[] memory targets,</span>
 334 |     | <span class='neutral'>        uint256[] memory values,</span>
 335 |     | <span class='neutral'>        bytes[] memory calldatas,</span>
 336 |     | <span class='neutral'>        string memory description,</span>
 337 |     | <span class='neutral'>        address proposer</span>
 338 |     | <span class='neutral'>    ) internal virtual returns (uint256 proposalId) {</span>
 339 |     | <span class='neutral'>        GovernorStorage storage $ = _getGovernorStorage();</span>
 340 |     | <span class='neutral'>        proposalId = getProposalId(targets, values, calldatas, keccak256(bytes(description)));</span>
 341 |     | <span class='neutral'></span>
 342 |     | <span class='neutral'>        if (targets.length != values.length || targets.length != calldatas.length || targets.length == 0) {</span>
 343 |     | <span class='neutral'>            revert GovernorInvalidProposalLength(targets.length, calldatas.length, values.length);</span>
 344 |     | <span class='neutral'>        }</span>
 345 |     | <span class='neutral'>        if ($._proposals[proposalId].voteStart != 0) {</span>
 346 |     | <span class='neutral'>            revert GovernorUnexpectedProposalState(proposalId, state(proposalId), bytes32(0));</span>
 347 |     | <span class='neutral'>        }</span>
 348 |     | <span class='neutral'></span>
 349 |     | <span class='neutral'>        uint256 snapshot = clock() + votingDelay();</span>
 350 |     | <span class='neutral'>        uint256 duration = votingPeriod();</span>
 351 |     | <span class='neutral'></span>
 352 |     | <span class='neutral'>        ProposalCore storage proposal = $._proposals[proposalId];</span>
 353 |     | <span class='neutral'>        proposal.proposer = proposer;</span>
 354 |     | <span class='neutral'>        proposal.voteStart = SafeCast.toUint48(snapshot);</span>
 355 |     | <span class='neutral'>        proposal.voteDuration = SafeCast.toUint32(duration);</span>
 356 |     | <span class='neutral'></span>
 357 |     | <span class='neutral'>        emit ProposalCreated(</span>
 358 |     | <span class='neutral'>            proposalId,</span>
 359 |     | <span class='neutral'>            proposer,</span>
 360 |     | <span class='neutral'>            targets,</span>
 361 |     | <span class='neutral'>            values,</span>
 362 |     | <span class='neutral'>            new string[](targets.length),</span>
 363 |     | <span class='neutral'>            calldatas,</span>
 364 |     | <span class='neutral'>            snapshot,</span>
 365 |     | <span class='neutral'>            snapshot + duration,</span>
 366 |     | <span class='neutral'>            description</span>
 367 |     | <span class='neutral'>        );</span>
 368 |     | <span class='neutral'></span>
 369 |     | <span class='neutral'>        // Using a named return variable to avoid stack too deep errors</span>
 370 |     | <span class='neutral'>    }</span>
 371 |     | <span class='neutral'></span>
 372 |     | <span class='neutral'>    /// @inheritdoc IGovernor</span>
 373 |     | <span class='neutral'>    function queue(</span>
 374 |     | <span class='neutral'>        address[] memory targets,</span>
 375 |     | <span class='neutral'>        uint256[] memory values,</span>
 376 |     | <span class='neutral'>        bytes[] memory calldatas,</span>
 377 |     | <span class='neutral'>        bytes32 descriptionHash</span>
 378 |     | <span class='neutral'>    ) public virtual returns (uint256) {</span>
 379 |     | <span class='neutral'>        GovernorStorage storage $ = _getGovernorStorage();</span>
 380 |     | <span class='neutral'>        uint256 proposalId = getProposalId(targets, values, calldatas, descriptionHash);</span>
 381 |     | <span class='neutral'></span>
 382 |     | <span class='neutral'>        _validateStateBitmap(proposalId, _encodeStateBitmap(ProposalState.Succeeded));</span>
 383 |     | <span class='neutral'></span>
 384 |     | <span class='neutral'>        uint48 etaSeconds = _queueOperations(proposalId, targets, values, calldatas, descriptionHash);</span>
 385 |     | <span class='neutral'></span>
 386 |     | <span class='neutral'>        if (etaSeconds != 0) {</span>
 387 |     | <span class='neutral'>            $._proposals[proposalId].etaSeconds = etaSeconds;</span>
 388 |     | <span class='neutral'>            emit ProposalQueued(proposalId, etaSeconds);</span>
 389 |     | <span class='neutral'>        } else {</span>
 390 |     | <span class='neutral'>            revert GovernorQueueNotImplemented();</span>
 391 |     | <span class='neutral'>        }</span>
 392 |     | <span class='neutral'></span>
 393 |     | <span class='neutral'>        return proposalId;</span>
 394 |     | <span class='neutral'>    }</span>
 395 |     | <span class='neutral'></span>
 396 |     | <span class='neutral'>    /**</span>
 397 |     | <span class='neutral'>     * @dev Internal queuing mechanism. Can be overridden (without a super call) to modify the way queuing is</span>
 398 |     | <span class='neutral'>     * performed (for example adding a vault/timelock).</span>
 399 |     | <span class='neutral'>     *</span>
 400 |     | <span class='neutral'>     * This is empty by default, and must be overridden to implement queuing.</span>
 401 |     | <span class='neutral'>     *</span>
 402 |     | <span class='neutral'>     * This function returns a timestamp that describes the expected ETA for execution. If the returned value is 0</span>
 403 |     | <span class='neutral'>     * (which is the default value), the core will consider queueing did not succeed, and the public {queue} function</span>
 404 |     | <span class='neutral'>     * will revert.</span>
 405 |     | <span class='neutral'>     *</span>
 406 |     | <span class='neutral'>     * NOTE: Calling this function directly will NOT check the current state of the proposal, or emit the</span>
 407 |     | <span class='neutral'>     * `ProposalQueued` event. Queuing a proposal should be done using {queue}.</span>
 408 |     | <span class='neutral'>     */</span>
 409 |     | <span class='neutral'>    function _queueOperations(</span>
 410 |     | <span class='neutral'>        uint256 /*proposalId*/,</span>
 411 |     | <span class='neutral'>        address[] memory /*targets*/,</span>
 412 |     | <span class='neutral'>        uint256[] memory /*values*/,</span>
 413 |     | <span class='neutral'>        bytes[] memory /*calldatas*/,</span>
 414 |     | <span class='neutral'>        bytes32 /*descriptionHash*/</span>
 415 |     | <span class='neutral'>    ) internal virtual returns (uint48) {</span>
 416 |     | <span class='neutral'>        return 0;</span>
 417 |     | <span class='neutral'>    }</span>
 418 |     | <span class='neutral'></span>
 419 |     | <span class='neutral'>    /// @inheritdoc IGovernor</span>
 420 |     | <span class='neutral'>    function execute(</span>
 421 |     | <span class='neutral'>        address[] memory targets,</span>
 422 |     | <span class='neutral'>        uint256[] memory values,</span>
 423 |     | <span class='neutral'>        bytes[] memory calldatas,</span>
 424 |     | <span class='neutral'>        bytes32 descriptionHash</span>
 425 |     | <span class='neutral'>    ) public payable virtual returns (uint256) {</span>
 426 |     | <span class='neutral'>        GovernorStorage storage $ = _getGovernorStorage();</span>
 427 |     | <span class='neutral'>        uint256 proposalId = getProposalId(targets, values, calldatas, descriptionHash);</span>
 428 |     | <span class='neutral'></span>
 429 |     | <span class='neutral'>        _validateStateBitmap(</span>
 430 |     | <span class='neutral'>            proposalId,</span>
 431 |     | <span class='neutral'>            _encodeStateBitmap(ProposalState.Succeeded) | _encodeStateBitmap(ProposalState.Queued)</span>
 432 |     | <span class='neutral'>        );</span>
 433 |     | <span class='neutral'></span>
 434 |     | <span class='neutral'>        // mark as executed before calls to avoid reentrancy</span>
 435 |     | <span class='neutral'>        $._proposals[proposalId].executed = true;</span>
 436 |     | <span class='neutral'></span>
 437 |     | <span class='neutral'>        // before execute: register governance call in queue.</span>
 438 |     | <span class='neutral'>        if (_executor() != address(this)) {</span>
 439 |     | <span class='neutral'>            for (uint256 i = 0; i &lt; targets.length; ++i) {</span>
 440 |     | <span class='neutral'>                if (targets[i] == address(this)) {</span>
 441 |     | <span class='neutral'>                    $._governanceCall.pushBack(keccak256(calldatas[i]));</span>
 442 |     | <span class='neutral'>                }</span>
 443 |     | <span class='neutral'>            }</span>
 444 |     | <span class='neutral'>        }</span>
 445 |     | <span class='neutral'></span>
 446 |     | <span class='neutral'>        _executeOperations(proposalId, targets, values, calldatas, descriptionHash);</span>
 447 |     | <span class='neutral'></span>
 448 |     | <span class='neutral'>        // after execute: cleanup governance call queue.</span>
 449 |     | <span class='neutral'>        if (_executor() != address(this) &amp;&amp; !$._governanceCall.empty()) {</span>
 450 |     | <span class='neutral'>            $._governanceCall.clear();</span>
 451 |     | <span class='neutral'>        }</span>
 452 |     | <span class='neutral'></span>
 453 |     | <span class='neutral'>        emit ProposalExecuted(proposalId);</span>
 454 |     | <span class='neutral'></span>
 455 |     | <span class='neutral'>        return proposalId;</span>
 456 |     | <span class='neutral'>    }</span>
 457 |     | <span class='neutral'></span>
 458 |     | <span class='neutral'>    /**</span>
 459 |     | <span class='neutral'>     * @dev Internal execution mechanism. Can be overridden (without a super call) to modify the way execution is</span>
 460 |     | <span class='neutral'>     * performed (for example adding a vault/timelock).</span>
 461 |     | <span class='neutral'>     *</span>
 462 |     | <span class='neutral'>     * NOTE: Calling this function directly will NOT check the current state of the proposal, set the executed flag to</span>
 463 |     | <span class='neutral'>     * true or emit the `ProposalExecuted` event. Executing a proposal should be done using {execute}.</span>
 464 |     | <span class='neutral'>     */</span>
 465 |     | <span class='neutral'>    function _executeOperations(</span>
 466 |     | <span class='neutral'>        uint256 /* proposalId */,</span>
 467 |     | <span class='neutral'>        address[] memory targets,</span>
 468 |     | <span class='neutral'>        uint256[] memory values,</span>
 469 |     | <span class='neutral'>        bytes[] memory calldatas,</span>
 470 |     | <span class='neutral'>        bytes32 /*descriptionHash*/</span>
 471 |     | <span class='neutral'>    ) internal virtual {</span>
 472 |     | <span class='neutral'>        for (uint256 i = 0; i &lt; targets.length; ++i) {</span>
 473 |     | <span class='neutral'>            (bool success, bytes memory returndata) = targets[i].call{value: values[i]}(calldatas[i]);</span>
 474 |     | <span class='neutral'>            Address.verifyCallResult(success, returndata);</span>
 475 |     | <span class='neutral'>        }</span>
 476 |     | <span class='neutral'>    }</span>
 477 |     | <span class='neutral'></span>
 478 |     | <span class='neutral'>    /// @inheritdoc IGovernor</span>
 479 |     | <span class='neutral'>    function cancel(</span>
 480 |     | <span class='neutral'>        address[] memory targets,</span>
 481 |     | <span class='neutral'>        uint256[] memory values,</span>
 482 |     | <span class='neutral'>        bytes[] memory calldatas,</span>
 483 |     | <span class='neutral'>        bytes32 descriptionHash</span>
 484 |     | <span class='neutral'>    ) public virtual returns (uint256) {</span>
 485 |     | <span class='neutral'>        // The proposalId will be recomputed in the `_cancel` call further down. However we need the value before we</span>
 486 |     | <span class='neutral'>        // do the internal call, because we need to check the proposal state BEFORE the internal `_cancel` call</span>
 487 |     | <span class='neutral'>        // changes it. The `getProposalId` duplication has a cost that is limited, and that we accept.</span>
 488 |     | <span class='neutral'>        uint256 proposalId = getProposalId(targets, values, calldatas, descriptionHash);</span>
 489 |     | <span class='neutral'></span>
 490 |     | <span class='neutral'>        address caller = _msgSender();</span>
 491 |     | <span class='neutral'>        if (!_validateCancel(proposalId, caller)) revert GovernorUnableToCancel(proposalId, caller);</span>
 492 |     | <span class='neutral'></span>
 493 |     | <span class='neutral'>        return _cancel(targets, values, calldatas, descriptionHash);</span>
 494 |     | <span class='neutral'>    }</span>
 495 |     | <span class='neutral'></span>
 496 |     | <span class='neutral'>    /**</span>
 497 |     | <span class='neutral'>     * @dev Internal cancel mechanism with minimal restrictions. A proposal can be cancelled in any state other than</span>
 498 |     | <span class='neutral'>     * Canceled, Expired, or Executed. Once cancelled a proposal can&#39;t be re-submitted.</span>
 499 |     | <span class='neutral'>     *</span>
 500 |     | <span class='neutral'>     * Emits a {IGovernor-ProposalCanceled} event.</span>
 501 |     | <span class='neutral'>     */</span>
 502 |     | <span class='neutral'>    function _cancel(</span>
 503 |     | <span class='neutral'>        address[] memory targets,</span>
 504 |     | <span class='neutral'>        uint256[] memory values,</span>
 505 |     | <span class='neutral'>        bytes[] memory calldatas,</span>
 506 |     | <span class='neutral'>        bytes32 descriptionHash</span>
 507 |     | <span class='neutral'>    ) internal virtual returns (uint256) {</span>
 508 |     | <span class='neutral'>        GovernorStorage storage $ = _getGovernorStorage();</span>
 509 |     | <span class='neutral'>        uint256 proposalId = getProposalId(targets, values, calldatas, descriptionHash);</span>
 510 |     | <span class='neutral'></span>
 511 |     | <span class='neutral'>        _validateStateBitmap(</span>
 512 |     | <span class='neutral'>            proposalId,</span>
 513 |     | <span class='neutral'>            ALL_PROPOSAL_STATES_BITMAP ^</span>
 514 |     | <span class='neutral'>                _encodeStateBitmap(ProposalState.Canceled) ^</span>
 515 |     | <span class='neutral'>                _encodeStateBitmap(ProposalState.Expired) ^</span>
 516 |     | <span class='neutral'>                _encodeStateBitmap(ProposalState.Executed)</span>
 517 |     | <span class='neutral'>        );</span>
 518 |     | <span class='neutral'></span>
 519 |     | <span class='neutral'>        $._proposals[proposalId].canceled = true;</span>
 520 |     | <span class='neutral'>        emit ProposalCanceled(proposalId);</span>
 521 |     | <span class='neutral'></span>
 522 |     | <span class='neutral'>        return proposalId;</span>
 523 |     | <span class='neutral'>    }</span>
 524 |     | <span class='neutral'></span>
 525 |     | <span class='neutral'>    /// @inheritdoc IGovernor</span>
 526 |     | <span class='neutral'>    function getVotes(address account, uint256 timepoint) public view virtual returns (uint256) {</span>
 527 |     | <span class='neutral'>        return _getVotes(account, timepoint, _defaultParams());</span>
 528 |     | <span class='neutral'>    }</span>
 529 |     | <span class='neutral'></span>
 530 |     | <span class='neutral'>    /// @inheritdoc IGovernor</span>
 531 |     | <span class='neutral'>    function getVotesWithParams(</span>
 532 |     | <span class='neutral'>        address account,</span>
 533 |     | <span class='neutral'>        uint256 timepoint,</span>
 534 |     | <span class='neutral'>        bytes memory params</span>
 535 |     | <span class='neutral'>    ) public view virtual returns (uint256) {</span>
 536 |     | <span class='neutral'>        return _getVotes(account, timepoint, params);</span>
 537 |     | <span class='neutral'>    }</span>
 538 |     | <span class='neutral'></span>
 539 |     | <span class='neutral'>    /// @inheritdoc IGovernor</span>
 540 |     | <span class='neutral'>    function castVote(uint256 proposalId, uint8 support) public virtual returns (uint256) {</span>
 541 |     | <span class='neutral'>        address voter = _msgSender();</span>
 542 |     | <span class='neutral'>        return _castVote(proposalId, voter, support, &quot;&quot;);</span>
 543 |     | <span class='neutral'>    }</span>
 544 |     | <span class='neutral'></span>
 545 |     | <span class='neutral'>    /// @inheritdoc IGovernor</span>
 546 |     | <span class='neutral'>    function castVoteWithReason(</span>
 547 |     | <span class='neutral'>        uint256 proposalId,</span>
 548 |     | <span class='neutral'>        uint8 support,</span>
 549 |     | <span class='neutral'>        string calldata reason</span>
 550 |     | <span class='neutral'>    ) public virtual returns (uint256) {</span>
 551 |     | <span class='neutral'>        address voter = _msgSender();</span>
 552 |     | <span class='neutral'>        return _castVote(proposalId, voter, support, reason);</span>
 553 |     | <span class='neutral'>    }</span>
 554 |     | <span class='neutral'></span>
 555 |     | <span class='neutral'>    /// @inheritdoc IGovernor</span>
 556 |     | <span class='neutral'>    function castVoteWithReasonAndParams(</span>
 557 |     | <span class='neutral'>        uint256 proposalId,</span>
 558 |     | <span class='neutral'>        uint8 support,</span>
 559 |     | <span class='neutral'>        string calldata reason,</span>
 560 |     | <span class='neutral'>        bytes memory params</span>
 561 |     | <span class='neutral'>    ) public virtual returns (uint256) {</span>
 562 |     | <span class='neutral'>        address voter = _msgSender();</span>
 563 |     | <span class='neutral'>        return _castVote(proposalId, voter, support, reason, params);</span>
 564 |     | <span class='neutral'>    }</span>
 565 |     | <span class='neutral'></span>
 566 |     | <span class='neutral'>    /// @inheritdoc IGovernor</span>
 567 |     | <span class='neutral'>    function castVoteBySig(</span>
 568 |     | <span class='neutral'>        uint256 proposalId,</span>
 569 |     | <span class='neutral'>        uint8 support,</span>
 570 |     | <span class='neutral'>        address voter,</span>
 571 |     | <span class='neutral'>        bytes memory signature</span>
 572 |     | <span class='neutral'>    ) public virtual returns (uint256) {</span>
 573 |     | <span class='neutral'>        if (!_validateVoteSig(proposalId, support, voter, signature)) {</span>
 574 |     | <span class='neutral'>            revert GovernorInvalidSignature(voter);</span>
 575 |     | <span class='neutral'>        }</span>
 576 |     | <span class='neutral'>        return _castVote(proposalId, voter, support, &quot;&quot;);</span>
 577 |     | <span class='neutral'>    }</span>
 578 |     | <span class='neutral'></span>
 579 |     | <span class='neutral'>    /// @inheritdoc IGovernor</span>
 580 |     | <span class='neutral'>    function castVoteWithReasonAndParamsBySig(</span>
 581 |     | <span class='neutral'>        uint256 proposalId,</span>
 582 |     | <span class='neutral'>        uint8 support,</span>
 583 |     | <span class='neutral'>        address voter,</span>
 584 |     | <span class='neutral'>        string calldata reason,</span>
 585 |     | <span class='neutral'>        bytes memory params,</span>
 586 |     | <span class='neutral'>        bytes memory signature</span>
 587 |     | <span class='neutral'>    ) public virtual returns (uint256) {</span>
 588 |     | <span class='neutral'>        if (!_validateExtendedVoteSig(proposalId, support, voter, reason, params, signature)) {</span>
 589 |     | <span class='neutral'>            revert GovernorInvalidSignature(voter);</span>
 590 |     | <span class='neutral'>        }</span>
 591 |     | <span class='neutral'>        return _castVote(proposalId, voter, support, reason, params);</span>
 592 |     | <span class='neutral'>    }</span>
 593 |     | <span class='neutral'></span>
 594 |     | <span class='neutral'>    /// @dev Validate the `signature` used in {castVoteBySig} function.</span>
 595 |     | <span class='neutral'>    function _validateVoteSig(</span>
 596 |     | <span class='neutral'>        uint256 proposalId,</span>
 597 |     | <span class='neutral'>        uint8 support,</span>
 598 |     | <span class='neutral'>        address voter,</span>
 599 |     | <span class='neutral'>        bytes memory signature</span>
 600 |     | <span class='neutral'>    ) internal virtual returns (bool) {</span>
 601 |     | <span class='neutral'>        return</span>
 602 |     | <span class='neutral'>            SignatureChecker.isValidSignatureNow(</span>
 603 |     | <span class='neutral'>                voter,</span>
 604 |     | <span class='neutral'>                _hashTypedDataV4(keccak256(abi.encode(BALLOT_TYPEHASH, proposalId, support, voter, _useNonce(voter)))),</span>
 605 |     | <span class='neutral'>                signature</span>
 606 |     | <span class='neutral'>            );</span>
 607 |     | <span class='neutral'>    }</span>
 608 |     | <span class='neutral'></span>
 609 |     | <span class='neutral'>    /// @dev Validate the `signature` used in {castVoteWithReasonAndParamsBySig} function.</span>
 610 |     | <span class='neutral'>    function _validateExtendedVoteSig(</span>
 611 |     | <span class='neutral'>        uint256 proposalId,</span>
 612 |     | <span class='neutral'>        uint8 support,</span>
 613 |     | <span class='neutral'>        address voter,</span>
 614 |     | <span class='neutral'>        string memory reason,</span>
 615 |     | <span class='neutral'>        bytes memory params,</span>
 616 |     | <span class='neutral'>        bytes memory signature</span>
 617 |     | <span class='neutral'>    ) internal virtual returns (bool) {</span>
 618 |     | <span class='neutral'>        return</span>
 619 |     | <span class='neutral'>            SignatureChecker.isValidSignatureNow(</span>
 620 |     | <span class='neutral'>                voter,</span>
 621 |     | <span class='neutral'>                _hashTypedDataV4(</span>
 622 |     | <span class='neutral'>                    keccak256(</span>
 623 |     | <span class='neutral'>                        abi.encode(</span>
 624 |     | <span class='neutral'>                            EXTENDED_BALLOT_TYPEHASH,</span>
 625 |     | <span class='neutral'>                            proposalId,</span>
 626 |     | <span class='neutral'>                            support,</span>
 627 |     | <span class='neutral'>                            voter,</span>
 628 |     | <span class='neutral'>                            _useNonce(voter),</span>
 629 |     | <span class='neutral'>                            keccak256(bytes(reason)),</span>
 630 |     | <span class='neutral'>                            keccak256(params)</span>
 631 |     | <span class='neutral'>                        )</span>
 632 |     | <span class='neutral'>                    )</span>
 633 |     | <span class='neutral'>                ),</span>
 634 |     | <span class='neutral'>                signature</span>
 635 |     | <span class='neutral'>            );</span>
 636 |     | <span class='neutral'>    }</span>
 637 |     | <span class='neutral'></span>
 638 |     | <span class='neutral'>    /**</span>
 639 |     | <span class='neutral'>     * @dev Internal vote casting mechanism: Check that the vote is pending, that it has not been cast yet, retrieve</span>
 640 |     | <span class='neutral'>     * voting weight using {IGovernor-getVotes} and call the {_countVote} internal function. Uses the _defaultParams().</span>
 641 |     | <span class='neutral'>     *</span>
 642 |     | <span class='neutral'>     * Emits a {IGovernor-VoteCast} event.</span>
 643 |     | <span class='neutral'>     */</span>
 644 |     | <span class='neutral'>    function _castVote(</span>
 645 |     | <span class='neutral'>        uint256 proposalId,</span>
 646 |     | <span class='neutral'>        address account,</span>
 647 |     | <span class='neutral'>        uint8 support,</span>
 648 |     | <span class='neutral'>        string memory reason</span>
 649 |     | <span class='neutral'>    ) internal virtual returns (uint256) {</span>
 650 |     | <span class='neutral'>        return _castVote(proposalId, account, support, reason, _defaultParams());</span>
 651 |     | <span class='neutral'>    }</span>
 652 |     | <span class='neutral'></span>
 653 |     | <span class='neutral'>    /**</span>
 654 |     | <span class='neutral'>     * @dev Internal vote casting mechanism: Check that the vote is pending, that it has not been cast yet, retrieve</span>
 655 |     | <span class='neutral'>     * voting weight using {IGovernor-getVotes} and call the {_countVote} internal function.</span>
 656 |     | <span class='neutral'>     *</span>
 657 |     | <span class='neutral'>     * Emits a {IGovernor-VoteCast} event.</span>
 658 |     | <span class='neutral'>     */</span>
 659 |     | <span class='neutral'>    function _castVote(</span>
 660 |     | <span class='neutral'>        uint256 proposalId,</span>
 661 |     | <span class='neutral'>        address account,</span>
 662 |     | <span class='neutral'>        uint8 support,</span>
 663 |     | <span class='neutral'>        string memory reason,</span>
 664 |     | <span class='neutral'>        bytes memory params</span>
 665 |     | <span class='neutral'>    ) internal virtual returns (uint256) {</span>
 666 |     | <span class='neutral'>        _validateStateBitmap(proposalId, _encodeStateBitmap(ProposalState.Active));</span>
 667 |     | <span class='neutral'></span>
 668 |     | <span class='neutral'>        uint256 totalWeight = _getVotes(account, proposalSnapshot(proposalId), params);</span>
 669 |     | <span class='neutral'>        uint256 votedWeight = _countVote(proposalId, account, support, totalWeight, params);</span>
 670 |     | <span class='neutral'></span>
 671 |     | <span class='neutral'>        if (params.length == 0) {</span>
 672 |     | <span class='neutral'>            emit VoteCast(account, proposalId, support, votedWeight, reason);</span>
 673 |     | <span class='neutral'>        } else {</span>
 674 |     | <span class='neutral'>            emit VoteCastWithParams(account, proposalId, support, votedWeight, reason, params);</span>
 675 |     | <span class='neutral'>        }</span>
 676 |     | <span class='neutral'></span>
 677 |     | <span class='neutral'>        _tallyUpdated(proposalId);</span>
 678 |     | <span class='neutral'></span>
 679 |     | <span class='neutral'>        return votedWeight;</span>
 680 |     | <span class='neutral'>    }</span>
 681 |     | <span class='neutral'></span>
 682 |     | <span class='neutral'>    /**</span>
 683 |     | <span class='neutral'>     * @dev Relays a transaction or function call to an arbitrary target. In cases where the governance executor</span>
 684 |     | <span class='neutral'>     * is some contract other than the governor itself, like when using a timelock, this function can be invoked</span>
 685 |     | <span class='neutral'>     * in a governance proposal to recover tokens or Ether that was sent to the governor contract by mistake.</span>
 686 |     | <span class='neutral'>     * Note that if the executor is simply the governor itself, use of `relay` is redundant.</span>
 687 |     | <span class='neutral'>     */</span>
 688 |     | <span class='neutral'>    function relay(address target, uint256 value, bytes calldata data) external payable virtual onlyGovernance {</span>
 689 |     | <span class='neutral'>        (bool success, bytes memory returndata) = target.call{value: value}(data);</span>
 690 |     | <span class='neutral'>        Address.verifyCallResult(success, returndata);</span>
 691 |     | <span class='neutral'>    }</span>
 692 |     | <span class='neutral'></span>
 693 |     | <span class='neutral'>    /**</span>
 694 |     | <span class='neutral'>     * @dev Address through which the governor executes action. Will be overloaded by module that execute actions</span>
 695 |     | <span class='neutral'>     * through another contract such as a timelock.</span>
 696 |     | <span class='neutral'>     */</span>
 697 |     | <span class='neutral'>    function _executor() internal view virtual returns (address) {</span>
 698 |     | <span class='neutral'>        return address(this);</span>
 699 |     | <span class='neutral'>    }</span>
 700 |     | <span class='neutral'></span>
 701 |     | <span class='neutral'>    /**</span>
 702 |     | <span class='neutral'>     * @dev See {IERC721Receiver-onERC721Received}.</span>
 703 |     | <span class='neutral'>     * Receiving tokens is disabled if the governance executor is other than the governor itself (eg. when using with a timelock).</span>
 704 |     | <span class='neutral'>     */</span>
 705 |     | <span class='neutral'>    function onERC721Received(address, address, uint256, bytes memory) public virtual returns (bytes4) {</span>
 706 |     | <span class='neutral'>        if (_executor() != address(this)) {</span>
 707 |     | <span class='neutral'>            revert GovernorDisabledDeposit();</span>
 708 |     | <span class='neutral'>        }</span>
 709 |     | <span class='neutral'>        return this.onERC721Received.selector;</span>
 710 |     | <span class='neutral'>    }</span>
 711 |     | <span class='neutral'></span>
 712 |     | <span class='neutral'>    /**</span>
 713 |     | <span class='neutral'>     * @dev See {IERC1155Receiver-onERC1155Received}.</span>
 714 |     | <span class='neutral'>     * Receiving tokens is disabled if the governance executor is other than the governor itself (eg. when using with a timelock).</span>
 715 |     | <span class='neutral'>     */</span>
 716 |     | <span class='neutral'>    function onERC1155Received(address, address, uint256, uint256, bytes memory) public virtual returns (bytes4) {</span>
 717 |     | <span class='neutral'>        if (_executor() != address(this)) {</span>
 718 |     | <span class='neutral'>            revert GovernorDisabledDeposit();</span>
 719 |     | <span class='neutral'>        }</span>
 720 |     | <span class='neutral'>        return this.onERC1155Received.selector;</span>
 721 |     | <span class='neutral'>    }</span>
 722 |     | <span class='neutral'></span>
 723 |     | <span class='neutral'>    /**</span>
 724 |     | <span class='neutral'>     * @dev See {IERC1155Receiver-onERC1155BatchReceived}.</span>
 725 |     | <span class='neutral'>     * Receiving tokens is disabled if the governance executor is other than the governor itself (eg. when using with a timelock).</span>
 726 |     | <span class='neutral'>     */</span>
 727 |     | <span class='neutral'>    function onERC1155BatchReceived(</span>
 728 |     | <span class='neutral'>        address,</span>
 729 |     | <span class='neutral'>        address,</span>
 730 |     | <span class='neutral'>        uint256[] memory,</span>
 731 |     | <span class='neutral'>        uint256[] memory,</span>
 732 |     | <span class='neutral'>        bytes memory</span>
 733 |     | <span class='neutral'>    ) public virtual returns (bytes4) {</span>
 734 |     | <span class='neutral'>        if (_executor() != address(this)) {</span>
 735 |     | <span class='neutral'>            revert GovernorDisabledDeposit();</span>
 736 |     | <span class='neutral'>        }</span>
 737 |     | <span class='neutral'>        return this.onERC1155BatchReceived.selector;</span>
 738 |     | <span class='neutral'>    }</span>
 739 |     | <span class='neutral'></span>
 740 |     | <span class='neutral'>    /**</span>
 741 |     | <span class='neutral'>     * @dev Encodes a `ProposalState` into a `bytes32` representation where each bit enabled corresponds to</span>
 742 |     | <span class='neutral'>     * the underlying position in the `ProposalState` enum. For example:</span>
 743 |     | <span class='neutral'>     *</span>
 744 |     | <span class='neutral'>     * 0x000...10000</span>
 745 |     | <span class='neutral'>     *   ^^^^^^------ ...</span>
 746 |     | <span class='neutral'>     *         ^----- Succeeded</span>
 747 |     | <span class='neutral'>     *          ^---- Defeated</span>
 748 |     | <span class='neutral'>     *           ^--- Canceled</span>
 749 |     | <span class='neutral'>     *            ^-- Active</span>
 750 |     | <span class='neutral'>     *             ^- Pending</span>
 751 |     | <span class='neutral'>     */</span>
 752 |     | <span class='neutral'>    function _encodeStateBitmap(ProposalState proposalState) internal pure returns (bytes32) {</span>
 753 |     | <span class='neutral'>        return bytes32(1 &lt;&lt; uint8(proposalState));</span>
 754 |     | <span class='neutral'>    }</span>
 755 |     | <span class='neutral'></span>
 756 |     | <span class='neutral'>    /**</span>
 757 |     | <span class='neutral'>     * @dev Check that the current state of a proposal matches the requirements described by the `allowedStates` bitmap.</span>
 758 |     | <span class='neutral'>     * This bitmap should be built using `_encodeStateBitmap`.</span>
 759 |     | <span class='neutral'>     *</span>
 760 |     | <span class='neutral'>     * If requirements are not met, reverts with a {GovernorUnexpectedProposalState} error.</span>
 761 |     | <span class='neutral'>     */</span>
 762 |     | <span class='neutral'>    function _validateStateBitmap(uint256 proposalId, bytes32 allowedStates) internal view returns (ProposalState) {</span>
 763 |     | <span class='neutral'>        ProposalState currentState = state(proposalId);</span>
 764 |     | <span class='neutral'>        if (_encodeStateBitmap(currentState) &amp; allowedStates == bytes32(0)) {</span>
 765 |     | <span class='neutral'>            revert GovernorUnexpectedProposalState(proposalId, currentState, allowedStates);</span>
 766 |     | <span class='neutral'>        }</span>
 767 |     | <span class='neutral'>        return currentState;</span>
 768 |     | <span class='neutral'>    }</span>
 769 |     | <span class='neutral'></span>
 770 |     | <span class='neutral'>    /*</span>
 771 |     | <span class='neutral'>     * @dev Check if the proposer is authorized to submit a proposal with the given description.</span>
 772 |     | <span class='neutral'>     *</span>
 773 |     | <span class='neutral'>     * If the proposal description ends with `#proposer=0x???`, where `0x???` is an address written as a hex string</span>
 774 |     | <span class='neutral'>     * (case insensitive), then the submission of this proposal will only be authorized to said address.</span>
 775 |     | <span class='neutral'>     *</span>
 776 |     | <span class='neutral'>     * This is used for frontrunning protection. By adding this pattern at the end of their proposal, one can ensure</span>
 777 |     | <span class='neutral'>     * that no other address can submit the same proposal. An attacker would have to either remove or change that part,</span>
 778 |     | <span class='neutral'>     * which would result in a different proposal id.</span>
 779 |     | <span class='neutral'>     *</span>
 780 |     | <span class='neutral'>     * If the description does not match this pattern, it is unrestricted and anyone can submit it. This includes:</span>
 781 |     | <span class='neutral'>     * - If the `0x???` part is not a valid hex string.</span>
 782 |     | <span class='neutral'>     * - If the `0x???` part is a valid hex string, but does not contain exactly 40 hex digits.</span>
 783 |     | <span class='neutral'>     * - If it ends with the expected suffix followed by newlines or other whitespace.</span>
 784 |     | <span class='neutral'>     * - If it ends with some other similar suffix, e.g. `#other=abc`.</span>
 785 |     | <span class='neutral'>     * - If it does not end with any such suffix.</span>
 786 |     | <span class='neutral'>     */</span>
 787 |     | <span class='neutral'>    function _isValidDescriptionForProposer(</span>
 788 |     | <span class='neutral'>        address proposer,</span>
 789 |     | <span class='neutral'>        string memory description</span>
 790 |     | <span class='neutral'>    ) internal view virtual returns (bool) {</span>
 791 |     | <span class='neutral'>        unchecked {</span>
 792 |     | <span class='neutral'>            uint256 length = bytes(description).length;</span>
 793 |     | <span class='neutral'></span>
 794 |     | <span class='neutral'>            // Length is too short to contain a valid proposer suffix</span>
 795 |     | <span class='neutral'>            if (length &lt; 52) {</span>
 796 |     | <span class='neutral'>                return true;</span>
 797 |     | <span class='neutral'>            }</span>
 798 |     | <span class='neutral'></span>
 799 |     | <span class='neutral'>            // Extract what would be the `#proposer=` marker beginning the suffix</span>
 800 |     | <span class='neutral'>            bytes10 marker = bytes10(_unsafeReadBytesOffset(bytes(description), length - 52));</span>
 801 |     | <span class='neutral'></span>
 802 |     | <span class='neutral'>            // If the marker is not found, there is no proposer suffix to check</span>
 803 |     | <span class='neutral'>            if (marker != bytes10(&quot;#proposer=&quot;)) {</span>
 804 |     | <span class='neutral'>                return true;</span>
 805 |     | <span class='neutral'>            }</span>
 806 |     | <span class='neutral'></span>
 807 |     | <span class='neutral'>            // Check that the last 42 characters (after the marker) are a properly formatted address.</span>
 808 |     | <span class='neutral'>            (bool success, address recovered) = Strings.tryParseAddress(description, length - 42, length);</span>
 809 |     | <span class='neutral'>            return !success || recovered == proposer;</span>
 810 |     | <span class='neutral'>        }</span>
 811 |     | <span class='neutral'>    }</span>
 812 |     | <span class='neutral'></span>
 813 |     | <span class='neutral'>    /**</span>
 814 |     | <span class='neutral'>     * @dev Check if the `caller` can cancel the proposal with the given `proposalId`.</span>
 815 |     | <span class='neutral'>     *</span>
 816 |     | <span class='neutral'>     * The default implementation allows the proposal proposer to cancel the proposal during the pending state.</span>
 817 |     | <span class='neutral'>     */</span>
 818 |     | <span class='neutral'>    function _validateCancel(uint256 proposalId, address caller) internal view virtual returns (bool) {</span>
 819 |     | <span class='neutral'>        return (state(proposalId) == ProposalState.Pending) &amp;&amp; caller == proposalProposer(proposalId);</span>
 820 |     | <span class='neutral'>    }</span>
 821 |     | <span class='neutral'></span>
 822 |     | <span class='neutral'>    /// @inheritdoc IERC6372</span>
 823 |     | <span class='neutral'>    function clock() public view virtual returns (uint48);</span>
 824 |     | <span class='neutral'></span>
 825 |     | <span class='neutral'>    /// @inheritdoc IERC6372</span>
 826 |     | <span class='neutral'>    // solhint-disable-next-line func-name-mixedcase</span>
 827 |     | <span class='neutral'>    function CLOCK_MODE() public view virtual returns (string memory);</span>
 828 |     | <span class='neutral'></span>
 829 |     | <span class='neutral'>    /// @inheritdoc IGovernor</span>
 830 |     | <span class='neutral'>    function votingDelay() public view virtual returns (uint256);</span>
 831 |     | <span class='neutral'></span>
 832 |     | <span class='neutral'>    /// @inheritdoc IGovernor</span>
 833 |     | <span class='neutral'>    function votingPeriod() public view virtual returns (uint256);</span>
 834 |     | <span class='neutral'></span>
 835 |     | <span class='neutral'>    /// @inheritdoc IGovernor</span>
 836 |     | <span class='neutral'>    function quorum(uint256 timepoint) public view virtual returns (uint256);</span>
 837 |     | <span class='neutral'></span>
 838 |     | <span class='neutral'>    /**</span>
 839 |     | <span class='neutral'>     * @dev Reads a bytes32 from a bytes array without bounds checking.</span>
 840 |     | <span class='neutral'>     *</span>
 841 |     | <span class='neutral'>     * NOTE: making this function internal would mean it could be used with memory unsafe offset, and marking the</span>
 842 |     | <span class='neutral'>     * assembly block as such would prevent some optimizations.</span>
 843 |     | <span class='neutral'>     */</span>
 844 |     | <span class='neutral'>    function _unsafeReadBytesOffset(bytes memory buffer, uint256 offset) private pure returns (bytes32 value) {</span>
 845 |     | <span class='neutral'>        // This is not memory safe in the general case, but all calls to this private function are within bounds.</span>
 846 |     | <span class='neutral'>        assembly (&quot;memory-safe&quot;) {</span>
 847 |     | <span class='neutral'>            value := mload(add(add(buffer, 0x20), offset))</span>
 848 |     | <span class='neutral'>        }</span>
 849 |     | <span class='neutral'>    }</span>
 850 |     | <span class='neutral'>}</span>
 851 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/phantom/Documents/azemora/azemora-contracts/lib/openzeppelin-contracts-upgradeable/contracts/governance/TimelockControllerUpgradeable.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'>// OpenZeppelin Contracts (last updated v5.3.0) (governance/TimelockController.sol)</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>pragma solidity ^0.8.20;</span>
   5 |     | <span class='neutral'></span>
   6 |     | <span class='neutral'>import {AccessControlUpgradeable} from &quot;../access/AccessControlUpgradeable.sol&quot;;</span>
   7 |     | <span class='neutral'>import {ERC721HolderUpgradeable} from &quot;../token/ERC721/utils/ERC721HolderUpgradeable.sol&quot;;</span>
   8 |     | <span class='neutral'>import {ERC1155HolderUpgradeable} from &quot;../token/ERC1155/utils/ERC1155HolderUpgradeable.sol&quot;;</span>
   9 |     | <span class='neutral'>import {Address} from &quot;@openzeppelin/contracts/utils/Address.sol&quot;;</span>
  10 |     | <span class='neutral'>import {IERC165} from &quot;@openzeppelin/contracts/utils/introspection/IERC165.sol&quot;;</span>
  11 |     | <span class='neutral'>import {Initializable} from &quot;../proxy/utils/Initializable.sol&quot;;</span>
  12 |     | <span class='neutral'></span>
  13 |     | <span class='neutral'>/**</span>
  14 |     | <span class='neutral'> * @dev Contract module which acts as a timelocked controller. When set as the</span>
  15 |     | <span class='neutral'> * owner of an `Ownable` smart contract, it enforces a timelock on all</span>
  16 |     | <span class='neutral'> * `onlyOwner` maintenance operations. This gives time for users of the</span>
  17 |     | <span class='neutral'> * controlled contract to exit before a potentially dangerous maintenance</span>
  18 |     | <span class='neutral'> * operation is applied.</span>
  19 |     | <span class='neutral'> *</span>
  20 |     | <span class='neutral'> * By default, this contract is self administered, meaning administration tasks</span>
  21 |     | <span class='neutral'> * have to go through the timelock process. The proposer (resp executor) role</span>
  22 |     | <span class='neutral'> * is in charge of proposing (resp executing) operations. A common use case is</span>
  23 |     | <span class='neutral'> * to position this {TimelockController} as the owner of a smart contract, with</span>
  24 |     | <span class='neutral'> * a multisig or a DAO as the sole proposer.</span>
  25 |     | <span class='neutral'> */</span>
  26 |     | <span class='neutral'>contract TimelockControllerUpgradeable is Initializable, AccessControlUpgradeable, ERC721HolderUpgradeable, ERC1155HolderUpgradeable {</span>
  27 |     | <span class='neutral'>    bytes32 public constant PROPOSER_ROLE = keccak256(&quot;PROPOSER_ROLE&quot;);</span>
  28 |     | <span class='neutral'>    bytes32 public constant EXECUTOR_ROLE = keccak256(&quot;EXECUTOR_ROLE&quot;);</span>
  29 |     | <span class='neutral'>    bytes32 public constant CANCELLER_ROLE = keccak256(&quot;CANCELLER_ROLE&quot;);</span>
  30 |     | <span class='neutral'>    uint256 internal constant _DONE_TIMESTAMP = uint256(1);</span>
  31 |     | <span class='neutral'></span>
  32 |     | <span class='neutral'>    /// @custom:storage-location erc7201:openzeppelin.storage.TimelockController</span>
  33 |     | <span class='neutral'>    struct TimelockControllerStorage {</span>
  34 |     | <span class='neutral'>        mapping(bytes32 id =&gt; uint256) _timestamps;</span>
  35 |     | <span class='neutral'>        uint256 _minDelay;</span>
  36 |     | <span class='neutral'>    }</span>
  37 |     | <span class='neutral'></span>
  38 |     | <span class='neutral'>    // keccak256(abi.encode(uint256(keccak256(&quot;openzeppelin.storage.TimelockController&quot;)) - 1)) &amp; ~bytes32(uint256(0xff))</span>
  39 |     | <span class='neutral'>    bytes32 private constant TimelockControllerStorageLocation = 0x9a37c2aa9d186a0969ff8a8267bf4e07e864c2f2768f5040949e28a624fb3600;</span>
  40 |     | <span class='neutral'></span>
  41 |     | <span class='neutral'>    function _getTimelockControllerStorage() private pure returns (TimelockControllerStorage storage $) {</span>
  42 |     | <span class='neutral'>        assembly {</span>
  43 |     | <span class='neutral'>            $.slot := TimelockControllerStorageLocation</span>
  44 |     | <span class='neutral'>        }</span>
  45 |     | <span class='neutral'>    }</span>
  46 |     | <span class='neutral'></span>
  47 |     | <span class='neutral'>    enum OperationState {</span>
  48 |     | <span class='neutral'>        Unset,</span>
  49 |     | <span class='neutral'>        Waiting,</span>
  50 |     | <span class='neutral'>        Ready,</span>
  51 |     | <span class='neutral'>        Done</span>
  52 |     | <span class='neutral'>    }</span>
  53 |     | <span class='neutral'></span>
  54 |     | <span class='neutral'>    /**</span>
  55 |     | <span class='neutral'>     * @dev Mismatch between the parameters length for an operation call.</span>
  56 |     | <span class='neutral'>     */</span>
  57 |     | <span class='neutral'>    error TimelockInvalidOperationLength(uint256 targets, uint256 payloads, uint256 values);</span>
  58 |     | <span class='neutral'></span>
  59 |     | <span class='neutral'>    /**</span>
  60 |     | <span class='neutral'>     * @dev The schedule operation doesn&#39;t meet the minimum delay.</span>
  61 |     | <span class='neutral'>     */</span>
  62 |     | <span class='neutral'>    error TimelockInsufficientDelay(uint256 delay, uint256 minDelay);</span>
  63 |     | <span class='neutral'></span>
  64 |     | <span class='neutral'>    /**</span>
  65 |     | <span class='neutral'>     * @dev The current state of an operation is not as required.</span>
  66 |     | <span class='neutral'>     * The `expectedStates` is a bitmap with the bits enabled for each OperationState enum position</span>
  67 |     | <span class='neutral'>     * counting from right to left.</span>
  68 |     | <span class='neutral'>     *</span>
  69 |     | <span class='neutral'>     * See {_encodeStateBitmap}.</span>
  70 |     | <span class='neutral'>     */</span>
  71 |     | <span class='neutral'>    error TimelockUnexpectedOperationState(bytes32 operationId, bytes32 expectedStates);</span>
  72 |     | <span class='neutral'></span>
  73 |     | <span class='neutral'>    /**</span>
  74 |     | <span class='neutral'>     * @dev The predecessor to an operation not yet done.</span>
  75 |     | <span class='neutral'>     */</span>
  76 |     | <span class='neutral'>    error TimelockUnexecutedPredecessor(bytes32 predecessorId);</span>
  77 |     | <span class='neutral'></span>
  78 |     | <span class='neutral'>    /**</span>
  79 |     | <span class='neutral'>     * @dev The caller account is not authorized.</span>
  80 |     | <span class='neutral'>     */</span>
  81 |     | <span class='neutral'>    error TimelockUnauthorizedCaller(address caller);</span>
  82 |     | <span class='neutral'></span>
  83 |     | <span class='neutral'>    /**</span>
  84 |     | <span class='neutral'>     * @dev Emitted when a call is scheduled as part of operation `id`.</span>
  85 |     | <span class='neutral'>     */</span>
  86 |     | <span class='neutral'>    event CallScheduled(</span>
  87 |     | <span class='neutral'>        bytes32 indexed id,</span>
  88 |     | <span class='neutral'>        uint256 indexed index,</span>
  89 |     | <span class='neutral'>        address target,</span>
  90 |     | <span class='neutral'>        uint256 value,</span>
  91 |     | <span class='neutral'>        bytes data,</span>
  92 |     | <span class='neutral'>        bytes32 predecessor,</span>
  93 |     | <span class='neutral'>        uint256 delay</span>
  94 |     | <span class='neutral'>    );</span>
  95 |     | <span class='neutral'></span>
  96 |     | <span class='neutral'>    /**</span>
  97 |     | <span class='neutral'>     * @dev Emitted when a call is performed as part of operation `id`.</span>
  98 |     | <span class='neutral'>     */</span>
  99 |     | <span class='neutral'>    event CallExecuted(bytes32 indexed id, uint256 indexed index, address target, uint256 value, bytes data);</span>
 100 |     | <span class='neutral'></span>
 101 |     | <span class='neutral'>    /**</span>
 102 |     | <span class='neutral'>     * @dev Emitted when new proposal is scheduled with non-zero salt.</span>
 103 |     | <span class='neutral'>     */</span>
 104 |     | <span class='neutral'>    event CallSalt(bytes32 indexed id, bytes32 salt);</span>
 105 |     | <span class='neutral'></span>
 106 |     | <span class='neutral'>    /**</span>
 107 |     | <span class='neutral'>     * @dev Emitted when operation `id` is cancelled.</span>
 108 |     | <span class='neutral'>     */</span>
 109 |     | <span class='neutral'>    event Cancelled(bytes32 indexed id);</span>
 110 |     | <span class='neutral'></span>
 111 |     | <span class='neutral'>    /**</span>
 112 |     | <span class='neutral'>     * @dev Emitted when the minimum delay for future operations is modified.</span>
 113 |     | <span class='neutral'>     */</span>
 114 |     | <span class='neutral'>    event MinDelayChange(uint256 oldDuration, uint256 newDuration);</span>
 115 |     | <span class='neutral'></span>
 116 |     | <span class='neutral'>    function initialize(uint256 minDelay, address[] memory proposers, address[] memory executors, address admin) public virtual initializer {</span>
 117 |     | <span class='neutral'>        __TimelockController_init(minDelay, proposers, executors, admin);</span>
 118 |     | <span class='neutral'>    }</span>
 119 |     | <span class='neutral'>    /**</span>
 120 |     | <span class='neutral'>     * @dev Initializes the contract with the following parameters:</span>
 121 |     | <span class='neutral'>     *</span>
 122 |     | <span class='neutral'>     * - `minDelay`: initial minimum delay in seconds for operations</span>
 123 |     | <span class='neutral'>     * - `proposers`: accounts to be granted proposer and canceller roles</span>
 124 |     | <span class='neutral'>     * - `executors`: accounts to be granted executor role</span>
 125 |     | <span class='neutral'>     * - `admin`: optional account to be granted admin role; disable with zero address</span>
 126 |     | <span class='neutral'>     *</span>
 127 |     | <span class='neutral'>     * IMPORTANT: The optional admin can aid with initial configuration of roles after deployment</span>
 128 |     | <span class='neutral'>     * without being subject to delay, but this role should be subsequently renounced in favor of</span>
 129 |     | <span class='neutral'>     * administration through timelocked proposals. Previous versions of this contract would assign</span>
 130 |     | <span class='neutral'>     * this admin to the deployer automatically and should be renounced as well.</span>
 131 |     | <span class='neutral'>     */</span>
 132 |     | <span class='neutral'>    function __TimelockController_init(uint256 minDelay, address[] memory proposers, address[] memory executors, address admin) internal onlyInitializing {</span>
 133 |     | <span class='neutral'>        __TimelockController_init_unchained(minDelay, proposers, executors, admin);</span>
 134 |     | <span class='neutral'>    }</span>
 135 |     | <span class='neutral'></span>
 136 |     | <span class='neutral'>    function __TimelockController_init_unchained(uint256 minDelay, address[] memory proposers, address[] memory executors, address admin) internal onlyInitializing {</span>
 137 |     | <span class='neutral'>        TimelockControllerStorage storage $ = _getTimelockControllerStorage();</span>
 138 |     | <span class='neutral'>        // self administration</span>
 139 |     | <span class='neutral'>        _grantRole(DEFAULT_ADMIN_ROLE, address(this));</span>
 140 |     | <span class='neutral'></span>
 141 |     | <span class='neutral'>        // optional admin</span>
 142 |     | <span class='neutral'>        if (admin != address(0)) {</span>
 143 |     | <span class='neutral'>            _grantRole(DEFAULT_ADMIN_ROLE, admin);</span>
 144 |     | <span class='neutral'>        }</span>
 145 |     | <span class='neutral'></span>
 146 |     | <span class='neutral'>        // register proposers and cancellers</span>
 147 |     | <span class='neutral'>        for (uint256 i = 0; i &lt; proposers.length; ++i) {</span>
 148 |     | <span class='neutral'>            _grantRole(PROPOSER_ROLE, proposers[i]);</span>
 149 |     | <span class='neutral'>            _grantRole(CANCELLER_ROLE, proposers[i]);</span>
 150 |     | <span class='neutral'>        }</span>
 151 |     | <span class='neutral'></span>
 152 |     | <span class='neutral'>        // register executors</span>
 153 |     | <span class='neutral'>        for (uint256 i = 0; i &lt; executors.length; ++i) {</span>
 154 |     | <span class='neutral'>            _grantRole(EXECUTOR_ROLE, executors[i]);</span>
 155 |     | <span class='neutral'>        }</span>
 156 |     | <span class='neutral'></span>
 157 |     | <span class='neutral'>        $._minDelay = minDelay;</span>
 158 |     | <span class='neutral'>        emit MinDelayChange(0, minDelay);</span>
 159 |     | <span class='neutral'>    }</span>
 160 |     | <span class='neutral'></span>
 161 |     | <span class='neutral'>    /**</span>
 162 |     | <span class='neutral'>     * @dev Modifier to make a function callable only by a certain role. In</span>
 163 |     | <span class='neutral'>     * addition to checking the sender&#39;s role, `address(0)` &#39;s role is also</span>
 164 |     | <span class='neutral'>     * considered. Granting a role to `address(0)` is equivalent to enabling</span>
 165 |     | <span class='neutral'>     * this role for everyone.</span>
 166 |     | <span class='neutral'>     */</span>
 167 |     | <span class='neutral'>    modifier onlyRoleOrOpenRole(bytes32 role) {</span>
 168 |     | <span class='neutral'>        if (!hasRole(role, address(0))) {</span>
 169 |     | <span class='neutral'>            _checkRole(role, _msgSender());</span>
 170 |     | <span class='neutral'>        }</span>
 171 |     | <span class='neutral'>        _;</span>
 172 |     | <span class='neutral'>    }</span>
 173 |     | <span class='neutral'></span>
 174 |     | <span class='neutral'>    /**</span>
 175 |     | <span class='neutral'>     * @dev Contract might receive/hold ETH as part of the maintenance process.</span>
 176 |     | <span class='neutral'>     */</span>
 177 |     | <span class='neutral'>    receive() external payable virtual {}</span>
 178 |     | <span class='neutral'></span>
 179 |     | <span class='neutral'>    /// @inheritdoc IERC165</span>
 180 |     | <span class='neutral'>    function supportsInterface(</span>
 181 |     | <span class='neutral'>        bytes4 interfaceId</span>
 182 |     | <span class='neutral'>    ) public view virtual override(AccessControlUpgradeable, ERC1155HolderUpgradeable) returns (bool) {</span>
 183 |     | <span class='neutral'>        return super.supportsInterface(interfaceId);</span>
 184 |     | <span class='neutral'>    }</span>
 185 |     | <span class='neutral'></span>
 186 |     | <span class='neutral'>    /**</span>
 187 |     | <span class='neutral'>     * @dev Returns whether an id corresponds to a registered operation. This</span>
 188 |     | <span class='neutral'>     * includes both Waiting, Ready, and Done operations.</span>
 189 |     | <span class='neutral'>     */</span>
 190 |     | <span class='neutral'>    function isOperation(bytes32 id) public view returns (bool) {</span>
 191 |     | <span class='neutral'>        return getOperationState(id) != OperationState.Unset;</span>
 192 |     | <span class='neutral'>    }</span>
 193 |     | <span class='neutral'></span>
 194 |     | <span class='neutral'>    /**</span>
 195 |     | <span class='neutral'>     * @dev Returns whether an operation is pending or not. Note that a &quot;pending&quot; operation may also be &quot;ready&quot;.</span>
 196 |     | <span class='neutral'>     */</span>
 197 |     | <span class='neutral'>    function isOperationPending(bytes32 id) public view returns (bool) {</span>
 198 |     | <span class='neutral'>        OperationState state = getOperationState(id);</span>
 199 |     | <span class='neutral'>        return state == OperationState.Waiting || state == OperationState.Ready;</span>
 200 |     | <span class='neutral'>    }</span>
 201 |     | <span class='neutral'></span>
 202 |     | <span class='neutral'>    /**</span>
 203 |     | <span class='neutral'>     * @dev Returns whether an operation is ready for execution. Note that a &quot;ready&quot; operation is also &quot;pending&quot;.</span>
 204 |     | <span class='neutral'>     */</span>
 205 |     | <span class='neutral'>    function isOperationReady(bytes32 id) public view returns (bool) {</span>
 206 |     | <span class='neutral'>        return getOperationState(id) == OperationState.Ready;</span>
 207 |     | <span class='neutral'>    }</span>
 208 |     | <span class='neutral'></span>
 209 |     | <span class='neutral'>    /**</span>
 210 |     | <span class='neutral'>     * @dev Returns whether an operation is done or not.</span>
 211 |     | <span class='neutral'>     */</span>
 212 |     | <span class='neutral'>    function isOperationDone(bytes32 id) public view returns (bool) {</span>
 213 |     | <span class='neutral'>        return getOperationState(id) == OperationState.Done;</span>
 214 |     | <span class='neutral'>    }</span>
 215 |     | <span class='neutral'></span>
 216 |     | <span class='neutral'>    /**</span>
 217 |     | <span class='neutral'>     * @dev Returns the timestamp at which an operation becomes ready (0 for</span>
 218 |     | <span class='neutral'>     * unset operations, 1 for done operations).</span>
 219 |     | <span class='neutral'>     */</span>
 220 |     | <span class='neutral'>    function getTimestamp(bytes32 id) public view virtual returns (uint256) {</span>
 221 |     | <span class='neutral'>        TimelockControllerStorage storage $ = _getTimelockControllerStorage();</span>
 222 |     | <span class='neutral'>        return $._timestamps[id];</span>
 223 |     | <span class='neutral'>    }</span>
 224 |     | <span class='neutral'></span>
 225 |     | <span class='neutral'>    /**</span>
 226 |     | <span class='neutral'>     * @dev Returns operation state.</span>
 227 |     | <span class='neutral'>     */</span>
 228 |     | <span class='neutral'>    function getOperationState(bytes32 id) public view virtual returns (OperationState) {</span>
 229 |     | <span class='neutral'>        uint256 timestamp = getTimestamp(id);</span>
 230 |     | <span class='neutral'>        if (timestamp == 0) {</span>
 231 |     | <span class='neutral'>            return OperationState.Unset;</span>
 232 |     | <span class='neutral'>        } else if (timestamp == _DONE_TIMESTAMP) {</span>
 233 |     | <span class='neutral'>            return OperationState.Done;</span>
 234 |     | <span class='neutral'>        } else if (timestamp &gt; block.timestamp) {</span>
 235 |     | <span class='neutral'>            return OperationState.Waiting;</span>
 236 |     | <span class='neutral'>        } else {</span>
 237 |     | <span class='neutral'>            return OperationState.Ready;</span>
 238 |     | <span class='neutral'>        }</span>
 239 |     | <span class='neutral'>    }</span>
 240 |     | <span class='neutral'></span>
 241 |     | <span class='neutral'>    /**</span>
 242 |     | <span class='neutral'>     * @dev Returns the minimum delay in seconds for an operation to become valid.</span>
 243 |     | <span class='neutral'>     *</span>
 244 |     | <span class='neutral'>     * This value can be changed by executing an operation that calls `updateDelay`.</span>
 245 |     | <span class='neutral'>     */</span>
 246 |     | <span class='neutral'>    function getMinDelay() public view virtual returns (uint256) {</span>
 247 |     | <span class='neutral'>        TimelockControllerStorage storage $ = _getTimelockControllerStorage();</span>
 248 |     | <span class='neutral'>        return $._minDelay;</span>
 249 |     | <span class='neutral'>    }</span>
 250 |     | <span class='neutral'></span>
 251 |     | <span class='neutral'>    /**</span>
 252 |     | <span class='neutral'>     * @dev Returns the identifier of an operation containing a single</span>
 253 |     | <span class='neutral'>     * transaction.</span>
 254 |     | <span class='neutral'>     */</span>
 255 |     | <span class='neutral'>    function hashOperation(</span>
 256 |     | <span class='neutral'>        address target,</span>
 257 |     | <span class='neutral'>        uint256 value,</span>
 258 |     | <span class='neutral'>        bytes calldata data,</span>
 259 |     | <span class='neutral'>        bytes32 predecessor,</span>
 260 |     | <span class='neutral'>        bytes32 salt</span>
 261 |     | <span class='neutral'>    ) public pure virtual returns (bytes32) {</span>
 262 |     | <span class='neutral'>        return keccak256(abi.encode(target, value, data, predecessor, salt));</span>
 263 |     | <span class='neutral'>    }</span>
 264 |     | <span class='neutral'></span>
 265 |     | <span class='neutral'>    /**</span>
 266 |     | <span class='neutral'>     * @dev Returns the identifier of an operation containing a batch of</span>
 267 |     | <span class='neutral'>     * transactions.</span>
 268 |     | <span class='neutral'>     */</span>
 269 |     | <span class='neutral'>    function hashOperationBatch(</span>
 270 |     | <span class='neutral'>        address[] calldata targets,</span>
 271 |     | <span class='neutral'>        uint256[] calldata values,</span>
 272 |     | <span class='neutral'>        bytes[] calldata payloads,</span>
 273 |     | <span class='neutral'>        bytes32 predecessor,</span>
 274 |     | <span class='neutral'>        bytes32 salt</span>
 275 |     | <span class='neutral'>    ) public pure virtual returns (bytes32) {</span>
 276 |     | <span class='neutral'>        return keccak256(abi.encode(targets, values, payloads, predecessor, salt));</span>
 277 |     | <span class='neutral'>    }</span>
 278 |     | <span class='neutral'></span>
 279 |     | <span class='neutral'>    /**</span>
 280 |     | <span class='neutral'>     * @dev Schedule an operation containing a single transaction.</span>
 281 |     | <span class='neutral'>     *</span>
 282 |     | <span class='neutral'>     * Emits {CallSalt} if salt is nonzero, and {CallScheduled}.</span>
 283 |     | <span class='neutral'>     *</span>
 284 |     | <span class='neutral'>     * Requirements:</span>
 285 |     | <span class='neutral'>     *</span>
 286 |     | <span class='neutral'>     * - the caller must have the &#39;proposer&#39; role.</span>
 287 |     | <span class='neutral'>     */</span>
 288 |     | <span class='neutral'>    function schedule(</span>
 289 |     | <span class='neutral'>        address target,</span>
 290 |     | <span class='neutral'>        uint256 value,</span>
 291 |     | <span class='neutral'>        bytes calldata data,</span>
 292 |     | <span class='neutral'>        bytes32 predecessor,</span>
 293 |     | <span class='neutral'>        bytes32 salt,</span>
 294 |     | <span class='neutral'>        uint256 delay</span>
 295 |     | <span class='neutral'>    ) public virtual onlyRole(PROPOSER_ROLE) {</span>
 296 |     | <span class='neutral'>        bytes32 id = hashOperation(target, value, data, predecessor, salt);</span>
 297 |     | <span class='neutral'>        _schedule(id, delay);</span>
 298 |     | <span class='neutral'>        emit CallScheduled(id, 0, target, value, data, predecessor, delay);</span>
 299 |     | <span class='neutral'>        if (salt != bytes32(0)) {</span>
 300 |     | <span class='neutral'>            emit CallSalt(id, salt);</span>
 301 |     | <span class='neutral'>        }</span>
 302 |     | <span class='neutral'>    }</span>
 303 |     | <span class='neutral'></span>
 304 |     | <span class='neutral'>    /**</span>
 305 |     | <span class='neutral'>     * @dev Schedule an operation containing a batch of transactions.</span>
 306 |     | <span class='neutral'>     *</span>
 307 |     | <span class='neutral'>     * Emits {CallSalt} if salt is nonzero, and one {CallScheduled} event per transaction in the batch.</span>
 308 |     | <span class='neutral'>     *</span>
 309 |     | <span class='neutral'>     * Requirements:</span>
 310 |     | <span class='neutral'>     *</span>
 311 |     | <span class='neutral'>     * - the caller must have the &#39;proposer&#39; role.</span>
 312 |     | <span class='neutral'>     */</span>
 313 |     | <span class='neutral'>    function scheduleBatch(</span>
 314 |     | <span class='neutral'>        address[] calldata targets,</span>
 315 |     | <span class='neutral'>        uint256[] calldata values,</span>
 316 |     | <span class='neutral'>        bytes[] calldata payloads,</span>
 317 |     | <span class='neutral'>        bytes32 predecessor,</span>
 318 |     | <span class='neutral'>        bytes32 salt,</span>
 319 |     | <span class='neutral'>        uint256 delay</span>
 320 |     | <span class='neutral'>    ) public virtual onlyRole(PROPOSER_ROLE) {</span>
 321 |     | <span class='neutral'>        if (targets.length != values.length || targets.length != payloads.length) {</span>
 322 |     | <span class='neutral'>            revert TimelockInvalidOperationLength(targets.length, payloads.length, values.length);</span>
 323 |     | <span class='neutral'>        }</span>
 324 |     | <span class='neutral'></span>
 325 |     | <span class='neutral'>        bytes32 id = hashOperationBatch(targets, values, payloads, predecessor, salt);</span>
 326 |     | <span class='neutral'>        _schedule(id, delay);</span>
 327 |     | <span class='neutral'>        for (uint256 i = 0; i &lt; targets.length; ++i) {</span>
 328 |     | <span class='neutral'>            emit CallScheduled(id, i, targets[i], values[i], payloads[i], predecessor, delay);</span>
 329 |     | <span class='neutral'>        }</span>
 330 |     | <span class='neutral'>        if (salt != bytes32(0)) {</span>
 331 |     | <span class='neutral'>            emit CallSalt(id, salt);</span>
 332 |     | <span class='neutral'>        }</span>
 333 |     | <span class='neutral'>    }</span>
 334 |     | <span class='neutral'></span>
 335 |     | <span class='neutral'>    /**</span>
 336 |     | <span class='neutral'>     * @dev Schedule an operation that is to become valid after a given delay.</span>
 337 |     | <span class='neutral'>     */</span>
 338 |     | <span class='neutral'>    function _schedule(bytes32 id, uint256 delay) private {</span>
 339 |     | <span class='neutral'>        TimelockControllerStorage storage $ = _getTimelockControllerStorage();</span>
 340 |     | <span class='neutral'>        if (isOperation(id)) {</span>
 341 |     | <span class='neutral'>            revert TimelockUnexpectedOperationState(id, _encodeStateBitmap(OperationState.Unset));</span>
 342 |     | <span class='neutral'>        }</span>
 343 |     | <span class='neutral'>        uint256 minDelay = getMinDelay();</span>
 344 |     | <span class='neutral'>        if (delay &lt; minDelay) {</span>
 345 |     | <span class='neutral'>            revert TimelockInsufficientDelay(delay, minDelay);</span>
 346 |     | <span class='neutral'>        }</span>
 347 |     | <span class='neutral'>        $._timestamps[id] = block.timestamp + delay;</span>
 348 |     | <span class='neutral'>    }</span>
 349 |     | <span class='neutral'></span>
 350 |     | <span class='neutral'>    /**</span>
 351 |     | <span class='neutral'>     * @dev Cancel an operation.</span>
 352 |     | <span class='neutral'>     *</span>
 353 |     | <span class='neutral'>     * Requirements:</span>
 354 |     | <span class='neutral'>     *</span>
 355 |     | <span class='neutral'>     * - the caller must have the &#39;canceller&#39; role.</span>
 356 |     | <span class='neutral'>     */</span>
 357 |     | <span class='neutral'>    function cancel(bytes32 id) public virtual onlyRole(CANCELLER_ROLE) {</span>
 358 |     | <span class='neutral'>        TimelockControllerStorage storage $ = _getTimelockControllerStorage();</span>
 359 |     | <span class='neutral'>        if (!isOperationPending(id)) {</span>
 360 |     | <span class='neutral'>            revert TimelockUnexpectedOperationState(</span>
 361 |     | <span class='neutral'>                id,</span>
 362 |     | <span class='neutral'>                _encodeStateBitmap(OperationState.Waiting) | _encodeStateBitmap(OperationState.Ready)</span>
 363 |     | <span class='neutral'>            );</span>
 364 |     | <span class='neutral'>        }</span>
 365 |     | <span class='neutral'>        delete $._timestamps[id];</span>
 366 |     | <span class='neutral'></span>
 367 |     | <span class='neutral'>        emit Cancelled(id);</span>
 368 |     | <span class='neutral'>    }</span>
 369 |     | <span class='neutral'></span>
 370 |     | <span class='neutral'>    /**</span>
 371 |     | <span class='neutral'>     * @dev Execute an (ready) operation containing a single transaction.</span>
 372 |     | <span class='neutral'>     *</span>
 373 |     | <span class='neutral'>     * Emits a {CallExecuted} event.</span>
 374 |     | <span class='neutral'>     *</span>
 375 |     | <span class='neutral'>     * Requirements:</span>
 376 |     | <span class='neutral'>     *</span>
 377 |     | <span class='neutral'>     * - the caller must have the &#39;executor&#39; role.</span>
 378 |     | <span class='neutral'>     */</span>
 379 |     | <span class='neutral'>    // This function can reenter, but it doesn&#39;t pose a risk because _afterCall checks that the proposal is pending,</span>
 380 |     | <span class='neutral'>    // thus any modifications to the operation during reentrancy should be caught.</span>
 381 |     | <span class='neutral'>    // slither-disable-next-line reentrancy-eth</span>
 382 |     | <span class='neutral'>    function execute(</span>
 383 |     | <span class='neutral'>        address target,</span>
 384 |     | <span class='neutral'>        uint256 value,</span>
 385 |     | <span class='neutral'>        bytes calldata payload,</span>
 386 |     | <span class='neutral'>        bytes32 predecessor,</span>
 387 |     | <span class='neutral'>        bytes32 salt</span>
 388 |     | <span class='neutral'>    ) public payable virtual onlyRoleOrOpenRole(EXECUTOR_ROLE) {</span>
 389 |     | <span class='neutral'>        bytes32 id = hashOperation(target, value, payload, predecessor, salt);</span>
 390 |     | <span class='neutral'></span>
 391 |     | <span class='neutral'>        _beforeCall(id, predecessor);</span>
 392 |     | <span class='neutral'>        _execute(target, value, payload);</span>
 393 |     | <span class='neutral'>        emit CallExecuted(id, 0, target, value, payload);</span>
 394 |     | <span class='neutral'>        _afterCall(id);</span>
 395 |     | <span class='neutral'>    }</span>
 396 |     | <span class='neutral'></span>
 397 |     | <span class='neutral'>    /**</span>
 398 |     | <span class='neutral'>     * @dev Execute an (ready) operation containing a batch of transactions.</span>
 399 |     | <span class='neutral'>     *</span>
 400 |     | <span class='neutral'>     * Emits one {CallExecuted} event per transaction in the batch.</span>
 401 |     | <span class='neutral'>     *</span>
 402 |     | <span class='neutral'>     * Requirements:</span>
 403 |     | <span class='neutral'>     *</span>
 404 |     | <span class='neutral'>     * - the caller must have the &#39;executor&#39; role.</span>
 405 |     | <span class='neutral'>     */</span>
 406 |     | <span class='neutral'>    // This function can reenter, but it doesn&#39;t pose a risk because _afterCall checks that the proposal is pending,</span>
 407 |     | <span class='neutral'>    // thus any modifications to the operation during reentrancy should be caught.</span>
 408 |     | <span class='neutral'>    // slither-disable-next-line reentrancy-eth</span>
 409 |     | <span class='neutral'>    function executeBatch(</span>
 410 |     | <span class='neutral'>        address[] calldata targets,</span>
 411 |     | <span class='neutral'>        uint256[] calldata values,</span>
 412 |     | <span class='neutral'>        bytes[] calldata payloads,</span>
 413 |     | <span class='neutral'>        bytes32 predecessor,</span>
 414 |     | <span class='neutral'>        bytes32 salt</span>
 415 |     | <span class='neutral'>    ) public payable virtual onlyRoleOrOpenRole(EXECUTOR_ROLE) {</span>
 416 |     | <span class='neutral'>        if (targets.length != values.length || targets.length != payloads.length) {</span>
 417 |     | <span class='neutral'>            revert TimelockInvalidOperationLength(targets.length, payloads.length, values.length);</span>
 418 |     | <span class='neutral'>        }</span>
 419 |     | <span class='neutral'></span>
 420 |     | <span class='neutral'>        bytes32 id = hashOperationBatch(targets, values, payloads, predecessor, salt);</span>
 421 |     | <span class='neutral'></span>
 422 |     | <span class='neutral'>        _beforeCall(id, predecessor);</span>
 423 |     | <span class='neutral'>        for (uint256 i = 0; i &lt; targets.length; ++i) {</span>
 424 |     | <span class='neutral'>            address target = targets[i];</span>
 425 |     | <span class='neutral'>            uint256 value = values[i];</span>
 426 |     | <span class='neutral'>            bytes calldata payload = payloads[i];</span>
 427 |     | <span class='neutral'>            _execute(target, value, payload);</span>
 428 |     | <span class='neutral'>            emit CallExecuted(id, i, target, value, payload);</span>
 429 |     | <span class='neutral'>        }</span>
 430 |     | <span class='neutral'>        _afterCall(id);</span>
 431 |     | <span class='neutral'>    }</span>
 432 |     | <span class='neutral'></span>
 433 |     | <span class='neutral'>    /**</span>
 434 |     | <span class='neutral'>     * @dev Execute an operation&#39;s call.</span>
 435 |     | <span class='neutral'>     */</span>
 436 |     | <span class='neutral'>    function _execute(address target, uint256 value, bytes calldata data) internal virtual {</span>
 437 |     | <span class='neutral'>        (bool success, bytes memory returndata) = target.call{value: value}(data);</span>
 438 |     | <span class='neutral'>        Address.verifyCallResult(success, returndata);</span>
 439 |     | <span class='neutral'>    }</span>
 440 |     | <span class='neutral'></span>
 441 |     | <span class='neutral'>    /**</span>
 442 |     | <span class='neutral'>     * @dev Checks before execution of an operation&#39;s calls.</span>
 443 |     | <span class='neutral'>     */</span>
 444 |     | <span class='neutral'>    function _beforeCall(bytes32 id, bytes32 predecessor) private view {</span>
 445 |     | <span class='neutral'>        if (!isOperationReady(id)) {</span>
 446 |     | <span class='neutral'>            revert TimelockUnexpectedOperationState(id, _encodeStateBitmap(OperationState.Ready));</span>
 447 |     | <span class='neutral'>        }</span>
 448 |     | <span class='neutral'>        if (predecessor != bytes32(0) &amp;&amp; !isOperationDone(predecessor)) {</span>
 449 |     | <span class='neutral'>            revert TimelockUnexecutedPredecessor(predecessor);</span>
 450 |     | <span class='neutral'>        }</span>
 451 |     | <span class='neutral'>    }</span>
 452 |     | <span class='neutral'></span>
 453 |     | <span class='neutral'>    /**</span>
 454 |     | <span class='neutral'>     * @dev Checks after execution of an operation&#39;s calls.</span>
 455 |     | <span class='neutral'>     */</span>
 456 |     | <span class='neutral'>    function _afterCall(bytes32 id) private {</span>
 457 |     | <span class='neutral'>        TimelockControllerStorage storage $ = _getTimelockControllerStorage();</span>
 458 |     | <span class='neutral'>        if (!isOperationReady(id)) {</span>
 459 |     | <span class='neutral'>            revert TimelockUnexpectedOperationState(id, _encodeStateBitmap(OperationState.Ready));</span>
 460 |     | <span class='neutral'>        }</span>
 461 |     | <span class='neutral'>        $._timestamps[id] = _DONE_TIMESTAMP;</span>
 462 |     | <span class='neutral'>    }</span>
 463 |     | <span class='neutral'></span>
 464 |     | <span class='neutral'>    /**</span>
 465 |     | <span class='neutral'>     * @dev Changes the minimum timelock duration for future operations.</span>
 466 |     | <span class='neutral'>     *</span>
 467 |     | <span class='neutral'>     * Emits a {MinDelayChange} event.</span>
 468 |     | <span class='neutral'>     *</span>
 469 |     | <span class='neutral'>     * Requirements:</span>
 470 |     | <span class='neutral'>     *</span>
 471 |     | <span class='neutral'>     * - the caller must be the timelock itself. This can only be achieved by scheduling and later executing</span>
 472 |     | <span class='neutral'>     * an operation where the timelock is the target and the data is the ABI-encoded call to this function.</span>
 473 |     | <span class='neutral'>     */</span>
 474 |     | <span class='neutral'>    function updateDelay(uint256 newDelay) external virtual {</span>
 475 |     | <span class='neutral'>        TimelockControllerStorage storage $ = _getTimelockControllerStorage();</span>
 476 |     | <span class='neutral'>        address sender = _msgSender();</span>
 477 |     | <span class='neutral'>        if (sender != address(this)) {</span>
 478 |     | <span class='neutral'>            revert TimelockUnauthorizedCaller(sender);</span>
 479 |     | <span class='neutral'>        }</span>
 480 |     | <span class='neutral'>        emit MinDelayChange($._minDelay, newDelay);</span>
 481 |     | <span class='neutral'>        $._minDelay = newDelay;</span>
 482 |     | <span class='neutral'>    }</span>
 483 |     | <span class='neutral'></span>
 484 |     | <span class='neutral'>    /**</span>
 485 |     | <span class='neutral'>     * @dev Encodes a `OperationState` into a `bytes32` representation where each bit enabled corresponds to</span>
 486 |     | <span class='neutral'>     * the underlying position in the `OperationState` enum. For example:</span>
 487 |     | <span class='neutral'>     *</span>
 488 |     | <span class='neutral'>     * 0x000...1000</span>
 489 |     | <span class='neutral'>     *   ^^^^^^----- ...</span>
 490 |     | <span class='neutral'>     *         ^---- Done</span>
 491 |     | <span class='neutral'>     *          ^--- Ready</span>
 492 |     | <span class='neutral'>     *           ^-- Waiting</span>
 493 |     | <span class='neutral'>     *            ^- Unset</span>
 494 |     | <span class='neutral'>     */</span>
 495 |     | <span class='neutral'>    function _encodeStateBitmap(OperationState operationState) internal pure returns (bytes32) {</span>
 496 |     | <span class='neutral'>        return bytes32(1 &lt;&lt; uint8(operationState));</span>
 497 |     | <span class='neutral'>    }</span>
 498 |     | <span class='neutral'>}</span>
 499 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/phantom/Documents/azemora/azemora-contracts/lib/openzeppelin-contracts-upgradeable/contracts/governance/extensions/GovernorCountingSimpleUpgradeable.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'>// OpenZeppelin Contracts (last updated v5.1.0) (governance/extensions/GovernorCountingSimple.sol)</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>pragma solidity ^0.8.24;</span>
   5 |     | <span class='neutral'></span>
   6 |     | <span class='unexecuted'>import {IGovernor} from &quot;@openzeppelin/contracts/governance/IGovernor.sol&quot;;</span>
   7 |     | <span class='neutral'>import {GovernorUpgradeable} from &quot;../GovernorUpgradeable.sol&quot;;</span>
   8 |     | <span class='neutral'>import {Initializable} from &quot;../../proxy/utils/Initializable.sol&quot;;</span>
   9 |     | <span class='neutral'></span>
  10 |     | <span class='neutral'>/**</span>
  11 |     | <span class='neutral'> * @dev Extension of {Governor} for simple, 3 options, vote counting.</span>
  12 |     | <span class='neutral'> */</span>
  13 |     | <span class='neutral'>abstract contract GovernorCountingSimpleUpgradeable is Initializable, GovernorUpgradeable {</span>
  14 |     | <span class='neutral'>    /**</span>
  15 |     | <span class='neutral'>     * @dev Supported vote types. Matches Governor Bravo ordering.</span>
  16 |     | <span class='neutral'>     */</span>
  17 |     | <span class='neutral'>    enum VoteType {</span>
  18 |     | <span class='neutral'>        Against,</span>
  19 |     | <span class='neutral'>        For,</span>
  20 |     | <span class='neutral'>        Abstain</span>
  21 |     | <span class='neutral'>    }</span>
  22 |     | <span class='neutral'></span>
  23 |     | <span class='neutral'>    struct ProposalVote {</span>
  24 |     | <span class='neutral'>        uint256 againstVotes;</span>
  25 |     | <span class='neutral'>        uint256 forVotes;</span>
  26 |     | <span class='neutral'>        uint256 abstainVotes;</span>
  27 |     | <span class='neutral'>        mapping(address voter =&gt; bool) hasVoted;</span>
  28 |     | <span class='neutral'>    }</span>
  29 |     | <span class='neutral'></span>
  30 |     | <span class='neutral'>    /// @custom:storage-location erc7201:openzeppelin.storage.GovernorCountingSimple</span>
  31 |     | <span class='neutral'>    struct GovernorCountingSimpleStorage {</span>
  32 |     | <span class='neutral'>        mapping(uint256 proposalId =&gt; ProposalVote) _proposalVotes;</span>
  33 |     | <span class='neutral'>    }</span>
  34 |     | <span class='neutral'></span>
  35 |     | <span class='neutral'>    // keccak256(abi.encode(uint256(keccak256(&quot;openzeppelin.storage.GovernorCountingSimple&quot;)) - 1)) &amp; ~bytes32(uint256(0xff))</span>
  36 |     | <span class='neutral'>    bytes32 private constant GovernorCountingSimpleStorageLocation = 0xa1cefa0f43667ef127a258e673c94202a79b656e62899531c4376d87a7f39800;</span>
  37 |     | <span class='neutral'></span>
  38 |     | <span class='neutral'>    function _getGovernorCountingSimpleStorage() private pure returns (GovernorCountingSimpleStorage storage $) {</span>
  39 |     | <span class='neutral'>        assembly {</span>
  40 |     | <span class='neutral'>            $.slot := GovernorCountingSimpleStorageLocation</span>
  41 |     | <span class='neutral'>        }</span>
  42 |     | <span class='neutral'>    }</span>
  43 |     | <span class='neutral'></span>
  44 |     | <span class='neutral'>    function __GovernorCountingSimple_init() internal onlyInitializing {</span>
  45 |     | <span class='neutral'>    }</span>
  46 |     | <span class='neutral'></span>
  47 |     | <span class='neutral'>    function __GovernorCountingSimple_init_unchained() internal onlyInitializing {</span>
  48 |     | <span class='neutral'>    }</span>
  49 |     | <span class='neutral'>    /// @inheritdoc IGovernor</span>
  50 |     | <span class='neutral'>    // solhint-disable-next-line func-name-mixedcase</span>
  51 |     | <span class='neutral'>    function COUNTING_MODE() public pure virtual override returns (string memory) {</span>
  52 |     | <span class='neutral'>        return &quot;support=bravo&amp;quorum=for,abstain&quot;;</span>
  53 |     | <span class='neutral'>    }</span>
  54 |     | <span class='neutral'></span>
  55 |     | <span class='neutral'>    /// @inheritdoc IGovernor</span>
  56 |     | <span class='neutral'>    function hasVoted(uint256 proposalId, address account) public view virtual override returns (bool) {</span>
  57 |     | <span class='neutral'>        GovernorCountingSimpleStorage storage $ = _getGovernorCountingSimpleStorage();</span>
  58 |     | <span class='neutral'>        return $._proposalVotes[proposalId].hasVoted[account];</span>
  59 |     | <span class='neutral'>    }</span>
  60 |     | <span class='neutral'></span>
  61 |     | <span class='neutral'>    /**</span>
  62 |     | <span class='neutral'>     * @dev Accessor to the internal vote counts.</span>
  63 |     | <span class='neutral'>     */</span>
  64 |     | <span class='neutral'>    function proposalVotes(</span>
  65 |     | <span class='neutral'>        uint256 proposalId</span>
  66 |     | <span class='neutral'>    ) public view virtual returns (uint256 againstVotes, uint256 forVotes, uint256 abstainVotes) {</span>
  67 |     | <span class='neutral'>        GovernorCountingSimpleStorage storage $ = _getGovernorCountingSimpleStorage();</span>
  68 |     | <span class='neutral'>        ProposalVote storage proposalVote = $._proposalVotes[proposalId];</span>
  69 |     | <span class='neutral'>        return (proposalVote.againstVotes, proposalVote.forVotes, proposalVote.abstainVotes);</span>
  70 |     | <span class='neutral'>    }</span>
  71 |     | <span class='neutral'></span>
  72 |     | <span class='neutral'>    /// @inheritdoc GovernorUpgradeable</span>
  73 |     | <span class='neutral'>    function _quorumReached(uint256 proposalId) internal view virtual override returns (bool) {</span>
  74 |     | <span class='neutral'>        GovernorCountingSimpleStorage storage $ = _getGovernorCountingSimpleStorage();</span>
  75 |     | <span class='neutral'>        ProposalVote storage proposalVote = $._proposalVotes[proposalId];</span>
  76 |     | <span class='neutral'></span>
  77 |     | <span class='neutral'>        return quorum(proposalSnapshot(proposalId)) &lt;= proposalVote.forVotes + proposalVote.abstainVotes;</span>
  78 |     | <span class='neutral'>    }</span>
  79 |     | <span class='neutral'></span>
  80 |     | <span class='neutral'>    /**</span>
  81 |     | <span class='neutral'>     * @dev See {Governor-_voteSucceeded}. In this module, the forVotes must be strictly over the againstVotes.</span>
  82 |     | <span class='neutral'>     */</span>
  83 |     | <span class='neutral'>    function _voteSucceeded(uint256 proposalId) internal view virtual override returns (bool) {</span>
  84 |     | <span class='neutral'>        GovernorCountingSimpleStorage storage $ = _getGovernorCountingSimpleStorage();</span>
  85 |     | <span class='neutral'>        ProposalVote storage proposalVote = $._proposalVotes[proposalId];</span>
  86 |     | <span class='neutral'></span>
  87 |     | <span class='neutral'>        return proposalVote.forVotes &gt; proposalVote.againstVotes;</span>
  88 |     | <span class='neutral'>    }</span>
  89 |     | <span class='neutral'></span>
  90 |     | <span class='neutral'>    /**</span>
  91 |     | <span class='neutral'>     * @dev See {Governor-_countVote}. In this module, the support follows the `VoteType` enum (from Governor Bravo).</span>
  92 |     | <span class='neutral'>     */</span>
  93 |     | <span class='neutral'>    function _countVote(</span>
  94 |     | <span class='neutral'>        uint256 proposalId,</span>
  95 |     | <span class='neutral'>        address account,</span>
  96 |     | <span class='neutral'>        uint8 support,</span>
  97 |     | <span class='neutral'>        uint256 totalWeight,</span>
  98 |     | <span class='neutral'>        bytes memory // params</span>
  99 | *   | <span class='executed'>    ) internal virtual override returns (uint256) {</span>
 100 | *   | <span class='executed'>        GovernorCountingSimpleStorage storage $ = _getGovernorCountingSimpleStorage();</span>
 101 | *   | <span class='executed'>        ProposalVote storage proposalVote = $._proposalVotes[proposalId];</span>
 102 |     | <span class='neutral'></span>
 103 | *   | <span class='executed'>        if (proposalVote.hasVoted[account]) {</span>
 104 | *   | <span class='executed'>            revert GovernorAlreadyCastVote(account);</span>
 105 |     | <span class='neutral'>        }</span>
 106 |     | <span class='neutral'>        proposalVote.hasVoted[account] = true;</span>
 107 |     | <span class='neutral'></span>
 108 |     | <span class='neutral'>        if (support == uint8(VoteType.Against)) {</span>
 109 |     | <span class='neutral'>            proposalVote.againstVotes += totalWeight;</span>
 110 |     | <span class='neutral'>        } else if (support == uint8(VoteType.For)) {</span>
 111 | *   | <span class='executed'>            proposalVote.forVotes += totalWeight;</span>
 112 |     | <span class='neutral'>        } else if (support == uint8(VoteType.Abstain)) {</span>
 113 |     | <span class='neutral'>            proposalVote.abstainVotes += totalWeight;</span>
 114 |     | <span class='neutral'>        } else {</span>
 115 | *   | <span class='executed'>            revert GovernorInvalidVoteType();</span>
 116 |     | <span class='neutral'>        }</span>
 117 |     | <span class='neutral'></span>
 118 |     | <span class='unexecuted'>        return totalWeight;</span>
 119 |     | <span class='neutral'>    }</span>
 120 |     | <span class='neutral'>}</span>
 121 | *   | <span class='executed'></span>

</code>
<br />

<b>/home/phantom/Documents/azemora/azemora-contracts/lib/openzeppelin-contracts-upgradeable/contracts/governance/extensions/GovernorSettingsUpgradeable.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'>// OpenZeppelin Contracts (last updated v5.0.0) (governance/extensions/GovernorSettings.sol)</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>pragma solidity ^0.8.24;</span>
   5 |     | <span class='neutral'></span>
   6 |     | <span class='neutral'>import {IGovernor} from &quot;@openzeppelin/contracts/governance/IGovernor.sol&quot;;</span>
   7 |     | <span class='neutral'>import {GovernorUpgradeable} from &quot;../GovernorUpgradeable.sol&quot;;</span>
   8 |     | <span class='neutral'>import {Initializable} from &quot;../../proxy/utils/Initializable.sol&quot;;</span>
   9 |     | <span class='neutral'></span>
  10 |     | <span class='neutral'>/**</span>
  11 |     | <span class='neutral'> * @dev Extension of {Governor} for settings updatable through governance.</span>
  12 |     | <span class='neutral'> */</span>
  13 |     | <span class='unexecuted'>abstract contract GovernorSettingsUpgradeable is Initializable, GovernorUpgradeable {</span>
  14 |     | <span class='neutral'>    /// @custom:storage-location erc7201:openzeppelin.storage.GovernorSettings</span>
  15 |     | <span class='neutral'>    struct GovernorSettingsStorage {</span>
  16 |     | <span class='neutral'>        // amount of token</span>
  17 |     | <span class='neutral'>        uint256 _proposalThreshold;</span>
  18 |     | <span class='neutral'>        // timepoint: limited to uint48 in core (same as clock() type)</span>
  19 |     | <span class='neutral'>        uint48 _votingDelay;</span>
  20 |     | <span class='neutral'>        // duration: limited to uint32 in core</span>
  21 |     | <span class='neutral'>        uint32 _votingPeriod;</span>
  22 |     | <span class='neutral'>    }</span>
  23 |     | <span class='neutral'></span>
  24 |     | <span class='neutral'>    // keccak256(abi.encode(uint256(keccak256(&quot;openzeppelin.storage.GovernorSettings&quot;)) - 1)) &amp; ~bytes32(uint256(0xff))</span>
  25 |     | <span class='neutral'>    bytes32 private constant GovernorSettingsStorageLocation = 0x00d7616c8fe29c6c2fbe1d0c5bc8f2faa4c35b43746e70b24b4d532752affd00;</span>
  26 |     | <span class='neutral'></span>
  27 |     | <span class='neutral'>    function _getGovernorSettingsStorage() private pure returns (GovernorSettingsStorage storage $) {</span>
  28 |     | <span class='neutral'>        assembly {</span>
  29 |     | <span class='neutral'>            $.slot := GovernorSettingsStorageLocation</span>
  30 |     | <span class='neutral'>        }</span>
  31 |     | <span class='neutral'>    }</span>
  32 |     | <span class='neutral'></span>
  33 |     | <span class='neutral'>    event VotingDelaySet(uint256 oldVotingDelay, uint256 newVotingDelay);</span>
  34 |     | <span class='neutral'>    event VotingPeriodSet(uint256 oldVotingPeriod, uint256 newVotingPeriod);</span>
  35 |     | <span class='neutral'>    event ProposalThresholdSet(uint256 oldProposalThreshold, uint256 newProposalThreshold);</span>
  36 |     | <span class='neutral'></span>
  37 |     | <span class='neutral'>    /**</span>
  38 |     | <span class='neutral'>     * @dev Initialize the governance parameters.</span>
  39 |     | <span class='neutral'>     */</span>
  40 |     | <span class='neutral'>    function __GovernorSettings_init(uint48 initialVotingDelay, uint32 initialVotingPeriod, uint256 initialProposalThreshold) internal onlyInitializing {</span>
  41 |     | <span class='neutral'>        __GovernorSettings_init_unchained(initialVotingDelay, initialVotingPeriod, initialProposalThreshold);</span>
  42 |     | <span class='neutral'>    }</span>
  43 |     | <span class='neutral'></span>
  44 |     | <span class='neutral'>    function __GovernorSettings_init_unchained(uint48 initialVotingDelay, uint32 initialVotingPeriod, uint256 initialProposalThreshold) internal onlyInitializing {</span>
  45 |     | <span class='neutral'>        _setVotingDelay(initialVotingDelay);</span>
  46 |     | <span class='neutral'>        _setVotingPeriod(initialVotingPeriod);</span>
  47 |     | <span class='neutral'>        _setProposalThreshold(initialProposalThreshold);</span>
  48 |     | <span class='neutral'>    }</span>
  49 |     | <span class='neutral'></span>
  50 |     | <span class='neutral'>    /// @inheritdoc IGovernor</span>
  51 |     | <span class='neutral'>    function votingDelay() public view virtual override returns (uint256) {</span>
  52 |     | <span class='neutral'>        GovernorSettingsStorage storage $ = _getGovernorSettingsStorage();</span>
  53 |     | <span class='neutral'>        return $._votingDelay;</span>
  54 |     | <span class='neutral'>    }</span>
  55 |     | <span class='neutral'></span>
  56 |     | <span class='neutral'>    /// @inheritdoc IGovernor</span>
  57 |     | <span class='neutral'>    function votingPeriod() public view virtual override returns (uint256) {</span>
  58 |     | <span class='neutral'>        GovernorSettingsStorage storage $ = _getGovernorSettingsStorage();</span>
  59 |     | <span class='neutral'>        return $._votingPeriod;</span>
  60 |     | <span class='neutral'>    }</span>
  61 |     | <span class='neutral'></span>
  62 |     | <span class='neutral'>    /// @inheritdoc GovernorUpgradeable</span>
  63 |     | <span class='neutral'>    function proposalThreshold() public view virtual override returns (uint256) {</span>
  64 |     | <span class='neutral'>        GovernorSettingsStorage storage $ = _getGovernorSettingsStorage();</span>
  65 |     | <span class='neutral'>        return $._proposalThreshold;</span>
  66 |     | <span class='neutral'>    }</span>
  67 |     | <span class='neutral'></span>
  68 |     | <span class='neutral'>    /**</span>
  69 |     | <span class='neutral'>     * @dev Update the voting delay. This operation can only be performed through a governance proposal.</span>
  70 |     | <span class='neutral'>     *</span>
  71 |     | <span class='neutral'>     * Emits a {VotingDelaySet} event.</span>
  72 |     | <span class='neutral'>     */</span>
  73 |     | <span class='neutral'>    function setVotingDelay(uint48 newVotingDelay) public virtual onlyGovernance {</span>
  74 |     | <span class='neutral'>        _setVotingDelay(newVotingDelay);</span>
  75 |     | <span class='neutral'>    }</span>
  76 |     | <span class='neutral'></span>
  77 |     | <span class='neutral'>    /**</span>
  78 |     | <span class='neutral'>     * @dev Update the voting period. This operation can only be performed through a governance proposal.</span>
  79 |     | <span class='neutral'>     *</span>
  80 |     | <span class='neutral'>     * Emits a {VotingPeriodSet} event.</span>
  81 |     | <span class='neutral'>     */</span>
  82 |     | <span class='neutral'>    function setVotingPeriod(uint32 newVotingPeriod) public virtual onlyGovernance {</span>
  83 |     | <span class='neutral'>        _setVotingPeriod(newVotingPeriod);</span>
  84 |     | <span class='neutral'>    }</span>
  85 |     | <span class='neutral'></span>
  86 |     | <span class='neutral'>    /**</span>
  87 |     | <span class='neutral'>     * @dev Update the proposal threshold. This operation can only be performed through a governance proposal.</span>
  88 |     | <span class='neutral'>     *</span>
  89 |     | <span class='neutral'>     * Emits a {ProposalThresholdSet} event.</span>
  90 |     | <span class='neutral'>     */</span>
  91 |     | <span class='neutral'>    function setProposalThreshold(uint256 newProposalThreshold) public virtual onlyGovernance {</span>
  92 |     | <span class='neutral'>        _setProposalThreshold(newProposalThreshold);</span>
  93 |     | <span class='neutral'>    }</span>
  94 |     | <span class='neutral'></span>
  95 |     | <span class='neutral'>    /**</span>
  96 |     | <span class='neutral'>     * @dev Internal setter for the voting delay.</span>
  97 |     | <span class='neutral'>     *</span>
  98 |     | <span class='neutral'>     * Emits a {VotingDelaySet} event.</span>
  99 |     | <span class='neutral'>     */</span>
 100 |     | <span class='neutral'>    function _setVotingDelay(uint48 newVotingDelay) internal virtual {</span>
 101 |     | <span class='neutral'>        GovernorSettingsStorage storage $ = _getGovernorSettingsStorage();</span>
 102 |     | <span class='neutral'>        emit VotingDelaySet($._votingDelay, newVotingDelay);</span>
 103 |     | <span class='neutral'>        $._votingDelay = newVotingDelay;</span>
 104 |     | <span class='neutral'>    }</span>
 105 |     | <span class='neutral'></span>
 106 |     | <span class='neutral'>    /**</span>
 107 |     | <span class='neutral'>     * @dev Internal setter for the voting period.</span>
 108 |     | <span class='neutral'>     *</span>
 109 |     | <span class='neutral'>     * Emits a {VotingPeriodSet} event.</span>
 110 |     | <span class='neutral'>     */</span>
 111 |     | <span class='neutral'>    function _setVotingPeriod(uint32 newVotingPeriod) internal virtual {</span>
 112 |     | <span class='neutral'>        GovernorSettingsStorage storage $ = _getGovernorSettingsStorage();</span>
 113 |     | <span class='neutral'>        if (newVotingPeriod == 0) {</span>
 114 |     | <span class='neutral'>            revert GovernorInvalidVotingPeriod(0);</span>
 115 |     | <span class='neutral'>        }</span>
 116 |     | <span class='neutral'>        emit VotingPeriodSet($._votingPeriod, newVotingPeriod);</span>
 117 |     | <span class='neutral'>        $._votingPeriod = newVotingPeriod;</span>
 118 |     | <span class='neutral'>    }</span>
 119 |     | <span class='neutral'></span>
 120 |     | <span class='neutral'>    /**</span>
 121 |     | <span class='neutral'>     * @dev Internal setter for the proposal threshold.</span>
 122 |     | <span class='neutral'>     *</span>
 123 |     | <span class='neutral'>     * Emits a {ProposalThresholdSet} event.</span>
 124 |     | <span class='neutral'>     */</span>
 125 |     | <span class='neutral'>    function _setProposalThreshold(uint256 newProposalThreshold) internal virtual {</span>
 126 |     | <span class='neutral'>        GovernorSettingsStorage storage $ = _getGovernorSettingsStorage();</span>
 127 |     | <span class='neutral'>        emit ProposalThresholdSet($._proposalThreshold, newProposalThreshold);</span>
 128 |     | <span class='neutral'>        $._proposalThreshold = newProposalThreshold;</span>
 129 |     | <span class='neutral'>    }</span>
 130 |     | <span class='neutral'>}</span>
 131 | *   | <span class='executed'></span>

</code>
<br />

<b>/home/phantom/Documents/azemora/azemora-contracts/lib/openzeppelin-contracts-upgradeable/contracts/governance/extensions/GovernorTimelockControlUpgradeable.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'>// OpenZeppelin Contracts (last updated v5.3.0) (governance/extensions/GovernorTimelockControl.sol)</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>pragma solidity ^0.8.24;</span>
   5 |     | <span class='neutral'></span>
   6 |     | <span class='unexecuted'>import {IGovernor} from &quot;@openzeppelin/contracts/governance/IGovernor.sol&quot;;</span>
   7 |     | <span class='neutral'>import {GovernorUpgradeable} from &quot;../GovernorUpgradeable.sol&quot;;</span>
   8 |     | <span class='neutral'>import {TimelockControllerUpgradeable} from &quot;../TimelockControllerUpgradeable.sol&quot;;</span>
   9 |     | <span class='neutral'>import {SafeCast} from &quot;@openzeppelin/contracts/utils/math/SafeCast.sol&quot;;</span>
  10 |     | <span class='neutral'>import {Initializable} from &quot;../../proxy/utils/Initializable.sol&quot;;</span>
  11 |     | <span class='neutral'></span>
  12 |     | <span class='neutral'>/**</span>
  13 |     | <span class='neutral'> * @dev Extension of {Governor} that binds the execution process to an instance of {TimelockController}. This adds a</span>
  14 |     | <span class='neutral'> * delay, enforced by the {TimelockController} to all successful proposal (in addition to the voting duration). The</span>
  15 |     | <span class='neutral'> * {Governor} needs the proposer (and ideally the executor and canceller) roles for the {Governor} to work properly.</span>
  16 |     | <span class='neutral'> *</span>
  17 |     | <span class='neutral'> * Using this model means the proposal will be operated by the {TimelockController} and not by the {Governor}. Thus,</span>
  18 |     | <span class='neutral'> * the assets and permissions must be attached to the {TimelockController}. Any asset sent to the {Governor} will be</span>
  19 |     | <span class='neutral'> * inaccessible from a proposal, unless executed via {Governor-relay}.</span>
  20 |     | <span class='neutral'> *</span>
  21 |     | <span class='neutral'> * WARNING: Setting up the TimelockController to have additional proposers or cancelers besides the governor is very</span>
  22 |     | <span class='neutral'> * risky, as it grants them the ability to: 1) execute operations as the timelock, and thus possibly performing</span>
  23 |     | <span class='neutral'> * operations or accessing funds that are expected to only be accessible through a vote, and 2) block governance</span>
  24 |     | <span class='neutral'> * proposals that have been approved by the voters, effectively executing a Denial of Service attack.</span>
  25 |     | <span class='neutral'> */</span>
  26 |     | <span class='neutral'>abstract contract GovernorTimelockControlUpgradeable is Initializable, GovernorUpgradeable {</span>
  27 |     | <span class='neutral'>    /// @custom:storage-location erc7201:openzeppelin.storage.GovernorTimelockControl</span>
  28 |     | <span class='neutral'>    struct GovernorTimelockControlStorage {</span>
  29 |     | <span class='neutral'>        TimelockControllerUpgradeable _timelock;</span>
  30 |     | <span class='neutral'>        mapping(uint256 proposalId =&gt; bytes32) _timelockIds;</span>
  31 |     | <span class='neutral'>    }</span>
  32 |     | <span class='neutral'></span>
  33 |     | <span class='neutral'>    // keccak256(abi.encode(uint256(keccak256(&quot;openzeppelin.storage.GovernorTimelockControl&quot;)) - 1)) &amp; ~bytes32(uint256(0xff))</span>
  34 |     | <span class='neutral'>    bytes32 private constant GovernorTimelockControlStorageLocation = 0x0d5829787b8befdbc6044ef7457d8a95c2a04bc99235349f1a212c063e59d400;</span>
  35 |     | <span class='neutral'></span>
  36 |     | <span class='neutral'>    function _getGovernorTimelockControlStorage() private pure returns (GovernorTimelockControlStorage storage $) {</span>
  37 |     | <span class='neutral'>        assembly {</span>
  38 |     | <span class='neutral'>            $.slot := GovernorTimelockControlStorageLocation</span>
  39 |     | <span class='neutral'>        }</span>
  40 |     | <span class='neutral'>    }</span>
  41 |     | <span class='neutral'></span>
  42 |     | <span class='neutral'>    /**</span>
  43 |     | <span class='neutral'>     * @dev Emitted when the timelock controller used for proposal execution is modified.</span>
  44 |     | <span class='neutral'>     */</span>
  45 |     | <span class='neutral'>    event TimelockChange(address oldTimelock, address newTimelock);</span>
  46 |     | <span class='neutral'></span>
  47 |     | <span class='neutral'>    /**</span>
  48 |     | <span class='neutral'>     * @dev Set the timelock.</span>
  49 |     | <span class='neutral'>     */</span>
  50 |     | <span class='neutral'>    function __GovernorTimelockControl_init(TimelockControllerUpgradeable timelockAddress) internal onlyInitializing {</span>
  51 |     | <span class='neutral'>        __GovernorTimelockControl_init_unchained(timelockAddress);</span>
  52 |     | <span class='neutral'>    }</span>
  53 |     | <span class='neutral'></span>
  54 |     | <span class='neutral'>    function __GovernorTimelockControl_init_unchained(TimelockControllerUpgradeable timelockAddress) internal onlyInitializing {</span>
  55 |     | <span class='neutral'>        _updateTimelock(timelockAddress);</span>
  56 |     | <span class='neutral'>    }</span>
  57 |     | <span class='neutral'></span>
  58 |     | <span class='neutral'>    /**</span>
  59 |     | <span class='neutral'>     * @dev Overridden version of the {Governor-state} function that considers the status reported by the timelock.</span>
  60 |     | <span class='neutral'>     */</span>
  61 |     | <span class='neutral'>    function state(uint256 proposalId) public view virtual override returns (ProposalState) {</span>
  62 |     | <span class='neutral'>        GovernorTimelockControlStorage storage $ = _getGovernorTimelockControlStorage();</span>
  63 |     | <span class='neutral'>        ProposalState currentState = super.state(proposalId);</span>
  64 |     | <span class='neutral'></span>
  65 |     | <span class='neutral'>        if (currentState != ProposalState.Queued) {</span>
  66 |     | <span class='neutral'>            return currentState;</span>
  67 |     | <span class='neutral'>        }</span>
  68 |     | <span class='neutral'></span>
  69 |     | <span class='neutral'>        bytes32 queueid = $._timelockIds[proposalId];</span>
  70 |     | <span class='neutral'>        if ($._timelock.isOperationPending(queueid)) {</span>
  71 |     | <span class='neutral'>            return ProposalState.Queued;</span>
  72 |     | <span class='neutral'>        } else if ($._timelock.isOperationDone(queueid)) {</span>
  73 |     | <span class='neutral'>            // This can happen if the proposal is executed directly on the timelock.</span>
  74 |     | <span class='neutral'>            return ProposalState.Executed;</span>
  75 |     | <span class='neutral'>        } else {</span>
  76 |     | <span class='neutral'>            // This can happen if the proposal is canceled directly on the timelock.</span>
  77 |     | <span class='neutral'>            return ProposalState.Canceled;</span>
  78 |     | <span class='neutral'>        }</span>
  79 |     | <span class='neutral'>    }</span>
  80 |     | <span class='neutral'></span>
  81 |     | <span class='neutral'>    /**</span>
  82 |     | <span class='neutral'>     * @dev Public accessor to check the address of the timelock</span>
  83 |     | <span class='neutral'>     */</span>
  84 |     | <span class='neutral'>    function timelock() public view virtual returns (address) {</span>
  85 |     | <span class='neutral'>        GovernorTimelockControlStorage storage $ = _getGovernorTimelockControlStorage();</span>
  86 |     | <span class='neutral'>        return address($._timelock);</span>
  87 |     | <span class='neutral'>    }</span>
  88 |     | <span class='neutral'></span>
  89 |     | <span class='neutral'>    /// @inheritdoc IGovernor</span>
  90 |     | <span class='neutral'>    function proposalNeedsQueuing(uint256) public view virtual override returns (bool) {</span>
  91 |     | <span class='neutral'>        return true;</span>
  92 |     | <span class='neutral'>    }</span>
  93 |     | <span class='neutral'></span>
  94 |     | <span class='neutral'>    /**</span>
  95 |     | <span class='neutral'>     * @dev Function to queue a proposal to the timelock.</span>
  96 |     | <span class='neutral'>     */</span>
  97 |     | <span class='neutral'>    function _queueOperations(</span>
  98 |     | <span class='neutral'>        uint256 proposalId,</span>
  99 |     | <span class='neutral'>        address[] memory targets,</span>
 100 |     | <span class='neutral'>        uint256[] memory values,</span>
 101 |     | <span class='neutral'>        bytes[] memory calldatas,</span>
 102 |     | <span class='neutral'>        bytes32 descriptionHash</span>
 103 |     | <span class='neutral'>    ) internal virtual override returns (uint48) {</span>
 104 |     | <span class='neutral'>        GovernorTimelockControlStorage storage $ = _getGovernorTimelockControlStorage();</span>
 105 |     | <span class='neutral'>        uint256 delay = $._timelock.getMinDelay();</span>
 106 |     | <span class='neutral'></span>
 107 |     | <span class='neutral'>        bytes32 salt = _timelockSalt(descriptionHash);</span>
 108 |     | <span class='neutral'>        $._timelockIds[proposalId] = $._timelock.hashOperationBatch(targets, values, calldatas, 0, salt);</span>
 109 |     | <span class='neutral'>        $._timelock.scheduleBatch(targets, values, calldatas, 0, salt, delay);</span>
 110 |     | <span class='neutral'></span>
 111 |     | <span class='neutral'>        return SafeCast.toUint48(block.timestamp + delay);</span>
 112 |     | <span class='neutral'>    }</span>
 113 |     | <span class='neutral'></span>
 114 |     | <span class='neutral'>    /**</span>
 115 |     | <span class='neutral'>     * @dev Overridden version of the {Governor-_executeOperations} function that runs the already queued proposal</span>
 116 |     | <span class='neutral'>     * through the timelock.</span>
 117 |     | <span class='neutral'>     */</span>
 118 |     | <span class='neutral'>    function _executeOperations(</span>
 119 |     | <span class='neutral'>        uint256 proposalId,</span>
 120 |     | <span class='neutral'>        address[] memory targets,</span>
 121 |     | <span class='neutral'>        uint256[] memory values,</span>
 122 |     | <span class='neutral'>        bytes[] memory calldatas,</span>
 123 |     | <span class='neutral'>        bytes32 descriptionHash</span>
 124 |     | <span class='neutral'>    ) internal virtual override {</span>
 125 |     | <span class='neutral'>        GovernorTimelockControlStorage storage $ = _getGovernorTimelockControlStorage();</span>
 126 |     | <span class='neutral'>        // execute</span>
 127 |     | <span class='neutral'>        $._timelock.executeBatch{value: msg.value}(targets, values, calldatas, 0, _timelockSalt(descriptionHash));</span>
 128 |     | <span class='neutral'>        // cleanup for refund</span>
 129 |     | <span class='neutral'>        delete $._timelockIds[proposalId];</span>
 130 |     | <span class='neutral'>    }</span>
 131 |     | <span class='neutral'></span>
 132 |     | <span class='neutral'>    /**</span>
 133 |     | <span class='neutral'>     * @dev Overridden version of the {Governor-_cancel} function to cancel the timelocked proposal if it has already</span>
 134 |     | <span class='neutral'>     * been queued.</span>
 135 |     | <span class='neutral'>     */</span>
 136 |     | <span class='neutral'>    // This function can reenter through the external call to the timelock, but we assume the timelock is trusted and</span>
 137 |     | <span class='neutral'>    // well behaved (according to TimelockController) and this will not happen.</span>
 138 |     | <span class='neutral'>    // slither-disable-next-line reentrancy-no-eth</span>
 139 |     | <span class='neutral'>    function _cancel(</span>
 140 |     | <span class='neutral'>        address[] memory targets,</span>
 141 |     | <span class='neutral'>        uint256[] memory values,</span>
 142 |     | <span class='neutral'>        bytes[] memory calldatas,</span>
 143 |     | <span class='neutral'>        bytes32 descriptionHash</span>
 144 |     | <span class='neutral'>    ) internal virtual override returns (uint256) {</span>
 145 |     | <span class='neutral'>        GovernorTimelockControlStorage storage $ = _getGovernorTimelockControlStorage();</span>
 146 |     | <span class='neutral'>        uint256 proposalId = super._cancel(targets, values, calldatas, descriptionHash);</span>
 147 |     | <span class='neutral'></span>
 148 |     | <span class='neutral'>        bytes32 timelockId = $._timelockIds[proposalId];</span>
 149 |     | <span class='neutral'>        if (timelockId != 0) {</span>
 150 |     | <span class='neutral'>            // cancel</span>
 151 |     | <span class='neutral'>            $._timelock.cancel(timelockId);</span>
 152 |     | <span class='neutral'>            // cleanup</span>
 153 |     | <span class='neutral'>            delete $._timelockIds[proposalId];</span>
 154 |     | <span class='neutral'>        }</span>
 155 |     | <span class='neutral'></span>
 156 |     | <span class='neutral'>        return proposalId;</span>
 157 |     | <span class='neutral'>    }</span>
 158 |     | <span class='neutral'></span>
 159 |     | <span class='neutral'>    /**</span>
 160 |     | <span class='neutral'>     * @dev Address through which the governor executes action. In this case, the timelock.</span>
 161 |     | <span class='neutral'>     */</span>
 162 |     | <span class='neutral'>    function _executor() internal view virtual override returns (address) {</span>
 163 |     | <span class='neutral'>        GovernorTimelockControlStorage storage $ = _getGovernorTimelockControlStorage();</span>
 164 |     | <span class='neutral'>        return address($._timelock);</span>
 165 |     | <span class='neutral'>    }</span>
 166 |     | <span class='neutral'></span>
 167 |     | <span class='neutral'>    /**</span>
 168 |     | <span class='neutral'>     * @dev Public endpoint to update the underlying timelock instance. Restricted to the timelock itself, so updates</span>
 169 |     | <span class='neutral'>     * must be proposed, scheduled, and executed through governance proposals.</span>
 170 |     | <span class='neutral'>     *</span>
 171 |     | <span class='neutral'>     * CAUTION: It is not recommended to change the timelock while there are other queued governance proposals.</span>
 172 |     | <span class='neutral'>     */</span>
 173 |     | <span class='neutral'>    function updateTimelock(TimelockControllerUpgradeable newTimelock) external virtual onlyGovernance {</span>
 174 |     | <span class='neutral'>        _updateTimelock(newTimelock);</span>
 175 |     | <span class='neutral'>    }</span>
 176 |     | <span class='neutral'></span>
 177 |     | <span class='neutral'>    function _updateTimelock(TimelockControllerUpgradeable newTimelock) private {</span>
 178 |     | <span class='neutral'>        GovernorTimelockControlStorage storage $ = _getGovernorTimelockControlStorage();</span>
 179 |     | <span class='neutral'>        emit TimelockChange(address($._timelock), address(newTimelock));</span>
 180 |     | <span class='neutral'>        $._timelock = newTimelock;</span>
 181 |     | <span class='neutral'>    }</span>
 182 |     | <span class='neutral'></span>
 183 |     | <span class='neutral'>    /**</span>
 184 |     | <span class='neutral'>     * @dev Computes the {TimelockController} operation salt.</span>
 185 |     | <span class='neutral'>     *</span>
 186 |     | <span class='neutral'>     * It is computed with the governor address itself to avoid collisions across governor instances using the</span>
 187 |     | <span class='neutral'>     * same timelock.</span>
 188 |     | <span class='neutral'>     */</span>
 189 |     | <span class='neutral'>    function _timelockSalt(bytes32 descriptionHash) private view returns (bytes32) {</span>
 190 |     | <span class='neutral'>        return bytes20(address(this)) ^ descriptionHash;</span>
 191 |     | <span class='neutral'>    }</span>
 192 |     | <span class='neutral'>}</span>
 193 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/phantom/Documents/azemora/azemora-contracts/lib/openzeppelin-contracts-upgradeable/contracts/governance/extensions/GovernorVotesQuorumFractionUpgradeable.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'>// OpenZeppelin Contracts (last updated v5.3.0) (governance/extensions/GovernorVotesQuorumFraction.sol)</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>pragma solidity ^0.8.24;</span>
   5 |     | <span class='neutral'></span>
   6 |     | <span class='unexecuted'>import {GovernorVotesUpgradeable} from &quot;./GovernorVotesUpgradeable.sol&quot;;</span>
   7 |     | <span class='neutral'>import {Math} from &quot;@openzeppelin/contracts/utils/math/Math.sol&quot;;</span>
   8 |     | <span class='neutral'>import {SafeCast} from &quot;@openzeppelin/contracts/utils/math/SafeCast.sol&quot;;</span>
   9 |     | <span class='neutral'>import {Checkpoints} from &quot;@openzeppelin/contracts/utils/structs/Checkpoints.sol&quot;;</span>
  10 |     | <span class='neutral'>import {Initializable} from &quot;../../proxy/utils/Initializable.sol&quot;;</span>
  11 |     | <span class='neutral'></span>
  12 |     | <span class='neutral'>/**</span>
  13 |     | <span class='neutral'> * @dev Extension of {Governor} for voting weight extraction from an {ERC20Votes} token and a quorum expressed as a</span>
  14 |     | <span class='neutral'> * fraction of the total supply.</span>
  15 |     | <span class='neutral'> */</span>
  16 |     | <span class='neutral'>abstract contract GovernorVotesQuorumFractionUpgradeable is Initializable, GovernorVotesUpgradeable {</span>
  17 |     | <span class='neutral'>    using Checkpoints for Checkpoints.Trace208;</span>
  18 |     | <span class='neutral'></span>
  19 |     | <span class='neutral'>    /// @custom:storage-location erc7201:openzeppelin.storage.GovernorVotesQuorumFraction</span>
  20 |     | <span class='neutral'>    struct GovernorVotesQuorumFractionStorage {</span>
  21 |     | <span class='neutral'>        Checkpoints.Trace208 _quorumNumeratorHistory;</span>
  22 |     | <span class='neutral'>    }</span>
  23 |     | <span class='neutral'></span>
  24 |     | <span class='neutral'>    // keccak256(abi.encode(uint256(keccak256(&quot;openzeppelin.storage.GovernorVotesQuorumFraction&quot;)) - 1)) &amp; ~bytes32(uint256(0xff))</span>
  25 |     | <span class='neutral'>    bytes32 private constant GovernorVotesQuorumFractionStorageLocation = 0xe770710421fd2cad75ad828c61aa98f2d77d423a440b67872d0f65554148e000;</span>
  26 |     | <span class='neutral'></span>
  27 |     | <span class='neutral'>    function _getGovernorVotesQuorumFractionStorage() private pure returns (GovernorVotesQuorumFractionStorage storage $) {</span>
  28 |     | <span class='neutral'>        assembly {</span>
  29 |     | <span class='neutral'>            $.slot := GovernorVotesQuorumFractionStorageLocation</span>
  30 |     | <span class='neutral'>        }</span>
  31 |     | <span class='neutral'>    }</span>
  32 |     | <span class='neutral'></span>
  33 |     | <span class='neutral'>    event QuorumNumeratorUpdated(uint256 oldQuorumNumerator, uint256 newQuorumNumerator);</span>
  34 |     | <span class='neutral'></span>
  35 |     | <span class='neutral'>    /**</span>
  36 |     | <span class='neutral'>     * @dev The quorum set is not a valid fraction.</span>
  37 |     | <span class='neutral'>     */</span>
  38 |     | <span class='neutral'>    error GovernorInvalidQuorumFraction(uint256 quorumNumerator, uint256 quorumDenominator);</span>
  39 |     | <span class='neutral'></span>
  40 |     | <span class='neutral'>    /**</span>
  41 |     | <span class='neutral'>     * @dev Initialize quorum as a fraction of the token&#39;s total supply.</span>
  42 |     | <span class='neutral'>     *</span>
  43 |     | <span class='neutral'>     * The fraction is specified as `numerator / denominator`. By default the denominator is 100, so quorum is</span>
  44 |     | <span class='neutral'>     * specified as a percent: a numerator of 10 corresponds to quorum being 10% of total supply. The denominator can be</span>
  45 |     | <span class='neutral'>     * customized by overriding {quorumDenominator}.</span>
  46 |     | <span class='neutral'>     */</span>
  47 |     | <span class='neutral'>    function __GovernorVotesQuorumFraction_init(uint256 quorumNumeratorValue) internal onlyInitializing {</span>
  48 |     | <span class='neutral'>        __GovernorVotesQuorumFraction_init_unchained(quorumNumeratorValue);</span>
  49 |     | <span class='neutral'>    }</span>
  50 |     | <span class='neutral'></span>
  51 |     | <span class='neutral'>    function __GovernorVotesQuorumFraction_init_unchained(uint256 quorumNumeratorValue) internal onlyInitializing {</span>
  52 |     | <span class='neutral'>        _updateQuorumNumerator(quorumNumeratorValue);</span>
  53 |     | <span class='neutral'>    }</span>
  54 |     | <span class='neutral'></span>
  55 |     | <span class='neutral'>    /**</span>
  56 |     | <span class='neutral'>     * @dev Returns the current quorum numerator. See {quorumDenominator}.</span>
  57 |     | <span class='neutral'>     */</span>
  58 |     | <span class='neutral'>    function quorumNumerator() public view virtual returns (uint256) {</span>
  59 |     | <span class='neutral'>        GovernorVotesQuorumFractionStorage storage $ = _getGovernorVotesQuorumFractionStorage();</span>
  60 |     | <span class='neutral'>        return $._quorumNumeratorHistory.latest();</span>
  61 |     | <span class='neutral'>    }</span>
  62 |     | <span class='neutral'></span>
  63 |     | <span class='neutral'>    /**</span>
  64 |     | <span class='neutral'>     * @dev Returns the quorum numerator at a specific timepoint. See {quorumDenominator}.</span>
  65 |     | <span class='neutral'>     */</span>
  66 |     | <span class='neutral'>    function quorumNumerator(uint256 timepoint) public view virtual returns (uint256) {</span>
  67 |     | <span class='neutral'>        GovernorVotesQuorumFractionStorage storage $ = _getGovernorVotesQuorumFractionStorage();</span>
  68 |     | <span class='neutral'>        return _optimisticUpperLookupRecent($._quorumNumeratorHistory, timepoint);</span>
  69 |     | <span class='neutral'>    }</span>
  70 |     | <span class='neutral'></span>
  71 |     | <span class='neutral'>    /**</span>
  72 |     | <span class='neutral'>     * @dev Returns the quorum denominator. Defaults to 100, but may be overridden.</span>
  73 |     | <span class='neutral'>     */</span>
  74 |     | <span class='neutral'>    function quorumDenominator() public view virtual returns (uint256) {</span>
  75 |     | <span class='neutral'>        return 100;</span>
  76 |     | <span class='neutral'>    }</span>
  77 |     | <span class='neutral'></span>
  78 |     | <span class='neutral'>    /**</span>
  79 |     | <span class='neutral'>     * @dev Returns the quorum for a timepoint, in terms of number of votes: `supply * numerator / denominator`.</span>
  80 |     | <span class='neutral'>     */</span>
  81 |     | <span class='neutral'>    function quorum(uint256 timepoint) public view virtual override returns (uint256) {</span>
  82 |     | <span class='neutral'>        return Math.mulDiv(token().getPastTotalSupply(timepoint), quorumNumerator(timepoint), quorumDenominator());</span>
  83 |     | <span class='neutral'>    }</span>
  84 |     | <span class='neutral'></span>
  85 |     | <span class='neutral'>    /**</span>
  86 |     | <span class='neutral'>     * @dev Changes the quorum numerator.</span>
  87 |     | <span class='neutral'>     *</span>
  88 |     | <span class='neutral'>     * Emits a {QuorumNumeratorUpdated} event.</span>
  89 |     | <span class='neutral'>     *</span>
  90 |     | <span class='neutral'>     * Requirements:</span>
  91 |     | <span class='neutral'>     *</span>
  92 |     | <span class='neutral'>     * - Must be called through a governance proposal.</span>
  93 |     | <span class='neutral'>     * - New numerator must be smaller or equal to the denominator.</span>
  94 |     | <span class='neutral'>     */</span>
  95 |     | <span class='neutral'>    function updateQuorumNumerator(uint256 newQuorumNumerator) external virtual onlyGovernance {</span>
  96 |     | <span class='neutral'>        _updateQuorumNumerator(newQuorumNumerator);</span>
  97 |     | <span class='neutral'>    }</span>
  98 |     | <span class='neutral'></span>
  99 |     | <span class='neutral'>    /**</span>
 100 |     | <span class='neutral'>     * @dev Changes the quorum numerator.</span>
 101 |     | <span class='neutral'>     *</span>
 102 |     | <span class='neutral'>     * Emits a {QuorumNumeratorUpdated} event.</span>
 103 |     | <span class='neutral'>     *</span>
 104 |     | <span class='neutral'>     * Requirements:</span>
 105 |     | <span class='neutral'>     *</span>
 106 |     | <span class='neutral'>     * - New numerator must be smaller or equal to the denominator.</span>
 107 |     | <span class='neutral'>     */</span>
 108 |     | <span class='neutral'>    function _updateQuorumNumerator(uint256 newQuorumNumerator) internal virtual {</span>
 109 |     | <span class='neutral'>        GovernorVotesQuorumFractionStorage storage $ = _getGovernorVotesQuorumFractionStorage();</span>
 110 |     | <span class='neutral'>        uint256 denominator = quorumDenominator();</span>
 111 |     | <span class='neutral'>        if (newQuorumNumerator &gt; denominator) {</span>
 112 |     | <span class='neutral'>            revert GovernorInvalidQuorumFraction(newQuorumNumerator, denominator);</span>
 113 |     | <span class='neutral'>        }</span>
 114 |     | <span class='neutral'></span>
 115 |     | <span class='neutral'>        uint256 oldQuorumNumerator = quorumNumerator();</span>
 116 |     | <span class='neutral'>        $._quorumNumeratorHistory.push(clock(), SafeCast.toUint208(newQuorumNumerator));</span>
 117 |     | <span class='neutral'></span>
 118 |     | <span class='neutral'>        emit QuorumNumeratorUpdated(oldQuorumNumerator, newQuorumNumerator);</span>
 119 |     | <span class='neutral'>    }</span>
 120 |     | <span class='neutral'></span>
 121 |     | <span class='neutral'>    /**</span>
 122 |     | <span class='neutral'>     * @dev Returns the numerator at a specific timepoint.</span>
 123 |     | <span class='neutral'>     */</span>
 124 |     | <span class='neutral'>    function _optimisticUpperLookupRecent(</span>
 125 |     | <span class='neutral'>        Checkpoints.Trace208 storage ckpts,</span>
 126 |     | <span class='neutral'>        uint256 timepoint</span>
 127 |     | <span class='neutral'>    ) internal view returns (uint256) {</span>
 128 |     | <span class='neutral'>        // If trace is empty, key and value are both equal to 0.</span>
 129 |     | <span class='neutral'>        // In that case `key &lt;= timepoint` is true, and it is ok to return 0.</span>
 130 |     | <span class='neutral'>        (, uint48 key, uint208 value) = ckpts.latestCheckpoint();</span>
 131 |     | <span class='neutral'>        return key &lt;= timepoint ? value : ckpts.upperLookupRecent(SafeCast.toUint48(timepoint));</span>
 132 |     | <span class='neutral'>    }</span>
 133 |     | <span class='neutral'>}</span>
 134 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/phantom/Documents/azemora/azemora-contracts/lib/openzeppelin-contracts-upgradeable/contracts/governance/extensions/GovernorVotesUpgradeable.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>// OpenZeppelin Contracts (last updated v5.1.0) (governance/extensions/GovernorVotes.sol)</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>pragma solidity ^0.8.24;</span>
  5 |     | <span class='neutral'></span>
  6 |     | <span class='neutral'>import {GovernorUpgradeable} from &quot;../GovernorUpgradeable.sol&quot;;</span>
  7 |     | <span class='neutral'>import {IVotes} from &quot;@openzeppelin/contracts/governance/utils/IVotes.sol&quot;;</span>
  8 |     | <span class='neutral'>import {IERC5805} from &quot;@openzeppelin/contracts/interfaces/IERC5805.sol&quot;;</span>
  9 |     | <span class='neutral'>import {Time} from &quot;@openzeppelin/contracts/utils/types/Time.sol&quot;;</span>
 10 |     | <span class='neutral'>import {Initializable} from &quot;../../proxy/utils/Initializable.sol&quot;;</span>
 11 |     | <span class='neutral'></span>
 12 |     | <span class='neutral'>/**</span>
 13 |     | <span class='neutral'> * @dev Extension of {Governor} for voting weight extraction from an {ERC20Votes} token, or since v4.5 an {ERC721Votes}</span>
 14 |     | <span class='neutral'> * token.</span>
 15 |     | <span class='neutral'> */</span>
 16 |     | <span class='neutral'>abstract contract GovernorVotesUpgradeable is Initializable, GovernorUpgradeable {</span>
 17 | *   | <span class='executed'>    /// @custom:storage-location erc7201:openzeppelin.storage.GovernorVotes</span>
 18 |     | <span class='neutral'>    struct GovernorVotesStorage {</span>
 19 |     | <span class='neutral'>        IERC5805 _token;</span>
 20 |     | <span class='neutral'>    }</span>
 21 |     | <span class='neutral'></span>
 22 |     | <span class='neutral'>    // keccak256(abi.encode(uint256(keccak256(&quot;openzeppelin.storage.GovernorVotes&quot;)) - 1)) &amp; ~bytes32(uint256(0xff))</span>
 23 |     | <span class='neutral'>    bytes32 private constant GovernorVotesStorageLocation = 0x3ba4977254e415696610a40ebf2258dbfa0ec6a2ff64e84bfe715ff16977cc00;</span>
 24 |     | <span class='neutral'></span>
 25 |     | <span class='neutral'>    function _getGovernorVotesStorage() private pure returns (GovernorVotesStorage storage $) {</span>
 26 |     | <span class='neutral'>        assembly {</span>
 27 |     | <span class='neutral'>            $.slot := GovernorVotesStorageLocation</span>
 28 |     | <span class='neutral'>        }</span>
 29 |     | <span class='neutral'>    }</span>
 30 |     | <span class='neutral'></span>
 31 |     | <span class='neutral'>    function __GovernorVotes_init(IVotes tokenAddress) internal onlyInitializing {</span>
 32 |     | <span class='neutral'>        __GovernorVotes_init_unchained(tokenAddress);</span>
 33 |     | <span class='neutral'>    }</span>
 34 |     | <span class='neutral'></span>
 35 |     | <span class='neutral'>    function __GovernorVotes_init_unchained(IVotes tokenAddress) internal onlyInitializing {</span>
 36 |     | <span class='neutral'>        GovernorVotesStorage storage $ = _getGovernorVotesStorage();</span>
 37 |     | <span class='neutral'>        $._token = IERC5805(address(tokenAddress));</span>
 38 |     | <span class='neutral'>    }</span>
 39 |     | <span class='neutral'></span>
 40 |     | <span class='neutral'>    /**</span>
 41 |     | <span class='neutral'>     * @dev The token that voting power is sourced from.</span>
 42 |     | <span class='neutral'>     */</span>
 43 |     | <span class='neutral'>    function token() public view virtual returns (IERC5805) {</span>
 44 |     | <span class='neutral'>        GovernorVotesStorage storage $ = _getGovernorVotesStorage();</span>
 45 |     | <span class='neutral'>        return $._token;</span>
 46 |     | <span class='neutral'>    }</span>
 47 |     | <span class='neutral'></span>
 48 |     | <span class='neutral'>    /**</span>
 49 |     | <span class='neutral'>     * @dev Clock (as specified in ERC-6372) is set to match the token&#39;s clock. Fallback to block numbers if the token</span>
 50 |     | <span class='neutral'>     * does not implement ERC-6372.</span>
 51 |     | <span class='neutral'>     */</span>
 52 |     | <span class='neutral'>    function clock() public view virtual override returns (uint48) {</span>
 53 |     | <span class='neutral'>        try token().clock() returns (uint48 timepoint) {</span>
 54 |     | <span class='neutral'>            return timepoint;</span>
 55 |     | <span class='neutral'>        } catch {</span>
 56 |     | <span class='neutral'>            return Time.blockNumber();</span>
 57 |     | <span class='neutral'>        }</span>
 58 |     | <span class='neutral'>    }</span>
 59 |     | <span class='neutral'></span>
 60 |     | <span class='neutral'>    /**</span>
 61 |     | <span class='neutral'>     * @dev Machine-readable description of the clock as specified in ERC-6372.</span>
 62 |     | <span class='neutral'>     */</span>
 63 |     | <span class='neutral'>    // solhint-disable-next-line func-name-mixedcase</span>
 64 |     | <span class='neutral'>    function CLOCK_MODE() public view virtual override returns (string memory) {</span>
 65 |     | <span class='neutral'>        try token().CLOCK_MODE() returns (string memory clockmode) {</span>
 66 |     | <span class='neutral'>            return clockmode;</span>
 67 |     | <span class='neutral'>        } catch {</span>
 68 |     | <span class='neutral'>            return &quot;mode=blocknumber&amp;from=default&quot;;</span>
 69 |     | <span class='neutral'>        }</span>
 70 |     | <span class='neutral'>    }</span>
 71 |     | <span class='neutral'></span>
 72 |     | <span class='neutral'>    /**</span>
 73 |     | <span class='neutral'>     * Read the voting weight from the token&#39;s built in snapshot mechanism (see {Governor-_getVotes}).</span>
 74 |     | <span class='neutral'>     */</span>
 75 |     | <span class='neutral'>    function _getVotes(</span>
 76 |     | <span class='neutral'>        address account,</span>
 77 |     | <span class='neutral'>        uint256 timepoint,</span>
 78 |     | <span class='neutral'>        bytes memory /*params*/</span>
 79 |     | <span class='neutral'>    ) internal view virtual override returns (uint256) {</span>
 80 |     | <span class='neutral'>        return token().getPastVotes(account, timepoint);</span>
 81 |     | <span class='neutral'>    }</span>
 82 |     | <span class='neutral'>}</span>
 83 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/phantom/Documents/azemora/azemora-contracts/lib/openzeppelin-contracts-upgradeable/contracts/governance/utils/VotesUpgradeable.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'>// OpenZeppelin Contracts (last updated v5.2.0) (governance/utils/Votes.sol)</span>
   3 |     | <span class='neutral'>pragma solidity ^0.8.20;</span>
   4 |     | <span class='neutral'></span>
   5 |     | <span class='neutral'>import {IERC5805} from &quot;@openzeppelin/contracts/interfaces/IERC5805.sol&quot;;</span>
   6 |     | <span class='neutral'>import {ContextUpgradeable} from &quot;../../utils/ContextUpgradeable.sol&quot;;</span>
   7 |     | <span class='neutral'>import {NoncesUpgradeable} from &quot;../../utils/NoncesUpgradeable.sol&quot;;</span>
   8 |     | <span class='unexecuted'>import {EIP712Upgradeable} from &quot;../../utils/cryptography/EIP712Upgradeable.sol&quot;;</span>
   9 |     | <span class='neutral'>import {Checkpoints} from &quot;@openzeppelin/contracts/utils/structs/Checkpoints.sol&quot;;</span>
  10 |     | <span class='neutral'>import {SafeCast} from &quot;@openzeppelin/contracts/utils/math/SafeCast.sol&quot;;</span>
  11 |     | <span class='neutral'>import {ECDSA} from &quot;@openzeppelin/contracts/utils/cryptography/ECDSA.sol&quot;;</span>
  12 |     | <span class='neutral'>import {Time} from &quot;@openzeppelin/contracts/utils/types/Time.sol&quot;;</span>
  13 |     | <span class='neutral'>import {Initializable} from &quot;../../proxy/utils/Initializable.sol&quot;;</span>
  14 |     | <span class='neutral'></span>
  15 |     | <span class='neutral'>/**</span>
  16 |     | <span class='neutral'> * @dev This is a base abstract contract that tracks voting units, which are a measure of voting power that can be</span>
  17 |     | <span class='neutral'> * transferred, and provides a system of vote delegation, where an account can delegate its voting units to a sort of</span>
  18 |     | <span class='neutral'> * &quot;representative&quot; that will pool delegated voting units from different accounts and can then use it to vote in</span>
  19 |     | <span class='neutral'> * decisions. In fact, voting units _must_ be delegated in order to count as actual votes, and an account has to</span>
  20 |     | <span class='neutral'> * delegate those votes to itself if it wishes to participate in decisions and does not have a trusted representative.</span>
  21 |     | <span class='neutral'> *</span>
  22 |     | <span class='neutral'> * This contract is often combined with a token contract such that voting units correspond to token units. For an</span>
  23 |     | <span class='neutral'> * example, see {ERC721Votes}.</span>
  24 |     | <span class='neutral'> *</span>
  25 |     | <span class='neutral'> * The full history of delegate votes is tracked on-chain so that governance protocols can consider votes as distributed</span>
  26 |     | <span class='neutral'> * at a particular block number to protect against flash loans and double voting. The opt-in delegate system makes the</span>
  27 |     | <span class='neutral'> * cost of this history tracking optional.</span>
  28 |     | <span class='neutral'> *</span>
  29 |     | <span class='neutral'> * When using this module the derived contract must implement {_getVotingUnits} (for example, make it return</span>
  30 |     | <span class='neutral'> * {ERC721-balanceOf}), and can use {_transferVotingUnits} to track a change in the distribution of those units (in the</span>
  31 |     | <span class='neutral'> * previous example, it would be included in {ERC721-_update}).</span>
  32 |     | <span class='neutral'> */</span>
  33 |     | <span class='neutral'>abstract contract VotesUpgradeable is Initializable, ContextUpgradeable, EIP712Upgradeable, NoncesUpgradeable, IERC5805 {</span>
  34 |     | <span class='neutral'>    using Checkpoints for Checkpoints.Trace208;</span>
  35 |     | <span class='neutral'></span>
  36 |     | <span class='neutral'>    bytes32 private constant DELEGATION_TYPEHASH =</span>
  37 |     | <span class='neutral'>        keccak256(&quot;Delegation(address delegatee,uint256 nonce,uint256 expiry)&quot;);</span>
  38 |     | <span class='neutral'></span>
  39 |     | <span class='neutral'>    /// @custom:storage-location erc7201:openzeppelin.storage.Votes</span>
  40 |     | <span class='neutral'>    struct VotesStorage {</span>
  41 |     | <span class='neutral'>        mapping(address account =&gt; address) _delegatee;</span>
  42 |     | <span class='neutral'></span>
  43 |     | <span class='neutral'>        mapping(address delegatee =&gt; Checkpoints.Trace208) _delegateCheckpoints;</span>
  44 |     | <span class='neutral'></span>
  45 |     | <span class='neutral'>        Checkpoints.Trace208 _totalCheckpoints;</span>
  46 |     | <span class='neutral'>    }</span>
  47 |     | <span class='neutral'></span>
  48 |     | <span class='neutral'>    // keccak256(abi.encode(uint256(keccak256(&quot;openzeppelin.storage.Votes&quot;)) - 1)) &amp; ~bytes32(uint256(0xff))</span>
  49 |     | <span class='neutral'>    bytes32 private constant VotesStorageLocation = 0xe8b26c30fad74198956032a3533d903385d56dd795af560196f9c78d4af40d00;</span>
  50 |     | <span class='neutral'></span>
  51 |     | <span class='neutral'>    function _getVotesStorage() private pure returns (VotesStorage storage $) {</span>
  52 |     | <span class='neutral'>        assembly {</span>
  53 |     | <span class='neutral'>            $.slot := VotesStorageLocation</span>
  54 |     | <span class='neutral'>        }</span>
  55 |     | <span class='neutral'>    }</span>
  56 |     | <span class='neutral'></span>
  57 |     | <span class='neutral'>    /**</span>
  58 |     | <span class='neutral'>     * @dev The clock was incorrectly modified.</span>
  59 |     | <span class='neutral'>     */</span>
  60 |     | <span class='neutral'>    error ERC6372InconsistentClock();</span>
  61 |     | <span class='neutral'></span>
  62 |     | <span class='neutral'>    /**</span>
  63 |     | <span class='neutral'>     * @dev Lookup to future votes is not available.</span>
  64 |     | <span class='neutral'>     */</span>
  65 |     | <span class='neutral'>    error ERC5805FutureLookup(uint256 timepoint, uint48 clock);</span>
  66 |     | <span class='neutral'></span>
  67 |     | <span class='neutral'>    function __Votes_init() internal onlyInitializing {</span>
  68 |     | <span class='neutral'>    }</span>
  69 |     | <span class='neutral'></span>
  70 |     | <span class='neutral'>    function __Votes_init_unchained() internal onlyInitializing {</span>
  71 |     | <span class='neutral'>    }</span>
  72 |     | <span class='neutral'>    /**</span>
  73 |     | <span class='neutral'>     * @dev Clock used for flagging checkpoints. Can be overridden to implement timestamp based</span>
  74 |     | <span class='neutral'>     * checkpoints (and voting), in which case {CLOCK_MODE} should be overridden as well to match.</span>
  75 |     | <span class='neutral'>     */</span>
  76 |     | <span class='neutral'>    function clock() public view virtual returns (uint48) {</span>
  77 |     | <span class='neutral'>        return Time.blockNumber();</span>
  78 |     | <span class='neutral'>    }</span>
  79 |     | <span class='neutral'></span>
  80 |     | <span class='neutral'>    /**</span>
  81 |     | <span class='neutral'>     * @dev Machine-readable description of the clock as specified in ERC-6372.</span>
  82 |     | <span class='neutral'>     */</span>
  83 |     | <span class='neutral'>    // solhint-disable-next-line func-name-mixedcase</span>
  84 |     | <span class='neutral'>    function CLOCK_MODE() public view virtual returns (string memory) {</span>
  85 |     | <span class='neutral'>        // Check that the clock was not modified</span>
  86 |     | <span class='neutral'>        if (clock() != Time.blockNumber()) {</span>
  87 |     | <span class='neutral'>            revert ERC6372InconsistentClock();</span>
  88 |     | <span class='neutral'>        }</span>
  89 |     | <span class='neutral'>        return &quot;mode=blocknumber&amp;from=default&quot;;</span>
  90 |     | <span class='neutral'>    }</span>
  91 |     | <span class='neutral'></span>
  92 |     | <span class='neutral'>    /**</span>
  93 |     | <span class='neutral'>     * @dev Validate that a timepoint is in the past, and return it as a uint48.</span>
  94 |     | <span class='neutral'>     */</span>
  95 |     | <span class='neutral'>    function _validateTimepoint(uint256 timepoint) internal view returns (uint48) {</span>
  96 |     | <span class='neutral'>        uint48 currentTimepoint = clock();</span>
  97 |     | <span class='neutral'>        if (timepoint &gt;= currentTimepoint) revert ERC5805FutureLookup(timepoint, currentTimepoint);</span>
  98 |     | <span class='neutral'>        return SafeCast.toUint48(timepoint);</span>
  99 |     | <span class='neutral'>    }</span>
 100 |     | <span class='neutral'></span>
 101 |     | <span class='neutral'>    /**</span>
 102 |     | <span class='neutral'>     * @dev Returns the current amount of votes that `account` has.</span>
 103 |     | <span class='neutral'>     */</span>
 104 |     | <span class='neutral'>    function getVotes(address account) public view virtual returns (uint256) {</span>
 105 |     | <span class='neutral'>        VotesStorage storage $ = _getVotesStorage();</span>
 106 |     | <span class='neutral'>        return $._delegateCheckpoints[account].latest();</span>
 107 |     | <span class='neutral'>    }</span>
 108 |     | <span class='neutral'></span>
 109 |     | <span class='neutral'>    /**</span>
 110 |     | <span class='neutral'>     * @dev Returns the amount of votes that `account` had at a specific moment in the past. If the `clock()` is</span>
 111 |     | <span class='neutral'>     * configured to use block numbers, this will return the value at the end of the corresponding block.</span>
 112 |     | <span class='neutral'>     *</span>
 113 |     | <span class='neutral'>     * Requirements:</span>
 114 |     | <span class='neutral'>     *</span>
 115 |     | <span class='neutral'>     * - `timepoint` must be in the past. If operating using block numbers, the block must be already mined.</span>
 116 |     | <span class='neutral'>     */</span>
 117 |     | <span class='neutral'>    function getPastVotes(address account, uint256 timepoint) public view virtual returns (uint256) {</span>
 118 |     | <span class='neutral'>        VotesStorage storage $ = _getVotesStorage();</span>
 119 |     | <span class='neutral'>        return $._delegateCheckpoints[account].upperLookupRecent(_validateTimepoint(timepoint));</span>
 120 |     | <span class='neutral'>    }</span>
 121 |     | <span class='neutral'></span>
 122 |     | <span class='neutral'>    /**</span>
 123 |     | <span class='neutral'>     * @dev Returns the total supply of votes available at a specific moment in the past. If the `clock()` is</span>
 124 |     | <span class='neutral'>     * configured to use block numbers, this will return the value at the end of the corresponding block.</span>
 125 |     | <span class='neutral'>     *</span>
 126 |     | <span class='neutral'>     * NOTE: This value is the sum of all available votes, which is not necessarily the sum of all delegated votes.</span>
 127 |     | <span class='neutral'>     * Votes that have not been delegated are still part of total supply, even though they would not participate in a</span>
 128 |     | <span class='neutral'>     * vote.</span>
 129 |     | <span class='neutral'>     *</span>
 130 |     | <span class='neutral'>     * Requirements:</span>
 131 |     | <span class='neutral'>     *</span>
 132 |     | <span class='neutral'>     * - `timepoint` must be in the past. If operating using block numbers, the block must be already mined.</span>
 133 |     | <span class='neutral'>     */</span>
 134 |     | <span class='neutral'>    function getPastTotalSupply(uint256 timepoint) public view virtual returns (uint256) {</span>
 135 |     | <span class='neutral'>        VotesStorage storage $ = _getVotesStorage();</span>
 136 |     | <span class='neutral'>        return $._totalCheckpoints.upperLookupRecent(_validateTimepoint(timepoint));</span>
 137 |     | <span class='neutral'>    }</span>
 138 |     | <span class='neutral'></span>
 139 |     | <span class='neutral'>    /**</span>
 140 |     | <span class='neutral'>     * @dev Returns the current total supply of votes.</span>
 141 |     | <span class='neutral'>     */</span>
 142 |     | <span class='neutral'>    function _getTotalSupply() internal view virtual returns (uint256) {</span>
 143 |     | <span class='neutral'>        VotesStorage storage $ = _getVotesStorage();</span>
 144 |     | <span class='neutral'>        return $._totalCheckpoints.latest();</span>
 145 |     | <span class='neutral'>    }</span>
 146 |     | <span class='neutral'></span>
 147 |     | <span class='neutral'>    /**</span>
 148 |     | <span class='neutral'>     * @dev Returns the delegate that `account` has chosen.</span>
 149 |     | <span class='neutral'>     */</span>
 150 |     | <span class='neutral'>    function delegates(address account) public view virtual returns (address) {</span>
 151 |     | <span class='neutral'>        VotesStorage storage $ = _getVotesStorage();</span>
 152 |     | <span class='neutral'>        return $._delegatee[account];</span>
 153 |     | <span class='neutral'>    }</span>
 154 |     | <span class='neutral'></span>
 155 |     | <span class='neutral'>    /**</span>
 156 |     | <span class='neutral'>     * @dev Delegates votes from the sender to `delegatee`.</span>
 157 |     | <span class='neutral'>     */</span>
 158 |     | <span class='neutral'>    function delegate(address delegatee) public virtual {</span>
 159 |     | <span class='neutral'>        address account = _msgSender();</span>
 160 |     | <span class='neutral'>        _delegate(account, delegatee);</span>
 161 |     | <span class='neutral'>    }</span>
 162 |     | <span class='neutral'></span>
 163 |     | <span class='neutral'>    /**</span>
 164 |     | <span class='neutral'>     * @dev Delegates votes from signer to `delegatee`.</span>
 165 |     | <span class='neutral'>     */</span>
 166 |     | <span class='neutral'>    function delegateBySig(</span>
 167 |     | <span class='neutral'>        address delegatee,</span>
 168 |     | <span class='neutral'>        uint256 nonce,</span>
 169 |     | <span class='neutral'>        uint256 expiry,</span>
 170 |     | <span class='neutral'>        uint8 v,</span>
 171 |     | <span class='neutral'>        bytes32 r,</span>
 172 |     | <span class='neutral'>        bytes32 s</span>
 173 |     | <span class='neutral'>    ) public virtual {</span>
 174 |     | <span class='neutral'>        if (block.timestamp &gt; expiry) {</span>
 175 |     | <span class='neutral'>            revert VotesExpiredSignature(expiry);</span>
 176 |     | <span class='neutral'>        }</span>
 177 |     | <span class='neutral'>        address signer = ECDSA.recover(</span>
 178 |     | <span class='neutral'>            _hashTypedDataV4(keccak256(abi.encode(DELEGATION_TYPEHASH, delegatee, nonce, expiry))),</span>
 179 |     | <span class='neutral'>            v,</span>
 180 |     | <span class='neutral'>            r,</span>
 181 |     | <span class='neutral'>            s</span>
 182 |     | <span class='neutral'>        );</span>
 183 |     | <span class='neutral'>        _useCheckedNonce(signer, nonce);</span>
 184 |     | <span class='neutral'>        _delegate(signer, delegatee);</span>
 185 |     | <span class='neutral'>    }</span>
 186 |     | <span class='neutral'></span>
 187 |     | <span class='neutral'>    /**</span>
 188 |     | <span class='neutral'>     * @dev Delegate all of `account`&#39;s voting units to `delegatee`.</span>
 189 |     | <span class='neutral'>     *</span>
 190 |     | <span class='neutral'>     * Emits events {IVotes-DelegateChanged} and {IVotes-DelegateVotesChanged}.</span>
 191 |     | <span class='neutral'>     */</span>
 192 |     | <span class='neutral'>    function _delegate(address account, address delegatee) internal virtual {</span>
 193 |     | <span class='neutral'>        VotesStorage storage $ = _getVotesStorage();</span>
 194 |     | <span class='neutral'>        address oldDelegate = delegates(account);</span>
 195 |     | <span class='neutral'>        $._delegatee[account] = delegatee;</span>
 196 |     | <span class='neutral'></span>
 197 |     | <span class='neutral'>        emit DelegateChanged(account, oldDelegate, delegatee);</span>
 198 |     | <span class='neutral'>        _moveDelegateVotes(oldDelegate, delegatee, _getVotingUnits(account));</span>
 199 |     | <span class='neutral'>    }</span>
 200 |     | <span class='neutral'></span>
 201 |     | <span class='neutral'>    /**</span>
 202 |     | <span class='neutral'>     * @dev Transfers, mints, or burns voting units. To register a mint, `from` should be zero. To register a burn, `to`</span>
 203 |     | <span class='neutral'>     * should be zero. Total supply of voting units will be adjusted with mints and burns.</span>
 204 |     | <span class='neutral'>     */</span>
 205 |     | <span class='neutral'>    function _transferVotingUnits(address from, address to, uint256 amount) internal virtual {</span>
 206 |     | <span class='neutral'>        VotesStorage storage $ = _getVotesStorage();</span>
 207 |     | <span class='neutral'>        if (from == address(0)) {</span>
 208 |     | <span class='neutral'>            _push($._totalCheckpoints, _add, SafeCast.toUint208(amount));</span>
 209 |     | <span class='neutral'>        }</span>
 210 |     | <span class='neutral'>        if (to == address(0)) {</span>
 211 |     | <span class='neutral'>            _push($._totalCheckpoints, _subtract, SafeCast.toUint208(amount));</span>
 212 |     | <span class='neutral'>        }</span>
 213 |     | <span class='neutral'>        _moveDelegateVotes(delegates(from), delegates(to), amount);</span>
 214 |     | <span class='neutral'>    }</span>
 215 |     | <span class='neutral'></span>
 216 |     | <span class='neutral'>    /**</span>
 217 |     | <span class='neutral'>     * @dev Moves delegated votes from one delegate to another.</span>
 218 |     | <span class='neutral'>     */</span>
 219 |     | <span class='neutral'>    function _moveDelegateVotes(address from, address to, uint256 amount) internal virtual {</span>
 220 |     | <span class='neutral'>        VotesStorage storage $ = _getVotesStorage();</span>
 221 |     | <span class='neutral'>        if (from != to &amp;&amp; amount &gt; 0) {</span>
 222 |     | <span class='neutral'>            if (from != address(0)) {</span>
 223 |     | <span class='neutral'>                (uint256 oldValue, uint256 newValue) = _push(</span>
 224 |     | <span class='neutral'>                    $._delegateCheckpoints[from],</span>
 225 |     | <span class='neutral'>                    _subtract,</span>
 226 |     | <span class='neutral'>                    SafeCast.toUint208(amount)</span>
 227 |     | <span class='neutral'>                );</span>
 228 |     | <span class='neutral'>                emit DelegateVotesChanged(from, oldValue, newValue);</span>
 229 |     | <span class='neutral'>            }</span>
 230 |     | <span class='neutral'>            if (to != address(0)) {</span>
 231 |     | <span class='neutral'>                (uint256 oldValue, uint256 newValue) = _push(</span>
 232 |     | <span class='neutral'>                    $._delegateCheckpoints[to],</span>
 233 |     | <span class='neutral'>                    _add,</span>
 234 |     | <span class='neutral'>                    SafeCast.toUint208(amount)</span>
 235 |     | <span class='neutral'>                );</span>
 236 |     | <span class='neutral'>                emit DelegateVotesChanged(to, oldValue, newValue);</span>
 237 |     | <span class='neutral'>            }</span>
 238 |     | <span class='neutral'>        }</span>
 239 |     | <span class='neutral'>    }</span>
 240 |     | <span class='neutral'></span>
 241 |     | <span class='neutral'>    /**</span>
 242 |     | <span class='neutral'>     * @dev Get number of checkpoints for `account`.</span>
 243 |     | <span class='neutral'>     */</span>
 244 |     | <span class='neutral'>    function _numCheckpoints(address account) internal view virtual returns (uint32) {</span>
 245 |     | <span class='neutral'>        VotesStorage storage $ = _getVotesStorage();</span>
 246 |     | <span class='neutral'>        return SafeCast.toUint32($._delegateCheckpoints[account].length());</span>
 247 |     | <span class='neutral'>    }</span>
 248 |     | <span class='neutral'></span>
 249 |     | <span class='neutral'>    /**</span>
 250 |     | <span class='neutral'>     * @dev Get the `pos`-th checkpoint for `account`.</span>
 251 |     | <span class='neutral'>     */</span>
 252 |     | <span class='neutral'>    function _checkpoints(</span>
 253 |     | <span class='neutral'>        address account,</span>
 254 |     | <span class='neutral'>        uint32 pos</span>
 255 |     | <span class='neutral'>    ) internal view virtual returns (Checkpoints.Checkpoint208 memory) {</span>
 256 |     | <span class='neutral'>        VotesStorage storage $ = _getVotesStorage();</span>
 257 |     | <span class='neutral'>        return $._delegateCheckpoints[account].at(pos);</span>
 258 |     | <span class='neutral'>    }</span>
 259 |     | <span class='neutral'></span>
 260 |     | <span class='neutral'>    function _push(</span>
 261 |     | <span class='neutral'>        Checkpoints.Trace208 storage store,</span>
 262 |     | <span class='neutral'>        function(uint208, uint208) view returns (uint208) op,</span>
 263 |     | <span class='neutral'>        uint208 delta</span>
 264 |     | <span class='neutral'>    ) private returns (uint208 oldValue, uint208 newValue) {</span>
 265 |     | <span class='neutral'>        return store.push(clock(), op(store.latest(), delta));</span>
 266 |     | <span class='neutral'>    }</span>
 267 |     | <span class='neutral'></span>
 268 |     | <span class='neutral'>    function _add(uint208 a, uint208 b) private pure returns (uint208) {</span>
 269 |     | <span class='neutral'>        return a + b;</span>
 270 |     | <span class='neutral'>    }</span>
 271 |     | <span class='neutral'></span>
 272 |     | <span class='neutral'>    function _subtract(uint208 a, uint208 b) private pure returns (uint208) {</span>
 273 |     | <span class='neutral'>        return a - b;</span>
 274 |     | <span class='neutral'>    }</span>
 275 |     | <span class='neutral'></span>
 276 |     | <span class='neutral'>    /**</span>
 277 |     | <span class='neutral'>     * @dev Must return the voting units held by an account.</span>
 278 |     | <span class='neutral'>     */</span>
 279 |     | <span class='neutral'>    function _getVotingUnits(address) internal view virtual returns (uint256);</span>
 280 |     | <span class='neutral'>}</span>
 281 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/phantom/Documents/azemora/azemora-contracts/lib/openzeppelin-contracts-upgradeable/contracts/proxy/utils/Initializable.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'>// OpenZeppelin Contracts (last updated v5.3.0) (proxy/utils/Initializable.sol)</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>pragma solidity ^0.8.20;</span>
   5 |     | <span class='neutral'></span>
   6 |     | <span class='neutral'>/**</span>
   7 |     | <span class='neutral'> * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed</span>
   8 |     | <span class='neutral'> * behind a proxy. Since proxied contracts do not make use of a constructor, it&#39;s common to move constructor logic to an</span>
   9 |     | <span class='neutral'> * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer</span>
  10 |     | <span class='neutral'> * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.</span>
  11 |     | <span class='neutral'> *</span>
  12 |     | <span class='unexecuted'> * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be</span>
  13 |     | <span class='neutral'> * reused. This mechanism prevents re-execution of each &quot;step&quot; but allows the creation of new initialization steps in</span>
  14 |     | <span class='neutral'> * case an upgrade adds a module that needs to be initialized.</span>
  15 |     | <span class='neutral'> *</span>
  16 |     | <span class='neutral'> * For example:</span>
  17 |     | <span class='neutral'> *</span>
  18 |     | <span class='unexecuted'> * [.hljs-theme-light.nopadding]</span>
  19 |     | <span class='neutral'> * ```solidity</span>
  20 |     | <span class='neutral'> * contract MyToken is ERC20Upgradeable {</span>
  21 |     | <span class='neutral'> *     function initialize() initializer public {</span>
  22 |     | <span class='neutral'> *         __ERC20_init(&quot;MyToken&quot;, &quot;MTK&quot;);</span>
  23 |     | <span class='neutral'> *     }</span>
  24 |     | <span class='neutral'> * }</span>
  25 |     | <span class='neutral'> *</span>
  26 |     | <span class='neutral'> * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {</span>
  27 |     | <span class='neutral'> *     function initializeV2() reinitializer(2) public {</span>
  28 |     | <span class='neutral'> *         __ERC20Permit_init(&quot;MyToken&quot;);</span>
  29 |     | <span class='neutral'> *     }</span>
  30 |     | <span class='neutral'> * }</span>
  31 |     | <span class='unexecuted'> * ```</span>
  32 |     | <span class='neutral'> *</span>
  33 |     | <span class='neutral'> * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as</span>
  34 |     | <span class='unexecuted'> * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.</span>
  35 |     | <span class='neutral'> *</span>
  36 |     | <span class='neutral'> * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure</span>
  37 |     | <span class='neutral'> * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.</span>
  38 |     | <span class='unexecuted'> *</span>
  39 |     | <span class='neutral'> * [CAUTION]</span>
  40 |     | <span class='neutral'> * ====</span>
  41 |     | <span class='neutral'> * Avoid leaving a contract uninitialized.</span>
  42 |     | <span class='neutral'> *</span>
  43 |     | <span class='unexecuted'> * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation</span>
  44 |     | <span class='neutral'> * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke</span>
  45 |     | <span class='neutral'> * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:</span>
  46 |     | <span class='neutral'> *</span>
  47 |     | <span class='neutral'> * [.hljs-theme-light.nopadding]</span>
  48 |     | <span class='neutral'> * ```</span>
  49 |     | <span class='neutral'> * /// @custom:oz-upgrades-unsafe-allow constructor</span>
  50 |     | <span class='neutral'> * constructor() {</span>
  51 |     | <span class='neutral'> *     _disableInitializers();</span>
  52 |     | <span class='neutral'> * }</span>
  53 |     | <span class='neutral'> * ```</span>
  54 |     | <span class='neutral'> * ====</span>
  55 |     | <span class='neutral'> */</span>
  56 |     | <span class='neutral'>abstract contract Initializable {</span>
  57 |     | <span class='neutral'>    /**</span>
  58 |     | <span class='neutral'>     * @dev Storage of the initializable contract.</span>
  59 |     | <span class='neutral'>     *</span>
  60 |     | <span class='neutral'>     * It&#39;s implemented on a custom ERC-7201 namespace to reduce the risk of storage collisions</span>
  61 |     | <span class='neutral'>     * when using with upgradeable contracts.</span>
  62 |     | <span class='neutral'>     *</span>
  63 |     | <span class='neutral'>     * @custom:storage-location erc7201:openzeppelin.storage.Initializable</span>
  64 |     | <span class='neutral'>     */</span>
  65 |     | <span class='neutral'>    struct InitializableStorage {</span>
  66 |     | <span class='neutral'>        /**</span>
  67 |     | <span class='neutral'>         * @dev Indicates that the contract has been initialized.</span>
  68 |     | <span class='neutral'>         */</span>
  69 |     | <span class='neutral'>        uint64 _initialized;</span>
  70 |     | <span class='neutral'>        /**</span>
  71 |     | <span class='neutral'>         * @dev Indicates that the contract is in the process of being initialized.</span>
  72 |     | <span class='neutral'>         */</span>
  73 |     | <span class='neutral'>        bool _initializing;</span>
  74 |     | <span class='neutral'>    }</span>
  75 |     | <span class='neutral'></span>
  76 |     | <span class='neutral'>    // keccak256(abi.encode(uint256(keccak256(&quot;openzeppelin.storage.Initializable&quot;)) - 1)) &amp; ~bytes32(uint256(0xff))</span>
  77 |     | <span class='neutral'>    bytes32 private constant INITIALIZABLE_STORAGE = 0xf0c57e16840df040f15088dc2f81fe391c3923bec73e23a9662efc9c229c6a00;</span>
  78 |     | <span class='neutral'></span>
  79 |     | <span class='neutral'>    /**</span>
  80 |     | <span class='neutral'>     * @dev The contract is already initialized.</span>
  81 |     | <span class='neutral'>     */</span>
  82 |     | <span class='neutral'>    error InvalidInitialization();</span>
  83 |     | <span class='neutral'></span>
  84 |     | <span class='neutral'>    /**</span>
  85 |     | <span class='neutral'>     * @dev The contract is not initializing.</span>
  86 |     | <span class='neutral'>     */</span>
  87 |     | <span class='neutral'>    error NotInitializing();</span>
  88 |     | <span class='neutral'></span>
  89 |     | <span class='neutral'>    /**</span>
  90 |     | <span class='neutral'>     * @dev Triggered when the contract has been initialized or reinitialized.</span>
  91 |     | <span class='neutral'>     */</span>
  92 |     | <span class='neutral'>    event Initialized(uint64 version);</span>
  93 |     | <span class='neutral'></span>
  94 |     | <span class='neutral'>    /**</span>
  95 |     | <span class='neutral'>     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,</span>
  96 |     | <span class='neutral'>     * `onlyInitializing` functions can be used to initialize parent contracts.</span>
  97 |     | <span class='neutral'>     *</span>
  98 |     | <span class='neutral'>     * Similar to `reinitializer(1)`, except that in the context of a constructor an `initializer` may be invoked any</span>
  99 |     | <span class='neutral'>     * number of times. This behavior in the constructor can be useful during testing and is not expected to be used in</span>
 100 |     | <span class='neutral'>     * production.</span>
 101 |     | <span class='neutral'>     *</span>
 102 |     | <span class='neutral'>     * Emits an {Initialized} event.</span>
 103 |     | <span class='neutral'>     */</span>
 104 |     | <span class='neutral'>    modifier initializer() {</span>
 105 |     | <span class='neutral'>        // solhint-disable-next-line var-name-mixedcase</span>
 106 |     | <span class='neutral'>        InitializableStorage storage $ = _getInitializableStorage();</span>
 107 |     | <span class='neutral'></span>
 108 |     | <span class='neutral'>        // Cache values to avoid duplicated sloads</span>
 109 |     | <span class='neutral'>        bool isTopLevelCall = !$._initializing;</span>
 110 |     | <span class='neutral'>        uint64 initialized = $._initialized;</span>
 111 |     | <span class='neutral'></span>
 112 |     | <span class='neutral'>        // Allowed calls:</span>
 113 |     | <span class='neutral'>        // - initialSetup: the contract is not in the initializing state and no previous version was</span>
 114 |     | <span class='neutral'>        //                 initialized</span>
 115 |     | <span class='neutral'>        // - construction: the contract is initialized at version 1 (no reinitialization) and the</span>
 116 |     | <span class='neutral'>        //                 current contract is just being deployed</span>
 117 |     | <span class='neutral'>        bool initialSetup = initialized == 0 &amp;&amp; isTopLevelCall;</span>
 118 |     | <span class='neutral'>        bool construction = initialized == 1 &amp;&amp; address(this).code.length == 0;</span>
 119 |     | <span class='neutral'></span>
 120 |     | <span class='neutral'>        if (!initialSetup &amp;&amp; !construction) {</span>
 121 |     | <span class='neutral'>            revert InvalidInitialization();</span>
 122 |     | <span class='neutral'>        }</span>
 123 |     | <span class='neutral'>        $._initialized = 1;</span>
 124 |     | <span class='neutral'>        if (isTopLevelCall) {</span>
 125 |     | <span class='neutral'>            $._initializing = true;</span>
 126 |     | <span class='neutral'>        }</span>
 127 |     | <span class='neutral'>        _;</span>
 128 |     | <span class='neutral'>        if (isTopLevelCall) {</span>
 129 |     | <span class='neutral'>            $._initializing = false;</span>
 130 |     | <span class='neutral'>            emit Initialized(1);</span>
 131 |     | <span class='neutral'>        }</span>
 132 |     | <span class='neutral'>    }</span>
 133 |     | <span class='neutral'></span>
 134 |     | <span class='neutral'>    /**</span>
 135 |     | <span class='neutral'>     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the</span>
 136 |     | <span class='neutral'>     * contract hasn&#39;t been initialized to a greater version before. In its scope, `onlyInitializing` functions can be</span>
 137 |     | <span class='neutral'>     * used to initialize parent contracts.</span>
 138 |     | <span class='neutral'>     *</span>
 139 |     | <span class='neutral'>     * A reinitializer may be used after the original initialization step. This is essential to configure modules that</span>
 140 |     | <span class='neutral'>     * are added through upgrades and that require initialization.</span>
 141 |     | <span class='neutral'>     *</span>
 142 |     | <span class='neutral'>     * When `version` is 1, this modifier is similar to `initializer`, except that functions marked with `reinitializer`</span>
 143 |     | <span class='neutral'>     * cannot be nested. If one is invoked in the context of another, execution will revert.</span>
 144 |     | <span class='neutral'>     *</span>
 145 |     | <span class='neutral'>     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in</span>
 146 |     | <span class='neutral'>     * a contract, executing them in the right order is up to the developer or operator.</span>
 147 |     | <span class='neutral'>     *</span>
 148 |     | <span class='neutral'>     * WARNING: Setting the version to 2**64 - 1 will prevent any future reinitialization.</span>
 149 |     | <span class='neutral'>     *</span>
 150 |     | <span class='neutral'>     * Emits an {Initialized} event.</span>
 151 |     | <span class='neutral'>     */</span>
 152 |     | <span class='neutral'>    modifier reinitializer(uint64 version) {</span>
 153 |     | <span class='neutral'>        // solhint-disable-next-line var-name-mixedcase</span>
 154 |     | <span class='neutral'>        InitializableStorage storage $ = _getInitializableStorage();</span>
 155 |     | <span class='neutral'></span>
 156 |     | <span class='neutral'>        if ($._initializing || $._initialized &gt;= version) {</span>
 157 |     | <span class='neutral'>            revert InvalidInitialization();</span>
 158 |     | <span class='neutral'>        }</span>
 159 |     | <span class='neutral'>        $._initialized = version;</span>
 160 |     | <span class='neutral'>        $._initializing = true;</span>
 161 |     | <span class='neutral'>        _;</span>
 162 |     | <span class='neutral'>        $._initializing = false;</span>
 163 |     | <span class='neutral'>        emit Initialized(version);</span>
 164 |     | <span class='neutral'>    }</span>
 165 |     | <span class='neutral'></span>
 166 |     | <span class='neutral'>    /**</span>
 167 |     | <span class='neutral'>     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the</span>
 168 |     | <span class='neutral'>     * {initializer} and {reinitializer} modifiers, directly or indirectly.</span>
 169 |     | <span class='neutral'>     */</span>
 170 |     | <span class='neutral'>    modifier onlyInitializing() {</span>
 171 |     | <span class='neutral'>        _checkInitializing();</span>
 172 |     | <span class='neutral'>        _;</span>
 173 |     | <span class='neutral'>    }</span>
 174 |     | <span class='neutral'></span>
 175 |     | <span class='neutral'>    /**</span>
 176 |     | <span class='neutral'>     * @dev Reverts if the contract is not in an initializing state. See {onlyInitializing}.</span>
 177 |     | <span class='neutral'>     */</span>
 178 |     | <span class='neutral'>    function _checkInitializing() internal view virtual {</span>
 179 |     | <span class='neutral'>        if (!_isInitializing()) {</span>
 180 |     | <span class='neutral'>            revert NotInitializing();</span>
 181 |     | <span class='neutral'>        }</span>
 182 |     | <span class='neutral'>    }</span>
 183 |     | <span class='neutral'></span>
 184 |     | <span class='neutral'>    /**</span>
 185 |     | <span class='neutral'>     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.</span>
 186 |     | <span class='neutral'>     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized</span>
 187 |     | <span class='neutral'>     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called</span>
 188 |     | <span class='neutral'>     * through proxies.</span>
 189 |     | <span class='neutral'>     *</span>
 190 |     | <span class='neutral'>     * Emits an {Initialized} event the first time it is successfully executed.</span>
 191 |     | <span class='neutral'>     */</span>
 192 |     | <span class='neutral'>    function _disableInitializers() internal virtual {</span>
 193 |     | <span class='neutral'>        // solhint-disable-next-line var-name-mixedcase</span>
 194 |     | <span class='neutral'>        InitializableStorage storage $ = _getInitializableStorage();</span>
 195 |     | <span class='neutral'></span>
 196 |     | <span class='neutral'>        if ($._initializing) {</span>
 197 |     | <span class='neutral'>            revert InvalidInitialization();</span>
 198 |     | <span class='neutral'>        }</span>
 199 |     | <span class='neutral'>        if ($._initialized != type(uint64).max) {</span>
 200 |     | <span class='neutral'>            $._initialized = type(uint64).max;</span>
 201 |     | <span class='neutral'>            emit Initialized(type(uint64).max);</span>
 202 |     | <span class='neutral'>        }</span>
 203 |     | <span class='neutral'>    }</span>
 204 |     | <span class='neutral'></span>
 205 |     | <span class='neutral'>    /**</span>
 206 |     | <span class='neutral'>     * @dev Returns the highest version that has been initialized. See {reinitializer}.</span>
 207 |     | <span class='neutral'>     */</span>
 208 |     | <span class='neutral'>    function _getInitializedVersion() internal view returns (uint64) {</span>
 209 |     | <span class='neutral'>        return _getInitializableStorage()._initialized;</span>
 210 |     | <span class='neutral'>    }</span>
 211 |     | <span class='neutral'></span>
 212 |     | <span class='neutral'>    /**</span>
 213 |     | <span class='neutral'>     * @dev Returns `true` if the contract is currently initializing. See {onlyInitializing}.</span>
 214 |     | <span class='neutral'>     */</span>
 215 |     | <span class='neutral'>    function _isInitializing() internal view returns (bool) {</span>
 216 |     | <span class='neutral'>        return _getInitializableStorage()._initializing;</span>
 217 |     | <span class='neutral'>    }</span>
 218 |     | <span class='neutral'></span>
 219 |     | <span class='neutral'>    /**</span>
 220 |     | <span class='neutral'>     * @dev Pointer to storage slot. Allows integrators to override it with a custom storage location.</span>
 221 |     | <span class='neutral'>     *</span>
 222 |     | <span class='neutral'>     * NOTE: Consider following the ERC-7201 formula to derive storage locations.</span>
 223 |     | <span class='neutral'>     */</span>
 224 |     | <span class='neutral'>    function _initializableStorageSlot() internal pure virtual returns (bytes32) {</span>
 225 |     | <span class='neutral'>        return INITIALIZABLE_STORAGE;</span>
 226 |     | <span class='neutral'>    }</span>
 227 |     | <span class='neutral'></span>
 228 |     | <span class='neutral'>    /**</span>
 229 |     | <span class='neutral'>     * @dev Returns a pointer to the storage namespace.</span>
 230 |     | <span class='neutral'>     */</span>
 231 |     | <span class='neutral'>    // solhint-disable-next-line var-name-mixedcase</span>
 232 |     | <span class='neutral'>    function _getInitializableStorage() private pure returns (InitializableStorage storage $) {</span>
 233 |     | <span class='neutral'>        bytes32 slot = _initializableStorageSlot();</span>
 234 |     | <span class='neutral'>        assembly {</span>
 235 |     | <span class='neutral'>            $.slot := slot</span>
 236 |     | <span class='neutral'>        }</span>
 237 |     | <span class='neutral'>    }</span>
 238 |     | <span class='neutral'>}</span>
 239 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/phantom/Documents/azemora/azemora-contracts/lib/openzeppelin-contracts-upgradeable/contracts/proxy/utils/UUPSUpgradeable.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'>// OpenZeppelin Contracts (last updated v5.3.0) (proxy/utils/UUPSUpgradeable.sol)</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>pragma solidity ^0.8.22;</span>
   5 |     | <span class='neutral'></span>
   6 |     | <span class='neutral'>import {IERC1822Proxiable} from &quot;@openzeppelin/contracts/interfaces/draft-IERC1822.sol&quot;;</span>
   7 |     | <span class='neutral'>import {ERC1967Utils} from &quot;@openzeppelin/contracts/proxy/ERC1967/ERC1967Utils.sol&quot;;</span>
   8 |     | <span class='neutral'>import {Initializable} from &quot;./Initializable.sol&quot;;</span>
   9 |     | <span class='neutral'></span>
  10 |     | <span class='neutral'>/**</span>
  11 |     | <span class='neutral'> * @dev An upgradeability mechanism designed for UUPS proxies. The functions included here can perform an upgrade of an</span>
  12 |     | <span class='neutral'> * {ERC1967Proxy}, when this contract is set as the implementation behind such a proxy.</span>
  13 |     | <span class='neutral'> *</span>
  14 |     | <span class='neutral'> * A security mechanism ensures that an upgrade does not turn off upgradeability accidentally, although this risk is</span>
  15 |     | <span class='neutral'> * reinstated if the upgrade retains upgradeability but removes the security mechanism, e.g. by replacing</span>
  16 |     | <span class='neutral'> * `UUPSUpgradeable` with a custom implementation of upgrades.</span>
  17 |     | <span class='neutral'> *</span>
  18 |     | <span class='neutral'> * The {_authorizeUpgrade} function must be overridden to include access restriction to the upgrade mechanism.</span>
  19 |     | <span class='neutral'> */</span>
  20 |     | <span class='neutral'>abstract contract UUPSUpgradeable is Initializable, IERC1822Proxiable {</span>
  21 |     | <span class='neutral'>    /// @custom:oz-upgrades-unsafe-allow state-variable-immutable</span>
  22 |     | <span class='neutral'>    address private immutable __self = address(this);</span>
  23 |     | <span class='neutral'></span>
  24 |     | <span class='neutral'>    /**</span>
  25 |     | <span class='neutral'>     * @dev The version of the upgrade interface of the contract. If this getter is missing, both `upgradeTo(address)`</span>
  26 |     | <span class='neutral'>     * and `upgradeToAndCall(address,bytes)` are present, and `upgradeTo` must be used if no function should be called,</span>
  27 |     | <span class='neutral'>     * while `upgradeToAndCall` will invoke the `receive` function if the second argument is the empty byte string.</span>
  28 |     | <span class='unexecuted'>     * If the getter returns `&quot;5.0.0&quot;`, only `upgradeToAndCall(address,bytes)` is present, and the second argument must</span>
  29 |     | <span class='neutral'>     * be the empty byte string if no function should be called, making it impossible to invoke the `receive` function</span>
  30 |     | <span class='neutral'>     * during an upgrade.</span>
  31 |     | <span class='neutral'>     */</span>
  32 |     | <span class='neutral'>    string public constant UPGRADE_INTERFACE_VERSION = &quot;5.0.0&quot;;</span>
  33 |     | <span class='neutral'></span>
  34 |     | <span class='neutral'>    /**</span>
  35 |     | <span class='neutral'>     * @dev The call is from an unauthorized context.</span>
  36 |     | <span class='neutral'>     */</span>
  37 |     | <span class='neutral'>    error UUPSUnauthorizedCallContext();</span>
  38 |     | <span class='neutral'></span>
  39 |     | <span class='neutral'>    /**</span>
  40 |     | <span class='neutral'>     * @dev The storage `slot` is unsupported as a UUID.</span>
  41 |     | <span class='neutral'>     */</span>
  42 |     | <span class='neutral'>    error UUPSUnsupportedProxiableUUID(bytes32 slot);</span>
  43 |     | <span class='neutral'></span>
  44 |     | <span class='neutral'>    /**</span>
  45 |     | <span class='neutral'>     * @dev Check that the execution is being performed through a delegatecall call and that the execution context is</span>
  46 |     | <span class='neutral'>     * a proxy contract with an implementation (as defined in ERC-1967) pointing to self. This should only be the case</span>
  47 |     | <span class='neutral'>     * for UUPS and transparent proxies that are using the current contract as their implementation. Execution of a</span>
  48 |     | <span class='neutral'>     * function through ERC-1167 minimal proxies (clones) would not normally pass this test, but is not guaranteed to</span>
  49 |     | <span class='neutral'>     * fail.</span>
  50 |     | <span class='neutral'>     */</span>
  51 |     | <span class='neutral'>    modifier onlyProxy() {</span>
  52 |     | <span class='neutral'>        _checkProxy();</span>
  53 |     | <span class='neutral'>        _;</span>
  54 |     | <span class='neutral'>    }</span>
  55 |     | <span class='neutral'></span>
  56 |     | <span class='neutral'>    /**</span>
  57 |     | <span class='neutral'>     * @dev Check that the execution is not being performed through a delegate call. This allows a function to be</span>
  58 |     | <span class='neutral'>     * callable on the implementing contract but not through proxies.</span>
  59 |     | <span class='neutral'>     */</span>
  60 |     | <span class='neutral'>    modifier notDelegated() {</span>
  61 |     | <span class='neutral'>        _checkNotDelegated();</span>
  62 |     | <span class='neutral'>        _;</span>
  63 |     | <span class='neutral'>    }</span>
  64 |     | <span class='neutral'></span>
  65 |     | <span class='neutral'>    function __UUPSUpgradeable_init() internal onlyInitializing {</span>
  66 |     | <span class='neutral'>    }</span>
  67 |     | <span class='neutral'></span>
  68 |     | <span class='neutral'>    function __UUPSUpgradeable_init_unchained() internal onlyInitializing {</span>
  69 |     | <span class='neutral'>    }</span>
  70 |     | <span class='neutral'>    /**</span>
  71 |     | <span class='neutral'>     * @dev Implementation of the ERC-1822 {proxiableUUID} function. This returns the storage slot used by the</span>
  72 |     | <span class='neutral'>     * implementation. It is used to validate the implementation&#39;s compatibility when performing an upgrade.</span>
  73 |     | <span class='neutral'>     *</span>
  74 |     | <span class='neutral'>     * IMPORTANT: A proxy pointing at a proxiable contract should not be considered proxiable itself, because this risks</span>
  75 |     | <span class='neutral'>     * bricking a proxy that upgrades to it, by delegating to itself until out of gas. Thus it is critical that this</span>
  76 |     | <span class='neutral'>     * function revert if invoked through a proxy. This is guaranteed by the `notDelegated` modifier.</span>
  77 |     | <span class='neutral'>     */</span>
  78 |     | <span class='neutral'>    function proxiableUUID() external view virtual notDelegated returns (bytes32) {</span>
  79 |     | <span class='neutral'>        return ERC1967Utils.IMPLEMENTATION_SLOT;</span>
  80 |     | <span class='neutral'>    }</span>
  81 |     | <span class='neutral'></span>
  82 |     | <span class='neutral'>    /**</span>
  83 |     | <span class='neutral'>     * @dev Upgrade the implementation of the proxy to `newImplementation`, and subsequently execute the function call</span>
  84 |     | <span class='neutral'>     * encoded in `data`.</span>
  85 |     | <span class='neutral'>     *</span>
  86 |     | <span class='neutral'>     * Calls {_authorizeUpgrade}.</span>
  87 |     | <span class='neutral'>     *</span>
  88 |     | <span class='neutral'>     * Emits an {Upgraded} event.</span>
  89 |     | <span class='neutral'>     *</span>
  90 |     | <span class='neutral'>     * @custom:oz-upgrades-unsafe-allow-reachable delegatecall</span>
  91 |     | <span class='neutral'>     */</span>
  92 |     | <span class='neutral'>    function upgradeToAndCall(address newImplementation, bytes memory data) public payable virtual onlyProxy {</span>
  93 |     | <span class='neutral'>        _authorizeUpgrade(newImplementation);</span>
  94 |     | <span class='neutral'>        _upgradeToAndCallUUPS(newImplementation, data);</span>
  95 |     | <span class='neutral'>    }</span>
  96 |     | <span class='neutral'></span>
  97 |     | <span class='neutral'>    /**</span>
  98 |     | <span class='neutral'>     * @dev Reverts if the execution is not performed via delegatecall or the execution</span>
  99 |     | <span class='neutral'>     * context is not of a proxy with an ERC-1967 compliant implementation pointing to self.</span>
 100 |     | <span class='neutral'>     */</span>
 101 |     | <span class='neutral'>    function _checkProxy() internal view virtual {</span>
 102 |     | <span class='neutral'>        if (</span>
 103 |     | <span class='neutral'>            address(this) == __self || // Must be called through delegatecall</span>
 104 |     | <span class='neutral'>            ERC1967Utils.getImplementation() != __self // Must be called through an active proxy</span>
 105 |     | <span class='neutral'>        ) {</span>
 106 |     | <span class='neutral'>            revert UUPSUnauthorizedCallContext();</span>
 107 |     | <span class='neutral'>        }</span>
 108 |     | <span class='neutral'>    }</span>
 109 |     | <span class='neutral'></span>
 110 |     | <span class='neutral'>    /**</span>
 111 |     | <span class='neutral'>     * @dev Reverts if the execution is performed via delegatecall.</span>
 112 |     | <span class='neutral'>     * See {notDelegated}.</span>
 113 |     | <span class='neutral'>     */</span>
 114 |     | <span class='neutral'>    function _checkNotDelegated() internal view virtual {</span>
 115 |     | <span class='neutral'>        if (address(this) != __self) {</span>
 116 |     | <span class='neutral'>            // Must not be called through delegatecall</span>
 117 |     | <span class='neutral'>            revert UUPSUnauthorizedCallContext();</span>
 118 |     | <span class='neutral'>        }</span>
 119 |     | <span class='neutral'>    }</span>
 120 |     | <span class='neutral'></span>
 121 |     | <span class='neutral'>    /**</span>
 122 |     | <span class='neutral'>     * @dev Function that should revert when `msg.sender` is not authorized to upgrade the contract. Called by</span>
 123 |     | <span class='neutral'>     * {upgradeToAndCall}.</span>
 124 |     | <span class='neutral'>     *</span>
 125 |     | <span class='neutral'>     * Normally, this function will use an xref:access.adoc[access control] modifier such as {Ownable-onlyOwner}.</span>
 126 |     | <span class='neutral'>     *</span>
 127 |     | <span class='neutral'>     * ```solidity</span>
 128 |     | <span class='neutral'>     * function _authorizeUpgrade(address) internal onlyOwner {}</span>
 129 |     | <span class='neutral'>     * ```</span>
 130 |     | <span class='neutral'>     */</span>
 131 |     | <span class='neutral'>    function _authorizeUpgrade(address newImplementation) internal virtual;</span>
 132 |     | <span class='neutral'></span>
 133 |     | <span class='neutral'>    /**</span>
 134 |     | <span class='neutral'>     * @dev Performs an implementation upgrade with a security check for UUPS proxies, and additional setup call.</span>
 135 |     | <span class='neutral'>     *</span>
 136 |     | <span class='neutral'>     * As a security check, {proxiableUUID} is invoked in the new implementation, and the return value</span>
 137 |     | <span class='neutral'>     * is expected to be the implementation slot in ERC-1967.</span>
 138 |     | <span class='neutral'>     *</span>
 139 |     | <span class='neutral'>     * Emits an {IERC1967-Upgraded} event.</span>
 140 |     | <span class='neutral'>     */</span>
 141 |     | <span class='neutral'>    function _upgradeToAndCallUUPS(address newImplementation, bytes memory data) private {</span>
 142 |     | <span class='neutral'>        try IERC1822Proxiable(newImplementation).proxiableUUID() returns (bytes32 slot) {</span>
 143 |     | <span class='neutral'>            if (slot != ERC1967Utils.IMPLEMENTATION_SLOT) {</span>
 144 |     | <span class='neutral'>                revert UUPSUnsupportedProxiableUUID(slot);</span>
 145 |     | <span class='neutral'>            }</span>
 146 |     | <span class='neutral'>            ERC1967Utils.upgradeToAndCall(newImplementation, data);</span>
 147 |     | <span class='neutral'>        } catch {</span>
 148 |     | <span class='neutral'>            // The implementation is not UUPS</span>
 149 |     | <span class='neutral'>            revert ERC1967Utils.ERC1967InvalidImplementation(newImplementation);</span>
 150 |     | <span class='neutral'>        }</span>
 151 |     | <span class='neutral'>    }</span>
 152 |     | <span class='neutral'>}</span>
 153 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/phantom/Documents/azemora/azemora-contracts/lib/openzeppelin-contracts-upgradeable/contracts/token/ERC1155/ERC1155Upgradeable.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'>// OpenZeppelin Contracts (last updated v5.1.0) (token/ERC1155/ERC1155.sol)</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>pragma solidity ^0.8.20;</span>
   5 |     | <span class='neutral'></span>
   6 |     | <span class='neutral'>import {IERC1155} from &quot;@openzeppelin/contracts/token/ERC1155/IERC1155.sol&quot;;</span>
   7 |     | <span class='neutral'>import {IERC1155MetadataURI} from &quot;@openzeppelin/contracts/token/ERC1155/extensions/IERC1155MetadataURI.sol&quot;;</span>
   8 |     | <span class='neutral'>import {ERC1155Utils} from &quot;@openzeppelin/contracts/token/ERC1155/utils/ERC1155Utils.sol&quot;;</span>
   9 |     | <span class='neutral'>import {ContextUpgradeable} from &quot;../../utils/ContextUpgradeable.sol&quot;;</span>
  10 |     | <span class='neutral'>import {IERC165} from &quot;@openzeppelin/contracts/utils/introspection/IERC165.sol&quot;;</span>
  11 |     | <span class='neutral'>import {ERC165Upgradeable} from &quot;../../utils/introspection/ERC165Upgradeable.sol&quot;;</span>
  12 |     | <span class='neutral'>import {Arrays} from &quot;@openzeppelin/contracts/utils/Arrays.sol&quot;;</span>
  13 |     | <span class='neutral'>import {IERC1155Errors} from &quot;@openzeppelin/contracts/interfaces/draft-IERC6093.sol&quot;;</span>
  14 |     | <span class='neutral'>import {Initializable} from &quot;../../proxy/utils/Initializable.sol&quot;;</span>
  15 |     | <span class='neutral'></span>
  16 |     | <span class='neutral'>/**</span>
  17 |     | <span class='neutral'> * @dev Implementation of the basic standard multi-token.</span>
  18 |     | <span class='neutral'> * See https://eips.ethereum.org/EIPS/eip-1155</span>
  19 |     | <span class='neutral'> * Originally based on code by Enjin: https://github.com/enjin/erc-1155</span>
  20 |     | <span class='neutral'> */</span>
  21 |     | <span class='neutral'>abstract contract ERC1155Upgradeable is Initializable, ContextUpgradeable, ERC165Upgradeable, IERC1155, IERC1155MetadataURI, IERC1155Errors {</span>
  22 |     | <span class='neutral'>    using Arrays for uint256[];</span>
  23 |     | <span class='neutral'>    using Arrays for address[];</span>
  24 |     | <span class='neutral'></span>
  25 |     | <span class='neutral'>    /// @custom:storage-location erc7201:openzeppelin.storage.ERC1155</span>
  26 |     | <span class='neutral'>    struct ERC1155Storage {</span>
  27 |     | <span class='unexecuted'>        mapping(uint256 id =&gt; mapping(address account =&gt; uint256)) _balances;</span>
  28 |     | <span class='neutral'></span>
  29 |     | <span class='neutral'>        mapping(address account =&gt; mapping(address operator =&gt; bool)) _operatorApprovals;</span>
  30 |     | <span class='neutral'></span>
  31 |     | <span class='neutral'>        // Used as the URI for all token types by relying on ID substitution, e.g. https://token-cdn-domain/{id}.json</span>
  32 |     | <span class='neutral'>        string _uri;</span>
  33 |     | <span class='neutral'>    }</span>
  34 |     | <span class='neutral'></span>
  35 |     | <span class='neutral'>    // keccak256(abi.encode(uint256(keccak256(&quot;openzeppelin.storage.ERC1155&quot;)) - 1)) &amp; ~bytes32(uint256(0xff))</span>
  36 |     | <span class='neutral'>    bytes32 private constant ERC1155StorageLocation = 0x88be536d5240c274a3b1d3a1be54482fd9caa294f08c62a7cde569f49a3c4500;</span>
  37 |     | <span class='neutral'></span>
  38 |     | <span class='neutral'>    function _getERC1155Storage() private pure returns (ERC1155Storage storage $) {</span>
  39 |     | <span class='neutral'>        assembly {</span>
  40 |     | <span class='neutral'>            $.slot := ERC1155StorageLocation</span>
  41 |     | <span class='neutral'>        }</span>
  42 |     | <span class='neutral'>    }</span>
  43 |     | <span class='neutral'></span>
  44 |     | <span class='neutral'>    /**</span>
  45 |     | <span class='neutral'>     * @dev See {_setURI}.</span>
  46 |     | <span class='neutral'>     */</span>
  47 |     | <span class='neutral'>    function __ERC1155_init(string memory uri_) internal onlyInitializing {</span>
  48 |     | <span class='neutral'>        __ERC1155_init_unchained(uri_);</span>
  49 |     | <span class='neutral'>    }</span>
  50 |     | <span class='neutral'></span>
  51 |     | <span class='neutral'>    function __ERC1155_init_unchained(string memory uri_) internal onlyInitializing {</span>
  52 |     | <span class='neutral'>        _setURI(uri_);</span>
  53 |     | <span class='neutral'>    }</span>
  54 |     | <span class='neutral'></span>
  55 |     | <span class='neutral'>    /// @inheritdoc IERC165</span>
  56 |     | <span class='neutral'>    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165Upgradeable, IERC165) returns (bool) {</span>
  57 |     | <span class='neutral'>        return</span>
  58 |     | <span class='neutral'>            interfaceId == type(IERC1155).interfaceId ||</span>
  59 |     | <span class='neutral'>            interfaceId == type(IERC1155MetadataURI).interfaceId ||</span>
  60 |     | <span class='neutral'>            super.supportsInterface(interfaceId);</span>
  61 |     | <span class='neutral'>    }</span>
  62 |     | <span class='neutral'></span>
  63 |     | <span class='neutral'>    /**</span>
  64 |     | <span class='neutral'>     * @dev See {IERC1155MetadataURI-uri}.</span>
  65 |     | <span class='neutral'>     *</span>
  66 |     | <span class='neutral'>     * This implementation returns the same URI for *all* token types. It relies</span>
  67 |     | <span class='neutral'>     * on the token type ID substitution mechanism</span>
  68 |     | <span class='neutral'>     * https://eips.ethereum.org/EIPS/eip-1155#metadata[defined in the ERC].</span>
  69 |     | <span class='neutral'>     *</span>
  70 |     | <span class='neutral'>     * Clients calling this function must replace the `\{id\}` substring with the</span>
  71 |     | <span class='neutral'>     * actual token type ID.</span>
  72 |     | <span class='neutral'>     */</span>
  73 |     | <span class='neutral'>    function uri(uint256 /* id */) public view virtual returns (string memory) {</span>
  74 |     | <span class='neutral'>        ERC1155Storage storage $ = _getERC1155Storage();</span>
  75 |     | <span class='neutral'>        return $._uri;</span>
  76 |     | <span class='neutral'>    }</span>
  77 |     | <span class='neutral'></span>
  78 |     | <span class='neutral'>    /// @inheritdoc IERC1155</span>
  79 |     | <span class='neutral'>    function balanceOf(address account, uint256 id) public view virtual returns (uint256) {</span>
  80 |     | <span class='neutral'>        ERC1155Storage storage $ = _getERC1155Storage();</span>
  81 |     | <span class='neutral'>        return $._balances[id][account];</span>
  82 |     | <span class='neutral'>    }</span>
  83 |     | <span class='neutral'></span>
  84 |     | <span class='neutral'>    /**</span>
  85 |     | <span class='neutral'>     * @dev See {IERC1155-balanceOfBatch}.</span>
  86 |     | <span class='neutral'>     *</span>
  87 |     | <span class='neutral'>     * Requirements:</span>
  88 |     | <span class='neutral'>     *</span>
  89 |     | <span class='neutral'>     * - `accounts` and `ids` must have the same length.</span>
  90 |     | <span class='neutral'>     */</span>
  91 |     | <span class='neutral'>    function balanceOfBatch(</span>
  92 |     | <span class='neutral'>        address[] memory accounts,</span>
  93 |     | <span class='neutral'>        uint256[] memory ids</span>
  94 |     | <span class='neutral'>    ) public view virtual returns (uint256[] memory) {</span>
  95 |     | <span class='neutral'>        if (accounts.length != ids.length) {</span>
  96 |     | <span class='neutral'>            revert ERC1155InvalidArrayLength(ids.length, accounts.length);</span>
  97 |     | <span class='neutral'>        }</span>
  98 |     | <span class='neutral'></span>
  99 |     | <span class='neutral'>        uint256[] memory batchBalances = new uint256[](accounts.length);</span>
 100 |     | <span class='neutral'></span>
 101 |     | <span class='neutral'>        for (uint256 i = 0; i &lt; accounts.length; ++i) {</span>
 102 |     | <span class='neutral'>            batchBalances[i] = balanceOf(accounts.unsafeMemoryAccess(i), ids.unsafeMemoryAccess(i));</span>
 103 |     | <span class='neutral'>        }</span>
 104 |     | <span class='neutral'></span>
 105 |     | <span class='neutral'>        return batchBalances;</span>
 106 |     | <span class='neutral'>    }</span>
 107 |     | <span class='neutral'></span>
 108 |     | <span class='neutral'>    /// @inheritdoc IERC1155</span>
 109 |     | <span class='neutral'>    function setApprovalForAll(address operator, bool approved) public virtual {</span>
 110 |     | <span class='neutral'>        _setApprovalForAll(_msgSender(), operator, approved);</span>
 111 |     | <span class='neutral'>    }</span>
 112 |     | <span class='neutral'></span>
 113 |     | <span class='neutral'>    /// @inheritdoc IERC1155</span>
 114 |     | <span class='neutral'>    function isApprovedForAll(address account, address operator) public view virtual returns (bool) {</span>
 115 |     | <span class='neutral'>        ERC1155Storage storage $ = _getERC1155Storage();</span>
 116 |     | <span class='neutral'>        return $._operatorApprovals[account][operator];</span>
 117 |     | <span class='neutral'>    }</span>
 118 |     | <span class='neutral'></span>
 119 |     | <span class='neutral'>    /// @inheritdoc IERC1155</span>
 120 |     | <span class='neutral'>    function safeTransferFrom(address from, address to, uint256 id, uint256 value, bytes memory data) public virtual {</span>
 121 |     | <span class='neutral'>        address sender = _msgSender();</span>
 122 |     | <span class='neutral'>        if (from != sender &amp;&amp; !isApprovedForAll(from, sender)) {</span>
 123 |     | <span class='neutral'>            revert ERC1155MissingApprovalForAll(sender, from);</span>
 124 |     | <span class='neutral'>        }</span>
 125 |     | <span class='neutral'>        _safeTransferFrom(from, to, id, value, data);</span>
 126 |     | <span class='neutral'>    }</span>
 127 |     | <span class='neutral'></span>
 128 |     | <span class='neutral'>    /// @inheritdoc IERC1155</span>
 129 |     | <span class='neutral'>    function safeBatchTransferFrom(</span>
 130 |     | <span class='neutral'>        address from,</span>
 131 |     | <span class='neutral'>        address to,</span>
 132 |     | <span class='neutral'>        uint256[] memory ids,</span>
 133 |     | <span class='neutral'>        uint256[] memory values,</span>
 134 |     | <span class='neutral'>        bytes memory data</span>
 135 |     | <span class='neutral'>    ) public virtual {</span>
 136 |     | <span class='neutral'>        address sender = _msgSender();</span>
 137 |     | <span class='neutral'>        if (from != sender &amp;&amp; !isApprovedForAll(from, sender)) {</span>
 138 |     | <span class='neutral'>            revert ERC1155MissingApprovalForAll(sender, from);</span>
 139 |     | <span class='neutral'>        }</span>
 140 |     | <span class='neutral'>        _safeBatchTransferFrom(from, to, ids, values, data);</span>
 141 |     | <span class='neutral'>    }</span>
 142 |     | <span class='neutral'></span>
 143 |     | <span class='neutral'>    /**</span>
 144 |     | <span class='neutral'>     * @dev Transfers a `value` amount of tokens of type `id` from `from` to `to`. Will mint (or burn) if `from`</span>
 145 |     | <span class='neutral'>     * (or `to`) is the zero address.</span>
 146 |     | <span class='neutral'>     *</span>
 147 |     | <span class='neutral'>     * Emits a {TransferSingle} event if the arrays contain one element, and {TransferBatch} otherwise.</span>
 148 |     | <span class='neutral'>     *</span>
 149 |     | <span class='neutral'>     * Requirements:</span>
 150 |     | <span class='neutral'>     *</span>
 151 |     | <span class='neutral'>     * - If `to` refers to a smart contract, it must implement either {IERC1155Receiver-onERC1155Received}</span>
 152 |     | <span class='neutral'>     *   or {IERC1155Receiver-onERC1155BatchReceived} and return the acceptance magic value.</span>
 153 |     | <span class='neutral'>     * - `ids` and `values` must have the same length.</span>
 154 |     | <span class='neutral'>     *</span>
 155 |     | <span class='neutral'>     * NOTE: The ERC-1155 acceptance check is not performed in this function. See {_updateWithAcceptanceCheck} instead.</span>
 156 |     | <span class='neutral'>     */</span>
 157 |     | <span class='neutral'>    function _update(address from, address to, uint256[] memory ids, uint256[] memory values) internal virtual {</span>
 158 |     | <span class='neutral'>        ERC1155Storage storage $ = _getERC1155Storage();</span>
 159 |     | <span class='neutral'>        if (ids.length != values.length) {</span>
 160 |     | <span class='neutral'>            revert ERC1155InvalidArrayLength(ids.length, values.length);</span>
 161 |     | <span class='neutral'>        }</span>
 162 |     | <span class='neutral'></span>
 163 |     | <span class='neutral'>        address operator = _msgSender();</span>
 164 |     | <span class='neutral'></span>
 165 |     | <span class='neutral'>        for (uint256 i = 0; i &lt; ids.length; ++i) {</span>
 166 |     | <span class='neutral'>            uint256 id = ids.unsafeMemoryAccess(i);</span>
 167 |     | <span class='neutral'>            uint256 value = values.unsafeMemoryAccess(i);</span>
 168 |     | <span class='neutral'></span>
 169 |     | <span class='neutral'>            if (from != address(0)) {</span>
 170 |     | <span class='neutral'>                uint256 fromBalance = $._balances[id][from];</span>
 171 |     | <span class='neutral'>                if (fromBalance &lt; value) {</span>
 172 |     | <span class='neutral'>                    revert ERC1155InsufficientBalance(from, fromBalance, value, id);</span>
 173 |     | <span class='neutral'>                }</span>
 174 |     | <span class='neutral'>                unchecked {</span>
 175 |     | <span class='neutral'>                    // Overflow not possible: value &lt;= fromBalance</span>
 176 |     | <span class='neutral'>                    $._balances[id][from] = fromBalance - value;</span>
 177 |     | <span class='neutral'>                }</span>
 178 |     | <span class='neutral'>            }</span>
 179 |     | <span class='neutral'></span>
 180 |     | <span class='neutral'>            if (to != address(0)) {</span>
 181 |     | <span class='neutral'>                $._balances[id][to] += value;</span>
 182 |     | <span class='neutral'>            }</span>
 183 |     | <span class='neutral'>        }</span>
 184 |     | <span class='neutral'></span>
 185 |     | <span class='neutral'>        if (ids.length == 1) {</span>
 186 |     | <span class='neutral'>            uint256 id = ids.unsafeMemoryAccess(0);</span>
 187 |     | <span class='neutral'>            uint256 value = values.unsafeMemoryAccess(0);</span>
 188 |     | <span class='neutral'>            emit TransferSingle(operator, from, to, id, value);</span>
 189 |     | <span class='neutral'>        } else {</span>
 190 |     | <span class='neutral'>            emit TransferBatch(operator, from, to, ids, values);</span>
 191 |     | <span class='neutral'>        }</span>
 192 |     | <span class='neutral'>    }</span>
 193 |     | <span class='neutral'></span>
 194 |     | <span class='neutral'>    /**</span>
 195 |     | <span class='neutral'>     * @dev Version of {_update} that performs the token acceptance check by calling</span>
 196 |     | <span class='neutral'>     * {IERC1155Receiver-onERC1155Received} or {IERC1155Receiver-onERC1155BatchReceived} on the receiver address if it</span>
 197 |     | <span class='neutral'>     * contains code (eg. is a smart contract at the moment of execution).</span>
 198 |     | <span class='neutral'>     *</span>
 199 |     | <span class='neutral'>     * IMPORTANT: Overriding this function is discouraged because it poses a reentrancy risk from the receiver. So any</span>
 200 |     | <span class='neutral'>     * update to the contract state after this function would break the check-effect-interaction pattern. Consider</span>
 201 |     | <span class='neutral'>     * overriding {_update} instead.</span>
 202 |     | <span class='neutral'>     */</span>
 203 |     | <span class='neutral'>    function _updateWithAcceptanceCheck(</span>
 204 |     | <span class='neutral'>        address from,</span>
 205 |     | <span class='neutral'>        address to,</span>
 206 |     | <span class='neutral'>        uint256[] memory ids,</span>
 207 |     | <span class='neutral'>        uint256[] memory values,</span>
 208 |     | <span class='neutral'>        bytes memory data</span>
 209 |     | <span class='neutral'>    ) internal virtual {</span>
 210 |     | <span class='neutral'>        _update(from, to, ids, values);</span>
 211 |     | <span class='neutral'>        if (to != address(0)) {</span>
 212 |     | <span class='neutral'>            address operator = _msgSender();</span>
 213 |     | <span class='neutral'>            if (ids.length == 1) {</span>
 214 |     | <span class='neutral'>                uint256 id = ids.unsafeMemoryAccess(0);</span>
 215 |     | <span class='neutral'>                uint256 value = values.unsafeMemoryAccess(0);</span>
 216 |     | <span class='neutral'>                ERC1155Utils.checkOnERC1155Received(operator, from, to, id, value, data);</span>
 217 |     | <span class='neutral'>            } else {</span>
 218 |     | <span class='neutral'>                ERC1155Utils.checkOnERC1155BatchReceived(operator, from, to, ids, values, data);</span>
 219 |     | <span class='neutral'>            }</span>
 220 |     | <span class='neutral'>        }</span>
 221 |     | <span class='neutral'>    }</span>
 222 |     | <span class='neutral'></span>
 223 |     | <span class='neutral'>    /**</span>
 224 |     | <span class='neutral'>     * @dev Transfers a `value` tokens of token type `id` from `from` to `to`.</span>
 225 |     | <span class='neutral'>     *</span>
 226 |     | <span class='neutral'>     * Emits a {TransferSingle} event.</span>
 227 |     | <span class='neutral'>     *</span>
 228 |     | <span class='neutral'>     * Requirements:</span>
 229 |     | <span class='neutral'>     *</span>
 230 |     | <span class='neutral'>     * - `to` cannot be the zero address.</span>
 231 |     | <span class='neutral'>     * - `from` must have a balance of tokens of type `id` of at least `value` amount.</span>
 232 |     | <span class='neutral'>     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the</span>
 233 |     | <span class='neutral'>     * acceptance magic value.</span>
 234 |     | <span class='neutral'>     */</span>
 235 |     | <span class='neutral'>    function _safeTransferFrom(address from, address to, uint256 id, uint256 value, bytes memory data) internal {</span>
 236 |     | <span class='neutral'>        if (to == address(0)) {</span>
 237 |     | <span class='neutral'>            revert ERC1155InvalidReceiver(address(0));</span>
 238 |     | <span class='neutral'>        }</span>
 239 |     | <span class='neutral'>        if (from == address(0)) {</span>
 240 |     | <span class='neutral'>            revert ERC1155InvalidSender(address(0));</span>
 241 |     | <span class='neutral'>        }</span>
 242 |     | <span class='neutral'>        (uint256[] memory ids, uint256[] memory values) = _asSingletonArrays(id, value);</span>
 243 |     | <span class='neutral'>        _updateWithAcceptanceCheck(from, to, ids, values, data);</span>
 244 |     | <span class='neutral'>    }</span>
 245 |     | <span class='neutral'></span>
 246 |     | <span class='neutral'>    /**</span>
 247 |     | <span class='neutral'>     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {_safeTransferFrom}.</span>
 248 |     | <span class='neutral'>     *</span>
 249 |     | <span class='neutral'>     * Emits a {TransferBatch} event.</span>
 250 |     | <span class='neutral'>     *</span>
 251 |     | <span class='neutral'>     * Requirements:</span>
 252 |     | <span class='neutral'>     *</span>
 253 |     | <span class='neutral'>     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the</span>
 254 |     | <span class='neutral'>     * acceptance magic value.</span>
 255 |     | <span class='neutral'>     * - `ids` and `values` must have the same length.</span>
 256 |     | <span class='neutral'>     */</span>
 257 |     | <span class='neutral'>    function _safeBatchTransferFrom(</span>
 258 |     | <span class='neutral'>        address from,</span>
 259 |     | <span class='neutral'>        address to,</span>
 260 |     | <span class='neutral'>        uint256[] memory ids,</span>
 261 |     | <span class='neutral'>        uint256[] memory values,</span>
 262 |     | <span class='neutral'>        bytes memory data</span>
 263 |     | <span class='neutral'>    ) internal {</span>
 264 |     | <span class='neutral'>        if (to == address(0)) {</span>
 265 |     | <span class='neutral'>            revert ERC1155InvalidReceiver(address(0));</span>
 266 |     | <span class='neutral'>        }</span>
 267 |     | <span class='neutral'>        if (from == address(0)) {</span>
 268 |     | <span class='neutral'>            revert ERC1155InvalidSender(address(0));</span>
 269 |     | <span class='neutral'>        }</span>
 270 |     | <span class='neutral'>        _updateWithAcceptanceCheck(from, to, ids, values, data);</span>
 271 |     | <span class='neutral'>    }</span>
 272 |     | <span class='neutral'></span>
 273 |     | <span class='neutral'>    /**</span>
 274 |     | <span class='neutral'>     * @dev Sets a new URI for all token types, by relying on the token type ID</span>
 275 |     | <span class='neutral'>     * substitution mechanism</span>
 276 |     | <span class='neutral'>     * https://eips.ethereum.org/EIPS/eip-1155#metadata[defined in the ERC].</span>
 277 |     | <span class='neutral'>     *</span>
 278 |     | <span class='neutral'>     * By this mechanism, any occurrence of the `\{id\}` substring in either the</span>
 279 |     | <span class='neutral'>     * URI or any of the values in the JSON file at said URI will be replaced by</span>
 280 |     | <span class='neutral'>     * clients with the token type ID.</span>
 281 |     | <span class='neutral'>     *</span>
 282 |     | <span class='neutral'>     * For example, the `https://token-cdn-domain/\{id\}.json` URI would be</span>
 283 |     | <span class='neutral'>     * interpreted by clients as</span>
 284 |     | <span class='neutral'>     * `https://token-cdn-domain/000000000000000000000000000000000000000000000000000000000004cce0.json`</span>
 285 |     | <span class='neutral'>     * for token type ID 0x4cce0.</span>
 286 |     | <span class='neutral'>     *</span>
 287 |     | <span class='neutral'>     * See {uri}.</span>
 288 |     | <span class='neutral'>     *</span>
 289 |     | <span class='neutral'>     * Because these URIs cannot be meaningfully represented by the {URI} event,</span>
 290 |     | <span class='neutral'>     * this function emits no events.</span>
 291 |     | <span class='neutral'>     */</span>
 292 |     | <span class='neutral'>    function _setURI(string memory newuri) internal virtual {</span>
 293 |     | <span class='neutral'>        ERC1155Storage storage $ = _getERC1155Storage();</span>
 294 |     | <span class='neutral'>        $._uri = newuri;</span>
 295 |     | <span class='neutral'>    }</span>
 296 |     | <span class='neutral'></span>
 297 |     | <span class='neutral'>    /**</span>
 298 |     | <span class='neutral'>     * @dev Creates a `value` amount of tokens of type `id`, and assigns them to `to`.</span>
 299 |     | <span class='neutral'>     *</span>
 300 |     | <span class='neutral'>     * Emits a {TransferSingle} event.</span>
 301 |     | <span class='neutral'>     *</span>
 302 |     | <span class='neutral'>     * Requirements:</span>
 303 |     | <span class='neutral'>     *</span>
 304 |     | <span class='neutral'>     * - `to` cannot be the zero address.</span>
 305 |     | <span class='neutral'>     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the</span>
 306 |     | <span class='neutral'>     * acceptance magic value.</span>
 307 |     | <span class='neutral'>     */</span>
 308 |     | <span class='neutral'>    function _mint(address to, uint256 id, uint256 value, bytes memory data) internal {</span>
 309 |     | <span class='neutral'>        if (to == address(0)) {</span>
 310 |     | <span class='neutral'>            revert ERC1155InvalidReceiver(address(0));</span>
 311 |     | <span class='neutral'>        }</span>
 312 |     | <span class='neutral'>        (uint256[] memory ids, uint256[] memory values) = _asSingletonArrays(id, value);</span>
 313 |     | <span class='neutral'>        _updateWithAcceptanceCheck(address(0), to, ids, values, data);</span>
 314 |     | <span class='neutral'>    }</span>
 315 |     | <span class='neutral'></span>
 316 |     | <span class='neutral'>    /**</span>
 317 |     | <span class='neutral'>     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {_mint}.</span>
 318 |     | <span class='neutral'>     *</span>
 319 |     | <span class='neutral'>     * Emits a {TransferBatch} event.</span>
 320 |     | <span class='neutral'>     *</span>
 321 |     | <span class='neutral'>     * Requirements:</span>
 322 |     | <span class='neutral'>     *</span>
 323 |     | <span class='neutral'>     * - `ids` and `values` must have the same length.</span>
 324 |     | <span class='neutral'>     * - `to` cannot be the zero address.</span>
 325 |     | <span class='neutral'>     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the</span>
 326 |     | <span class='neutral'>     * acceptance magic value.</span>
 327 |     | <span class='neutral'>     */</span>
 328 |     | <span class='neutral'>    function _mintBatch(address to, uint256[] memory ids, uint256[] memory values, bytes memory data) internal {</span>
 329 |     | <span class='neutral'>        if (to == address(0)) {</span>
 330 |     | <span class='neutral'>            revert ERC1155InvalidReceiver(address(0));</span>
 331 |     | <span class='neutral'>        }</span>
 332 |     | <span class='neutral'>        _updateWithAcceptanceCheck(address(0), to, ids, values, data);</span>
 333 |     | <span class='neutral'>    }</span>
 334 |     | <span class='neutral'></span>
 335 |     | <span class='neutral'>    /**</span>
 336 |     | <span class='neutral'>     * @dev Destroys a `value` amount of tokens of type `id` from `from`</span>
 337 |     | <span class='neutral'>     *</span>
 338 |     | <span class='neutral'>     * Emits a {TransferSingle} event.</span>
 339 |     | <span class='neutral'>     *</span>
 340 |     | <span class='neutral'>     * Requirements:</span>
 341 |     | <span class='neutral'>     *</span>
 342 |     | <span class='neutral'>     * - `from` cannot be the zero address.</span>
 343 |     | <span class='neutral'>     * - `from` must have at least `value` amount of tokens of type `id`.</span>
 344 |     | <span class='neutral'>     */</span>
 345 |     | <span class='neutral'>    function _burn(address from, uint256 id, uint256 value) internal {</span>
 346 |     | <span class='neutral'>        if (from == address(0)) {</span>
 347 |     | <span class='neutral'>            revert ERC1155InvalidSender(address(0));</span>
 348 |     | <span class='neutral'>        }</span>
 349 |     | <span class='neutral'>        (uint256[] memory ids, uint256[] memory values) = _asSingletonArrays(id, value);</span>
 350 |     | <span class='neutral'>        _updateWithAcceptanceCheck(from, address(0), ids, values, &quot;&quot;);</span>
 351 |     | <span class='neutral'>    }</span>
 352 |     | <span class='neutral'></span>
 353 |     | <span class='neutral'>    /**</span>
 354 |     | <span class='neutral'>     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {_burn}.</span>
 355 |     | <span class='neutral'>     *</span>
 356 |     | <span class='neutral'>     * Emits a {TransferBatch} event.</span>
 357 |     | <span class='neutral'>     *</span>
 358 |     | <span class='neutral'>     * Requirements:</span>
 359 |     | <span class='neutral'>     *</span>
 360 |     | <span class='neutral'>     * - `from` cannot be the zero address.</span>
 361 |     | <span class='neutral'>     * - `from` must have at least `value` amount of tokens of type `id`.</span>
 362 |     | <span class='neutral'>     * - `ids` and `values` must have the same length.</span>
 363 |     | <span class='neutral'>     */</span>
 364 |     | <span class='neutral'>    function _burnBatch(address from, uint256[] memory ids, uint256[] memory values) internal {</span>
 365 |     | <span class='neutral'>        if (from == address(0)) {</span>
 366 |     | <span class='neutral'>            revert ERC1155InvalidSender(address(0));</span>
 367 |     | <span class='neutral'>        }</span>
 368 |     | <span class='neutral'>        _updateWithAcceptanceCheck(from, address(0), ids, values, &quot;&quot;);</span>
 369 |     | <span class='neutral'>    }</span>
 370 |     | <span class='neutral'></span>
 371 |     | <span class='neutral'>    /**</span>
 372 |     | <span class='neutral'>     * @dev Approve `operator` to operate on all of `owner` tokens</span>
 373 |     | <span class='neutral'>     *</span>
 374 |     | <span class='neutral'>     * Emits an {ApprovalForAll} event.</span>
 375 |     | <span class='neutral'>     *</span>
 376 |     | <span class='neutral'>     * Requirements:</span>
 377 |     | <span class='neutral'>     *</span>
 378 |     | <span class='neutral'>     * - `operator` cannot be the zero address.</span>
 379 |     | <span class='neutral'>     */</span>
 380 |     | <span class='neutral'>    function _setApprovalForAll(address owner, address operator, bool approved) internal virtual {</span>
 381 |     | <span class='neutral'>        ERC1155Storage storage $ = _getERC1155Storage();</span>
 382 |     | <span class='neutral'>        if (operator == address(0)) {</span>
 383 |     | <span class='neutral'>            revert ERC1155InvalidOperator(address(0));</span>
 384 |     | <span class='neutral'>        }</span>
 385 |     | <span class='neutral'>        $._operatorApprovals[owner][operator] = approved;</span>
 386 |     | <span class='neutral'>        emit ApprovalForAll(owner, operator, approved);</span>
 387 |     | <span class='neutral'>    }</span>
 388 |     | <span class='neutral'></span>
 389 |     | <span class='neutral'>    /**</span>
 390 |     | <span class='neutral'>     * @dev Creates an array in memory with only one value for each of the elements provided.</span>
 391 |     | <span class='neutral'>     */</span>
 392 |     | <span class='neutral'>    function _asSingletonArrays(</span>
 393 |     | <span class='neutral'>        uint256 element1,</span>
 394 |     | <span class='neutral'>        uint256 element2</span>
 395 |     | <span class='neutral'>    ) private pure returns (uint256[] memory array1, uint256[] memory array2) {</span>
 396 |     | <span class='neutral'>        assembly (&quot;memory-safe&quot;) {</span>
 397 |     | <span class='neutral'>            // Load the free memory pointer</span>
 398 |     | <span class='neutral'>            array1 := mload(0x40)</span>
 399 |     | <span class='neutral'>            // Set array length to 1</span>
 400 |     | <span class='neutral'>            mstore(array1, 1)</span>
 401 |     | <span class='neutral'>            // Store the single element at the next word after the length (where content starts)</span>
 402 |     | <span class='neutral'>            mstore(add(array1, 0x20), element1)</span>
 403 |     | <span class='neutral'></span>
 404 |     | <span class='neutral'>            // Repeat for next array locating it right after the first array</span>
 405 |     | <span class='neutral'>            array2 := add(array1, 0x40)</span>
 406 |     | <span class='neutral'>            mstore(array2, 1)</span>
 407 |     | <span class='neutral'>            mstore(add(array2, 0x20), element2)</span>
 408 |     | <span class='neutral'></span>
 409 |     | <span class='neutral'>            // Update the free memory pointer by pointing after the second array</span>
 410 |     | <span class='neutral'>            mstore(0x40, add(array2, 0x40))</span>
 411 |     | <span class='neutral'>        }</span>
 412 |     | <span class='neutral'>    }</span>
 413 |     | <span class='neutral'>}</span>
 414 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/phantom/Documents/azemora/azemora-contracts/lib/openzeppelin-contracts-upgradeable/contracts/token/ERC1155/utils/ERC1155HolderUpgradeable.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>// OpenZeppelin Contracts (last updated v5.1.0) (token/ERC1155/utils/ERC1155Holder.sol)</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>pragma solidity ^0.8.20;</span>
  5 |     | <span class='neutral'></span>
  6 |     | <span class='neutral'>import {IERC165} from &quot;@openzeppelin/contracts/utils/introspection/IERC165.sol&quot;;</span>
  7 |     | <span class='unexecuted'>import {ERC165Upgradeable} from &quot;../../../utils/introspection/ERC165Upgradeable.sol&quot;;</span>
  8 |     | <span class='neutral'>import {IERC1155Receiver} from &quot;@openzeppelin/contracts/token/ERC1155/IERC1155Receiver.sol&quot;;</span>
  9 |     | <span class='neutral'>import {Initializable} from &quot;../../../proxy/utils/Initializable.sol&quot;;</span>
 10 |     | <span class='neutral'></span>
 11 |     | <span class='neutral'>/**</span>
 12 |     | <span class='neutral'> * @dev Simple implementation of `IERC1155Receiver` that will allow a contract to hold ERC-1155 tokens.</span>
 13 |     | <span class='neutral'> *</span>
 14 |     | <span class='neutral'> * IMPORTANT: When inheriting this contract, you must include a way to use the received tokens, otherwise they will be</span>
 15 |     | <span class='neutral'> * stuck.</span>
 16 |     | <span class='neutral'> */</span>
 17 |     | <span class='neutral'>abstract contract ERC1155HolderUpgradeable is Initializable, ERC165Upgradeable, IERC1155Receiver {</span>
 18 |     | <span class='neutral'>    function __ERC1155Holder_init() internal onlyInitializing {</span>
 19 |     | <span class='neutral'>    }</span>
 20 |     | <span class='neutral'></span>
 21 |     | <span class='neutral'>    function __ERC1155Holder_init_unchained() internal onlyInitializing {</span>
 22 |     | <span class='neutral'>    }</span>
 23 |     | <span class='neutral'>    /// @inheritdoc IERC165</span>
 24 |     | <span class='neutral'>    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165Upgradeable, IERC165) returns (bool) {</span>
 25 |     | <span class='neutral'>        return interfaceId == type(IERC1155Receiver).interfaceId || super.supportsInterface(interfaceId);</span>
 26 |     | <span class='neutral'>    }</span>
 27 |     | <span class='neutral'></span>
 28 |     | <span class='neutral'>    function onERC1155Received(</span>
 29 |     | <span class='neutral'>        address,</span>
 30 |     | <span class='neutral'>        address,</span>
 31 |     | <span class='neutral'>        uint256,</span>
 32 |     | <span class='neutral'>        uint256,</span>
 33 |     | <span class='neutral'>        bytes memory</span>
 34 |     | <span class='neutral'>    ) public virtual override returns (bytes4) {</span>
 35 |     | <span class='neutral'>        return this.onERC1155Received.selector;</span>
 36 |     | <span class='neutral'>    }</span>
 37 |     | <span class='neutral'></span>
 38 |     | <span class='neutral'>    function onERC1155BatchReceived(</span>
 39 |     | <span class='neutral'>        address,</span>
 40 |     | <span class='neutral'>        address,</span>
 41 |     | <span class='neutral'>        uint256[] memory,</span>
 42 |     | <span class='neutral'>        uint256[] memory,</span>
 43 |     | <span class='neutral'>        bytes memory</span>
 44 |     | <span class='neutral'>    ) public virtual override returns (bytes4) {</span>
 45 |     | <span class='neutral'>        return this.onERC1155BatchReceived.selector;</span>
 46 |     | <span class='neutral'>    }</span>
 47 |     | <span class='neutral'>}</span>
 48 |     | <span class='unexecuted'></span>

</code>
<br />

<b>/home/phantom/Documents/azemora/azemora-contracts/lib/openzeppelin-contracts-upgradeable/contracts/token/ERC20/ERC20Upgradeable.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'>// OpenZeppelin Contracts (last updated v5.3.0) (token/ERC20/ERC20.sol)</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>pragma solidity ^0.8.20;</span>
   5 |     | <span class='neutral'></span>
   6 |     | <span class='neutral'>import {IERC20} from &quot;@openzeppelin/contracts/token/ERC20/IERC20.sol&quot;;</span>
   7 |     | <span class='neutral'>import {IERC20Metadata} from &quot;@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol&quot;;</span>
   8 |     | <span class='unexecuted'>import {ContextUpgradeable} from &quot;../../utils/ContextUpgradeable.sol&quot;;</span>
   9 |     | <span class='neutral'>import {IERC20Errors} from &quot;@openzeppelin/contracts/interfaces/draft-IERC6093.sol&quot;;</span>
  10 |     | <span class='neutral'>import {Initializable} from &quot;../../proxy/utils/Initializable.sol&quot;;</span>
  11 |     | <span class='neutral'></span>
  12 |     | <span class='neutral'>/**</span>
  13 |     | <span class='neutral'> * @dev Implementation of the {IERC20} interface.</span>
  14 |     | <span class='neutral'> *</span>
  15 |     | <span class='neutral'> * This implementation is agnostic to the way tokens are created. This means</span>
  16 |     | <span class='neutral'> * that a supply mechanism has to be added in a derived contract using {_mint}.</span>
  17 |     | <span class='neutral'> *</span>
  18 |     | <span class='neutral'> * TIP: For a detailed writeup see our guide</span>
  19 |     | <span class='neutral'> * https://forum.openzeppelin.com/t/how-to-implement-erc20-supply-mechanisms/226[How</span>
  20 |     | <span class='neutral'> * to implement supply mechanisms].</span>
  21 |     | <span class='neutral'> *</span>
  22 |     | <span class='neutral'> * The default value of {decimals} is 18. To change this, you should override</span>
  23 |     | <span class='neutral'> * this function so it returns a different value.</span>
  24 |     | <span class='neutral'> *</span>
  25 |     | <span class='neutral'> * We have followed general OpenZeppelin Contracts guidelines: functions revert</span>
  26 |     | <span class='neutral'> * instead returning `false` on failure. This behavior is nonetheless</span>
  27 |     | <span class='neutral'> * conventional and does not conflict with the expectations of ERC-20</span>
  28 |     | <span class='neutral'> * applications.</span>
  29 |     | <span class='neutral'> */</span>
  30 |     | <span class='neutral'>abstract contract ERC20Upgradeable is Initializable, ContextUpgradeable, IERC20, IERC20Metadata, IERC20Errors {</span>
  31 |     | <span class='neutral'>    /// @custom:storage-location erc7201:openzeppelin.storage.ERC20</span>
  32 |     | <span class='neutral'>    struct ERC20Storage {</span>
  33 |     | <span class='neutral'>        mapping(address account =&gt; uint256) _balances;</span>
  34 |     | <span class='neutral'></span>
  35 |     | <span class='neutral'>        mapping(address account =&gt; mapping(address spender =&gt; uint256)) _allowances;</span>
  36 |     | <span class='neutral'></span>
  37 |     | <span class='neutral'>        uint256 _totalSupply;</span>
  38 |     | <span class='neutral'></span>
  39 |     | <span class='neutral'>        string _name;</span>
  40 |     | <span class='neutral'>        string _symbol;</span>
  41 |     | <span class='neutral'>    }</span>
  42 |     | <span class='neutral'></span>
  43 |     | <span class='neutral'>    // keccak256(abi.encode(uint256(keccak256(&quot;openzeppelin.storage.ERC20&quot;)) - 1)) &amp; ~bytes32(uint256(0xff))</span>
  44 |     | <span class='neutral'>    bytes32 private constant ERC20StorageLocation = 0x52c63247e1f47db19d5ce0460030c497f067ca4cebf71ba98eeadabe20bace00;</span>
  45 |     | <span class='neutral'></span>
  46 |     | <span class='neutral'>    function _getERC20Storage() private pure returns (ERC20Storage storage $) {</span>
  47 |     | <span class='neutral'>        assembly {</span>
  48 |     | <span class='neutral'>            $.slot := ERC20StorageLocation</span>
  49 |     | <span class='neutral'>        }</span>
  50 |     | <span class='neutral'>    }</span>
  51 |     | <span class='neutral'></span>
  52 |     | <span class='neutral'>    /**</span>
  53 |     | <span class='unexecuted'>     * @dev Sets the values for {name} and {symbol}.</span>
  54 |     | <span class='neutral'>     *</span>
  55 |     | <span class='unexecuted'>     * Both values are immutable: they can only be set once during construction.</span>
  56 |     | <span class='unexecuted'>     */</span>
  57 |     | <span class='unexecuted'>    function __ERC20_init(string memory name_, string memory symbol_) internal onlyInitializing {</span>
  58 |     | <span class='neutral'>        __ERC20_init_unchained(name_, symbol_);</span>
  59 |     | <span class='neutral'>    }</span>
  60 |     | <span class='neutral'></span>
  61 |     | <span class='neutral'>    function __ERC20_init_unchained(string memory name_, string memory symbol_) internal onlyInitializing {</span>
  62 |     | <span class='neutral'>        ERC20Storage storage $ = _getERC20Storage();</span>
  63 |     | <span class='unexecuted'>        $._name = name_;</span>
  64 |     | <span class='unexecuted'>        $._symbol = symbol_;</span>
  65 |     | <span class='unexecuted'>    }</span>
  66 |     | <span class='neutral'></span>
  67 |     | <span class='unexecuted'>    /**</span>
  68 |     | <span class='unexecuted'>     * @dev Returns the name of the token.</span>
  69 |     | <span class='unexecuted'>     */</span>
  70 |     | <span class='unexecuted'>    function name() public view virtual returns (string memory) {</span>
  71 |     | <span class='unexecuted'>        ERC20Storage storage $ = _getERC20Storage();</span>
  72 |     | <span class='unexecuted'>        return $._name;</span>
  73 |     | <span class='neutral'>    }</span>
  74 |     | <span class='neutral'></span>
  75 |     | <span class='neutral'>    /**</span>
  76 |     | <span class='unexecuted'>     * @dev Returns the symbol of the token, usually a shorter version of the</span>
  77 |     | <span class='neutral'>     * name.</span>
  78 |     | <span class='neutral'>     */</span>
  79 |     | <span class='neutral'>    function symbol() public view virtual returns (string memory) {</span>
  80 |     | <span class='neutral'>        ERC20Storage storage $ = _getERC20Storage();</span>
  81 |     | <span class='neutral'>        return $._symbol;</span>
  82 |     | <span class='neutral'>    }</span>
  83 |     | <span class='neutral'></span>
  84 |     | <span class='neutral'>    /**</span>
  85 |     | <span class='neutral'>     * @dev Returns the number of decimals used to get its user representation.</span>
  86 |     | <span class='neutral'>     * For example, if `decimals` equals `2`, a balance of `505` tokens should</span>
  87 |     | <span class='neutral'>     * be displayed to a user as `5.05` (`505 / 10 ** 2`).</span>
  88 |     | <span class='neutral'>     *</span>
  89 |     | <span class='neutral'>     * Tokens usually opt for a value of 18, imitating the relationship between</span>
  90 |     | <span class='neutral'>     * Ether and Wei. This is the default value returned by this function, unless</span>
  91 |     | <span class='neutral'>     * it&#39;s overridden.</span>
  92 |     | <span class='neutral'>     *</span>
  93 |     | <span class='neutral'>     * NOTE: This information is only used for _display_ purposes: it in</span>
  94 |     | <span class='neutral'>     * no way affects any of the arithmetic of the contract, including</span>
  95 |     | <span class='neutral'>     * {IERC20-balanceOf} and {IERC20-transfer}.</span>
  96 |     | <span class='neutral'>     */</span>
  97 |     | <span class='neutral'>    function decimals() public view virtual returns (uint8) {</span>
  98 |     | <span class='neutral'>        return 18;</span>
  99 |     | <span class='neutral'>    }</span>
 100 |     | <span class='neutral'></span>
 101 |     | <span class='neutral'>    /// @inheritdoc IERC20</span>
 102 |     | <span class='neutral'>    function totalSupply() public view virtual returns (uint256) {</span>
 103 |     | <span class='neutral'>        ERC20Storage storage $ = _getERC20Storage();</span>
 104 |     | <span class='neutral'>        return $._totalSupply;</span>
 105 |     | <span class='neutral'>    }</span>
 106 |     | <span class='neutral'></span>
 107 |     | <span class='neutral'>    /// @inheritdoc IERC20</span>
 108 |     | <span class='neutral'>    function balanceOf(address account) public view virtual returns (uint256) {</span>
 109 |     | <span class='neutral'>        ERC20Storage storage $ = _getERC20Storage();</span>
 110 |     | <span class='neutral'>        return $._balances[account];</span>
 111 |     | <span class='neutral'>    }</span>
 112 |     | <span class='neutral'></span>
 113 |     | <span class='neutral'>    /**</span>
 114 |     | <span class='neutral'>     * @dev See {IERC20-transfer}.</span>
 115 |     | <span class='neutral'>     *</span>
 116 |     | <span class='neutral'>     * Requirements:</span>
 117 |     | <span class='neutral'>     *</span>
 118 |     | <span class='neutral'>     * - `to` cannot be the zero address.</span>
 119 |     | <span class='neutral'>     * - the caller must have a balance of at least `value`.</span>
 120 |     | <span class='neutral'>     */</span>
 121 |     | <span class='neutral'>    function transfer(address to, uint256 value) public virtual returns (bool) {</span>
 122 |     | <span class='neutral'>        address owner = _msgSender();</span>
 123 |     | <span class='neutral'>        _transfer(owner, to, value);</span>
 124 |     | <span class='neutral'>        return true;</span>
 125 |     | <span class='neutral'>    }</span>
 126 |     | <span class='neutral'></span>
 127 |     | <span class='neutral'>    /// @inheritdoc IERC20</span>
 128 |     | <span class='neutral'>    function allowance(address owner, address spender) public view virtual returns (uint256) {</span>
 129 |     | <span class='neutral'>        ERC20Storage storage $ = _getERC20Storage();</span>
 130 |     | <span class='neutral'>        return $._allowances[owner][spender];</span>
 131 |     | <span class='neutral'>    }</span>
 132 |     | <span class='neutral'></span>
 133 |     | <span class='neutral'>    /**</span>
 134 |     | <span class='neutral'>     * @dev See {IERC20-approve}.</span>
 135 |     | <span class='neutral'>     *</span>
 136 |     | <span class='neutral'>     * NOTE: If `value` is the maximum `uint256`, the allowance is not updated on</span>
 137 |     | <span class='neutral'>     * `transferFrom`. This is semantically equivalent to an infinite approval.</span>
 138 |     | <span class='neutral'>     *</span>
 139 |     | <span class='neutral'>     * Requirements:</span>
 140 |     | <span class='neutral'>     *</span>
 141 |     | <span class='neutral'>     * - `spender` cannot be the zero address.</span>
 142 |     | <span class='neutral'>     */</span>
 143 |     | <span class='neutral'>    function approve(address spender, uint256 value) public virtual returns (bool) {</span>
 144 |     | <span class='unexecuted'>        address owner = _msgSender();</span>
 145 |     | <span class='neutral'>        _approve(owner, spender, value);</span>
 146 |     | <span class='neutral'>        return true;</span>
 147 |     | <span class='neutral'>    }</span>
 148 |     | <span class='neutral'></span>
 149 |     | <span class='neutral'>    /**</span>
 150 |     | <span class='unexecuted'>     * @dev See {IERC20-transferFrom}.</span>
 151 |     | <span class='neutral'>     *</span>
 152 |     | <span class='neutral'>     * Skips emitting an {Approval} event indicating an allowance update. This is not</span>
 153 |     | <span class='neutral'>     * required by the ERC. See {xref-ERC20-_approve-address-address-uint256-bool-}[_approve].</span>
 154 |     | <span class='neutral'>     *</span>
 155 |     | <span class='neutral'>     * NOTE: Does not update the allowance if the current allowance</span>
 156 |     | <span class='neutral'>     * is the maximum `uint256`.</span>
 157 |     | <span class='neutral'>     *</span>
 158 |     | <span class='neutral'>     * Requirements:</span>
 159 |     | <span class='neutral'>     *</span>
 160 |     | <span class='neutral'>     * - `from` and `to` cannot be the zero address.</span>
 161 |     | <span class='neutral'>     * - `from` must have a balance of at least `value`.</span>
 162 |     | <span class='neutral'>     * - the caller must have allowance for ``from``&#39;s tokens of at least</span>
 163 |     | <span class='neutral'>     * `value`.</span>
 164 |     | <span class='neutral'>     */</span>
 165 |     | <span class='neutral'>    function transferFrom(address from, address to, uint256 value) public virtual returns (bool) {</span>
 166 |     | <span class='neutral'>        address spender = _msgSender();</span>
 167 |     | <span class='neutral'>        _spendAllowance(from, spender, value);</span>
 168 |     | <span class='neutral'>        _transfer(from, to, value);</span>
 169 |     | <span class='neutral'>        return true;</span>
 170 |     | <span class='neutral'>    }</span>
 171 |     | <span class='neutral'></span>
 172 |     | <span class='neutral'>    /**</span>
 173 |     | <span class='neutral'>     * @dev Moves a `value` amount of tokens from `from` to `to`.</span>
 174 |     | <span class='neutral'>     *</span>
 175 |     | <span class='unexecuted'>     * This internal function is equivalent to {transfer}, and can be used to</span>
 176 |     | <span class='unexecuted'>     * e.g. implement automatic token fees, slashing mechanisms, etc.</span>
 177 |     | <span class='neutral'>     *</span>
 178 |     | <span class='unexecuted'>     * Emits a {Transfer} event.</span>
 179 |     | <span class='neutral'>     *</span>
 180 |     | <span class='unexecuted'>     * NOTE: This function is not virtual, {_update} should be overridden instead.</span>
 181 |     | <span class='neutral'>     */</span>
 182 |     | <span class='unexecuted'>    function _transfer(address from, address to, uint256 value) internal {</span>
 183 |     | <span class='neutral'>        if (from == address(0)) {</span>
 184 |     | <span class='unexecuted'>            revert ERC20InvalidSender(address(0));</span>
 185 |     | <span class='neutral'>        }</span>
 186 |     | <span class='unexecuted'>        if (to == address(0)) {</span>
 187 |     | <span class='unexecuted'>            revert ERC20InvalidReceiver(address(0));</span>
 188 |     | <span class='neutral'>        }</span>
 189 |     | <span class='neutral'>        _update(from, to, value);</span>
 190 |     | <span class='neutral'>    }</span>
 191 |     | <span class='neutral'></span>
 192 |     | <span class='neutral'>    /**</span>
 193 |     | <span class='unexecuted'>     * @dev Transfers a `value` amount of tokens from `from` to `to`, or alternatively mints (or burns) if `from`</span>
 194 |     | <span class='unexecuted'>     * (or `to`) is the zero address. All customizations to transfers, mints, and burns should be done by overriding</span>
 195 |     | <span class='unexecuted'>     * this function.</span>
 196 |     | <span class='unexecuted'>     *</span>
 197 |     | <span class='unexecuted'>     * Emits a {Transfer} event.</span>
 198 |     | <span class='neutral'>     */</span>
 199 |     | <span class='unexecuted'>    function _update(address from, address to, uint256 value) internal virtual {</span>
 200 |     | <span class='neutral'>        ERC20Storage storage $ = _getERC20Storage();</span>
 201 |     | <span class='unexecuted'>        if (from == address(0)) {</span>
 202 |     | <span class='unexecuted'>            // Overflow check required: The rest of the code assumes that totalSupply never overflows</span>
 203 |     | <span class='neutral'>            $._totalSupply += value;</span>
 204 |     | <span class='neutral'>        } else {</span>
 205 |     | <span class='unexecuted'>            uint256 fromBalance = $._balances[from];</span>
 206 |     | <span class='unexecuted'>            if (fromBalance &lt; value) {</span>
 207 |     | <span class='unexecuted'>                revert ERC20InsufficientBalance(from, fromBalance, value);</span>
 208 |     | <span class='neutral'>            }</span>
 209 |     | <span class='unexecuted'>            unchecked {</span>
 210 |     | <span class='unexecuted'>                // Overflow not possible: value &lt;= fromBalance &lt;= totalSupply.</span>
 211 |     | <span class='unexecuted'>                $._balances[from] = fromBalance - value;</span>
 212 |     | <span class='neutral'>            }</span>
 213 |     | <span class='neutral'>        }</span>
 214 |     | <span class='neutral'></span>
 215 |     | <span class='neutral'>        if (to == address(0)) {</span>
 216 |     | <span class='neutral'>            unchecked {</span>
 217 |     | <span class='neutral'>                // Overflow not possible: value &lt;= totalSupply or value &lt;= fromBalance &lt;= totalSupply.</span>
 218 |     | <span class='neutral'>                $._totalSupply -= value;</span>
 219 |     | <span class='neutral'>            }</span>
 220 |     | <span class='neutral'>        } else {</span>
 221 |     | <span class='neutral'>            unchecked {</span>
 222 |     | <span class='neutral'>                // Overflow not possible: balance + value is at most totalSupply, which we know fits into a uint256.</span>
 223 |     | <span class='neutral'>                $._balances[to] += value;</span>
 224 |     | <span class='neutral'>            }</span>
 225 |     | <span class='neutral'>        }</span>
 226 |     | <span class='neutral'></span>
 227 |     | <span class='neutral'>        emit Transfer(from, to, value);</span>
 228 |     | <span class='neutral'>    }</span>
 229 |     | <span class='neutral'></span>
 230 |     | <span class='neutral'>    /**</span>
 231 |     | <span class='neutral'>     * @dev Creates a `value` amount of tokens and assigns them to `account`, by transferring it from address(0).</span>
 232 |     | <span class='neutral'>     * Relies on the `_update` mechanism</span>
 233 |     | <span class='neutral'>     *</span>
 234 |     | <span class='neutral'>     * Emits a {Transfer} event with `from` set to the zero address.</span>
 235 |     | <span class='neutral'>     *</span>
 236 |     | <span class='neutral'>     * NOTE: This function is not virtual, {_update} should be overridden instead.</span>
 237 |     | <span class='neutral'>     */</span>
 238 |     | <span class='neutral'>    function _mint(address account, uint256 value) internal {</span>
 239 |     | <span class='neutral'>        if (account == address(0)) {</span>
 240 |     | <span class='neutral'>            revert ERC20InvalidReceiver(address(0));</span>
 241 |     | <span class='neutral'>        }</span>
 242 |     | <span class='neutral'>        _update(address(0), account, value);</span>
 243 |     | <span class='neutral'>    }</span>
 244 |     | <span class='neutral'></span>
 245 |     | <span class='neutral'>    /**</span>
 246 |     | <span class='neutral'>     * @dev Destroys a `value` amount of tokens from `account`, lowering the total supply.</span>
 247 |     | <span class='neutral'>     * Relies on the `_update` mechanism.</span>
 248 |     | <span class='neutral'>     *</span>
 249 |     | <span class='neutral'>     * Emits a {Transfer} event with `to` set to the zero address.</span>
 250 |     | <span class='neutral'>     *</span>
 251 |     | <span class='neutral'>     * NOTE: This function is not virtual, {_update} should be overridden instead</span>
 252 |     | <span class='neutral'>     */</span>
 253 |     | <span class='neutral'>    function _burn(address account, uint256 value) internal {</span>
 254 |     | <span class='neutral'>        if (account == address(0)) {</span>
 255 |     | <span class='neutral'>            revert ERC20InvalidSender(address(0));</span>
 256 |     | <span class='neutral'>        }</span>
 257 |     | <span class='neutral'>        _update(account, address(0), value);</span>
 258 |     | <span class='neutral'>    }</span>
 259 |     | <span class='neutral'></span>
 260 |     | <span class='neutral'>    /**</span>
 261 |     | <span class='neutral'>     * @dev Sets `value` as the allowance of `spender` over the `owner`&#39;s tokens.</span>
 262 |     | <span class='neutral'>     *</span>
 263 |     | <span class='neutral'>     * This internal function is equivalent to `approve`, and can be used to</span>
 264 |     | <span class='neutral'>     * e.g. set automatic allowances for certain subsystems, etc.</span>
 265 |     | <span class='neutral'>     *</span>
 266 |     | <span class='neutral'>     * Emits an {Approval} event.</span>
 267 |     | <span class='neutral'>     *</span>
 268 |     | <span class='neutral'>     * Requirements:</span>
 269 |     | <span class='neutral'>     *</span>
 270 |     | <span class='neutral'>     * - `owner` cannot be the zero address.</span>
 271 |     | <span class='neutral'>     * - `spender` cannot be the zero address.</span>
 272 |     | <span class='neutral'>     *</span>
 273 |     | <span class='neutral'>     * Overrides to this logic should be done to the variant with an additional `bool emitEvent` argument.</span>
 274 |     | <span class='neutral'>     */</span>
 275 |     | <span class='neutral'>    function _approve(address owner, address spender, uint256 value) internal {</span>
 276 |     | <span class='neutral'>        _approve(owner, spender, value, true);</span>
 277 |     | <span class='neutral'>    }</span>
 278 |     | <span class='neutral'></span>
 279 |     | <span class='neutral'>    /**</span>
 280 |     | <span class='neutral'>     * @dev Variant of {_approve} with an optional flag to enable or disable the {Approval} event.</span>
 281 |     | <span class='neutral'>     *</span>
 282 |     | <span class='neutral'>     * By default (when calling {_approve}) the flag is set to true. On the other hand, approval changes made by</span>
 283 |     | <span class='neutral'>     * `_spendAllowance` during the `transferFrom` operation set the flag to false. This saves gas by not emitting any</span>
 284 |     | <span class='neutral'>     * `Approval` event during `transferFrom` operations.</span>
 285 |     | <span class='neutral'>     *</span>
 286 |     | <span class='neutral'>     * Anyone who wishes to continue emitting `Approval` events on the`transferFrom` operation can force the flag to</span>
 287 |     | <span class='neutral'>     * true using the following override:</span>
 288 |     | <span class='neutral'>     *</span>
 289 |     | <span class='neutral'>     * ```solidity</span>
 290 |     | <span class='neutral'>     * function _approve(address owner, address spender, uint256 value, bool) internal virtual override {</span>
 291 |     | <span class='neutral'>     *     super._approve(owner, spender, value, true);</span>
 292 |     | <span class='neutral'>     * }</span>
 293 |     | <span class='neutral'>     * ```</span>
 294 |     | <span class='neutral'>     *</span>
 295 |     | <span class='neutral'>     * Requirements are the same as {_approve}.</span>
 296 |     | <span class='neutral'>     */</span>
 297 |     | <span class='neutral'>    function _approve(address owner, address spender, uint256 value, bool emitEvent) internal virtual {</span>
 298 |     | <span class='neutral'>        ERC20Storage storage $ = _getERC20Storage();</span>
 299 |     | <span class='neutral'>        if (owner == address(0)) {</span>
 300 |     | <span class='neutral'>            revert ERC20InvalidApprover(address(0));</span>
 301 |     | <span class='neutral'>        }</span>
 302 |     | <span class='neutral'>        if (spender == address(0)) {</span>
 303 |     | <span class='neutral'>            revert ERC20InvalidSpender(address(0));</span>
 304 |     | <span class='neutral'>        }</span>
 305 |     | <span class='neutral'>        $._allowances[owner][spender] = value;</span>
 306 |     | <span class='neutral'>        if (emitEvent) {</span>
 307 |     | <span class='neutral'>            emit Approval(owner, spender, value);</span>
 308 |     | <span class='neutral'>        }</span>
 309 |     | <span class='neutral'>    }</span>
 310 |     | <span class='neutral'></span>
 311 |     | <span class='neutral'>    /**</span>
 312 |     | <span class='neutral'>     * @dev Updates `owner`&#39;s allowance for `spender` based on spent `value`.</span>
 313 |     | <span class='neutral'>     *</span>
 314 |     | <span class='neutral'>     * Does not update the allowance value in case of infinite allowance.</span>
 315 |     | <span class='neutral'>     * Revert if not enough allowance is available.</span>
 316 |     | <span class='neutral'>     *</span>
 317 |     | <span class='neutral'>     * Does not emit an {Approval} event.</span>
 318 |     | <span class='neutral'>     */</span>
 319 |     | <span class='neutral'>    function _spendAllowance(address owner, address spender, uint256 value) internal virtual {</span>
 320 |     | <span class='neutral'>        uint256 currentAllowance = allowance(owner, spender);</span>
 321 |     | <span class='neutral'>        if (currentAllowance &lt; type(uint256).max) {</span>
 322 |     | <span class='neutral'>            if (currentAllowance &lt; value) {</span>
 323 |     | <span class='neutral'>                revert ERC20InsufficientAllowance(spender, currentAllowance, value);</span>
 324 |     | <span class='neutral'>            }</span>
 325 |     | <span class='neutral'>            unchecked {</span>
 326 |     | <span class='neutral'>                _approve(owner, spender, currentAllowance - value, false);</span>
 327 |     | <span class='neutral'>            }</span>
 328 |     | <span class='neutral'>        }</span>
 329 |     | <span class='neutral'>    }</span>
 330 |     | <span class='neutral'>}</span>
 331 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/phantom/Documents/azemora/azemora-contracts/lib/openzeppelin-contracts-upgradeable/contracts/token/ERC20/extensions/ERC20PermitUpgradeable.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>// OpenZeppelin Contracts (last updated v5.1.0) (token/ERC20/extensions/ERC20Permit.sol)</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>pragma solidity ^0.8.20;</span>
  5 |     | <span class='neutral'></span>
  6 |     | <span class='neutral'>import {IERC20Permit} from &quot;@openzeppelin/contracts/token/ERC20/extensions/IERC20Permit.sol&quot;;</span>
  7 |     | <span class='neutral'>import {ERC20Upgradeable} from &quot;../ERC20Upgradeable.sol&quot;;</span>
  8 |     | <span class='neutral'>import {ECDSA} from &quot;@openzeppelin/contracts/utils/cryptography/ECDSA.sol&quot;;</span>
  9 |     | <span class='neutral'>import {EIP712Upgradeable} from &quot;../../../utils/cryptography/EIP712Upgradeable.sol&quot;;</span>
 10 |     | <span class='unexecuted'>import {NoncesUpgradeable} from &quot;../../../utils/NoncesUpgradeable.sol&quot;;</span>
 11 |     | <span class='neutral'>import {Initializable} from &quot;../../../proxy/utils/Initializable.sol&quot;;</span>
 12 |     | <span class='neutral'></span>
 13 |     | <span class='neutral'>/**</span>
 14 |     | <span class='neutral'> * @dev Implementation of the ERC-20 Permit extension allowing approvals to be made via signatures, as defined in</span>
 15 |     | <span class='neutral'> * https://eips.ethereum.org/EIPS/eip-2612[ERC-2612].</span>
 16 |     | <span class='neutral'> *</span>
 17 |     | <span class='neutral'> * Adds the {permit} method, which can be used to change an account&#39;s ERC-20 allowance (see {IERC20-allowance}) by</span>
 18 |     | <span class='neutral'> * presenting a message signed by the account. By not relying on `{IERC20-approve}`, the token holder account doesn&#39;t</span>
 19 |     | <span class='neutral'> * need to send a transaction, and thus is not required to hold Ether at all.</span>
 20 |     | <span class='neutral'> */</span>
 21 |     | <span class='neutral'>abstract contract ERC20PermitUpgradeable is Initializable, ERC20Upgradeable, IERC20Permit, EIP712Upgradeable, NoncesUpgradeable {</span>
 22 |     | <span class='neutral'>    bytes32 private constant PERMIT_TYPEHASH =</span>
 23 |     | <span class='neutral'>        keccak256(&quot;Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)&quot;);</span>
 24 |     | <span class='neutral'></span>
 25 |     | <span class='neutral'>    /**</span>
 26 |     | <span class='neutral'>     * @dev Permit deadline has expired.</span>
 27 |     | <span class='neutral'>     */</span>
 28 |     | <span class='neutral'>    error ERC2612ExpiredSignature(uint256 deadline);</span>
 29 |     | <span class='neutral'></span>
 30 |     | <span class='neutral'>    /**</span>
 31 |     | <span class='neutral'>     * @dev Mismatched signature.</span>
 32 |     | <span class='neutral'>     */</span>
 33 |     | <span class='neutral'>    error ERC2612InvalidSigner(address signer, address owner);</span>
 34 |     | <span class='neutral'></span>
 35 |     | <span class='neutral'>    /**</span>
 36 |     | <span class='neutral'>     * @dev Initializes the {EIP712} domain separator using the `name` parameter, and setting `version` to `&quot;1&quot;`.</span>
 37 |     | <span class='neutral'>     *</span>
 38 |     | <span class='neutral'>     * It&#39;s a good idea to use the same `name` that is defined as the ERC-20 token name.</span>
 39 |     | <span class='neutral'>     */</span>
 40 |     | <span class='neutral'>    function __ERC20Permit_init(string memory name) internal onlyInitializing {</span>
 41 |     | <span class='neutral'>        __EIP712_init_unchained(name, &quot;1&quot;);</span>
 42 |     | <span class='neutral'>    }</span>
 43 |     | <span class='neutral'></span>
 44 |     | <span class='neutral'>    function __ERC20Permit_init_unchained(string memory) internal onlyInitializing {}</span>
 45 |     | <span class='neutral'></span>
 46 |     | <span class='neutral'>    /// @inheritdoc IERC20Permit</span>
 47 |     | <span class='neutral'>    function permit(</span>
 48 |     | <span class='neutral'>        address owner,</span>
 49 |     | <span class='neutral'>        address spender,</span>
 50 |     | <span class='neutral'>        uint256 value,</span>
 51 |     | <span class='neutral'>        uint256 deadline,</span>
 52 |     | <span class='neutral'>        uint8 v,</span>
 53 |     | <span class='neutral'>        bytes32 r,</span>
 54 |     | <span class='neutral'>        bytes32 s</span>
 55 |     | <span class='neutral'>    ) public virtual {</span>
 56 |     | <span class='neutral'>        if (block.timestamp &gt; deadline) {</span>
 57 |     | <span class='neutral'>            revert ERC2612ExpiredSignature(deadline);</span>
 58 |     | <span class='neutral'>        }</span>
 59 |     | <span class='neutral'></span>
 60 |     | <span class='neutral'>        bytes32 structHash = keccak256(abi.encode(PERMIT_TYPEHASH, owner, spender, value, _useNonce(owner), deadline));</span>
 61 |     | <span class='neutral'></span>
 62 |     | <span class='neutral'>        bytes32 hash = _hashTypedDataV4(structHash);</span>
 63 |     | <span class='neutral'></span>
 64 |     | <span class='neutral'>        address signer = ECDSA.recover(hash, v, r, s);</span>
 65 |     | <span class='neutral'>        if (signer != owner) {</span>
 66 |     | <span class='neutral'>            revert ERC2612InvalidSigner(signer, owner);</span>
 67 |     | <span class='neutral'>        }</span>
 68 |     | <span class='neutral'></span>
 69 |     | <span class='neutral'>        _approve(owner, spender, value);</span>
 70 |     | <span class='neutral'>    }</span>
 71 |     | <span class='neutral'></span>
 72 |     | <span class='neutral'>    /// @inheritdoc IERC20Permit</span>
 73 |     | <span class='neutral'>    function nonces(address owner) public view virtual override(IERC20Permit, NoncesUpgradeable) returns (uint256) {</span>
 74 |     | <span class='neutral'>        return super.nonces(owner);</span>
 75 |     | <span class='neutral'>    }</span>
 76 |     | <span class='neutral'></span>
 77 |     | <span class='neutral'>    /// @inheritdoc IERC20Permit</span>
 78 |     | <span class='neutral'>    // solhint-disable-next-line func-name-mixedcase</span>
 79 |     | <span class='neutral'>    function DOMAIN_SEPARATOR() external view virtual returns (bytes32) {</span>
 80 |     | <span class='neutral'>        return _domainSeparatorV4();</span>
 81 |     | <span class='neutral'>    }</span>
 82 |     | <span class='neutral'>}</span>
 83 |     | <span class='unexecuted'></span>

</code>
<br />

<b>/home/phantom/Documents/azemora/azemora-contracts/lib/openzeppelin-contracts-upgradeable/contracts/token/ERC20/extensions/ERC20VotesUpgradeable.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>// OpenZeppelin Contracts (last updated v5.1.0) (token/ERC20/extensions/ERC20Votes.sol)</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>pragma solidity ^0.8.20;</span>
  5 |     | <span class='neutral'></span>
  6 |     | <span class='neutral'>import {ERC20Upgradeable} from &quot;../ERC20Upgradeable.sol&quot;;</span>
  7 |     | <span class='neutral'>import {VotesUpgradeable} from &quot;../../../governance/utils/VotesUpgradeable.sol&quot;;</span>
  8 |     | <span class='neutral'>import {Checkpoints} from &quot;@openzeppelin/contracts/utils/structs/Checkpoints.sol&quot;;</span>
  9 |     | <span class='neutral'>import {Initializable} from &quot;../../../proxy/utils/Initializable.sol&quot;;</span>
 10 |     | <span class='neutral'></span>
 11 |     | <span class='neutral'>/**</span>
 12 |     | <span class='neutral'> * @dev Extension of ERC-20 to support Compound-like voting and delegation. This version is more generic than Compound&#39;s,</span>
 13 |     | <span class='neutral'> * and supports token supply up to 2^208^ - 1, while COMP is limited to 2^96^ - 1.</span>
 14 |     | <span class='neutral'> *</span>
 15 |     | <span class='neutral'> * NOTE: This contract does not provide interface compatibility with Compound&#39;s COMP token.</span>
 16 |     | <span class='neutral'> *</span>
 17 |     | <span class='unexecuted'> * This extension keeps a history (checkpoints) of each account&#39;s vote power. Vote power can be delegated either</span>
 18 |     | <span class='neutral'> * by calling the {Votes-delegate} function directly, or by providing a signature to be used with {Votes-delegateBySig}. Voting</span>
 19 |     | <span class='neutral'> * power can be queried through the public accessors {Votes-getVotes} and {Votes-getPastVotes}.</span>
 20 |     | <span class='neutral'> *</span>
 21 |     | <span class='neutral'> * By default, token balance does not account for voting power. This makes transfers cheaper. The downside is that it</span>
 22 |     | <span class='neutral'> * requires users to delegate to themselves in order to activate checkpoints and have their voting power tracked.</span>
 23 |     | <span class='neutral'> */</span>
 24 |     | <span class='neutral'>abstract contract ERC20VotesUpgradeable is Initializable, ERC20Upgradeable, VotesUpgradeable {</span>
 25 |     | <span class='neutral'>    /**</span>
 26 |     | <span class='unexecuted'>     * @dev Total supply cap has been exceeded, introducing a risk of votes overflowing.</span>
 27 |     | <span class='neutral'>     */</span>
 28 |     | <span class='neutral'>    error ERC20ExceededSafeSupply(uint256 increasedSupply, uint256 cap);</span>
 29 |     | <span class='neutral'></span>
 30 |     | <span class='unexecuted'>    function __ERC20Votes_init() internal onlyInitializing {</span>
 31 |     | <span class='unexecuted'>    }</span>
 32 |     | <span class='neutral'></span>
 33 |     | <span class='unexecuted'>    function __ERC20Votes_init_unchained() internal onlyInitializing {</span>
 34 |     | <span class='neutral'>    }</span>
 35 |     | <span class='neutral'>    /**</span>
 36 |     | <span class='unexecuted'>     * @dev Maximum token supply. Defaults to `type(uint208).max` (2^208^ - 1).</span>
 37 |     | <span class='neutral'>     *</span>
 38 |     | <span class='unexecuted'>     * This maximum is enforced in {_update}. It limits the total supply of the token, which is otherwise a uint256,</span>
 39 |     | <span class='neutral'>     * so that checkpoints can be stored in the Trace208 structure used by {Votes}. Increasing this value will not</span>
 40 |     | <span class='neutral'>     * remove the underlying limitation, and will cause {_update} to fail because of a math overflow in</span>
 41 |     | <span class='neutral'>     * {Votes-_transferVotingUnits}. An override could be used to further restrict the total supply (to a lower value) if</span>
 42 |     | <span class='unexecuted'>     * additional logic requires it. When resolving override conflicts on this function, the minimum should be</span>
 43 |     | <span class='neutral'>     * returned.</span>
 44 |     | <span class='neutral'>     */</span>
 45 |     | <span class='unexecuted'>    function _maxSupply() internal view virtual returns (uint256) {</span>
 46 |     | <span class='unexecuted'>        return type(uint208).max;</span>
 47 |     | <span class='neutral'>    }</span>
 48 |     | <span class='neutral'></span>
 49 |     | <span class='neutral'>    /**</span>
 50 |     | <span class='unexecuted'>     * @dev Move voting power when tokens are transferred.</span>
 51 |     | <span class='unexecuted'>     *</span>
 52 |     | <span class='unexecuted'>     * Emits a {IVotes-DelegateVotesChanged} event.</span>
 53 |     | <span class='unexecuted'>     */</span>
 54 |     | <span class='unexecuted'>    function _update(address from, address to, uint256 value) internal virtual override {</span>
 55 |     | <span class='neutral'>        super._update(from, to, value);</span>
 56 |     | <span class='neutral'>        if (from == address(0)) {</span>
 57 |     | <span class='neutral'>            uint256 supply = totalSupply();</span>
 58 |     | <span class='neutral'>            uint256 cap = _maxSupply();</span>
 59 |     | <span class='neutral'>            if (supply &gt; cap) {</span>
 60 |     | <span class='neutral'>                revert ERC20ExceededSafeSupply(supply, cap);</span>
 61 |     | <span class='neutral'>            }</span>
 62 |     | <span class='neutral'>        }</span>
 63 |     | <span class='neutral'>        _transferVotingUnits(from, to, value);</span>
 64 |     | <span class='neutral'>    }</span>
 65 |     | <span class='neutral'></span>
 66 |     | <span class='neutral'>    /**</span>
 67 |     | <span class='neutral'>     * @dev Returns the voting units of an `account`.</span>
 68 |     | <span class='neutral'>     *</span>
 69 |     | <span class='neutral'>     * WARNING: Overriding this function may compromise the internal vote accounting.</span>
 70 |     | <span class='neutral'>     * `ERC20Votes` assumes tokens map to voting units 1:1 and this is not easy to change.</span>
 71 |     | <span class='neutral'>     */</span>
 72 |     | <span class='neutral'>    function _getVotingUnits(address account) internal view virtual override returns (uint256) {</span>
 73 |     | <span class='neutral'>        return balanceOf(account);</span>
 74 |     | <span class='neutral'>    }</span>
 75 |     | <span class='neutral'></span>
 76 |     | <span class='neutral'>    /**</span>
 77 |     | <span class='neutral'>     * @dev Get number of checkpoints for `account`.</span>
 78 |     | <span class='neutral'>     */</span>
 79 |     | <span class='neutral'>    function numCheckpoints(address account) public view virtual returns (uint32) {</span>
 80 |     | <span class='neutral'>        return _numCheckpoints(account);</span>
 81 |     | <span class='neutral'>    }</span>
 82 |     | <span class='neutral'></span>
 83 |     | <span class='neutral'>    /**</span>
 84 |     | <span class='neutral'>     * @dev Get the `pos`-th checkpoint for `account`.</span>
 85 |     | <span class='neutral'>     */</span>
 86 |     | <span class='neutral'>    function checkpoints(address account, uint32 pos) public view virtual returns (Checkpoints.Checkpoint208 memory) {</span>
 87 |     | <span class='neutral'>        return _checkpoints(account, pos);</span>
 88 |     | <span class='neutral'>    }</span>
 89 |     | <span class='neutral'>}</span>
 90 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/phantom/Documents/azemora/azemora-contracts/lib/openzeppelin-contracts-upgradeable/contracts/token/ERC721/utils/ERC721HolderUpgradeable.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC721/utils/ERC721Holder.sol)</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>pragma solidity ^0.8.20;</span>
  5 |     | <span class='neutral'></span>
  6 |     | <span class='neutral'>import {IERC721Receiver} from &quot;@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol&quot;;</span>
  7 |     | <span class='neutral'>import {Initializable} from &quot;../../../proxy/utils/Initializable.sol&quot;;</span>
  8 |     | <span class='neutral'></span>
  9 |     | <span class='neutral'>/**</span>
 10 |     | <span class='neutral'> * @dev Implementation of the {IERC721Receiver} interface.</span>
 11 |     | <span class='neutral'> *</span>
 12 |     | <span class='neutral'> * Accepts all token transfers.</span>
 13 |     | <span class='neutral'> * Make sure the contract is able to use its token with {IERC721-safeTransferFrom}, {IERC721-approve} or</span>
 14 |     | <span class='neutral'> * {IERC721-setApprovalForAll}.</span>
 15 |     | <span class='neutral'> */</span>
 16 |     | <span class='neutral'>abstract contract ERC721HolderUpgradeable is Initializable, IERC721Receiver {</span>
 17 |     | <span class='neutral'>    function __ERC721Holder_init() internal onlyInitializing {</span>
 18 |     | <span class='neutral'>    }</span>
 19 |     | <span class='neutral'></span>
 20 |     | <span class='neutral'>    function __ERC721Holder_init_unchained() internal onlyInitializing {</span>
 21 |     | <span class='neutral'>    }</span>
 22 |     | <span class='neutral'>    /**</span>
 23 |     | <span class='neutral'>     * @dev See {IERC721Receiver-onERC721Received}.</span>
 24 |     | <span class='neutral'>     *</span>
 25 |     | <span class='neutral'>     * Always returns `IERC721Receiver.onERC721Received.selector`.</span>
 26 |     | <span class='neutral'>     */</span>
 27 |     | <span class='neutral'>    function onERC721Received(address, address, uint256, bytes memory) public virtual returns (bytes4) {</span>
 28 |     | <span class='neutral'>        return this.onERC721Received.selector;</span>
 29 |     | <span class='neutral'>    }</span>
 30 |     | <span class='neutral'>}</span>
 31 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/phantom/Documents/azemora/azemora-contracts/lib/openzeppelin-contracts-upgradeable/contracts/utils/ContextUpgradeable.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>pragma solidity ^0.8.20;</span>
  5 |     | <span class='neutral'>import {Initializable} from &quot;../proxy/utils/Initializable.sol&quot;;</span>
  6 |     | <span class='neutral'></span>
  7 |     | <span class='neutral'>/**</span>
  8 |     | <span class='neutral'> * @dev Provides information about the current execution context, including the</span>
  9 |     | <span class='unexecuted'> * sender of the transaction and its data. While these are generally available</span>
 10 |     | <span class='neutral'> * via msg.sender and msg.data, they should not be accessed in such a direct</span>
 11 |     | <span class='neutral'> * manner, since when dealing with meta-transactions the account sending and</span>
 12 |     | <span class='neutral'> * paying for execution may not be the actual sender (as far as an application</span>
 13 |     | <span class='neutral'> * is concerned).</span>
 14 |     | <span class='neutral'> *</span>
 15 |     | <span class='neutral'> * This contract is only required for intermediate, library-like contracts.</span>
 16 |     | <span class='neutral'> */</span>
 17 |     | <span class='neutral'>abstract contract ContextUpgradeable is Initializable {</span>
 18 |     | <span class='neutral'>    function __Context_init() internal onlyInitializing {</span>
 19 |     | <span class='neutral'>    }</span>
 20 |     | <span class='neutral'></span>
 21 |     | <span class='neutral'>    function __Context_init_unchained() internal onlyInitializing {</span>
 22 |     | <span class='neutral'>    }</span>
 23 |     | <span class='neutral'>    function _msgSender() internal view virtual returns (address) {</span>
 24 |     | <span class='neutral'>        return msg.sender;</span>
 25 |     | <span class='neutral'>    }</span>
 26 |     | <span class='neutral'></span>
 27 |     | <span class='unexecuted'>    function _msgData() internal view virtual returns (bytes calldata) {</span>
 28 |     | <span class='neutral'>        return msg.data;</span>
 29 |     | <span class='unexecuted'>    }</span>
 30 |     | <span class='neutral'></span>
 31 |     | <span class='neutral'>    function _contextSuffixLength() internal view virtual returns (uint256) {</span>
 32 |     | <span class='neutral'>        return 0;</span>
 33 |     | <span class='neutral'>    }</span>
 34 |     | <span class='neutral'>}</span>
 35 |     | <span class='unexecuted'></span>

</code>
<br />

<b>/home/phantom/Documents/azemora/azemora-contracts/lib/openzeppelin-contracts-upgradeable/contracts/utils/NoncesUpgradeable.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>// OpenZeppelin Contracts (last updated v5.0.0) (utils/Nonces.sol)</span>
  3 |     | <span class='neutral'>pragma solidity ^0.8.20;</span>
  4 |     | <span class='neutral'>import {Initializable} from &quot;../proxy/utils/Initializable.sol&quot;;</span>
  5 |     | <span class='neutral'></span>
  6 |     | <span class='neutral'>/**</span>
  7 |     | <span class='neutral'> * @dev Provides tracking nonces for addresses. Nonces will only increment.</span>
  8 |     | <span class='neutral'> */</span>
  9 |     | <span class='neutral'>abstract contract NoncesUpgradeable is Initializable {</span>
 10 |     | <span class='neutral'>    /**</span>
 11 |     | <span class='neutral'>     * @dev The nonce used for an `account` is not the expected current nonce.</span>
 12 |     | <span class='neutral'>     */</span>
 13 |     | <span class='neutral'>    error InvalidAccountNonce(address account, uint256 currentNonce);</span>
 14 |     | <span class='neutral'></span>
 15 |     | <span class='neutral'>    /// @custom:storage-location erc7201:openzeppelin.storage.Nonces</span>
 16 |     | <span class='neutral'>    struct NoncesStorage {</span>
 17 |     | <span class='neutral'>        mapping(address account =&gt; uint256) _nonces;</span>
 18 |     | <span class='neutral'>    }</span>
 19 |     | <span class='neutral'></span>
 20 |     | <span class='neutral'>    // keccak256(abi.encode(uint256(keccak256(&quot;openzeppelin.storage.Nonces&quot;)) - 1)) &amp; ~bytes32(uint256(0xff))</span>
 21 |     | <span class='unexecuted'>    bytes32 private constant NoncesStorageLocation = 0x5ab42ced628888259c08ac98db1eb0cf702fc1501344311d8b100cd1bfe4bb00;</span>
 22 |     | <span class='neutral'></span>
 23 |     | <span class='neutral'>    function _getNoncesStorage() private pure returns (NoncesStorage storage $) {</span>
 24 |     | <span class='neutral'>        assembly {</span>
 25 |     | <span class='neutral'>            $.slot := NoncesStorageLocation</span>
 26 |     | <span class='neutral'>        }</span>
 27 |     | <span class='neutral'>    }</span>
 28 |     | <span class='neutral'></span>
 29 |     | <span class='neutral'>    function __Nonces_init() internal onlyInitializing {</span>
 30 |     | <span class='neutral'>    }</span>
 31 |     | <span class='neutral'></span>
 32 |     | <span class='neutral'>    function __Nonces_init_unchained() internal onlyInitializing {</span>
 33 |     | <span class='neutral'>    }</span>
 34 |     | <span class='neutral'>    /**</span>
 35 |     | <span class='neutral'>     * @dev Returns the next unused nonce for an address.</span>
 36 |     | <span class='neutral'>     */</span>
 37 |     | <span class='neutral'>    function nonces(address owner) public view virtual returns (uint256) {</span>
 38 |     | <span class='neutral'>        NoncesStorage storage $ = _getNoncesStorage();</span>
 39 |     | <span class='neutral'>        return $._nonces[owner];</span>
 40 |     | <span class='neutral'>    }</span>
 41 |     | <span class='neutral'></span>
 42 |     | <span class='neutral'>    /**</span>
 43 |     | <span class='neutral'>     * @dev Consumes a nonce.</span>
 44 |     | <span class='neutral'>     *</span>
 45 |     | <span class='neutral'>     * Returns the current value and increments nonce.</span>
 46 |     | <span class='neutral'>     */</span>
 47 |     | <span class='neutral'>    function _useNonce(address owner) internal virtual returns (uint256) {</span>
 48 |     | <span class='neutral'>        NoncesStorage storage $ = _getNoncesStorage();</span>
 49 |     | <span class='neutral'>        // For each account, the nonce has an initial value of 0, can only be incremented by one, and cannot be</span>
 50 |     | <span class='neutral'>        // decremented or reset. This guarantees that the nonce never overflows.</span>
 51 |     | <span class='neutral'>        unchecked {</span>
 52 |     | <span class='neutral'>            // It is important to do x++ and not ++x here.</span>
 53 |     | <span class='neutral'>            return $._nonces[owner]++;</span>
 54 |     | <span class='neutral'>        }</span>
 55 |     | <span class='neutral'>    }</span>
 56 |     | <span class='neutral'></span>
 57 |     | <span class='neutral'>    /**</span>
 58 |     | <span class='neutral'>     * @dev Same as {_useNonce} but checking that `nonce` is the next valid for `owner`.</span>
 59 |     | <span class='neutral'>     */</span>
 60 |     | <span class='neutral'>    function _useCheckedNonce(address owner, uint256 nonce) internal virtual {</span>
 61 |     | <span class='neutral'>        uint256 current = _useNonce(owner);</span>
 62 |     | <span class='neutral'>        if (nonce != current) {</span>
 63 |     | <span class='neutral'>            revert InvalidAccountNonce(owner, current);</span>
 64 |     | <span class='neutral'>        }</span>
 65 |     | <span class='neutral'>    }</span>
 66 |     | <span class='neutral'>}</span>
 67 |     | <span class='unexecuted'></span>

</code>
<br />

<b>/home/phantom/Documents/azemora/azemora-contracts/lib/openzeppelin-contracts-upgradeable/contracts/utils/PausableUpgradeable.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'>// OpenZeppelin Contracts (last updated v5.3.0) (utils/Pausable.sol)</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>pragma solidity ^0.8.20;</span>
   5 |     | <span class='neutral'></span>
   6 |     | <span class='neutral'>import {ContextUpgradeable} from &quot;../utils/ContextUpgradeable.sol&quot;;</span>
   7 |     | <span class='unexecuted'>import {Initializable} from &quot;../proxy/utils/Initializable.sol&quot;;</span>
   8 |     | <span class='neutral'></span>
   9 |     | <span class='neutral'>/**</span>
  10 |     | <span class='neutral'> * @dev Contract module which allows children to implement an emergency stop</span>
  11 |     | <span class='neutral'> * mechanism that can be triggered by an authorized account.</span>
  12 |     | <span class='neutral'> *</span>
  13 |     | <span class='neutral'> * This module is used through inheritance. It will make available the</span>
  14 |     | <span class='neutral'> * modifiers `whenNotPaused` and `whenPaused`, which can be applied to</span>
  15 |     | <span class='neutral'> * the functions of your contract. Note that they will not be pausable by</span>
  16 |     | <span class='neutral'> * simply including this module, only once the modifiers are put in place.</span>
  17 |     | <span class='neutral'> */</span>
  18 |     | <span class='neutral'>abstract contract PausableUpgradeable is Initializable, ContextUpgradeable {</span>
  19 |     | <span class='neutral'>    /// @custom:storage-location erc7201:openzeppelin.storage.Pausable</span>
  20 |     | <span class='neutral'>    struct PausableStorage {</span>
  21 |     | <span class='neutral'>        bool _paused;</span>
  22 |     | <span class='neutral'>    }</span>
  23 |     | <span class='neutral'></span>
  24 |     | <span class='neutral'>    // keccak256(abi.encode(uint256(keccak256(&quot;openzeppelin.storage.Pausable&quot;)) - 1)) &amp; ~bytes32(uint256(0xff))</span>
  25 |     | <span class='neutral'>    bytes32 private constant PausableStorageLocation = 0xcd5ed15c6e187e77e9aee88184c21f4f2182ab5827cb3b7e07fbedcd63f03300;</span>
  26 |     | <span class='neutral'></span>
  27 |     | <span class='neutral'>    function _getPausableStorage() private pure returns (PausableStorage storage $) {</span>
  28 |     | <span class='neutral'>        assembly {</span>
  29 |     | <span class='neutral'>            $.slot := PausableStorageLocation</span>
  30 |     | <span class='neutral'>        }</span>
  31 |     | <span class='neutral'>    }</span>
  32 |     | <span class='neutral'></span>
  33 |     | <span class='neutral'>    /**</span>
  34 |     | <span class='neutral'>     * @dev Emitted when the pause is triggered by `account`.</span>
  35 |     | <span class='neutral'>     */</span>
  36 |     | <span class='neutral'>    event Paused(address account);</span>
  37 |     | <span class='neutral'></span>
  38 |     | <span class='neutral'>    /**</span>
  39 |     | <span class='neutral'>     * @dev Emitted when the pause is lifted by `account`.</span>
  40 |     | <span class='neutral'>     */</span>
  41 |     | <span class='neutral'>    event Unpaused(address account);</span>
  42 |     | <span class='neutral'></span>
  43 |     | <span class='neutral'>    /**</span>
  44 |     | <span class='neutral'>     * @dev The operation failed because the contract is paused.</span>
  45 |     | <span class='neutral'>     */</span>
  46 |     | <span class='neutral'>    error EnforcedPause();</span>
  47 |     | <span class='neutral'></span>
  48 |     | <span class='neutral'>    /**</span>
  49 |     | <span class='neutral'>     * @dev The operation failed because the contract is not paused.</span>
  50 |     | <span class='neutral'>     */</span>
  51 |     | <span class='neutral'>    error ExpectedPause();</span>
  52 |     | <span class='neutral'></span>
  53 |     | <span class='neutral'>    /**</span>
  54 |     | <span class='neutral'>     * @dev Modifier to make a function callable only when the contract is not paused.</span>
  55 |     | <span class='neutral'>     *</span>
  56 |     | <span class='neutral'>     * Requirements:</span>
  57 |     | <span class='neutral'>     *</span>
  58 |     | <span class='neutral'>     * - The contract must not be paused.</span>
  59 |     | <span class='neutral'>     */</span>
  60 |     | <span class='neutral'>    modifier whenNotPaused() {</span>
  61 |     | <span class='neutral'>        _requireNotPaused();</span>
  62 |     | <span class='neutral'>        _;</span>
  63 |     | <span class='neutral'>    }</span>
  64 |     | <span class='neutral'></span>
  65 |     | <span class='neutral'>    /**</span>
  66 |     | <span class='neutral'>     * @dev Modifier to make a function callable only when the contract is paused.</span>
  67 |     | <span class='neutral'>     *</span>
  68 |     | <span class='neutral'>     * Requirements:</span>
  69 |     | <span class='neutral'>     *</span>
  70 |     | <span class='neutral'>     * - The contract must be paused.</span>
  71 |     | <span class='neutral'>     */</span>
  72 |     | <span class='neutral'>    modifier whenPaused() {</span>
  73 |     | <span class='neutral'>        _requirePaused();</span>
  74 |     | <span class='neutral'>        _;</span>
  75 |     | <span class='neutral'>    }</span>
  76 |     | <span class='neutral'></span>
  77 |     | <span class='neutral'>    function __Pausable_init() internal onlyInitializing {</span>
  78 |     | <span class='neutral'>    }</span>
  79 |     | <span class='neutral'></span>
  80 |     | <span class='neutral'>    function __Pausable_init_unchained() internal onlyInitializing {</span>
  81 |     | <span class='neutral'>    }</span>
  82 |     | <span class='neutral'>    /**</span>
  83 |     | <span class='neutral'>     * @dev Returns true if the contract is paused, and false otherwise.</span>
  84 |     | <span class='neutral'>     */</span>
  85 |     | <span class='neutral'>    function paused() public view virtual returns (bool) {</span>
  86 |     | <span class='neutral'>        PausableStorage storage $ = _getPausableStorage();</span>
  87 |     | <span class='neutral'>        return $._paused;</span>
  88 |     | <span class='neutral'>    }</span>
  89 |     | <span class='neutral'></span>
  90 |     | <span class='neutral'>    /**</span>
  91 |     | <span class='neutral'>     * @dev Throws if the contract is paused.</span>
  92 |     | <span class='neutral'>     */</span>
  93 |     | <span class='neutral'>    function _requireNotPaused() internal view virtual {</span>
  94 |     | <span class='neutral'>        if (paused()) {</span>
  95 |     | <span class='neutral'>            revert EnforcedPause();</span>
  96 |     | <span class='neutral'>        }</span>
  97 |     | <span class='neutral'>    }</span>
  98 |     | <span class='neutral'></span>
  99 |     | <span class='neutral'>    /**</span>
 100 |     | <span class='neutral'>     * @dev Throws if the contract is not paused.</span>
 101 |     | <span class='neutral'>     */</span>
 102 |     | <span class='neutral'>    function _requirePaused() internal view virtual {</span>
 103 |     | <span class='neutral'>        if (!paused()) {</span>
 104 |     | <span class='neutral'>            revert ExpectedPause();</span>
 105 |     | <span class='neutral'>        }</span>
 106 |     | <span class='neutral'>    }</span>
 107 |     | <span class='neutral'></span>
 108 |     | <span class='neutral'>    /**</span>
 109 |     | <span class='neutral'>     * @dev Triggers stopped state.</span>
 110 |     | <span class='neutral'>     *</span>
 111 |     | <span class='neutral'>     * Requirements:</span>
 112 |     | <span class='neutral'>     *</span>
 113 |     | <span class='neutral'>     * - The contract must not be paused.</span>
 114 |     | <span class='neutral'>     */</span>
 115 |     | <span class='neutral'>    function _pause() internal virtual whenNotPaused {</span>
 116 |     | <span class='neutral'>        PausableStorage storage $ = _getPausableStorage();</span>
 117 |     | <span class='neutral'>        $._paused = true;</span>
 118 |     | <span class='neutral'>        emit Paused(_msgSender());</span>
 119 |     | <span class='neutral'>    }</span>
 120 |     | <span class='neutral'></span>
 121 |     | <span class='neutral'>    /**</span>
 122 |     | <span class='neutral'>     * @dev Returns to normal state.</span>
 123 |     | <span class='neutral'>     *</span>
 124 |     | <span class='neutral'>     * Requirements:</span>
 125 |     | <span class='neutral'>     *</span>
 126 |     | <span class='neutral'>     * - The contract must be paused.</span>
 127 |     | <span class='neutral'>     */</span>
 128 |     | <span class='neutral'>    function _unpause() internal virtual whenPaused {</span>
 129 |     | <span class='neutral'>        PausableStorage storage $ = _getPausableStorage();</span>
 130 |     | <span class='neutral'>        $._paused = false;</span>
 131 |     | <span class='neutral'>        emit Unpaused(_msgSender());</span>
 132 |     | <span class='neutral'>    }</span>
 133 |     | <span class='neutral'>}</span>
 134 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/phantom/Documents/azemora/azemora-contracts/lib/openzeppelin-contracts-upgradeable/contracts/utils/ReentrancyGuardUpgradeable.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'>// OpenZeppelin Contracts (last updated v5.1.0) (utils/ReentrancyGuard.sol)</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>pragma solidity ^0.8.20;</span>
   5 |     | <span class='neutral'>import {Initializable} from &quot;../proxy/utils/Initializable.sol&quot;;</span>
   6 |     | <span class='neutral'></span>
   7 |     | <span class='neutral'>/**</span>
   8 |     | <span class='neutral'> * @dev Contract module that helps prevent reentrant calls to a function.</span>
   9 |     | <span class='neutral'> *</span>
  10 |     | <span class='neutral'> * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier</span>
  11 |     | <span class='neutral'> * available, which can be applied to functions to make sure there are no nested</span>
  12 |     | <span class='neutral'> * (reentrant) calls to them.</span>
  13 |     | <span class='neutral'> *</span>
  14 |     | <span class='neutral'> * Note that because there is a single `nonReentrant` guard, functions marked as</span>
  15 |     | <span class='neutral'> * `nonReentrant` may not call one another. This can be worked around by making</span>
  16 |     | <span class='unexecuted'> * those functions `private`, and then adding `external` `nonReentrant` entry</span>
  17 |     | <span class='neutral'> * points to them.</span>
  18 |     | <span class='neutral'> *</span>
  19 |     | <span class='neutral'> * TIP: If EIP-1153 (transient storage) is available on the chain you&#39;re deploying at,</span>
  20 |     | <span class='neutral'> * consider using {ReentrancyGuardTransient} instead.</span>
  21 |     | <span class='neutral'> *</span>
  22 |     | <span class='neutral'> * TIP: If you would like to learn more about reentrancy and alternative ways</span>
  23 |     | <span class='neutral'> * to protect against it, check out our blog post</span>
  24 |     | <span class='neutral'> * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].</span>
  25 |     | <span class='neutral'> */</span>
  26 |     | <span class='neutral'>abstract contract ReentrancyGuardUpgradeable is Initializable {</span>
  27 |     | <span class='neutral'>    // Booleans are more expensive than uint256 or any type that takes up a full</span>
  28 |     | <span class='neutral'>    // word because each write operation emits an extra SLOAD to first read the</span>
  29 |     | <span class='neutral'>    // slot&#39;s contents, replace the bits taken up by the boolean, and then write</span>
  30 |     | <span class='neutral'>    // back. This is the compiler&#39;s defense against contract upgrades and</span>
  31 |     | <span class='neutral'>    // pointer aliasing, and it cannot be disabled.</span>
  32 |     | <span class='neutral'></span>
  33 |     | <span class='neutral'>    // The values being non-zero value makes deployment a bit more expensive,</span>
  34 |     | <span class='neutral'>    // but in exchange the refund on every call to nonReentrant will be lower in</span>
  35 |     | <span class='neutral'>    // amount. Since refunds are capped to a percentage of the total</span>
  36 |     | <span class='neutral'>    // transaction&#39;s gas, it is best to keep them low in cases like this one, to</span>
  37 |     | <span class='neutral'>    // increase the likelihood of the full refund coming into effect.</span>
  38 |     | <span class='neutral'>    uint256 private constant NOT_ENTERED = 1;</span>
  39 |     | <span class='neutral'>    uint256 private constant ENTERED = 2;</span>
  40 |     | <span class='neutral'></span>
  41 |     | <span class='neutral'>    /// @custom:storage-location erc7201:openzeppelin.storage.ReentrancyGuard</span>
  42 |     | <span class='neutral'>    struct ReentrancyGuardStorage {</span>
  43 |     | <span class='neutral'>        uint256 _status;</span>
  44 |     | <span class='neutral'>    }</span>
  45 |     | <span class='neutral'></span>
  46 |     | <span class='neutral'>    // keccak256(abi.encode(uint256(keccak256(&quot;openzeppelin.storage.ReentrancyGuard&quot;)) - 1)) &amp; ~bytes32(uint256(0xff))</span>
  47 |     | <span class='neutral'>    bytes32 private constant ReentrancyGuardStorageLocation = 0x9b779b17422d0df92223018b32b4d1fa46e071723d6817e2486d003becc55f00;</span>
  48 |     | <span class='neutral'></span>
  49 |     | <span class='neutral'>    function _getReentrancyGuardStorage() private pure returns (ReentrancyGuardStorage storage $) {</span>
  50 |     | <span class='neutral'>        assembly {</span>
  51 |     | <span class='neutral'>            $.slot := ReentrancyGuardStorageLocation</span>
  52 |     | <span class='neutral'>        }</span>
  53 |     | <span class='neutral'>    }</span>
  54 |     | <span class='neutral'></span>
  55 |     | <span class='neutral'>    /**</span>
  56 |     | <span class='neutral'>     * @dev Unauthorized reentrant call.</span>
  57 |     | <span class='neutral'>     */</span>
  58 |     | <span class='neutral'>    error ReentrancyGuardReentrantCall();</span>
  59 |     | <span class='neutral'></span>
  60 |     | <span class='neutral'>    function __ReentrancyGuard_init() internal onlyInitializing {</span>
  61 |     | <span class='neutral'>        __ReentrancyGuard_init_unchained();</span>
  62 |     | <span class='neutral'>    }</span>
  63 |     | <span class='neutral'></span>
  64 |     | <span class='neutral'>    function __ReentrancyGuard_init_unchained() internal onlyInitializing {</span>
  65 |     | <span class='neutral'>        ReentrancyGuardStorage storage $ = _getReentrancyGuardStorage();</span>
  66 |     | <span class='neutral'>        $._status = NOT_ENTERED;</span>
  67 |     | <span class='neutral'>    }</span>
  68 |     | <span class='neutral'></span>
  69 |     | <span class='neutral'>    /**</span>
  70 |     | <span class='neutral'>     * @dev Prevents a contract from calling itself, directly or indirectly.</span>
  71 |     | <span class='neutral'>     * Calling a `nonReentrant` function from another `nonReentrant`</span>
  72 |     | <span class='neutral'>     * function is not supported. It is possible to prevent this from happening</span>
  73 |     | <span class='neutral'>     * by making the `nonReentrant` function external, and making it call a</span>
  74 |     | <span class='neutral'>     * `private` function that does the actual work.</span>
  75 |     | <span class='neutral'>     */</span>
  76 |     | <span class='neutral'>    modifier nonReentrant() {</span>
  77 |     | <span class='neutral'>        _nonReentrantBefore();</span>
  78 |     | <span class='neutral'>        _;</span>
  79 |     | <span class='neutral'>        _nonReentrantAfter();</span>
  80 |     | <span class='neutral'>    }</span>
  81 |     | <span class='neutral'></span>
  82 |     | <span class='neutral'>    function _nonReentrantBefore() private {</span>
  83 |     | <span class='neutral'>        ReentrancyGuardStorage storage $ = _getReentrancyGuardStorage();</span>
  84 |     | <span class='neutral'>        // On the first call to nonReentrant, _status will be NOT_ENTERED</span>
  85 |     | <span class='neutral'>        if ($._status == ENTERED) {</span>
  86 |     | <span class='neutral'>            revert ReentrancyGuardReentrantCall();</span>
  87 |     | <span class='neutral'>        }</span>
  88 |     | <span class='neutral'></span>
  89 |     | <span class='neutral'>        // Any calls to nonReentrant after this point will fail</span>
  90 |     | <span class='neutral'>        $._status = ENTERED;</span>
  91 |     | <span class='neutral'>    }</span>
  92 |     | <span class='neutral'></span>
  93 |     | <span class='neutral'>    function _nonReentrantAfter() private {</span>
  94 |     | <span class='neutral'>        ReentrancyGuardStorage storage $ = _getReentrancyGuardStorage();</span>
  95 |     | <span class='neutral'>        // By storing the original value once again, a refund is triggered (see</span>
  96 |     | <span class='neutral'>        // https://eips.ethereum.org/EIPS/eip-2200)</span>
  97 |     | <span class='neutral'>        $._status = NOT_ENTERED;</span>
  98 |     | <span class='neutral'>    }</span>
  99 |     | <span class='neutral'></span>
 100 |     | <span class='neutral'>    /**</span>
 101 |     | <span class='neutral'>     * @dev Returns true if the reentrancy guard is currently set to &quot;entered&quot;, which indicates there is a</span>
 102 |     | <span class='neutral'>     * `nonReentrant` function in the call stack.</span>
 103 |     | <span class='neutral'>     */</span>
 104 |     | <span class='neutral'>    function _reentrancyGuardEntered() internal view returns (bool) {</span>
 105 |     | <span class='neutral'>        ReentrancyGuardStorage storage $ = _getReentrancyGuardStorage();</span>
 106 |     | <span class='neutral'>        return $._status == ENTERED;</span>
 107 |     | <span class='neutral'>    }</span>
 108 |     | <span class='neutral'>}</span>
 109 |     | <span class='unexecuted'></span>

</code>
<br />

<b>/home/phantom/Documents/azemora/azemora-contracts/lib/openzeppelin-contracts-upgradeable/contracts/utils/cryptography/EIP712Upgradeable.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'>// OpenZeppelin Contracts (last updated v5.3.0) (utils/cryptography/EIP712.sol)</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>pragma solidity ^0.8.20;</span>
   5 |     | <span class='neutral'></span>
   6 |     | <span class='neutral'>import {MessageHashUtils} from &quot;@openzeppelin/contracts/utils/cryptography/MessageHashUtils.sol&quot;;</span>
   7 |     | <span class='neutral'>import {IERC5267} from &quot;@openzeppelin/contracts/interfaces/IERC5267.sol&quot;;</span>
   8 |     | <span class='neutral'>import {Initializable} from &quot;../../proxy/utils/Initializable.sol&quot;;</span>
   9 |     | <span class='neutral'></span>
  10 |     | <span class='neutral'>/**</span>
  11 |     | <span class='neutral'> * @dev https://eips.ethereum.org/EIPS/eip-712[EIP-712] is a standard for hashing and signing of typed structured data.</span>
  12 |     | <span class='neutral'> *</span>
  13 |     | <span class='neutral'> * The encoding scheme specified in the EIP requires a domain separator and a hash of the typed structured data, whose</span>
  14 |     | <span class='neutral'> * encoding is very generic and therefore its implementation in Solidity is not feasible, thus this contract</span>
  15 |     | <span class='unexecuted'> * does not implement the encoding itself. Protocols need to implement the type-specific encoding they need in order to</span>
  16 |     | <span class='neutral'> * produce the hash of their typed data using a combination of `abi.encode` and `keccak256`.</span>
  17 |     | <span class='neutral'> *</span>
  18 |     | <span class='neutral'> * This contract implements the EIP-712 domain separator ({_domainSeparatorV4}) that is used as part of the encoding</span>
  19 |     | <span class='neutral'> * scheme, and the final step of the encoding to obtain the message digest that is then signed via ECDSA</span>
  20 |     | <span class='neutral'> * ({_hashTypedDataV4}).</span>
  21 |     | <span class='neutral'> *</span>
  22 |     | <span class='neutral'> * The implementation of the domain separator was designed to be as efficient as possible while still properly updating</span>
  23 |     | <span class='neutral'> * the chain id to protect against replay attacks on an eventual fork of the chain.</span>
  24 |     | <span class='neutral'> *</span>
  25 |     | <span class='neutral'> * NOTE: This contract implements the version of the encoding known as &quot;v4&quot;, as implemented by the JSON RPC method</span>
  26 |     | <span class='neutral'> * https://docs.metamask.io/guide/signing-data.html[`eth_signTypedDataV4` in MetaMask].</span>
  27 |     | <span class='neutral'> *</span>
  28 |     | <span class='unexecuted'> * NOTE: The upgradeable version of this contract does not use an immutable cache and recomputes the domain separator</span>
  29 |     | <span class='unexecuted'> * each time {_domainSeparatorV4} is called. That is cheaper than accessing a cached version in cold storage.</span>
  30 |     | <span class='neutral'> */</span>
  31 |     | <span class='unexecuted'>abstract contract EIP712Upgradeable is Initializable, IERC5267 {</span>
  32 |     | <span class='unexecuted'>    bytes32 private constant TYPE_HASH =</span>
  33 |     | <span class='neutral'>        keccak256(&quot;EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)&quot;);</span>
  34 |     | <span class='neutral'></span>
  35 |     | <span class='neutral'>    /// @custom:storage-location erc7201:openzeppelin.storage.EIP712</span>
  36 |     | <span class='neutral'>    struct EIP712Storage {</span>
  37 |     | <span class='neutral'>        /// @custom:oz-renamed-from _HASHED_NAME</span>
  38 |     | <span class='neutral'>        bytes32 _hashedName;</span>
  39 |     | <span class='neutral'>        /// @custom:oz-renamed-from _HASHED_VERSION</span>
  40 |     | <span class='neutral'>        bytes32 _hashedVersion;</span>
  41 |     | <span class='neutral'></span>
  42 |     | <span class='neutral'>        string _name;</span>
  43 |     | <span class='neutral'>        string _version;</span>
  44 |     | <span class='neutral'>    }</span>
  45 |     | <span class='neutral'></span>
  46 |     | <span class='neutral'>    // keccak256(abi.encode(uint256(keccak256(&quot;openzeppelin.storage.EIP712&quot;)) - 1)) &amp; ~bytes32(uint256(0xff))</span>
  47 |     | <span class='neutral'>    bytes32 private constant EIP712StorageLocation = 0xa16a46d94261c7517cc8ff89f61c0ce93598e3c849801011dee649a6a557d100;</span>
  48 |     | <span class='neutral'></span>
  49 |     | <span class='neutral'>    function _getEIP712Storage() private pure returns (EIP712Storage storage $) {</span>
  50 |     | <span class='neutral'>        assembly {</span>
  51 |     | <span class='neutral'>            $.slot := EIP712StorageLocation</span>
  52 |     | <span class='neutral'>        }</span>
  53 |     | <span class='neutral'>    }</span>
  54 |     | <span class='neutral'></span>
  55 |     | <span class='neutral'>    /**</span>
  56 |     | <span class='neutral'>     * @dev Initializes the domain separator and parameter caches.</span>
  57 |     | <span class='neutral'>     *</span>
  58 |     | <span class='neutral'>     * The meaning of `name` and `version` is specified in</span>
  59 |     | <span class='neutral'>     * https://eips.ethereum.org/EIPS/eip-712#definition-of-domainseparator[EIP-712]:</span>
  60 |     | <span class='neutral'>     *</span>
  61 |     | <span class='neutral'>     * - `name`: the user readable name of the signing domain, i.e. the name of the DApp or the protocol.</span>
  62 |     | <span class='unexecuted'>     * - `version`: the current major version of the signing domain.</span>
  63 |     | <span class='neutral'>     *</span>
  64 |     | <span class='unexecuted'>     * NOTE: These parameters cannot be changed except through a xref:learn::upgrading-smart-contracts.adoc[smart</span>
  65 |     | <span class='unexecuted'>     * contract upgrade].</span>
  66 |     | <span class='unexecuted'>     */</span>
  67 |     | <span class='unexecuted'>    function __EIP712_init(string memory name, string memory version) internal onlyInitializing {</span>
  68 |     | <span class='unexecuted'>        __EIP712_init_unchained(name, version);</span>
  69 |     | <span class='unexecuted'>    }</span>
  70 |     | <span class='neutral'></span>
  71 |     | <span class='unexecuted'>    function __EIP712_init_unchained(string memory name, string memory version) internal onlyInitializing {</span>
  72 |     | <span class='neutral'>        EIP712Storage storage $ = _getEIP712Storage();</span>
  73 |     | <span class='neutral'>        $._name = name;</span>
  74 |     | <span class='neutral'>        $._version = version;</span>
  75 |     | <span class='neutral'></span>
  76 |     | <span class='neutral'>        // Reset prior values in storage if upgrading</span>
  77 |     | <span class='neutral'>        $._hashedName = 0;</span>
  78 |     | <span class='neutral'>        $._hashedVersion = 0;</span>
  79 |     | <span class='neutral'>    }</span>
  80 |     | <span class='neutral'></span>
  81 |     | <span class='neutral'>    /**</span>
  82 |     | <span class='neutral'>     * @dev Returns the domain separator for the current chain.</span>
  83 |     | <span class='neutral'>     */</span>
  84 |     | <span class='neutral'>    function _domainSeparatorV4() internal view returns (bytes32) {</span>
  85 |     | <span class='neutral'>        return _buildDomainSeparator();</span>
  86 |     | <span class='neutral'>    }</span>
  87 |     | <span class='neutral'></span>
  88 |     | <span class='neutral'>    function _buildDomainSeparator() private view returns (bytes32) {</span>
  89 |     | <span class='neutral'>        return keccak256(abi.encode(TYPE_HASH, _EIP712NameHash(), _EIP712VersionHash(), block.chainid, address(this)));</span>
  90 |     | <span class='neutral'>    }</span>
  91 |     | <span class='neutral'></span>
  92 |     | <span class='neutral'>    /**</span>
  93 |     | <span class='neutral'>     * @dev Given an already https://eips.ethereum.org/EIPS/eip-712#definition-of-hashstruct[hashed struct], this</span>
  94 |     | <span class='neutral'>     * function returns the hash of the fully encoded EIP712 message for this domain.</span>
  95 |     | <span class='neutral'>     *</span>
  96 |     | <span class='neutral'>     * This hash can be used together with {ECDSA-recover} to obtain the signer of a message. For example:</span>
  97 |     | <span class='neutral'>     *</span>
  98 |     | <span class='neutral'>     * ```solidity</span>
  99 |     | <span class='neutral'>     * bytes32 digest = _hashTypedDataV4(keccak256(abi.encode(</span>
 100 |     | <span class='neutral'>     *     keccak256(&quot;Mail(address to,string contents)&quot;),</span>
 101 |     | <span class='neutral'>     *     mailTo,</span>
 102 |     | <span class='neutral'>     *     keccak256(bytes(mailContents))</span>
 103 |     | <span class='neutral'>     * )));</span>
 104 |     | <span class='neutral'>     * address signer = ECDSA.recover(digest, signature);</span>
 105 |     | <span class='neutral'>     * ```</span>
 106 |     | <span class='neutral'>     */</span>
 107 |     | <span class='neutral'>    function _hashTypedDataV4(bytes32 structHash) internal view virtual returns (bytes32) {</span>
 108 |     | <span class='neutral'>        return MessageHashUtils.toTypedDataHash(_domainSeparatorV4(), structHash);</span>
 109 |     | <span class='neutral'>    }</span>
 110 |     | <span class='neutral'></span>
 111 |     | <span class='neutral'>    /// @inheritdoc IERC5267</span>
 112 |     | <span class='neutral'>    function eip712Domain()</span>
 113 |     | <span class='neutral'>        public</span>
 114 |     | <span class='neutral'>        view</span>
 115 |     | <span class='neutral'>        virtual</span>
 116 |     | <span class='neutral'>        returns (</span>
 117 |     | <span class='neutral'>            bytes1 fields,</span>
 118 |     | <span class='neutral'>            string memory name,</span>
 119 |     | <span class='unexecuted'>            string memory version,</span>
 120 |     | <span class='unexecuted'>            uint256 chainId,</span>
 121 |     | <span class='neutral'>            address verifyingContract,</span>
 122 |     | <span class='neutral'>            bytes32 salt,</span>
 123 |     | <span class='neutral'>            uint256[] memory extensions</span>
 124 |     | <span class='neutral'>        )</span>
 125 |     | <span class='neutral'>    {</span>
 126 |     | <span class='neutral'>        EIP712Storage storage $ = _getEIP712Storage();</span>
 127 |     | <span class='neutral'>        // If the hashed name and version in storage are non-zero, the contract hasn&#39;t been properly initialized</span>
 128 |     | <span class='neutral'>        // and the EIP712 domain is not reliable, as it will be missing name and version.</span>
 129 |     | <span class='unexecuted'>        require($._hashedName == 0 &amp;&amp; $._hashedVersion == 0, &quot;EIP712: Uninitialized&quot;);</span>
 130 |     | <span class='neutral'></span>
 131 |     | <span class='neutral'>        return (</span>
 132 |     | <span class='neutral'>            hex&quot;0f&quot;, // 01111</span>
 133 |     | <span class='neutral'>            _EIP712Name(),</span>
 134 |     | <span class='neutral'>            _EIP712Version(),</span>
 135 |     | <span class='neutral'>            block.chainid,</span>
 136 |     | <span class='neutral'>            address(this),</span>
 137 |     | <span class='neutral'>            bytes32(0),</span>
 138 |     | <span class='neutral'>            new uint256[](0)</span>
 139 |     | <span class='neutral'>        );</span>
 140 |     | <span class='neutral'>    }</span>
 141 |     | <span class='neutral'></span>
 142 |     | <span class='neutral'>    /**</span>
 143 |     | <span class='neutral'>     * @dev The name parameter for the EIP712 domain.</span>
 144 |     | <span class='neutral'>     *</span>
 145 |     | <span class='neutral'>     * NOTE: This function reads from storage by default, but can be redefined to return a constant value if gas costs</span>
 146 |     | <span class='neutral'>     * are a concern.</span>
 147 |     | <span class='neutral'>     */</span>
 148 |     | <span class='neutral'>    function _EIP712Name() internal view virtual returns (string memory) {</span>
 149 |     | <span class='neutral'>        EIP712Storage storage $ = _getEIP712Storage();</span>
 150 |     | <span class='neutral'>        return $._name;</span>
 151 |     | <span class='neutral'>    }</span>
 152 |     | <span class='neutral'></span>
 153 |     | <span class='neutral'>    /**</span>
 154 |     | <span class='neutral'>     * @dev The version parameter for the EIP712 domain.</span>
 155 |     | <span class='neutral'>     *</span>
 156 |     | <span class='neutral'>     * NOTE: This function reads from storage by default, but can be redefined to return a constant value if gas costs</span>
 157 |     | <span class='neutral'>     * are a concern.</span>
 158 |     | <span class='neutral'>     */</span>
 159 |     | <span class='neutral'>    function _EIP712Version() internal view virtual returns (string memory) {</span>
 160 |     | <span class='neutral'>        EIP712Storage storage $ = _getEIP712Storage();</span>
 161 |     | <span class='neutral'>        return $._version;</span>
 162 |     | <span class='neutral'>    }</span>
 163 |     | <span class='neutral'></span>
 164 |     | <span class='neutral'>    /**</span>
 165 |     | <span class='neutral'>     * @dev The hash of the name parameter for the EIP712 domain.</span>
 166 |     | <span class='neutral'>     *</span>
 167 |     | <span class='neutral'>     * NOTE: In previous versions this function was virtual. In this version you should override `_EIP712Name` instead.</span>
 168 |     | <span class='neutral'>     */</span>
 169 |     | <span class='neutral'>    function _EIP712NameHash() internal view returns (bytes32) {</span>
 170 |     | <span class='neutral'>        EIP712Storage storage $ = _getEIP712Storage();</span>
 171 |     | <span class='neutral'>        string memory name = _EIP712Name();</span>
 172 |     | <span class='neutral'>        if (bytes(name).length &gt; 0) {</span>
 173 |     | <span class='neutral'>            return keccak256(bytes(name));</span>
 174 |     | <span class='neutral'>        } else {</span>
 175 |     | <span class='neutral'>            // If the name is empty, the contract may have been upgraded without initializing the new storage.</span>
 176 |     | <span class='neutral'>            // We return the name hash in storage if non-zero, otherwise we assume the name is empty by design.</span>
 177 |     | <span class='neutral'>            bytes32 hashedName = $._hashedName;</span>
 178 |     | <span class='neutral'>            if (hashedName != 0) {</span>
 179 |     | <span class='neutral'>                return hashedName;</span>
 180 |     | <span class='neutral'>            } else {</span>
 181 |     | <span class='neutral'>                return keccak256(&quot;&quot;);</span>
 182 |     | <span class='neutral'>            }</span>
 183 |     | <span class='neutral'>        }</span>
 184 |     | <span class='neutral'>    }</span>
 185 |     | <span class='neutral'></span>
 186 |     | <span class='neutral'>    /**</span>
 187 |     | <span class='neutral'>     * @dev The hash of the version parameter for the EIP712 domain.</span>
 188 |     | <span class='neutral'>     *</span>
 189 |     | <span class='neutral'>     * NOTE: In previous versions this function was virtual. In this version you should override `_EIP712Version` instead.</span>
 190 |     | <span class='neutral'>     */</span>
 191 |     | <span class='neutral'>    function _EIP712VersionHash() internal view returns (bytes32) {</span>
 192 |     | <span class='neutral'>        EIP712Storage storage $ = _getEIP712Storage();</span>
 193 |     | <span class='neutral'>        string memory version = _EIP712Version();</span>
 194 |     | <span class='neutral'>        if (bytes(version).length &gt; 0) {</span>
 195 |     | <span class='neutral'>            return keccak256(bytes(version));</span>
 196 |     | <span class='neutral'>        } else {</span>
 197 |     | <span class='neutral'>            // If the version is empty, the contract may have been upgraded without initializing the new storage.</span>
 198 |     | <span class='neutral'>            // We return the version hash in storage if non-zero, otherwise we assume the version is empty by design.</span>
 199 |     | <span class='neutral'>            bytes32 hashedVersion = $._hashedVersion;</span>
 200 |     | <span class='neutral'>            if (hashedVersion != 0) {</span>
 201 |     | <span class='neutral'>                return hashedVersion;</span>
 202 |     | <span class='neutral'>            } else {</span>
 203 |     | <span class='neutral'>                return keccak256(&quot;&quot;);</span>
 204 |     | <span class='neutral'>            }</span>
 205 |     | <span class='neutral'>        }</span>
 206 |     | <span class='neutral'>    }</span>
 207 |     | <span class='neutral'>}</span>
 208 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/phantom/Documents/azemora/azemora-contracts/lib/openzeppelin-contracts-upgradeable/contracts/utils/introspection/ERC165Upgradeable.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>// OpenZeppelin Contracts (last updated v5.1.0) (utils/introspection/ERC165.sol)</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>pragma solidity ^0.8.20;</span>
  5 |     | <span class='neutral'></span>
  6 |     | <span class='neutral'>import {IERC165} from &quot;@openzeppelin/contracts/utils/introspection/IERC165.sol&quot;;</span>
  7 |     | <span class='neutral'>import {Initializable} from &quot;../../proxy/utils/Initializable.sol&quot;;</span>
  8 |     | <span class='neutral'></span>
  9 |     | <span class='neutral'>/**</span>
 10 |     | <span class='neutral'> * @dev Implementation of the {IERC165} interface.</span>
 11 |     | <span class='neutral'> *</span>
 12 |     | <span class='neutral'> * Contracts that want to implement ERC-165 should inherit from this contract and override {supportsInterface} to check</span>
 13 |     | <span class='neutral'> * for the additional interface id that will be supported. For example:</span>
 14 |     | <span class='neutral'> *</span>
 15 |     | <span class='neutral'> * ```solidity</span>
 16 |     | <span class='unexecuted'> * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {</span>
 17 |     | <span class='neutral'> *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);</span>
 18 |     | <span class='neutral'> * }</span>
 19 |     | <span class='neutral'> * ```</span>
 20 |     | <span class='neutral'> */</span>
 21 |     | <span class='neutral'>abstract contract ERC165Upgradeable is Initializable, IERC165 {</span>
 22 |     | <span class='neutral'>    function __ERC165_init() internal onlyInitializing {</span>
 23 |     | <span class='neutral'>    }</span>
 24 |     | <span class='neutral'></span>
 25 |     | <span class='unexecuted'>    function __ERC165_init_unchained() internal onlyInitializing {</span>
 26 |     | <span class='neutral'>    }</span>
 27 |     | <span class='unexecuted'>    /// @inheritdoc IERC165</span>
 28 |     | <span class='unexecuted'>    function supportsInterface(bytes4 interfaceId) public view virtual returns (bool) {</span>
 29 |     | <span class='neutral'>        return interfaceId == type(IERC165).interfaceId;</span>
 30 |     | <span class='neutral'>    }</span>
 31 |     | <span class='neutral'>}</span>
 32 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/phantom/Documents/azemora/azemora-contracts/src/core/DynamicImpactCredit.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'>pragma solidity ^0.8.20;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>import &quot;@openzeppelin/contracts-upgradeable/token/ERC1155/ERC1155Upgradeable.sol&quot;;</span>
   5 |     | <span class='neutral'>import &quot;@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol&quot;;</span>
   6 |     | <span class='neutral'>import &quot;@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol&quot;;</span>
   7 |     | <span class='neutral'>import &quot;@openzeppelin/contracts-upgradeable/utils/PausableUpgradeable.sol&quot;;</span>
   8 |     | <span class='neutral'>import &quot;./ProjectRegistry.sol&quot;;</span>
   9 |     | <span class='neutral'></span>
  10 |     | <span class='neutral'>// --- Custom Errors ---</span>
  11 |     | <span class='neutral'>error DynamicImpactCredit__ProjectNotActive();</span>
  12 |     | <span class='neutral'>error DynamicImpactCredit__URINotSet();</span>
  13 |     | <span class='neutral'>error DynamicImpactCredit__NotAuthorized();</span>
  14 |     | <span class='neutral'>error DynamicImpactCredit__LengthMismatch();</span>
  15 |     | <span class='neutral'></span>
  16 |     | <span class='neutral'>/**</span>
  17 |     | <span class='neutral'> * @title DynamicImpactCredit</span>
  18 |     | <span class='neutral'> * @author Genci Mehmeti</span>
  19 |     | <span class='neutral'> * @dev An ERC1155 token contract for creating dynamic environmental assets.</span>
  20 |     | <span class='neutral'> * Each `tokenId`, derived from a `projectId`, represents a unique class of impact credit.</span>
  21 |     | <span class='neutral'> * The contract stores a history of metadata URIs for each token, allowing its</span>
  22 |     | <span class='neutral'> * attributes to evolve as new dMRV data is verified. Minting is restricted to</span>
  23 |     | <span class='neutral'> * the `DMRVManager` contract, ensuring credits are only created based on validated impact.</span>
  24 |     | <span class='neutral'> * It is upgradeable using the UUPS pattern.</span>
  25 |     | <span class='neutral'> */</span>
  26 | *   | <span class='executed'>contract DynamicImpactCredit is ERC1155Upgradeable, AccessControlUpgradeable, UUPSUpgradeable, PausableUpgradeable {</span>
  27 | *   | <span class='executed'>    bytes32 public constant DMRV_MANAGER_ROLE = keccak256(&quot;DMRV_MANAGER_ROLE&quot;);</span>
  28 | *   | <span class='executed'>    bytes32 public constant METADATA_UPDATER_ROLE = keccak256(&quot;METADATA_UPDATER_ROLE&quot;);</span>
  29 | *   | <span class='executed'>    bytes32 public constant PAUSER_ROLE = keccak256(&quot;PAUSER_ROLE&quot;);</span>
  30 |     | <span class='neutral'></span>
  31 |     | <span class='neutral'>    bytes32[] private _roles;</span>
  32 |     | <span class='neutral'></span>
  33 |     | <span class='neutral'>    mapping(uint256 =&gt; string[]) private _tokenURIs;</span>
  34 |     | <span class='neutral'>    string private _contractURI;</span>
  35 |     | <span class='unexecuted'>    IProjectRegistry public immutable projectRegistry;</span>
  36 |     | <span class='neutral'></span>
  37 |     | <span class='neutral'>    uint256[50] private __gap;</span>
  38 |     | <span class='neutral'></span>
  39 |     | <span class='neutral'>    // --- Events ---</span>
  40 |     | <span class='neutral'>    event ContractURIUpdated(string newURI);</span>
  41 |     | <span class='neutral'>    event CreditsRetired(address indexed retirer, uint256 indexed tokenId, uint256 amount);</span>
  42 |     | <span class='neutral'></span>
  43 |     | <span class='neutral'>    /// @custom:oz-upgrades-unsafe-allow constructor</span>
  44 | *   | <span class='executed'>    constructor(address projectRegistry_) {</span>
  45 | *   | <span class='executed'>        if (projectRegistry_ == address(0)) revert(&quot;Zero address not allowed&quot;);</span>
  46 | *   | <span class='executed'>        projectRegistry = IProjectRegistry(projectRegistry_);</span>
  47 | *   | <span class='executed'>        _disableInitializers(); // protect the impl</span>
  48 |     | <span class='neutral'>    }</span>
  49 |     | <span class='neutral'></span>
  50 |     | <span class='neutral'>    /**</span>
  51 |     | <span class='neutral'>     * @notice Initializes the contract, setting the contract URI and dependent contracts.</span>
  52 |     | <span class='neutral'>     * @dev Sets up roles and contract dependencies. The deployer is granted `DEFAULT_ADMIN_ROLE`</span>
  53 |     | <span class='neutral'>     * and `PAUSER_ROLE`. In a production environment, the other roles (`DMRV_MANAGER_ROLE`,</span>
  54 |     | <span class='neutral'>     * `METADATA_UPDATER_ROLE`) must be granted to their respective contracts.</span>
  55 |     | <span class='neutral'>     * @param contractURI_ The URI for the contract-level metadata.</span>
  56 |     | <span class='neutral'>     */</span>
  57 | *   | <span class='executed'>    function initialize(string memory contractURI_) public initializer {</span>
  58 | *   | <span class='executed'>        __ERC1155_init(&quot;&quot;); // base URI empty  each token has its own</span>
  59 | *   | <span class='executed'>        __AccessControl_init();</span>
  60 | *   | <span class='executed'>        __UUPSUpgradeable_init();</span>
  61 | *   | <span class='executed'>        __Pausable_init();</span>
  62 |     | <span class='neutral'></span>
  63 | *   | <span class='executed'>        _grantRole(DEFAULT_ADMIN_ROLE, _msgSender()); // This is required to make the initializer the admin.</span>
  64 | *   | <span class='executed'>        _grantRole(PAUSER_ROLE, _msgSender());</span>
  65 | *   | <span class='executed'>        _contractURI = contractURI_;</span>
  66 |     | <span class='neutral'></span>
  67 | *   | <span class='executed'>        _roles.push(DEFAULT_ADMIN_ROLE);</span>
  68 | *   | <span class='executed'>        _roles.push(DMRV_MANAGER_ROLE);</span>
  69 | *   | <span class='executed'>        _roles.push(METADATA_UPDATER_ROLE);</span>
  70 | *   | <span class='executed'>        _roles.push(PAUSER_ROLE);</span>
  71 |     | <span class='neutral'>    }</span>
  72 |     | <span class='neutral'></span>
  73 |     | <span class='neutral'>    /**</span>
  74 |     | <span class='neutral'>     * @notice Mints a new batch of impact credits for a verified project.</span>
  75 |     | <span class='neutral'>     * @dev Can only be called by an address with `DMRV_MANAGER_ROLE`. The `tokenId` is the `uint256`</span>
  76 |     | <span class='neutral'>     * cast of the `projectId`. This function adds the new metadata URI to the token&#39;s history.</span>
  77 |     | <span class='neutral'>     * The project must be `Active` in the `ProjectRegistry`.</span>
  78 |     | <span class='neutral'>     * @param to The address to receive the new credits.</span>
  79 |     | <span class='neutral'>     * @param projectId The project ID, used to derive the `tokenId`.</span>
  80 |     | <span class='neutral'>     * @param amount The quantity of credits to mint.</span>
  81 |     | <span class='neutral'>     * @param newUri The new metadata URI for this batch, pointing to dMRV data.</span>
  82 |     | <span class='neutral'>     */</span>
  83 | *   | <span class='executed'>    function mintCredits(address to, bytes32 projectId, uint256 amount, string calldata newUri)</span>
  84 |     | <span class='neutral'>        external</span>
  85 |     | <span class='neutral'>        onlyRole(DMRV_MANAGER_ROLE)</span>
  86 |     | <span class='neutral'>        whenNotPaused</span>
  87 | *   | <span class='executed'>    {</span>
  88 | *   | <span class='executed'>        if (!projectRegistry.isProjectActive(projectId)) revert DynamicImpactCredit__ProjectNotActive();</span>
  89 |     | <span class='neutral'></span>
  90 | *   | <span class='executed'>        uint256 tokenId = uint256(projectId);</span>
  91 | *   | <span class='executed'>        _mint(to, tokenId, amount, &quot;&quot;);</span>
  92 |     | <span class='neutral'></span>
  93 |     | <span class='neutral'>        // Always update the URI by pushing to the history array</span>
  94 | *   | <span class='executed'>        _tokenURIs[tokenId].push(newUri);</span>
  95 |     | <span class='neutral'></span>
  96 | *   | <span class='executed'>        emit URI(newUri, tokenId);</span>
  97 |     | <span class='neutral'>    }</span>
  98 |     | <span class='neutral'></span>
  99 |     | <span class='neutral'>    /**</span>
 100 |     | <span class='neutral'>     * @notice Updates a token&#39;s metadata by adding a new URI to its history.</span>
 101 |     | <span class='neutral'>     * @dev Can only be called by an address with `METADATA_UPDATER_ROLE`. This allows for</span>
 102 |     | <span class='neutral'>     * impact data to be updated without minting new tokens. Emits a `URI` event.</span>
 103 |     | <span class='neutral'>     * @param id The project ID (`bytes32`) of the token to update.</span>
 104 |     | <span class='neutral'>     * @param newUri The new metadata URI to add to the token&#39;s history.</span>
 105 |     | <span class='neutral'>     */</span>
 106 |     | <span class='unexecuted'>    function setTokenURI(bytes32 id, string calldata newUri) external onlyRole(METADATA_UPDATER_ROLE) whenNotPaused {</span>
 107 |     | <span class='unexecuted'>        uint256 tokenId = uint256(id);</span>
 108 |     | <span class='unexecuted'>        _tokenURIs[tokenId].push(newUri);</span>
 109 |     | <span class='unexecuted'>        emit URI(newUri, tokenId);</span>
 110 |     | <span class='neutral'>    }</span>
 111 |     | <span class='neutral'></span>
 112 |     | <span class='neutral'>    /**</span>
 113 |     | <span class='neutral'>     * @notice Returns the latest metadata URI for a given token ID.</span>
 114 |     | <span class='neutral'>     * @dev This points to the most up-to-date off-chain metadata JSON. The token must exist.</span>
 115 |     | <span class='neutral'>     * @param id The token ID to query.</span>
 116 |     | <span class='neutral'>     * @return The latest metadata URI string.</span>
 117 |     | <span class='neutral'>     */</span>
 118 |     | <span class='unexecuted'>    function uri(uint256 id) public view override returns (string memory) {</span>
 119 |     | <span class='unexecuted'>        string[] storage uris = _tokenURIs[id];</span>
 120 |     | <span class='unexecuted'>        if (uris.length == 0) revert DynamicImpactCredit__URINotSet();</span>
 121 |     | <span class='unexecuted'>        return uris[uris.length - 1];</span>
 122 |     | <span class='neutral'>    }</span>
 123 |     | <span class='neutral'></span>
 124 |     | <span class='neutral'>    /**</span>
 125 |     | <span class='neutral'>     * @notice Retrieves the entire history of metadata URIs for a token.</span>
 126 |     | <span class='neutral'>     * @dev Provides a transparent, on-chain audit trail of all changes to a token&#39;s</span>
 127 |     | <span class='neutral'>     * verified data.</span>
 128 |     | <span class='neutral'>     * @param id The token ID to query.</span>
 129 |     | <span class='neutral'>     * @return An array of all historical metadata URI strings.</span>
 130 |     | <span class='neutral'>     */</span>
 131 |     | <span class='unexecuted'>    function getTokenURIHistory(uint256 id) public view returns (string[] memory) {</span>
 132 |     | <span class='unexecuted'>        return _tokenURIs[id];</span>
 133 |     | <span class='neutral'>    }</span>
 134 |     | <span class='neutral'></span>
 135 |     | <span class='neutral'>    /**</span>
 136 |     | <span class='neutral'>     * @notice Retires (burns) a specified amount of credits from an owner&#39;s balance.</span>
 137 |     | <span class='neutral'>     * @dev Any credit holder can call this to permanently retire their assets, preventing re-sale</span>
 138 |     | <span class='neutral'>     * and &quot;double counting&quot; of the environmental claim. The caller must be the owner of the tokens</span>
 139 |     | <span class='neutral'>     * or be approved to manage them. Emits a `CreditsRetired` event.</span>
 140 |     | <span class='neutral'>     * @param from The address of the credit holder.</span>
 141 |     | <span class='neutral'>     * @param id The project ID (`bytes32`) of the credits to retire.</span>
 142 |     | <span class='neutral'>     * @param amount The quantity of credits to retire.</span>
 143 |     | <span class='neutral'>     */</span>
 144 | *   | <span class='executed'>    function retire(address from, bytes32 id, uint256 amount) public virtual whenNotPaused {</span>
 145 |     | <span class='unexecuted'>        if (from != _msgSender() &amp;&amp; !isApprovedForAll(from, _msgSender())) revert DynamicImpactCredit__NotAuthorized();</span>
 146 |     | <span class='unexecuted'>        uint256 tokenId = uint256(id);</span>
 147 |     | <span class='unexecuted'>        _burn(from, tokenId, amount);</span>
 148 | *   | <span class='executed'>        emit CreditsRetired(_msgSender(), tokenId, amount);</span>
 149 |     | <span class='neutral'>    }</span>
 150 |     | <span class='neutral'></span>
 151 |     | <span class='neutral'>    /**</span>
 152 |     | <span class='neutral'>     * @notice Gets all the roles held by a specific account.</span>
 153 |     | <span class='neutral'>     * @dev Provides an easy way for UIs and other tools to check permissions.</span>
 154 |     | <span class='neutral'>     * @param account The address to check.</span>
 155 |     | <span class='neutral'>     * @return A list of role identifiers held by the account.</span>
 156 |     | <span class='neutral'>     */</span>
 157 |     | <span class='unexecuted'>    function getRoles(address account) external view returns (bytes32[] memory) {</span>
 158 |     | <span class='unexecuted'>        uint256 count = 0;</span>
 159 |     | <span class='unexecuted'>        for (uint256 i = 0; i &lt; _roles.length; i++) {</span>
 160 |     | <span class='unexecuted'>            if (hasRole(_roles[i], account)) {</span>
 161 |     | <span class='unexecuted'>                count++;</span>
 162 |     | <span class='neutral'>            }</span>
 163 |     | <span class='neutral'>        }</span>
 164 |     | <span class='neutral'></span>
 165 |     | <span class='unexecuted'>        bytes32[] memory roles = new bytes32[](count);</span>
 166 |     | <span class='unexecuted'>        uint256 index = 0;</span>
 167 |     | <span class='unexecuted'>        for (uint256 i = 0; i &lt; _roles.length; i++) {</span>
 168 |     | <span class='unexecuted'>            if (hasRole(_roles[i], account)) {</span>
 169 |     | <span class='unexecuted'>                roles[index++] = _roles[i];</span>
 170 |     | <span class='neutral'>            }</span>
 171 |     | <span class='neutral'>        }</span>
 172 |     | <span class='unexecuted'>        return roles;</span>
 173 |     | <span class='neutral'>    }</span>
 174 |     | <span class='neutral'></span>
 175 |     | <span class='neutral'>    /**</span>
 176 |     | <span class='neutral'>     * @notice Returns the contract-level metadata URI.</span>
 177 |     | <span class='neutral'>     * @dev This URI points to a JSON file that describes the contract, following the ERC-1155 metadata standard.</span>
 178 |     | <span class='neutral'>     */</span>
 179 |     | <span class='unexecuted'>    function contractURI() external view returns (string memory) {</span>
 180 |     | <span class='unexecuted'>        return _contractURI;</span>
 181 |     | <span class='neutral'>    }</span>
 182 |     | <span class='neutral'></span>
 183 |     | <span class='neutral'>    /**</span>
 184 |     | <span class='neutral'>     * @notice Updates the contract-level metadata URI.</span>
 185 |     | <span class='neutral'>     * @dev Can only be called by an address with the `DEFAULT_ADMIN_ROLE`.</span>
 186 |     | <span class='neutral'>     * Emits a `ContractURIUpdated` event.</span>
 187 |     | <span class='neutral'>     * @param newUri The new contract-level URI.</span>
 188 |     | <span class='neutral'>     */</span>
 189 |     | <span class='unexecuted'>    function setContractURI(string calldata newUri) external onlyRole(DEFAULT_ADMIN_ROLE) {</span>
 190 |     | <span class='unexecuted'>        _contractURI = newUri;</span>
 191 |     | <span class='unexecuted'>        emit ContractURIUpdated(newUri);</span>
 192 |     | <span class='neutral'>    }</span>
 193 |     | <span class='neutral'></span>
 194 |     | <span class='neutral'>    /**</span>
 195 |     | <span class='neutral'>     * @notice Pauses all state-changing functions in the contract.</span>
 196 |     | <span class='neutral'>     * @dev Can only be called by an address with the `PAUSER_ROLE`.</span>
 197 |     | <span class='neutral'>     * This is a critical safety feature to halt activity in case of an emergency.</span>
 198 |     | <span class='neutral'>     * Emits a `Paused` event.</span>
 199 |     | <span class='neutral'>     */</span>
 200 |     | <span class='unexecuted'>    function pause() external onlyRole(PAUSER_ROLE) {</span>
 201 |     | <span class='unexecuted'>        _pause();</span>
 202 |     | <span class='neutral'>    }</span>
 203 |     | <span class='neutral'></span>
 204 |     | <span class='neutral'>    /**</span>
 205 |     | <span class='neutral'>     * @notice Lifts the pause on the contract, resuming normal operations.</span>
 206 |     | <span class='neutral'>     * @dev Can only be called by an address with the `PAUSER_ROLE`.</span>
 207 |     | <span class='neutral'>     * Emits an `Unpaused` event.</span>
 208 |     | <span class='neutral'>     */</span>
 209 | *   | <span class='executed'>    function unpause() external onlyRole(PAUSER_ROLE) {</span>
 210 | *   | <span class='executed'>        _unpause();</span>
 211 |     | <span class='neutral'>    }</span>
 212 |     | <span class='neutral'></span>
 213 |     | <span class='neutral'>    /* ---------- upgrade auth ---------- */</span>
 214 |     | <span class='unexecuted'>    function _authorizeUpgrade(address /* newImpl */ ) internal virtual override onlyRole(DEFAULT_ADMIN_ROLE) {}</span>
 215 |     | <span class='neutral'></span>
 216 |     | <span class='neutral'>    /* ---------- interface fan-in ---------- */</span>
 217 |     | <span class='unexecuted'>    function supportsInterface(bytes4 interfaceId)</span>
 218 |     | <span class='neutral'>        public</span>
 219 |     | <span class='neutral'>        view</span>
 220 |     | <span class='neutral'>        override(ERC1155Upgradeable, AccessControlUpgradeable)</span>
 221 |     | <span class='unexecuted'>        returns (bool)</span>
 222 |     | <span class='neutral'>    {</span>
 223 |     | <span class='unexecuted'>        return super.supportsInterface(interfaceId);</span>
 224 |     | <span class='neutral'>    }</span>
 225 |     | <span class='neutral'></span>
 226 |     | <span class='neutral'>    /**</span>
 227 |     | <span class='neutral'>     * @notice Mints multiple batches of impact credits.</span>
 228 |     | <span class='neutral'>     * @dev A gas-efficient alternative to `mintCredits` for minting credits for multiple projects</span>
 229 |     | <span class='neutral'>     * at once. Can only be called by an address with `DMRV_MANAGER_ROLE`. All projects must be active.</span>
 230 |     | <span class='neutral'>     * @param to The address to receive all the new credits.</span>
 231 |     | <span class='neutral'>     * @param ids An array of project IDs.</span>
 232 |     | <span class='neutral'>     * @param amounts An array of amounts to mint for each corresponding project ID.</span>
 233 |     | <span class='neutral'>     * @param uris An array of initial metadata URIs for each corresponding project ID.</span>
 234 |     | <span class='neutral'>     */</span>
 235 |     | <span class='unexecuted'>    function batchMintCredits(</span>
 236 |     | <span class='neutral'>        address to,</span>
 237 |     | <span class='neutral'>        bytes32[] calldata ids,</span>
 238 |     | <span class='neutral'>        uint256[] calldata amounts,</span>
 239 |     | <span class='neutral'>        string[] calldata uris // 1-to-1 with ids</span>
 240 |     | <span class='unexecuted'>    ) external onlyRole(DMRV_MANAGER_ROLE) whenNotPaused {</span>
 241 |     | <span class='unexecuted'>        if (ids.length != amounts.length || ids.length != uris.length) revert DynamicImpactCredit__LengthMismatch();</span>
 242 |     | <span class='neutral'></span>
 243 |     | <span class='unexecuted'>        uint256[] memory tokenIds = new uint256[](ids.length);</span>
 244 |     | <span class='unexecuted'>        for (uint256 i = 0; i &lt; ids.length;) {</span>
 245 |     | <span class='unexecuted'>            if (!projectRegistry.isProjectActive(ids[i])) revert DynamicImpactCredit__ProjectNotActive();</span>
 246 |     | <span class='unexecuted'>            tokenIds[i] = uint256(ids[i]);</span>
 247 |     | <span class='neutral'>            unchecked {</span>
 248 |     | <span class='unexecuted'>                ++i;</span>
 249 |     | <span class='neutral'>            }</span>
 250 |     | <span class='neutral'>        }</span>
 251 |     | <span class='neutral'></span>
 252 |     | <span class='unexecuted'>        _mintBatch(to, tokenIds, amounts, &quot;&quot;);</span>
 253 |     | <span class='neutral'></span>
 254 |     | <span class='unexecuted'>        for (uint256 i = 0; i &lt; ids.length;) {</span>
 255 |     | <span class='neutral'>            // Only add the URI if it&#39;s the very first mint for that token</span>
 256 |     | <span class='unexecuted'>            if (_tokenURIs[tokenIds[i]].length == 0) {</span>
 257 |     | <span class='unexecuted'>                _tokenURIs[tokenIds[i]].push(uris[i]);</span>
 258 |     | <span class='unexecuted'>                emit URI(uris[i], tokenIds[i]);</span>
 259 |     | <span class='neutral'>            }</span>
 260 |     | <span class='neutral'>            unchecked {</span>
 261 |     | <span class='unexecuted'>                ++i;</span>
 262 |     | <span class='neutral'>            }</span>
 263 |     | <span class='neutral'>        }</span>
 264 |     | <span class='neutral'>    }</span>
 265 |     | <span class='neutral'>}</span>
 266 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/phantom/Documents/azemora/azemora-contracts/src/core/ProjectRegistry.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'>pragma solidity ^0.8.20;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>import &quot;@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol&quot;;</span>
   5 |     | <span class='neutral'>import &quot;@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol&quot;;</span>
   6 |     | <span class='neutral'>import &quot;@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol&quot;;</span>
   7 |     | <span class='neutral'>import &quot;@openzeppelin/contracts-upgradeable/utils/ReentrancyGuardUpgradeable.sol&quot;;</span>
   8 |     | <span class='neutral'>import &quot;@openzeppelin/contracts-upgradeable/utils/PausableUpgradeable.sol&quot;;</span>
   9 |     | <span class='neutral'></span>
  10 |     | <span class='neutral'>/**</span>
  11 |     | <span class='neutral'> * @title IProjectRegistry</span>
  12 |     | <span class='neutral'> * @dev Interface for the ProjectRegistry contract.</span>
  13 |     | <span class='neutral'> * Allows other contracts to securely interact with the registry to verify project status.</span>
  14 |     | <span class='neutral'> */</span>
  15 |     | <span class='neutral'>interface IProjectRegistry {</span>
  16 |     | <span class='neutral'>    function isProjectActive(bytes32 projectId) external view returns (bool);</span>
  17 |     | <span class='neutral'>}</span>
  18 |     | <span class='neutral'></span>
  19 |     | <span class='neutral'>// --- Custom Errors ---</span>
  20 |     | <span class='neutral'>error ProjectRegistry__IdAlreadyExists();</span>
  21 |     | <span class='neutral'>error ProjectRegistry__ProjectNotFound();</span>
  22 |     | <span class='neutral'>error ProjectRegistry__StatusIsSame();</span>
  23 |     | <span class='neutral'>error ProjectRegistry__ArchivedProjectCannotBeModified();</span>
  24 |     | <span class='neutral'>error ProjectRegistry__CallerNotVerifier();</span>
  25 |     | <span class='neutral'>error ProjectRegistry__InvalidActivationState();</span>
  26 |     | <span class='neutral'>error ProjectRegistry__CallerNotAdmin();</span>
  27 |     | <span class='neutral'>error ProjectRegistry__InvalidPauseState();</span>
  28 |     | <span class='neutral'>error ProjectRegistry__InvalidStatusTransition();</span>
  29 |     | <span class='neutral'>error ProjectRegistry__NotProjectOwner();</span>
  30 |     | <span class='neutral'>error ProjectRegistry__NewOwnerIsZeroAddress();</span>
  31 |     | <span class='neutral'></span>
  32 |     | <span class='neutral'>/**</span>
  33 |     | <span class='neutral'> * @title ProjectRegistry</span>
  34 |     | <span class='neutral'> * @author Genci Mehmeti</span>
  35 |     | <span class='neutral'> * @dev Manages the registration and lifecycle of climate action projects.</span>
  36 |     | <span class='neutral'> * This contract serves as the on-chain registry, ensuring that environmental assets</span>
  37 |     | <span class='neutral'> * can only be minted for valid, recognized projects. It uses UUPS for upgradeability</span>
  38 |     | <span class='neutral'> * and AccessControl for role-based permissions, allowing for permissionless registration</span>
  39 |     | <span class='neutral'> * with a subsequent verification step.</span>
  40 |     | <span class='neutral'> */</span>
  41 | *   | <span class='executed'>contract ProjectRegistry is</span>
  42 |     | <span class='neutral'>    Initializable,</span>
  43 |     | <span class='neutral'>    AccessControlUpgradeable,</span>
  44 |     | <span class='neutral'>    UUPSUpgradeable,</span>
  45 |     | <span class='neutral'>    ReentrancyGuardUpgradeable,</span>
  46 |     | <span class='neutral'>    PausableUpgradeable</span>
  47 |     | <span class='neutral'>{</span>
  48 | *   | <span class='executed'>    bytes32 public constant VERIFIER_ROLE = keccak256(&quot;VERIFIER_ROLE&quot;);</span>
  49 | *   | <span class='executed'>    bytes32 public constant PAUSER_ROLE = keccak256(&quot;PAUSER_ROLE&quot;);</span>
  50 |     | <span class='neutral'></span>
  51 |     | <span class='neutral'>    bytes32[] private _roles;</span>
  52 |     | <span class='neutral'></span>
  53 |     | <span class='neutral'>    enum ProjectStatus {</span>
  54 |     | <span class='neutral'>        Pending, // Newly registered, awaiting verification</span>
  55 |     | <span class='neutral'>        Active, // Verified and eligible for credit minting</span>
  56 |     | <span class='neutral'>        Paused, // Temporarily suspended by admin</span>
  57 |     | <span class='neutral'>        Archived // Permanently archived, not active</span>
  58 |     | <span class='neutral'></span>
  59 |     | <span class='neutral'>    }</span>
  60 |     | <span class='neutral'></span>
  61 |     | <span class='neutral'>    struct Project {</span>
  62 |     | <span class='neutral'>        bytes32 id;</span>
  63 |     | <span class='neutral'>        string metaURI; // URI to off-chain JSON metadata (IPFS)</span>
  64 |     | <span class='neutral'>        // --- Packed for gas efficiency ---</span>
  65 |     | <span class='neutral'>        address owner; // 20 bytes</span>
  66 |     | <span class='neutral'>        ProjectStatus status; // 1 byte</span>
  67 |     | <span class='neutral'>    }</span>
  68 |     | <span class='neutral'></span>
  69 |     | <span class='neutral'>    mapping(bytes32 =&gt; Project) private _projects;</span>
  70 |     | <span class='neutral'></span>
  71 |     | <span class='neutral'>    uint256[50] private __gap;</span>
  72 |     | <span class='neutral'></span>
  73 |     | <span class='neutral'>    // --- Events ---</span>
  74 |     | <span class='neutral'></span>
  75 |     | <span class='neutral'>    event ProjectRegistered(bytes32 indexed projectId, address indexed owner, string metaURI);</span>
  76 |     | <span class='neutral'>    event ProjectStatusChanged(bytes32 indexed projectId, ProjectStatus oldStatus, ProjectStatus newStatus);</span>
  77 |     | <span class='neutral'>    event ProjectMetaURIUpdated(bytes32 indexed projectId, string newMetaURI);</span>
  78 |     | <span class='neutral'>    event ProjectOwnershipTransferred(bytes32 indexed projectId, address indexed oldOwner, address indexed newOwner);</span>
  79 |     | <span class='neutral'></span>
  80 |     | <span class='neutral'>    /// @custom:oz-upgrades-unsafe-allow constructor</span>
  81 | *   | <span class='executed'>    constructor() {</span>
  82 | *   | <span class='executed'>        _disableInitializers();</span>
  83 |     | <span class='neutral'>    }</span>
  84 |     | <span class='neutral'></span>
  85 |     | <span class='neutral'>    /**</span>
  86 |     | <span class='neutral'>     * @notice Initializes the contract, setting up roles and pausable state.</span>
  87 |     | <span class='neutral'>     * @dev The deployer is granted the `DEFAULT_ADMIN_ROLE`, `VERIFIER_ROLE`, and `PAUSER_ROLE`.</span>
  88 |     | <span class='neutral'>     * This function should only be called once on the implementation contract, and it is automatically</span>
  89 |     | <span class='neutral'>     * called by the proxy constructor during deployment.</span>
  90 |     | <span class='neutral'>     */</span>
  91 | *   | <span class='executed'>    function initialize() public initializer {</span>
  92 | *   | <span class='executed'>        __AccessControl_init();</span>
  93 | *   | <span class='executed'>        __UUPSUpgradeable_init();</span>
  94 | *   | <span class='executed'>        __ReentrancyGuard_init();</span>
  95 | *   | <span class='executed'>        __Pausable_init();</span>
  96 |     | <span class='neutral'></span>
  97 | *   | <span class='executed'>        _grantRole(DEFAULT_ADMIN_ROLE, _msgSender());</span>
  98 | *   | <span class='executed'>        _grantRole(VERIFIER_ROLE, _msgSender());</span>
  99 | *   | <span class='executed'>        _grantRole(PAUSER_ROLE, _msgSender());</span>
 100 |     | <span class='neutral'></span>
 101 | *   | <span class='executed'>        _roles.push(DEFAULT_ADMIN_ROLE);</span>
 102 | *   | <span class='executed'>        _roles.push(VERIFIER_ROLE);</span>
 103 | *   | <span class='executed'>        _roles.push(PAUSER_ROLE);</span>
 104 |     | <span class='neutral'>    }</span>
 105 |     | <span class='neutral'></span>
 106 |     | <span class='neutral'>    // --- State-Changing Functions ---</span>
 107 |     | <span class='neutral'></span>
 108 |     | <span class='neutral'>    /**</span>
 109 |     | <span class='neutral'>     * @notice Registers a new project, making it known to the Azemora platform.</span>
 110 |     | <span class='neutral'>     * @dev Anyone can register a project. The caller becomes the initial owner. The project starts</span>
 111 |     | <span class='neutral'>     * in the `Pending` state and must be moved to `Active` by a `VERIFIER_ROLE` holder</span>
 112 |     | <span class='neutral'>     * before any actions can be taken on it. The `projectId` should be a unique identifier,</span>
 113 |     | <span class='neutral'>     * typically a keccak256 hash of key project details to prevent collisions.</span>
 114 |     | <span class='neutral'>     * @param projectId The unique identifier for the project.</span>
 115 |     | <span class='neutral'>     * @param metaURI A URI pointing to an off-chain JSON file (e.g., on IPFS) with project details.</span>
 116 |     | <span class='neutral'>     */</span>
 117 | *   | <span class='executed'>    function registerProject(bytes32 projectId, string calldata metaURI) external nonReentrant whenNotPaused {</span>
 118 | *   | <span class='executed'>        if (_projects[projectId].id != 0) revert ProjectRegistry__IdAlreadyExists();</span>
 119 |     | <span class='neutral'></span>
 120 | *   | <span class='executed'>        _projects[projectId] =</span>
 121 | *   | <span class='executed'>            Project({id: projectId, metaURI: metaURI, owner: _msgSender(), status: ProjectStatus.Pending});</span>
 122 |     | <span class='neutral'></span>
 123 | *   | <span class='executed'>        emit ProjectRegistered(projectId, _msgSender(), metaURI);</span>
 124 |     | <span class='neutral'>    }</span>
 125 |     | <span class='neutral'></span>
 126 |     | <span class='neutral'>    /**</span>
 127 |     | <span class='neutral'>     * @notice Updates the status of an existing project (e.g., to activate, pause, or archive it).</span>
 128 |     | <span class='neutral'>     * @dev This is a privileged action.</span>
 129 |     | <span class='neutral'>     * - A `VERIFIER_ROLE` holder can move a project to `Active`.</span>
 130 |     | <span class='neutral'>     * - A `DEFAULT_ADMIN_ROLE` holder can `Pause` or `Archive` a project.</span>
 131 |     | <span class='neutral'>     * Status transitions are restricted to logical paths (e.g., you cannot activate an archived project).</span>
 132 |     | <span class='neutral'>     * @param projectId The ID of the project to update.</span>
 133 |     | <span class='neutral'>     * @param newStatus The new status for the project.</span>
 134 |     | <span class='neutral'>     */</span>
 135 | *   | <span class='executed'>    function setProjectStatus(bytes32 projectId, ProjectStatus newStatus) external nonReentrant whenNotPaused {</span>
 136 | *   | <span class='executed'>        Project storage project = _projects[projectId];</span>
 137 | *   | <span class='executed'>        ProjectStatus oldStatus = project.status;</span>
 138 |     | <span class='neutral'></span>
 139 | *   | <span class='executed'>        if (project.id == 0) revert ProjectRegistry__ProjectNotFound();</span>
 140 | *   | <span class='executed'>        if (oldStatus == newStatus) revert ProjectRegistry__StatusIsSame();</span>
 141 | *   | <span class='executed'>        if (oldStatus == ProjectStatus.Archived) revert ProjectRegistry__ArchivedProjectCannotBeModified();</span>
 142 |     | <span class='neutral'></span>
 143 | *   | <span class='executed'>        if (newStatus == ProjectStatus.Active) {</span>
 144 | *   | <span class='executed'>            if (!hasRole(VERIFIER_ROLE, _msgSender())) revert ProjectRegistry__CallerNotVerifier();</span>
 145 | *   | <span class='executed'>            if (oldStatus != ProjectStatus.Pending &amp;&amp; oldStatus != ProjectStatus.Paused) {</span>
 146 |     | <span class='unexecuted'>                revert ProjectRegistry__InvalidActivationState();</span>
 147 |     | <span class='neutral'>            }</span>
 148 |     | <span class='unexecuted'>        } else if (newStatus == ProjectStatus.Paused) {</span>
 149 |     | <span class='unexecuted'>            if (!hasRole(DEFAULT_ADMIN_ROLE, _msgSender())) revert ProjectRegistry__CallerNotAdmin();</span>
 150 |     | <span class='unexecuted'>            if (oldStatus != ProjectStatus.Active) revert ProjectRegistry__InvalidPauseState();</span>
 151 | *   | <span class='executed'>        } else if (newStatus == ProjectStatus.Archived) {</span>
 152 |     | <span class='unexecuted'>            if (!hasRole(DEFAULT_ADMIN_ROLE, _msgSender())) revert ProjectRegistry__CallerNotAdmin();</span>
 153 |     | <span class='neutral'>            // Any non-archived state can be archived. The initial checks are sufficient.</span>
 154 |     | <span class='neutral'>        } else {</span>
 155 |     | <span class='neutral'>            // This case should be unreachable if all statuses are handled above.</span>
 156 |     | <span class='neutral'>            // It prevents transitioning to an undefined status.</span>
 157 |     | <span class='unexecuted'>            revert ProjectRegistry__InvalidStatusTransition();</span>
 158 |     | <span class='neutral'>        }</span>
 159 |     | <span class='neutral'></span>
 160 | *   | <span class='executed'>        emit ProjectStatusChanged(projectId, oldStatus, newStatus);</span>
 161 | *   | <span class='executed'>        project.status = newStatus;</span>
 162 |     | <span class='neutral'>    }</span>
 163 |     | <span class='neutral'></span>
 164 |     | <span class='neutral'>    /**</span>
 165 |     | <span class='neutral'>     * @notice Allows the project owner to update the project&#39;s metadata URI.</span>
 166 |     | <span class='neutral'>     * @dev The caller must be the current owner of the project. The URI should point to a valid</span>
 167 |     | <span class='neutral'>     * JSON metadata file, typically hosted on a decentralized storage system like IPFS.</span>
 168 |     | <span class='neutral'>     * @param projectId The ID of the project to update.</span>
 169 |     | <span class='neutral'>     * @param newMetaURI The new metadata URI.</span>
 170 |     | <span class='neutral'>     */</span>
 171 | *   | <span class='executed'>    function setProjectMetaURI(bytes32 projectId, string calldata newMetaURI) external nonReentrant whenNotPaused {</span>
 172 |     | <span class='unexecuted'>        _checkProjectOwner(projectId);</span>
 173 |     | <span class='unexecuted'>        _projects[projectId].metaURI = newMetaURI;</span>
 174 |     | <span class='unexecuted'>        emit ProjectMetaURIUpdated(projectId, newMetaURI);</span>
 175 |     | <span class='neutral'>    }</span>
 176 |     | <span class='neutral'></span>
 177 |     | <span class='neutral'>    /**</span>
 178 |     | <span class='neutral'>     * @notice Allows the current project owner to transfer project ownership to a new address.</span>
 179 |     | <span class='neutral'>     * @dev The caller must be the current owner. Ownership cannot be transferred to the zero address.</span>
 180 |     | <span class='neutral'>     * The new owner will have the authority to update the project&#39;s metadata URI and perform other</span>
 181 |     | <span class='neutral'>     * owner-specific actions in the future.</span>
 182 |     | <span class='neutral'>     * @param projectId The ID of the project being transferred.</span>
 183 |     | <span class='neutral'>     * @param newOwner The address of the new owner.</span>
 184 |     | <span class='neutral'>     */</span>
 185 |     | <span class='unexecuted'>    function transferProjectOwnership(bytes32 projectId, address newOwner) external nonReentrant whenNotPaused {</span>
 186 |     | <span class='unexecuted'>        _checkProjectOwner(projectId);</span>
 187 |     | <span class='unexecuted'>        if (newOwner == address(0)) revert ProjectRegistry__NewOwnerIsZeroAddress();</span>
 188 |     | <span class='neutral'></span>
 189 |     | <span class='unexecuted'>        address oldOwner = _projects[projectId].owner;</span>
 190 |     | <span class='unexecuted'>        _projects[projectId].owner = newOwner;</span>
 191 |     | <span class='unexecuted'>        emit ProjectOwnershipTransferred(projectId, oldOwner, newOwner);</span>
 192 |     | <span class='neutral'>    }</span>
 193 |     | <span class='neutral'></span>
 194 |     | <span class='neutral'>    // --- View Functions ---</span>
 195 |     | <span class='neutral'></span>
 196 |     | <span class='neutral'>    /**</span>
 197 |     | <span class='neutral'>     * @notice Retrieves the full data for a given project.</span>
 198 |     | <span class='neutral'>     * @param projectId The ID of the project.</span>
 199 |     | <span class='neutral'>     * @return A Project struct containing all project data.</span>
 200 |     | <span class='neutral'>     */</span>
 201 |     | <span class='unexecuted'>    function getProject(bytes32 projectId) external view returns (Project memory) {</span>
 202 |     | <span class='unexecuted'>        if (_projects[projectId].id == 0) revert ProjectRegistry__ProjectNotFound();</span>
 203 |     | <span class='unexecuted'>        return _projects[projectId];</span>
 204 |     | <span class='neutral'>    }</span>
 205 |     | <span class='neutral'></span>
 206 |     | <span class='neutral'>    /**</span>
 207 |     | <span class='neutral'>     * @notice Checks if a project is currently active.</span>
 208 |     | <span class='neutral'>     * @dev This is the primary view function for other contracts (like the NFT contract)</span>
 209 |     | <span class='neutral'>     * to verify a project&#39;s eligibility for minting.</span>
 210 |     | <span class='neutral'>     * @param projectId The ID of the project to check.</span>
 211 |     | <span class='neutral'>     * @return True if the project&#39;s status is Active, false otherwise.</span>
 212 |     | <span class='neutral'>     */</span>
 213 | *   | <span class='executed'>    function isProjectActive(bytes32 projectId) public view returns (bool) {</span>
 214 | *   | <span class='executed'>        return _projects[projectId].status == ProjectStatus.Active;</span>
 215 |     | <span class='neutral'>    }</span>
 216 |     | <span class='neutral'></span>
 217 |     | <span class='neutral'>    /**</span>
 218 |     | <span class='neutral'>     * @notice Gets all the roles held by a specific account.</span>
 219 |     | <span class='neutral'>     * @dev Provides an easy way for UIs and other tools to check permissions.</span>
 220 |     | <span class='neutral'>     * @param account The address to check.</span>
 221 |     | <span class='neutral'>     * @return A list of role identifiers held by the account.</span>
 222 |     | <span class='neutral'>     */</span>
 223 |     | <span class='unexecuted'>    function getRoles(address account) external view returns (bytes32[] memory) {</span>
 224 |     | <span class='unexecuted'>        uint256 count = 0;</span>
 225 |     | <span class='unexecuted'>        for (uint256 i = 0; i &lt; _roles.length; i++) {</span>
 226 |     | <span class='unexecuted'>            if (hasRole(_roles[i], account)) {</span>
 227 |     | <span class='unexecuted'>                count++;</span>
 228 |     | <span class='neutral'>            }</span>
 229 |     | <span class='neutral'>        }</span>
 230 |     | <span class='neutral'></span>
 231 |     | <span class='unexecuted'>        bytes32[] memory roles = new bytes32[](count);</span>
 232 |     | <span class='unexecuted'>        uint256 index = 0;</span>
 233 |     | <span class='unexecuted'>        for (uint256 i = 0; i &lt; _roles.length; i++) {</span>
 234 |     | <span class='unexecuted'>            if (hasRole(_roles[i], account)) {</span>
 235 |     | <span class='unexecuted'>                roles[index++] = _roles[i];</span>
 236 |     | <span class='neutral'>            }</span>
 237 |     | <span class='neutral'>        }</span>
 238 |     | <span class='unexecuted'>        return roles;</span>
 239 |     | <span class='neutral'>    }</span>
 240 |     | <span class='neutral'></span>
 241 |     | <span class='neutral'>    /**</span>
 242 |     | <span class='neutral'>     * @notice Pauses all state-changing functions in the contract.</span>
 243 |     | <span class='neutral'>     * @dev Can only be called by an address with the `PAUSER_ROLE`.</span>
 244 |     | <span class='neutral'>     * This is a critical safety feature to halt activity in case of an emergency.</span>
 245 |     | <span class='neutral'>     * Emits a `Paused` event.</span>
 246 |     | <span class='neutral'>     */</span>
 247 |     | <span class='unexecuted'>    function pause() external onlyRole(PAUSER_ROLE) {</span>
 248 |     | <span class='unexecuted'>        _pause();</span>
 249 |     | <span class='neutral'>    }</span>
 250 |     | <span class='neutral'></span>
 251 |     | <span class='neutral'>    /**</span>
 252 |     | <span class='neutral'>     * @notice Lifts the pause on the contract, resuming normal operations.</span>
 253 |     | <span class='neutral'>     * @dev Can only be called by an address with the `PAUSER_ROLE`.</span>
 254 |     | <span class='neutral'>     * Emits an `Unpaused` event.</span>
 255 |     | <span class='neutral'>     */</span>
 256 | *   | <span class='executed'>    function unpause() external onlyRole(PAUSER_ROLE) {</span>
 257 | *   | <span class='executed'>        _unpause();</span>
 258 |     | <span class='neutral'>    }</span>
 259 |     | <span class='neutral'></span>
 260 |     | <span class='neutral'>    // --- Internal &amp; Auth Functions ---</span>
 261 |     | <span class='neutral'></span>
 262 |     | <span class='neutral'>    /**</span>
 263 |     | <span class='neutral'>     * @dev Reverts if the caller is not the owner of the specified project.</span>
 264 |     | <span class='neutral'>     */</span>
 265 |     | <span class='unexecuted'>    function _checkProjectOwner(bytes32 projectId) internal view {</span>
 266 |     | <span class='unexecuted'>        if (_projects[projectId].id == 0) revert ProjectRegistry__ProjectNotFound();</span>
 267 |     | <span class='unexecuted'>        if (_projects[projectId].owner != _msgSender()) revert ProjectRegistry__NotProjectOwner();</span>
 268 |     | <span class='neutral'>    }</span>
 269 |     | <span class='neutral'></span>
 270 |     | <span class='unexecuted'>    function _authorizeUpgrade(address newImplementation) internal override onlyRole(DEFAULT_ADMIN_ROLE) {}</span>
 271 |     | <span class='neutral'></span>
 272 | *   | <span class='executed'>    function supportsInterface(bytes4 interfaceId) public view override(AccessControlUpgradeable) returns (bool) {</span>
 273 | *   | <span class='executed'>        return interfaceId == type(IProjectRegistry).interfaceId || super.supportsInterface(interfaceId);</span>
 274 |     | <span class='neutral'>    }</span>
 275 |     | <span class='neutral'>}</span>
 276 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/phantom/Documents/azemora/azemora-contracts/src/core/dMRVManager.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'>pragma solidity ^0.8.20;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>import &quot;@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol&quot;;</span>
   5 |     | <span class='neutral'>import &quot;@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol&quot;;</span>
   6 |     | <span class='neutral'>import &quot;@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol&quot;;</span>
   7 |     | <span class='neutral'>import &quot;@openzeppelin/contracts-upgradeable/utils/ReentrancyGuardUpgradeable.sol&quot;;</span>
   8 |     | <span class='neutral'>import &quot;@openzeppelin/contracts-upgradeable/utils/PausableUpgradeable.sol&quot;;</span>
   9 |     | <span class='neutral'>import &quot;./ProjectRegistry.sol&quot;;</span>
  10 |     | <span class='neutral'>import &quot;./DynamicImpactCredit.sol&quot;;</span>
  11 |     | <span class='neutral'></span>
  12 |     | <span class='neutral'>// --- Custom Errors ---</span>
  13 |     | <span class='neutral'>error DMRVManager__ProjectNotActive();</span>
  14 |     | <span class='neutral'>error DMRVManager__RequestNotFound();</span>
  15 |     | <span class='neutral'>error DMRVManager__RequestAlreadyFulfilled();</span>
  16 |     | <span class='neutral'></span>
  17 |     | <span class='neutral'>/**</span>
  18 |     | <span class='neutral'> * @title DMRVManager</span>
  19 |     | <span class='neutral'> * @author Genci Mehmeti</span>
  20 |     | <span class='neutral'> * @dev Manages the retrieval and processing of digital Monitoring, Reporting, and</span>
  21 |     | <span class='neutral'> * Verification (dMRV) data. This contract acts as the bridge between off-chain</span>
  22 |     | <span class='neutral'> * data sources (oracles) and the on-chain minting of `DynamicImpactCredit` tokens,</span>
  23 |     | <span class='neutral'> * ensuring that only verified environmental impact results in token creation.</span>
  24 |     | <span class='neutral'> * It is upgradeable using the UUPS pattern.</span>
  25 |     | <span class='neutral'> */</span>
  26 |     | <span class='unexecuted'>contract DMRVManager is</span>
  27 |     | <span class='neutral'>    Initializable,</span>
  28 |     | <span class='neutral'>    AccessControlUpgradeable,</span>
  29 |     | <span class='neutral'>    UUPSUpgradeable,</span>
  30 |     | <span class='neutral'>    ReentrancyGuardUpgradeable,</span>
  31 |     | <span class='neutral'>    PausableUpgradeable</span>
  32 |     | <span class='neutral'>{</span>
  33 |     | <span class='neutral'>    // --- Roles ---</span>
  34 |     | <span class='unexecuted'>    bytes32 public constant ORACLE_ROLE = keccak256(&quot;ORACLE_ROLE&quot;);</span>
  35 |     | <span class='unexecuted'>    bytes32 public constant PAUSER_ROLE = keccak256(&quot;PAUSER_ROLE&quot;);</span>
  36 |     | <span class='neutral'></span>
  37 |     | <span class='neutral'>    bytes32[] private _roles;</span>
  38 |     | <span class='neutral'></span>
  39 |     | <span class='neutral'>    // --- State variables ---</span>
  40 |     | <span class='unexecuted'>    ProjectRegistry public immutable projectRegistry;</span>
  41 |     | <span class='unexecuted'>    DynamicImpactCredit public immutable creditContract;</span>
  42 |     | <span class='neutral'></span>
  43 |     | <span class='neutral'>    // Mapping to track verification requests by request ID</span>
  44 |     | <span class='neutral'>    mapping(bytes32 =&gt; VerificationRequest) private _requests;</span>
  45 |     | <span class='neutral'></span>
  46 |     | <span class='neutral'>    uint256[50] private __gap;</span>
  47 |     | <span class='neutral'></span>
  48 |     | <span class='neutral'>    // Structure for tracking verification requests</span>
  49 |     | <span class='neutral'>    // Struct is packed to save gas on storage.</span>
  50 |     | <span class='neutral'>    struct VerificationRequest {</span>
  51 |     | <span class='neutral'>        bytes32 projectId; // 32 bytes - Slot 0</span>
  52 |     | <span class='neutral'>        // --- Packed into a single 32-byte slot (Slot 1) ---</span>
  53 |     | <span class='neutral'>        address requestor; // 20 bytes</span>
  54 |     | <span class='neutral'>        uint64 timestamp; // 8 bytes</span>
  55 |     | <span class='neutral'>        bool fulfilled; // 1 byte</span>
  56 |     | <span class='neutral'>    }</span>
  57 |     | <span class='neutral'></span>
  58 |     | <span class='neutral'>    // Structure for representing parsed verification data</span>
  59 |     | <span class='neutral'>    struct VerificationData {</span>
  60 |     | <span class='neutral'>        uint256 creditAmount;</span>
  61 |     | <span class='neutral'>        string metadataURI;</span>
  62 |     | <span class='neutral'>        bool updateMetadataOnly;</span>
  63 |     | <span class='neutral'>        bytes32 signature; // For validating that data came from an authorized source</span>
  64 |     | <span class='neutral'>    }</span>
  65 |     | <span class='neutral'></span>
  66 |     | <span class='neutral'>    // --- Events ---</span>
  67 |     | <span class='neutral'>    event VerificationRequested(bytes32 indexed requestId, bytes32 indexed projectId, address indexed requestor);</span>
  68 |     | <span class='neutral'>    event VerificationFulfilled(bytes32 indexed requestId, bytes32 indexed projectId, uint256 creditAmount);</span>
  69 |     | <span class='neutral'>    event AdminVerificationSubmitted(</span>
  70 |     | <span class='neutral'>        bytes32 indexed projectId, uint256 creditAmount, string metadataURI, bool updateMetadataOnly</span>
  71 |     | <span class='neutral'>    );</span>
  72 |     | <span class='neutral'>    event MetadataUpdated(bytes32 indexed projectId, string newURI);</span>
  73 |     | <span class='neutral'>    event CreditsMinted(bytes32 indexed projectId, address indexed owner, uint256 amount);</span>
  74 |     | <span class='neutral'>    event MissingProjectError(bytes32 indexed projectId);</span>
  75 |     | <span class='neutral'></span>
  76 |     | <span class='neutral'>    /// @custom:oz-upgrades-unsafe-allow constructor</span>
  77 |     | <span class='unexecuted'>    constructor(address projectRegistry_, address creditContract_) {</span>
  78 |     | <span class='unexecuted'>        if (projectRegistry_ == address(0) || creditContract_ == address(0)) {</span>
  79 |     | <span class='unexecuted'>            revert(&quot;Zero address not allowed&quot;);</span>
  80 |     | <span class='neutral'>        }</span>
  81 |     | <span class='unexecuted'>        projectRegistry = ProjectRegistry(projectRegistry_);</span>
  82 |     | <span class='unexecuted'>        creditContract = DynamicImpactCredit(creditContract_);</span>
  83 |     | <span class='unexecuted'>        _disableInitializers();</span>
  84 |     | <span class='neutral'>    }</span>
  85 |     | <span class='neutral'></span>
  86 |     | <span class='neutral'>    /**</span>
  87 |     | <span class='neutral'>     * @notice Initializes the contract with dependent contract addresses.</span>
  88 |     | <span class='neutral'>     * @dev Sets up roles and contract dependencies. The deployer is granted `DEFAULT_ADMIN_ROLE`,</span>
  89 |     | <span class='neutral'>     * `ORACLE_ROLE`, and `PAUSER_ROLE`. In a production environment, the `ORACLE_ROLE` would be</span>
  90 |     | <span class='neutral'>     * transferred to trusted oracle contracts.</span>
  91 |     | <span class='neutral'>     */</span>
  92 |     | <span class='unexecuted'>    function initialize() public initializer {</span>
  93 |     | <span class='unexecuted'>        __AccessControl_init();</span>
  94 |     | <span class='unexecuted'>        __UUPSUpgradeable_init();</span>
  95 |     | <span class='unexecuted'>        __ReentrancyGuard_init();</span>
  96 |     | <span class='unexecuted'>        __Pausable_init();</span>
  97 |     | <span class='neutral'></span>
  98 |     | <span class='unexecuted'>        _grantRole(DEFAULT_ADMIN_ROLE, _msgSender());</span>
  99 |     | <span class='neutral'>        // In a real deployment, this would be set to trusted oracle addresses</span>
 100 |     | <span class='unexecuted'>        _grantRole(ORACLE_ROLE, _msgSender());</span>
 101 |     | <span class='unexecuted'>        _grantRole(PAUSER_ROLE, _msgSender());</span>
 102 |     | <span class='neutral'></span>
 103 |     | <span class='unexecuted'>        _roles.push(DEFAULT_ADMIN_ROLE);</span>
 104 |     | <span class='unexecuted'>        _roles.push(ORACLE_ROLE);</span>
 105 |     | <span class='unexecuted'>        _roles.push(PAUSER_ROLE);</span>
 106 |     | <span class='neutral'>    }</span>
 107 |     | <span class='neutral'></span>
 108 |     | <span class='neutral'>    /**</span>
 109 |     | <span class='neutral'>     * @notice Initiates a request for dMRV data from an oracle for a given project.</span>
 110 |     | <span class='neutral'>     * @dev Emits a `VerificationRequested` event. For the MVP, this simulates an oracle request by</span>
 111 |     | <span class='neutral'>     * creating a request entry. In a production environment, this function would be expanded to</span>
 112 |     | <span class='neutral'>     * make a direct call to a decentralized oracle network like Chainlink.</span>
 113 |     | <span class='neutral'>     * The project must be in the `Active` state.</span>
 114 |     | <span class='neutral'>     * @param projectId The unique identifier of the project to verify.</span>
 115 |     | <span class='neutral'>     * @return requestId A unique ID for the verification request.</span>
 116 |     | <span class='neutral'>     */</span>
 117 |     | <span class='unexecuted'>    function requestVerification(bytes32 projectId) external nonReentrant whenNotPaused returns (bytes32 requestId) {</span>
 118 |     | <span class='unexecuted'>        if (!projectRegistry.isProjectActive(projectId)) revert DMRVManager__ProjectNotActive();</span>
 119 |     | <span class='neutral'></span>
 120 |     | <span class='neutral'>        // For MVP: Generate a simple request ID.</span>
 121 |     | <span class='neutral'>        // In production, this would come from the Chainlink request.</span>
 122 |     | <span class='unexecuted'>        requestId = keccak256(abi.encodePacked(projectId, _msgSender(), block.timestamp));</span>
 123 |     | <span class='neutral'></span>
 124 |     | <span class='unexecuted'>        _requests[requestId] = VerificationRequest({</span>
 125 |     | <span class='unexecuted'>            projectId: projectId,</span>
 126 |     | <span class='unexecuted'>            requestor: _msgSender(),</span>
 127 |     | <span class='unexecuted'>            timestamp: uint64(block.timestamp),</span>
 128 |     | <span class='neutral'>            fulfilled: false</span>
 129 |     | <span class='neutral'>        });</span>
 130 |     | <span class='neutral'></span>
 131 |     | <span class='unexecuted'>        emit VerificationRequested(requestId, projectId, _msgSender());</span>
 132 |     | <span class='neutral'></span>
 133 |     | <span class='neutral'>        // In a real implementation, we&#39;d make a Chainlink request here.</span>
 134 |     | <span class='neutral'>        // For MVP purposes, we&#39;re simulating the oracle callback.</span>
 135 |     | <span class='neutral'></span>
 136 |     | <span class='neutral'>        return requestId;</span>
 137 |     | <span class='neutral'>    }</span>
 138 |     | <span class='neutral'></span>
 139 |     | <span class='neutral'>    /**</span>
 140 |     | <span class='neutral'>     * @notice Callback function for oracles to deliver verified dMRV data.</span>
 141 |     | <span class='neutral'>     * @dev This is a privileged function that can only be called by addresses with the `ORACLE_ROLE`.</span>
 142 |     | <span class='neutral'>     * It marks the request as fulfilled and processes the incoming data to mint new impact credit tokens</span>
 143 |     | <span class='neutral'>     * or update the metadata of existing ones. Emits a `VerificationFulfilled` event.</span>
 144 |     | <span class='neutral'>     * @param requestId The ID of the verification request being fulfilled.</span>
 145 |     | <span class='neutral'>     * @param data The raw, encoded verification data from the dMRV system.</span>
 146 |     | <span class='neutral'>     */</span>
 147 |     | <span class='unexecuted'>    function fulfillVerification(bytes32 requestId, bytes calldata data)</span>
 148 |     | <span class='neutral'>        external</span>
 149 |     | <span class='neutral'>        onlyRole(ORACLE_ROLE)</span>
 150 |     | <span class='neutral'>        nonReentrant</span>
 151 |     | <span class='neutral'>        whenNotPaused</span>
 152 |     | <span class='unexecuted'>    {</span>
 153 |     | <span class='unexecuted'>        VerificationRequest storage request = _requests[requestId];</span>
 154 |     | <span class='unexecuted'>        if (request.timestamp == 0) revert DMRVManager__RequestNotFound();</span>
 155 |     | <span class='unexecuted'>        if (request.fulfilled) revert DMRVManager__RequestAlreadyFulfilled();</span>
 156 |     | <span class='neutral'></span>
 157 |     | <span class='unexecuted'>        request.fulfilled = true;</span>
 158 |     | <span class='neutral'></span>
 159 |     | <span class='neutral'>        // Process the verification data</span>
 160 |     | <span class='unexecuted'>        VerificationData memory vData = parseVerificationData(data);</span>
 161 |     | <span class='neutral'></span>
 162 |     | <span class='neutral'>        // Act based on the verification data</span>
 163 |     | <span class='unexecuted'>        processVerification(request.projectId, request.requestor, vData);</span>
 164 |     | <span class='neutral'></span>
 165 |     | <span class='unexecuted'>        emit VerificationFulfilled(requestId, request.projectId, vData.creditAmount);</span>
 166 |     | <span class='neutral'>    }</span>
 167 |     | <span class='neutral'></span>
 168 |     | <span class='neutral'>    /**</span>
 169 |     | <span class='neutral'>     * @dev Internal function to process verified dMRV data. It either mints new</span>
 170 |     | <span class='neutral'>     * credits to the project owner or updates the metadata URI of the associated token.</span>
 171 |     | <span class='neutral'>     * @param projectId The project identifier.</span>
 172 |     | <span class='neutral'>     * @param data The parsed verification data.</span>
 173 |     | <span class='neutral'>     */</span>
 174 |     | <span class='unexecuted'>    function processVerification(bytes32 projectId, address, /* requestor */ VerificationData memory data) internal {</span>
 175 |     | <span class='unexecuted'>        if (data.updateMetadataOnly) {</span>
 176 |     | <span class='neutral'>            // Update metadata only</span>
 177 |     | <span class='unexecuted'>            creditContract.setTokenURI(projectId, data.metadataURI);</span>
 178 |     | <span class='unexecuted'>            emit MetadataUpdated(projectId, data.metadataURI);</span>
 179 |     | <span class='unexecuted'>        } else if (data.creditAmount &gt; 0) {</span>
 180 |     | <span class='neutral'>            // Get project owner from registry to mint credits to them</span>
 181 |     | <span class='unexecuted'>            try projectRegistry.getProject(projectId) returns (ProjectRegistry.Project memory project) {</span>
 182 |     | <span class='neutral'>                // Mint new credits to the project owner</span>
 183 |     | <span class='unexecuted'>                creditContract.mintCredits(project.owner, projectId, data.creditAmount, data.metadataURI);</span>
 184 |     | <span class='unexecuted'>                emit CreditsMinted(projectId, project.owner, data.creditAmount);</span>
 185 |     | <span class='neutral'>            } catch {</span>
 186 |     | <span class='unexecuted'>                emit MissingProjectError(projectId);</span>
 187 |     | <span class='neutral'>            }</span>
 188 |     | <span class='neutral'>        }</span>
 189 |     | <span class='neutral'>    }</span>
 190 |     | <span class='neutral'></span>
 191 |     | <span class='neutral'>    /**</span>
 192 |     | <span class='neutral'>     * @dev Parses raw verification data from the oracle into a structured format.</span>
 193 |     | <span class='neutral'>     * @param data The raw byte data from the oracle.</span>
 194 |     | <span class='neutral'>     * @return A `VerificationData` struct.</span>
 195 |     | <span class='neutral'>     */</span>
 196 |     | <span class='unexecuted'>    function parseVerificationData(bytes calldata data) internal pure returns (VerificationData memory) {</span>
 197 |     | <span class='neutral'>        // A more robust decoding scheme.</span>
 198 |     | <span class='neutral'>        (uint256 creditAmount, bool updateMetadataOnly, bytes32 signature, string memory metadataURI) =</span>
 199 |     | <span class='unexecuted'>            abi.decode(data, (uint256, bool, bytes32, string));</span>
 200 |     | <span class='neutral'></span>
 201 |     | <span class='unexecuted'>        return VerificationData({</span>
 202 |     | <span class='neutral'>            creditAmount: creditAmount,</span>
 203 |     | <span class='neutral'>            metadataURI: metadataURI,</span>
 204 |     | <span class='neutral'>            updateMetadataOnly: updateMetadataOnly,</span>
 205 |     | <span class='neutral'>            signature: signature</span>
 206 |     | <span class='neutral'>        });</span>
 207 |     | <span class='neutral'>    }</span>
 208 |     | <span class='neutral'></span>
 209 |     | <span class='neutral'>    /**</span>
 210 |     | <span class='neutral'>     * @notice Admin function to manually submit verification data, bypassing the oracle.</span>
 211 |     | <span class='neutral'>     * @dev This is a privileged function for `DEFAULT_ADMIN_ROLE` holders. It is intended for</span>
 212 |     | <span class='neutral'>     * testing, emergency interventions, or manual data entry. It directly calls the internal</span>
 213 |     | <span class='neutral'>     * processing logic. Emits an `AdminVerificationSubmitted` event.</span>
 214 |     | <span class='neutral'>     * @param projectId The project identifier.</span>
 215 |     | <span class='neutral'>     * @param creditAmount Amount of credits to mint (can be 0).</span>
 216 |     | <span class='neutral'>     * @param metadataURI The new metadata URI to set.</span>
 217 |     | <span class='neutral'>     * @param updateMetadataOnly If true, only updates metadata without minting.</span>
 218 |     | <span class='neutral'>     */</span>
 219 |     | <span class='unexecuted'>    function adminSubmitVerification(</span>
 220 |     | <span class='neutral'>        bytes32 projectId,</span>
 221 |     | <span class='neutral'>        uint256 creditAmount,</span>
 222 |     | <span class='neutral'>        string calldata metadataURI,</span>
 223 |     | <span class='neutral'>        bool updateMetadataOnly</span>
 224 |     | <span class='unexecuted'>    ) external onlyRole(DEFAULT_ADMIN_ROLE) nonReentrant whenNotPaused {</span>
 225 |     | <span class='unexecuted'>        if (!projectRegistry.isProjectActive(projectId)) revert DMRVManager__ProjectNotActive();</span>
 226 |     | <span class='neutral'></span>
 227 |     | <span class='unexecuted'>        VerificationData memory vData = VerificationData({</span>
 228 |     | <span class='unexecuted'>            creditAmount: creditAmount,</span>
 229 |     | <span class='unexecuted'>            metadataURI: metadataURI,</span>
 230 |     | <span class='neutral'>            updateMetadataOnly: updateMetadataOnly,</span>
 231 |     | <span class='neutral'>            signature: bytes32(0) // Not needed for admin functions</span>
 232 |     | <span class='neutral'>        });</span>
 233 |     | <span class='neutral'></span>
 234 |     | <span class='unexecuted'>        processVerification(projectId, _msgSender(), vData);</span>
 235 |     | <span class='unexecuted'>        emit AdminVerificationSubmitted(projectId, creditAmount, metadataURI, updateMetadataOnly);</span>
 236 |     | <span class='neutral'>    }</span>
 237 |     | <span class='neutral'></span>
 238 |     | <span class='neutral'>    /**</span>
 239 |     | <span class='neutral'>     * @notice Pauses all state-changing functions in the contract.</span>
 240 |     | <span class='neutral'>     * @dev Can only be called by an address with the `PAUSER_ROLE`.</span>
 241 |     | <span class='neutral'>     * This is a critical safety feature to halt activity in case of an emergency.</span>
 242 |     | <span class='neutral'>     * Emits a `Paused` event.</span>
 243 |     | <span class='neutral'>     */</span>
 244 |     | <span class='unexecuted'>    function pause() external onlyRole(PAUSER_ROLE) {</span>
 245 |     | <span class='unexecuted'>        _pause();</span>
 246 |     | <span class='neutral'>    }</span>
 247 |     | <span class='neutral'></span>
 248 |     | <span class='neutral'>    /**</span>
 249 |     | <span class='neutral'>     * @notice Lifts the pause on the contract, resuming normal operations.</span>
 250 |     | <span class='neutral'>     * @dev Can only be called by an address with the `PAUSER_ROLE`.</span>
 251 |     | <span class='neutral'>     * Emits an `Unpaused` event.</span>
 252 |     | <span class='neutral'>     */</span>
 253 |     | <span class='unexecuted'>    function unpause() external onlyRole(PAUSER_ROLE) {</span>
 254 |     | <span class='unexecuted'>        _unpause();</span>
 255 |     | <span class='neutral'>    }</span>
 256 |     | <span class='neutral'></span>
 257 |     | <span class='neutral'>    /* ---------- upgrade auth ---------- */</span>
 258 |     | <span class='unexecuted'>    function _authorizeUpgrade(address /* newImpl */ ) internal override onlyRole(DEFAULT_ADMIN_ROLE) {}</span>
 259 |     | <span class='neutral'></span>
 260 |     | <span class='neutral'>    /**</span>
 261 |     | <span class='neutral'>     * @notice Gets all the roles held by a specific account.</span>
 262 |     | <span class='neutral'>     * @dev Provides an easy way for UIs and other tools to check permissions.</span>
 263 |     | <span class='neutral'>     * @param account The address to check.</span>
 264 |     | <span class='neutral'>     * @return A list of role identifiers held by the account.</span>
 265 |     | <span class='neutral'>     */</span>
 266 |     | <span class='unexecuted'>    function getRoles(address account) external view returns (bytes32[] memory) {</span>
 267 |     | <span class='unexecuted'>        uint256 count = 0;</span>
 268 |     | <span class='unexecuted'>        for (uint256 i = 0; i &lt; _roles.length; i++) {</span>
 269 |     | <span class='unexecuted'>            if (hasRole(_roles[i], account)) {</span>
 270 |     | <span class='unexecuted'>                count++;</span>
 271 |     | <span class='neutral'>            }</span>
 272 |     | <span class='neutral'>        }</span>
 273 |     | <span class='neutral'></span>
 274 |     | <span class='unexecuted'>        bytes32[] memory roles = new bytes32[](count);</span>
 275 |     | <span class='unexecuted'>        uint256 index = 0;</span>
 276 |     | <span class='unexecuted'>        for (uint256 i = 0; i &lt; _roles.length; i++) {</span>
 277 |     | <span class='unexecuted'>            if (hasRole(_roles[i], account)) {</span>
 278 |     | <span class='unexecuted'>                roles[index++] = _roles[i];</span>
 279 |     | <span class='neutral'>            }</span>
 280 |     | <span class='neutral'>        }</span>
 281 |     | <span class='unexecuted'>        return roles;</span>
 282 |     | <span class='neutral'>    }</span>
 283 |     | <span class='neutral'>}</span>
 284 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/phantom/Documents/azemora/azemora-contracts/src/governance/AzemoraGovernor.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'>pragma solidity ^0.8.20;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>import &quot;@openzeppelin/contracts-upgradeable/governance/GovernorUpgradeable.sol&quot;;</span>
   5 |     | <span class='neutral'>import &quot;@openzeppelin/contracts-upgradeable/governance/extensions/GovernorSettingsUpgradeable.sol&quot;;</span>
   6 |     | <span class='neutral'>import &quot;@openzeppelin/contracts-upgradeable/governance/extensions/GovernorCountingSimpleUpgradeable.sol&quot;;</span>
   7 |     | <span class='neutral'>import &quot;@openzeppelin/contracts-upgradeable/governance/extensions/GovernorVotesUpgradeable.sol&quot;;</span>
   8 |     | <span class='neutral'>import &quot;@openzeppelin/contracts-upgradeable/governance/extensions/GovernorVotesQuorumFractionUpgradeable.sol&quot;;</span>
   9 |     | <span class='neutral'>import &quot;@openzeppelin/contracts-upgradeable/governance/extensions/GovernorTimelockControlUpgradeable.sol&quot;;</span>
  10 |     | <span class='neutral'>import &quot;@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol&quot;;</span>
  11 |     | <span class='neutral'></span>
  12 |     | <span class='neutral'>/**</span>
  13 |     | <span class='neutral'> * @title AzemoraGovernor</span>
  14 |     | <span class='neutral'> * @author Genci Mehmeti</span>
  15 |     | <span class='neutral'> * @dev The governance contract for the Azemora platform.</span>
  16 |     | <span class='neutral'> * It uses OpenZeppelin&#39;s Governor modules for voting, quorum, and timelock functionality.</span>
  17 |     | <span class='neutral'> * The governor manages proposals and executes them via a TimelockController.</span>
  18 |     | <span class='neutral'> * This version is optimized for size by removing UUPS and AccessControl.</span>
  19 |     | <span class='neutral'> * Upgrades are managed by the Timelock.</span>
  20 |     | <span class='neutral'> */</span>
  21 |     | <span class='unexecuted'>contract AzemoraGovernor is</span>
  22 |     | <span class='neutral'>    Initializable,</span>
  23 |     | <span class='neutral'>    GovernorUpgradeable,</span>
  24 |     | <span class='neutral'>    GovernorSettingsUpgradeable,</span>
  25 |     | <span class='neutral'>    GovernorCountingSimpleUpgradeable,</span>
  26 |     | <span class='neutral'>    GovernorVotesUpgradeable,</span>
  27 |     | <span class='neutral'>    GovernorVotesQuorumFractionUpgradeable,</span>
  28 |     | <span class='neutral'>    GovernorTimelockControlUpgradeable</span>
  29 |     | <span class='neutral'>{</span>
  30 |     | <span class='neutral'>    /// @custom:oz-upgrades-unsafe-allow constructor</span>
  31 |     | <span class='unexecuted'>    constructor() {</span>
  32 |     | <span class='unexecuted'>        _disableInitializers();</span>
  33 |     | <span class='neutral'>    }</span>
  34 |     | <span class='neutral'></span>
  35 |     | <span class='unexecuted'>    function initialize(</span>
  36 |     | <span class='neutral'>        IVotes token,</span>
  37 |     | <span class='neutral'>        TimelockControllerUpgradeable timelock,</span>
  38 |     | <span class='neutral'>        uint48 _votingDelay,</span>
  39 |     | <span class='neutral'>        uint32 _votingPeriod,</span>
  40 |     | <span class='neutral'>        uint256 _proposalThreshold</span>
  41 |     | <span class='neutral'>    ) public initializer {</span>
  42 |     | <span class='unexecuted'>        __Governor_init(&quot;AzemoraGovernor&quot;);</span>
  43 |     | <span class='unexecuted'>        __GovernorSettings_init(_votingDelay, _votingPeriod, _proposalThreshold);</span>
  44 |     | <span class='unexecuted'>        __GovernorVotes_init(token);</span>
  45 |     | <span class='unexecuted'>        __GovernorVotesQuorumFraction_init(4); // 4% quorum</span>
  46 |     | <span class='unexecuted'>        __GovernorTimelockControl_init(timelock);</span>
  47 |     | <span class='neutral'></span>
  48 |     | <span class='neutral'>        // The deployer is granted the proposer role by default,</span>
  49 |     | <span class='neutral'>        // and the timelock is granted the executor role.</span>
  50 |     | <span class='neutral'>        // The timelock admin is the governor itself.</span>
  51 |     | <span class='neutral'>    }</span>
  52 |     | <span class='neutral'></span>
  53 |     | <span class='neutral'>    // The following functions are overrides required by Solidity.</span>
  54 |     | <span class='neutral'></span>
  55 |     | <span class='unexecuted'>    function proposalNeedsQueuing(uint256 proposalId)</span>
  56 |     | <span class='neutral'>        public</span>
  57 |     | <span class='neutral'>        view</span>
  58 |     | <span class='neutral'>        override(GovernorUpgradeable, GovernorTimelockControlUpgradeable)</span>
  59 |     | <span class='unexecuted'>        returns (bool)</span>
  60 |     | <span class='neutral'>    {</span>
  61 |     | <span class='unexecuted'>        return super.proposalNeedsQueuing(proposalId);</span>
  62 |     | <span class='neutral'>    }</span>
  63 |     | <span class='neutral'></span>
  64 |     | <span class='unexecuted'>    function _queueOperations(</span>
  65 |     | <span class='neutral'>        uint256 proposalId,</span>
  66 |     | <span class='neutral'>        address[] memory targets,</span>
  67 |     | <span class='neutral'>        uint256[] memory values,</span>
  68 |     | <span class='neutral'>        bytes[] memory calldatas,</span>
  69 |     | <span class='neutral'>        bytes32 descriptionHash</span>
  70 |     | <span class='unexecuted'>    ) internal override(GovernorUpgradeable, GovernorTimelockControlUpgradeable) returns (uint48) {</span>
  71 |     | <span class='unexecuted'>        return super._queueOperations(proposalId, targets, values, calldatas, descriptionHash);</span>
  72 |     | <span class='neutral'>    }</span>
  73 |     | <span class='neutral'></span>
  74 |     | <span class='unexecuted'>    function _executeOperations(</span>
  75 |     | <span class='neutral'>        uint256 proposalId,</span>
  76 |     | <span class='neutral'>        address[] memory targets,</span>
  77 |     | <span class='neutral'>        uint256[] memory values,</span>
  78 |     | <span class='neutral'>        bytes[] memory calldatas,</span>
  79 |     | <span class='neutral'>        bytes32 descriptionHash</span>
  80 |     | <span class='neutral'>    ) internal override(GovernorUpgradeable, GovernorTimelockControlUpgradeable) {</span>
  81 |     | <span class='unexecuted'>        super._executeOperations(proposalId, targets, values, calldatas, descriptionHash);</span>
  82 |     | <span class='neutral'>    }</span>
  83 |     | <span class='neutral'></span>
  84 |     | <span class='unexecuted'>    function _cancel(</span>
  85 |     | <span class='neutral'>        address[] memory targets,</span>
  86 |     | <span class='neutral'>        uint256[] memory values,</span>
  87 |     | <span class='neutral'>        bytes[] memory calldatas,</span>
  88 |     | <span class='neutral'>        bytes32 descriptionHash</span>
  89 |     | <span class='unexecuted'>    ) internal override(GovernorUpgradeable, GovernorTimelockControlUpgradeable) returns (uint256) {</span>
  90 |     | <span class='unexecuted'>        return super._cancel(targets, values, calldatas, descriptionHash);</span>
  91 |     | <span class='neutral'>    }</span>
  92 |     | <span class='neutral'></span>
  93 |     | <span class='unexecuted'>    function _executor()</span>
  94 |     | <span class='neutral'>        internal</span>
  95 |     | <span class='neutral'>        view</span>
  96 |     | <span class='neutral'>        override(GovernorUpgradeable, GovernorTimelockControlUpgradeable)</span>
  97 |     | <span class='unexecuted'>        returns (address)</span>
  98 |     | <span class='neutral'>    {</span>
  99 |     | <span class='unexecuted'>        return super._executor();</span>
 100 |     | <span class='neutral'>    }</span>
 101 |     | <span class='neutral'></span>
 102 |     | <span class='unexecuted'>    function state(uint256 proposalId)</span>
 103 |     | <span class='neutral'>        public</span>
 104 |     | <span class='neutral'>        view</span>
 105 |     | <span class='neutral'>        override(GovernorUpgradeable, GovernorTimelockControlUpgradeable)</span>
 106 |     | <span class='unexecuted'>        returns (ProposalState)</span>
 107 |     | <span class='neutral'>    {</span>
 108 |     | <span class='unexecuted'>        return super.state(proposalId);</span>
 109 |     | <span class='neutral'>    }</span>
 110 |     | <span class='neutral'></span>
 111 |     | <span class='unexecuted'>    function votingDelay() public view override(GovernorUpgradeable, GovernorSettingsUpgradeable) returns (uint256) {</span>
 112 |     | <span class='unexecuted'>        return super.votingDelay();</span>
 113 |     | <span class='neutral'>    }</span>
 114 |     | <span class='neutral'></span>
 115 |     | <span class='unexecuted'>    function votingPeriod() public view override(GovernorUpgradeable, GovernorSettingsUpgradeable) returns (uint256) {</span>
 116 |     | <span class='neutral'>        return super.votingPeriod();</span>
 117 |     | <span class='neutral'>    }</span>
 118 |     | <span class='neutral'></span>
 119 |     | <span class='unexecuted'>    function quorum(uint256 blockNumber)</span>
 120 |     | <span class='neutral'>        public</span>
 121 |     | <span class='neutral'>        view</span>
 122 |     | <span class='neutral'>        override(GovernorUpgradeable, GovernorVotesQuorumFractionUpgradeable)</span>
 123 |     | <span class='unexecuted'>        returns (uint256)</span>
 124 |     | <span class='neutral'>    {</span>
 125 |     | <span class='unexecuted'>        return super.quorum(blockNumber);</span>
 126 |     | <span class='neutral'>    }</span>
 127 |     | <span class='neutral'></span>
 128 |     | <span class='unexecuted'>    function proposalThreshold()</span>
 129 |     | <span class='neutral'>        public</span>
 130 |     | <span class='neutral'>        view</span>
 131 |     | <span class='neutral'>        override(GovernorUpgradeable, GovernorSettingsUpgradeable)</span>
 132 |     | <span class='unexecuted'>        returns (uint256)</span>
 133 |     | <span class='neutral'>    {</span>
 134 |     | <span class='unexecuted'>        return super.proposalThreshold();</span>
 135 |     | <span class='neutral'>    }</span>
 136 |     | <span class='neutral'></span>
 137 |     | <span class='unexecuted'>    function supportsInterface(bytes4 interfaceId) public view override(GovernorUpgradeable) returns (bool) {</span>
 138 |     | <span class='unexecuted'>        return super.supportsInterface(interfaceId);</span>
 139 |     | <span class='neutral'>    }</span>
 140 |     | <span class='neutral'>}</span>
 141 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/phantom/Documents/azemora/azemora-contracts/src/governance/AzemoraTimelockController.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>pragma solidity ^0.8.20;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>import &quot;@openzeppelin/contracts-upgradeable/governance/TimelockControllerUpgradeable.sol&quot;;</span>
  5 |     | <span class='neutral'>import &quot;@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol&quot;;</span>
  6 |     | <span class='neutral'></span>
  7 |     | <span class='neutral'>/**</span>
  8 |     | <span class='neutral'> * @title AzemoraTimelockController</span>
  9 |     | <span class='neutral'> * @author Genci Mehmeti</span>
 10 |     | <span class='neutral'> * @dev A simple, upgradeable wrapper for OpenZeppelin&#39;s TimelockController.</span>
 11 |     | <span class='neutral'> * This contract will be the owner of other contracts in the system, and will</span>
 12 |     | <span class='neutral'> * execute transactions proposed and passed by the AzemoraGovernor.</span>
 13 |     | <span class='neutral'> */</span>
 14 |     | <span class='unexecuted'>contract AzemoraTimelockController is Initializable, TimelockControllerUpgradeable {</span>
 15 |     | <span class='neutral'>    /// @custom:oz-upgrades-unsafe-allow constructor</span>
 16 |     | <span class='unexecuted'>    constructor() {</span>
 17 |     | <span class='unexecuted'>        _disableInitializers();</span>
 18 |     | <span class='neutral'>    }</span>
 19 |     | <span class='neutral'></span>
 20 |     | <span class='unexecuted'>    function initialize(uint256 minDelay, address[] memory proposers, address[] memory executors, address admin)</span>
 21 |     | <span class='neutral'>        public</span>
 22 |     | <span class='neutral'>        override</span>
 23 |     | <span class='neutral'>        initializer</span>
 24 |     | <span class='neutral'>    {</span>
 25 |     | <span class='unexecuted'>        __TimelockController_init(minDelay, proposers, executors, admin);</span>
 26 |     | <span class='neutral'>    }</span>
 27 |     | <span class='neutral'>}</span>
 28 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/phantom/Documents/azemora/azemora-contracts/src/governance/Treasury.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>pragma solidity ^0.8.20;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>import &quot;@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol&quot;;</span>
  5 |     | <span class='neutral'>import &quot;@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol&quot;;</span>
  6 |     | <span class='neutral'>import &quot;@openzeppelin/contracts-upgradeable/utils/ReentrancyGuardUpgradeable.sol&quot;;</span>
  7 |     | <span class='neutral'>import &quot;@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol&quot;;</span>
  8 |     | <span class='neutral'></span>
  9 |     | <span class='neutral'>/**</span>
 10 |     | <span class='neutral'> * @title Treasury</span>
 11 |     | <span class='neutral'> * @author Genci Mehmeti</span>
 12 |     | <span class='neutral'> * @dev A simple contract to hold and manage funds for the Azemora platform.</span>
 13 |     | <span class='neutral'> * It is owned by the governance system (via the Timelock) and allows for the</span>
 14 |     | <span class='neutral'> * withdrawal of ETH and any ERC20 tokens.</span>
 15 |     | <span class='neutral'> */</span>
 16 |     | <span class='unexecuted'>contract Treasury is Initializable, OwnableUpgradeable, ReentrancyGuardUpgradeable, UUPSUpgradeable {</span>
 17 |     | <span class='neutral'>    event ETHWithdrawn(address indexed to, uint256 amount);</span>
 18 |     | <span class='neutral'>    event ERC20Withdrawn(address indexed token, address indexed to, uint256 amount);</span>
 19 |     | <span class='neutral'></span>
 20 |     | <span class='neutral'>    uint256[50] private __gap;</span>
 21 |     | <span class='neutral'></span>
 22 |     | <span class='neutral'>    /// @custom:oz-upgrades-unsafe-allow constructor</span>
 23 |     | <span class='unexecuted'>    constructor() {</span>
 24 |     | <span class='unexecuted'>        _disableInitializers();</span>
 25 |     | <span class='neutral'>    }</span>
 26 |     | <span class='neutral'></span>
 27 |     | <span class='unexecuted'>    function initialize(address initialOwner) public initializer {</span>
 28 |     | <span class='unexecuted'>        __Ownable_init(initialOwner);</span>
 29 |     | <span class='unexecuted'>        __ReentrancyGuard_init();</span>
 30 |     | <span class='unexecuted'>        __UUPSUpgradeable_init();</span>
 31 |     | <span class='neutral'>    }</span>
 32 |     | <span class='neutral'></span>
 33 |     | <span class='neutral'>    receive() external payable {}</span>
 34 |     | <span class='neutral'></span>
 35 |     | <span class='unexecuted'>    function withdrawETH(address to, uint256 amount) external onlyOwner nonReentrant {</span>
 36 |     | <span class='unexecuted'>        require(to != address(0), &quot;Cannot send to zero address&quot;);</span>
 37 |     | <span class='unexecuted'>        require(address(this).balance &gt;= amount, &quot;Insufficient ETH balance&quot;);</span>
 38 |     | <span class='unexecuted'>        (bool success,) = to.call{value: amount}(&quot;&quot;);</span>
 39 |     | <span class='unexecuted'>        require(success, &quot;ETH transfer failed&quot;);</span>
 40 |     | <span class='unexecuted'>        emit ETHWithdrawn(to, amount);</span>
 41 |     | <span class='neutral'>    }</span>
 42 |     | <span class='neutral'></span>
 43 |     | <span class='unexecuted'>    function withdrawERC20(address token, address to, uint256 amount) external onlyOwner nonReentrant {</span>
 44 |     | <span class='unexecuted'>        require(to != address(0), &quot;Cannot send to zero address&quot;);</span>
 45 |     | <span class='unexecuted'>        (bool success,) = token.call(abi.encodeWithSignature(&quot;transfer(address,uint256)&quot;, to, amount));</span>
 46 |     | <span class='unexecuted'>        require(success, &quot;ERC20 transfer failed&quot;);</span>
 47 |     | <span class='unexecuted'>        emit ERC20Withdrawn(token, to, amount);</span>
 48 |     | <span class='neutral'>    }</span>
 49 |     | <span class='neutral'></span>
 50 |     | <span class='unexecuted'>    function _authorizeUpgrade(address newImplementation) internal override onlyOwner {}</span>
 51 |     | <span class='neutral'>}</span>
 52 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/phantom/Documents/azemora/azemora-contracts/src/marketplace/Marketplace.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'>pragma solidity ^0.8.20;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>import &quot;@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol&quot;;</span>
   5 |     | <span class='neutral'>import &quot;@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol&quot;;</span>
   6 |     | <span class='neutral'>import &quot;@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol&quot;;</span>
   7 |     | <span class='neutral'>import &quot;@openzeppelin/contracts-upgradeable/utils/ReentrancyGuardUpgradeable.sol&quot;;</span>
   8 |     | <span class='neutral'>import &quot;@openzeppelin/contracts-upgradeable/token/ERC1155/utils/ERC1155HolderUpgradeable.sol&quot;;</span>
   9 |     | <span class='neutral'>import &quot;@openzeppelin/contracts-upgradeable/utils/PausableUpgradeable.sol&quot;;</span>
  10 |     | <span class='neutral'></span>
  11 |     | <span class='neutral'>// --- Custom Interfaces to avoid import issues ---</span>
  12 |     | <span class='neutral'></span>
  13 |     | <span class='neutral'>interface IERC165Upgradeable {</span>
  14 |     | <span class='neutral'>    function supportsInterface(bytes4 interfaceId) external view returns (bool);</span>
  15 |     | <span class='neutral'>}</span>
  16 |     | <span class='neutral'></span>
  17 |     | <span class='neutral'>// Interface for ERC1155 functionality</span>
  18 |     | <span class='neutral'>interface IERC1155Upgradeable is IERC165Upgradeable {</span>
  19 |     | <span class='neutral'>    event TransferSingle(address indexed operator, address indexed from, address indexed to, uint256 id, uint256 value);</span>
  20 |     | <span class='neutral'>    event TransferBatch(</span>
  21 |     | <span class='neutral'>        address indexed operator, address indexed from, address indexed to, uint256[] ids, uint256[] values</span>
  22 |     | <span class='neutral'>    );</span>
  23 |     | <span class='neutral'>    event ApprovalForAll(address indexed account, address indexed operator, bool approved);</span>
  24 |     | <span class='neutral'>    event URI(string value, uint256 indexed id);</span>
  25 |     | <span class='neutral'></span>
  26 |     | <span class='neutral'>    function balanceOf(address account, uint256 id) external view returns (uint256);</span>
  27 |     | <span class='neutral'></span>
  28 |     | <span class='neutral'>    function balanceOfBatch(address[] calldata accounts, uint256[] calldata ids)</span>
  29 |     | <span class='neutral'>        external</span>
  30 |     | <span class='neutral'>        view</span>
  31 |     | <span class='neutral'>        returns (uint256[] memory);</span>
  32 |     | <span class='neutral'></span>
  33 |     | <span class='neutral'>    function setApprovalForAll(address operator, bool approved) external;</span>
  34 |     | <span class='neutral'></span>
  35 |     | <span class='neutral'>    function isApprovedForAll(address account, address operator) external view returns (bool);</span>
  36 |     | <span class='neutral'></span>
  37 |     | <span class='neutral'>    function safeTransferFrom(address from, address to, uint256 id, uint256 amount, bytes calldata data) external;</span>
  38 |     | <span class='neutral'></span>
  39 |     | <span class='neutral'>    function safeBatchTransferFrom(</span>
  40 |     | <span class='neutral'>        address from,</span>
  41 |     | <span class='neutral'>        address to,</span>
  42 |     | <span class='neutral'>        uint256[] calldata ids,</span>
  43 |     | <span class='neutral'>        uint256[] calldata amounts,</span>
  44 |     | <span class='neutral'>        bytes calldata data</span>
  45 |     | <span class='neutral'>    ) external;</span>
  46 |     | <span class='neutral'>}</span>
  47 |     | <span class='neutral'></span>
  48 |     | <span class='neutral'>// Interface for ERC20 functionality, included directly to avoid import issues.</span>
  49 |     | <span class='neutral'>interface IERC20Upgradeable {</span>
  50 |     | <span class='neutral'>    event Transfer(address indexed from, address indexed to, uint256 value);</span>
  51 |     | <span class='neutral'>    event Approval(address indexed owner, address indexed spender, uint256 value);</span>
  52 |     | <span class='neutral'></span>
  53 |     | <span class='neutral'>    function totalSupply() external view returns (uint256);</span>
  54 |     | <span class='neutral'></span>
  55 |     | <span class='neutral'>    function balanceOf(address account) external view returns (uint256);</span>
  56 |     | <span class='neutral'></span>
  57 |     | <span class='neutral'>    function transfer(address to, uint256 amount) external returns (bool);</span>
  58 |     | <span class='neutral'></span>
  59 |     | <span class='neutral'>    function allowance(address owner, address spender) external view returns (uint256);</span>
  60 |     | <span class='neutral'></span>
  61 |     | <span class='neutral'>    function approve(address spender, uint256 amount) external returns (bool);</span>
  62 |     | <span class='neutral'></span>
  63 |     | <span class='neutral'>    function transferFrom(address from, address to, uint256 amount) external returns (bool);</span>
  64 |     | <span class='neutral'>}</span>
  65 |     | <span class='neutral'></span>
  66 |     | <span class='neutral'>// --- Custom Errors for Gas Optimization ---</span>
  67 |     | <span class='neutral'>error Marketplace__ZeroAmount();</span>
  68 |     | <span class='neutral'>error Marketplace__ZeroPrice();</span>
  69 |     | <span class='neutral'>error Marketplace__ZeroExpiry();</span>
  70 |     | <span class='neutral'>error Marketplace__ListingNotActive();</span>
  71 |     | <span class='neutral'>error Marketplace__ListingExpired();</span>
  72 |     | <span class='neutral'>error Marketplace__NotEnoughItemsInListing();</span>
  73 |     | <span class='neutral'>error Marketplace__InsufficientBalance();</span>
  74 |     | <span class='neutral'>error Marketplace__NotTheSeller();</span>
  75 |     | <span class='neutral'>error Marketplace__TreasuryAddressZero();</span>
  76 |     | <span class='neutral'>error Marketplace__FeeTooHigh();</span>
  77 |     | <span class='neutral'>error Marketplace__ListingNotFound();</span>
  78 |     | <span class='neutral'>error Marketplace__ArrayLengthMismatch();</span>
  79 |     | <span class='neutral'>error Marketplace__TransferFailed();</span>
  80 |     | <span class='neutral'>error Marketplace__ListingNotExpired();</span>
  81 |     | <span class='neutral'></span>
  82 |     | <span class='neutral'>/**</span>
  83 |     | <span class='neutral'> * @title Marketplace</span>
  84 |     | <span class='neutral'> * @author Genci Mehmeti</span>
  85 |     | <span class='neutral'> * @dev A custodial marketplace for trading ERC1155-based environmental assets.</span>
  86 |     | <span class='neutral'> * Sellers list their assets by transferring them to this contract. Buyers can then</span>
  87 |     | <span class='neutral'> * purchase these assets using a designated ERC20 payment token. The contract</span>
  88 |     | <span class='neutral'> * supports partial purchases and includes a platform fee on sales.</span>
  89 |     | <span class='neutral'> * It is upgradeable using the UUPS pattern.</span>
  90 |     | <span class='neutral'> */</span>
  91 | *   | <span class='executed'>contract Marketplace is</span>
  92 |     | <span class='neutral'>    Initializable,</span>
  93 |     | <span class='neutral'>    AccessControlUpgradeable,</span>
  94 |     | <span class='neutral'>    UUPSUpgradeable,</span>
  95 |     | <span class='neutral'>    ReentrancyGuardUpgradeable,</span>
  96 |     | <span class='neutral'>    ERC1155HolderUpgradeable,</span>
  97 |     | <span class='neutral'>    PausableUpgradeable</span>
  98 |     | <span class='neutral'>{</span>
  99 |     | <span class='neutral'>    // --- Roles ---</span>
 100 | *   | <span class='executed'>    bytes32 public constant PAUSER_ROLE = keccak256(&quot;PAUSER_ROLE&quot;);</span>
 101 |     | <span class='neutral'></span>
 102 |     | <span class='neutral'>    bytes32[] private _roles;</span>
 103 |     | <span class='neutral'></span>
 104 |     | <span class='neutral'>    // --- State ---</span>
 105 |     | <span class='unexecuted'>    IERC1155Upgradeable public creditContract;</span>
 106 |     | <span class='unexecuted'>    IERC20Upgradeable public paymentToken;</span>
 107 |     | <span class='unexecuted'>    address public treasury;</span>
 108 |     | <span class='unexecuted'>    uint256 public feeBps; // Fee in basis points (e.g., 250 = 2.5%)</span>
 109 |     | <span class='neutral'></span>
 110 |     | <span class='neutral'>    struct Listing {</span>
 111 |     | <span class='neutral'>        uint256 id;</span>
 112 |     | <span class='neutral'>        uint256 tokenId;</span>
 113 |     | <span class='neutral'>        uint256 amount;</span>
 114 |     | <span class='neutral'>        uint256 pricePerUnit;</span>
 115 |     | <span class='neutral'>        // --- Packed for gas efficiency ---</span>
 116 |     | <span class='neutral'>        address seller; // 20 bytes</span>
 117 |     | <span class='neutral'>        uint64 expiryTimestamp; // 8 bytes</span>
 118 |     | <span class='neutral'>        bool active; // 1 byte</span>
 119 |     | <span class='neutral'>    }</span>
 120 |     | <span class='neutral'></span>
 121 | *   | <span class='executed'>    mapping(uint256 =&gt; Listing) public listings;</span>
 122 | *   | <span class='executed'>    uint256 public listingIdCounter;</span>
 123 |     | <span class='unexecuted'>    uint256 public activeListingCount;</span>
 124 |     | <span class='neutral'></span>
 125 |     | <span class='neutral'>    uint256[50] private __gap;</span>
 126 |     | <span class='neutral'></span>
 127 |     | <span class='neutral'>    // --- Events ---</span>
 128 |     | <span class='neutral'>    event Listed(</span>
 129 |     | <span class='neutral'>        uint256 indexed listingId, address indexed seller, uint256 indexed tokenId, uint256 amount, uint256 pricePerUnit</span>
 130 |     | <span class='neutral'>    );</span>
 131 |     | <span class='neutral'>    event Sold(uint256 indexed listingId, address indexed buyer, uint256 amount, uint256 totalPrice);</span>
 132 |     | <span class='neutral'>    event ListingCancelled(uint256 indexed listingId);</span>
 133 |     | <span class='neutral'>    event ListingPriceUpdated(uint256 indexed listingId, uint256 newPricePerUnit);</span>
 134 |     | <span class='neutral'>    event TreasuryUpdated(address indexed newTreasury);</span>
 135 |     | <span class='neutral'>    event FeeUpdated(uint256 newFeeBps);</span>
 136 |     | <span class='neutral'>    event PartialSold(uint256 indexed listingId, address indexed buyer, uint256 amount, uint256 totalPrice);</span>
 137 |     | <span class='neutral'>    event FeePaid(address indexed recipient, uint256 amount);</span>
 138 |     | <span class='neutral'></span>
 139 |     | <span class='neutral'>    /// @custom:oz-upgrades-unsafe-allow constructor</span>
 140 | *   | <span class='executed'>    constructor() {</span>
 141 | *   | <span class='executed'>        _disableInitializers();</span>
 142 |     | <span class='neutral'>    }</span>
 143 |     | <span class='neutral'></span>
 144 |     | <span class='neutral'>    /**</span>
 145 |     | <span class='neutral'>     * @notice Initializes the marketplace with its core dependencies.</span>
 146 |     | <span class='neutral'>     * @dev Sets up roles and contract dependencies. The deployer is granted `DEFAULT_ADMIN_ROLE`</span>
 147 |     | <span class='neutral'>     * and `PAUSER_ROLE`. The `treasury` and `feeBps` must be set in separate transactions</span>
 148 |     | <span class='neutral'>     * after initialization.</span>
 149 |     | <span class='neutral'>     * @param creditContract_ The address of the ERC1155 `DynamicImpactCredit` contract.</span>
 150 |     | <span class='neutral'>     * @param paymentToken_ The address of the ERC20 token used for payments.</span>
 151 |     | <span class='neutral'>     */</span>
 152 | *   | <span class='executed'>    function initialize(address creditContract_, address paymentToken_) public initializer {</span>
 153 | *   | <span class='executed'>        __AccessControl_init();</span>
 154 | *   | <span class='executed'>        __UUPSUpgradeable_init();</span>
 155 | *   | <span class='executed'>        __ReentrancyGuard_init();</span>
 156 | *   | <span class='executed'>        __ERC1155Holder_init();</span>
 157 | *   | <span class='executed'>        __Pausable_init();</span>
 158 |     | <span class='neutral'></span>
 159 | *   | <span class='executed'>        _grantRole(DEFAULT_ADMIN_ROLE, _msgSender());</span>
 160 | *   | <span class='executed'>        _grantRole(PAUSER_ROLE, _msgSender());</span>
 161 |     | <span class='neutral'></span>
 162 | *   | <span class='executed'>        creditContract = IERC1155Upgradeable(creditContract_);</span>
 163 | *   | <span class='executed'>        paymentToken = IERC20Upgradeable(paymentToken_);</span>
 164 |     | <span class='neutral'></span>
 165 | *   | <span class='executed'>        _roles.push(DEFAULT_ADMIN_ROLE);</span>
 166 | *   | <span class='executed'>        _roles.push(PAUSER_ROLE);</span>
 167 |     | <span class='neutral'>    }</span>
 168 |     | <span class='neutral'></span>
 169 |     | <span class='neutral'>    /**</span>
 170 |     | <span class='neutral'>     * @notice Lists a specified amount of an ERC1155 token for sale.</span>
 171 |     | <span class='neutral'>     * @dev The seller must have first approved the marketplace to manage their tokens via `setApprovalForAll`.</span>
 172 |     | <span class='neutral'>     * The tokens are held in custody by this contract until sold or the listing is cancelled.</span>
 173 |     | <span class='neutral'>     * Emits a `Listed` event.</span>
 174 |     | <span class='neutral'>     * @param tokenId The ID of the token to list.</span>
 175 |     | <span class='neutral'>     * @param amount The quantity of the token to list.</span>
 176 |     | <span class='neutral'>     * @param pricePerUnit The price for each single unit of the token in the payment currency.</span>
 177 |     | <span class='neutral'>     * @param expiryDuration The duration in seconds from now after which the listing will expire.</span>
 178 |     | <span class='neutral'>     * @return listingId The unique ID of the newly created listing.</span>
 179 |     | <span class='neutral'>     */</span>
 180 | *   | <span class='executed'>    function list(uint256 tokenId, uint256 amount, uint256 pricePerUnit, uint256 expiryDuration)</span>
 181 |     | <span class='neutral'>        external</span>
 182 |     | <span class='neutral'>        nonReentrant</span>
 183 |     | <span class='neutral'>        whenNotPaused</span>
 184 | *   | <span class='executed'>        returns (uint256 listingId)</span>
 185 |     | <span class='neutral'>    {</span>
 186 | *   | <span class='executed'>        if (amount == 0) revert Marketplace__ZeroAmount();</span>
 187 | *   | <span class='executed'>        if (pricePerUnit == 0) revert Marketplace__ZeroPrice();</span>
 188 | *   | <span class='executed'>        if (expiryDuration == 0) revert Marketplace__ZeroExpiry();</span>
 189 |     | <span class='neutral'></span>
 190 |     | <span class='neutral'>        // Custodial model: Transfer tokens from seller to this contract</span>
 191 | *   | <span class='executed'>        creditContract.safeTransferFrom(_msgSender(), address(this), tokenId, amount, &quot;&quot;);</span>
 192 |     | <span class='neutral'></span>
 193 | *   | <span class='executed'>        listingId = listingIdCounter++;</span>
 194 | *   | <span class='executed'>        listings[listingId] = Listing({</span>
 195 | *   | <span class='executed'>            id: listingId,</span>
 196 | *   | <span class='executed'>            seller: _msgSender(),</span>
 197 | *   | <span class='executed'>            tokenId: tokenId,</span>
 198 | *   | <span class='executed'>            amount: amount,</span>
 199 | *   | <span class='executed'>            pricePerUnit: pricePerUnit,</span>
 200 | *   | <span class='executed'>            expiryTimestamp: uint64(block.timestamp + expiryDuration),</span>
 201 | *   | <span class='executed'>            active: true</span>
 202 |     | <span class='neutral'>        });</span>
 203 |     | <span class='neutral'></span>
 204 | *   | <span class='executed'>        activeListingCount++;</span>
 205 |     | <span class='neutral'></span>
 206 | *   | <span class='executed'>        emit Listed(listingId, _msgSender(), tokenId, amount, pricePerUnit);</span>
 207 |     | <span class='neutral'>        return listingId;</span>
 208 |     | <span class='neutral'>    }</span>
 209 |     | <span class='neutral'></span>
 210 |     | <span class='neutral'>    /**</span>
 211 |     | <span class='neutral'>     * @notice Purchases a specified amount of tokens from an active listing.</span>
 212 |     | <span class='neutral'>     * @dev The buyer must have first approved the marketplace to spend their payment tokens via `approve`.</span>
 213 |     | <span class='neutral'>     * The function handles payment transfers to the seller and the treasury, and transfers the</span>
 214 |     | <span class='neutral'>     * purchased tokens to the buyer. Supports partial buys.</span>
 215 |     | <span class='neutral'>     * Emits a `PartialSold` event or a `Sold` event if the listing is fully depleted.</span>
 216 |     | <span class='neutral'>     * @param listingId The ID of the listing to buy from.</span>
 217 |     | <span class='neutral'>     * @param amountToBuy The quantity of tokens to purchase from the listing.</span>
 218 |     | <span class='neutral'>     */</span>
 219 | *   | <span class='executed'>    function buy(uint256 listingId, uint256 amountToBuy) external nonReentrant whenNotPaused {</span>
 220 | *   | <span class='executed'>        Listing storage listing = listings[listingId];</span>
 221 |     | <span class='neutral'>        // --- CHECKS ---</span>
 222 | *   | <span class='executed'>        if (!listing.active) revert Marketplace__ListingNotActive();</span>
 223 | *   | <span class='executed'>        if (block.timestamp &gt;= listing.expiryTimestamp) revert Marketplace__ListingExpired();</span>
 224 | *   | <span class='executed'>        if (amountToBuy == 0) revert Marketplace__ZeroAmount();</span>
 225 | *   | <span class='executed'>        if (listing.amount &lt; amountToBuy) revert Marketplace__NotEnoughItemsInListing();</span>
 226 |     | <span class='neutral'></span>
 227 | *   | <span class='executed'>        uint256 totalPrice = amountToBuy * listing.pricePerUnit;</span>
 228 | *   | <span class='executed'>        if (paymentToken.balanceOf(_msgSender()) &lt; totalPrice) revert Marketplace__InsufficientBalance();</span>
 229 |     | <span class='neutral'></span>
 230 | *   | <span class='executed'>        uint256 fee = (totalPrice * feeBps) / 10000;</span>
 231 | *   | <span class='executed'>        uint256 sellerProceeds = totalPrice - fee;</span>
 232 |     | <span class='neutral'></span>
 233 |     | <span class='neutral'>        // --- EFFECTS ---</span>
 234 | *   | <span class='executed'>        listing.amount -= amountToBuy;</span>
 235 | *   | <span class='executed'>        if (listing.amount == 0) {</span>
 236 | *   | <span class='executed'>            listing.active = false;</span>
 237 | *   | <span class='executed'>            activeListingCount--;</span>
 238 | *   | <span class='executed'>            emit Sold(listingId, _msgSender(), amountToBuy, totalPrice);</span>
 239 |     | <span class='neutral'>        } else {</span>
 240 | *   | <span class='executed'>            emit PartialSold(listingId, _msgSender(), amountToBuy, totalPrice);</span>
 241 |     | <span class='neutral'>        }</span>
 242 |     | <span class='neutral'></span>
 243 |     | <span class='neutral'>        // --- INTERACTIONS ---</span>
 244 |     | <span class='neutral'>        // Transfer payment from buyer to seller and fee recipient</span>
 245 | *   | <span class='executed'>        if (sellerProceeds &gt; 0) {</span>
 246 | *   | <span class='executed'>            if (!paymentToken.transferFrom(_msgSender(), listing.seller, sellerProceeds)) {</span>
 247 |     | <span class='unexecuted'>                revert Marketplace__TransferFailed();</span>
 248 |     | <span class='neutral'>            }</span>
 249 |     | <span class='neutral'>        }</span>
 250 | *   | <span class='executed'>        if (fee &gt; 0) {</span>
 251 |     | <span class='unexecuted'>            if (!paymentToken.transferFrom(_msgSender(), treasury, fee)) {</span>
 252 |     | <span class='unexecuted'>                revert Marketplace__TransferFailed();</span>
 253 |     | <span class='neutral'>            }</span>
 254 |     | <span class='unexecuted'>            emit FeePaid(treasury, fee);</span>
 255 |     | <span class='neutral'>        }</span>
 256 |     | <span class='neutral'></span>
 257 |     | <span class='neutral'>        // Transfer the NFT from marketplace to buyer</span>
 258 | *   | <span class='executed'>        creditContract.safeTransferFrom(address(this), _msgSender(), listing.tokenId, amountToBuy, &quot;&quot;);</span>
 259 |     | <span class='neutral'>    }</span>
 260 |     | <span class='neutral'></span>
 261 |     | <span class='neutral'>    /**</span>
 262 |     | <span class='neutral'>     * @notice Cancels an active listing.</span>
 263 |     | <span class='neutral'>     * @dev Can only be called by the original seller. Any unsold tokens held in custody are</span>
 264 |     | <span class='neutral'>     * returned to the seller. Emits a `ListingCancelled` event.</span>
 265 |     | <span class='neutral'>     * @param listingId The ID of the listing to cancel.</span>
 266 |     | <span class='neutral'>     */</span>
 267 | *   | <span class='executed'>    function cancelListing(uint256 listingId) external nonReentrant whenNotPaused {</span>
 268 | *   | <span class='executed'>        Listing storage listing = listings[listingId];</span>
 269 | *   | <span class='executed'>        if (!listing.active) revert Marketplace__ListingNotActive();</span>
 270 | *   | <span class='executed'>        if (listing.seller != _msgSender()) revert Marketplace__NotTheSeller();</span>
 271 |     | <span class='neutral'></span>
 272 |     | <span class='neutral'>        listing.active = false;</span>
 273 |     | <span class='neutral'>        activeListingCount--;</span>
 274 |     | <span class='neutral'></span>
 275 |     | <span class='neutral'>        // Return the unsold tokens to the seller</span>
 276 |     | <span class='neutral'>        creditContract.safeTransferFrom(address(this), listing.seller, listing.tokenId, listing.amount, &quot;&quot;);</span>
 277 |     | <span class='neutral'></span>
 278 |     | <span class='neutral'>        emit ListingCancelled(listingId);</span>
 279 |     | <span class='neutral'>    }</span>
 280 |     | <span class='neutral'></span>
 281 |     | <span class='neutral'>    /**</span>
 282 |     | <span class='neutral'>     * @notice Cancels multiple active listings in a single transaction.</span>
 283 |     | <span class='neutral'>     * @dev Can only be called by the original seller of all listings. Unsold tokens</span>
 284 |     | <span class='neutral'>     * for each cancelled listing are returned to the seller in a single batch transaction,</span>
 285 |     | <span class='neutral'>     * which is more gas-efficient than calling `cancelListing` individually.</span>
 286 |     | <span class='neutral'>     * @param listingIds An array of listing IDs to cancel.</span>
 287 |     | <span class='neutral'>     */</span>
 288 |     | <span class='unexecuted'>    function batchCancelListings(uint256[] calldata listingIds) external nonReentrant whenNotPaused {</span>
 289 |     | <span class='unexecuted'>        uint256[] memory tokenIds = new uint256[](listingIds.length);</span>
 290 |     | <span class='unexecuted'>        uint256[] memory amounts = new uint256[](listingIds.length);</span>
 291 |     | <span class='neutral'>        address seller = _msgSender();</span>
 292 |     | <span class='neutral'></span>
 293 |     | <span class='neutral'>        // Down-counting loop is more gas-efficient.</span>
 294 |     | <span class='unexecuted'>        for (uint256 i = listingIds.length; i &gt; 0; --i) {</span>
 295 |     | <span class='unexecuted'>            uint256 listingId = listingIds[i - 1];</span>
 296 |     | <span class='unexecuted'>            Listing storage listing = listings[listingId];</span>
 297 |     | <span class='unexecuted'>            if (!listing.active) revert Marketplace__ListingNotActive();</span>
 298 |     | <span class='unexecuted'>            if (listing.seller != seller) revert Marketplace__NotTheSeller();</span>
 299 |     | <span class='neutral'></span>
 300 |     | <span class='unexecuted'>            listing.active = false;</span>
 301 |     | <span class='unexecuted'>            activeListingCount--;</span>
 302 |     | <span class='neutral'></span>
 303 |     | <span class='unexecuted'>            tokenIds[i - 1] = listing.tokenId;</span>
 304 |     | <span class='unexecuted'>            amounts[i - 1] = listing.amount;</span>
 305 |     | <span class='neutral'></span>
 306 |     | <span class='unexecuted'>            emit ListingCancelled(listingId);</span>
 307 |     | <span class='neutral'>        }</span>
 308 |     | <span class='neutral'></span>
 309 |     | <span class='neutral'>        // Return all unsold tokens to the seller in a single batch transaction</span>
 310 |     | <span class='unexecuted'>        creditContract.safeBatchTransferFrom(address(this), seller, tokenIds, amounts, &quot;&quot;);</span>
 311 |     | <span class='neutral'>    }</span>
 312 |     | <span class='neutral'></span>
 313 |     | <span class='neutral'>    /**</span>
 314 |     | <span class='neutral'>     * @notice Purchases tokens from multiple listings in a single transaction.</span>
 315 |     | <span class='neutral'>     * @dev The buyer must have approved the marketplace to spend the total amount of payment tokens.</span>
 316 |     | <span class='neutral'>     * This function iterates through the provided listings and amounts, processes payments,</span>
 317 |     | <span class='neutral'>     * and transfers the purchased tokens to the buyer in a single batch. It is significantly</span>
 318 |     | <span class='neutral'>     * more gas-efficient than calling `buy` multiple times.</span>
 319 |     | <span class='neutral'>     * @param listingIds An array of listing IDs to buy from.</span>
 320 |     | <span class='neutral'>     * @param amountsToBuy An array of token quantities to purchase from each corresponding listing.</span>
 321 |     | <span class='neutral'>     */</span>
 322 |     | <span class='unexecuted'>    function batchBuy(uint256[] calldata listingIds, uint256[] calldata amountsToBuy)</span>
 323 |     | <span class='neutral'>        external</span>
 324 |     | <span class='neutral'>        nonReentrant</span>
 325 |     | <span class='neutral'>        whenNotPaused</span>
 326 |     | <span class='unexecuted'>    {</span>
 327 |     | <span class='unexecuted'>        if (listingIds.length != amountsToBuy.length) revert Marketplace__ArrayLengthMismatch();</span>
 328 |     | <span class='neutral'></span>
 329 |     | <span class='unexecuted'>        uint256 totalPayment = 0;</span>
 330 |     | <span class='neutral'>        uint256 totalFee = 0;</span>
 331 |     | <span class='unexecuted'>        uint256[] memory tokenIds = new uint256[](listingIds.length);</span>
 332 |     | <span class='unexecuted'>        uint256 len = listingIds.length;</span>
 333 |     | <span class='neutral'></span>
 334 |     | <span class='neutral'>        // First loop for CHECKS. This is critical for security and atomicity.</span>
 335 |     | <span class='neutral'>        // Down-counting loop is more gas-efficient.</span>
 336 |     | <span class='unexecuted'>        for (uint256 i = len; i &gt; 0; --i) {</span>
 337 |     | <span class='unexecuted'>            uint256 listingId = listingIds[i - 1];</span>
 338 |     | <span class='unexecuted'>            uint256 amountToBuy = amountsToBuy[i - 1];</span>
 339 |     | <span class='unexecuted'>            Listing storage listing = listings[listingId];</span>
 340 |     | <span class='neutral'></span>
 341 |     | <span class='unexecuted'>            if (!listing.active) revert Marketplace__ListingNotActive();</span>
 342 |     | <span class='unexecuted'>            if (block.timestamp &gt;= listing.expiryTimestamp) revert Marketplace__ListingExpired();</span>
 343 |     | <span class='unexecuted'>            if (amountToBuy == 0) revert Marketplace__ZeroAmount();</span>
 344 |     | <span class='unexecuted'>            if (listing.amount &lt; amountToBuy) revert Marketplace__NotEnoughItemsInListing();</span>
 345 |     | <span class='neutral'></span>
 346 |     | <span class='unexecuted'>            uint256 price = amountToBuy * listing.pricePerUnit;</span>
 347 |     | <span class='unexecuted'>            totalPayment += price;</span>
 348 |     | <span class='unexecuted'>            totalFee += (price * feeBps) / 10000;</span>
 349 |     | <span class='neutral'>        }</span>
 350 |     | <span class='neutral'></span>
 351 |     | <span class='unexecuted'>        if (paymentToken.balanceOf(_msgSender()) &lt; totalPayment) revert Marketplace__InsufficientBalance();</span>
 352 |     | <span class='neutral'></span>
 353 |     | <span class='neutral'>        // Transfer total fee to treasury in one go.</span>
 354 |     | <span class='unexecuted'>        if (totalFee &gt; 0) {</span>
 355 |     | <span class='unexecuted'>            if (!paymentToken.transferFrom(_msgSender(), treasury, totalFee)) {</span>
 356 |     | <span class='unexecuted'>                revert Marketplace__TransferFailed();</span>
 357 |     | <span class='neutral'>            }</span>
 358 |     | <span class='unexecuted'>            emit FeePaid(treasury, totalFee);</span>
 359 |     | <span class='neutral'>        }</span>
 360 |     | <span class='neutral'></span>
 361 |     | <span class='neutral'>        // Second loop for EFFECTS and INTERACTIONS (Seller payments).</span>
 362 |     | <span class='neutral'>        // Down-counting loop is more gas-efficient.</span>
 363 |     | <span class='unexecuted'>        for (uint256 i = len; i &gt; 0; --i) {</span>
 364 |     | <span class='unexecuted'>            uint256 listingId = listingIds[i - 1];</span>
 365 |     | <span class='unexecuted'>            uint256 amountToBuy = amountsToBuy[i - 1];</span>
 366 |     | <span class='unexecuted'>            Listing storage listing = listings[listingId];</span>
 367 |     | <span class='neutral'></span>
 368 |     | <span class='unexecuted'>            uint256 price = amountToBuy * listing.pricePerUnit;</span>
 369 |     | <span class='unexecuted'>            uint256 fee = (price * feeBps) / 10000;</span>
 370 |     | <span class='unexecuted'>            uint256 sellerProceeds = price - fee;</span>
 371 |     | <span class='neutral'></span>
 372 |     | <span class='neutral'>            // --- EFFECTS ---</span>
 373 |     | <span class='unexecuted'>            listing.amount -= amountToBuy;</span>
 374 |     | <span class='unexecuted'>            if (listing.amount == 0) {</span>
 375 |     | <span class='unexecuted'>                listing.active = false;</span>
 376 |     | <span class='unexecuted'>                activeListingCount--;</span>
 377 |     | <span class='unexecuted'>                emit Sold(listingId, _msgSender(), amountToBuy, price);</span>
 378 |     | <span class='neutral'>            } else {</span>
 379 |     | <span class='unexecuted'>                emit PartialSold(listingId, _msgSender(), amountToBuy, price);</span>
 380 |     | <span class='neutral'>            }</span>
 381 |     | <span class='neutral'></span>
 382 |     | <span class='unexecuted'>            tokenIds[i - 1] = listing.tokenId;</span>
 383 |     | <span class='neutral'></span>
 384 |     | <span class='neutral'>            // --- INTERACTIONS (Seller Only) ---</span>
 385 |     | <span class='unexecuted'>            if (sellerProceeds &gt; 0) {</span>
 386 |     | <span class='unexecuted'>                if (!paymentToken.transferFrom(_msgSender(), listing.seller, sellerProceeds)) {</span>
 387 |     | <span class='unexecuted'>                    revert Marketplace__TransferFailed();</span>
 388 |     | <span class='neutral'>                }</span>
 389 |     | <span class='neutral'>            }</span>
 390 |     | <span class='neutral'>        }</span>
 391 |     | <span class='neutral'></span>
 392 |     | <span class='neutral'>        // Final Interaction: Batch transfer all NFTs to buyer.</span>
 393 |     | <span class='unexecuted'>        creditContract.safeBatchTransferFrom(address(this), _msgSender(), tokenIds, amountsToBuy, &quot;&quot;);</span>
 394 |     | <span class='neutral'>    }</span>
 395 |     | <span class='neutral'></span>
 396 |     | <span class='neutral'>    /**</span>
 397 |     | <span class='neutral'>     * @notice Cancels an expired listing.</span>
 398 |     | <span class='neutral'>     * @dev Can be called by anyone to clean up an expired listing. The unsold</span>
 399 |     | <span class='neutral'>     * tokens are returned from custody to the seller.</span>
 400 |     | <span class='neutral'>     * @param listingId The ID of the expired listing to cancel.</span>
 401 |     | <span class='neutral'>     */</span>
 402 | *   | <span class='executed'>    function cancelExpiredListing(uint256 listingId) external nonReentrant whenNotPaused {</span>
 403 |     | <span class='unexecuted'>        Listing storage listing = listings[listingId];</span>
 404 |     | <span class='unexecuted'>        if (!listing.active) revert Marketplace__ListingNotActive();</span>
 405 | *   | <span class='executed'>        if (block.timestamp &lt; listing.expiryTimestamp) revert Marketplace__ListingNotExpired();</span>
 406 |     | <span class='neutral'></span>
 407 | *   | <span class='executed'>        listing.active = false;</span>
 408 | *   | <span class='executed'>        activeListingCount--;</span>
 409 |     | <span class='neutral'></span>
 410 |     | <span class='neutral'>        // Return the unsold tokens to the seller</span>
 411 | *   | <span class='executed'>        creditContract.safeTransferFrom(address(this), listing.seller, listing.tokenId, listing.amount, &quot;&quot;);</span>
 412 |     | <span class='neutral'></span>
 413 |     | <span class='unexecuted'>        emit ListingCancelled(listingId);</span>
 414 |     | <span class='neutral'>    }</span>
 415 |     | <span class='neutral'></span>
 416 |     | <span class='neutral'>    /**</span>
 417 |     | <span class='neutral'>     * @notice Allows a seller to update the price of their active listing.</span>
 418 |     | <span class='neutral'>     * @dev Can only be called by the original seller of the listing.</span>
 419 |     | <span class='neutral'>     * Emits a `ListingPriceUpdated` event.</span>
 420 |     | <span class='neutral'>     * @param listingId The ID of the listing to update.</span>
 421 |     | <span class='neutral'>     * @param newPricePerUnit The new price for each unit of the token.</span>
 422 |     | <span class='neutral'>     */</span>
 423 |     | <span class='unexecuted'>    function updateListingPrice(uint256 listingId, uint256 newPricePerUnit) external nonReentrant whenNotPaused {</span>
 424 |     | <span class='unexecuted'>        Listing storage listing = listings[listingId];</span>
 425 |     | <span class='unexecuted'>        if (!listing.active) revert Marketplace__ListingNotActive();</span>
 426 |     | <span class='unexecuted'>        if (listing.seller != _msgSender()) revert Marketplace__NotTheSeller();</span>
 427 |     | <span class='unexecuted'>        if (newPricePerUnit == 0) revert Marketplace__ZeroPrice();</span>
 428 |     | <span class='neutral'></span>
 429 |     | <span class='unexecuted'>        listing.pricePerUnit = newPricePerUnit;</span>
 430 |     | <span class='unexecuted'>        emit ListingPriceUpdated(listingId, newPricePerUnit);</span>
 431 |     | <span class='neutral'>    }</span>
 432 |     | <span class='neutral'></span>
 433 |     | <span class='neutral'>    /**</span>
 434 |     | <span class='neutral'>     * @notice Sets the address of the treasury contract that receives platform fees.</span>
 435 |     | <span class='neutral'>     * @dev Can only be called by an address with the `DEFAULT_ADMIN_ROLE`.</span>
 436 |     | <span class='neutral'>     * It is recommended this be the Timelock contract in a DAO context.</span>
 437 |     | <span class='neutral'>     * Emits a `TreasuryUpdated` event.</span>
 438 |     | <span class='neutral'>     * @param newTreasury The address of the new treasury.</span>
 439 |     | <span class='neutral'>     */</span>
 440 |     | <span class='unexecuted'>    function setTreasury(address newTreasury) external onlyRole(DEFAULT_ADMIN_ROLE) {</span>
 441 |     | <span class='unexecuted'>        if (newTreasury == address(0)) revert Marketplace__TreasuryAddressZero();</span>
 442 |     | <span class='unexecuted'>        treasury = newTreasury;</span>
 443 |     | <span class='unexecuted'>        emit TreasuryUpdated(newTreasury);</span>
 444 |     | <span class='neutral'>    }</span>
 445 |     | <span class='neutral'></span>
 446 |     | <span class='neutral'>    /**</span>
 447 |     | <span class='neutral'>     * @notice Sets the platform fee in basis points.</span>
 448 |     | <span class='neutral'>     * @dev Can only be called by an address with the `DEFAULT_ADMIN_ROLE`.</span>
 449 |     | <span class='neutral'>     * For example, a value of 250 corresponds to a 2.5% fee.</span>
 450 |     | <span class='neutral'>     * Emits a `FeeUpdated` event.</span>
 451 |     | <span class='neutral'>     * @param newFeeBps The new fee in basis points.</span>
 452 |     | <span class='neutral'>     */</span>
 453 |     | <span class='unexecuted'>    function setFee(uint256 newFeeBps) external onlyRole(DEFAULT_ADMIN_ROLE) {</span>
 454 |     | <span class='neutral'>        // A sanity check to prevent accidentally setting an enormous fee.</span>
 455 |     | <span class='neutral'>        // 10000 bps = 100%</span>
 456 |     | <span class='unexecuted'>        if (newFeeBps &gt; 10000) revert Marketplace__FeeTooHigh();</span>
 457 |     | <span class='unexecuted'>        feeBps = newFeeBps;</span>
 458 |     | <span class='unexecuted'>        emit FeeUpdated(newFeeBps);</span>
 459 |     | <span class='neutral'>    }</span>
 460 |     | <span class='neutral'></span>
 461 |     | <span class='neutral'>    /**</span>
 462 |     | <span class='neutral'>     * @notice Retrieves the details of a specific listing.</span>
 463 |     | <span class='neutral'>     * @param listingId The ID of the listing to query.</span>
 464 |     | <span class='neutral'>     * @return A `Listing` struct containing the listing&#39;s data.</span>
 465 |     | <span class='neutral'>     */</span>
 466 |     | <span class='unexecuted'>    function getListing(uint256 listingId) external view returns (Listing memory) {</span>
 467 |     | <span class='unexecuted'>        if (listings[listingId].id != listingId) revert Marketplace__ListingNotFound();</span>
 468 |     | <span class='unexecuted'>        return listings[listingId];</span>
 469 |     | <span class='neutral'>    }</span>
 470 |     | <span class='neutral'></span>
 471 |     | <span class='neutral'>    /**</span>
 472 |     | <span class='neutral'>     * @notice Gets all the roles held by a specific account.</span>
 473 |     | <span class='neutral'>     * @dev Provides an easy way for UIs and other tools to check permissions.</span>
 474 |     | <span class='neutral'>     * @param account The address to check.</span>
 475 |     | <span class='neutral'>     * @return A list of role identifiers held by the account.</span>
 476 |     | <span class='neutral'>     */</span>
 477 |     | <span class='unexecuted'>    function getRoles(address account) external view returns (bytes32[] memory) {</span>
 478 |     | <span class='neutral'>        // More efficient implementation: loop only once.</span>
 479 |     | <span class='unexecuted'>        bytes32[] memory temporaryRoles = new bytes32[](_roles.length);</span>
 480 |     | <span class='unexecuted'>        uint256 count = 0;</span>
 481 |     | <span class='unexecuted'>        for (uint256 i = 0; i &lt; _roles.length; i++) {</span>
 482 |     | <span class='unexecuted'>            if (hasRole(_roles[i], account)) {</span>
 483 |     | <span class='unexecuted'>                temporaryRoles[count] = _roles[i];</span>
 484 |     | <span class='unexecuted'>                count++;</span>
 485 |     | <span class='neutral'>            }</span>
 486 |     | <span class='neutral'>        }</span>
 487 |     | <span class='neutral'></span>
 488 |     | <span class='unexecuted'>        bytes32[] memory roles = new bytes32[](count);</span>
 489 |     | <span class='unexecuted'>        for (uint256 i = 0; i &lt; count; i++) {</span>
 490 |     | <span class='unexecuted'>            roles[i] = temporaryRoles[i];</span>
 491 |     | <span class='neutral'>        }</span>
 492 |     | <span class='unexecuted'>        return roles;</span>
 493 |     | <span class='neutral'>    }</span>
 494 |     | <span class='neutral'></span>
 495 |     | <span class='neutral'>    /**</span>
 496 |     | <span class='neutral'>     * @notice Pauses all state-changing functions in the contract.</span>
 497 |     | <span class='neutral'>     * @dev Can only be called by an address with the `PAUSER_ROLE`.</span>
 498 |     | <span class='neutral'>     * This is a critical safety feature to halt activity in case of an emergency.</span>
 499 |     | <span class='neutral'>     * Emits a `Paused` event.</span>
 500 |     | <span class='neutral'>     */</span>
 501 |     | <span class='unexecuted'>    function pause() external onlyRole(PAUSER_ROLE) {</span>
 502 |     | <span class='unexecuted'>        _pause();</span>
 503 |     | <span class='neutral'>    }</span>
 504 |     | <span class='neutral'></span>
 505 |     | <span class='neutral'>    /**</span>
 506 |     | <span class='neutral'>     * @notice Lifts the pause on the contract, resuming normal operations.</span>
 507 |     | <span class='neutral'>     * @dev Can only be called by an address with the `PAUSER_ROLE`.</span>
 508 |     | <span class='neutral'>     * Emits an `Unpaused` event.</span>
 509 |     | <span class='neutral'>     */</span>
 510 |     | <span class='unexecuted'>    function unpause() external onlyRole(PAUSER_ROLE) {</span>
 511 |     | <span class='unexecuted'>        _unpause();</span>
 512 |     | <span class='neutral'>    }</span>
 513 |     | <span class='neutral'></span>
 514 |     | <span class='neutral'>    // --- Interface Support ---</span>
 515 | *   | <span class='executed'>    function supportsInterface(bytes4 interfaceId)</span>
 516 |     | <span class='neutral'>        public</span>
 517 |     | <span class='neutral'>        view</span>
 518 |     | <span class='neutral'>        override(AccessControlUpgradeable, ERC1155HolderUpgradeable)</span>
 519 |     | <span class='unexecuted'>        returns (bool)</span>
 520 |     | <span class='neutral'>    {</span>
 521 | *   | <span class='executed'>        return super.supportsInterface(interfaceId);</span>
 522 |     | <span class='neutral'>    }</span>
 523 |     | <span class='neutral'></span>
 524 |     | <span class='neutral'>    /* ---------- upgrade auth ---------- */</span>
 525 |     | <span class='unexecuted'>    function _authorizeUpgrade(address newImplementation) internal override onlyRole(DEFAULT_ADMIN_ROLE) {}</span>
 526 |     | <span class='neutral'>}</span>
 527 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/phantom/Documents/azemora/azemora-contracts/src/token/AzemoraToken.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>pragma solidity ^0.8.20;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>import &quot;@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol&quot;;</span>
  5 |     | <span class='neutral'>import &quot;@openzeppelin/contracts-upgradeable/token/ERC20/extensions/ERC20PermitUpgradeable.sol&quot;;</span>
  6 |     | <span class='neutral'>import &quot;@openzeppelin/contracts-upgradeable/token/ERC20/extensions/ERC20VotesUpgradeable.sol&quot;;</span>
  7 |     | <span class='neutral'>import &quot;@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol&quot;;</span>
  8 |     | <span class='neutral'>import &quot;@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol&quot;;</span>
  9 |     | <span class='neutral'>import &quot;@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol&quot;;</span>
 10 |     | <span class='neutral'></span>
 11 |     | <span class='neutral'>/**</span>
 12 |     | <span class='neutral'> * @title AzemoraToken</span>
 13 |     | <span class='neutral'> * @author Genci Mehmeti</span>
 14 |     | <span class='neutral'> * @dev The governance token for the Azemora platform.</span>
 15 |     | <span class='neutral'> * It is an ERC20 token with voting and permit functionalities, based on OpenZeppelin&#39;s</span>
 16 |     | <span class='neutral'> * upgradeable contracts. A fixed supply of 1 billion tokens is minted to the</span>
 17 |     | <span class='neutral'> * admin upon initialization.</span>
 18 |     | <span class='neutral'> */</span>
 19 |     | <span class='unexecuted'>contract AzemoraToken is</span>
 20 |     | <span class='neutral'>    Initializable,</span>
 21 |     | <span class='neutral'>    ERC20Upgradeable,</span>
 22 |     | <span class='neutral'>    ERC20PermitUpgradeable,</span>
 23 |     | <span class='neutral'>    ERC20VotesUpgradeable,</span>
 24 |     | <span class='neutral'>    AccessControlUpgradeable,</span>
 25 |     | <span class='neutral'>    UUPSUpgradeable</span>
 26 |     | <span class='neutral'>{</span>
 27 |     | <span class='neutral'>    /// @custom:oz-upgrades-unsafe-allow constructor</span>
 28 |     | <span class='unexecuted'>    constructor() {</span>
 29 |     | <span class='unexecuted'>        _disableInitializers();</span>
 30 |     | <span class='neutral'>    }</span>
 31 |     | <span class='neutral'></span>
 32 |     | <span class='unexecuted'>    function initialize() public initializer {</span>
 33 |     | <span class='unexecuted'>        __ERC20_init(&quot;Azemora&quot;, &quot;AZE&quot;);</span>
 34 |     | <span class='unexecuted'>        __ERC20Permit_init(&quot;Azemora&quot;);</span>
 35 |     | <span class='unexecuted'>        __ERC20Votes_init();</span>
 36 |     | <span class='unexecuted'>        __AccessControl_init();</span>
 37 |     | <span class='unexecuted'>        __UUPSUpgradeable_init();</span>
 38 |     | <span class='neutral'></span>
 39 |     | <span class='unexecuted'>        _grantRole(DEFAULT_ADMIN_ROLE, _msgSender());</span>
 40 |     | <span class='neutral'></span>
 41 |     | <span class='neutral'>        // Mint a fixed supply of 1 billion tokens to the deployer.</span>
 42 |     | <span class='neutral'>        // The token has 18 decimals by default.</span>
 43 |     | <span class='unexecuted'>        _mint(_msgSender(), 1_000_000_000 * (10 ** decimals()));</span>
 44 |     | <span class='neutral'>    }</span>
 45 |     | <span class='neutral'></span>
 46 |     | <span class='neutral'>    // The following functions are overrides required by Solidity.</span>
 47 |     | <span class='neutral'></span>
 48 |     | <span class='unexecuted'>    function _update(address from, address to, uint256 value)</span>
 49 |     | <span class='neutral'>        internal</span>
 50 |     | <span class='neutral'>        override(ERC20Upgradeable, ERC20VotesUpgradeable)</span>
 51 |     | <span class='neutral'>    {</span>
 52 |     | <span class='unexecuted'>        super._update(from, to, value);</span>
 53 |     | <span class='neutral'>    }</span>
 54 |     | <span class='neutral'></span>
 55 |     | <span class='unexecuted'>    function nonces(address owner) public view override(ERC20PermitUpgradeable, NoncesUpgradeable) returns (uint256) {</span>
 56 |     | <span class='unexecuted'>        return super.nonces(owner);</span>
 57 |     | <span class='neutral'>    }</span>
 58 |     | <span class='neutral'></span>
 59 |     | <span class='unexecuted'>    function _authorizeUpgrade(address newImplementation) internal override onlyRole(DEFAULT_ADMIN_ROLE) {}</span>
 60 |     | <span class='neutral'>}</span>
 61 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/phantom/Documents/azemora/azemora-contracts/test/dMRVManager/DMRVManager.fuzz.t.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'>pragma solidity ^0.8.20;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>import &quot;forge-std/Test.sol&quot;;</span>
   5 |     | <span class='neutral'>import &quot;../../src/core/dMRVManager.sol&quot;;</span>
   6 |     | <span class='neutral'>import &quot;../../src/core/ProjectRegistry.sol&quot;;</span>
   7 |     | <span class='neutral'>import &quot;../../src/core/DynamicImpactCredit.sol&quot;;</span>
   8 |     | <span class='neutral'>import &quot;@openzeppelin/contracts/proxy/ERC1967/ERC1967Proxy.sol&quot;;</span>
   9 |     | <span class='neutral'></span>
  10 |     | <span class='unexecuted'>contract DMRVManagerFuzzTest is Test {</span>
  11 |     | <span class='neutral'>    DMRVManager manager;</span>
  12 |     | <span class='neutral'>    ProjectRegistry registry;</span>
  13 |     | <span class='neutral'>    DynamicImpactCredit credit;</span>
  14 |     | <span class='neutral'></span>
  15 |     | <span class='unexecuted'>    address admin = address(0xA11CE);</span>
  16 |     | <span class='unexecuted'>    address oracle = address(0x0AC1E);</span>
  17 |     | <span class='unexecuted'>    address verifier = address(0xC1E4);</span>
  18 |     | <span class='unexecuted'>    address projectOwner = address(0x044E);</span>
  19 |     | <span class='neutral'></span>
  20 |     | <span class='unexecuted'>    bytes32 projectId = keccak256(&quot;Fuzz Test Project&quot;);</span>
  21 |     | <span class='neutral'></span>
  22 |     | <span class='unexecuted'>    function setUp() public {</span>
  23 |     | <span class='neutral'>        // Deploy and set up the contract infrastructure</span>
  24 |     | <span class='unexecuted'>        vm.startPrank(admin);</span>
  25 |     | <span class='neutral'></span>
  26 |     | <span class='neutral'>        // 1. Deploy Registry</span>
  27 |     | <span class='unexecuted'>        registry = ProjectRegistry(</span>
  28 |     | <span class='unexecuted'>            address(new ERC1967Proxy(address(new ProjectRegistry()), abi.encodeCall(ProjectRegistry.initialize, ())))</span>
  29 |     | <span class='neutral'>        );</span>
  30 |     | <span class='unexecuted'>        registry.grantRole(registry.VERIFIER_ROLE(), verifier);</span>
  31 |     | <span class='neutral'></span>
  32 |     | <span class='neutral'>        // 2. Deploy DynamicImpactCredit</span>
  33 |     | <span class='unexecuted'>        credit = DynamicImpactCredit(</span>
  34 |     | <span class='neutral'>            address(</span>
  35 |     | <span class='unexecuted'>                new ERC1967Proxy(</span>
  36 |     | <span class='unexecuted'>                    address(new DynamicImpactCredit(address(registry))),</span>
  37 |     | <span class='unexecuted'>                    abi.encodeCall(DynamicImpactCredit.initialize, (&quot;uri&quot;))</span>
  38 |     | <span class='neutral'>                )</span>
  39 |     | <span class='neutral'>            )</span>
  40 |     | <span class='neutral'>        );</span>
  41 |     | <span class='neutral'></span>
  42 |     | <span class='neutral'>        // 3. Deploy DMRVManager</span>
  43 |     | <span class='unexecuted'>        DMRVManager managerImpl = new DMRVManager(address(registry), address(credit));</span>
  44 |     | <span class='unexecuted'>        manager =</span>
  45 |     | <span class='unexecuted'>            DMRVManager(address(new ERC1967Proxy(address(managerImpl), abi.encodeCall(DMRVManager.initialize, ()))));</span>
  46 |     | <span class='neutral'></span>
  47 |     | <span class='neutral'>        // 4. Set up roles</span>
  48 |     | <span class='unexecuted'>        credit.grantRole(credit.DMRV_MANAGER_ROLE(), address(manager));</span>
  49 |     | <span class='unexecuted'>        credit.grantRole(credit.METADATA_UPDATER_ROLE(), address(manager));</span>
  50 |     | <span class='unexecuted'>        manager.grantRole(manager.ORACLE_ROLE(), oracle);</span>
  51 |     | <span class='neutral'></span>
  52 |     | <span class='unexecuted'>        vm.stopPrank();</span>
  53 |     | <span class='neutral'></span>
  54 |     | <span class='neutral'>        // 5. Register and activate a test project for fuzzing</span>
  55 |     | <span class='unexecuted'>        vm.prank(projectOwner);</span>
  56 |     | <span class='unexecuted'>        registry.registerProject(projectId, &quot;ipfs://initial.json&quot;);</span>
  57 |     | <span class='neutral'></span>
  58 |     | <span class='unexecuted'>        vm.prank(verifier);</span>
  59 |     | <span class='unexecuted'>        registry.setProjectStatus(projectId, ProjectRegistry.ProjectStatus.Active);</span>
  60 |     | <span class='neutral'></span>
  61 |     | <span class='neutral'>        // 6. Set an initial verification to establish a base URI history</span>
  62 |     | <span class='unexecuted'>        vm.prank(admin);</span>
  63 |     | <span class='unexecuted'>        manager.adminSubmitVerification(projectId, 1, &quot;ipfs://initial.json&quot;, false);</span>
  64 |     | <span class='neutral'>    }</span>
  65 |     | <span class='neutral'></span>
  66 |     | <span class='unexecuted'>    function testFuzz_FulfillVerification(</span>
  67 |     | <span class='neutral'>        uint256 creditAmount,</span>
  68 |     | <span class='neutral'>        bool updateMetadataOnly,</span>
  69 |     | <span class='neutral'>        bytes32 signature,</span>
  70 |     | <span class='neutral'>        string calldata metadataURI</span>
  71 |     | <span class='unexecuted'>    ) public {</span>
  72 |     | <span class='neutral'>        // Bound the amount to prevent absolutely massive numbers that trigger edge cases</span>
  73 |     | <span class='neutral'>        // Uint64.max (18.4 quintillion) is a practical but still very large limit</span>
  74 |     | <span class='unexecuted'>        uint64 maxAmount = type(uint64).max;</span>
  75 |     | <span class='unexecuted'>        creditAmount = bound(creditAmount, 0, maxAmount);</span>
  76 |     | <span class='neutral'></span>
  77 |     | <span class='neutral'>        // Skip empty strings or strings with ASCII control characters</span>
  78 |     | <span class='unexecuted'>        vm.assume(bytes(metadataURI).length &gt; 0);</span>
  79 |     | <span class='neutral'></span>
  80 |     | <span class='neutral'>        // --- Setup State ---</span>
  81 |     | <span class='neutral'>        // 1. Create a fresh verification request for each fuzz run</span>
  82 |     | <span class='unexecuted'>        vm.prank(projectOwner);</span>
  83 |     | <span class='unexecuted'>        bytes32 requestId = manager.requestVerification(projectId);</span>
  84 |     | <span class='neutral'></span>
  85 |     | <span class='neutral'>        // 2. Capture initial state</span>
  86 |     | <span class='unexecuted'>        uint256 initialBalance = credit.balanceOf(projectOwner, uint256(projectId));</span>
  87 |     | <span class='unexecuted'>        string[] memory initialHistory = credit.getTokenURIHistory(uint256(projectId));</span>
  88 |     | <span class='unexecuted'>        uint256 initialHistoryLength = initialHistory.length;</span>
  89 |     | <span class='neutral'></span>
  90 |     | <span class='neutral'>        // --- Execute Action ---</span>
  91 |     | <span class='neutral'>        // 3. Prepare oracle data and fulfill the request</span>
  92 |     | <span class='unexecuted'>        bytes memory data = abi.encode(creditAmount, updateMetadataOnly, signature, metadataURI);</span>
  93 |     | <span class='neutral'></span>
  94 |     | <span class='unexecuted'>        vm.prank(oracle);</span>
  95 |     | <span class='unexecuted'>        manager.fulfillVerification(requestId, data);</span>
  96 |     | <span class='neutral'></span>
  97 |     | <span class='neutral'>        // --- Assert Final State ---</span>
  98 |     | <span class='neutral'>        // 4. Verify the state changes match the inputs</span>
  99 |     | <span class='unexecuted'>        if (updateMetadataOnly) {</span>
 100 |     | <span class='neutral'>            // Balance should be unchanged</span>
 101 |     | <span class='unexecuted'>            assertEq(</span>
 102 |     | <span class='unexecuted'>                credit.balanceOf(projectOwner, uint256(projectId)),</span>
 103 |     | <span class='unexecuted'>                initialBalance,</span>
 104 |     | <span class='neutral'>                &quot;Balance should not change on metadata update&quot;</span>
 105 |     | <span class='neutral'>            );</span>
 106 |     | <span class='neutral'></span>
 107 |     | <span class='neutral'>            // Metadata should be updated and history grown by 1</span>
 108 |     | <span class='unexecuted'>            assertEq(credit.uri(uint256(projectId)), metadataURI, &quot;URI should be updated&quot;);</span>
 109 |     | <span class='unexecuted'>            string[] memory finalHistory = credit.getTokenURIHistory(uint256(projectId));</span>
 110 |     | <span class='unexecuted'>            assertEq(finalHistory.length, initialHistoryLength + 1, &quot;URI history should grow by 1&quot;);</span>
 111 |     | <span class='unexecuted'>            assertEq(finalHistory[finalHistory.length - 1], metadataURI, &quot;New URI should be last in history&quot;);</span>
 112 |     | <span class='neutral'>        } else {</span>
 113 |     | <span class='neutral'>            // Balance should increase by the credit amount</span>
 114 |     | <span class='unexecuted'>            assertEq(</span>
 115 |     | <span class='unexecuted'>                credit.balanceOf(projectOwner, uint256(projectId)),</span>
 116 |     | <span class='unexecuted'>                initialBalance + creditAmount,</span>
 117 |     | <span class='neutral'>                &quot;Balance should increase on mint&quot;</span>
 118 |     | <span class='neutral'>            );</span>
 119 |     | <span class='neutral'></span>
 120 |     | <span class='neutral'>            // Metadata should be updated if credits were minted</span>
 121 |     | <span class='unexecuted'>            if (creditAmount &gt; 0) {</span>
 122 |     | <span class='unexecuted'>                assertEq(credit.uri(uint256(projectId)), metadataURI, &quot;URI should be updated on mint&quot;);</span>
 123 |     | <span class='unexecuted'>                string[] memory finalHistory = credit.getTokenURIHistory(uint256(projectId));</span>
 124 |     | <span class='unexecuted'>                assertEq(finalHistory.length, initialHistoryLength + 1, &quot;URI history should grow by 1 on mint&quot;);</span>
 125 |     | <span class='neutral'>            } else {</span>
 126 |     | <span class='neutral'>                // If amount is 0 and not update-only, nothing should change</span>
 127 |     | <span class='unexecuted'>                assertEq(</span>
 128 |     | <span class='unexecuted'>                    credit.uri(uint256(projectId)),</span>
 129 |     | <span class='unexecuted'>                    initialHistory[initialHistory.length - 1],</span>
 130 |     | <span class='neutral'>                    &quot;URI should not change if amount is 0&quot;</span>
 131 |     | <span class='neutral'>                );</span>
 132 |     | <span class='neutral'>            }</span>
 133 |     | <span class='neutral'>        }</span>
 134 |     | <span class='neutral'>    }</span>
 135 |     | <span class='neutral'>}</span>
 136 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/phantom/Documents/azemora/azemora-contracts/test/dMRVManager/dMRVManager.t.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>pragma solidity ^0.8.20;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>import &quot;forge-std/Test.sol&quot;;</span>
  5 |     | <span class='neutral'>import &quot;../../src/core/dMRVManager.sol&quot;;</span>
  6 |     | <span class='neutral'>import &quot;../../src/core/ProjectRegistry.sol&quot;;</span>
  7 |     | <span class='neutral'>import &quot;../../src/core/DynamicImpactCredit.sol&quot;;</span>
  8 |     | <span class='neutral'>import &quot;@openzeppelin/contracts/proxy/ERC1967/ERC1967Proxy.sol&quot;;</span>
  9 |     | <span class='neutral'></span>
 10 |     | <span class='unexecuted'>contract DMRVManagerTest is Test {</span>
 11 |     | <span class='neutral'>    DMRVManager dMRVManager;</span>
 12 |     | <span class='neutral'>    ProjectRegistry registry;</span>
 13 |     | <span class='neutral'>    DynamicImpactCredit credit;</span>
 14 |     | <span class='neutral'></span>
 15 |     | <span class='unexecuted'>    address admin = address(0xA11CE);</span>
 16 |     | <span class='unexecuted'>    address oracle = address(0x044C);</span>
 17 |     | <span class='unexecuted'>    address projectOwner = address(0x044E);</span>
 18 |     | <span class='neutral'></span>
 19 |     | <span class='unexecuted'>    bytes32 projectId = keccak256(&quot;Test Project&quot;);</span>
 20 |     | <span class='neutral'>    bytes32 requestId;</span>
 21 |     | <span class='neutral'></span>
 22 |     | <span class='unexecuted'>    function setUp() public {</span>
 23 |     | <span class='unexecuted'>        vm.startPrank(admin);</span>
 24 |     | <span class='neutral'>        // --- Registry Setup ---</span>
 25 |     | <span class='unexecuted'>        ProjectRegistry registryImpl = new ProjectRegistry();</span>
 26 |     | <span class='unexecuted'>        bytes memory registryInitData = abi.encodeCall(ProjectRegistry.initialize, ());</span>
 27 |     | <span class='unexecuted'>        ERC1967Proxy registryProxy = new ERC1967Proxy(address(registryImpl), registryInitData);</span>
 28 |     | <span class='unexecuted'>        registry = ProjectRegistry(address(registryProxy));</span>
 29 |     | <span class='neutral'></span>
 30 |     | <span class='neutral'>        // --- Credit Setup ---</span>
 31 |     | <span class='unexecuted'>        DynamicImpactCredit creditImpl = new DynamicImpactCredit(address(registry));</span>
 32 |     | <span class='unexecuted'>        bytes memory creditInitData = abi.encodeCall(DynamicImpactCredit.initialize, (&quot;ipfs://collection&quot;));</span>
 33 |     | <span class='unexecuted'>        ERC1967Proxy creditProxy = new ERC1967Proxy(address(creditImpl), creditInitData);</span>
 34 |     | <span class='unexecuted'>        credit = DynamicImpactCredit(address(creditProxy));</span>
 35 |     | <span class='neutral'></span>
 36 |     | <span class='neutral'>        // --- dMRVManager Setup ---</span>
 37 |     | <span class='unexecuted'>        DMRVManager dMRVManagerImpl = new DMRVManager(address(registry), address(credit));</span>
 38 |     | <span class='unexecuted'>        bytes memory dMRVManagerInitData = abi.encodeCall(DMRVManager.initialize, ());</span>
 39 |     | <span class='unexecuted'>        ERC1967Proxy dMRVManagerProxy = new ERC1967Proxy(address(dMRVManagerImpl), dMRVManagerInitData);</span>
 40 |     | <span class='unexecuted'>        dMRVManager = DMRVManager(address(dMRVManagerProxy));</span>
 41 |     | <span class='neutral'></span>
 42 |     | <span class='neutral'>        // --- Role Setup ---</span>
 43 |     | <span class='unexecuted'>        dMRVManager.grantRole(dMRVManager.ORACLE_ROLE(), oracle);</span>
 44 |     | <span class='unexecuted'>        credit.grantRole(credit.DMRV_MANAGER_ROLE(), address(dMRVManager));</span>
 45 |     | <span class='neutral'></span>
 46 |     | <span class='unexecuted'>        vm.stopPrank();</span>
 47 |     | <span class='neutral'></span>
 48 |     | <span class='neutral'>        // --- Initial State ---</span>
 49 |     | <span class='neutral'>        // Register and approve a project</span>
 50 |     | <span class='unexecuted'>        vm.prank(projectOwner);</span>
 51 |     | <span class='unexecuted'>        registry.registerProject(projectId, &quot;ipfs://initial.json&quot;);</span>
 52 |     | <span class='unexecuted'>        vm.prank(admin);</span>
 53 |     | <span class='unexecuted'>        registry.setProjectStatus(projectId, ProjectRegistry.ProjectStatus.Active);</span>
 54 |     | <span class='neutral'></span>
 55 |     | <span class='neutral'>        // Make an initial verification request</span>
 56 |     | <span class='unexecuted'>        vm.prank(projectOwner);</span>
 57 |     | <span class='unexecuted'>        requestId = dMRVManager.requestVerification(projectId);</span>
 58 |     | <span class='neutral'>    }</span>
 59 |     | <span class='neutral'></span>
 60 |     | <span class='unexecuted'>    function test_RequestVerification_RevertsForNonActiveProject() public {</span>
 61 |     | <span class='neutral'>        // Register a new project, leave it in Pending state</span>
 62 |     | <span class='unexecuted'>        vm.prank(projectOwner);</span>
 63 |     | <span class='unexecuted'>        bytes32 pendingProjectId = keccak256(&quot;Pending Project&quot;);</span>
 64 |     | <span class='unexecuted'>        registry.registerProject(pendingProjectId, &quot;ipfs://pending.json&quot;);</span>
 65 |     | <span class='neutral'></span>
 66 |     | <span class='unexecuted'>        vm.prank(projectOwner);</span>
 67 |     | <span class='unexecuted'>        vm.expectRevert(DMRVManager__ProjectNotActive.selector);</span>
 68 |     | <span class='unexecuted'>        dMRVManager.requestVerification(pendingProjectId);</span>
 69 |     | <span class='neutral'>    }</span>
 70 |     | <span class='neutral'></span>
 71 |     | <span class='unexecuted'>    function test_FulfillVerification_RevertsForNonExistentRequest() public {</span>
 72 |     | <span class='unexecuted'>        bytes32 nonExistentRequestId = keccak256(&quot;non-existent&quot;);</span>
 73 |     | <span class='unexecuted'>        bytes memory data = abi.encode(100, false, bytes32(0), &quot;ipfs://new.json&quot;);</span>
 74 |     | <span class='neutral'></span>
 75 |     | <span class='unexecuted'>        vm.prank(oracle);</span>
 76 |     | <span class='unexecuted'>        vm.expectRevert(DMRVManager__RequestNotFound.selector);</span>
 77 |     | <span class='unexecuted'>        dMRVManager.fulfillVerification(nonExistentRequestId, data);</span>
 78 |     | <span class='neutral'>    }</span>
 79 |     | <span class='neutral'></span>
 80 |     | <span class='unexecuted'>    function test_FulfillVerification_RevertsWhenAlreadyFulfilled() public {</span>
 81 |     | <span class='unexecuted'>        bytes memory data = abi.encode(100, false, bytes32(0), &quot;ipfs://new.json&quot;);</span>
 82 |     | <span class='neutral'></span>
 83 |     | <span class='neutral'>        // Fulfill it once</span>
 84 |     | <span class='unexecuted'>        vm.prank(oracle);</span>
 85 |     | <span class='unexecuted'>        dMRVManager.fulfillVerification(requestId, data);</span>
 86 |     | <span class='neutral'></span>
 87 |     | <span class='neutral'>        // Try to fulfill it again</span>
 88 |     | <span class='unexecuted'>        vm.prank(oracle);</span>
 89 |     | <span class='unexecuted'>        vm.expectRevert(DMRVManager__RequestAlreadyFulfilled.selector);</span>
 90 |     | <span class='unexecuted'>        dMRVManager.fulfillVerification(requestId, data);</span>
 91 |     | <span class='neutral'>    }</span>
 92 |     | <span class='neutral'>}</span>
 93 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/phantom/Documents/azemora/azemora-contracts/test/dMRVManager/dMRVManager.uncovered.t.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'>pragma solidity ^0.8.20;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>import &quot;forge-std/Test.sol&quot;;</span>
   5 |     | <span class='neutral'>import &quot;../../src/core/dMRVManager.sol&quot;;</span>
   6 |     | <span class='neutral'>import &quot;../../src/core/ProjectRegistry.sol&quot;;</span>
   7 |     | <span class='neutral'>import &quot;../../src/core/DynamicImpactCredit.sol&quot;;</span>
   8 |     | <span class='neutral'>import &quot;@openzeppelin/contracts/proxy/ERC1967/ERC1967Proxy.sol&quot;;</span>
   9 |     | <span class='neutral'></span>
  10 |     | <span class='unexecuted'>contract DMRVManagerTest is Test {</span>
  11 |     | <span class='neutral'>    DMRVManager manager;</span>
  12 |     | <span class='neutral'>    ProjectRegistry registry;</span>
  13 |     | <span class='neutral'>    DynamicImpactCredit credit;</span>
  14 |     | <span class='neutral'></span>
  15 |     | <span class='unexecuted'>    address admin = address(0xA11CE);</span>
  16 |     | <span class='unexecuted'>    address oracle = address(0x0AC1E);</span>
  17 |     | <span class='unexecuted'>    address verifier = address(0xC1E4);</span>
  18 |     | <span class='unexecuted'>    address projectOwner = address(0x044E);</span>
  19 |     | <span class='neutral'></span>
  20 |     | <span class='unexecuted'>    bytes32 projectId = keccak256(&quot;Test Project&quot;);</span>
  21 |     | <span class='neutral'></span>
  22 |     | <span class='unexecuted'>    function setUp() public {</span>
  23 |     | <span class='neutral'>        // Deploy and set up the contract infrastructure</span>
  24 |     | <span class='unexecuted'>        vm.startPrank(admin);</span>
  25 |     | <span class='neutral'></span>
  26 |     | <span class='neutral'>        // 1. Deploy Registry</span>
  27 |     | <span class='unexecuted'>        ProjectRegistry registryImpl = new ProjectRegistry();</span>
  28 |     | <span class='unexecuted'>        bytes memory registryInitData = abi.encodeCall(ProjectRegistry.initialize, ());</span>
  29 |     | <span class='unexecuted'>        ERC1967Proxy registryProxy = new ERC1967Proxy(address(registryImpl), registryInitData);</span>
  30 |     | <span class='unexecuted'>        registry = ProjectRegistry(address(registryProxy));</span>
  31 |     | <span class='unexecuted'>        registry.grantRole(registry.VERIFIER_ROLE(), verifier);</span>
  32 |     | <span class='neutral'></span>
  33 |     | <span class='neutral'>        // 2. Deploy DynamicImpactCredit</span>
  34 |     | <span class='unexecuted'>        DynamicImpactCredit creditImpl = new DynamicImpactCredit(address(registry));</span>
  35 |     | <span class='unexecuted'>        bytes memory creditInitData = abi.encodeCall(DynamicImpactCredit.initialize, (&quot;ipfs://contract-metadata.json&quot;));</span>
  36 |     | <span class='unexecuted'>        ERC1967Proxy creditProxy = new ERC1967Proxy(address(creditImpl), creditInitData);</span>
  37 |     | <span class='unexecuted'>        credit = DynamicImpactCredit(address(creditProxy));</span>
  38 |     | <span class='neutral'></span>
  39 |     | <span class='neutral'>        // 3. Deploy DMRVManager</span>
  40 |     | <span class='unexecuted'>        DMRVManager managerImpl = new DMRVManager(address(registry), address(credit));</span>
  41 |     | <span class='unexecuted'>        bytes memory managerInitData = abi.encodeCall(DMRVManager.initialize, ());</span>
  42 |     | <span class='unexecuted'>        ERC1967Proxy managerProxy = new ERC1967Proxy(address(managerImpl), managerInitData);</span>
  43 |     | <span class='unexecuted'>        manager = DMRVManager(address(managerProxy));</span>
  44 |     | <span class='neutral'></span>
  45 |     | <span class='neutral'>        // 4. Set up roles</span>
  46 |     | <span class='unexecuted'>        credit.grantRole(credit.DMRV_MANAGER_ROLE(), address(manager));</span>
  47 |     | <span class='unexecuted'>        credit.grantRole(credit.METADATA_UPDATER_ROLE(), address(manager));</span>
  48 |     | <span class='unexecuted'>        manager.grantRole(manager.ORACLE_ROLE(), oracle);</span>
  49 |     | <span class='neutral'></span>
  50 |     | <span class='unexecuted'>        vm.stopPrank();</span>
  51 |     | <span class='neutral'></span>
  52 |     | <span class='neutral'>        // 5. Register and activate a test project</span>
  53 |     | <span class='unexecuted'>        vm.prank(projectOwner);</span>
  54 |     | <span class='unexecuted'>        registry.registerProject(projectId, &quot;ipfs://initial.json&quot;);</span>
  55 |     | <span class='neutral'></span>
  56 |     | <span class='unexecuted'>        vm.prank(verifier);</span>
  57 |     | <span class='unexecuted'>        registry.setProjectStatus(projectId, ProjectRegistry.ProjectStatus.Active);</span>
  58 |     | <span class='neutral'>    }</span>
  59 |     | <span class='neutral'></span>
  60 |     | <span class='neutral'>    /* ---------- Basic Functionality Tests ---------- */</span>
  61 |     | <span class='neutral'></span>
  62 |     | <span class='unexecuted'>    function test_Initialization() public view {</span>
  63 |     | <span class='unexecuted'>        assertEq(address(manager.projectRegistry()), address(registry));</span>
  64 |     | <span class='unexecuted'>        assertEq(address(manager.creditContract()), address(credit));</span>
  65 |     | <span class='unexecuted'>        assertTrue(manager.hasRole(manager.ORACLE_ROLE(), oracle));</span>
  66 |     | <span class='unexecuted'>        assertTrue(manager.hasRole(manager.DEFAULT_ADMIN_ROLE(), admin));</span>
  67 |     | <span class='neutral'>    }</span>
  68 |     | <span class='neutral'></span>
  69 |     | <span class='unexecuted'>    function test_RequestVerification() public {</span>
  70 |     | <span class='unexecuted'>        vm.prank(projectOwner);</span>
  71 |     | <span class='unexecuted'>        bytes32 requestId = manager.requestVerification(projectId);</span>
  72 |     | <span class='neutral'></span>
  73 |     | <span class='neutral'>        // Verify requestId is not zero</span>
  74 |     | <span class='unexecuted'>        assertTrue(requestId != bytes32(0));</span>
  75 |     | <span class='neutral'>    }</span>
  76 |     | <span class='neutral'></span>
  77 |     | <span class='neutral'>    /* ---------- Oracle Fulfillment Tests ---------- */</span>
  78 |     | <span class='neutral'></span>
  79 |     | <span class='unexecuted'>    function test_OracleFulfillment_MintCredits() public {</span>
  80 |     | <span class='neutral'>        // 1. Create a verification request</span>
  81 |     | <span class='unexecuted'>        vm.prank(projectOwner);</span>
  82 |     | <span class='unexecuted'>        bytes32 requestId = manager.requestVerification(projectId);</span>
  83 |     | <span class='neutral'></span>
  84 |     | <span class='neutral'>        // 2. Prepare oracle data for minting 100 credits</span>
  85 |     | <span class='unexecuted'>        uint256 creditAmount = 100;</span>
  86 |     | <span class='unexecuted'>        string memory metadataURI = &quot;ipfs://new-verification.json&quot;;</span>
  87 |     | <span class='unexecuted'>        bool updateMetadataOnly = false;</span>
  88 |     | <span class='unexecuted'>        bytes32 signature = keccak256(abi.encodePacked(&quot;test-signature&quot;));</span>
  89 |     | <span class='neutral'></span>
  90 |     | <span class='neutral'>        // 3. Encode the data according to our expected format</span>
  91 |     | <span class='unexecuted'>        bytes memory data = abi.encode(creditAmount, updateMetadataOnly, signature, metadataURI);</span>
  92 |     | <span class='neutral'></span>
  93 |     | <span class='neutral'>        // 4. Oracle fulfills the verification</span>
  94 |     | <span class='unexecuted'>        vm.prank(oracle);</span>
  95 |     | <span class='unexecuted'>        manager.fulfillVerification(requestId, data);</span>
  96 |     | <span class='neutral'></span>
  97 |     | <span class='neutral'>        // 5. Check that credits were minted to project owner</span>
  98 |     | <span class='unexecuted'>        assertEq(credit.balanceOf(projectOwner, uint256(projectId)), 100);</span>
  99 |     | <span class='unexecuted'>        assertEq(credit.uri(uint256(projectId)), metadataURI);</span>
 100 |     | <span class='neutral'>    }</span>
 101 |     | <span class='neutral'></span>
 102 |     | <span class='unexecuted'>    function test_OracleFulfillment_UpdateMetadataOnly() public {</span>
 103 |     | <span class='neutral'>        // 1. First mint some initial credits directly instead of calling the other test</span>
 104 |     | <span class='unexecuted'>        vm.prank(projectOwner);</span>
 105 |     | <span class='unexecuted'>        bytes32 initialRequestId = manager.requestVerification(projectId);</span>
 106 |     | <span class='neutral'></span>
 107 |     | <span class='neutral'>        // Set up initial minting data</span>
 108 |     | <span class='unexecuted'>        bytes memory initialData = abi.encode(</span>
 109 |     | <span class='unexecuted'>            uint256(100), // creditAmount</span>
 110 |     | <span class='unexecuted'>            false, // updateMetadataOnly</span>
 111 |     | <span class='unexecuted'>            bytes32(0), // signature</span>
 112 |     | <span class='neutral'>            &quot;ipfs://initial.json&quot; // metadataURI</span>
 113 |     | <span class='neutral'>        );</span>
 114 |     | <span class='neutral'></span>
 115 |     | <span class='unexecuted'>        vm.prank(oracle);</span>
 116 |     | <span class='unexecuted'>        manager.fulfillVerification(initialRequestId, initialData);</span>
 117 |     | <span class='neutral'></span>
 118 |     | <span class='unexecuted'>        uint256 initialBalance = credit.balanceOf(projectOwner, uint256(projectId));</span>
 119 |     | <span class='neutral'></span>
 120 |     | <span class='neutral'>        // 2. Create a new verification request</span>
 121 |     | <span class='unexecuted'>        vm.prank(projectOwner);</span>
 122 |     | <span class='unexecuted'>        bytes32 requestId = manager.requestVerification(projectId);</span>
 123 |     | <span class='neutral'></span>
 124 |     | <span class='neutral'>        // 3. Prepare oracle data for updating metadata only</span>
 125 |     | <span class='unexecuted'>        uint256 creditAmount = 0; // No new credits</span>
 126 |     | <span class='unexecuted'>        string memory metadataURI = &quot;ipfs://updated-verification.json&quot;;</span>
 127 |     | <span class='unexecuted'>        bool updateMetadataOnly = true;</span>
 128 |     | <span class='unexecuted'>        bytes32 signature = keccak256(abi.encodePacked(&quot;test-signature-2&quot;));</span>
 129 |     | <span class='neutral'></span>
 130 |     | <span class='neutral'>        // 4. Encode the data</span>
 131 |     | <span class='unexecuted'>        bytes memory data = abi.encode(creditAmount, updateMetadataOnly, signature, metadataURI);</span>
 132 |     | <span class='neutral'></span>
 133 |     | <span class='neutral'>        // 5. Oracle fulfills the verification</span>
 134 |     | <span class='unexecuted'>        vm.prank(oracle);</span>
 135 |     | <span class='unexecuted'>        manager.fulfillVerification(requestId, data);</span>
 136 |     | <span class='neutral'></span>
 137 |     | <span class='neutral'>        // 6. Check that only metadata was updated (balance unchanged)</span>
 138 |     | <span class='unexecuted'>        assertEq(credit.balanceOf(projectOwner, uint256(projectId)), initialBalance);</span>
 139 |     | <span class='unexecuted'>        assertEq(credit.uri(uint256(projectId)), metadataURI);</span>
 140 |     | <span class='neutral'>    }</span>
 141 |     | <span class='neutral'></span>
 142 |     | <span class='unexecuted'>    function test_OracleFulfillment_RecordsUriHistory() public {</span>
 143 |     | <span class='unexecuted'>        uint256 tokenId = uint256(projectId);</span>
 144 |     | <span class='neutral'></span>
 145 |     | <span class='neutral'>        // --- 1. First fulfillment (mints and sets initial URI) ---</span>
 146 |     | <span class='unexecuted'>        string memory uri1 = &quot;ipfs://report-v1.json&quot;;</span>
 147 |     | <span class='unexecuted'>        bytes memory data1 = abi.encode(uint256(100), false, bytes32(0), uri1);</span>
 148 |     | <span class='neutral'>        // Request by projectOwner</span>
 149 |     | <span class='unexecuted'>        vm.prank(projectOwner);</span>
 150 |     | <span class='unexecuted'>        bytes32 requestId1 = manager.requestVerification(projectId);</span>
 151 |     | <span class='neutral'>        // Fulfill by oracle</span>
 152 |     | <span class='unexecuted'>        vm.prank(oracle);</span>
 153 |     | <span class='unexecuted'>        manager.fulfillVerification(requestId1, data1);</span>
 154 |     | <span class='neutral'></span>
 155 |     | <span class='neutral'>        // --- 2. Second fulfillment (updates metadata only) ---</span>
 156 |     | <span class='unexecuted'>        string memory uri2 = &quot;ipfs://report-v2.json&quot;;</span>
 157 |     | <span class='unexecuted'>        bytes memory data2 = abi.encode(uint256(0), true, bytes32(0), uri2);</span>
 158 |     | <span class='neutral'>        // Request by projectOwner</span>
 159 |     | <span class='unexecuted'>        vm.prank(projectOwner);</span>
 160 |     | <span class='unexecuted'>        bytes32 requestId2 = manager.requestVerification(projectId);</span>
 161 |     | <span class='neutral'>        // Fulfill by oracle</span>
 162 |     | <span class='unexecuted'>        vm.prank(oracle);</span>
 163 |     | <span class='unexecuted'>        manager.fulfillVerification(requestId2, data2);</span>
 164 |     | <span class='neutral'></span>
 165 |     | <span class='neutral'>        // --- 3. Third fulfillment (mints more credits and updates URI again) ---</span>
 166 |     | <span class='unexecuted'>        string memory uri3 = &quot;ipfs://report-v3.json&quot;;</span>
 167 |     | <span class='unexecuted'>        bytes memory data3 = abi.encode(uint256(50), false, bytes32(0), uri3);</span>
 168 |     | <span class='neutral'>        // Request by projectOwner</span>
 169 |     | <span class='unexecuted'>        vm.prank(projectOwner);</span>
 170 |     | <span class='unexecuted'>        bytes32 requestId3 = manager.requestVerification(projectId);</span>
 171 |     | <span class='neutral'>        // Fulfill by oracle</span>
 172 |     | <span class='unexecuted'>        vm.prank(oracle);</span>
 173 |     | <span class='unexecuted'>        manager.fulfillVerification(requestId3, data3);</span>
 174 |     | <span class='neutral'></span>
 175 |     | <span class='neutral'>        // --- 4. Verify the entire URI history ---</span>
 176 |     | <span class='unexecuted'>        string[] memory history = credit.getTokenURIHistory(tokenId);</span>
 177 |     | <span class='neutral'></span>
 178 |     | <span class='unexecuted'>        assertEq(history.length, 3, &quot;URI history should have 3 entries&quot;);</span>
 179 |     | <span class='unexecuted'>        assertEq(history[0], uri1, &quot;First URI in history is incorrect&quot;);</span>
 180 |     | <span class='unexecuted'>        assertEq(history[1], uri2, &quot;Second URI in history is incorrect&quot;);</span>
 181 |     | <span class='unexecuted'>        assertEq(history[2], uri3, &quot;Third URI in history is incorrect&quot;);</span>
 182 |     | <span class='neutral'></span>
 183 |     | <span class='neutral'>        // Also check that the current URI is the latest one</span>
 184 |     | <span class='unexecuted'>        assertEq(credit.uri(tokenId), uri3, &quot;Current URI should be the latest one&quot;);</span>
 185 |     | <span class='unexecuted'>        assertEq(credit.balanceOf(projectOwner, tokenId), 150, &quot;Final balance should be sum of mints&quot;);</span>
 186 |     | <span class='neutral'>    }</span>
 187 |     | <span class='neutral'></span>
 188 |     | <span class='neutral'>    /* ---------- Admin Functions ---------- */</span>
 189 |     | <span class='neutral'></span>
 190 |     | <span class='unexecuted'>    function test_AdminSubmitVerification() public {</span>
 191 |     | <span class='neutral'>        // Admin can directly set verification without oracle</span>
 192 |     | <span class='unexecuted'>        vm.prank(admin);</span>
 193 |     | <span class='unexecuted'>        manager.adminSubmitVerification(projectId, 50, &quot;ipfs://admin-set.json&quot;, false);</span>
 194 |     | <span class='neutral'></span>
 195 |     | <span class='neutral'>        // Check credits were minted</span>
 196 |     | <span class='unexecuted'>        assertEq(credit.balanceOf(projectOwner, uint256(projectId)), 50);</span>
 197 |     | <span class='unexecuted'>        assertEq(credit.uri(uint256(projectId)), &quot;ipfs://admin-set.json&quot;);</span>
 198 |     | <span class='neutral'>    }</span>
 199 |     | <span class='neutral'></span>
 200 |     | <span class='neutral'>    /* ---------- Error Cases ---------- */</span>
 201 |     | <span class='neutral'></span>
 202 |     | <span class='unexecuted'>    function test_RequestVerification_RequiresActiveProject() public {</span>
 203 |     | <span class='neutral'>        // Create an inactive project</span>
 204 |     | <span class='unexecuted'>        bytes32 inactiveId = keccak256(&quot;Inactive Project&quot;);</span>
 205 |     | <span class='unexecuted'>        vm.prank(projectOwner);</span>
 206 |     | <span class='unexecuted'>        registry.registerProject(inactiveId, &quot;ipfs://inactive.json&quot;);</span>
 207 |     | <span class='neutral'>        // Note: We don&#39;t activate it</span>
 208 |     | <span class='neutral'></span>
 209 |     | <span class='neutral'>        // Attempt to request verification should fail</span>
 210 |     | <span class='unexecuted'>        vm.prank(projectOwner);</span>
 211 |     | <span class='unexecuted'>        vm.expectRevert(DMRVManager__ProjectNotActive.selector);</span>
 212 |     | <span class='unexecuted'>        manager.requestVerification(inactiveId);</span>
 213 |     | <span class='neutral'>    }</span>
 214 |     | <span class='neutral'></span>
 215 |     | <span class='unexecuted'>    function test_FulfillVerification_OnlyOracle() public {</span>
 216 |     | <span class='neutral'>        // 1. Create a request</span>
 217 |     | <span class='unexecuted'>        vm.prank(projectOwner);</span>
 218 |     | <span class='unexecuted'>        bytes32 requestId = manager.requestVerification(projectId);</span>
 219 |     | <span class='neutral'></span>
 220 |     | <span class='neutral'>        // 2. Prepare some data</span>
 221 |     | <span class='unexecuted'>        bytes memory data = abi.encode(uint256(100), false, bytes32(0), &quot;ipfs://test.json&quot;);</span>
 222 |     | <span class='neutral'></span>
 223 |     | <span class='neutral'>        // 3. Attempt to fulfill from non-oracle account</span>
 224 |     | <span class='unexecuted'>        vm.prank(projectOwner);</span>
 225 |     | <span class='unexecuted'>        vm.expectRevert(); // Will revert due to AccessControl</span>
 226 |     | <span class='neutral'>        manager.fulfillVerification(requestId, data);</span>
 227 |     | <span class='neutral'>    }</span>
 228 |     | <span class='neutral'></span>
 229 |     | <span class='unexecuted'>    function test_FulfillVerification_CannotFulfillTwice() public {</span>
 230 |     | <span class='neutral'>        // 1. Create a request</span>
 231 |     | <span class='unexecuted'>        vm.prank(projectOwner);</span>
 232 |     | <span class='unexecuted'>        bytes32 requestId = manager.requestVerification(projectId);</span>
 233 |     | <span class='neutral'></span>
 234 |     | <span class='neutral'>        // 2. Prepare some data</span>
 235 |     | <span class='unexecuted'>        bytes memory data = abi.encode(uint256(100), false, bytes32(0), &quot;ipfs://test.json&quot;);</span>
 236 |     | <span class='neutral'></span>
 237 |     | <span class='neutral'>        // 3. Oracle fulfills the verification</span>
 238 |     | <span class='unexecuted'>        vm.prank(oracle);</span>
 239 |     | <span class='unexecuted'>        manager.fulfillVerification(requestId, data);</span>
 240 |     | <span class='neutral'></span>
 241 |     | <span class='neutral'>        // 4. Try to fulfill again should fail</span>
 242 |     | <span class='unexecuted'>        vm.prank(oracle);</span>
 243 |     | <span class='unexecuted'>        vm.expectRevert(DMRVManager__RequestAlreadyFulfilled.selector);</span>
 244 |     | <span class='unexecuted'>        manager.fulfillVerification(requestId, data);</span>
 245 |     | <span class='neutral'>    }</span>
 246 |     | <span class='neutral'></span>
 247 |     | <span class='neutral'>    /* ---------- Pausable Tests ---------- */</span>
 248 |     | <span class='neutral'></span>
 249 |     | <span class='unexecuted'>    function test_PauseAndUnpause() public {</span>
 250 |     | <span class='unexecuted'>        bytes32 pauserRole = manager.PAUSER_ROLE();</span>
 251 |     | <span class='neutral'></span>
 252 |     | <span class='unexecuted'>        vm.startPrank(admin);</span>
 253 |     | <span class='neutral'>        // Admin has pauser role by default from setUp</span>
 254 |     | <span class='unexecuted'>        manager.pause();</span>
 255 |     | <span class='unexecuted'>        assertTrue(manager.paused());</span>
 256 |     | <span class='unexecuted'>        manager.unpause();</span>
 257 |     | <span class='unexecuted'>        assertFalse(manager.paused());</span>
 258 |     | <span class='unexecuted'>        vm.stopPrank();</span>
 259 |     | <span class='neutral'></span>
 260 |     | <span class='neutral'>        // Non-pauser cannot pause</span>
 261 |     | <span class='unexecuted'>        vm.prank(projectOwner);</span>
 262 |     | <span class='unexecuted'>        vm.expectRevert(</span>
 263 |     | <span class='unexecuted'>            abi.encodeWithSelector(</span>
 264 |     | <span class='unexecuted'>                bytes4(keccak256(&quot;AccessControlUnauthorizedAccount(address,bytes32)&quot;)), projectOwner, pauserRole</span>
 265 |     | <span class='neutral'>            )</span>
 266 |     | <span class='neutral'>        );</span>
 267 |     | <span class='unexecuted'>        manager.pause();</span>
 268 |     | <span class='neutral'>    }</span>
 269 |     | <span class='neutral'></span>
 270 |     | <span class='unexecuted'>    function test_RevertsWhenPaused() public {</span>
 271 |     | <span class='unexecuted'>        vm.prank(admin);</span>
 272 |     | <span class='unexecuted'>        manager.pause();</span>
 273 |     | <span class='neutral'></span>
 274 |     | <span class='unexecuted'>        bytes4 expectedRevert = bytes4(keccak256(&quot;EnforcedPause()&quot;));</span>
 275 |     | <span class='neutral'></span>
 276 |     | <span class='unexecuted'>        vm.prank(projectOwner);</span>
 277 |     | <span class='unexecuted'>        vm.expectRevert(expectedRevert);</span>
 278 |     | <span class='unexecuted'>        manager.requestVerification(projectId);</span>
 279 |     | <span class='neutral'></span>
 280 |     | <span class='unexecuted'>        vm.prank(oracle);</span>
 281 |     | <span class='unexecuted'>        bytes memory data = abi.encode(1, false, bytes32(0), &quot;ipfs://fail.json&quot;);</span>
 282 |     | <span class='unexecuted'>        vm.expectRevert(expectedRevert);</span>
 283 |     | <span class='unexecuted'>        manager.fulfillVerification(bytes32(0), data);</span>
 284 |     | <span class='neutral'></span>
 285 |     | <span class='unexecuted'>        vm.prank(admin);</span>
 286 |     | <span class='unexecuted'>        vm.expectRevert(expectedRevert);</span>
 287 |     | <span class='unexecuted'>        manager.adminSubmitVerification(projectId, 1, &quot;ipfs://fail.json&quot;, false);</span>
 288 |     | <span class='neutral'>    }</span>
 289 |     | <span class='neutral'>}</span>
 290 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/phantom/Documents/azemora/azemora-contracts/test/dynamicImpactCredit/DynamicImpactCredit.complex.t.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'>pragma solidity ^0.8.20;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>import &quot;forge-std/Test.sol&quot;;</span>
   5 |     | <span class='neutral'>import &quot;../dynamicImpactCredit/DynamicImpactCredit.t.sol&quot;;</span>
   6 |     | <span class='neutral'>import &quot;../../src/core/ProjectRegistry.sol&quot;;</span>
   7 |     | <span class='neutral'>import &quot;../../src/core/DynamicImpactCredit.sol&quot;;</span>
   8 |     | <span class='neutral'>import &quot;../../src/core/dMRVManager.sol&quot;;</span>
   9 |     | <span class='neutral'>import &quot;@openzeppelin/contracts/proxy/ERC1967/ERC1967Proxy.sol&quot;;</span>
  10 |     | <span class='neutral'>import &quot;@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol&quot;;</span>
  11 |     | <span class='neutral'></span>
  12 |     | <span class='neutral'>// A V2 contract for testing that includes a new function and a new event</span>
  13 |     | <span class='unexecuted'>contract DynamicImpactCreditExtendedV2 is DynamicImpactCredit {</span>
  14 |     | <span class='unexecuted'>    uint256 public constant VERSION = 2;</span>
  15 |     | <span class='neutral'></span>
  16 |     | <span class='neutral'>    event RetiredWithReason(address indexed retirer, uint256 indexed tokenId, uint256 amount, string reason);</span>
  17 |     | <span class='neutral'></span>
  18 |     | <span class='neutral'>    struct RetirementInfo {</span>
  19 |     | <span class='neutral'>        uint256 timestamp;</span>
  20 |     | <span class='neutral'>        uint256 totalRetired;</span>
  21 |     | <span class='neutral'>    }</span>
  22 |     | <span class='neutral'></span>
  23 |     | <span class='unexecuted'>    mapping(uint256 =&gt; mapping(address =&gt; RetirementInfo)) public retirementInfo;</span>
  24 |     | <span class='neutral'></span>
  25 |     | <span class='unexecuted'>    constructor(address registry) DynamicImpactCredit(registry) {}</span>
  26 |     | <span class='neutral'></span>
  27 |     | <span class='unexecuted'>    function retireWithReason(address from, bytes32 id, uint256 amount, string calldata reason) external {</span>
  28 |     | <span class='unexecuted'>        super.retire(from, id, amount);</span>
  29 |     | <span class='unexecuted'>        uint256 tokenId = uint256(id);</span>
  30 |     | <span class='unexecuted'>        RetirementInfo storage info = retirementInfo[tokenId][from];</span>
  31 |     | <span class='unexecuted'>        info.timestamp = block.timestamp;</span>
  32 |     | <span class='unexecuted'>        info.totalRetired += amount;</span>
  33 |     | <span class='unexecuted'>        emit RetiredWithReason(from, tokenId, amount, reason);</span>
  34 |     | <span class='neutral'>    }</span>
  35 |     | <span class='neutral'></span>
  36 |     | <span class='unexecuted'>    function getRetirementInfo(bytes32 id, address user) external view returns (uint256, uint256) {</span>
  37 |     | <span class='neutral'>        uint256 tokenId = uint256(id);</span>
  38 |     | <span class='unexecuted'>        RetirementInfo storage info = retirementInfo[tokenId][user];</span>
  39 |     | <span class='unexecuted'>        return (info.timestamp, info.totalRetired);</span>
  40 |     | <span class='neutral'>    }</span>
  41 |     | <span class='neutral'>}</span>
  42 |     | <span class='neutral'></span>
  43 |     | <span class='unexecuted'>contract DynamicImpactCreditComplexTest is Test {</span>
  44 |     | <span class='neutral'>    DynamicImpactCredit credit;</span>
  45 |     | <span class='neutral'>    ProjectRegistry registry;</span>
  46 |     | <span class='unexecuted'>    address admin = address(0xA11CE);</span>
  47 |     | <span class='unexecuted'>    address dmrvManager = address(0xB01D);</span>
  48 |     | <span class='unexecuted'>    address verifier = address(0xC1E4);</span>
  49 |     | <span class='neutral'></span>
  50 |     | <span class='neutral'>    // Create multiple user addresses</span>
  51 |     | <span class='unexecuted'>    address user1 = address(0xCAFE);</span>
  52 |     | <span class='unexecuted'>    address user2 = address(0xBEEF);</span>
  53 |     | <span class='unexecuted'>    address user3 = address(0xFACE);</span>
  54 |     | <span class='neutral'></span>
  55 |     | <span class='neutral'>    // Project data for realistic simulation</span>
  56 |     | <span class='neutral'>    struct Project {</span>
  57 |     | <span class='neutral'>        bytes32 id;</span>
  58 |     | <span class='neutral'>        string name;</span>
  59 |     | <span class='neutral'>        string baseURI;</span>
  60 |     | <span class='neutral'>        uint256 initialCredits;</span>
  61 |     | <span class='neutral'>    }</span>
  62 |     | <span class='neutral'></span>
  63 |     | <span class='neutral'>    Project[] projects;</span>
  64 |     | <span class='neutral'></span>
  65 |     | <span class='unexecuted'>    function setUp() public {</span>
  66 |     | <span class='unexecuted'>        vm.startPrank(admin);</span>
  67 |     | <span class='neutral'>        // Deploy Registry</span>
  68 |     | <span class='unexecuted'>        ProjectRegistry registryImpl = new ProjectRegistry();</span>
  69 |     | <span class='unexecuted'>        registry = ProjectRegistry(</span>
  70 |     | <span class='unexecuted'>            address(new ERC1967Proxy(address(registryImpl), abi.encodeCall(ProjectRegistry.initialize, ())))</span>
  71 |     | <span class='neutral'>        );</span>
  72 |     | <span class='unexecuted'>        registry.grantRole(registry.VERIFIER_ROLE(), verifier);</span>
  73 |     | <span class='neutral'></span>
  74 |     | <span class='neutral'>        // Deploy Credit Contract</span>
  75 |     | <span class='unexecuted'>        DynamicImpactCredit impl = new DynamicImpactCredit(address(registry));</span>
  76 |     | <span class='unexecuted'>        credit = DynamicImpactCredit(</span>
  77 |     | <span class='neutral'>            address(</span>
  78 |     | <span class='unexecuted'>                new ERC1967Proxy(</span>
  79 |     | <span class='unexecuted'>                    address(impl), abi.encodeCall(DynamicImpactCredit.initialize, (&quot;ipfs://contract-metadata.json&quot;))</span>
  80 |     | <span class='neutral'>                )</span>
  81 |     | <span class='neutral'>            )</span>
  82 |     | <span class='neutral'>        );</span>
  83 |     | <span class='neutral'></span>
  84 |     | <span class='unexecuted'>        credit.grantRole(credit.DMRV_MANAGER_ROLE(), dmrvManager);</span>
  85 |     | <span class='unexecuted'>        credit.grantRole(credit.METADATA_UPDATER_ROLE(), admin);</span>
  86 |     | <span class='unexecuted'>        vm.stopPrank();</span>
  87 |     | <span class='neutral'></span>
  88 |     | <span class='neutral'>        // Set up some realistic projects</span>
  89 |     | <span class='unexecuted'>        projects.push(</span>
  90 |     | <span class='unexecuted'>            Project({</span>
  91 |     | <span class='unexecuted'>                id: bytes32(uint256(101)),</span>
  92 |     | <span class='neutral'>                name: &quot;Reforestation Project Alpha&quot;,</span>
  93 |     | <span class='neutral'>                baseURI: &quot;ipfs://reforest-alpha/metadata-&quot;,</span>
  94 |     | <span class='unexecuted'>                initialCredits: 10000</span>
  95 |     | <span class='neutral'>            })</span>
  96 |     | <span class='neutral'>        );</span>
  97 |     | <span class='neutral'></span>
  98 |     | <span class='unexecuted'>        projects.push(</span>
  99 |     | <span class='unexecuted'>            Project({</span>
 100 |     | <span class='unexecuted'>                id: bytes32(uint256(202)),</span>
 101 |     | <span class='neutral'>                name: &quot;Solar Farm Beta&quot;,</span>
 102 |     | <span class='neutral'>                baseURI: &quot;ipfs://solar-beta/metadata-&quot;,</span>
 103 |     | <span class='unexecuted'>                initialCredits: 5000</span>
 104 |     | <span class='neutral'>            })</span>
 105 |     | <span class='neutral'>        );</span>
 106 |     | <span class='neutral'></span>
 107 |     | <span class='unexecuted'>        projects.push(</span>
 108 |     | <span class='unexecuted'>            Project({</span>
 109 |     | <span class='unexecuted'>                id: bytes32(uint256(303)),</span>
 110 |     | <span class='neutral'>                name: &quot;Methane Capture Gamma&quot;,</span>
 111 |     | <span class='neutral'>                baseURI: &quot;ipfs://methane-gamma/metadata-&quot;,</span>
 112 |     | <span class='unexecuted'>                initialCredits: 7500</span>
 113 |     | <span class='neutral'>            })</span>
 114 |     | <span class='neutral'>        );</span>
 115 |     | <span class='neutral'>    }</span>
 116 |     | <span class='neutral'></span>
 117 |     | <span class='neutral'>    // Complex test: Full lifecycle simulation with dMRV updates</span>
 118 |     | <span class='unexecuted'>    function testComplex_FullLifecycle() public {</span>
 119 |     | <span class='neutral'>        // STEP 1: Initial project registrations and credit minting</span>
 120 |     | <span class='neutral'>        // Register and activate projects</span>
 121 |     | <span class='unexecuted'>        for (uint256 i = 0; i &lt; projects.length; i++) {</span>
 122 |     | <span class='unexecuted'>            vm.prank(user1); // Owner registers</span>
 123 |     | <span class='unexecuted'>            registry.registerProject(projects[i].id, &quot;ipfs://project-meta&quot;);</span>
 124 |     | <span class='unexecuted'>            vm.prank(verifier); // Verifier activates</span>
 125 |     | <span class='unexecuted'>            registry.setProjectStatus(projects[i].id, ProjectRegistry.ProjectStatus.Active);</span>
 126 |     | <span class='neutral'>        }</span>
 127 |     | <span class='neutral'></span>
 128 |     | <span class='unexecuted'>        vm.startPrank(dmrvManager);</span>
 129 |     | <span class='neutral'></span>
 130 |     | <span class='unexecuted'>        for (uint256 i = 0; i &lt; projects.length; i++) {</span>
 131 |     | <span class='neutral'>            // Mint initial credits to user1</span>
 132 |     | <span class='unexecuted'>            credit.mintCredits(</span>
 133 |     | <span class='unexecuted'>                user1,</span>
 134 |     | <span class='unexecuted'>                projects[i].id,</span>
 135 |     | <span class='unexecuted'>                projects[i].initialCredits,</span>
 136 |     | <span class='unexecuted'>                string(abi.encodePacked(projects[i].baseURI, &quot;v1.json&quot;))</span>
 137 |     | <span class='neutral'>            );</span>
 138 |     | <span class='neutral'>        }</span>
 139 |     | <span class='neutral'></span>
 140 |     | <span class='unexecuted'>        vm.stopPrank();</span>
 141 |     | <span class='neutral'></span>
 142 |     | <span class='neutral'>        // STEP 2: User1 transfers some credits to other users</span>
 143 |     | <span class='unexecuted'>        vm.startPrank(user1);</span>
 144 |     | <span class='neutral'></span>
 145 |     | <span class='neutral'>        // Transfer half of project 0 credits to user2</span>
 146 |     | <span class='unexecuted'>        uint256 transferAmount1 = projects[0].initialCredits / 2;</span>
 147 |     | <span class='unexecuted'>        credit.safeTransferFrom(user1, user2, uint256(projects[0].id), transferAmount1, &quot;&quot;);</span>
 148 |     | <span class='neutral'></span>
 149 |     | <span class='neutral'>        // Transfer 1/3 of project 1 credits to user3</span>
 150 |     | <span class='unexecuted'>        uint256 transferAmount2 = projects[1].initialCredits / 3;</span>
 151 |     | <span class='unexecuted'>        credit.safeTransferFrom(user1, user3, uint256(projects[1].id), transferAmount2, &quot;&quot;);</span>
 152 |     | <span class='neutral'></span>
 153 |     | <span class='unexecuted'>        vm.stopPrank();</span>
 154 |     | <span class='neutral'></span>
 155 |     | <span class='neutral'>        // Verify balances after transfers</span>
 156 |     | <span class='unexecuted'>        assertEq(credit.balanceOf(user1, uint256(projects[0].id)), projects[0].initialCredits - transferAmount1);</span>
 157 |     | <span class='unexecuted'>        assertEq(credit.balanceOf(user2, uint256(projects[0].id)), transferAmount1);</span>
 158 |     | <span class='unexecuted'>        assertEq(credit.balanceOf(user1, uint256(projects[1].id)), projects[1].initialCredits - transferAmount2);</span>
 159 |     | <span class='unexecuted'>        assertEq(credit.balanceOf(user3, uint256(projects[1].id)), transferAmount2);</span>
 160 |     | <span class='neutral'></span>
 161 |     | <span class='neutral'>        // STEP 3: Simulate dMRV update - metadata is updated to reflect new measurement</span>
 162 |     | <span class='unexecuted'>        vm.startPrank(admin);</span>
 163 |     | <span class='neutral'></span>
 164 |     | <span class='neutral'>        // Update metadata for project 0 to reflect new verification data</span>
 165 |     | <span class='unexecuted'>        string memory newURI = string(abi.encodePacked(projects[0].baseURI, &quot;v2-verified.json&quot;));</span>
 166 |     | <span class='unexecuted'>        credit.setTokenURI(projects[0].id, newURI);</span>
 167 |     | <span class='neutral'></span>
 168 |     | <span class='unexecuted'>        vm.stopPrank();</span>
 169 |     | <span class='neutral'></span>
 170 |     | <span class='neutral'>        // Verify metadata was updated</span>
 171 |     | <span class='unexecuted'>        assertEq(credit.uri(uint256(projects[0].id)), newURI);</span>
 172 |     | <span class='unexecuted'>        string[] memory history = credit.getTokenURIHistory(uint256(projects[0].id));</span>
 173 |     | <span class='unexecuted'>        assertEq(history.length, 2);</span>
 174 |     | <span class='unexecuted'>        assertEq(history[0], string(abi.encodePacked(projects[0].baseURI, &quot;v1.json&quot;)));</span>
 175 |     | <span class='unexecuted'>        assertEq(history[1], newURI);</span>
 176 |     | <span class='neutral'></span>
 177 |     | <span class='neutral'>        // STEP 4: Users retire some credits</span>
 178 |     | <span class='unexecuted'>        vm.prank(user2);</span>
 179 |     | <span class='unexecuted'>        uint256 retireAmount1 = transferAmount1 / 2;</span>
 180 |     | <span class='unexecuted'>        credit.retire(user2, projects[0].id, retireAmount1);</span>
 181 |     | <span class='neutral'></span>
 182 |     | <span class='unexecuted'>        vm.prank(user3);</span>
 183 |     | <span class='unexecuted'>        uint256 retireAmount2 = transferAmount2;</span>
 184 |     | <span class='unexecuted'>        credit.retire(user3, projects[1].id, retireAmount2);</span>
 185 |     | <span class='neutral'></span>
 186 |     | <span class='neutral'>        // Verify balances after retirement</span>
 187 |     | <span class='unexecuted'>        assertEq(credit.balanceOf(user2, uint256(projects[0].id)), transferAmount1 - retireAmount1);</span>
 188 |     | <span class='unexecuted'>        assertEq(credit.balanceOf(user3, uint256(projects[1].id)), 0);</span>
 189 |     | <span class='neutral'></span>
 190 |     | <span class='neutral'>        // STEP 5: Upgrade to V2 with enhanced features</span>
 191 |     | <span class='unexecuted'>        DynamicImpactCreditExtendedV2 v2 = new DynamicImpactCreditExtendedV2(address(registry));</span>
 192 |     | <span class='neutral'></span>
 193 |     | <span class='unexecuted'>        vm.prank(admin);</span>
 194 |     | <span class='unexecuted'>        IUUPS(address(credit)).upgradeToAndCall(address(v2), &quot;&quot;);</span>
 195 |     | <span class='neutral'></span>
 196 |     | <span class='neutral'>        // Cast to V2</span>
 197 |     | <span class='unexecuted'>        DynamicImpactCreditExtendedV2 creditV2 = DynamicImpactCreditExtendedV2(address(credit));</span>
 198 |     | <span class='neutral'></span>
 199 |     | <span class='neutral'>        // Verify upgrade was successful</span>
 200 |     | <span class='unexecuted'>        assertEq(creditV2.VERSION(), 2);</span>
 201 |     | <span class='neutral'></span>
 202 |     | <span class='neutral'>        // STEP 6: Use new V2 features</span>
 203 |     | <span class='unexecuted'>        vm.prank(user1);</span>
 204 |     | <span class='unexecuted'>        uint256 retireAmount3 = 100;</span>
 205 |     | <span class='unexecuted'>        creditV2.retireWithReason(user1, projects[2].id, retireAmount3, &quot;Test reason&quot;);</span>
 206 |     | <span class='neutral'></span>
 207 |     | <span class='neutral'>        // Verify V2 specific data</span>
 208 |     | <span class='unexecuted'>        (uint256 timestamp, uint256 userTotal) = creditV2.getRetirementInfo(projects[2].id, user1);</span>
 209 |     | <span class='unexecuted'>        assertEq(timestamp, block.timestamp);</span>
 210 |     | <span class='unexecuted'>        assertEq(userTotal, retireAmount3);</span>
 211 |     | <span class='neutral'></span>
 212 |     | <span class='neutral'>        // Confirm old balances are preserved</span>
 213 |     | <span class='unexecuted'>        assertEq(creditV2.balanceOf(user1, uint256(projects[0].id)), projects[0].initialCredits - transferAmount1);</span>
 214 |     | <span class='unexecuted'>        assertEq(creditV2.balanceOf(user2, uint256(projects[0].id)), transferAmount1 - retireAmount1);</span>
 215 |     | <span class='neutral'></span>
 216 |     | <span class='neutral'>        // STEP 7: Mint additional credits with the new implementation</span>
 217 |     | <span class='unexecuted'>        bytes32 newProjectId = bytes32(uint256(404));</span>
 218 |     | <span class='unexecuted'>        vm.prank(user1);</span>
 219 |     | <span class='unexecuted'>        registry.registerProject(newProjectId, &quot;new.json&quot;);</span>
 220 |     | <span class='unexecuted'>        vm.prank(verifier);</span>
 221 |     | <span class='unexecuted'>        registry.setProjectStatus(newProjectId, ProjectRegistry.ProjectStatus.Active);</span>
 222 |     | <span class='neutral'></span>
 223 |     | <span class='unexecuted'>        vm.prank(dmrvManager);</span>
 224 |     | <span class='unexecuted'>        creditV2.mintCredits(user1, newProjectId, 1000, &quot;ipfs://new-project/metadata.json&quot;);</span>
 225 |     | <span class='neutral'></span>
 226 |     | <span class='unexecuted'>        assertEq(creditV2.balanceOf(user1, uint256(newProjectId)), 1000);</span>
 227 |     | <span class='neutral'>    }</span>
 228 |     | <span class='neutral'></span>
 229 |     | <span class='neutral'>    // Complex test: Batch operations and approvals</span>
 230 |     | <span class='unexecuted'>    function testComplex_BatchOperationsAndApprovals() public {</span>
 231 |     | <span class='neutral'>        // STEP 1: Mint multiple token types in a batch</span>
 232 |     | <span class='unexecuted'>        bytes32[] memory ids = new bytes32[](3);</span>
 233 |     | <span class='unexecuted'>        uint256[] memory amounts = new uint256[](3);</span>
 234 |     | <span class='unexecuted'>        string[] memory uris = new string[](3);</span>
 235 |     | <span class='neutral'></span>
 236 |     | <span class='unexecuted'>        for (uint256 i = 0; i &lt; 3; i++) {</span>
 237 |     | <span class='unexecuted'>            ids[i] = projects[i].id;</span>
 238 |     | <span class='unexecuted'>            amounts[i] = projects[i].initialCredits;</span>
 239 |     | <span class='unexecuted'>            uris[i] = string(abi.encodePacked(projects[i].baseURI, &quot;v1.json&quot;));</span>
 240 |     | <span class='neutral'></span>
 241 |     | <span class='unexecuted'>            vm.prank(user1);</span>
 242 |     | <span class='unexecuted'>            registry.registerProject(ids[i], &quot;meta.json&quot;);</span>
 243 |     | <span class='unexecuted'>            vm.prank(verifier);</span>
 244 |     | <span class='unexecuted'>            registry.setProjectStatus(ids[i], ProjectRegistry.ProjectStatus.Active);</span>
 245 |     | <span class='neutral'>        }</span>
 246 |     | <span class='neutral'></span>
 247 |     | <span class='unexecuted'>        vm.prank(dmrvManager);</span>
 248 |     | <span class='unexecuted'>        credit.batchMintCredits(user1, ids, amounts, uris);</span>
 249 |     | <span class='neutral'></span>
 250 |     | <span class='neutral'>        // Verify all credits were minted</span>
 251 |     | <span class='unexecuted'>        for (uint256 i = 0; i &lt; 3; i++) {</span>
 252 |     | <span class='unexecuted'>            assertEq(credit.balanceOf(user1, uint256(ids[i])), amounts[i]);</span>
 253 |     | <span class='unexecuted'>            assertEq(credit.uri(uint256(ids[i])), uris[i]);</span>
 254 |     | <span class='neutral'>        }</span>
 255 |     | <span class='neutral'></span>
 256 |     | <span class='neutral'>        // STEP 2: User1 approves user2 to manage all tokens</span>
 257 |     | <span class='unexecuted'>        vm.prank(user1);</span>
 258 |     | <span class='unexecuted'>        credit.setApprovalForAll(user2, true);</span>
 259 |     | <span class='neutral'></span>
 260 |     | <span class='neutral'>        // STEP 3: User2 transfers from user1 to user3 using approval</span>
 261 |     | <span class='unexecuted'>        vm.startPrank(user2);</span>
 262 |     | <span class='neutral'></span>
 263 |     | <span class='neutral'>        // Transfer half of all projects from user1 to user3</span>
 264 |     | <span class='unexecuted'>        for (uint256 i = 0; i &lt; 3; i++) {</span>
 265 |     | <span class='unexecuted'>            uint256 transferAmount = amounts[i] / 2;</span>
 266 |     | <span class='unexecuted'>            credit.safeTransferFrom(user1, user3, uint256(ids[i]), transferAmount, &quot;&quot;);</span>
 267 |     | <span class='neutral'>        }</span>
 268 |     | <span class='neutral'></span>
 269 |     | <span class='neutral'>        // User2 also retires some credits on behalf of user1</span>
 270 |     | <span class='unexecuted'>        credit.retire(user1, ids[0], 100);</span>
 271 |     | <span class='neutral'></span>
 272 |     | <span class='unexecuted'>        vm.stopPrank();</span>
 273 |     | <span class='neutral'></span>
 274 |     | <span class='neutral'>        // Verify balances after transfers and retirement</span>
 275 |     | <span class='unexecuted'>        for (uint256 i = 0; i &lt; 3; i++) {</span>
 276 |     | <span class='unexecuted'>            uint256 expectedUser1Balance = amounts[i] / 2;</span>
 277 |     | <span class='unexecuted'>            if (i == 0) expectedUser1Balance -= 100; // Account for retirement</span>
 278 |     | <span class='neutral'></span>
 279 |     | <span class='unexecuted'>            assertEq(credit.balanceOf(user1, uint256(ids[i])), expectedUser1Balance);</span>
 280 |     | <span class='unexecuted'>            assertEq(credit.balanceOf(user3, uint256(ids[i])), amounts[i] / 2);</span>
 281 |     | <span class='neutral'>        }</span>
 282 |     | <span class='neutral'></span>
 283 |     | <span class='neutral'>        // STEP 4: User1 revokes approval</span>
 284 |     | <span class='unexecuted'>        vm.prank(user1);</span>
 285 |     | <span class='unexecuted'>        credit.setApprovalForAll(user2, false);</span>
 286 |     | <span class='neutral'></span>
 287 |     | <span class='neutral'>        // STEP 5: User2 attempts to transfer more tokens (should fail)</span>
 288 |     | <span class='unexecuted'>        vm.prank(user2);</span>
 289 |     | <span class='unexecuted'>        vm.expectRevert(</span>
 290 |     | <span class='unexecuted'>            abi.encodeWithSelector(bytes4(keccak256(&quot;ERC1155MissingApprovalForAll(address,address)&quot;)), user2, user1)</span>
 291 |     | <span class='neutral'>        );</span>
 292 |     | <span class='unexecuted'>        credit.safeTransferFrom(user1, user3, uint256(ids[0]), 10, &quot;&quot;);</span>
 293 |     | <span class='neutral'>    }</span>
 294 |     | <span class='neutral'>}</span>
 295 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/phantom/Documents/azemora/azemora-contracts/test/dynamicImpactCredit/DynamicImpactCredit.fuzz.t.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'>pragma solidity ^0.8.20;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>import &quot;forge-std/Test.sol&quot;;</span>
   5 |     | <span class='neutral'>import &quot;../../src/core/ProjectRegistry.sol&quot;;</span>
   6 |     | <span class='neutral'>import &quot;../../src/core/DynamicImpactCredit.sol&quot;;</span>
   7 |     | <span class='neutral'>import &quot;@openzeppelin/contracts/proxy/ERC1967/ERC1967Proxy.sol&quot;;</span>
   8 |     | <span class='neutral'></span>
   9 |     | <span class='unexecuted'>contract DynamicImpactCreditFuzzTest is Test {</span>
  10 |     | <span class='neutral'>    DynamicImpactCredit credit;</span>
  11 |     | <span class='neutral'>    ProjectRegistry registry;</span>
  12 |     | <span class='unexecuted'>    address admin = address(0xA11CE);</span>
  13 |     | <span class='unexecuted'>    address dmrvManager = address(0xB01D);</span>
  14 |     | <span class='unexecuted'>    address user = address(0xCAFE);</span>
  15 |     | <span class='unexecuted'>    address verifier = address(0xC1E4);</span>
  16 |     | <span class='neutral'></span>
  17 |     | <span class='unexecuted'>    function setUp() public {</span>
  18 |     | <span class='unexecuted'>        vm.startPrank(admin);</span>
  19 |     | <span class='neutral'>        // Deploy Registry</span>
  20 |     | <span class='unexecuted'>        ProjectRegistry registryImpl = new ProjectRegistry();</span>
  21 |     | <span class='unexecuted'>        registry = ProjectRegistry(</span>
  22 |     | <span class='unexecuted'>            address(new ERC1967Proxy(address(registryImpl), abi.encodeCall(ProjectRegistry.initialize, ())))</span>
  23 |     | <span class='neutral'>        );</span>
  24 |     | <span class='unexecuted'>        registry.grantRole(registry.VERIFIER_ROLE(), verifier);</span>
  25 |     | <span class='neutral'></span>
  26 |     | <span class='neutral'>        // Deploy Credit Contract</span>
  27 |     | <span class='unexecuted'>        DynamicImpactCredit impl = new DynamicImpactCredit(address(registry));</span>
  28 |     | <span class='neutral'></span>
  29 |     | <span class='unexecuted'>        bytes memory initData = abi.encodeCall(DynamicImpactCredit.initialize, (&quot;ipfs://contract-metadata.json&quot;));</span>
  30 |     | <span class='neutral'></span>
  31 |     | <span class='unexecuted'>        ERC1967Proxy proxy = new ERC1967Proxy(address(impl), initData);</span>
  32 |     | <span class='unexecuted'>        credit = DynamicImpactCredit(address(proxy));</span>
  33 |     | <span class='neutral'></span>
  34 |     | <span class='unexecuted'>        credit.grantRole(credit.DMRV_MANAGER_ROLE(), dmrvManager);</span>
  35 |     | <span class='unexecuted'>        credit.grantRole(credit.METADATA_UPDATER_ROLE(), admin);</span>
  36 |     | <span class='unexecuted'>        vm.stopPrank();</span>
  37 |     | <span class='neutral'>    }</span>
  38 |     | <span class='neutral'></span>
  39 |     | <span class='neutral'>    // Fuzz test: Batch mint with varying array lengths and contents</span>
  40 |     | <span class='unexecuted'>    function testFuzz_BatchMintArrays(uint8 arraySize, uint64 seed) public {</span>
  41 |     | <span class='neutral'>        // Bound arraySize to avoid extreme values</span>
  42 |     | <span class='unexecuted'>        arraySize = uint8(bound(arraySize, 1, 20));</span>
  43 |     | <span class='neutral'></span>
  44 |     | <span class='neutral'>        // Create arrays of proper length</span>
  45 |     | <span class='unexecuted'>        bytes32[] memory ids = new bytes32[](arraySize);</span>
  46 |     | <span class='unexecuted'>        uint256[] memory amounts = new uint256[](arraySize);</span>
  47 |     | <span class='unexecuted'>        string[] memory uris = new string[](arraySize);</span>
  48 |     | <span class='neutral'></span>
  49 |     | <span class='neutral'>        // Generate deterministic but varied data based on seed</span>
  50 |     | <span class='unexecuted'>        for (uint8 i = 0; i &lt; arraySize; i++) {</span>
  51 |     | <span class='neutral'>            // Ensure unique IDs by using the index</span>
  52 |     | <span class='unexecuted'>            ids[i] = keccak256(abi.encode(seed, i + 1));</span>
  53 |     | <span class='unexecuted'>            amounts[i] = uint256(keccak256(abi.encode(seed, &quot;amount&quot;, i))) % 1000 + 1;</span>
  54 |     | <span class='unexecuted'>            uris[i] = string(</span>
  55 |     | <span class='unexecuted'>                abi.encodePacked(&quot;ipfs://&quot;, vm.toString(uint256(keccak256(abi.encode(seed, &quot;uri&quot;, i))) % 1000000))</span>
  56 |     | <span class='neutral'>            );</span>
  57 |     | <span class='neutral'>            // Register and activate project</span>
  58 |     | <span class='unexecuted'>            vm.prank(user);</span>
  59 |     | <span class='unexecuted'>            registry.registerProject(ids[i], &quot;meta.json&quot;);</span>
  60 |     | <span class='unexecuted'>            vm.prank(verifier);</span>
  61 |     | <span class='unexecuted'>            registry.setProjectStatus(ids[i], ProjectRegistry.ProjectStatus.Active);</span>
  62 |     | <span class='neutral'>        }</span>
  63 |     | <span class='neutral'></span>
  64 |     | <span class='unexecuted'>        vm.prank(dmrvManager);</span>
  65 |     | <span class='unexecuted'>        credit.batchMintCredits(user, ids, amounts, uris);</span>
  66 |     | <span class='neutral'></span>
  67 |     | <span class='neutral'>        // Verify all tokens were minted with correct amounts and URIs</span>
  68 |     | <span class='unexecuted'>        for (uint8 i = 0; i &lt; arraySize; i++) {</span>
  69 |     | <span class='unexecuted'>            assertEq(credit.balanceOf(user, uint256(ids[i])), amounts[i], &quot;Balance mismatch for token ID&quot;);</span>
  70 |     | <span class='unexecuted'>            assertEq(credit.uri(uint256(ids[i])), uris[i], &quot;URI mismatch for token ID&quot;);</span>
  71 |     | <span class='neutral'>        }</span>
  72 |     | <span class='neutral'>    }</span>
  73 |     | <span class='neutral'></span>
  74 |     | <span class='neutral'>    // Fuzz test: Retirement with random amounts</span>
  75 |     | <span class='unexecuted'>    function testFuzz_Retire(uint256 seed, uint256 mintAmount, uint256 retireAmount) public {</span>
  76 |     | <span class='unexecuted'>        bytes32 projectId = keccak256(abi.encode(seed));</span>
  77 |     | <span class='neutral'>        // Constrain values to reasonable ranges</span>
  78 |     | <span class='unexecuted'>        mintAmount = bound(mintAmount, 1, 1000000);</span>
  79 |     | <span class='unexecuted'>        retireAmount = bound(retireAmount, 1, mintAmount);</span>
  80 |     | <span class='neutral'></span>
  81 |     | <span class='neutral'>        // Register and activate project</span>
  82 |     | <span class='unexecuted'>        vm.prank(user);</span>
  83 |     | <span class='unexecuted'>        registry.registerProject(projectId, &quot;meta.json&quot;);</span>
  84 |     | <span class='unexecuted'>        vm.prank(verifier);</span>
  85 |     | <span class='unexecuted'>        registry.setProjectStatus(projectId, ProjectRegistry.ProjectStatus.Active);</span>
  86 |     | <span class='neutral'></span>
  87 |     | <span class='neutral'>        // Mint the tokens</span>
  88 |     | <span class='unexecuted'>        vm.prank(dmrvManager);</span>
  89 |     | <span class='unexecuted'>        credit.mintCredits(user, projectId, mintAmount, string(abi.encodePacked(&quot;ipfs://token&quot;, vm.toString(seed))));</span>
  90 |     | <span class='neutral'></span>
  91 |     | <span class='neutral'>        // Retire some tokens</span>
  92 |     | <span class='unexecuted'>        vm.prank(user);</span>
  93 |     | <span class='unexecuted'>        credit.retire(user, projectId, retireAmount);</span>
  94 |     | <span class='neutral'></span>
  95 |     | <span class='neutral'>        // Verify the remaining balance</span>
  96 |     | <span class='unexecuted'>        assertEq(credit.balanceOf(user, uint256(projectId)), mintAmount - retireAmount);</span>
  97 |     | <span class='neutral'>    }</span>
  98 |     | <span class='neutral'></span>
  99 |     | <span class='neutral'>    // Fuzz test: URI updates with random strings</span>
 100 |     | <span class='unexecuted'>    function testFuzz_URIUpdates(uint256 seed, string calldata initialURI, string calldata updatedURI) public {</span>
 101 |     | <span class='unexecuted'>        bytes32 projectId = keccak256(abi.encode(seed));</span>
 102 |     | <span class='neutral'></span>
 103 |     | <span class='neutral'>        // Register and activate project</span>
 104 |     | <span class='unexecuted'>        vm.prank(user);</span>
 105 |     | <span class='unexecuted'>        registry.registerProject(projectId, &quot;meta.json&quot;);</span>
 106 |     | <span class='unexecuted'>        vm.prank(verifier);</span>
 107 |     | <span class='unexecuted'>        registry.setProjectStatus(projectId, ProjectRegistry.ProjectStatus.Active);</span>
 108 |     | <span class='neutral'></span>
 109 |     | <span class='neutral'>        // Mint with initial URI</span>
 110 |     | <span class='unexecuted'>        vm.prank(dmrvManager);</span>
 111 |     | <span class='unexecuted'>        credit.mintCredits(user, projectId, 100, initialURI);</span>
 112 |     | <span class='neutral'></span>
 113 |     | <span class='neutral'>        // Update URI</span>
 114 |     | <span class='unexecuted'>        vm.prank(admin);</span>
 115 |     | <span class='unexecuted'>        credit.setTokenURI(projectId, updatedURI);</span>
 116 |     | <span class='neutral'></span>
 117 |     | <span class='neutral'>        // Verify the URI was updated</span>
 118 |     | <span class='unexecuted'>        assertEq(credit.uri(uint256(projectId)), updatedURI);</span>
 119 |     | <span class='neutral'></span>
 120 |     | <span class='neutral'>        // Verify history</span>
 121 |     | <span class='unexecuted'>        string[] memory history = credit.getTokenURIHistory(uint256(projectId));</span>
 122 |     | <span class='unexecuted'>        assertEq(history.length, 2, &quot;History length should be 2&quot;);</span>
 123 |     | <span class='unexecuted'>        assertEq(history[0], initialURI, &quot;Initial URI mismatch in history&quot;);</span>
 124 |     | <span class='unexecuted'>        assertEq(history[1], updatedURI, &quot;Updated URI mismatch in history&quot;);</span>
 125 |     | <span class='neutral'>    }</span>
 126 |     | <span class='neutral'>}</span>
 127 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/phantom/Documents/azemora/azemora-contracts/test/dynamicImpactCredit/DynamicImpactCredit.invariant.t.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'>pragma solidity ^0.8.20;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>import &quot;forge-std/Test.sol&quot;;</span>
   5 |     | <span class='neutral'>import &quot;./DynamicImpactCredit.t.sol&quot;;</span>
   6 |     | <span class='neutral'>import &quot;../../src/core/ProjectRegistry.sol&quot;;</span>
   7 |     | <span class='neutral'>import &quot;../../src/core/DynamicImpactCredit.sol&quot;;</span>
   8 |     | <span class='neutral'>import &quot;@openzeppelin/contracts/proxy/ERC1967/ERC1967Proxy.sol&quot;;</span>
   9 |     | <span class='neutral'></span>
  10 |     | <span class='neutral'>/*:.+.*.*:.*..:..*.*:.*..:.+.*.*:*/</span>
  11 |     | <span class='neutral'>/*                       INVARIANT TESTING                      */</span>
  12 |     | <span class='neutral'></span>
  13 |     | <span class='neutral'>// Handler contract to perform actions on the credit contract</span>
  14 |     | <span class='unexecuted'>contract CreditHandler is Test {</span>
  15 |     | <span class='neutral'>    DynamicImpactCredit credit;</span>
  16 |     | <span class='neutral'>    ProjectRegistry registry;</span>
  17 |     | <span class='neutral'>    address admin;</span>
  18 |     | <span class='neutral'>    address dmrvManager;</span>
  19 |     | <span class='neutral'>    address verifier;</span>
  20 |     | <span class='neutral'>    address[] users;</span>
  21 |     | <span class='unexecuted'>    mapping(address =&gt; mapping(bytes32 =&gt; uint256)) public userBalances;</span>
  22 |     | <span class='unexecuted'>    mapping(bytes32 =&gt; uint256) public totalSupply;</span>
  23 |     | <span class='unexecuted'>    mapping(bytes32 =&gt; uint256) public retiredAmount;</span>
  24 |     | <span class='neutral'></span>
  25 |     | <span class='neutral'>    // Track which token IDs have been minted</span>
  26 |     | <span class='unexecuted'>    bytes32[] public mintedTokenIds;</span>
  27 |     | <span class='unexecuted'>    mapping(bytes32 =&gt; bool) public tokenIdExists;</span>
  28 |     | <span class='neutral'></span>
  29 |     | <span class='unexecuted'>    constructor(</span>
  30 |     | <span class='neutral'>        DynamicImpactCredit _credit,</span>
  31 |     | <span class='neutral'>        ProjectRegistry _registry,</span>
  32 |     | <span class='neutral'>        address _admin,</span>
  33 |     | <span class='neutral'>        address _dmrvManager,</span>
  34 |     | <span class='neutral'>        address _verifier</span>
  35 |     | <span class='neutral'>    ) {</span>
  36 |     | <span class='unexecuted'>        credit = _credit;</span>
  37 |     | <span class='unexecuted'>        registry = _registry;</span>
  38 |     | <span class='unexecuted'>        admin = _admin;</span>
  39 |     | <span class='unexecuted'>        dmrvManager = _dmrvManager;</span>
  40 |     | <span class='unexecuted'>        verifier = _verifier;</span>
  41 |     | <span class='neutral'></span>
  42 |     | <span class='neutral'>        // Create a set of test users</span>
  43 |     | <span class='unexecuted'>        for (uint256 i = 0; i &lt; 5; i++) {</span>
  44 |     | <span class='unexecuted'>            users.push(address(uint160(0x1000 + i)));</span>
  45 |     | <span class='neutral'>        }</span>
  46 |     | <span class='neutral'>    }</span>
  47 |     | <span class='neutral'></span>
  48 |     | <span class='neutral'>    // Add a function to get the length of mintedTokenIds</span>
  49 |     | <span class='unexecuted'>    function getMintedTokenIdsLength() public view returns (uint256) {</span>
  50 |     | <span class='unexecuted'>        return mintedTokenIds.length;</span>
  51 |     | <span class='neutral'>    }</span>
  52 |     | <span class='neutral'></span>
  53 |     | <span class='neutral'>    // Mint credits to a random user</span>
  54 |     | <span class='unexecuted'>    function mintCredits(uint256 tokenIdSeed, uint256 amount, string calldata uri) public {</span>
  55 |     | <span class='neutral'>        // Ensure tokenId is a reasonable value and not zero</span>
  56 |     | <span class='unexecuted'>        bytes32 projectId = keccak256(abi.encodePacked(&quot;project&quot;, tokenIdSeed % 10));</span>
  57 |     | <span class='unexecuted'>        amount = bound(amount, 1, 10000);</span>
  58 |     | <span class='neutral'></span>
  59 |     | <span class='neutral'>        // Select a random user</span>
  60 |     | <span class='unexecuted'>        address user = users[tokenIdSeed % users.length];</span>
  61 |     | <span class='neutral'></span>
  62 |     | <span class='neutral'>        // Register and approve the project first</span>
  63 |     | <span class='unexecuted'>        if (!tokenIdExists[projectId]) {</span>
  64 |     | <span class='unexecuted'>            vm.prank(user); // Project owner registers</span>
  65 |     | <span class='unexecuted'>            registry.registerProject(projectId, &quot;ipfs://meta.json&quot;);</span>
  66 |     | <span class='unexecuted'>            vm.prank(verifier);</span>
  67 |     | <span class='unexecuted'>            registry.setProjectStatus(projectId, ProjectRegistry.ProjectStatus.Active);</span>
  68 |     | <span class='neutral'>        }</span>
  69 |     | <span class='neutral'></span>
  70 |     | <span class='unexecuted'>        vm.prank(dmrvManager);</span>
  71 |     | <span class='unexecuted'>        credit.mintCredits(user, projectId, amount, uri);</span>
  72 |     | <span class='neutral'></span>
  73 |     | <span class='neutral'>        // Track state for invariant testing</span>
  74 |     | <span class='unexecuted'>        userBalances[user][projectId] += amount;</span>
  75 |     | <span class='unexecuted'>        totalSupply[projectId] += amount;</span>
  76 |     | <span class='neutral'></span>
  77 |     | <span class='neutral'>        // Track this token ID</span>
  78 |     | <span class='unexecuted'>        if (!tokenIdExists[projectId]) {</span>
  79 |     | <span class='unexecuted'>            mintedTokenIds.push(projectId);</span>
  80 |     | <span class='unexecuted'>            tokenIdExists[projectId] = true;</span>
  81 |     | <span class='neutral'>        }</span>
  82 |     | <span class='neutral'>    }</span>
  83 |     | <span class='neutral'></span>
  84 |     | <span class='neutral'>    // Retire credits for a user</span>
  85 |     | <span class='unexecuted'>    function retireCredits(uint256 tokenIdSeed, uint256 amountSeed) public {</span>
  86 |     | <span class='unexecuted'>        if (mintedTokenIds.length == 0) return;</span>
  87 |     | <span class='neutral'></span>
  88 |     | <span class='neutral'>        // Select an existing token ID</span>
  89 |     | <span class='unexecuted'>        uint256 tokenIndex = tokenIdSeed % mintedTokenIds.length;</span>
  90 |     | <span class='unexecuted'>        bytes32 projectId = mintedTokenIds[tokenIndex];</span>
  91 |     | <span class='neutral'></span>
  92 |     | <span class='neutral'>        // Select a user who might have this token</span>
  93 |     | <span class='unexecuted'>        address user = users[tokenIdSeed % users.length];</span>
  94 |     | <span class='neutral'></span>
  95 |     | <span class='neutral'>        // Skip if user has no tokens</span>
  96 |     | <span class='unexecuted'>        if (userBalances[user][projectId] == 0) return;</span>
  97 |     | <span class='neutral'></span>
  98 |     | <span class='neutral'>        // Determine retire amount (cannot exceed balance)</span>
  99 |     | <span class='unexecuted'>        uint256 retireAmount = (amountSeed % userBalances[user][projectId]) + 1;</span>
 100 |     | <span class='neutral'></span>
 101 |     | <span class='unexecuted'>        vm.prank(user);</span>
 102 |     | <span class='unexecuted'>        try credit.retire(user, projectId, retireAmount) {</span>
 103 |     | <span class='neutral'>            // Track state changes</span>
 104 |     | <span class='unexecuted'>            userBalances[user][projectId] -= retireAmount;</span>
 105 |     | <span class='unexecuted'>            retiredAmount[projectId] += retireAmount;</span>
 106 |     | <span class='neutral'>        } catch {</span>
 107 |     | <span class='neutral'>            // If retire fails, that&#39;s okay - we&#39;re just testing invariants</span>
 108 |     | <span class='neutral'>        }</span>
 109 |     | <span class='neutral'>    }</span>
 110 |     | <span class='neutral'></span>
 111 |     | <span class='neutral'>    // Transfer credits between users</span>
 112 |     | <span class='unexecuted'>    function transferCredits(uint256 tokenIdSeed, uint256 fromUserSeed, uint256 toUserSeed, uint256 amountSeed)</span>
 113 |     | <span class='neutral'>        public</span>
 114 |     | <span class='unexecuted'>    {</span>
 115 |     | <span class='unexecuted'>        if (mintedTokenIds.length == 0) return;</span>
 116 |     | <span class='neutral'></span>
 117 |     | <span class='neutral'>        // Select an existing token ID</span>
 118 |     | <span class='unexecuted'>        uint256 tokenIndex = tokenIdSeed % mintedTokenIds.length;</span>
 119 |     | <span class='unexecuted'>        bytes32 projectId = mintedTokenIds[tokenIndex];</span>
 120 |     | <span class='neutral'></span>
 121 |     | <span class='neutral'>        // Select different from/to users</span>
 122 |     | <span class='unexecuted'>        address from = users[fromUserSeed % users.length];</span>
 123 |     | <span class='unexecuted'>        address to = users[(fromUserSeed + toUserSeed + 1) % users.length];</span>
 124 |     | <span class='unexecuted'>        if (from == to) to = users[(toUserSeed + 2) % users.length];</span>
 125 |     | <span class='neutral'></span>
 126 |     | <span class='neutral'>        // Skip if from user has no tokens</span>
 127 |     | <span class='unexecuted'>        if (userBalances[from][projectId] == 0) return;</span>
 128 |     | <span class='neutral'></span>
 129 |     | <span class='neutral'>        // Determine transfer amount (cannot exceed balance)</span>
 130 |     | <span class='unexecuted'>        uint256 transferAmount = (amountSeed % userBalances[from][projectId]) + 1;</span>
 131 |     | <span class='neutral'></span>
 132 |     | <span class='unexecuted'>        vm.prank(from);</span>
 133 |     | <span class='unexecuted'>        try credit.safeTransferFrom(from, to, uint256(projectId), transferAmount, &quot;&quot;) {</span>
 134 |     | <span class='neutral'>            // Track state changes</span>
 135 |     | <span class='unexecuted'>            userBalances[from][projectId] -= transferAmount;</span>
 136 |     | <span class='unexecuted'>            userBalances[to][projectId] += transferAmount;</span>
 137 |     | <span class='neutral'>        } catch {</span>
 138 |     | <span class='neutral'>            // If transfer fails, that&#39;s okay - we&#39;re just testing invariants</span>
 139 |     | <span class='neutral'>        }</span>
 140 |     | <span class='neutral'>    }</span>
 141 |     | <span class='neutral'></span>
 142 |     | <span class='neutral'>    // Update token URI (only used by admin)</span>
 143 |     | <span class='unexecuted'>    function updateTokenURI(uint256 tokenIdSeed, string calldata newURI) public {</span>
 144 |     | <span class='unexecuted'>        if (mintedTokenIds.length == 0) return;</span>
 145 |     | <span class='neutral'></span>
 146 |     | <span class='neutral'>        // Select an existing token ID</span>
 147 |     | <span class='unexecuted'>        uint256 tokenIndex = tokenIdSeed % mintedTokenIds.length;</span>
 148 |     | <span class='unexecuted'>        bytes32 projectId = mintedTokenIds[tokenIndex];</span>
 149 |     | <span class='neutral'></span>
 150 |     | <span class='unexecuted'>        vm.prank(admin);</span>
 151 |     | <span class='unexecuted'>        credit.setTokenURI(projectId, newURI);</span>
 152 |     | <span class='neutral'>    }</span>
 153 |     | <span class='neutral'></span>
 154 |     | <span class='neutral'>    // Helper function to get total minted credits across all users</span>
 155 |     | <span class='unexecuted'>    function getTotalUserBalance(bytes32 projectId) public view returns (uint256) {</span>
 156 |     | <span class='neutral'>        uint256 total = 0;</span>
 157 |     | <span class='unexecuted'>        for (uint256 i = 0; i &lt; users.length; i++) {</span>
 158 |     | <span class='unexecuted'>            total += userBalances[users[i]][projectId];</span>
 159 |     | <span class='neutral'>        }</span>
 160 |     | <span class='unexecuted'>        return total;</span>
 161 |     | <span class='neutral'>    }</span>
 162 |     | <span class='neutral'>}</span>
 163 |     | <span class='neutral'></span>
 164 |     | <span class='neutral'>// Fix: The correct inheritance order is StdInvariant first, then Test</span>
 165 |     | <span class='unexecuted'>contract DynamicImpactCreditInvariantTest is StdInvariant, Test {</span>
 166 |     | <span class='neutral'>    DynamicImpactCredit credit;</span>
 167 |     | <span class='neutral'>    ProjectRegistry registry;</span>
 168 |     | <span class='neutral'>    CreditHandler handler;</span>
 169 |     | <span class='unexecuted'>    address admin = address(0xA11CE);</span>
 170 |     | <span class='unexecuted'>    address dmrvManager = address(0xB01D);</span>
 171 |     | <span class='unexecuted'>    address verifier = address(0xC1E4);</span>
 172 |     | <span class='neutral'></span>
 173 |     | <span class='unexecuted'>    function setUp() public {</span>
 174 |     | <span class='unexecuted'>        vm.startPrank(admin);</span>
 175 |     | <span class='neutral'>        // Deploy Registry</span>
 176 |     | <span class='unexecuted'>        ProjectRegistry registryImpl = new ProjectRegistry();</span>
 177 |     | <span class='unexecuted'>        registry = ProjectRegistry(</span>
 178 |     | <span class='unexecuted'>            address(new ERC1967Proxy(address(registryImpl), abi.encodeCall(ProjectRegistry.initialize, ())))</span>
 179 |     | <span class='neutral'>        );</span>
 180 |     | <span class='unexecuted'>        DynamicImpactCredit impl = new DynamicImpactCredit(address(registry));</span>
 181 |     | <span class='unexecuted'>        credit = DynamicImpactCredit(</span>
 182 |     | <span class='neutral'>            address(</span>
 183 |     | <span class='unexecuted'>                new ERC1967Proxy(</span>
 184 |     | <span class='unexecuted'>                    address(impl), abi.encodeCall(DynamicImpactCredit.initialize, (&quot;ipfs://contract-metadata.json&quot;))</span>
 185 |     | <span class='neutral'>                )</span>
 186 |     | <span class='neutral'>            )</span>
 187 |     | <span class='neutral'>        );</span>
 188 |     | <span class='neutral'></span>
 189 |     | <span class='neutral'>        // Grant roles</span>
 190 |     | <span class='unexecuted'>        credit.grantRole(credit.DMRV_MANAGER_ROLE(), dmrvManager);</span>
 191 |     | <span class='unexecuted'>        credit.grantRole(credit.METADATA_UPDATER_ROLE(), admin);</span>
 192 |     | <span class='unexecuted'>        registry.grantRole(registry.VERIFIER_ROLE(), verifier);</span>
 193 |     | <span class='unexecuted'>        vm.stopPrank();</span>
 194 |     | <span class='neutral'></span>
 195 |     | <span class='neutral'>        // Create handler and target it for invariant testing</span>
 196 |     | <span class='unexecuted'>        handler = new CreditHandler(credit, registry, admin, dmrvManager, verifier);</span>
 197 |     | <span class='unexecuted'>        targetContract(address(handler));</span>
 198 |     | <span class='neutral'>    }</span>
 199 |     | <span class='neutral'></span>
 200 |     | <span class='neutral'>    // Invariant: For each token ID, the sum of all user balances should equal total supply minus retired amount</span>
 201 |     | <span class='unexecuted'>    function invariant_balancesMatchSupply() public view {</span>
 202 |     | <span class='unexecuted'>        uint256 numTokens = handler.getMintedTokenIdsLength();</span>
 203 |     | <span class='unexecuted'>        for (uint256 i = 0; i &lt; numTokens; i++) {</span>
 204 |     | <span class='unexecuted'>            bytes32 projectId = handler.mintedTokenIds(i);</span>
 205 |     | <span class='unexecuted'>            uint256 onChainTotalBalance = handler.getTotalUserBalance(projectId);</span>
 206 |     | <span class='neutral'></span>
 207 |     | <span class='unexecuted'>            assertEq(</span>
 208 |     | <span class='unexecuted'>                onChainTotalBalance + handler.retiredAmount(projectId),</span>
 209 |     | <span class='unexecuted'>                handler.totalSupply(projectId),</span>
 210 |     | <span class='neutral'>                &quot;Total balances + retired should equal total supply&quot;</span>
 211 |     | <span class='neutral'>            );</span>
 212 |     | <span class='neutral'>        }</span>
 213 |     | <span class='neutral'>    }</span>
 214 |     | <span class='neutral'></span>
 215 |     | <span class='neutral'>    // Invariant: User balances tracked in the handler should match balances on the contract</span>
 216 |     | <span class='unexecuted'>    function invariant_handlerBalancesMatchContract() public view {</span>
 217 |     | <span class='unexecuted'>        address[] memory users = new address[](5);</span>
 218 |     | <span class='unexecuted'>        for (uint256 i = 0; i &lt; 5; i++) {</span>
 219 |     | <span class='unexecuted'>            users[i] = address(uint160(0x1000 + i));</span>
 220 |     | <span class='neutral'>        }</span>
 221 |     | <span class='neutral'></span>
 222 |     | <span class='unexecuted'>        uint256 numTokens = handler.getMintedTokenIdsLength();</span>
 223 |     | <span class='unexecuted'>        for (uint256 i = 0; i &lt; numTokens; i++) {</span>
 224 |     | <span class='unexecuted'>            bytes32 projectId = handler.mintedTokenIds(i);</span>
 225 |     | <span class='neutral'></span>
 226 |     | <span class='unexecuted'>            for (uint256 j = 0; j &lt; users.length; j++) {</span>
 227 |     | <span class='unexecuted'>                address user = users[j];</span>
 228 |     | <span class='unexecuted'>                assertEq(</span>
 229 |     | <span class='unexecuted'>                    handler.userBalances(user, projectId),</span>
 230 |     | <span class='unexecuted'>                    credit.balanceOf(user, uint256(projectId)),</span>
 231 |     | <span class='neutral'>                    &quot;Handler balances should match contract balances&quot;</span>
 232 |     | <span class='neutral'>                );</span>
 233 |     | <span class='neutral'>            }</span>
 234 |     | <span class='neutral'>        }</span>
 235 |     | <span class='neutral'>    }</span>
 236 |     | <span class='neutral'></span>
 237 |     | <span class='neutral'>    // Invariant: Admin role should never change</span>
 238 |     | <span class='unexecuted'>    function invariant_adminRoleNeverChanges() public view {</span>
 239 |     | <span class='unexecuted'>        assertTrue(credit.hasRole(credit.DEFAULT_ADMIN_ROLE(), admin), &quot;Admin should always have admin role&quot;);</span>
 240 |     | <span class='neutral'>    }</span>
 241 |     | <span class='neutral'></span>
 242 |     | <span class='neutral'>    // Invariant: DMRV Manager role should never change</span>
 243 |     | <span class='unexecuted'>    function invariant_dmrvManagerRoleNeverChanges() public view {</span>
 244 |     | <span class='unexecuted'>        assertTrue(credit.hasRole(credit.DMRV_MANAGER_ROLE(), dmrvManager), &quot;DMRV Manager should always have its role&quot;);</span>
 245 |     | <span class='neutral'>    }</span>
 246 |     | <span class='neutral'>}</span>
 247 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/phantom/Documents/azemora/azemora-contracts/test/dynamicImpactCredit/DynamicImpactCredit.t.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'>pragma solidity ^0.8.20;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>import &quot;forge-std/Test.sol&quot;;</span>
   5 |     | <span class='neutral'>import &quot;../../src/core/ProjectRegistry.sol&quot;;</span>
   6 |     | <span class='neutral'>import &quot;../../src/core/dMRVManager.sol&quot;;</span>
   7 |     | <span class='neutral'>import &quot;../../src/core/DynamicImpactCredit.sol&quot;;</span>
   8 |     | <span class='neutral'>import &quot;@openzeppelin/contracts/proxy/ERC1967/ERC1967Proxy.sol&quot;;</span>
   9 |     | <span class='neutral'>import &quot;@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol&quot;;</span>
  10 |     | <span class='neutral'>import &quot;@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol&quot;;</span>
  11 |     | <span class='neutral'></span>
  12 |     | <span class='neutral'>interface IUUPS {</span>
  13 |     | <span class='neutral'>    function upgradeTo(address newImplementation) external;</span>
  14 |     | <span class='neutral'>    function upgradeToAndCall(address newImplementation, bytes calldata data) external payable;</span>
  15 |     | <span class='neutral'>}</span>
  16 |     | <span class='neutral'></span>
  17 |     | <span class='unexecuted'>contract DynamicImpactCreditTest is Test {</span>
  18 |     | <span class='neutral'>    DynamicImpactCredit creditImpl;</span>
  19 |     | <span class='neutral'>    DynamicImpactCredit credit; // proxy cast</span>
  20 |     | <span class='neutral'>    ProjectRegistry registry;</span>
  21 |     | <span class='neutral'></span>
  22 |     | <span class='unexecuted'>    address admin = address(0xA11CE);</span>
  23 |     | <span class='unexecuted'>    address dmrvManager = address(0xB01D);</span>
  24 |     | <span class='unexecuted'>    address user = address(0xCAFE);</span>
  25 |     | <span class='unexecuted'>    address other = address(0xD00D);</span>
  26 |     | <span class='unexecuted'>    address verifier = address(0xC1E4);</span>
  27 |     | <span class='neutral'></span>
  28 |     | <span class='neutral'>    bytes32 setupProjectId;</span>
  29 |     | <span class='neutral'></span>
  30 |     | <span class='neutral'>    /* ---------- set-up ---------- */</span>
  31 |     | <span class='unexecuted'>    function setUp() public {</span>
  32 |     | <span class='unexecuted'>        setupProjectId = keccak256(&quot;Project-For-Setup&quot;);</span>
  33 |     | <span class='neutral'></span>
  34 |     | <span class='unexecuted'>        vm.startPrank(admin);</span>
  35 |     | <span class='neutral'></span>
  36 |     | <span class='neutral'>        // Deploy Registry</span>
  37 |     | <span class='unexecuted'>        ProjectRegistry registryImpl = new ProjectRegistry();</span>
  38 |     | <span class='unexecuted'>        bytes memory registryInitData = abi.encodeCall(ProjectRegistry.initialize, ());</span>
  39 |     | <span class='unexecuted'>        ERC1967Proxy registryProxy = new ERC1967Proxy(address(registryImpl), registryInitData);</span>
  40 |     | <span class='unexecuted'>        registry = ProjectRegistry(address(registryProxy));</span>
  41 |     | <span class='unexecuted'>        registry.grantRole(registry.VERIFIER_ROLE(), verifier);</span>
  42 |     | <span class='neutral'></span>
  43 |     | <span class='neutral'>        // Deploy Credit Contract</span>
  44 |     | <span class='unexecuted'>        creditImpl = new DynamicImpactCredit(address(registry));</span>
  45 |     | <span class='neutral'></span>
  46 |     | <span class='unexecuted'>        bytes memory creditInitData = abi.encodeCall(DynamicImpactCredit.initialize, (&quot;ipfs://contract-metadata.json&quot;));</span>
  47 |     | <span class='neutral'></span>
  48 |     | <span class='unexecuted'>        ERC1967Proxy creditProxy = new ERC1967Proxy(address(creditImpl), creditInitData);</span>
  49 |     | <span class='unexecuted'>        credit = DynamicImpactCredit(address(creditProxy));</span>
  50 |     | <span class='neutral'></span>
  51 |     | <span class='unexecuted'>        credit.grantRole(credit.DMRV_MANAGER_ROLE(), dmrvManager);</span>
  52 |     | <span class='unexecuted'>        credit.grantRole(credit.METADATA_UPDATER_ROLE(), admin);</span>
  53 |     | <span class='neutral'></span>
  54 |     | <span class='unexecuted'>        vm.stopPrank();</span>
  55 |     | <span class='neutral'></span>
  56 |     | <span class='neutral'>        // Register the project here so it exists for all tests that need it.</span>
  57 |     | <span class='unexecuted'>        vm.prank(user);</span>
  58 |     | <span class='unexecuted'>        registry.registerProject(setupProjectId, &quot;ipfs://project-for-setup.json&quot;);</span>
  59 |     | <span class='neutral'>    }</span>
  60 |     | <span class='neutral'></span>
  61 |     | <span class='neutral'>    /* ---------- single mint ---------- */</span>
  62 |     | <span class='unexecuted'>    function testMint() public {</span>
  63 |     | <span class='unexecuted'>        bytes32 projectId = keccak256(&quot;Project-1&quot;);</span>
  64 |     | <span class='unexecuted'>        vm.prank(user);</span>
  65 |     | <span class='unexecuted'>        registry.registerProject(projectId, &quot;ipfs://project1.json&quot;);</span>
  66 |     | <span class='unexecuted'>        vm.prank(verifier);</span>
  67 |     | <span class='unexecuted'>        registry.setProjectStatus(projectId, ProjectRegistry.ProjectStatus.Active);</span>
  68 |     | <span class='neutral'></span>
  69 |     | <span class='unexecuted'>        vm.prank(dmrvManager);</span>
  70 |     | <span class='unexecuted'>        credit.mintCredits(user, projectId, 100, &quot;ipfs://t1.json&quot;);</span>
  71 |     | <span class='neutral'></span>
  72 |     | <span class='unexecuted'>        assertEq(credit.balanceOf(user, uint256(projectId)), 100);</span>
  73 |     | <span class='unexecuted'>        assertEq(credit.uri(uint256(projectId)), &quot;ipfs://t1.json&quot;);</span>
  74 |     | <span class='neutral'>    }</span>
  75 |     | <span class='neutral'></span>
  76 |     | <span class='neutral'>    /* ---------- batch mint ---------- */</span>
  77 |     | <span class='unexecuted'>    function testBatchMint() public {</span>
  78 |     | <span class='unexecuted'>        bytes32[] memory ids = new bytes32[](2);</span>
  79 |     | <span class='unexecuted'>        uint256[] memory amounts = new uint256[](2);</span>
  80 |     | <span class='unexecuted'>        string[] memory uris = new string[](2);</span>
  81 |     | <span class='neutral'></span>
  82 |     | <span class='unexecuted'>        ids[0] = keccak256(&quot;Project-10&quot;);</span>
  83 |     | <span class='unexecuted'>        ids[1] = keccak256(&quot;Project-11&quot;);</span>
  84 |     | <span class='unexecuted'>        amounts[0] = 5;</span>
  85 |     | <span class='unexecuted'>        amounts[1] = 7;</span>
  86 |     | <span class='unexecuted'>        uris[0] = &quot;ipfs://a.json&quot;;</span>
  87 |     | <span class='unexecuted'>        uris[1] = &quot;ipfs://b.json&quot;;</span>
  88 |     | <span class='neutral'></span>
  89 |     | <span class='neutral'>        // Register and activate projects - FIX: separate prank calls for each registration</span>
  90 |     | <span class='unexecuted'>        vm.prank(user);</span>
  91 |     | <span class='unexecuted'>        registry.registerProject(ids[0], &quot;p10.json&quot;);</span>
  92 |     | <span class='neutral'></span>
  93 |     | <span class='unexecuted'>        vm.prank(user);</span>
  94 |     | <span class='unexecuted'>        registry.registerProject(ids[1], &quot;p11.json&quot;);</span>
  95 |     | <span class='neutral'></span>
  96 |     | <span class='unexecuted'>        vm.startPrank(verifier);</span>
  97 |     | <span class='unexecuted'>        registry.setProjectStatus(ids[0], ProjectRegistry.ProjectStatus.Active);</span>
  98 |     | <span class='unexecuted'>        registry.setProjectStatus(ids[1], ProjectRegistry.ProjectStatus.Active);</span>
  99 |     | <span class='unexecuted'>        vm.stopPrank();</span>
 100 |     | <span class='neutral'></span>
 101 |     | <span class='unexecuted'>        vm.prank(dmrvManager);</span>
 102 |     | <span class='unexecuted'>        credit.batchMintCredits(user, ids, amounts, uris);</span>
 103 |     | <span class='neutral'></span>
 104 |     | <span class='unexecuted'>        assertEq(credit.balanceOf(user, uint256(ids[0])), 5);</span>
 105 |     | <span class='unexecuted'>        assertEq(credit.balanceOf(user, uint256(ids[1])), 7);</span>
 106 |     | <span class='unexecuted'>        assertEq(credit.uri(uint256(ids[1])), &quot;ipfs://b.json&quot;);</span>
 107 |     | <span class='neutral'>    }</span>
 108 |     | <span class='neutral'></span>
 109 |     | <span class='neutral'>    /* ---------- unauthorized mint revert ---------- */</span>
 110 |     | <span class='unexecuted'>    function testMintNotMinterReverts() public {</span>
 111 |     | <span class='unexecuted'>        bytes32 projectId = keccak256(&quot;Project-2&quot;);</span>
 112 |     | <span class='unexecuted'>        vm.prank(user);</span>
 113 |     | <span class='unexecuted'>        registry.registerProject(projectId, &quot;p2.json&quot;);</span>
 114 |     | <span class='unexecuted'>        vm.prank(verifier);</span>
 115 |     | <span class='unexecuted'>        registry.setProjectStatus(projectId, ProjectRegistry.ProjectStatus.Active);</span>
 116 |     | <span class='neutral'></span>
 117 |     | <span class='unexecuted'>        vm.expectRevert(</span>
 118 |     | <span class='unexecuted'>            abi.encodeWithSignature(</span>
 119 |     | <span class='unexecuted'>                &quot;AccessControlUnauthorizedAccount(address,bytes32)&quot;, other, credit.DMRV_MANAGER_ROLE()</span>
 120 |     | <span class='neutral'>            )</span>
 121 |     | <span class='neutral'>        );</span>
 122 |     | <span class='unexecuted'>        vm.prank(other);</span>
 123 |     | <span class='unexecuted'>        credit.mintCredits(user, projectId, 1, &quot;ipfs://fail.json&quot;);</span>
 124 |     | <span class='neutral'>    }</span>
 125 |     | <span class='neutral'></span>
 126 |     | <span class='neutral'>    /* ---------- metadata update ---------- */</span>
 127 |     | <span class='unexecuted'>    function testSetTokenURI() public {</span>
 128 |     | <span class='unexecuted'>        bytes32 projectId = keccak256(&quot;Project-3&quot;);</span>
 129 |     | <span class='unexecuted'>        vm.prank(user);</span>
 130 |     | <span class='unexecuted'>        registry.registerProject(projectId, &quot;p3.json&quot;);</span>
 131 |     | <span class='unexecuted'>        vm.prank(verifier);</span>
 132 |     | <span class='unexecuted'>        registry.setProjectStatus(projectId, ProjectRegistry.ProjectStatus.Active);</span>
 133 |     | <span class='neutral'></span>
 134 |     | <span class='unexecuted'>        string memory oldURI = &quot;ipfs://old.json&quot;;</span>
 135 |     | <span class='unexecuted'>        vm.startPrank(dmrvManager);</span>
 136 |     | <span class='unexecuted'>        credit.mintCredits(user, projectId, 1, oldURI);</span>
 137 |     | <span class='unexecuted'>        vm.stopPrank();</span>
 138 |     | <span class='neutral'></span>
 139 |     | <span class='unexecuted'>        vm.prank(admin);</span>
 140 |     | <span class='unexecuted'>        string memory newURI = &quot;ipfs://new.json&quot;;</span>
 141 |     | <span class='unexecuted'>        credit.setTokenURI(projectId, newURI);</span>
 142 |     | <span class='unexecuted'>        assertEq(credit.uri(uint256(projectId)), newURI);</span>
 143 |     | <span class='neutral'></span>
 144 |     | <span class='unexecuted'>        string[] memory history = credit.getTokenURIHistory(uint256(projectId));</span>
 145 |     | <span class='unexecuted'>        assertEq(history.length, 2);</span>
 146 |     | <span class='unexecuted'>        assertEq(history[0], oldURI);</span>
 147 |     | <span class='unexecuted'>        assertEq(history[1], newURI);</span>
 148 |     | <span class='neutral'>    }</span>
 149 |     | <span class='neutral'></span>
 150 |     | <span class='neutral'>    /* ---------- retire flow ---------- */</span>
 151 |     | <span class='unexecuted'>    function testRetire() public {</span>
 152 |     | <span class='unexecuted'>        bytes32 projectId = keccak256(&quot;Project-4&quot;);</span>
 153 |     | <span class='unexecuted'>        vm.prank(user);</span>
 154 |     | <span class='unexecuted'>        registry.registerProject(projectId, &quot;p4.json&quot;);</span>
 155 |     | <span class='unexecuted'>        vm.prank(verifier);</span>
 156 |     | <span class='unexecuted'>        registry.setProjectStatus(projectId, ProjectRegistry.ProjectStatus.Active);</span>
 157 |     | <span class='neutral'></span>
 158 |     | <span class='unexecuted'>        vm.prank(dmrvManager);</span>
 159 |     | <span class='unexecuted'>        credit.mintCredits(user, projectId, 10, &quot;ipfs://t.json&quot;);</span>
 160 |     | <span class='neutral'></span>
 161 |     | <span class='unexecuted'>        vm.prank(user);</span>
 162 |     | <span class='unexecuted'>        credit.retire(user, projectId, 6);</span>
 163 |     | <span class='neutral'></span>
 164 |     | <span class='unexecuted'>        assertEq(credit.balanceOf(user, uint256(projectId)), 4);</span>
 165 |     | <span class='neutral'>    }</span>
 166 |     | <span class='neutral'></span>
 167 |     | <span class='neutral'>    /* ---------- retire too much reverts ---------- */</span>
 168 |     | <span class='unexecuted'>    function testRetireTooMuch() public {</span>
 169 |     | <span class='unexecuted'>        bytes32 projectId = keccak256(&quot;Project-5&quot;);</span>
 170 |     | <span class='unexecuted'>        vm.prank(user);</span>
 171 |     | <span class='unexecuted'>        registry.registerProject(projectId, &quot;p5.json&quot;);</span>
 172 |     | <span class='unexecuted'>        vm.prank(verifier);</span>
 173 |     | <span class='unexecuted'>        registry.setProjectStatus(projectId, ProjectRegistry.ProjectStatus.Active);</span>
 174 |     | <span class='neutral'></span>
 175 |     | <span class='unexecuted'>        vm.prank(dmrvManager);</span>
 176 |     | <span class='unexecuted'>        credit.mintCredits(user, projectId, 1, &quot;ipfs://t.json&quot;);</span>
 177 |     | <span class='neutral'></span>
 178 |     | <span class='unexecuted'>        vm.prank(user);</span>
 179 |     | <span class='unexecuted'>        vm.expectRevert();</span>
 180 |     | <span class='unexecuted'>        credit.retire(user, projectId, 2);</span>
 181 |     | <span class='neutral'>    }</span>
 182 |     | <span class='neutral'></span>
 183 |     | <span class='neutral'>    /* ---------- re-initialization blocked ---------- */</span>
 184 |     | <span class='unexecuted'>    function testCannotReinitialize() public {</span>
 185 |     | <span class='unexecuted'>        vm.expectRevert(Initializable.InvalidInitialization.selector);</span>
 186 |     | <span class='unexecuted'>        credit.initialize(&quot;ipfs://again&quot;);</span>
 187 |     | <span class='neutral'>    }</span>
 188 |     | <span class='neutral'></span>
 189 |     | <span class='neutral'>    /* ---------- upgrade keeps state ---------- */</span>
 190 |     | <span class='unexecuted'>    function testUpgradeKeepsBalance() public {</span>
 191 |     | <span class='unexecuted'>        bytes32 projectId = keccak256(&quot;Project-7&quot;);</span>
 192 |     | <span class='unexecuted'>        vm.prank(user);</span>
 193 |     | <span class='unexecuted'>        registry.registerProject(projectId, &quot;p7.json&quot;);</span>
 194 |     | <span class='unexecuted'>        vm.prank(verifier);</span>
 195 |     | <span class='unexecuted'>        registry.setProjectStatus(projectId, ProjectRegistry.ProjectStatus.Active);</span>
 196 |     | <span class='neutral'></span>
 197 |     | <span class='unexecuted'>        vm.prank(dmrvManager);</span>
 198 |     | <span class='unexecuted'>        credit.mintCredits(user, projectId, 42, &quot;ipfs://state.json&quot;);</span>
 199 |     | <span class='neutral'></span>
 200 |     | <span class='neutral'>        // deploy V2 with new variable</span>
 201 |     | <span class='unexecuted'>        DynamicImpactCreditV2 v2 = new DynamicImpactCreditV2(address(registry));</span>
 202 |     | <span class='neutral'></span>
 203 |     | <span class='unexecuted'>        vm.startPrank(admin);</span>
 204 |     | <span class='neutral'>        // Empty bytes for data since we don&#39;t need initialization logic</span>
 205 |     | <span class='unexecuted'>        IUUPS(address(credit)).upgradeToAndCall(address(v2), &quot;&quot;);</span>
 206 |     | <span class='unexecuted'>        vm.stopPrank();</span>
 207 |     | <span class='neutral'></span>
 208 |     | <span class='neutral'>        // cast back</span>
 209 |     | <span class='unexecuted'>        DynamicImpactCreditV2 upgraded = DynamicImpactCreditV2(address(credit));</span>
 210 |     | <span class='neutral'></span>
 211 |     | <span class='unexecuted'>        assertEq(upgraded.balanceOf(user, uint256(projectId)), 42);</span>
 212 |     | <span class='unexecuted'>        assertEq(upgraded.VERSION(), 2);</span>
 213 |     | <span class='neutral'>    }</span>
 214 |     | <span class='neutral'></span>
 215 |     | <span class='unexecuted'>    function testRoleAssignment() public view {</span>
 216 |     | <span class='unexecuted'>        console.log(&quot;Admin address:&quot;, admin);</span>
 217 |     | <span class='unexecuted'>        console.log(&quot;Admin has DEFAULT_ADMIN_ROLE:&quot;, credit.hasRole(credit.DEFAULT_ADMIN_ROLE(), admin));</span>
 218 |     | <span class='unexecuted'>        console.log(&quot;Test contract has DEFAULT_ADMIN_ROLE:&quot;, credit.hasRole(credit.DEFAULT_ADMIN_ROLE(), address(this)));</span>
 219 |     | <span class='neutral'>    }</span>
 220 |     | <span class='neutral'></span>
 221 |     | <span class='neutral'>    /* ---------- Pausable Tests ---------- */</span>
 222 |     | <span class='neutral'></span>
 223 |     | <span class='unexecuted'>    function test_PauseAndUnpause() public {</span>
 224 |     | <span class='unexecuted'>        bytes32 pauserRole = credit.PAUSER_ROLE();</span>
 225 |     | <span class='neutral'></span>
 226 |     | <span class='unexecuted'>        vm.startPrank(admin);</span>
 227 |     | <span class='neutral'>        // Admin has pauser role by default from setUp</span>
 228 |     | <span class='unexecuted'>        credit.pause();</span>
 229 |     | <span class='unexecuted'>        assertTrue(credit.paused());</span>
 230 |     | <span class='unexecuted'>        credit.unpause();</span>
 231 |     | <span class='unexecuted'>        assertFalse(credit.paused());</span>
 232 |     | <span class='unexecuted'>        vm.stopPrank();</span>
 233 |     | <span class='neutral'></span>
 234 |     | <span class='neutral'>        // Non-pauser cannot pause</span>
 235 |     | <span class='unexecuted'>        vm.prank(other);</span>
 236 |     | <span class='unexecuted'>        vm.expectRevert(</span>
 237 |     | <span class='unexecuted'>            abi.encodeWithSelector(</span>
 238 |     | <span class='unexecuted'>                bytes4(keccak256(&quot;AccessControlUnauthorizedAccount(address,bytes32)&quot;)), other, pauserRole</span>
 239 |     | <span class='neutral'>            )</span>
 240 |     | <span class='neutral'>        );</span>
 241 |     | <span class='unexecuted'>        credit.pause();</span>
 242 |     | <span class='neutral'>    }</span>
 243 |     | <span class='neutral'></span>
 244 |     | <span class='unexecuted'>    function test_RevertsWhenPaused() public {</span>
 245 |     | <span class='unexecuted'>        bytes32 projectId = keccak256(&quot;Project-Pausable&quot;);</span>
 246 |     | <span class='unexecuted'>        vm.prank(user);</span>
 247 |     | <span class='unexecuted'>        registry.registerProject(projectId, &quot;p-pausable.json&quot;);</span>
 248 |     | <span class='unexecuted'>        vm.prank(verifier);</span>
 249 |     | <span class='unexecuted'>        registry.setProjectStatus(projectId, ProjectRegistry.ProjectStatus.Active);</span>
 250 |     | <span class='neutral'></span>
 251 |     | <span class='unexecuted'>        vm.prank(admin);</span>
 252 |     | <span class='unexecuted'>        credit.pause();</span>
 253 |     | <span class='neutral'></span>
 254 |     | <span class='unexecuted'>        vm.expectRevert(&quot;EnforcedPause()&quot;);</span>
 255 |     | <span class='unexecuted'>        vm.prank(dmrvManager);</span>
 256 |     | <span class='unexecuted'>        credit.mintCredits(user, projectId, 1, &quot;ipfs://fail-paused.json&quot;);</span>
 257 |     | <span class='neutral'>    }</span>
 258 |     | <span class='neutral'></span>
 259 |     | <span class='unexecuted'>    function test_MintCredits_RevertsForNonActiveProject() public {</span>
 260 |     | <span class='neutral'>        // setupProjectId is registered but not activated</span>
 261 |     | <span class='unexecuted'>        vm.prank(dmrvManager);</span>
 262 |     | <span class='unexecuted'>        vm.expectRevert(DynamicImpactCredit__ProjectNotActive.selector);</span>
 263 |     | <span class='unexecuted'>        credit.mintCredits(user, setupProjectId, 100, &quot;ipfs://t1.json&quot;);</span>
 264 |     | <span class='neutral'>    }</span>
 265 |     | <span class='neutral'></span>
 266 |     | <span class='unexecuted'>    function test_Retire_RevertsWhenNotAuthorized() public {</span>
 267 |     | <span class='unexecuted'>        bytes32 projectId = keccak256(&quot;Project-To-Retire&quot;);</span>
 268 |     | <span class='neutral'>        uint256 tokenId = uint256(projectId);</span>
 269 |     | <span class='neutral'></span>
 270 |     | <span class='unexecuted'>        vm.prank(user);</span>
 271 |     | <span class='unexecuted'>        registry.registerProject(projectId, &quot;ipfs://retire.json&quot;);</span>
 272 |     | <span class='neutral'></span>
 273 |     | <span class='unexecuted'>        vm.prank(verifier);</span>
 274 |     | <span class='unexecuted'>        registry.setProjectStatus(projectId, ProjectRegistry.ProjectStatus.Active);</span>
 275 |     | <span class='neutral'></span>
 276 |     | <span class='unexecuted'>        vm.prank(dmrvManager);</span>
 277 |     | <span class='unexecuted'>        credit.mintCredits(user, projectId, 10, &quot;ipfs://t.json&quot;);</span>
 278 |     | <span class='neutral'></span>
 279 |     | <span class='neutral'>        // &#39;other&#39; user, who is not the owner and not approved, tries to retire</span>
 280 |     | <span class='unexecuted'>        vm.prank(other);</span>
 281 |     | <span class='unexecuted'>        vm.expectRevert(DynamicImpactCredit__NotAuthorized.selector);</span>
 282 |     | <span class='unexecuted'>        credit.retire(user, projectId, 5);</span>
 283 |     | <span class='neutral'>    }</span>
 284 |     | <span class='neutral'></span>
 285 |     | <span class='unexecuted'>    function test_URI_RevertsForNonExistentToken() public {</span>
 286 |     | <span class='unexecuted'>        vm.expectRevert(DynamicImpactCredit__URINotSet.selector);</span>
 287 |     | <span class='unexecuted'>        credit.uri(99999); // A token that has not been minted</span>
 288 |     | <span class='neutral'>    }</span>
 289 |     | <span class='neutral'></span>
 290 |     | <span class='unexecuted'>    function test_BatchMint_RevertsOnMismatchedArrays() public {</span>
 291 |     | <span class='unexecuted'>        bytes32[] memory ids = new bytes32[](2);</span>
 292 |     | <span class='unexecuted'>        uint256[] memory amounts = new uint256[](1); // Mismatched length</span>
 293 |     | <span class='unexecuted'>        string[] memory uris = new string[](2);</span>
 294 |     | <span class='neutral'></span>
 295 |     | <span class='unexecuted'>        ids[0] = keccak256(&quot;p1&quot;);</span>
 296 |     | <span class='unexecuted'>        ids[1] = keccak256(&quot;p2&quot;);</span>
 297 |     | <span class='unexecuted'>        amounts[0] = 1;</span>
 298 |     | <span class='unexecuted'>        uris[0] = &quot;u1&quot;;</span>
 299 |     | <span class='unexecuted'>        uris[1] = &quot;u2&quot;;</span>
 300 |     | <span class='neutral'></span>
 301 |     | <span class='unexecuted'>        vm.prank(dmrvManager);</span>
 302 |     | <span class='unexecuted'>        vm.expectRevert(DynamicImpactCredit__LengthMismatch.selector);</span>
 303 |     | <span class='unexecuted'>        credit.batchMintCredits(user, ids, amounts, uris);</span>
 304 |     | <span class='neutral'>    }</span>
 305 |     | <span class='neutral'></span>
 306 |     | <span class='unexecuted'>    function test_BatchMint_RevertsForNonActiveProject() public {</span>
 307 |     | <span class='unexecuted'>        bytes32[] memory ids = new bytes32[](2);</span>
 308 |     | <span class='unexecuted'>        uint256[] memory amounts = new uint256[](2);</span>
 309 |     | <span class='unexecuted'>        string[] memory uris = new string[](2);</span>
 310 |     | <span class='neutral'></span>
 311 |     | <span class='unexecuted'>        ids[0] = setupProjectId; // This project is not active by default in setUp</span>
 312 |     | <span class='unexecuted'>        ids[1] = keccak256(&quot;another-active-one&quot;);</span>
 313 |     | <span class='unexecuted'>        amounts[0] = 5;</span>
 314 |     | <span class='unexecuted'>        amounts[1] = 7;</span>
 315 |     | <span class='unexecuted'>        uris[0] = &quot;ipfs://a.json&quot;;</span>
 316 |     | <span class='unexecuted'>        uris[1] = &quot;ipfs://b.json&quot;;</span>
 317 |     | <span class='neutral'></span>
 318 |     | <span class='neutral'>        // Activate the second project</span>
 319 |     | <span class='unexecuted'>        vm.prank(user);</span>
 320 |     | <span class='unexecuted'>        registry.registerProject(ids[1], &quot;p11.json&quot;);</span>
 321 |     | <span class='unexecuted'>        vm.prank(verifier);</span>
 322 |     | <span class='unexecuted'>        registry.setProjectStatus(ids[1], ProjectRegistry.ProjectStatus.Active);</span>
 323 |     | <span class='neutral'></span>
 324 |     | <span class='unexecuted'>        vm.prank(dmrvManager);</span>
 325 |     | <span class='unexecuted'>        vm.expectRevert(DynamicImpactCredit__ProjectNotActive.selector);</span>
 326 |     | <span class='neutral'>        credit.batchMintCredits(user, ids, amounts, uris);</span>
 327 |     | <span class='neutral'>    }</span>
 328 |     | <span class='neutral'>}</span>
 329 |     | <span class='neutral'></span>
 330 |     | <span class='neutral'>/* ---------- dummy V2 impl for upgrade test ---------- */</span>
 331 |     | <span class='unexecuted'>contract DynamicImpactCreditV2 is UUPSUpgradeable, DynamicImpactCredit {</span>
 332 |     | <span class='unexecuted'>    uint256 public constant VERSION = 2;</span>
 333 |     | <span class='neutral'></span>
 334 |     | <span class='unexecuted'>    constructor(address registryAddress) DynamicImpactCredit(registryAddress) {}</span>
 335 |     | <span class='neutral'></span>
 336 |     | <span class='unexecuted'>    function getVersion() external pure returns (uint256) {</span>
 337 |     | <span class='neutral'>        return VERSION;</span>
 338 |     | <span class='neutral'>    }</span>
 339 |     | <span class='neutral'></span>
 340 |     | <span class='neutral'>    function _authorizeUpgrade(address newImplementation) internal override(DynamicImpactCredit, UUPSUpgradeable) {}</span>
 341 |     | <span class='neutral'>}</span>
 342 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/phantom/Documents/azemora/azemora-contracts/test/echidna/Marketplace.echidna.t.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'>pragma solidity 0.8.25;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>import {Test} from &quot;forge-std/Test.sol&quot;;</span>
   5 |     | <span class='neutral'>import {Marketplace} from &quot;src/marketplace/Marketplace.sol&quot;;</span>
   6 |     | <span class='neutral'>import {DynamicImpactCredit} from &quot;src/core/DynamicImpactCredit.sol&quot;;</span>
   7 |     | <span class='neutral'>import {ProjectRegistry} from &quot;src/core/ProjectRegistry.sol&quot;;</span>
   8 |     | <span class='neutral'>import {ERC20Mock} from &quot;@openzeppelin/contracts/mocks/token/ERC20Mock.sol&quot;;</span>
   9 |     | <span class='neutral'>import {ERC1967Proxy} from &quot;@openzeppelin/contracts/proxy/ERC1967/ERC1967Proxy.sol&quot;;</span>
  10 |     | <span class='neutral'></span>
  11 |     | <span class='neutral'></span>
  12 |     | <span class='neutral'>/// @title Echidna test for the Marketplace contract</span>
  13 |     | <span class='neutral'>/// @notice This contract defines properties (invariants) that should always hold true</span>
  14 |     | <span class='neutral'>/// for the Marketplace, no matter what sequence of functions are called.</span>
  15 |     | <span class='neutral'>/// Echidna will try to break these properties.</span>
  16 | *r  | <span class='executed'>contract MarketplaceEchidnaTest is Test {</span>
  17 |     | <span class='neutral'>    Marketplace internal marketplace;</span>
  18 |     | <span class='neutral'>    DynamicImpactCredit internal credit;</span>
  19 |     | <span class='neutral'>    ProjectRegistry internal registry;</span>
  20 |     | <span class='neutral'>    ERC20Mock internal paymentToken;</span>
  21 |     | <span class='neutral'></span>
  22 |     | <span class='neutral'>    // Echidna will use this to generate random users</span>
  23 |     | <span class='neutral'>    address[] internal users;</span>
  24 |     | <span class='neutral'></span>
  25 |     | <span class='neutral'>    // Constants for the test setup</span>
  26 | *   | <span class='executed'>    uint256 constant NUM_TOKENS = 10;</span>
  27 | *   | <span class='executed'>    uint256 constant NUM_USERS = 5;</span>
  28 | *   | <span class='executed'>    uint256 constant INITIAL_MINT_AMOUNT = 1000;</span>
  29 | *   | <span class='executed'>    uint256 constant INITIAL_PAYMENT_BALANCE = 1_000_000 ether;</span>
  30 |     | <span class='neutral'></span>
  31 | *   | <span class='executed'>    constructor() {</span>
  32 |     | <span class='neutral'>        // --- Deploy Logic &amp; Proxies in correct order ---</span>
  33 |     | <span class='neutral'></span>
  34 |     | <span class='neutral'>        // 1. Deploy Registry (logic and proxy)</span>
  35 | *   | <span class='executed'>        ProjectRegistry registryImpl = new ProjectRegistry();</span>
  36 | *   | <span class='executed'>        bytes memory registryData = abi.encodeWithSelector(ProjectRegistry.initialize.selector);</span>
  37 | *   | <span class='executed'>        registry = ProjectRegistry(payable(address(new ERC1967Proxy(address(registryImpl), registryData))));</span>
  38 |     | <span class='neutral'></span>
  39 |     | <span class='neutral'>        // 2. Deploy Credit contract logic, passing it the *registry proxy* address</span>
  40 | *   | <span class='executed'>        DynamicImpactCredit creditImpl = new DynamicImpactCredit(address(registry));</span>
  41 | *   | <span class='executed'>        bytes memory creditData = abi.encodeWithSelector(creditImpl.initialize.selector, &quot;contract_uri&quot;);</span>
  42 | *   | <span class='executed'>        credit = DynamicImpactCredit(payable(address(new ERC1967Proxy(address(creditImpl), creditData))));</span>
  43 |     | <span class='neutral'></span>
  44 |     | <span class='neutral'>        // 3. Deploy Payment Token</span>
  45 | *   | <span class='executed'>        paymentToken = new ERC20Mock();</span>
  46 |     | <span class='neutral'></span>
  47 |     | <span class='neutral'>        // 4. Deploy Marketplace (logic and proxy)</span>
  48 | *   | <span class='executed'>        Marketplace marketplaceImpl = new Marketplace();</span>
  49 |     | <span class='neutral'>        bytes memory marketplaceData =</span>
  50 | *   | <span class='executed'>            abi.encodeWithSelector(marketplaceImpl.initialize.selector, address(credit), address(paymentToken));</span>
  51 | *   | <span class='executed'>        marketplace = Marketplace(payable(address(new ERC1967Proxy(address(marketplaceImpl), marketplaceData))));</span>
  52 |     | <span class='neutral'></span>
  53 |     | <span class='neutral'></span>
  54 |     | <span class='neutral'>        // --- Grant Roles ---</span>
  55 | *   | <span class='executed'>        credit.grantRole(credit.DMRV_MANAGER_ROLE(), address(this));</span>
  56 | *   | <span class='executed'>        registry.grantRole(registry.VERIFIER_ROLE(), address(this));</span>
  57 |     | <span class='neutral'></span>
  58 |     | <span class='neutral'>        // --- Create Users and Tokens ---</span>
  59 | *   | <span class='executed'>        for (uint256 i = 0; i &lt; NUM_USERS; i++) {</span>
  60 | *   | <span class='executed'>            users.push(address(uint160(i + 1))); // Create non-zero user addresses</span>
  61 |     | <span class='neutral'>        }</span>
  62 |     | <span class='neutral'></span>
  63 | *   | <span class='executed'>        for (uint256 i = 0; i &lt; NUM_TOKENS; i++) {</span>
  64 | *   | <span class='executed'>            bytes32 projectId = keccak256(abi.encodePacked(i));</span>
  65 | *   | <span class='executed'>            registry.registerProject(projectId, &quot;uri&quot;); // Step 1: Register</span>
  66 | *   | <span class='executed'>            registry.setProjectStatus(projectId, ProjectRegistry.ProjectStatus.Active);</span>
  67 | *   | <span class='executed'>            credit.mintCredits(address(this), projectId, INITIAL_MINT_AMOUNT, &quot;token_uri&quot;);</span>
  68 |     | <span class='neutral'>        }</span>
  69 |     | <span class='neutral'></span>
  70 |     | <span class='neutral'>        // --- Distribute Assets ---</span>
  71 |     | <span class='neutral'>        // Give this test contract approval to manage its own tokens on the marketplace</span>
  72 | *   | <span class='executed'>        credit.setApprovalForAll(address(marketplace), true);</span>
  73 |     | <span class='neutral'></span>
  74 |     | <span class='neutral'>        // Give all our fake users some payment tokens and approve the marketplace</span>
  75 | *   | <span class='executed'>        for (uint256 i = 0; i &lt; users.length; i++) {</span>
  76 | *   | <span class='executed'>            vm.startPrank(users[i]);</span>
  77 | *   | <span class='executed'>            paymentToken.mint(users[i], INITIAL_PAYMENT_BALANCE);</span>
  78 | *   | <span class='executed'>            paymentToken.approve(address(marketplace), type(uint256).max);</span>
  79 | *   | <span class='executed'>            vm.stopPrank();</span>
  80 |     | <span class='neutral'>        }</span>
  81 |     | <span class='neutral'>    }</span>
  82 |     | <span class='neutral'></span>
  83 |     | <span class='neutral'>    // =================================================================</span>
  84 |     | <span class='neutral'>    //                           INVARIANTS</span>
  85 |     | <span class='neutral'>    // =================================================================</span>
  86 |     | <span class='neutral'></span>
  87 |     | <span class='neutral'>    /// @dev Property: An active listing must always have a price greater than zero.</span>
  88 |     | <span class='unexecuted'>    function echidna_active_listing_has_price() public view returns (bool) {</span>
  89 |     | <span class='unexecuted'>        uint256 counter = marketplace.listingIdCounter();</span>
  90 |     | <span class='unexecuted'>        for (uint256 i = 0; i &lt; counter; i++) {</span>
  91 |     | <span class='unexecuted'>            (,,, uint256 pricePerUnit,, , bool active) = marketplace.listings(i);</span>
  92 |     | <span class='unexecuted'>            if (active) {</span>
  93 |     | <span class='unexecuted'>                if (pricePerUnit == 0) return false;</span>
  94 |     | <span class='neutral'>            }</span>
  95 |     | <span class='neutral'>        }</span>
  96 |     | <span class='neutral'>        return true;</span>
  97 |     | <span class='neutral'>    }</span>
  98 |     | <span class='neutral'></span>
  99 |     | <span class='neutral'>    /// @dev Property: An active listing&#39;s seller cannot be the zero address.</span>
 100 | *   | <span class='executed'>    function echidna_active_listing_has_seller() public view returns (bool) {</span>
 101 |     | <span class='unexecuted'>        uint256 counter = marketplace.listingIdCounter();</span>
 102 |     | <span class='unexecuted'>        for (uint256 i = 0; i &lt; counter; i++) {</span>
 103 |     | <span class='unexecuted'>            (,,,, address seller, , bool active) = marketplace.listings(i);</span>
 104 |     | <span class='unexecuted'>            if (active) {</span>
 105 |     | <span class='unexecuted'>                if (seller == address(0)) return false;</span>
 106 |     | <span class='neutral'>            }</span>
 107 |     | <span class='neutral'>        }</span>
 108 |     | <span class='unexecuted'>        return true;</span>
 109 |     | <span class='neutral'>    }</span>
 110 |     | <span class='neutral'></span>
 111 |     | <span class='neutral'>    /// @dev Property: The marketplace contract&#39;s token balance for a given tokenId</span>
 112 |     | <span class='neutral'>    /// should equal the sum of all active listings for that tokenId.</span>
 113 |     | <span class='unexecuted'>    function echidna_marketplace_holds_listed_tokens() public view returns (bool) {</span>
 114 |     | <span class='unexecuted'>        uint256 listingCounter = marketplace.listingIdCounter();</span>
 115 |     | <span class='neutral'></span>
 116 |     | <span class='neutral'>        // Check this invariant for each token type we created.</span>
 117 |     | <span class='unexecuted'>        for (uint256 i = 0; i &lt; NUM_TOKENS; i++) {</span>
 118 |     | <span class='unexecuted'>            bytes32 projectId = keccak256(abi.encodePacked(i));</span>
 119 |     | <span class='unexecuted'>            uint256 currentTokenId = uint256(projectId);</span>
 120 |     | <span class='neutral'>            uint256 totalListedForToken = 0;</span>
 121 |     | <span class='neutral'></span>
 122 |     | <span class='neutral'>            // Sum up all active listings for the current tokenId.</span>
 123 |     | <span class='unexecuted'>            for (uint256 j = 0; j &lt; listingCounter; j++) {</span>
 124 |     | <span class='unexecuted'>                (, uint256 listedTokenId, uint256 amount,, , , bool active) = marketplace.listings(j);</span>
 125 |     | <span class='unexecuted'>                if (active &amp;&amp; listedTokenId == currentTokenId) {</span>
 126 |     | <span class='unexecuted'>                    totalListedForToken += amount;</span>
 127 |     | <span class='neutral'>                }</span>
 128 |     | <span class='neutral'>            }</span>
 129 |     | <span class='neutral'></span>
 130 |     | <span class='neutral'>            // The marketplace&#39;s balance should match the sum of active listings.</span>
 131 |     | <span class='unexecuted'>            if (credit.balanceOf(address(marketplace), currentTokenId) != totalListedForToken) {</span>
 132 |     | <span class='unexecuted'>                return false;</span>
 133 |     | <span class='neutral'>            }</span>
 134 |     | <span class='neutral'>        }</span>
 135 |     | <span class='neutral'></span>
 136 |     | <span class='neutral'>        return true;</span>
 137 |     | <span class='neutral'>    }</span>
 138 |     | <span class='neutral'></span>
 139 |     | <span class='neutral'>    // =================================================================</span>
 140 |     | <span class='neutral'>    //                      STATE-CHANGING FUNCTIONS</span>
 141 |     | <span class='neutral'>    // =================================================================</span>
 142 |     | <span class='neutral'>    // These wrappers guide Echidna to call the marketplace functions</span>
 143 |     | <span class='neutral'>    // with valid (or at least semi-valid) parameters.</span>
 144 |     | <span class='neutral'></span>
 145 | *   | <span class='executed'>    function list(uint256 tokenId, uint256 amount, uint256 price, uint256 duration) public {</span>
 146 | *   | <span class='executed'>        tokenId = constrain(tokenId, 0, NUM_TOKENS - 1);</span>
 147 | *   | <span class='executed'>        amount = constrain(amount, 1, INITIAL_MINT_AMOUNT); // list at least 1</span>
 148 | *   | <span class='executed'>        price = constrain(price, 1, 1000 ether); // price must be &gt; 0</span>
 149 | *   | <span class='executed'>        duration = constrain(duration, 1, 365 days); // duration must be &gt; 0</span>
 150 |     | <span class='neutral'></span>
 151 | *   | <span class='executed'>        bytes32 projectId = keccak256(abi.encodePacked(tokenId));</span>
 152 | *   | <span class='executed'>        uint256 realTokenId = uint256(projectId);</span>
 153 |     | <span class='neutral'></span>
 154 |     | <span class='neutral'>        // Ensure we don&#39;t try to list more than we have.</span>
 155 | *   | <span class='executed'>        uint256 balance = credit.balanceOf(address(this), realTokenId);</span>
 156 | *   | <span class='executed'>        if (amount &gt; balance) {</span>
 157 | *   | <span class='executed'>            amount = balance;</span>
 158 |     | <span class='neutral'>        }</span>
 159 | *   | <span class='executed'>        if (amount == 0) return;</span>
 160 |     | <span class='neutral'></span>
 161 | *   | <span class='executed'>        marketplace.list(realTokenId, amount, price, duration);</span>
 162 |     | <span class='neutral'>    }</span>
 163 |     | <span class='neutral'></span>
 164 | *   | <span class='executed'>    function buy(uint256 listingId, uint256 amountToBuy) public {</span>
 165 | *   | <span class='executed'>        uint256 counter = marketplace.listingIdCounter();</span>
 166 | *   | <span class='executed'>        if (counter == 0) return;</span>
 167 |     | <span class='neutral'></span>
 168 | *   | <span class='executed'>        listingId = constrain(listingId, 0, counter - 1);</span>
 169 | *   | <span class='executed'>        address buyer = users[listingId % NUM_USERS]; // Pick a random user</span>
 170 |     | <span class='neutral'></span>
 171 | *   | <span class='executed'>        (</span>
 172 |     | <span class='neutral'>            , // id</span>
 173 |     | <span class='neutral'>            , // tokenId</span>
 174 |     | <span class='neutral'>            uint256 amount,</span>
 175 |     | <span class='neutral'>            uint256 pricePerUnit,</span>
 176 |     | <span class='neutral'>            address seller,</span>
 177 |     | <span class='neutral'>            uint64 expiryTimestamp,</span>
 178 |     | <span class='neutral'>            bool active</span>
 179 | *   | <span class='executed'>        ) = marketplace.listings(listingId);</span>
 180 |     | <span class='neutral'></span>
 181 | *   | <span class='executed'>        if (!active || expiryTimestamp &lt; block.timestamp || seller == buyer) return;</span>
 182 |     | <span class='neutral'></span>
 183 | *   | <span class='executed'>        amountToBuy = constrain(amountToBuy, 1, amount);</span>
 184 |     | <span class='neutral'></span>
 185 | *   | <span class='executed'>        uint256 cost = amountToBuy * pricePerUnit;</span>
 186 | *   | <span class='executed'>        if (paymentToken.balanceOf(buyer) &lt; cost) return;</span>
 187 |     | <span class='neutral'></span>
 188 | *   | <span class='executed'>        vm.prank(buyer);</span>
 189 | *   | <span class='executed'>        marketplace.buy(listingId, amountToBuy);</span>
 190 |     | <span class='neutral'>    }</span>
 191 |     | <span class='neutral'></span>
 192 | *   | <span class='executed'>    function cancelListing(uint256 listingId) public {</span>
 193 | *   | <span class='executed'>        uint256 counter = marketplace.listingIdCounter();</span>
 194 | *   | <span class='executed'>        if (counter == 0) return;</span>
 195 | *   | <span class='executed'>        listingId = constrain(listingId, 0, counter - 1);</span>
 196 |     | <span class='neutral'></span>
 197 | *   | <span class='executed'>        (,,,, address seller,, bool active) = marketplace.listings(listingId);</span>
 198 | *   | <span class='executed'>        if (seller != address(this) || !active) return; // Only contract can cancel its own ACTIVE listings</span>
 199 |     | <span class='neutral'></span>
 200 | *r  | <span class='executed'>        marketplace.cancelListing(listingId);</span>
 201 |     | <span class='neutral'>    }</span>
 202 |     | <span class='neutral'></span>
 203 |     | <span class='neutral'>    // --- Helper function to constrain Echidna&#39;s random inputs ---</span>
 204 | *   | <span class='executed'>    function constrain(uint256 val, uint256 min, uint256 max) internal pure returns (uint256) {</span>
 205 | *   | <span class='executed'>        if (min &gt;= max) {</span>
 206 | *   | <span class='executed'>            return min;</span>
 207 |     | <span class='neutral'>        }</span>
 208 |     | <span class='neutral'>        // Use modulo to wrap the value into the range [min, max]</span>
 209 | *   | <span class='executed'>        return (val % (max - min + 1)) + min;</span>
 210 |     | <span class='neutral'>    }</span>
 211 |     | <span class='neutral'></span>
 212 |     | <span class='neutral'>        // --- Helper function to bound Echidna&#39;s random inputs ---</span>
 213 |     | <span class='neutral'>    function bound(</span>
 214 |     | <span class='neutral'>        uint256 val,</span>
 215 |     | <span class='neutral'>        uint256 min,</span>
 216 |     | <span class='neutral'>        uint256 max</span>
 217 |     | <span class='neutral'>    ) internal override pure returns (uint256) {</span>
 218 |     | <span class='neutral'>        return uint256(int256(val) % int256(max - min)) + min;</span>
 219 |     | <span class='neutral'>    }</span>
 220 |     | <span class='neutral'>} </span>

</code>
<br />

<b>/home/phantom/Documents/azemora/azemora-contracts/test/governance/Governance.complex.t.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'>pragma solidity ^0.8.20;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>import &quot;forge-std/Test.sol&quot;;</span>
   5 |     | <span class='neutral'>import &quot;../../src/token/AzemoraToken.sol&quot;;</span>
   6 |     | <span class='neutral'>import &quot;../../src/governance/AzemoraGovernor.sol&quot;;</span>
   7 |     | <span class='neutral'>import &quot;../../src/governance/AzemoraTimelockController.sol&quot;;</span>
   8 |     | <span class='neutral'>import &quot;@openzeppelin/contracts-upgradeable/governance/GovernorUpgradeable.sol&quot;;</span>
   9 |     | <span class='neutral'>import &quot;../../src/governance/Treasury.sol&quot;;</span>
  10 |     | <span class='neutral'>import &quot;../../src/marketplace/Marketplace.sol&quot;;</span>
  11 |     | <span class='neutral'>import &quot;../../src/core/DynamicImpactCredit.sol&quot;;</span>
  12 |     | <span class='neutral'>import &quot;../../src/core/ProjectRegistry.sol&quot;;</span>
  13 |     | <span class='neutral'>import &quot;@openzeppelin/contracts/proxy/ERC1967/ERC1967Proxy.sol&quot;;</span>
  14 |     | <span class='neutral'></span>
  15 |     | <span class='neutral'>// A mock ERC20 is needed for the Marketplace setup.</span>
  16 |     | <span class='unexecuted'>contract MockERC20ForGovTest {</span>
  17 |     | <span class='unexecuted'>    function mint(address, uint256) public {}</span>
  18 |     | <span class='neutral'>}</span>
  19 |     | <span class='neutral'></span>
  20 |     | <span class='unexecuted'>contract GovernanceComplexTest is Test {</span>
  21 |     | <span class='neutral'>    // Use addresses instead of contract references to avoid conversion issues</span>
  22 |     | <span class='neutral'>    AzemoraToken token;</span>
  23 |     | <span class='unexecuted'>    address payable public timelockAddr;</span>
  24 |     | <span class='unexecuted'>    address payable public governorAddr;</span>
  25 |     | <span class='unexecuted'>    address payable public treasuryAddr;</span>
  26 |     | <span class='neutral'>    Marketplace marketplace;</span>
  27 |     | <span class='neutral'>    DynamicImpactCredit credit;</span>
  28 |     | <span class='neutral'>    MockERC20ForGovTest paymentToken;</span>
  29 |     | <span class='neutral'></span>
  30 |     | <span class='neutral'>    // Users</span>
  31 |     | <span class='neutral'>    address admin;</span>
  32 |     | <span class='unexecuted'>    address voter = makeAddr(&quot;voter&quot;);</span>
  33 |     | <span class='unexecuted'>    address voter2 = makeAddr(&quot;voter2&quot;);</span>
  34 |     | <span class='unexecuted'>    address poorVoter = makeAddr(&quot;poorVoter&quot;);</span>
  35 |     | <span class='unexecuted'>    address recipient = makeAddr(&quot;recipient&quot;);</span>
  36 |     | <span class='neutral'></span>
  37 |     | <span class='neutral'>    // Governance settings</span>
  38 |     | <span class='unexecuted'>    uint256 constant VOTING_DELAY = 1; // blocks</span>
  39 |     | <span class='unexecuted'>    uint256 constant VOTING_PERIOD = 5; // blocks</span>
  40 |     | <span class='unexecuted'>    uint256 constant MIN_DELAY = 1; // seconds</span>
  41 |     | <span class='unexecuted'>    uint256 constant PROPOSAL_THRESHOLD = 1000e18;</span>
  42 |     | <span class='neutral'></span>
  43 |     | <span class='unexecuted'>    function setUp() public {</span>
  44 |     | <span class='unexecuted'>        admin = address(this);</span>
  45 |     | <span class='neutral'></span>
  46 |     | <span class='neutral'>        // 1. Deploy Governance Token</span>
  47 |     | <span class='unexecuted'>        AzemoraToken tokenImpl = new AzemoraToken();</span>
  48 |     | <span class='unexecuted'>        bytes memory tokenInitData = abi.encodeCall(AzemoraToken.initialize, ());</span>
  49 |     | <span class='unexecuted'>        ERC1967Proxy tokenProxy = new ERC1967Proxy(address(tokenImpl), tokenInitData);</span>
  50 |     | <span class='unexecuted'>        token = AzemoraToken(address(tokenProxy));</span>
  51 |     | <span class='neutral'></span>
  52 |     | <span class='neutral'>        // 2. Deploy Timelock</span>
  53 |     | <span class='unexecuted'>        AzemoraTimelockController timelockImpl = new AzemoraTimelockController();</span>
  54 |     | <span class='unexecuted'>        bytes memory timelockInitData =</span>
  55 |     | <span class='unexecuted'>            abi.encodeCall(AzemoraTimelockController.initialize, (MIN_DELAY, new address[](0), new address[](0), admin));</span>
  56 |     | <span class='unexecuted'>        ERC1967Proxy timelockProxy = new ERC1967Proxy(address(timelockImpl), timelockInitData);</span>
  57 |     | <span class='unexecuted'>        timelockAddr = payable(address(timelockProxy));</span>
  58 |     | <span class='neutral'></span>
  59 |     | <span class='neutral'>        // 3. Deploy Governor</span>
  60 |     | <span class='unexecuted'>        AzemoraGovernor governorImpl = new AzemoraGovernor();</span>
  61 |     | <span class='unexecuted'>        bytes memory governorInitData = abi.encodeCall(</span>
  62 |     | <span class='neutral'>            AzemoraGovernor.initialize,</span>
  63 |     | <span class='neutral'>            (</span>
  64 |     | <span class='unexecuted'>                token,</span>
  65 |     | <span class='unexecuted'>                AzemoraTimelockController(timelockAddr),</span>
  66 |     | <span class='neutral'>                uint48(VOTING_DELAY),</span>
  67 |     | <span class='neutral'>                uint32(VOTING_PERIOD),</span>
  68 |     | <span class='neutral'>                PROPOSAL_THRESHOLD</span>
  69 |     | <span class='neutral'>            )</span>
  70 |     | <span class='neutral'>        );</span>
  71 |     | <span class='unexecuted'>        ERC1967Proxy governorProxy = new ERC1967Proxy(address(governorImpl), governorInitData);</span>
  72 |     | <span class='unexecuted'>        governorAddr = payable(address(governorProxy));</span>
  73 |     | <span class='neutral'></span>
  74 |     | <span class='neutral'>        // 4. Deploy Treasury</span>
  75 |     | <span class='unexecuted'>        Treasury treasuryImpl = new Treasury();</span>
  76 |     | <span class='unexecuted'>        bytes memory treasuryInitData = abi.encodeCall(Treasury.initialize, (admin));</span>
  77 |     | <span class='unexecuted'>        ERC1967Proxy treasuryProxy = new ERC1967Proxy(address(treasuryImpl), treasuryInitData);</span>
  78 |     | <span class='unexecuted'>        treasuryAddr = payable(address(treasuryProxy));</span>
  79 |     | <span class='neutral'></span>
  80 |     | <span class='neutral'>        // 5. Deploy Marketplace and its dependencies</span>
  81 |     | <span class='unexecuted'>        paymentToken = new MockERC20ForGovTest();</span>
  82 |     | <span class='neutral'></span>
  83 |     | <span class='unexecuted'>        ProjectRegistry registryImpl = new ProjectRegistry();</span>
  84 |     | <span class='unexecuted'>        bytes memory registryInitData = abi.encodeCall(ProjectRegistry.initialize, ());</span>
  85 |     | <span class='unexecuted'>        ERC1967Proxy registryProxy = new ERC1967Proxy(address(registryImpl), registryInitData);</span>
  86 |     | <span class='unexecuted'>        ProjectRegistry registry = ProjectRegistry(address(registryProxy));</span>
  87 |     | <span class='neutral'></span>
  88 |     | <span class='unexecuted'>        DynamicImpactCredit creditImpl = new DynamicImpactCredit(address(registry));</span>
  89 |     | <span class='unexecuted'>        bytes memory creditInitData = abi.encodeCall(DynamicImpactCredit.initialize, (&quot;uri&quot;));</span>
  90 |     | <span class='unexecuted'>        credit = DynamicImpactCredit(address(new ERC1967Proxy(address(creditImpl), creditInitData)));</span>
  91 |     | <span class='neutral'></span>
  92 |     | <span class='neutral'>        // Roles</span>
  93 |     | <span class='unexecuted'>        credit.grantRole(credit.DMRV_MANAGER_ROLE(), address(this)); // test contract is minter</span>
  94 |     | <span class='neutral'></span>
  95 |     | <span class='unexecuted'>        Marketplace marketplaceImpl = new Marketplace();</span>
  96 |     | <span class='unexecuted'>        bytes memory marketplaceInitData =</span>
  97 |     | <span class='unexecuted'>            abi.encodeCall(Marketplace.initialize, (address(credit), address(paymentToken)));</span>
  98 |     | <span class='unexecuted'>        ERC1967Proxy marketplaceProxy = new ERC1967Proxy(address(marketplaceImpl), marketplaceInitData);</span>
  99 |     | <span class='unexecuted'>        marketplace = Marketplace(address(marketplaceProxy));</span>
 100 |     | <span class='neutral'></span>
 101 |     | <span class='neutral'>        // 6. Configure Roles &amp; Ownership</span>
 102 |     | <span class='unexecuted'>        bytes32 proposerRole = AzemoraTimelockController(timelockAddr).PROPOSER_ROLE();</span>
 103 |     | <span class='unexecuted'>        bytes32 executorRole = AzemoraTimelockController(timelockAddr).EXECUTOR_ROLE();</span>
 104 |     | <span class='neutral'>        // bytes32 timelockAdminRole = AzemoraTimelockController(timelockAddr).DEFAULT_ADMIN_ROLE();</span>
 105 |     | <span class='neutral'></span>
 106 |     | <span class='unexecuted'>        AzemoraTimelockController(timelockAddr).grantRole(proposerRole, governorAddr);</span>
 107 |     | <span class='unexecuted'>        AzemoraTimelockController(timelockAddr).grantRole(executorRole, address(0)); // Anyone can execute</span>
 108 |     | <span class='neutral'></span>
 109 |     | <span class='neutral'>        // Transfer ownership/admin of manageable contracts to the Timelock itself.</span>
 110 |     | <span class='unexecuted'>        bytes32 marketplaceAdminRole = marketplace.DEFAULT_ADMIN_ROLE();</span>
 111 |     | <span class='unexecuted'>        marketplace.grantRole(marketplaceAdminRole, timelockAddr);</span>
 112 |     | <span class='unexecuted'>        marketplace.renounceRole(marketplaceAdminRole, admin);</span>
 113 |     | <span class='neutral'></span>
 114 |     | <span class='unexecuted'>        Treasury(treasuryAddr).transferOwnership(timelockAddr);</span>
 115 |     | <span class='neutral'></span>
 116 |     | <span class='neutral'>        // DO NOT RENOUNCE THE ADMIN ROLE. The test will fail if the timelock is headless.</span>
 117 |     | <span class='neutral'>        // This line was the root cause of the silent queue failures.</span>
 118 |     | <span class='neutral'>        // AzemoraTimelockController(timelockAddr).renounceRole(timelockAdminRole, admin);</span>
 119 |     | <span class='neutral'></span>
 120 |     | <span class='neutral'>        // 7. Distribute tokens and set up voters</span>
 121 |     | <span class='unexecuted'>        token.transfer(voter, 50_000_000e18);</span>
 122 |     | <span class='unexecuted'>        token.transfer(voter2, 60_000_000e18);</span>
 123 |     | <span class='unexecuted'>        token.transfer(poorVoter, 1e18);</span>
 124 |     | <span class='neutral'></span>
 125 |     | <span class='unexecuted'>        vm.prank(voter);</span>
 126 |     | <span class='unexecuted'>        token.delegate(voter);</span>
 127 |     | <span class='neutral'></span>
 128 |     | <span class='unexecuted'>        vm.prank(voter2);</span>
 129 |     | <span class='unexecuted'>        token.delegate(voter2);</span>
 130 |     | <span class='neutral'></span>
 131 |     | <span class='unexecuted'>        vm.prank(poorVoter);</span>
 132 |     | <span class='unexecuted'>        token.delegate(poorVoter);</span>
 133 |     | <span class='neutral'></span>
 134 |     | <span class='unexecuted'>        vm.deal(treasuryAddr, 10 ether);</span>
 135 |     | <span class='unexecuted'>        vm.roll(block.number + 1);</span>
 136 |     | <span class='neutral'>    }</span>
 137 |     | <span class='neutral'></span>
 138 |     | <span class='neutral'>    /**</span>
 139 |     | <span class='neutral'>     * @dev A complex test to ensure governance can update its own settings.</span>
 140 |     | <span class='neutral'>     */</span>
 141 |     | <span class='unexecuted'>    function test_Complex_Update_Governor_Settings() public {</span>
 142 |     | <span class='unexecuted'>        uint48 newVotingDelay = 2;</span>
 143 |     | <span class='unexecuted'>        uint32 newVotingPeriod = 10;</span>
 144 |     | <span class='neutral'></span>
 145 |     | <span class='neutral'>        // Propose changing the governor&#39;s settings. This requires two separate calls.</span>
 146 |     | <span class='unexecuted'>        address[] memory targets = new address[](2);</span>
 147 |     | <span class='unexecuted'>        targets[0] = governorAddr;</span>
 148 |     | <span class='unexecuted'>        targets[1] = governorAddr;</span>
 149 |     | <span class='unexecuted'>        uint256[] memory values = new uint256[](2); // No ETH</span>
 150 |     | <span class='unexecuted'>        bytes[] memory calldatas = new bytes[](2);</span>
 151 |     | <span class='unexecuted'>        calldatas[0] = abi.encodeWithSignature(&quot;setVotingDelay(uint48)&quot;, newVotingDelay);</span>
 152 |     | <span class='unexecuted'>        calldatas[1] = abi.encodeWithSignature(&quot;setVotingPeriod(uint32)&quot;, newVotingPeriod);</span>
 153 |     | <span class='neutral'></span>
 154 |     | <span class='unexecuted'>        string memory description = &quot;Update Governor voting settings&quot;;</span>
 155 |     | <span class='unexecuted'>        bytes32 descriptionHash = keccak256(bytes(description));</span>
 156 |     | <span class='neutral'></span>
 157 |     | <span class='neutral'>        // Full proposal lifecycle</span>
 158 |     | <span class='unexecuted'>        vm.prank(voter);</span>
 159 |     | <span class='unexecuted'>        uint256 proposalId = AzemoraGovernor(governorAddr).propose(targets, values, calldatas, description);</span>
 160 |     | <span class='unexecuted'>        vm.roll(block.number + VOTING_DELAY + 1);</span>
 161 |     | <span class='unexecuted'>        vm.prank(voter);</span>
 162 |     | <span class='unexecuted'>        AzemoraGovernor(governorAddr).castVote(proposalId, 1); // Vote For</span>
 163 |     | <span class='unexecuted'>        vm.roll(block.number + VOTING_PERIOD + 1);</span>
 164 |     | <span class='unexecuted'>        AzemoraGovernor(governorAddr).queue(targets, values, calldatas, descriptionHash);</span>
 165 |     | <span class='unexecuted'>        vm.warp(block.timestamp + MIN_DELAY + 1);</span>
 166 |     | <span class='unexecuted'>        AzemoraGovernor(governorAddr).execute(targets, values, calldatas, descriptionHash);</span>
 167 |     | <span class='neutral'></span>
 168 |     | <span class='neutral'>        // Verify the new settings are active</span>
 169 |     | <span class='unexecuted'>        assertEq(AzemoraGovernor(governorAddr).votingDelay(), newVotingDelay, &quot;Voting delay should be updated&quot;);</span>
 170 |     | <span class='unexecuted'>        assertEq(AzemoraGovernor(governorAddr).votingPeriod(), newVotingPeriod, &quot;Voting period should be updated&quot;);</span>
 171 |     | <span class='neutral'>    }</span>
 172 |     | <span class='neutral'></span>
 173 |     | <span class='neutral'>    /**</span>
 174 |     | <span class='neutral'>     * @dev A complex test to ensure a proposal passes when the quorum is met exactly.</span>
 175 |     | <span class='neutral'>     */</span>
 176 |     | <span class='unexecuted'>    function test_Complex_Quorum_Met_Exactly_At_Boundary() public {</span>
 177 |     | <span class='neutral'>        // The quorum is 4% of 1B tokens = 40M tokens.</span>
 178 |     | <span class='unexecuted'>        uint256 quorumVotes = 40_000_000e18;</span>
 179 |     | <span class='unexecuted'>        address quorumVoter = makeAddr(&quot;quorumVoter&quot;);</span>
 180 |     | <span class='neutral'></span>
 181 |     | <span class='neutral'>        // Setup the voter with the exact amount of tokens needed for quorum.</span>
 182 |     | <span class='unexecuted'>        token.transfer(quorumVoter, quorumVotes);</span>
 183 |     | <span class='unexecuted'>        vm.prank(quorumVoter);</span>
 184 |     | <span class='unexecuted'>        token.delegate(quorumVoter);</span>
 185 |     | <span class='unexecuted'>        vm.roll(block.number + 1); // Let delegation register.</span>
 186 |     | <span class='neutral'></span>
 187 |     | <span class='neutral'>        // Propose a simple action.</span>
 188 |     | <span class='unexecuted'>        address[] memory targets = new address[](1);</span>
 189 |     | <span class='unexecuted'>        targets[0] = address(marketplace);</span>
 190 |     | <span class='unexecuted'>        uint256[] memory values = new uint256[](1);</span>
 191 |     | <span class='unexecuted'>        bytes[] memory calldatas = new bytes[](1);</span>
 192 |     | <span class='unexecuted'>        calldatas[0] = abi.encodeWithSelector(Marketplace.setFee.selector, 300); // Set fee to 3%</span>
 193 |     | <span class='unexecuted'>        string memory description = &quot;Proposal to set fee to 3% with exact quorum&quot;;</span>
 194 |     | <span class='unexecuted'>        bytes32 descriptionHash = keccak256(bytes(description));</span>
 195 |     | <span class='neutral'></span>
 196 |     | <span class='neutral'>        // Propose the action.</span>
 197 |     | <span class='unexecuted'>        vm.prank(quorumVoter);</span>
 198 |     | <span class='unexecuted'>        uint256 proposalId = AzemoraGovernor(governorAddr).propose(targets, values, calldatas, description);</span>
 199 |     | <span class='neutral'></span>
 200 |     | <span class='neutral'>        // Vote on the proposal.</span>
 201 |     | <span class='unexecuted'>        vm.roll(block.number + VOTING_DELAY + 1);</span>
 202 |     | <span class='unexecuted'>        vm.prank(quorumVoter);</span>
 203 |     | <span class='unexecuted'>        AzemoraGovernor(governorAddr).castVote(proposalId, 1); // Vote For.</span>
 204 |     | <span class='neutral'></span>
 205 |     | <span class='neutral'>        // End the voting period.</span>
 206 |     | <span class='unexecuted'>        vm.roll(block.number + VOTING_PERIOD + 1);</span>
 207 |     | <span class='neutral'></span>
 208 |     | <span class='neutral'>        // Check that the proposal is now in the &quot;Succeeded&quot; state.</span>
 209 |     | <span class='unexecuted'>        assertEq(uint256(AzemoraGovernor(governorAddr).state(proposalId)), 4, &quot;Proposal should be Succeeded&quot;);</span>
 210 |     | <span class='neutral'></span>
 211 |     | <span class='neutral'>        // Queue and execute to confirm the whole flow works.</span>
 212 |     | <span class='unexecuted'>        AzemoraGovernor(governorAddr).queue(targets, values, calldatas, descriptionHash);</span>
 213 |     | <span class='unexecuted'>        vm.warp(block.timestamp + MIN_DELAY + 1);</span>
 214 |     | <span class='unexecuted'>        AzemoraGovernor(governorAddr).execute(targets, values, calldatas, descriptionHash);</span>
 215 |     | <span class='neutral'></span>
 216 |     | <span class='unexecuted'>        assertEq(marketplace.feeBps(), 300, &quot;Marketplace fee should be updated&quot;);</span>
 217 |     | <span class='neutral'>    }</span>
 218 |     | <span class='neutral'></span>
 219 |     | <span class='neutral'>    /**</span>
 220 |     | <span class='neutral'>     * @dev Ensures a proposal cannot be queued or executed again after it has already been executed.</span>
 221 |     | <span class='neutral'>     * This prevents replay attacks.</span>
 222 |     | <span class='neutral'>     */</span>
 223 |     | <span class='unexecuted'>    function test_ReplayAttack_FailsAfterExecution() public {</span>
 224 |     | <span class='neutral'>        // --- Create and pass a proposal ---</span>
 225 |     | <span class='unexecuted'>        address[] memory targets = new address[](1);</span>
 226 |     | <span class='unexecuted'>        targets[0] = address(marketplace);</span>
 227 |     | <span class='unexecuted'>        uint256[] memory values = new uint256[](1);</span>
 228 |     | <span class='unexecuted'>        bytes[] memory calldatas = new bytes[](1);</span>
 229 |     | <span class='unexecuted'>        calldatas[0] = abi.encodeWithSelector(Marketplace.setFee.selector, 600); // Set fee to 6%</span>
 230 |     | <span class='unexecuted'>        string memory description = &quot;Proposal to set fee to 6%&quot;;</span>
 231 |     | <span class='unexecuted'>        bytes32 descriptionHash = keccak256(bytes(description));</span>
 232 |     | <span class='neutral'></span>
 233 |     | <span class='unexecuted'>        vm.prank(voter);</span>
 234 |     | <span class='unexecuted'>        uint256 proposalId = AzemoraGovernor(governorAddr).propose(targets, values, calldatas, description);</span>
 235 |     | <span class='neutral'></span>
 236 |     | <span class='unexecuted'>        vm.roll(block.number + VOTING_DELAY + 1);</span>
 237 |     | <span class='unexecuted'>        vm.prank(voter);</span>
 238 |     | <span class='unexecuted'>        AzemoraGovernor(governorAddr).castVote(proposalId, 1);</span>
 239 |     | <span class='unexecuted'>        vm.roll(block.number + VOTING_PERIOD + 1);</span>
 240 |     | <span class='neutral'></span>
 241 |     | <span class='neutral'>        // --- Execute the proposal successfully ---</span>
 242 |     | <span class='unexecuted'>        AzemoraGovernor(governorAddr).queue(targets, values, calldatas, descriptionHash);</span>
 243 |     | <span class='unexecuted'>        vm.warp(block.timestamp + MIN_DELAY + 1);</span>
 244 |     | <span class='unexecuted'>        AzemoraGovernor(governorAddr).execute(targets, values, calldatas, descriptionHash);</span>
 245 |     | <span class='unexecuted'>        assertEq(</span>
 246 |     | <span class='unexecuted'>            7, // Executed</span>
 247 |     | <span class='unexecuted'>            uint256(AzemoraGovernor(governorAddr).state(proposalId)),</span>
 248 |     | <span class='neutral'>            &quot;Proposal should be Executed&quot;</span>
 249 |     | <span class='neutral'>        );</span>
 250 |     | <span class='unexecuted'>        assertEq(marketplace.feeBps(), 600, &quot;Marketplace fee should be updated&quot;);</span>
 251 |     | <span class='neutral'></span>
 252 |     | <span class='neutral'>        // --- Assert replay attacks fail ---</span>
 253 |     | <span class='neutral'></span>
 254 |     | <span class='neutral'>        // 1. Attempting to queue again should fail because the proposal is not in the &#39;Succeeded&#39; state.</span>
 255 |     | <span class='unexecuted'>        try AzemoraGovernor(governorAddr).queue(targets, values, calldatas, descriptionHash) {</span>
 256 |     | <span class='unexecuted'>            fail();</span>
 257 |     | <span class='unexecuted'>        } catch (bytes memory reason) {</span>
 258 |     | <span class='neutral'>            // This will log the exact revert data to the console.</span>
 259 |     | <span class='unexecuted'>            console.log(&quot;Revert data from queue:&quot;);</span>
 260 |     | <span class='unexecuted'>            console.logBytes(reason);</span>
 261 |     | <span class='neutral'>        }</span>
 262 |     | <span class='neutral'></span>
 263 |     | <span class='neutral'>        /*</span>
 264 |     | <span class='neutral'>        // 2. Attempting to execute again should fail because the proposal is not in the &#39;Queued&#39; state.</span>
 265 |     | <span class='neutral'>        bytes memory expectedRevertDataExecute =</span>
 266 |     | <span class='neutral'>            abi.encodeWithSignature(&quot;GovernorUnexpectedProposalState(uint256,uint256)&quot;, proposalId, 7); // current state is Executed</span>
 267 |     | <span class='neutral'>        vm.expectRevert(expectedRevertDataExecute);</span>
 268 |     | <span class='neutral'>        AzemoraGovernor(governorAddr).execute(targets, values, calldatas, descriptionHash);</span>
 269 |     | <span class='neutral'>        */</span>
 270 |     | <span class='neutral'>    }</span>
 271 |     | <span class='neutral'></span>
 272 |     | <span class='neutral'>    /**</span>
 273 |     | <span class='neutral'>     * @dev Ensures two proposals with identical logic but different salts are treated as unique operations.</span>
 274 |     | <span class='neutral'>     */</span>
 275 |     | <span class='unexecuted'>    function test_Timelock_HashClash_Succeeds() public {</span>
 276 |     | <span class='neutral'>        // --- Create two proposals with the same execution logic but different descriptions ---</span>
 277 |     | <span class='unexecuted'>        address[] memory targets = new address[](1);</span>
 278 |     | <span class='unexecuted'>        targets[0] = address(marketplace);</span>
 279 |     | <span class='unexecuted'>        uint256[] memory values = new uint256[](1);</span>
 280 |     | <span class='unexecuted'>        bytes[] memory calldatas = new bytes[](1);</span>
 281 |     | <span class='unexecuted'>        calldatas[0] = abi.encodeWithSelector(Marketplace.setFee.selector, 800); // Set fee to 8%</span>
 282 |     | <span class='neutral'></span>
 283 |     | <span class='unexecuted'>        string memory description1 = &quot;Set fee to 8% (Monday)&quot;;</span>
 284 |     | <span class='unexecuted'>        bytes32 descriptionHash1 = keccak256(bytes(description1));</span>
 285 |     | <span class='unexecuted'>        string memory description2 = &quot;Set fee to 8% (Tuesday)&quot;;</span>
 286 |     | <span class='unexecuted'>        bytes32 descriptionHash2 = keccak256(bytes(description2));</span>
 287 |     | <span class='neutral'></span>
 288 |     | <span class='neutral'>        // Propose both</span>
 289 |     | <span class='unexecuted'>        vm.prank(voter);</span>
 290 |     | <span class='unexecuted'>        uint256 proposalId1 = AzemoraGovernor(governorAddr).propose(targets, values, calldatas, description1);</span>
 291 |     | <span class='unexecuted'>        vm.prank(voter);</span>
 292 |     | <span class='unexecuted'>        uint256 proposalId2 = AzemoraGovernor(governorAddr).propose(targets, values, calldatas, description2);</span>
 293 |     | <span class='neutral'></span>
 294 |     | <span class='neutral'>        // --- Vote both proposals through ---</span>
 295 |     | <span class='unexecuted'>        vm.roll(block.number + VOTING_DELAY + 1);</span>
 296 |     | <span class='unexecuted'>        vm.prank(voter);</span>
 297 |     | <span class='unexecuted'>        AzemoraGovernor(governorAddr).castVote(proposalId1, 1);</span>
 298 |     | <span class='unexecuted'>        vm.prank(voter);</span>
 299 |     | <span class='unexecuted'>        AzemoraGovernor(governorAddr).castVote(proposalId2, 1);</span>
 300 |     | <span class='neutral'></span>
 301 |     | <span class='unexecuted'>        vm.roll(block.number + VOTING_PERIOD + 1);</span>
 302 |     | <span class='neutral'></span>
 303 |     | <span class='neutral'>        // --- Queue proposals and check for uniqueness ---</span>
 304 |     | <span class='neutral'>        // As per GovernorTimelockControl, the predecessor is 0 and the salt is a mix of the governor address and description hash.</span>
 305 |     | <span class='unexecuted'>        bytes32 salt1 = bytes20(address(governorAddr)) ^ descriptionHash1;</span>
 306 |     | <span class='unexecuted'>        bytes32 salt2 = bytes20(address(governorAddr)) ^ descriptionHash2;</span>
 307 |     | <span class='neutral'></span>
 308 |     | <span class='unexecuted'>        bytes32 opId1 = AzemoraTimelockController(timelockAddr).hashOperationBatch(targets, values, calldatas, 0, salt1);</span>
 309 |     | <span class='unexecuted'>        bytes32 opId2 = AzemoraTimelockController(timelockAddr).hashOperationBatch(targets, values, calldatas, 0, salt2);</span>
 310 |     | <span class='neutral'></span>
 311 |     | <span class='neutral'>        // Queue the first proposal</span>
 312 |     | <span class='unexecuted'>        AzemoraGovernor(governorAddr).queue(targets, values, calldatas, descriptionHash1);</span>
 313 |     | <span class='neutral'></span>
 314 |     | <span class='neutral'>        // Assert first is scheduled and second is NOT</span>
 315 |     | <span class='unexecuted'>        assertTrue(AzemoraTimelockController(timelockAddr).isOperation(opId1), &quot;Op 1 should be scheduled&quot;);</span>
 316 |     | <span class='unexecuted'>        assertFalse(AzemoraTimelockController(timelockAddr).isOperation(opId2), &quot;Op 2 should NOT be scheduled yet&quot;);</span>
 317 |     | <span class='neutral'></span>
 318 |     | <span class='neutral'>        // Queue the second proposal</span>
 319 |     | <span class='unexecuted'>        AzemoraGovernor(governorAddr).queue(targets, values, calldatas, descriptionHash2);</span>
 320 |     | <span class='unexecuted'>        assertTrue(AzemoraTimelockController(timelockAddr).isOperation(opId2), &quot;Op 2 should now be scheduled&quot;);</span>
 321 |     | <span class='neutral'>    }</span>
 322 |     | <span class='neutral'>}</span>
 323 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/phantom/Documents/azemora/azemora-contracts/test/governance/Governance.fuzz.t.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'>pragma solidity ^0.8.20;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>import &quot;forge-std/Test.sol&quot;;</span>
   5 |     | <span class='neutral'>import &quot;../../src/token/AzemoraToken.sol&quot;;</span>
   6 |     | <span class='neutral'>import &quot;../../src/governance/AzemoraGovernor.sol&quot;;</span>
   7 |     | <span class='neutral'>import &quot;../../src/governance/AzemoraTimelockController.sol&quot;;</span>
   8 |     | <span class='neutral'>import &quot;../../src/governance/Treasury.sol&quot;;</span>
   9 |     | <span class='neutral'>import &quot;../../src/marketplace/Marketplace.sol&quot;;</span>
  10 |     | <span class='neutral'>import &quot;../../src/core/DynamicImpactCredit.sol&quot;;</span>
  11 |     | <span class='neutral'>import &quot;../../src/core/ProjectRegistry.sol&quot;;</span>
  12 |     | <span class='neutral'>import &quot;@openzeppelin/contracts/proxy/ERC1967/ERC1967Proxy.sol&quot;;</span>
  13 |     | <span class='neutral'></span>
  14 |     | <span class='neutral'>// A mock ERC20 is needed for the Marketplace setup.</span>
  15 |     | <span class='unexecuted'>contract MockERC20ForGovTest {</span>
  16 |     | <span class='unexecuted'>    function mint(address, uint256) public {}</span>
  17 |     | <span class='neutral'>}</span>
  18 |     | <span class='neutral'></span>
  19 |     | <span class='unexecuted'>contract GovernanceFuzzTest is Test {</span>
  20 |     | <span class='neutral'>    // Use addresses instead of contract references to avoid conversion issues</span>
  21 |     | <span class='neutral'>    AzemoraToken token;</span>
  22 |     | <span class='unexecuted'>    address payable public timelockAddr;</span>
  23 |     | <span class='unexecuted'>    address payable public governorAddr;</span>
  24 |     | <span class='unexecuted'>    address payable public treasuryAddr;</span>
  25 |     | <span class='neutral'>    Marketplace marketplace;</span>
  26 |     | <span class='neutral'>    DynamicImpactCredit credit;</span>
  27 |     | <span class='neutral'>    MockERC20ForGovTest paymentToken;</span>
  28 |     | <span class='neutral'></span>
  29 |     | <span class='neutral'>    // Users</span>
  30 |     | <span class='neutral'>    address admin;</span>
  31 |     | <span class='unexecuted'>    address voter = makeAddr(&quot;voter&quot;);</span>
  32 |     | <span class='unexecuted'>    address voter2 = makeAddr(&quot;voter2&quot;);</span>
  33 |     | <span class='unexecuted'>    address poorVoter = makeAddr(&quot;poorVoter&quot;);</span>
  34 |     | <span class='unexecuted'>    address recipient = makeAddr(&quot;recipient&quot;);</span>
  35 |     | <span class='neutral'></span>
  36 |     | <span class='neutral'>    // Governance settings</span>
  37 |     | <span class='unexecuted'>    uint256 constant VOTING_DELAY = 1; // blocks</span>
  38 |     | <span class='unexecuted'>    uint256 constant VOTING_PERIOD = 5; // blocks</span>
  39 |     | <span class='unexecuted'>    uint256 constant MIN_DELAY = 1; // seconds</span>
  40 |     | <span class='unexecuted'>    uint256 constant PROPOSAL_THRESHOLD = 1000e18;</span>
  41 |     | <span class='neutral'></span>
  42 |     | <span class='unexecuted'>    function setUp() public {</span>
  43 |     | <span class='unexecuted'>        admin = address(this);</span>
  44 |     | <span class='neutral'></span>
  45 |     | <span class='neutral'>        // 1. Deploy Governance Token</span>
  46 |     | <span class='unexecuted'>        AzemoraToken tokenImpl = new AzemoraToken();</span>
  47 |     | <span class='unexecuted'>        bytes memory tokenInitData = abi.encodeCall(AzemoraToken.initialize, ());</span>
  48 |     | <span class='unexecuted'>        ERC1967Proxy tokenProxy = new ERC1967Proxy(address(tokenImpl), tokenInitData);</span>
  49 |     | <span class='unexecuted'>        token = AzemoraToken(address(tokenProxy));</span>
  50 |     | <span class='neutral'></span>
  51 |     | <span class='neutral'>        // 2. Deploy Timelock</span>
  52 |     | <span class='unexecuted'>        AzemoraTimelockController timelockImpl = new AzemoraTimelockController();</span>
  53 |     | <span class='unexecuted'>        bytes memory timelockInitData =</span>
  54 |     | <span class='unexecuted'>            abi.encodeCall(AzemoraTimelockController.initialize, (MIN_DELAY, new address[](0), new address[](0), admin));</span>
  55 |     | <span class='unexecuted'>        ERC1967Proxy timelockProxy = new ERC1967Proxy(address(timelockImpl), timelockInitData);</span>
  56 |     | <span class='unexecuted'>        timelockAddr = payable(address(timelockProxy));</span>
  57 |     | <span class='neutral'></span>
  58 |     | <span class='neutral'>        // 3. Deploy Governor</span>
  59 |     | <span class='unexecuted'>        AzemoraGovernor governorImpl = new AzemoraGovernor();</span>
  60 |     | <span class='unexecuted'>        bytes memory governorInitData = abi.encodeCall(</span>
  61 |     | <span class='neutral'>            AzemoraGovernor.initialize,</span>
  62 |     | <span class='neutral'>            (</span>
  63 |     | <span class='unexecuted'>                token,</span>
  64 |     | <span class='unexecuted'>                AzemoraTimelockController(timelockAddr),</span>
  65 |     | <span class='neutral'>                uint48(VOTING_DELAY),</span>
  66 |     | <span class='neutral'>                uint32(VOTING_PERIOD),</span>
  67 |     | <span class='neutral'>                PROPOSAL_THRESHOLD</span>
  68 |     | <span class='neutral'>            )</span>
  69 |     | <span class='neutral'>        );</span>
  70 |     | <span class='unexecuted'>        ERC1967Proxy governorProxy = new ERC1967Proxy(address(governorImpl), governorInitData);</span>
  71 |     | <span class='unexecuted'>        governorAddr = payable(address(governorProxy));</span>
  72 |     | <span class='neutral'></span>
  73 |     | <span class='neutral'>        // 4. Deploy Treasury</span>
  74 |     | <span class='unexecuted'>        Treasury treasuryImpl = new Treasury();</span>
  75 |     | <span class='unexecuted'>        bytes memory treasuryInitData = abi.encodeCall(Treasury.initialize, (admin));</span>
  76 |     | <span class='unexecuted'>        ERC1967Proxy treasuryProxy = new ERC1967Proxy(address(treasuryImpl), treasuryInitData);</span>
  77 |     | <span class='unexecuted'>        treasuryAddr = payable(address(treasuryProxy));</span>
  78 |     | <span class='neutral'></span>
  79 |     | <span class='neutral'>        // 5. Deploy Marketplace and its dependencies</span>
  80 |     | <span class='unexecuted'>        paymentToken = new MockERC20ForGovTest();</span>
  81 |     | <span class='neutral'></span>
  82 |     | <span class='unexecuted'>        ProjectRegistry registryImpl = new ProjectRegistry();</span>
  83 |     | <span class='unexecuted'>        bytes memory registryInitData = abi.encodeCall(ProjectRegistry.initialize, ());</span>
  84 |     | <span class='unexecuted'>        ERC1967Proxy registryProxy = new ERC1967Proxy(address(registryImpl), registryInitData);</span>
  85 |     | <span class='unexecuted'>        ProjectRegistry registry = ProjectRegistry(address(registryProxy));</span>
  86 |     | <span class='neutral'></span>
  87 |     | <span class='unexecuted'>        DynamicImpactCredit creditImpl = new DynamicImpactCredit(address(registry));</span>
  88 |     | <span class='unexecuted'>        bytes memory creditInitData = abi.encodeCall(DynamicImpactCredit.initialize, (&quot;uri&quot;));</span>
  89 |     | <span class='unexecuted'>        ERC1967Proxy creditProxy = new ERC1967Proxy(address(creditImpl), creditInitData);</span>
  90 |     | <span class='unexecuted'>        credit = DynamicImpactCredit(address(creditProxy));</span>
  91 |     | <span class='neutral'></span>
  92 |     | <span class='unexecuted'>        Marketplace marketplaceImpl = new Marketplace();</span>
  93 |     | <span class='unexecuted'>        bytes memory marketplaceInitData =</span>
  94 |     | <span class='unexecuted'>            abi.encodeCall(Marketplace.initialize, (address(credit), address(paymentToken)));</span>
  95 |     | <span class='unexecuted'>        ERC1967Proxy marketplaceProxy = new ERC1967Proxy(address(marketplaceImpl), marketplaceInitData);</span>
  96 |     | <span class='unexecuted'>        marketplace = Marketplace(address(marketplaceProxy));</span>
  97 |     | <span class='neutral'></span>
  98 |     | <span class='neutral'>        // 6. Configure Roles &amp; Ownership</span>
  99 |     | <span class='unexecuted'>        bytes32 proposerRole = AzemoraTimelockController(timelockAddr).PROPOSER_ROLE();</span>
 100 |     | <span class='unexecuted'>        bytes32 executorRole = AzemoraTimelockController(timelockAddr).EXECUTOR_ROLE();</span>
 101 |     | <span class='unexecuted'>        bytes32 timelockAdminRole = AzemoraTimelockController(timelockAddr).DEFAULT_ADMIN_ROLE();</span>
 102 |     | <span class='neutral'></span>
 103 |     | <span class='unexecuted'>        AzemoraTimelockController(timelockAddr).grantRole(proposerRole, governorAddr);</span>
 104 |     | <span class='unexecuted'>        AzemoraTimelockController(timelockAddr).grantRole(executorRole, address(0)); // Anyone can execute</span>
 105 |     | <span class='unexecuted'>        AzemoraTimelockController(timelockAddr).renounceRole(timelockAdminRole, admin);</span>
 106 |     | <span class='neutral'></span>
 107 |     | <span class='neutral'>        // Transfer ownership of manageable contracts to the Timelock</span>
 108 |     | <span class='unexecuted'>        bytes32 marketplaceAdminRole = marketplace.DEFAULT_ADMIN_ROLE();</span>
 109 |     | <span class='unexecuted'>        marketplace.grantRole(marketplaceAdminRole, timelockAddr);</span>
 110 |     | <span class='unexecuted'>        marketplace.renounceRole(marketplaceAdminRole, admin);</span>
 111 |     | <span class='neutral'></span>
 112 |     | <span class='unexecuted'>        Treasury(treasuryAddr).transferOwnership(timelockAddr);</span>
 113 |     | <span class='neutral'></span>
 114 |     | <span class='neutral'>        // 7. Distribute tokens and set up voters</span>
 115 |     | <span class='unexecuted'>        token.transfer(voter, 50_000_000e18);</span>
 116 |     | <span class='unexecuted'>        token.transfer(voter2, 60_000_000e18);</span>
 117 |     | <span class='unexecuted'>        token.transfer(poorVoter, 1e18);</span>
 118 |     | <span class='neutral'></span>
 119 |     | <span class='unexecuted'>        vm.prank(voter);</span>
 120 |     | <span class='unexecuted'>        token.delegate(voter);</span>
 121 |     | <span class='neutral'></span>
 122 |     | <span class='unexecuted'>        vm.prank(voter2);</span>
 123 |     | <span class='unexecuted'>        token.delegate(voter2);</span>
 124 |     | <span class='neutral'></span>
 125 |     | <span class='unexecuted'>        vm.prank(poorVoter);</span>
 126 |     | <span class='unexecuted'>        token.delegate(poorVoter);</span>
 127 |     | <span class='neutral'></span>
 128 |     | <span class='unexecuted'>        vm.deal(treasuryAddr, 10 ether);</span>
 129 |     | <span class='unexecuted'>        vm.roll(block.number + 1);</span>
 130 |     | <span class='neutral'>    }</span>
 131 |     | <span class='neutral'></span>
 132 |     | <span class='neutral'>    /**</span>
 133 |     | <span class='neutral'>     * @dev Fuzz test to ensure vote counting is always correct.</span>
 134 |     | <span class='neutral'>     */</span>
 135 |     | <span class='unexecuted'>    function test_Fuzz_VoteCounting(uint8 voteType) public {</span>
 136 |     | <span class='neutral'>        // Constrain voteType to the 3 valid options: 0=Against, 1=For, 2=Abstain</span>
 137 |     | <span class='unexecuted'>        vm.assume(voteType &lt;= 2);</span>
 138 |     | <span class='neutral'></span>
 139 |     | <span class='neutral'>        // Propose something simple</span>
 140 |     | <span class='unexecuted'>        address[] memory targets = new address[](1);</span>
 141 |     | <span class='unexecuted'>        targets[0] = address(marketplace);</span>
 142 |     | <span class='unexecuted'>        uint256[] memory values = new uint256[](1);</span>
 143 |     | <span class='unexecuted'>        bytes[] memory calldatas = new bytes[](1);</span>
 144 |     | <span class='unexecuted'>        calldatas[0] = abi.encodeWithSelector(Marketplace.setTreasury.selector, treasuryAddr);</span>
 145 |     | <span class='unexecuted'>        string memory description = &quot;Fuzz test proposal&quot;;</span>
 146 |     | <span class='neutral'></span>
 147 |     | <span class='unexecuted'>        vm.prank(voter);</span>
 148 |     | <span class='unexecuted'>        uint256 proposalId = AzemoraGovernor(governorAddr).propose(targets, values, calldatas, description);</span>
 149 |     | <span class='neutral'></span>
 150 |     | <span class='neutral'>        // Vote with the fuzzed vote type</span>
 151 |     | <span class='unexecuted'>        vm.roll(block.number + VOTING_DELAY + 1);</span>
 152 |     | <span class='unexecuted'>        vm.prank(voter);</span>
 153 |     | <span class='unexecuted'>        AzemoraGovernor(governorAddr).castVote(proposalId, voteType);</span>
 154 |     | <span class='neutral'></span>
 155 |     | <span class='neutral'>        // Verify the votes were counted correctly</span>
 156 |     | <span class='unexecuted'>        (uint256 againstVotes, uint256 forVotes, uint256 abstainVotes) =</span>
 157 |     | <span class='unexecuted'>            AzemoraGovernor(governorAddr).proposalVotes(proposalId);</span>
 158 |     | <span class='neutral'></span>
 159 |     | <span class='unexecuted'>        uint256 voterPower = token.getVotes(voter);</span>
 160 |     | <span class='neutral'></span>
 161 |     | <span class='unexecuted'>        if (voteType == 1) {</span>
 162 |     | <span class='neutral'>            // For</span>
 163 |     | <span class='unexecuted'>            assertEq(forVotes, voterPower, &quot;For votes should match voter&#39;s power&quot;);</span>
 164 |     | <span class='unexecuted'>        } else if (voteType == 0) {</span>
 165 |     | <span class='neutral'>            // Against</span>
 166 |     | <span class='unexecuted'>            assertEq(againstVotes, voterPower, &quot;Against votes should match voter&#39;s power&quot;);</span>
 167 |     | <span class='neutral'>        } else {</span>
 168 |     | <span class='neutral'>            // Abstain</span>
 169 |     | <span class='unexecuted'>            assertEq(abstainVotes, voterPower, &quot;Abstain votes should match voter&#39;s power&quot;);</span>
 170 |     | <span class='neutral'>        }</span>
 171 |     | <span class='neutral'>    }</span>
 172 |     | <span class='neutral'>}</span>
 173 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/phantom/Documents/azemora/azemora-contracts/test/governance/Governance.invariant.t.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'>pragma solidity ^0.8.20;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>import &quot;forge-std/Test.sol&quot;;</span>
   5 |     | <span class='neutral'>import &quot;../../src/token/AzemoraToken.sol&quot;;</span>
   6 |     | <span class='neutral'>import &quot;../../src/governance/AzemoraGovernor.sol&quot;;</span>
   7 |     | <span class='neutral'>import &quot;../../src/governance/AzemoraTimelockController.sol&quot;;</span>
   8 |     | <span class='neutral'>import &quot;../../src/governance/Treasury.sol&quot;;</span>
   9 |     | <span class='neutral'>import &quot;../../src/marketplace/Marketplace.sol&quot;;</span>
  10 |     | <span class='neutral'>import &quot;../../src/core/DynamicImpactCredit.sol&quot;;</span>
  11 |     | <span class='neutral'>import &quot;../../src/core/ProjectRegistry.sol&quot;;</span>
  12 |     | <span class='neutral'>import &quot;@openzeppelin/contracts/proxy/ERC1967/ERC1967Proxy.sol&quot;;</span>
  13 |     | <span class='neutral'></span>
  14 |     | <span class='neutral'>// A mock ERC20 is needed for the Marketplace setup.</span>
  15 |     | <span class='unexecuted'>contract MockERC20ForGovTest {</span>
  16 |     | <span class='unexecuted'>    function mint(address, uint256) public {}</span>
  17 |     | <span class='neutral'>}</span>
  18 |     | <span class='neutral'></span>
  19 |     | <span class='unexecuted'>contract GovernanceInvariantTest is Test {</span>
  20 |     | <span class='neutral'>    // Use addresses instead of contract references to avoid conversion issues</span>
  21 |     | <span class='neutral'>    AzemoraToken token;</span>
  22 |     | <span class='unexecuted'>    address payable public timelockAddr;</span>
  23 |     | <span class='unexecuted'>    address payable public governorAddr;</span>
  24 |     | <span class='unexecuted'>    address payable public treasuryAddr;</span>
  25 |     | <span class='neutral'>    Marketplace marketplace;</span>
  26 |     | <span class='neutral'>    DynamicImpactCredit credit;</span>
  27 |     | <span class='neutral'>    MockERC20ForGovTest paymentToken;</span>
  28 |     | <span class='neutral'></span>
  29 |     | <span class='neutral'>    // Users</span>
  30 |     | <span class='neutral'>    address admin;</span>
  31 |     | <span class='unexecuted'>    address voter = makeAddr(&quot;voter&quot;);</span>
  32 |     | <span class='unexecuted'>    address voter2 = makeAddr(&quot;voter2&quot;);</span>
  33 |     | <span class='unexecuted'>    address poorVoter = makeAddr(&quot;poorVoter&quot;);</span>
  34 |     | <span class='unexecuted'>    address recipient = makeAddr(&quot;recipient&quot;);</span>
  35 |     | <span class='neutral'></span>
  36 |     | <span class='neutral'>    // Invariant state</span>
  37 |     | <span class='unexecuted'>    uint256 public initialTotalSupply;</span>
  38 |     | <span class='neutral'></span>
  39 |     | <span class='neutral'>    // Governance settings</span>
  40 |     | <span class='neutral'>    uint256 constant VOTING_DELAY = 1; // blocks</span>
  41 |     | <span class='unexecuted'>    uint256 constant VOTING_PERIOD = 5; // blocks</span>
  42 |     | <span class='unexecuted'>    uint256 constant MIN_DELAY = 1; // seconds</span>
  43 |     | <span class='unexecuted'>    uint256 constant PROPOSAL_THRESHOLD = 1000e18;</span>
  44 |     | <span class='neutral'></span>
  45 |     | <span class='unexecuted'>    function setUp() public {</span>
  46 |     | <span class='unexecuted'>        admin = address(this);</span>
  47 |     | <span class='neutral'></span>
  48 |     | <span class='neutral'>        // 1. Deploy Governance Token</span>
  49 |     | <span class='unexecuted'>        AzemoraToken tokenImpl = new AzemoraToken();</span>
  50 |     | <span class='unexecuted'>        bytes memory tokenInitData = abi.encodeCall(AzemoraToken.initialize, ());</span>
  51 |     | <span class='unexecuted'>        ERC1967Proxy tokenProxy = new ERC1967Proxy(address(tokenImpl), tokenInitData);</span>
  52 |     | <span class='unexecuted'>        token = AzemoraToken(address(tokenProxy));</span>
  53 |     | <span class='neutral'></span>
  54 |     | <span class='neutral'>        // 2. Deploy Timelock</span>
  55 |     | <span class='unexecuted'>        AzemoraTimelockController timelockImpl = new AzemoraTimelockController();</span>
  56 |     | <span class='unexecuted'>        bytes memory timelockInitData =</span>
  57 |     | <span class='unexecuted'>            abi.encodeCall(AzemoraTimelockController.initialize, (MIN_DELAY, new address[](0), new address[](0), admin));</span>
  58 |     | <span class='unexecuted'>        ERC1967Proxy timelockProxy = new ERC1967Proxy(address(timelockImpl), timelockInitData);</span>
  59 |     | <span class='unexecuted'>        timelockAddr = payable(address(timelockProxy));</span>
  60 |     | <span class='neutral'></span>
  61 |     | <span class='neutral'>        // 3. Deploy Governor</span>
  62 |     | <span class='unexecuted'>        AzemoraGovernor governorImpl = new AzemoraGovernor();</span>
  63 |     | <span class='unexecuted'>        bytes memory governorInitData = abi.encodeCall(</span>
  64 |     | <span class='neutral'>            AzemoraGovernor.initialize,</span>
  65 |     | <span class='neutral'>            (</span>
  66 |     | <span class='unexecuted'>                token,</span>
  67 |     | <span class='unexecuted'>                AzemoraTimelockController(timelockAddr),</span>
  68 |     | <span class='neutral'>                uint48(VOTING_DELAY),</span>
  69 |     | <span class='neutral'>                uint32(VOTING_PERIOD),</span>
  70 |     | <span class='neutral'>                PROPOSAL_THRESHOLD</span>
  71 |     | <span class='neutral'>            )</span>
  72 |     | <span class='neutral'>        );</span>
  73 |     | <span class='unexecuted'>        ERC1967Proxy governorProxy = new ERC1967Proxy(address(governorImpl), governorInitData);</span>
  74 |     | <span class='unexecuted'>        governorAddr = payable(address(governorProxy));</span>
  75 |     | <span class='neutral'></span>
  76 |     | <span class='neutral'>        // 4. Deploy Treasury</span>
  77 |     | <span class='unexecuted'>        Treasury treasuryImpl = new Treasury();</span>
  78 |     | <span class='unexecuted'>        bytes memory treasuryInitData = abi.encodeCall(Treasury.initialize, (admin));</span>
  79 |     | <span class='unexecuted'>        ERC1967Proxy treasuryProxy = new ERC1967Proxy(address(treasuryImpl), treasuryInitData);</span>
  80 |     | <span class='unexecuted'>        treasuryAddr = payable(address(treasuryProxy));</span>
  81 |     | <span class='neutral'></span>
  82 |     | <span class='neutral'>        // 5. Deploy Marketplace and its dependencies</span>
  83 |     | <span class='unexecuted'>        paymentToken = new MockERC20ForGovTest();</span>
  84 |     | <span class='neutral'></span>
  85 |     | <span class='unexecuted'>        ProjectRegistry registryImpl = new ProjectRegistry();</span>
  86 |     | <span class='unexecuted'>        bytes memory registryInitData = abi.encodeCall(ProjectRegistry.initialize, ());</span>
  87 |     | <span class='unexecuted'>        ERC1967Proxy registryProxy = new ERC1967Proxy(address(registryImpl), registryInitData);</span>
  88 |     | <span class='unexecuted'>        ProjectRegistry registry = ProjectRegistry(address(registryProxy));</span>
  89 |     | <span class='neutral'></span>
  90 |     | <span class='unexecuted'>        DynamicImpactCredit creditImpl = new DynamicImpactCredit(address(registry));</span>
  91 |     | <span class='unexecuted'>        bytes memory creditInitData = abi.encodeCall(DynamicImpactCredit.initialize, (&quot;uri&quot;));</span>
  92 |     | <span class='unexecuted'>        ERC1967Proxy creditProxy = new ERC1967Proxy(address(creditImpl), creditInitData);</span>
  93 |     | <span class='unexecuted'>        credit = DynamicImpactCredit(address(creditProxy));</span>
  94 |     | <span class='neutral'></span>
  95 |     | <span class='unexecuted'>        Marketplace marketplaceImpl = new Marketplace();</span>
  96 |     | <span class='unexecuted'>        bytes memory marketplaceInitData =</span>
  97 |     | <span class='unexecuted'>            abi.encodeCall(Marketplace.initialize, (address(credit), address(paymentToken)));</span>
  98 |     | <span class='unexecuted'>        ERC1967Proxy marketplaceProxy = new ERC1967Proxy(address(marketplaceImpl), marketplaceInitData);</span>
  99 |     | <span class='unexecuted'>        marketplace = Marketplace(address(marketplaceProxy));</span>
 100 |     | <span class='neutral'></span>
 101 |     | <span class='neutral'>        // 6. Configure Roles &amp; Ownership</span>
 102 |     | <span class='unexecuted'>        bytes32 proposerRole = AzemoraTimelockController(timelockAddr).PROPOSER_ROLE();</span>
 103 |     | <span class='unexecuted'>        bytes32 executorRole = AzemoraTimelockController(timelockAddr).EXECUTOR_ROLE();</span>
 104 |     | <span class='unexecuted'>        bytes32 timelockAdminRole = AzemoraTimelockController(timelockAddr).DEFAULT_ADMIN_ROLE();</span>
 105 |     | <span class='neutral'></span>
 106 |     | <span class='unexecuted'>        AzemoraTimelockController(timelockAddr).grantRole(proposerRole, governorAddr);</span>
 107 |     | <span class='unexecuted'>        AzemoraTimelockController(timelockAddr).grantRole(executorRole, address(0)); // Anyone can execute</span>
 108 |     | <span class='unexecuted'>        AzemoraTimelockController(timelockAddr).renounceRole(timelockAdminRole, admin);</span>
 109 |     | <span class='neutral'></span>
 110 |     | <span class='neutral'>        // Transfer ownership of manageable contracts to the Timelock</span>
 111 |     | <span class='unexecuted'>        bytes32 marketplaceAdminRole = marketplace.DEFAULT_ADMIN_ROLE();</span>
 112 |     | <span class='unexecuted'>        marketplace.grantRole(marketplaceAdminRole, timelockAddr);</span>
 113 |     | <span class='unexecuted'>        marketplace.renounceRole(marketplaceAdminRole, admin);</span>
 114 |     | <span class='neutral'></span>
 115 |     | <span class='unexecuted'>        Treasury(treasuryAddr).transferOwnership(timelockAddr);</span>
 116 |     | <span class='neutral'></span>
 117 |     | <span class='neutral'>        // 7. Distribute tokens and set up voters</span>
 118 |     | <span class='unexecuted'>        token.transfer(voter, 50_000_000e18);</span>
 119 |     | <span class='unexecuted'>        token.transfer(voter2, 60_000_000e18);</span>
 120 |     | <span class='unexecuted'>        token.transfer(poorVoter, 1e18);</span>
 121 |     | <span class='neutral'></span>
 122 |     | <span class='unexecuted'>        vm.prank(voter);</span>
 123 |     | <span class='unexecuted'>        token.delegate(voter);</span>
 124 |     | <span class='neutral'></span>
 125 |     | <span class='unexecuted'>        vm.prank(voter2);</span>
 126 |     | <span class='unexecuted'>        token.delegate(voter2);</span>
 127 |     | <span class='neutral'></span>
 128 |     | <span class='unexecuted'>        vm.prank(poorVoter);</span>
 129 |     | <span class='unexecuted'>        token.delegate(poorVoter);</span>
 130 |     | <span class='neutral'></span>
 131 |     | <span class='unexecuted'>        vm.deal(treasuryAddr, 10 ether);</span>
 132 |     | <span class='unexecuted'>        vm.roll(block.number + 1);</span>
 133 |     | <span class='neutral'></span>
 134 |     | <span class='neutral'>        // Set initial state for invariant testing</span>
 135 |     | <span class='unexecuted'>        initialTotalSupply = token.totalSupply();</span>
 136 |     | <span class='neutral'>    }</span>
 137 |     | <span class='neutral'></span>
 138 |     | <span class='neutral'>    /**</span>
 139 |     | <span class='neutral'>     * @dev Invariant: The total supply of the governance token should remain constant.</span>
 140 |     | <span class='neutral'>     * This ensures no new tokens are minted or burned unexpectedly.</span>
 141 |     | <span class='neutral'>     */</span>
 142 |     | <span class='unexecuted'>    function invariant_totalSupplyIsConstant() public view {</span>
 143 |     | <span class='unexecuted'>        assertEq(token.totalSupply(), initialTotalSupply, &quot;The total supply of the governance token must never change.&quot;);</span>
 144 |     | <span class='neutral'>    }</span>
 145 |     | <span class='neutral'>}</span>
 146 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/phantom/Documents/azemora/azemora-contracts/test/governance/Governance.t.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'>pragma solidity ^0.8.20;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>import &quot;forge-std/Test.sol&quot;;</span>
   5 |     | <span class='neutral'>import &quot;../../src/token/AzemoraToken.sol&quot;;</span>
   6 |     | <span class='neutral'>import &quot;../../src/governance/AzemoraGovernor.sol&quot;;</span>
   7 |     | <span class='neutral'>import &quot;../../src/governance/AzemoraTimelockController.sol&quot;;</span>
   8 |     | <span class='neutral'>import &quot;../../src/governance/Treasury.sol&quot;;</span>
   9 |     | <span class='neutral'>import &quot;../../src/marketplace/Marketplace.sol&quot;;</span>
  10 |     | <span class='neutral'>import &quot;../../src/core/DynamicImpactCredit.sol&quot;;</span>
  11 |     | <span class='neutral'>import &quot;../../src/core/ProjectRegistry.sol&quot;;</span>
  12 |     | <span class='neutral'>import &quot;@openzeppelin/contracts/proxy/ERC1967/ERC1967Proxy.sol&quot;;</span>
  13 |     | <span class='neutral'></span>
  14 |     | <span class='neutral'>// A mock ERC20 is needed for the Marketplace setup.</span>
  15 |     | <span class='neutral'>// We can define it here to keep the test self-contained.</span>
  16 |     | <span class='unexecuted'>contract MockERC20ForGovTest {</span>
  17 |     | <span class='unexecuted'>    function mint(address, uint256) public {}</span>
  18 |     | <span class='neutral'>}</span>
  19 |     | <span class='neutral'></span>
  20 |     | <span class='unexecuted'>contract GovernanceTest is Test {</span>
  21 |     | <span class='neutral'>    // Use addresses instead of contract references to avoid conversion issues</span>
  22 |     | <span class='neutral'>    AzemoraToken token;</span>
  23 |     | <span class='unexecuted'>    address payable public timelockAddr;</span>
  24 |     | <span class='unexecuted'>    address payable public governorAddr;</span>
  25 |     | <span class='unexecuted'>    address payable public treasuryAddr;</span>
  26 |     | <span class='neutral'>    Marketplace marketplace;</span>
  27 |     | <span class='neutral'>    DynamicImpactCredit credit;</span>
  28 |     | <span class='neutral'>    MockERC20ForGovTest paymentToken;</span>
  29 |     | <span class='neutral'></span>
  30 |     | <span class='neutral'>    // Users</span>
  31 |     | <span class='neutral'>    address admin;</span>
  32 |     | <span class='unexecuted'>    address voter = makeAddr(&quot;voter&quot;);</span>
  33 |     | <span class='unexecuted'>    address voter2 = makeAddr(&quot;voter2&quot;);</span>
  34 |     | <span class='unexecuted'>    address poorVoter = makeAddr(&quot;poorVoter&quot;);</span>
  35 |     | <span class='unexecuted'>    address recipient = makeAddr(&quot;recipient&quot;);</span>
  36 |     | <span class='neutral'></span>
  37 |     | <span class='neutral'>    // Governance settings</span>
  38 |     | <span class='unexecuted'>    uint256 constant VOTING_DELAY = 1; // blocks</span>
  39 |     | <span class='unexecuted'>    uint256 constant VOTING_PERIOD = 5; // blocks</span>
  40 |     | <span class='unexecuted'>    uint256 constant MIN_DELAY = 1; // seconds</span>
  41 |     | <span class='unexecuted'>    uint256 constant PROPOSAL_THRESHOLD = 1000e18;</span>
  42 |     | <span class='neutral'></span>
  43 |     | <span class='unexecuted'>    function setUp() public {</span>
  44 |     | <span class='unexecuted'>        admin = address(this);</span>
  45 |     | <span class='neutral'></span>
  46 |     | <span class='neutral'>        // 1. Deploy Governance Token</span>
  47 |     | <span class='unexecuted'>        AzemoraToken tokenImpl = new AzemoraToken();</span>
  48 |     | <span class='unexecuted'>        bytes memory tokenInitData = abi.encodeCall(AzemoraToken.initialize, ());</span>
  49 |     | <span class='unexecuted'>        ERC1967Proxy tokenProxy = new ERC1967Proxy(address(tokenImpl), tokenInitData);</span>
  50 |     | <span class='unexecuted'>        token = AzemoraToken(address(tokenProxy));</span>
  51 |     | <span class='neutral'></span>
  52 |     | <span class='neutral'>        // 2. Deploy Timelock</span>
  53 |     | <span class='unexecuted'>        AzemoraTimelockController timelockImpl = new AzemoraTimelockController();</span>
  54 |     | <span class='unexecuted'>        bytes memory timelockInitData =</span>
  55 |     | <span class='unexecuted'>            abi.encodeCall(AzemoraTimelockController.initialize, (MIN_DELAY, new address[](0), new address[](0), admin));</span>
  56 |     | <span class='unexecuted'>        ERC1967Proxy timelockProxy = new ERC1967Proxy(address(timelockImpl), timelockInitData);</span>
  57 |     | <span class='unexecuted'>        timelockAddr = payable(address(timelockProxy));</span>
  58 |     | <span class='neutral'></span>
  59 |     | <span class='neutral'>        // 3. Deploy Governor</span>
  60 |     | <span class='unexecuted'>        AzemoraGovernor governorImpl = new AzemoraGovernor();</span>
  61 |     | <span class='neutral'>        // Use temporary direct casting for initialization only</span>
  62 |     | <span class='unexecuted'>        bytes memory governorInitData = abi.encodeCall(</span>
  63 |     | <span class='neutral'>            AzemoraGovernor.initialize,</span>
  64 |     | <span class='neutral'>            (</span>
  65 |     | <span class='unexecuted'>                token,</span>
  66 |     | <span class='unexecuted'>                AzemoraTimelockController(timelockAddr),</span>
  67 |     | <span class='neutral'>                uint48(VOTING_DELAY),</span>
  68 |     | <span class='neutral'>                uint32(VOTING_PERIOD),</span>
  69 |     | <span class='neutral'>                PROPOSAL_THRESHOLD</span>
  70 |     | <span class='neutral'>            )</span>
  71 |     | <span class='neutral'>        );</span>
  72 |     | <span class='unexecuted'>        ERC1967Proxy governorProxy = new ERC1967Proxy(address(governorImpl), governorInitData);</span>
  73 |     | <span class='unexecuted'>        governorAddr = payable(address(governorProxy));</span>
  74 |     | <span class='neutral'></span>
  75 |     | <span class='neutral'>        // 4. Deploy Treasury</span>
  76 |     | <span class='unexecuted'>        Treasury treasuryImpl = new Treasury();</span>
  77 |     | <span class='unexecuted'>        bytes memory treasuryInitData = abi.encodeCall(Treasury.initialize, (admin));</span>
  78 |     | <span class='unexecuted'>        ERC1967Proxy treasuryProxy = new ERC1967Proxy(address(treasuryImpl), treasuryInitData);</span>
  79 |     | <span class='unexecuted'>        treasuryAddr = payable(address(treasuryProxy));</span>
  80 |     | <span class='neutral'></span>
  81 |     | <span class='neutral'>        // 5. Deploy Marketplace and its dependencies</span>
  82 |     | <span class='unexecuted'>        paymentToken = new MockERC20ForGovTest();</span>
  83 |     | <span class='neutral'></span>
  84 |     | <span class='unexecuted'>        ProjectRegistry registryImpl = new ProjectRegistry();</span>
  85 |     | <span class='unexecuted'>        bytes memory registryInitData = abi.encodeCall(ProjectRegistry.initialize, ());</span>
  86 |     | <span class='unexecuted'>        ERC1967Proxy registryProxy = new ERC1967Proxy(address(registryImpl), registryInitData);</span>
  87 |     | <span class='unexecuted'>        ProjectRegistry registry = ProjectRegistry(address(registryProxy));</span>
  88 |     | <span class='neutral'></span>
  89 |     | <span class='unexecuted'>        DynamicImpactCredit creditImpl = new DynamicImpactCredit(address(registry));</span>
  90 |     | <span class='unexecuted'>        bytes memory creditInitData = abi.encodeCall(DynamicImpactCredit.initialize, (&quot;uri&quot;));</span>
  91 |     | <span class='unexecuted'>        ERC1967Proxy creditProxy = new ERC1967Proxy(address(creditImpl), creditInitData);</span>
  92 |     | <span class='unexecuted'>        credit = DynamicImpactCredit(address(creditProxy));</span>
  93 |     | <span class='neutral'></span>
  94 |     | <span class='unexecuted'>        Marketplace marketplaceImpl = new Marketplace();</span>
  95 |     | <span class='unexecuted'>        bytes memory marketplaceInitData =</span>
  96 |     | <span class='unexecuted'>            abi.encodeCall(Marketplace.initialize, (address(credit), address(paymentToken)));</span>
  97 |     | <span class='unexecuted'>        ERC1967Proxy marketplaceProxy = new ERC1967Proxy(address(marketplaceImpl), marketplaceInitData);</span>
  98 |     | <span class='unexecuted'>        marketplace = Marketplace(address(marketplaceProxy));</span>
  99 |     | <span class='neutral'></span>
 100 |     | <span class='neutral'>        // 6. Configure Roles &amp; Ownership using direct calls with casts</span>
 101 |     | <span class='neutral'>        // This is safe because we&#39;re only temporarily casting for function calls</span>
 102 |     | <span class='unexecuted'>        bytes32 proposerRole = AzemoraTimelockController(timelockAddr).PROPOSER_ROLE();</span>
 103 |     | <span class='unexecuted'>        bytes32 executorRole = AzemoraTimelockController(timelockAddr).EXECUTOR_ROLE();</span>
 104 |     | <span class='unexecuted'>        bytes32 timelockAdminRole = AzemoraTimelockController(timelockAddr).DEFAULT_ADMIN_ROLE();</span>
 105 |     | <span class='neutral'></span>
 106 |     | <span class='unexecuted'>        AzemoraTimelockController(timelockAddr).grantRole(proposerRole, governorAddr);</span>
 107 |     | <span class='unexecuted'>        AzemoraTimelockController(timelockAddr).grantRole(executorRole, address(0)); // Anyone can execute</span>
 108 |     | <span class='unexecuted'>        AzemoraTimelockController(timelockAddr).renounceRole(timelockAdminRole, admin);</span>
 109 |     | <span class='neutral'></span>
 110 |     | <span class='neutral'>        // Transfer ownership of manageable contracts to the Timelock</span>
 111 |     | <span class='unexecuted'>        bytes32 marketplaceAdminRole = marketplace.DEFAULT_ADMIN_ROLE();</span>
 112 |     | <span class='unexecuted'>        marketplace.grantRole(marketplaceAdminRole, timelockAddr);</span>
 113 |     | <span class='unexecuted'>        marketplace.renounceRole(marketplaceAdminRole, admin);</span>
 114 |     | <span class='neutral'></span>
 115 |     | <span class='neutral'>        // Transfer Treasury ownership to timelock</span>
 116 |     | <span class='unexecuted'>        Treasury(treasuryAddr).transferOwnership(timelockAddr);</span>
 117 |     | <span class='neutral'></span>
 118 |     | <span class='neutral'>        // 7. Distribute tokens and set up voters</span>
 119 |     | <span class='neutral'>        // Voter needs &gt;4% of total supply (1B) to meet quorum. 50M = 5%.</span>
 120 |     | <span class='unexecuted'>        token.transfer(voter, 50_000_000e18); // Give voter 50M tokens (5%)</span>
 121 |     | <span class='unexecuted'>        token.transfer(voter2, 60_000_000e18); // Give voter2 60M tokens (6%) to have more power</span>
 122 |     | <span class='unexecuted'>        token.transfer(poorVoter, 1e18); // Give poorVoter 1 token (below proposal threshold)</span>
 123 |     | <span class='neutral'></span>
 124 |     | <span class='unexecuted'>        vm.prank(voter);</span>
 125 |     | <span class='unexecuted'>        token.delegate(voter); // Voter delegates voting power to themselves</span>
 126 |     | <span class='neutral'></span>
 127 |     | <span class='unexecuted'>        vm.prank(voter2);</span>
 128 |     | <span class='unexecuted'>        token.delegate(voter2);</span>
 129 |     | <span class='neutral'></span>
 130 |     | <span class='unexecuted'>        vm.prank(poorVoter);</span>
 131 |     | <span class='unexecuted'>        token.delegate(poorVoter);</span>
 132 |     | <span class='neutral'></span>
 133 |     | <span class='neutral'>        // Fund the treasury for the withdrawal test</span>
 134 |     | <span class='unexecuted'>        vm.deal(treasuryAddr, 10 ether);</span>
 135 |     | <span class='neutral'></span>
 136 |     | <span class='neutral'>        // Advance a block to ensure delegations are registered before any proposal is made</span>
 137 |     | <span class='unexecuted'>        vm.roll(block.number + 1);</span>
 138 |     | <span class='neutral'>    }</span>
 139 |     | <span class='neutral'></span>
 140 |     | <span class='unexecuted'>    function test_Governance_Full_Flow() public {</span>
 141 |     | <span class='neutral'>        // --- 1. Propose ---</span>
 142 |     | <span class='unexecuted'>        address[] memory targets = new address[](1);</span>
 143 |     | <span class='unexecuted'>        targets[0] = address(marketplace);</span>
 144 |     | <span class='unexecuted'>        uint256[] memory values = new uint256[](1); // No ETH being sent</span>
 145 |     | <span class='unexecuted'>        bytes[] memory calldatas = new bytes[](1);</span>
 146 |     | <span class='unexecuted'>        calldatas[0] = abi.encodeWithSelector(Marketplace.setTreasury.selector, treasuryAddr);</span>
 147 |     | <span class='unexecuted'>        string memory description = &quot;Set marketplace fee recipient to Treasury&quot;;</span>
 148 |     | <span class='unexecuted'>        bytes32 descriptionHash = keccak256(bytes(description));</span>
 149 |     | <span class='neutral'></span>
 150 |     | <span class='neutral'>        // Propose the action - use temporary casting</span>
 151 |     | <span class='unexecuted'>        vm.prank(voter);</span>
 152 |     | <span class='unexecuted'>        uint256 proposalId = AzemoraGovernor(governorAddr).propose(targets, values, calldatas, description);</span>
 153 |     | <span class='neutral'></span>
 154 |     | <span class='neutral'>        // --- 2. Vote ---</span>
 155 |     | <span class='unexecuted'>        vm.roll(block.number + VOTING_DELAY + 1); // Wait for voting delay</span>
 156 |     | <span class='neutral'></span>
 157 |     | <span class='neutral'>        // Vote in favor - use temporary casting</span>
 158 |     | <span class='unexecuted'>        vm.prank(voter);</span>
 159 |     | <span class='unexecuted'>        AzemoraGovernor(governorAddr).castVote(proposalId, uint8(1)); // 1 = For</span>
 160 |     | <span class='neutral'></span>
 161 |     | <span class='neutral'>        // --- 3. Queue ---</span>
 162 |     | <span class='unexecuted'>        vm.roll(block.number + VOTING_PERIOD + 1); // Wait for voting period to end</span>
 163 |     | <span class='neutral'></span>
 164 |     | <span class='neutral'>        // Queue the proposal - use temporary casting</span>
 165 |     | <span class='unexecuted'>        AzemoraGovernor(governorAddr).queue(targets, values, calldatas, descriptionHash);</span>
 166 |     | <span class='neutral'></span>
 167 |     | <span class='neutral'>        // --- 4. Execute ---</span>
 168 |     | <span class='unexecuted'>        vm.warp(block.timestamp + MIN_DELAY + 1); // Wait for the timelock min delay</span>
 169 |     | <span class='neutral'></span>
 170 |     | <span class='neutral'>        // Execute the proposal - use temporary casting</span>
 171 |     | <span class='unexecuted'>        AzemoraGovernor(governorAddr).execute(targets, values, calldatas, descriptionHash);</span>
 172 |     | <span class='neutral'></span>
 173 |     | <span class='neutral'>        // --- 5. Verify ---</span>
 174 |     | <span class='unexecuted'>        assertEq(marketplace.treasury(), treasuryAddr, &quot;Fee recipient should be the Treasury&quot;);</span>
 175 |     | <span class='neutral'>    }</span>
 176 |     | <span class='neutral'></span>
 177 |     | <span class='unexecuted'>    function test_Fail_When_Quorum_Not_Met() public {</span>
 178 |     | <span class='neutral'>        // --- 1. Propose ---</span>
 179 |     | <span class='unexecuted'>        address[] memory targets = new address[](1);</span>
 180 |     | <span class='unexecuted'>        targets[0] = address(marketplace);</span>
 181 |     | <span class='unexecuted'>        uint256[] memory values = new uint256[](1); // No ETH being sent</span>
 182 |     | <span class='unexecuted'>        bytes[] memory calldatas = new bytes[](1);</span>
 183 |     | <span class='unexecuted'>        calldatas[0] = abi.encodeWithSelector(Marketplace.setTreasury.selector, treasuryAddr);</span>
 184 |     | <span class='unexecuted'>        string memory description = &quot;Set marketplace fee recipient to Treasury&quot;;</span>
 185 |     | <span class='neutral'></span>
 186 |     | <span class='neutral'>        // Propose the action with a valid proposer</span>
 187 |     | <span class='unexecuted'>        vm.prank(voter);</span>
 188 |     | <span class='unexecuted'>        uint256 proposalId = AzemoraGovernor(governorAddr).propose(targets, values, calldatas, description);</span>
 189 |     | <span class='neutral'></span>
 190 |     | <span class='neutral'>        // --- 2. Vote ---</span>
 191 |     | <span class='unexecuted'>        vm.roll(block.number + VOTING_DELAY + 1); // Wait for voting delay</span>
 192 |     | <span class='neutral'></span>
 193 |     | <span class='neutral'>        // Vote with a user who doesn&#39;t have enough tokens to meet quorum</span>
 194 |     | <span class='unexecuted'>        vm.prank(poorVoter);</span>
 195 |     | <span class='unexecuted'>        AzemoraGovernor(governorAddr).castVote(proposalId, uint8(1)); // 1 = For</span>
 196 |     | <span class='neutral'></span>
 197 |     | <span class='neutral'>        // --- 3. Check State ---</span>
 198 |     | <span class='neutral'>        vm.roll(block.number + VOTING_PERIOD + 1); // Wait for voting period to end</span>
 199 |     | <span class='neutral'></span>
 200 |     | <span class='neutral'>        // Proposal should be defeated because quorum was not met</span>
 201 |     | <span class='neutral'>        assertEq(uint256(AzemoraGovernor(governorAddr).state(proposalId)), 3); // 3 = Defeated</span>
 202 |     | <span class='neutral'>    }</span>
 203 |     | <span class='neutral'></span>
 204 |     | <span class='unexecuted'>    function test_Fail_When_Voted_Down() public {</span>
 205 |     | <span class='neutral'>        // --- 1. Propose ---</span>
 206 |     | <span class='unexecuted'>        address[] memory targets = new address[](1);</span>
 207 |     | <span class='unexecuted'>        targets[0] = address(marketplace);</span>
 208 |     | <span class='unexecuted'>        uint256[] memory values = new uint256[](1); // No ETH being sent</span>
 209 |     | <span class='unexecuted'>        bytes[] memory calldatas = new bytes[](1);</span>
 210 |     | <span class='unexecuted'>        calldatas[0] = abi.encodeWithSelector(Marketplace.setTreasury.selector, treasuryAddr);</span>
 211 |     | <span class='unexecuted'>        string memory description = &quot;Set marketplace fee recipient to Treasury&quot;;</span>
 212 |     | <span class='neutral'></span>
 213 |     | <span class='neutral'>        // voter proposes</span>
 214 |     | <span class='unexecuted'>        vm.prank(voter);</span>
 215 |     | <span class='unexecuted'>        uint256 proposalId = AzemoraGovernor(governorAddr).propose(targets, values, calldatas, description);</span>
 216 |     | <span class='neutral'></span>
 217 |     | <span class='neutral'>        // --- 2. Vote ---</span>
 218 |     | <span class='unexecuted'>        vm.roll(block.number + VOTING_DELAY + 1); // Wait for voting delay</span>
 219 |     | <span class='neutral'></span>
 220 |     | <span class='neutral'>        // voter votes FOR</span>
 221 |     | <span class='unexecuted'>        vm.prank(voter);</span>
 222 |     | <span class='unexecuted'>        AzemoraGovernor(governorAddr).castVote(proposalId, uint8(1)); // 1 = For</span>
 223 |     | <span class='neutral'></span>
 224 |     | <span class='neutral'>        // voter2 has more tokens and votes AGAINST</span>
 225 |     | <span class='unexecuted'>        vm.prank(voter2);</span>
 226 |     | <span class='unexecuted'>        AzemoraGovernor(governorAddr).castVote(proposalId, uint8(0)); // 0 = Against</span>
 227 |     | <span class='neutral'></span>
 228 |     | <span class='neutral'>        // --- 3. Check State ---</span>
 229 |     | <span class='unexecuted'>        vm.roll(block.number + VOTING_PERIOD + 1); // Wait for voting period to end</span>
 230 |     | <span class='neutral'></span>
 231 |     | <span class='neutral'>        // Proposal should be defeated because against votes &gt; for votes</span>
 232 |     | <span class='unexecuted'>        assertEq(uint256(AzemoraGovernor(governorAddr).state(proposalId)), 3); // 3 = Defeated</span>
 233 |     | <span class='neutral'>    }</span>
 234 |     | <span class='neutral'></span>
 235 |     | <span class='unexecuted'>    function test_Propose_And_Withdraw_From_Treasury() public {</span>
 236 |     | <span class='unexecuted'>        uint256 startingBalance = recipient.balance;</span>
 237 |     | <span class='unexecuted'>        uint256 treasuryBalance = address(treasuryAddr).balance;</span>
 238 |     | <span class='unexecuted'>        uint256 withdrawAmount = 1 ether;</span>
 239 |     | <span class='neutral'></span>
 240 |     | <span class='neutral'>        // --- 1. Propose ---</span>
 241 |     | <span class='unexecuted'>        address[] memory targets = new address[](1);</span>
 242 |     | <span class='unexecuted'>        targets[0] = treasuryAddr;</span>
 243 |     | <span class='unexecuted'>        uint256[] memory values = new uint256[](1); // No ETH being sent with the proposal itself</span>
 244 |     | <span class='unexecuted'>        bytes[] memory calldatas = new bytes[](1);</span>
 245 |     | <span class='unexecuted'>        calldatas[0] = abi.encodeWithSelector(Treasury.withdrawETH.selector, recipient, withdrawAmount);</span>
 246 |     | <span class='unexecuted'>        string memory description = &quot;Proposal to withdraw 1 ETH from Treasury&quot;;</span>
 247 |     | <span class='unexecuted'>        bytes32 descriptionHash = keccak256(bytes(description));</span>
 248 |     | <span class='neutral'></span>
 249 |     | <span class='neutral'>        // Propose the action</span>
 250 |     | <span class='unexecuted'>        vm.prank(voter);</span>
 251 |     | <span class='unexecuted'>        uint256 proposalId = AzemoraGovernor(governorAddr).propose(targets, values, calldatas, description);</span>
 252 |     | <span class='neutral'></span>
 253 |     | <span class='neutral'>        // --- 2. Vote ---</span>
 254 |     | <span class='unexecuted'>        vm.roll(block.number + VOTING_DELAY + 1); // Wait for voting delay</span>
 255 |     | <span class='neutral'></span>
 256 |     | <span class='neutral'>        // Vote in favor</span>
 257 |     | <span class='unexecuted'>        vm.prank(voter);</span>
 258 |     | <span class='unexecuted'>        AzemoraGovernor(governorAddr).castVote(proposalId, uint8(1)); // 1 = For</span>
 259 |     | <span class='neutral'></span>
 260 |     | <span class='neutral'>        // --- 3. Queue ---</span>
 261 |     | <span class='unexecuted'>        vm.roll(block.number + VOTING_PERIOD + 1); // Wait for voting period to end</span>
 262 |     | <span class='neutral'></span>
 263 |     | <span class='neutral'>        // Queue the proposal</span>
 264 |     | <span class='unexecuted'>        AzemoraGovernor(governorAddr).queue(targets, values, calldatas, descriptionHash);</span>
 265 |     | <span class='neutral'></span>
 266 |     | <span class='neutral'>        // --- 4. Execute ---</span>
 267 |     | <span class='unexecuted'>        vm.warp(block.timestamp + MIN_DELAY + 1); // Wait for the timelock min delay</span>
 268 |     | <span class='neutral'></span>
 269 |     | <span class='neutral'>        // Execute the proposal</span>
 270 |     | <span class='unexecuted'>        AzemoraGovernor(governorAddr).execute(targets, values, calldatas, descriptionHash);</span>
 271 |     | <span class='neutral'></span>
 272 |     | <span class='neutral'>        // --- 5. Verify ---</span>
 273 |     | <span class='unexecuted'>        assertEq(recipient.balance, startingBalance + withdrawAmount, &quot;Recipient should have received ETH&quot;);</span>
 274 |     | <span class='unexecuted'>        assertEq(</span>
 275 |     | <span class='unexecuted'>            address(treasuryAddr).balance, treasuryBalance - withdrawAmount, &quot;Treasury balance should have decreased&quot;</span>
 276 |     | <span class='neutral'>        );</span>
 277 |     | <span class='neutral'>    }</span>
 278 |     | <span class='neutral'></span>
 279 |     | <span class='unexecuted'>    function test_Fail_If_Proposer_Below_Threshold() public {</span>
 280 |     | <span class='unexecuted'>        vm.prank(poorVoter);</span>
 281 |     | <span class='neutral'></span>
 282 |     | <span class='unexecuted'>        address[] memory targets = new address[](1);</span>
 283 |     | <span class='unexecuted'>        targets[0] = address(marketplace);</span>
 284 |     | <span class='unexecuted'>        uint256[] memory values = new uint256[](1);</span>
 285 |     | <span class='unexecuted'>        bytes[] memory calldatas = new bytes[](1);</span>
 286 |     | <span class='unexecuted'>        calldatas[0] = abi.encodeWithSelector(Marketplace.setTreasury.selector, treasuryAddr);</span>
 287 |     | <span class='unexecuted'>        string memory description = &quot;This proposal should fail&quot;;</span>
 288 |     | <span class='neutral'></span>
 289 |     | <span class='unexecuted'>        vm.expectRevert(</span>
 290 |     | <span class='unexecuted'>            abi.encodeWithSignature(</span>
 291 |     | <span class='unexecuted'>                &quot;GovernorInsufficientProposerVotes(address,uint256,uint256)&quot;, poorVoter, 1e18, PROPOSAL_THRESHOLD</span>
 292 |     | <span class='neutral'>            )</span>
 293 |     | <span class='neutral'>        );</span>
 294 |     | <span class='unexecuted'>        AzemoraGovernor(governorAddr).propose(targets, values, calldatas, description);</span>
 295 |     | <span class='neutral'>    }</span>
 296 |     | <span class='neutral'></span>
 297 |     | <span class='unexecuted'>    function test_Proposal_Cancellation_Permissions() public {</span>
 298 |     | <span class='neutral'>        // --- Setup ---</span>
 299 |     | <span class='unexecuted'>        address[] memory targets = new address[](1);</span>
 300 |     | <span class='unexecuted'>        targets[0] = address(marketplace);</span>
 301 |     | <span class='unexecuted'>        uint256[] memory values = new uint256[](1);</span>
 302 |     | <span class='unexecuted'>        bytes[] memory calldatas = new bytes[](1);</span>
 303 |     | <span class='unexecuted'>        calldatas[0] = abi.encodeWithSelector(Marketplace.setTreasury.selector, treasuryAddr);</span>
 304 |     | <span class='neutral'></span>
 305 |     | <span class='neutral'>        // --- Scenario 1: Proposer CAN cancel ---</span>
 306 |     | <span class='unexecuted'>        string memory description1 = &quot;Proposal 1&quot;;</span>
 307 |     | <span class='unexecuted'>        bytes32 descriptionHash1 = keccak256(bytes(description1));</span>
 308 |     | <span class='unexecuted'>        vm.prank(voter);</span>
 309 |     | <span class='unexecuted'>        uint256 proposalId1 = AzemoraGovernor(governorAddr).propose(targets, values, calldatas, description1);</span>
 310 |     | <span class='neutral'></span>
 311 |     | <span class='unexecuted'>        vm.prank(voter); // The proposer themself cancels</span>
 312 |     | <span class='unexecuted'>        AzemoraGovernor(governorAddr).cancel(targets, values, calldatas, descriptionHash1);</span>
 313 |     | <span class='unexecuted'>        assertEq(uint256(AzemoraGovernor(governorAddr).state(proposalId1)), 2, &quot;State should be Canceled by proposer&quot;);</span>
 314 |     | <span class='neutral'></span>
 315 |     | <span class='neutral'>        // --- Scenario 2: Non-proposer CANNOT cancel ---</span>
 316 |     | <span class='unexecuted'>        string memory description2 = &quot;Proposal 2&quot;;</span>
 317 |     | <span class='unexecuted'>        bytes32 descriptionHash2 = keccak256(bytes(description2));</span>
 318 |     | <span class='unexecuted'>        vm.prank(voter); // voter makes a new proposal</span>
 319 |     | <span class='unexecuted'>        uint256 proposalId2 = AzemoraGovernor(governorAddr).propose(targets, values, calldatas, description2);</span>
 320 |     | <span class='neutral'></span>
 321 |     | <span class='unexecuted'>        vm.prank(voter2); // Non-proposer (voter2) attempts to cancel</span>
 322 |     | <span class='unexecuted'>        vm.expectRevert(abi.encodeWithSignature(&quot;GovernorUnableToCancel(uint256,address)&quot;, proposalId2, voter2));</span>
 323 |     | <span class='unexecuted'>        AzemoraGovernor(governorAddr).cancel(targets, values, calldatas, descriptionHash2);</span>
 324 |     | <span class='neutral'></span>
 325 |     | <span class='neutral'>        // Verify state is unchanged after failed cancellation attempt</span>
 326 |     | <span class='unexecuted'>        assertEq(uint256(AzemoraGovernor(governorAddr).state(proposalId2)), 0, &quot;State should still be Pending&quot;);</span>
 327 |     | <span class='neutral'>    }</span>
 328 |     | <span class='neutral'></span>
 329 |     | <span class='unexecuted'>    function test_Execution_Fails_If_Target_Call_Reverts() public {</span>
 330 |     | <span class='unexecuted'>        uint256 treasuryBalance = address(treasuryAddr).balance; // 10 ether</span>
 331 |     | <span class='unexecuted'>        uint256 withdrawAmount = treasuryBalance + 1 ether; // Attempt to withdraw more than available</span>
 332 |     | <span class='neutral'></span>
 333 |     | <span class='neutral'>        // --- 1. Propose ---</span>
 334 |     | <span class='unexecuted'>        address[] memory targets = new address[](1);</span>
 335 |     | <span class='unexecuted'>        targets[0] = treasuryAddr;</span>
 336 |     | <span class='unexecuted'>        uint256[] memory values = new uint256[](1);</span>
 337 |     | <span class='unexecuted'>        bytes[] memory calldatas = new bytes[](1);</span>
 338 |     | <span class='unexecuted'>        calldatas[0] = abi.encodeWithSelector(Treasury.withdrawETH.selector, recipient, withdrawAmount);</span>
 339 |     | <span class='unexecuted'>        string memory description = &quot;Proposal to withdraw more ETH than available&quot;;</span>
 340 |     | <span class='unexecuted'>        bytes32 descriptionHash = keccak256(bytes(description));</span>
 341 |     | <span class='neutral'></span>
 342 |     | <span class='neutral'>        // Propose, vote, and queue successfully</span>
 343 |     | <span class='unexecuted'>        vm.prank(voter);</span>
 344 |     | <span class='unexecuted'>        uint256 proposalId = AzemoraGovernor(governorAddr).propose(targets, values, calldatas, description);</span>
 345 |     | <span class='unexecuted'>        vm.roll(block.number + VOTING_DELAY + 1);</span>
 346 |     | <span class='unexecuted'>        vm.prank(voter);</span>
 347 |     | <span class='unexecuted'>        AzemoraGovernor(governorAddr).castVote(proposalId, uint8(1));</span>
 348 |     | <span class='unexecuted'>        vm.roll(block.number + VOTING_PERIOD + 1);</span>
 349 |     | <span class='unexecuted'>        AzemoraGovernor(governorAddr).queue(targets, values, calldatas, descriptionHash);</span>
 350 |     | <span class='neutral'></span>
 351 |     | <span class='neutral'>        // --- 2. Execute ---</span>
 352 |     | <span class='unexecuted'>        vm.warp(block.timestamp + MIN_DELAY + 1);</span>
 353 |     | <span class='neutral'></span>
 354 |     | <span class='neutral'>        // Expect execution to fail because the treasury withdrawal will revert</span>
 355 |     | <span class='unexecuted'>        vm.expectRevert(&quot;Insufficient ETH balance&quot;);</span>
 356 |     | <span class='unexecuted'>        AzemoraGovernor(governorAddr).execute(targets, values, calldatas, descriptionHash);</span>
 357 |     | <span class='neutral'>    }</span>
 358 |     | <span class='neutral'>}</span>
 359 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/phantom/Documents/azemora/azemora-contracts/test/governance/Treasury.t.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>pragma solidity ^0.8.20;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>import &quot;forge-std/Test.sol&quot;;</span>
  5 |     | <span class='neutral'>import &quot;../../src/governance/Treasury.sol&quot;;</span>
  6 |     | <span class='neutral'>import &quot;@openzeppelin/contracts/proxy/ERC1967/ERC1967Proxy.sol&quot;;</span>
  7 |     | <span class='neutral'></span>
  8 |     | <span class='neutral'>// Minimal mock ERC20 to avoid dependency on forge-std/mocks</span>
  9 |     | <span class='unexecuted'>contract MockERC20 {</span>
 10 |     | <span class='neutral'>    event Transfer(address indexed from, address indexed to, uint256 value);</span>
 11 |     | <span class='neutral'>    event Approval(address indexed owner, address indexed spender, uint256 value);</span>
 12 |     | <span class='neutral'></span>
 13 |     | <span class='unexecuted'>    mapping(address =&gt; uint256) public balanceOf;</span>
 14 |     | <span class='unexecuted'>    mapping(address =&gt; mapping(address =&gt; uint256)) public allowance;</span>
 15 |     | <span class='unexecuted'>    uint256 public totalSupply;</span>
 16 |     | <span class='unexecuted'>    string public name;</span>
 17 |     | <span class='unexecuted'>    string public symbol;</span>
 18 |     | <span class='unexecuted'>    uint8 public decimals;</span>
 19 |     | <span class='neutral'></span>
 20 |     | <span class='unexecuted'>    constructor(string memory name_, string memory symbol_, uint8 decimals_) {</span>
 21 |     | <span class='unexecuted'>        name = name_;</span>
 22 |     | <span class='unexecuted'>        symbol = symbol_;</span>
 23 |     | <span class='unexecuted'>        decimals = decimals_;</span>
 24 |     | <span class='neutral'>    }</span>
 25 |     | <span class='neutral'></span>
 26 |     | <span class='unexecuted'>    function approve(address spender, uint256 amount) public returns (bool) {</span>
 27 |     | <span class='unexecuted'>        allowance[msg.sender][spender] = amount;</span>
 28 |     | <span class='unexecuted'>        emit Approval(msg.sender, spender, amount);</span>
 29 |     | <span class='unexecuted'>        return true;</span>
 30 |     | <span class='neutral'>    }</span>
 31 |     | <span class='neutral'></span>
 32 |     | <span class='unexecuted'>    function transfer(address to, uint256 amount) public returns (bool) {</span>
 33 |     | <span class='unexecuted'>        balanceOf[msg.sender] -= amount;</span>
 34 |     | <span class='unexecuted'>        balanceOf[to] += amount;</span>
 35 |     | <span class='unexecuted'>        emit Transfer(msg.sender, to, amount);</span>
 36 |     | <span class='neutral'>        return true;</span>
 37 |     | <span class='neutral'>    }</span>
 38 |     | <span class='neutral'></span>
 39 |     | <span class='unexecuted'>    function transferFrom(address from, address to, uint256 amount) public returns (bool) {</span>
 40 |     | <span class='unexecuted'>        require(balanceOf[from] &gt;= amount, &quot;ERC20: insufficient balance&quot;);</span>
 41 |     | <span class='unexecuted'>        require(allowance[from][msg.sender] &gt;= amount, &quot;ERC20: insufficient allowance&quot;);</span>
 42 |     | <span class='unexecuted'>        if (allowance[from][msg.sender] != type(uint256).max) {</span>
 43 |     | <span class='unexecuted'>            allowance[from][msg.sender] -= amount;</span>
 44 |     | <span class='neutral'>        }</span>
 45 |     | <span class='unexecuted'>        balanceOf[from] -= amount;</span>
 46 |     | <span class='unexecuted'>        balanceOf[to] += amount;</span>
 47 |     | <span class='unexecuted'>        emit Transfer(from, to, amount);</span>
 48 |     | <span class='unexecuted'>        return true;</span>
 49 |     | <span class='neutral'>    }</span>
 50 |     | <span class='neutral'></span>
 51 |     | <span class='unexecuted'>    function mint(address to, uint256 amount) public {</span>
 52 |     | <span class='unexecuted'>        balanceOf[to] += amount;</span>
 53 |     | <span class='unexecuted'>        totalSupply += amount;</span>
 54 |     | <span class='unexecuted'>        emit Transfer(address(0), to, amount);</span>
 55 |     | <span class='neutral'>    }</span>
 56 |     | <span class='neutral'>}</span>
 57 |     | <span class='neutral'></span>
 58 |     | <span class='unexecuted'>contract TreasuryTest is Test {</span>
 59 |     | <span class='neutral'>    Treasury treasury;</span>
 60 |     | <span class='neutral'>    MockERC20 token;</span>
 61 |     | <span class='neutral'></span>
 62 |     | <span class='unexecuted'>    address admin = address(0xA11CE);</span>
 63 |     | <span class='unexecuted'>    address anotherUser = address(0xBEEF);</span>
 64 |     | <span class='neutral'></span>
 65 |     | <span class='unexecuted'>    function setUp() public {</span>
 66 |     | <span class='unexecuted'>        token = new MockERC20(&quot;Mock Token&quot;, &quot;MOCK&quot;, 18);</span>
 67 |     | <span class='neutral'></span>
 68 |     | <span class='unexecuted'>        vm.startPrank(admin);</span>
 69 |     | <span class='unexecuted'>        Treasury treasuryImpl = new Treasury();</span>
 70 |     | <span class='unexecuted'>        bytes memory treasuryInitData = abi.encodeCall(Treasury.initialize, (admin));</span>
 71 |     | <span class='unexecuted'>        ERC1967Proxy treasuryProxy = new ERC1967Proxy(address(treasuryImpl), treasuryInitData);</span>
 72 |     | <span class='unexecuted'>        treasury = Treasury(payable(address(treasuryProxy)));</span>
 73 |     | <span class='unexecuted'>        vm.stopPrank();</span>
 74 |     | <span class='neutral'></span>
 75 |     | <span class='neutral'>        // Fund treasury with some ETH and ERC20</span>
 76 |     | <span class='unexecuted'>        vm.deal(address(treasury), 1 ether);</span>
 77 |     | <span class='unexecuted'>        token.mint(address(treasury), 1000 * 1e18);</span>
 78 |     | <span class='neutral'>    }</span>
 79 |     | <span class='neutral'></span>
 80 |     | <span class='unexecuted'>    function test_WithdrawETH_RevertsOnZeroAddress() public {</span>
 81 |     | <span class='unexecuted'>        vm.prank(admin);</span>
 82 |     | <span class='unexecuted'>        vm.expectRevert(&quot;Cannot send to zero address&quot;);</span>
 83 |     | <span class='unexecuted'>        treasury.withdrawETH(address(0), 1 ether);</span>
 84 |     | <span class='neutral'>    }</span>
 85 |     | <span class='neutral'></span>
 86 |     | <span class='unexecuted'>    function test_WithdrawETH_RevertsOnInsufficientBalance() public {</span>
 87 |     | <span class='unexecuted'>        vm.prank(admin);</span>
 88 |     | <span class='unexecuted'>        vm.expectRevert(&quot;Insufficient ETH balance&quot;);</span>
 89 |     | <span class='unexecuted'>        treasury.withdrawETH(anotherUser, 2 ether);</span>
 90 |     | <span class='neutral'>    }</span>
 91 |     | <span class='neutral'></span>
 92 |     | <span class='unexecuted'>    function test_WithdrawERC20_RevertsOnZeroAddress() public {</span>
 93 |     | <span class='unexecuted'>        vm.prank(admin);</span>
 94 |     | <span class='unexecuted'>        vm.expectRevert(&quot;Cannot send to zero address&quot;);</span>
 95 |     | <span class='unexecuted'>        treasury.withdrawERC20(address(token), address(0), 100 * 1e18);</span>
 96 |     | <span class='neutral'>    }</span>
 97 |     | <span class='neutral'>}</span>
 98 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/phantom/Documents/azemora/azemora-contracts/test/integration/FullFlow.t.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'>pragma solidity ^0.8.20;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>import &quot;forge-std/Test.sol&quot;;</span>
   5 |     | <span class='neutral'>import &quot;../../src/token/AzemoraToken.sol&quot;;</span>
   6 |     | <span class='neutral'>import &quot;../../src/governance/AzemoraGovernor.sol&quot;;</span>
   7 |     | <span class='neutral'>import &quot;../../src/governance/AzemoraTimelockController.sol&quot;;</span>
   8 |     | <span class='neutral'>import &quot;../../src/governance/Treasury.sol&quot;;</span>
   9 |     | <span class='neutral'>import &quot;../../src/marketplace/Marketplace.sol&quot;;</span>
  10 |     | <span class='neutral'>import &quot;../../src/core/DynamicImpactCredit.sol&quot;;</span>
  11 |     | <span class='neutral'>import &quot;../../src/core/ProjectRegistry.sol&quot;;</span>
  12 |     | <span class='neutral'>import &quot;../../src/core/dMRVManager.sol&quot;;</span>
  13 |     | <span class='neutral'>import &quot;@openzeppelin/contracts/proxy/ERC1967/ERC1967Proxy.sol&quot;;</span>
  14 |     | <span class='neutral'></span>
  15 |     | <span class='neutral'>// Re-using the mock from marketplace tests</span>
  16 |     | <span class='unexecuted'>contract MockERC20ForFlowTest {</span>
  17 |     | <span class='neutral'>    event Transfer(address indexed from, address indexed to, uint256 value);</span>
  18 |     | <span class='neutral'>    event Approval(address indexed owner, address indexed spender, uint256 value);</span>
  19 |     | <span class='neutral'></span>
  20 |     | <span class='unexecuted'>    mapping(address =&gt; uint256) public balanceOf;</span>
  21 |     | <span class='unexecuted'>    mapping(address =&gt; mapping(address =&gt; uint256)) public allowance;</span>
  22 |     | <span class='neutral'></span>
  23 |     | <span class='unexecuted'>    function approve(address spender, uint256 amount) public returns (bool) {</span>
  24 |     | <span class='unexecuted'>        allowance[msg.sender][spender] = amount;</span>
  25 |     | <span class='unexecuted'>        emit Approval(msg.sender, spender, amount);</span>
  26 |     | <span class='unexecuted'>        return true;</span>
  27 |     | <span class='neutral'>    }</span>
  28 |     | <span class='neutral'></span>
  29 |     | <span class='unexecuted'>    function transferFrom(address from, address to, uint256 amount) public returns (bool) {</span>
  30 |     | <span class='unexecuted'>        require(allowance[from][msg.sender] &gt;= amount, &quot;ERC20: insufficient allowance&quot;);</span>
  31 |     | <span class='unexecuted'>        if (allowance[from][msg.sender] != type(uint256).max) {</span>
  32 |     | <span class='unexecuted'>            allowance[from][msg.sender] -= amount;</span>
  33 |     | <span class='neutral'>        }</span>
  34 |     | <span class='unexecuted'>        balanceOf[from] -= amount;</span>
  35 |     | <span class='unexecuted'>        balanceOf[to] += amount;</span>
  36 |     | <span class='unexecuted'>        emit Transfer(from, to, amount);</span>
  37 |     | <span class='unexecuted'>        return true;</span>
  38 |     | <span class='neutral'>    }</span>
  39 |     | <span class='neutral'></span>
  40 |     | <span class='unexecuted'>    function transfer(address to, uint256 amount) public returns (bool) {</span>
  41 |     | <span class='neutral'>        // In the context of the treasury withdrawal, msg.sender will be the treasury contract</span>
  42 |     | <span class='unexecuted'>        require(balanceOf[msg.sender] &gt;= amount, &quot;ERC20: insufficient balance&quot;);</span>
  43 |     | <span class='unexecuted'>        balanceOf[msg.sender] -= amount;</span>
  44 |     | <span class='unexecuted'>        balanceOf[to] += amount;</span>
  45 |     | <span class='unexecuted'>        emit Transfer(msg.sender, to, amount);</span>
  46 |     | <span class='neutral'>        return true;</span>
  47 |     | <span class='neutral'>    }</span>
  48 |     | <span class='neutral'></span>
  49 |     | <span class='unexecuted'>    function mint(address to, uint256 amount) public {</span>
  50 |     | <span class='unexecuted'>        balanceOf[to] += amount;</span>
  51 |     | <span class='unexecuted'>        emit Transfer(address(0), to, amount);</span>
  52 |     | <span class='neutral'>    }</span>
  53 |     | <span class='neutral'>}</span>
  54 |     | <span class='neutral'></span>
  55 |     | <span class='unexecuted'>contract FullFlowTest is Test {</span>
  56 |     | <span class='neutral'>    // --- Contracts ---</span>
  57 |     | <span class='neutral'>    // Core Logic</span>
  58 |     | <span class='neutral'>    ProjectRegistry registry;</span>
  59 |     | <span class='neutral'>    DMRVManager dmrvManager;</span>
  60 |     | <span class='neutral'>    DynamicImpactCredit credit;</span>
  61 |     | <span class='neutral'>    Marketplace marketplace;</span>
  62 |     | <span class='neutral'>    // Governance</span>
  63 |     | <span class='neutral'>    AzemoraToken govToken;</span>
  64 |     | <span class='neutral'>    AzemoraGovernor governor;</span>
  65 |     | <span class='neutral'>    AzemoraTimelockController timelock;</span>
  66 |     | <span class='neutral'>    Treasury treasury;</span>
  67 |     | <span class='neutral'>    // Mocks</span>
  68 |     | <span class='neutral'>    MockERC20ForFlowTest paymentToken;</span>
  69 |     | <span class='neutral'></span>
  70 |     | <span class='neutral'>    // --- Actors ---</span>
  71 |     | <span class='unexecuted'>    address admin = makeAddr(&quot;admin&quot;);</span>
  72 |     | <span class='unexecuted'>    address projectDeveloper = makeAddr(&quot;projectDeveloper&quot;);</span>
  73 |     | <span class='unexecuted'>    address verifier = makeAddr(&quot;verifier&quot;);</span>
  74 |     | <span class='unexecuted'>    address dmrvOracle = makeAddr(&quot;dmrvOracle&quot;);</span>
  75 |     | <span class='unexecuted'>    address buyer = makeAddr(&quot;buyer&quot;);</span>
  76 |     | <span class='unexecuted'>    address governanceProposer = makeAddr(&quot;governanceProposer&quot;);</span>
  77 |     | <span class='unexecuted'>    address feeRecipient = makeAddr(&quot;feeRecipient&quot;);</span>
  78 |     | <span class='neutral'></span>
  79 |     | <span class='neutral'>    // --- Constants ---</span>
  80 |     | <span class='unexecuted'>    uint256 constant VOTING_DELAY = 1; // blocks</span>
  81 |     | <span class='unexecuted'>    uint256 constant VOTING_PERIOD = 5; // blocks</span>
  82 |     | <span class='unexecuted'>    uint256 constant MIN_DELAY = 1; // seconds</span>
  83 |     | <span class='neutral'></span>
  84 |     | <span class='unexecuted'>    function setUp() public {</span>
  85 |     | <span class='unexecuted'>        vm.startPrank(admin);</span>
  86 |     | <span class='neutral'></span>
  87 |     | <span class='neutral'>        // --- 1. DEPLOY GOVERNANCE &amp; TREASURY ---</span>
  88 |     | <span class='unexecuted'>        AzemoraToken govTokenImpl = new AzemoraToken();</span>
  89 |     | <span class='unexecuted'>        govToken =</span>
  90 |     | <span class='unexecuted'>            AzemoraToken(address(new ERC1967Proxy(address(govTokenImpl), abi.encodeCall(AzemoraToken.initialize, ()))));</span>
  91 |     | <span class='neutral'></span>
  92 |     | <span class='unexecuted'>        AzemoraTimelockController timelockImpl = new AzemoraTimelockController();</span>
  93 |     | <span class='unexecuted'>        timelock = AzemoraTimelockController(</span>
  94 |     | <span class='neutral'>            payable(</span>
  95 |     | <span class='neutral'>                address(</span>
  96 |     | <span class='unexecuted'>                    new ERC1967Proxy(</span>
  97 |     | <span class='neutral'>                        address(timelockImpl),</span>
  98 |     | <span class='unexecuted'>                        abi.encodeCall(</span>
  99 |     | <span class='unexecuted'>                            AzemoraTimelockController.initialize, (MIN_DELAY, new address[](0), new address[](0), admin)</span>
 100 |     | <span class='neutral'>                        )</span>
 101 |     | <span class='neutral'>                    )</span>
 102 |     | <span class='neutral'>                )</span>
 103 |     | <span class='neutral'>            )</span>
 104 |     | <span class='neutral'>        );</span>
 105 |     | <span class='neutral'></span>
 106 |     | <span class='unexecuted'>        AzemoraGovernor governorImpl = new AzemoraGovernor();</span>
 107 |     | <span class='unexecuted'>        governor = AzemoraGovernor(</span>
 108 |     | <span class='neutral'>            payable(</span>
 109 |     | <span class='neutral'>                address(</span>
 110 |     | <span class='unexecuted'>                    new ERC1967Proxy(</span>
 111 |     | <span class='neutral'>                        address(governorImpl),</span>
 112 |     | <span class='unexecuted'>                        abi.encodeCall(</span>
 113 |     | <span class='neutral'>                            AzemoraGovernor.initialize,</span>
 114 |     | <span class='unexecuted'>                            (govToken, timelock, uint48(VOTING_DELAY), uint32(VOTING_PERIOD), 0)</span>
 115 |     | <span class='neutral'>                        )</span>
 116 |     | <span class='neutral'>                    )</span>
 117 |     | <span class='neutral'>                )</span>
 118 |     | <span class='neutral'>            )</span>
 119 |     | <span class='neutral'>        );</span>
 120 |     | <span class='neutral'></span>
 121 |     | <span class='unexecuted'>        Treasury treasuryImpl = new Treasury();</span>
 122 |     | <span class='unexecuted'>        treasury = Treasury(</span>
 123 |     | <span class='unexecuted'>            payable(address(new ERC1967Proxy(address(treasuryImpl), abi.encodeCall(Treasury.initialize, (admin)))))</span>
 124 |     | <span class='neutral'>        );</span>
 125 |     | <span class='unexecuted'>        vm.deal(address(treasury), 10 ether); // Pre-fund treasury for other tests if needed</span>
 126 |     | <span class='neutral'></span>
 127 |     | <span class='neutral'>        // --- 2. DEPLOY CORE LOGIC ---</span>
 128 |     | <span class='unexecuted'>        ProjectRegistry registryImpl = new ProjectRegistry();</span>
 129 |     | <span class='unexecuted'>        registry = ProjectRegistry(</span>
 130 |     | <span class='unexecuted'>            address(new ERC1967Proxy(address(registryImpl), abi.encodeCall(ProjectRegistry.initialize, ())))</span>
 131 |     | <span class='neutral'>        );</span>
 132 |     | <span class='neutral'></span>
 133 |     | <span class='unexecuted'>        DynamicImpactCredit creditImpl = new DynamicImpactCredit(address(registry));</span>
 134 |     | <span class='unexecuted'>        credit = DynamicImpactCredit(</span>
 135 |     | <span class='unexecuted'>            address(new ERC1967Proxy(address(creditImpl), abi.encodeCall(DynamicImpactCredit.initialize, (&quot;ipfs://&quot;))))</span>
 136 |     | <span class='neutral'>        );</span>
 137 |     | <span class='neutral'></span>
 138 |     | <span class='unexecuted'>        DMRVManager dmrvManagerImpl = new DMRVManager(address(registry), address(credit));</span>
 139 |     | <span class='unexecuted'>        dmrvManager =</span>
 140 |     | <span class='unexecuted'>            DMRVManager(address(new ERC1967Proxy(address(dmrvManagerImpl), abi.encodeCall(DMRVManager.initialize, ()))));</span>
 141 |     | <span class='neutral'></span>
 142 |     | <span class='neutral'>        // --- 3. DEPLOY MARKETPLACE ---</span>
 143 |     | <span class='unexecuted'>        paymentToken = new MockERC20ForFlowTest();</span>
 144 |     | <span class='unexecuted'>        Marketplace marketplaceImpl = new Marketplace();</span>
 145 |     | <span class='unexecuted'>        marketplace = Marketplace(</span>
 146 |     | <span class='neutral'>            address(</span>
 147 |     | <span class='unexecuted'>                new ERC1967Proxy(</span>
 148 |     | <span class='neutral'>                    address(marketplaceImpl),</span>
 149 |     | <span class='unexecuted'>                    abi.encodeCall(Marketplace.initialize, (address(credit), address(paymentToken)))</span>
 150 |     | <span class='neutral'>                )</span>
 151 |     | <span class='neutral'>            )</span>
 152 |     | <span class='neutral'>        );</span>
 153 |     | <span class='neutral'></span>
 154 |     | <span class='neutral'>        // --- 4. CONFIGURE ROLES &amp; OWNERSHIP ---</span>
 155 |     | <span class='neutral'>        // Grant dMRVManager the right to mint credits</span>
 156 |     | <span class='unexecuted'>        credit.grantRole(credit.DMRV_MANAGER_ROLE(), address(dmrvManager));</span>
 157 |     | <span class='neutral'>        // Grant verifier role in the registry</span>
 158 |     | <span class='unexecuted'>        registry.grantRole(registry.VERIFIER_ROLE(), verifier);</span>
 159 |     | <span class='neutral'>        // Grant oracle role in dMRV Manager</span>
 160 |     | <span class='unexecuted'>        dmrvManager.grantRole(dmrvManager.ORACLE_ROLE(), dmrvOracle);</span>
 161 |     | <span class='neutral'>        // Set marketplace treasury</span>
 162 |     | <span class='unexecuted'>        marketplace.setTreasury(address(treasury));</span>
 163 |     | <span class='unexecuted'>        marketplace.setFee(500); // 5% fee</span>
 164 |     | <span class='neutral'></span>
 165 |     | <span class='neutral'>        // Configure Governance</span>
 166 |     | <span class='unexecuted'>        bytes32 proposerRole = timelock.PROPOSER_ROLE();</span>
 167 |     | <span class='unexecuted'>        bytes32 executorRole = timelock.EXECUTOR_ROLE();</span>
 168 |     | <span class='unexecuted'>        bytes32 timelockAdminRole = timelock.DEFAULT_ADMIN_ROLE();</span>
 169 |     | <span class='neutral'></span>
 170 |     | <span class='unexecuted'>        timelock.grantRole(proposerRole, address(governor));</span>
 171 |     | <span class='unexecuted'>        timelock.grantRole(executorRole, address(0)); // Anyone can execute</span>
 172 |     | <span class='neutral'></span>
 173 |     | <span class='neutral'>        // Transfer contract ownership to the Timelock/DAO</span>
 174 |     | <span class='unexecuted'>        treasury.transferOwnership(address(timelock));</span>
 175 |     | <span class='neutral'>        // Note: Other contracts with admin roles would also be transferred here in a real scenario</span>
 176 |     | <span class='neutral'>        // e.g., marketplace.grantRole(marketplace.DEFAULT_ADMIN_ROLE(), address(timelock));</span>
 177 |     | <span class='neutral'></span>
 178 |     | <span class='neutral'>        // Renounce initial admin control</span>
 179 |     | <span class='unexecuted'>        timelock.renounceRole(timelockAdminRole, admin);</span>
 180 |     | <span class='neutral'></span>
 181 |     | <span class='neutral'>        // --- 5. SETUP ACTOR STATE ---</span>
 182 |     | <span class='neutral'>        // Fund buyer with payment tokens</span>
 183 |     | <span class='unexecuted'>        paymentToken.mint(buyer, 1_000_000 * 1e18);</span>
 184 |     | <span class='neutral'>        // Fund proposer with enough governance tokens to pass quorum (4% of 1B)</span>
 185 |     | <span class='unexecuted'>        govToken.transfer(governanceProposer, 40_000_000e18);</span>
 186 |     | <span class='neutral'></span>
 187 |     | <span class='unexecuted'>        vm.stopPrank(); // End the admin&#39;s multi-line prank</span>
 188 |     | <span class='neutral'></span>
 189 |     | <span class='unexecuted'>        vm.prank(governanceProposer); // Start a new single-line prank for the proposer</span>
 190 |     | <span class='unexecuted'>        govToken.delegate(governanceProposer);</span>
 191 |     | <span class='neutral'></span>
 192 |     | <span class='unexecuted'>        vm.roll(block.number + 1); // Let delegations register</span>
 193 |     | <span class='neutral'>    }</span>
 194 |     | <span class='neutral'></span>
 195 |     | <span class='unexecuted'>    function test_Full_End_To_End_Lifecycle() public {</span>
 196 |     | <span class='neutral'>        // --- STAGE 1: Project Creation &amp; Verification ---</span>
 197 |     | <span class='unexecuted'>        bytes32 projectId = keccak256(&quot;Great Green Wall&quot;);</span>
 198 |     | <span class='unexecuted'>        vm.prank(projectDeveloper);</span>
 199 |     | <span class='unexecuted'>        registry.registerProject(projectId, &quot;ipfs://great-green-wall&quot;);</span>
 200 |     | <span class='neutral'></span>
 201 |     | <span class='unexecuted'>        vm.prank(verifier);</span>
 202 |     | <span class='unexecuted'>        registry.setProjectStatus(projectId, ProjectRegistry.ProjectStatus.Active);</span>
 203 |     | <span class='unexecuted'>        assertEq(</span>
 204 |     | <span class='unexecuted'>            uint256(registry.getProject(projectId).status),</span>
 205 |     | <span class='unexecuted'>            uint256(ProjectRegistry.ProjectStatus.Active),</span>
 206 |     | <span class='neutral'>            &quot;Project should be active&quot;</span>
 207 |     | <span class='neutral'>        );</span>
 208 |     | <span class='neutral'></span>
 209 |     | <span class='neutral'>        // --- STAGE 2: dMRV and Credit Minting ---</span>
 210 |     | <span class='unexecuted'>        uint256 creditsToMint = 500;</span>
 211 |     | <span class='unexecuted'>        string memory verificationURI = &quot;ipfs://verification-report-1&quot;;</span>
 212 |     | <span class='neutral'></span>
 213 |     | <span class='neutral'>        // 2.1 Project developer requests verification</span>
 214 |     | <span class='unexecuted'>        vm.prank(projectDeveloper);</span>
 215 |     | <span class='unexecuted'>        bytes32 requestId = dmrvManager.requestVerification(projectId);</span>
 216 |     | <span class='neutral'></span>
 217 |     | <span class='neutral'>        // 2.2 Oracle fulfills the verification request</span>
 218 |     | <span class='unexecuted'>        vm.prank(dmrvOracle);</span>
 219 |     | <span class='unexecuted'>        bytes memory verificationData = abi.encode(creditsToMint, false, bytes32(0), verificationURI);</span>
 220 |     | <span class='unexecuted'>        dmrvManager.fulfillVerification(requestId, verificationData);</span>
 221 |     | <span class='neutral'></span>
 222 |     | <span class='unexecuted'>        assertEq(</span>
 223 |     | <span class='unexecuted'>            credit.balanceOf(projectDeveloper, uint256(projectId)),</span>
 224 |     | <span class='unexecuted'>            creditsToMint,</span>
 225 |     | <span class='neutral'>            &quot;Developer should have minted credits&quot;</span>
 226 |     | <span class='neutral'>        );</span>
 227 |     | <span class='neutral'></span>
 228 |     | <span class='neutral'>        // --- STAGE 3: Marketplace Listing &amp; Purchase ---</span>
 229 |     | <span class='unexecuted'>        uint256 listAmount = 100;</span>
 230 |     | <span class='unexecuted'>        uint256 pricePerUnit = 20 * 1e18; // 20 payment tokens per credit</span>
 231 |     | <span class='neutral'>        uint256 listingId;</span>
 232 |     | <span class='neutral'></span>
 233 |     | <span class='unexecuted'>        vm.startPrank(projectDeveloper);</span>
 234 |     | <span class='unexecuted'>        credit.setApprovalForAll(address(marketplace), true);</span>
 235 |     | <span class='unexecuted'>        listingId = marketplace.list(uint256(projectId), listAmount, pricePerUnit, 1 days);</span>
 236 |     | <span class='unexecuted'>        vm.stopPrank();</span>
 237 |     | <span class='neutral'></span>
 238 |     | <span class='unexecuted'>        assertEq(</span>
 239 |     | <span class='unexecuted'>            credit.balanceOf(address(marketplace), uint256(projectId)),</span>
 240 |     | <span class='unexecuted'>            listAmount,</span>
 241 |     | <span class='neutral'>            &quot;Marketplace should hold listed credits&quot;</span>
 242 |     | <span class='neutral'>        );</span>
 243 |     | <span class='neutral'></span>
 244 |     | <span class='unexecuted'>        uint256 buyAmount = 50;</span>
 245 |     | <span class='unexecuted'>        uint256 totalPrice = buyAmount * pricePerUnit;</span>
 246 |     | <span class='unexecuted'>        uint256 fee = (totalPrice * marketplace.feeBps()) / 10000;</span>
 247 |     | <span class='neutral'></span>
 248 |     | <span class='unexecuted'>        uint256 treasuryInitialBalance = paymentToken.balanceOf(address(treasury));</span>
 249 |     | <span class='neutral'></span>
 250 |     | <span class='unexecuted'>        vm.startPrank(buyer);</span>
 251 |     | <span class='unexecuted'>        paymentToken.approve(address(marketplace), totalPrice);</span>
 252 |     | <span class='unexecuted'>        marketplace.buy(listingId, buyAmount);</span>
 253 |     | <span class='unexecuted'>        vm.stopPrank();</span>
 254 |     | <span class='neutral'></span>
 255 |     | <span class='unexecuted'>        assertEq(credit.balanceOf(buyer, uint256(projectId)), buyAmount, &quot;Buyer should receive purchased credits&quot;);</span>
 256 |     | <span class='unexecuted'>        assertEq(</span>
 257 |     | <span class='unexecuted'>            paymentToken.balanceOf(address(treasury)), treasuryInitialBalance + fee, &quot;Treasury should receive fees&quot;</span>
 258 |     | <span class='neutral'>        );</span>
 259 |     | <span class='neutral'></span>
 260 |     | <span class='neutral'>        // --- STAGE 4: Governance Withdraws Fees ---</span>
 261 |     | <span class='unexecuted'>        uint256 treasuryBalanceBefore = paymentToken.balanceOf(address(treasury));</span>
 262 |     | <span class='unexecuted'>        uint256 recipientBalanceBefore = paymentToken.balanceOf(feeRecipient);</span>
 263 |     | <span class='neutral'></span>
 264 |     | <span class='neutral'>        // 4.1 Propose</span>
 265 |     | <span class='unexecuted'>        address[] memory targets = new address[](1);</span>
 266 |     | <span class='unexecuted'>        targets[0] = address(treasury); // The timelock will call the Treasury contract</span>
 267 |     | <span class='unexecuted'>        uint256[] memory values = new uint256[](1); // No ETH</span>
 268 |     | <span class='unexecuted'>        bytes[] memory calldatas = new bytes[](1);</span>
 269 |     | <span class='neutral'>        // The proposal tells the timelock to call &#39;withdrawERC20&#39; on the treasury</span>
 270 |     | <span class='unexecuted'>        calldatas[0] = abi.encodeWithSelector(</span>
 271 |     | <span class='unexecuted'>            Treasury.withdrawERC20.selector, address(paymentToken), feeRecipient, treasuryBalanceBefore</span>
 272 |     | <span class='neutral'>        );</span>
 273 |     | <span class='neutral'></span>
 274 |     | <span class='unexecuted'>        string memory description = &quot;Withdraw collected fees from Treasury&quot;;</span>
 275 |     | <span class='unexecuted'>        bytes32 descriptionHash = keccak256(bytes(description));</span>
 276 |     | <span class='neutral'></span>
 277 |     | <span class='unexecuted'>        vm.prank(governanceProposer);</span>
 278 |     | <span class='unexecuted'>        uint256 proposalId = governor.propose(targets, values, calldatas, description);</span>
 279 |     | <span class='neutral'></span>
 280 |     | <span class='neutral'>        // 4.2 Vote</span>
 281 |     | <span class='unexecuted'>        vm.roll(block.number + VOTING_DELAY + 1);</span>
 282 |     | <span class='unexecuted'>        vm.prank(governanceProposer);</span>
 283 |     | <span class='unexecuted'>        governor.castVote(proposalId, uint8(1)); // Vote FOR</span>
 284 |     | <span class='neutral'></span>
 285 |     | <span class='neutral'>        // 4.3 Queue &amp; Execute</span>
 286 |     | <span class='unexecuted'>        vm.roll(block.number + VOTING_PERIOD + 1);</span>
 287 |     | <span class='unexecuted'>        governor.queue(targets, values, calldatas, descriptionHash);</span>
 288 |     | <span class='unexecuted'>        vm.warp(block.timestamp + MIN_DELAY + 1);</span>
 289 |     | <span class='unexecuted'>        governor.execute(targets, values, calldatas, descriptionHash);</span>
 290 |     | <span class='neutral'></span>
 291 |     | <span class='neutral'>        // --- STAGE 5: Final Verification ---</span>
 292 |     | <span class='unexecuted'>        assertEq(paymentToken.balanceOf(address(treasury)), 0, &quot;Treasury should be empty after withdrawal&quot;);</span>
 293 |     | <span class='unexecuted'>        assertEq(</span>
 294 |     | <span class='unexecuted'>            paymentToken.balanceOf(feeRecipient),</span>
 295 |     | <span class='unexecuted'>            recipientBalanceBefore + treasuryBalanceBefore,</span>
 296 |     | <span class='neutral'>            &quot;Fee Recipient should receive funds&quot;</span>
 297 |     | <span class='neutral'>        );</span>
 298 |     | <span class='neutral'>    }</span>
 299 |     | <span class='neutral'>}</span>
 300 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/phantom/Documents/azemora/azemora-contracts/test/invariants/Fee.invariant.t.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'>pragma solidity ^0.8.20;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>import &quot;forge-std/Test.sol&quot;;</span>
   5 |     | <span class='neutral'>import &quot;../../src/marketplace/Marketplace.sol&quot;;</span>
   6 |     | <span class='neutral'>import &quot;../../src/governance/Treasury.sol&quot;;</span>
   7 |     | <span class='neutral'>import &quot;../../src/core/DynamicImpactCredit.sol&quot;;</span>
   8 |     | <span class='neutral'>import &quot;../../src/core/ProjectRegistry.sol&quot;;</span>
   9 |     | <span class='neutral'>import &quot;@openzeppelin/contracts/proxy/ERC1967/ERC1967Proxy.sol&quot;;</span>
  10 |     | <span class='neutral'>import &quot;@openzeppelin/contracts/mocks/token/ERC20Mock.sol&quot;;</span>
  11 |     | <span class='neutral'>import &quot;../marketplace/Marketplace.t.sol&quot;;</span>
  12 |     | <span class='neutral'></span>
  13 |     | <span class='neutral'>// THE FIX: Define an interface to break the circular dependency.</span>
  14 |     | <span class='neutral'>// The handler will call this interface, and the test contract will implement it.</span>
  15 |     | <span class='neutral'>interface IFeeCallback {</span>
  16 |     | <span class='neutral'>    function addFee(uint256 fee) external;</span>
  17 |     | <span class='neutral'>}</span>
  18 |     | <span class='neutral'></span>
  19 |     | <span class='neutral'>/*</span>
  20 |     | <span class='neutral'> * @title FeeInvariantHandler</span>
  21 |     | <span class='neutral'> * @notice The &quot;fuzzer actor&quot; that performs random actions on the marketplace.</span>
  22 |     | <span class='neutral'> * @dev Foundry&#39;s fuzzer will call the functions on this contract. This handler</span>
  23 |     | <span class='neutral'> *      is stateful and attempts to perform valid operations. If an operation</span>
  24 |     | <span class='neutral'> *      succeeds, it notifies the main test contract to update the ghost variable.</span>
  25 |     | <span class='neutral'> */</span>
  26 |     | <span class='neutral'>// THE FIX: The handler must inherit from `Test` to use `vm` cheatcodes.</span>
  27 |     | <span class='unexecuted'>contract FeeInvariantHandler is Test {</span>
  28 |     | <span class='neutral'>    IFeeCallback immutable mainTest; // Depends on the simple interface</span>
  29 |     | <span class='neutral'>    Marketplace immutable marketplace;</span>
  30 |     | <span class='neutral'>    ERC20Mock immutable paymentToken;</span>
  31 |     | <span class='neutral'>    address immutable treasury;</span>
  32 |     | <span class='neutral'>    address immutable seller;</span>
  33 |     | <span class='neutral'>    address immutable buyer;</span>
  34 |     | <span class='neutral'>    uint256 immutable tokenId;</span>
  35 |     | <span class='neutral'></span>
  36 |     | <span class='neutral'>    // Keep track of listings created by this handler to try and buy from them.</span>
  37 |     | <span class='unexecuted'>    uint256[] public listingIds;</span>
  38 |     | <span class='neutral'></span>
  39 |     | <span class='unexecuted'>    constructor(</span>
  40 |     | <span class='neutral'>        IFeeCallback _mainTest, // Takes the interface as an argument</span>
  41 |     | <span class='neutral'>        Marketplace _marketplace,</span>
  42 |     | <span class='neutral'>        ERC20Mock _paymentToken,</span>
  43 |     | <span class='neutral'>        address _treasury,</span>
  44 |     | <span class='neutral'>        address _seller,</span>
  45 |     | <span class='neutral'>        address _buyer,</span>
  46 |     | <span class='neutral'>        uint256 _tokenId</span>
  47 |     | <span class='neutral'>    ) {</span>
  48 |     | <span class='unexecuted'>        mainTest = _mainTest;</span>
  49 |     | <span class='unexecuted'>        marketplace = _marketplace;</span>
  50 |     | <span class='unexecuted'>        paymentToken = _paymentToken;</span>
  51 |     | <span class='unexecuted'>        treasury = _treasury;</span>
  52 |     | <span class='unexecuted'>        seller = _seller;</span>
  53 |     | <span class='unexecuted'>        buyer = _buyer;</span>
  54 |     | <span class='unexecuted'>        tokenId = _tokenId;</span>
  55 |     | <span class='neutral'>    }</span>
  56 |     | <span class='neutral'></span>
  57 |     | <span class='neutral'>    /// @notice FUZZ ACTION: List 1 token for 1 ether.</span>
  58 |     | <span class='unexecuted'>    function list() public {</span>
  59 |     | <span class='unexecuted'>        vm.prank(seller);</span>
  60 |     | <span class='neutral'>        // We list only 1 token to have more individual listings to interact with.</span>
  61 |     | <span class='neutral'>        // This call can revert if the seller runs out of tokens, which is fine.</span>
  62 |     | <span class='unexecuted'>        try marketplace.list(tokenId, 1, 1 ether, 1 days) returns (uint256 newListingId) {</span>
  63 |     | <span class='unexecuted'>            listingIds.push(newListingId);</span>
  64 |     | <span class='neutral'>        } catch {}</span>
  65 |     | <span class='neutral'>    }</span>
  66 |     | <span class='neutral'></span>
  67 |     | <span class='neutral'>    /// @notice FUZZ ACTION: Attempt to buy 1 token from a random listing.</span>
  68 |     | <span class='unexecuted'>    function buy() public {</span>
  69 |     | <span class='unexecuted'>        if (listingIds.length == 0) return;</span>
  70 |     | <span class='neutral'></span>
  71 |     | <span class='neutral'>        // Pick a random listing to attempt to buy from.</span>
  72 |     | <span class='unexecuted'>        uint256 listingIndex = block.timestamp % listingIds.length;</span>
  73 |     | <span class='unexecuted'>        uint256 listingId = listingIds[listingIndex];</span>
  74 |     | <span class='neutral'></span>
  75 |     | <span class='neutral'>        // Check if the listing is still valid before attempting the buy.</span>
  76 |     | <span class='unexecuted'>        try marketplace.getListing(listingId) returns (Marketplace.Listing memory listing) {</span>
  77 |     | <span class='unexecuted'>            if (!listing.active || listing.amount == 0) return;</span>
  78 |     | <span class='neutral'></span>
  79 |     | <span class='unexecuted'>            uint256 amountToBuy = 1;</span>
  80 |     | <span class='unexecuted'>            uint256 cost = amountToBuy * listing.pricePerUnit;</span>
  81 |     | <span class='neutral'></span>
  82 |     | <span class='neutral'>            // Fuzzer needs funds to succeed.</span>
  83 |     | <span class='unexecuted'>            if (paymentToken.balanceOf(buyer) &lt; cost) return;</span>
  84 |     | <span class='neutral'></span>
  85 |     | <span class='unexecuted'>            uint256 treasuryBalanceBefore = paymentToken.balanceOf(treasury);</span>
  86 |     | <span class='neutral'></span>
  87 |     | <span class='unexecuted'>            vm.prank(buyer);</span>
  88 |     | <span class='unexecuted'>            try marketplace.buy(listingId, amountToBuy) {</span>
  89 |     | <span class='neutral'>                // SUCCESS CASE: The buy succeeded. Calculate the fee and update the ghost variable.</span>
  90 |     | <span class='unexecuted'>                uint256 treasuryBalanceAfter = paymentToken.balanceOf(treasury);</span>
  91 |     | <span class='unexecuted'>                uint256 feeCollected = treasuryBalanceAfter - treasuryBalanceBefore;</span>
  92 |     | <span class='neutral'>                // This call now works correctly through the interface.</span>
  93 |     | <span class='unexecuted'>                mainTest.addFee(feeCollected);</span>
  94 |     | <span class='neutral'>            } catch {}</span>
  95 |     | <span class='neutral'>        } catch {}</span>
  96 |     | <span class='neutral'>    }</span>
  97 |     | <span class='neutral'></span>
  98 |     | <span class='neutral'>    /// @notice FUZZ ACTION: Attempt to cancel a random listing.</span>
  99 |     | <span class='unexecuted'>    function cancel() public {</span>
 100 |     | <span class='unexecuted'>        if (listingIds.length == 0) return;</span>
 101 |     | <span class='unexecuted'>        uint256 listingIndex = block.timestamp % listingIds.length;</span>
 102 |     | <span class='unexecuted'>        uint256 listingId = listingIds[listingIndex];</span>
 103 |     | <span class='neutral'></span>
 104 |     | <span class='unexecuted'>        vm.prank(seller);</span>
 105 |     | <span class='neutral'>        // This may revert if the listing is already inactive, which is fine.</span>
 106 |     | <span class='unexecuted'>        try marketplace.cancelListing(listingId) {} catch {}</span>
 107 |     | <span class='neutral'>    }</span>
 108 |     | <span class='neutral'>}</span>
 109 |     | <span class='neutral'></span>
 110 |     | <span class='neutral'>/*</span>
 111 |     | <span class='neutral'> * @title FeeInvariantTest</span>
 112 |     | <span class='neutral'> * @notice An invariant test to ensure marketplace fees are always correctly accounted for.</span>
 113 |     | <span class='neutral'> * @dev THE FIX: This contract now implements the IFeeCallback interface.</span>
 114 |     | <span class='neutral'> */</span>
 115 |     | <span class='unexecuted'>contract FeeInvariantTest is Test, IFeeCallback {</span>
 116 |     | <span class='neutral'>    // Contracts</span>
 117 |     | <span class='neutral'>    Marketplace marketplace;</span>
 118 |     | <span class='neutral'>    Treasury treasury;</span>
 119 |     | <span class='neutral'>    DynamicImpactCredit credit;</span>
 120 |     | <span class='neutral'>    ProjectRegistry registry;</span>
 121 |     | <span class='neutral'>    ERC20Mock paymentToken;</span>
 122 |     | <span class='neutral'></span>
 123 |     | <span class='neutral'>    // Users</span>
 124 |     | <span class='unexecuted'>    address admin = makeAddr(&quot;admin&quot;);</span>
 125 |     | <span class='unexecuted'>    address seller = makeAddr(&quot;seller&quot;);</span>
 126 |     | <span class='unexecuted'>    address buyer = makeAddr(&quot;buyer&quot;);</span>
 127 |     | <span class='neutral'></span>
 128 |     | <span class='neutral'>    // The GHOST VARIABLE: Tracks the total fees that should have been collected.</span>
 129 |     | <span class='unexecuted'>    uint256 public totalFeesCalculated;</span>
 130 |     | <span class='neutral'></span>
 131 |     | <span class='unexecuted'>    function setUp() public {</span>
 132 |     | <span class='unexecuted'>        vm.startPrank(admin);</span>
 133 |     | <span class='neutral'>        // Deploy all contracts</span>
 134 |     | <span class='unexecuted'>        ProjectRegistry registryImpl = new ProjectRegistry();</span>
 135 |     | <span class='unexecuted'>        registry = ProjectRegistry(</span>
 136 |     | <span class='unexecuted'>            address(new ERC1967Proxy(address(registryImpl), abi.encodeCall(ProjectRegistry.initialize, ())))</span>
 137 |     | <span class='neutral'>        );</span>
 138 |     | <span class='unexecuted'>        treasury = Treasury(payable(address(new ERC1967Proxy(address(new Treasury()), &quot;&quot;))));</span>
 139 |     | <span class='unexecuted'>        treasury.initialize(admin);</span>
 140 |     | <span class='unexecuted'>        credit = DynamicImpactCredit(address(new ERC1967Proxy(address(new DynamicImpactCredit(address(registry))), &quot;&quot;)));</span>
 141 |     | <span class='unexecuted'>        credit.initialize(&quot;ipfs://&quot;);</span>
 142 |     | <span class='unexecuted'>        paymentToken = new ERC20Mock();</span>
 143 |     | <span class='unexecuted'>        marketplace = Marketplace(</span>
 144 |     | <span class='neutral'>            address(</span>
 145 |     | <span class='unexecuted'>                new ERC1967Proxy(</span>
 146 |     | <span class='unexecuted'>                    address(new Marketplace()),</span>
 147 |     | <span class='unexecuted'>                    abi.encodeCall(Marketplace.initialize, (address(credit), address(paymentToken)))</span>
 148 |     | <span class='neutral'>                )</span>
 149 |     | <span class='neutral'>            )</span>
 150 |     | <span class='neutral'>        );</span>
 151 |     | <span class='unexecuted'>        marketplace.setTreasury(address(treasury));</span>
 152 |     | <span class='unexecuted'>        marketplace.setFee(250); // 2.5%</span>
 153 |     | <span class='neutral'></span>
 154 |     | <span class='neutral'>        // Setup Project</span>
 155 |     | <span class='unexecuted'>        bytes32 projectId = keccak256(&quot;Test Project&quot;);</span>
 156 |     | <span class='neutral'>        uint256 tokenId = uint256(projectId);</span>
 157 |     | <span class='unexecuted'>        registry.registerProject(projectId, &quot;ipfs://&quot;);</span>
 158 |     | <span class='unexecuted'>        registry.setProjectStatus(projectId, ProjectRegistry.ProjectStatus.Active);</span>
 159 |     | <span class='unexecuted'>        credit.grantRole(credit.DMRV_MANAGER_ROLE(), seller);</span>
 160 |     | <span class='neutral'></span>
 161 |     | <span class='unexecuted'>        vm.stopPrank();</span>
 162 |     | <span class='neutral'></span>
 163 |     | <span class='neutral'>        // --- Fund Users and Set Approvals ---</span>
 164 |     | <span class='neutral'>        // Seller gets 1,000 credits to list</span>
 165 |     | <span class='unexecuted'>        vm.prank(seller);</span>
 166 |     | <span class='unexecuted'>        credit.mintCredits(seller, projectId, 1000, &quot;&quot;);</span>
 167 |     | <span class='unexecuted'>        credit.setApprovalForAll(address(marketplace), true);</span>
 168 |     | <span class='neutral'></span>
 169 |     | <span class='neutral'>        // Buyer gets 1,000,000 payment tokens and approves marketplace</span>
 170 |     | <span class='unexecuted'>        paymentToken.mint(buyer, 1_000_000 * 1 ether);</span>
 171 |     | <span class='unexecuted'>        vm.prank(buyer);</span>
 172 |     | <span class='unexecuted'>        paymentToken.approve(address(marketplace), type(uint256).max);</span>
 173 |     | <span class='neutral'></span>
 174 |     | <span class='neutral'>        // --- Setup Handler ---</span>
 175 |     | <span class='unexecuted'>        FeeInvariantHandler handler =</span>
 176 |     | <span class='unexecuted'>            new FeeInvariantHandler(this, marketplace, paymentToken, address(treasury), seller, buyer, tokenId);</span>
 177 |     | <span class='neutral'>        // Tell the fuzzer to call functions on the handler</span>
 178 |     | <span class='neutral'>        targetContract(address(handler));</span>
 179 |     | <span class='neutral'>    }</span>
 180 |     | <span class='neutral'></span>
 181 |     | <span class='neutral'>    /// @notice Implementation of the callback function for the handler.</span>
 182 |     | <span class='unexecuted'>    function addFee(uint256 fee) external override {</span>
 183 |     | <span class='unexecuted'>        totalFeesCalculated += fee;</span>
 184 |     | <span class='neutral'>    }</span>
 185 |     | <span class='neutral'></span>
 186 |     | <span class='neutral'>    /*</span>
 187 |     | <span class='neutral'>     * @notice INVARIANT: The Treasury&#39;s balance must always equal the sum of all fees collected.</span>
 188 |     | <span class='neutral'>     * @dev After every random action by the handler, this invariant checks that our off-chain</span>
 189 |     | <span class='neutral'>     *      calculation of fees matches the actual on-chain balance of the Treasury. This proves</span>
 190 |     | <span class='neutral'>     *      that fees are never lost, created from nothing, or sent to the wrong place.</span>
 191 |     | <span class='neutral'>     */</span>
 192 |     | <span class='unexecuted'>    function invariant_feeAccountingIsCorrect() public view {</span>
 193 |     | <span class='unexecuted'>        assertEq(</span>
 194 |     | <span class='unexecuted'>            totalFeesCalculated,</span>
 195 |     | <span class='unexecuted'>            paymentToken.balanceOf(address(treasury)),</span>
 196 |     | <span class='neutral'>            &quot;Fee Invariant Violated: Treasury balance does not match calculated fees.&quot;</span>
 197 |     | <span class='neutral'>        );</span>
 198 |     | <span class='neutral'>    }</span>
 199 |     | <span class='neutral'>}</span>
 200 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/phantom/Documents/azemora/azemora-contracts/test/invariants/Project.invariant.t.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'>pragma solidity ^0.8.20;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>import &quot;forge-std/Test.sol&quot;;</span>
   5 |     | <span class='neutral'>import &quot;../../src/core/ProjectRegistry.sol&quot;;</span>
   6 |     | <span class='neutral'>import &quot;@openzeppelin/contracts/proxy/ERC1967/ERC1967Proxy.sol&quot;;</span>
   7 |     | <span class='neutral'></span>
   8 |     | <span class='neutral'>// Interface to break the circular dependency between the test and the handler.</span>
   9 |     | <span class='neutral'>interface IProjectStateCallback {</span>
  10 |     | <span class='neutral'>    function trackProjectCreation(bytes32 projectId) external;</span>
  11 |     | <span class='neutral'>    function trackStateChange(bytes32 projectId, ProjectRegistry.ProjectStatus newStatus) external;</span>
  12 |     | <span class='neutral'>}</span>
  13 |     | <span class='neutral'></span>
  14 |     | <span class='neutral'>/**</span>
  15 |     | <span class='neutral'> * @title ProjectStateHandler</span>
  16 |     | <span class='neutral'> * @notice The &quot;fuzzer actor&quot; that performs random actions on the ProjectRegistry.</span>
  17 |     | <span class='neutral'> * @dev Foundry&#39;s fuzzer calls this handler&#39;s functions. The handler attempts</span>
  18 |     | <span class='neutral'> *      valid and invalid state transitions. If a transition succeeds, it notifies</span>
  19 |     | <span class='neutral'> *      the main test contract to update the ghost state variables.</span>
  20 |     | <span class='neutral'> */</span>
  21 |     | <span class='unexecuted'>contract ProjectStateHandler is Test {</span>
  22 |     | <span class='neutral'>    IProjectStateCallback immutable mainTest;</span>
  23 |     | <span class='neutral'>    ProjectRegistry immutable registry;</span>
  24 |     | <span class='neutral'>    address immutable projectCreator;</span>
  25 |     | <span class='neutral'>    address immutable verifier;</span>
  26 |     | <span class='neutral'></span>
  27 |     | <span class='neutral'>    // Keep track of projects created by this handler to randomly interact with them.</span>
  28 |     | <span class='unexecuted'>    bytes32[] public projectIds;</span>
  29 |     | <span class='neutral'></span>
  30 |     | <span class='unexecuted'>    constructor(</span>
  31 |     | <span class='neutral'>        IProjectStateCallback _mainTest,</span>
  32 |     | <span class='neutral'>        ProjectRegistry _registry,</span>
  33 |     | <span class='neutral'>        address _projectCreator,</span>
  34 |     | <span class='neutral'>        address _verifier</span>
  35 |     | <span class='neutral'>    ) {</span>
  36 |     | <span class='unexecuted'>        mainTest = _mainTest;</span>
  37 |     | <span class='unexecuted'>        registry = _registry;</span>
  38 |     | <span class='unexecuted'>        projectCreator = _projectCreator;</span>
  39 |     | <span class='unexecuted'>        verifier = _verifier;</span>
  40 |     | <span class='neutral'>    }</span>
  41 |     | <span class='neutral'></span>
  42 |     | <span class='neutral'>    /// @notice FUZZ ACTION: Register a new project.</span>
  43 |     | <span class='unexecuted'>    function register() public {</span>
  44 |     | <span class='neutral'>        // Create a unique project ID for each registration attempt.</span>
  45 |     | <span class='unexecuted'>        bytes32 projectId = keccak256(abi.encodePacked(&quot;Project &quot;, projectIds.length));</span>
  46 |     | <span class='unexecuted'>        vm.prank(projectCreator);</span>
  47 |     | <span class='neutral'></span>
  48 |     | <span class='neutral'>        // This call is not expected to revert under normal circumstances.</span>
  49 |     | <span class='unexecuted'>        try registry.registerProject(projectId, &quot;ipfs://&quot;) {</span>
  50 |     | <span class='unexecuted'>            projectIds.push(projectId);</span>
  51 |     | <span class='unexecuted'>            mainTest.trackProjectCreation(projectId);</span>
  52 |     | <span class='neutral'>        } catch {}</span>
  53 |     | <span class='neutral'>    }</span>
  54 |     | <span class='neutral'></span>
  55 |     | <span class='neutral'>    /// @notice FUZZ ACTION: Attempt to change a project&#39;s status to a random new state.</span>
  56 |     | <span class='unexecuted'>    function setStatus(ProjectRegistry.ProjectStatus newStatus) public {</span>
  57 |     | <span class='unexecuted'>        if (projectIds.length == 0) return;</span>
  58 |     | <span class='neutral'></span>
  59 |     | <span class='neutral'>        // Pick a random project to try and change.</span>
  60 |     | <span class='unexecuted'>        uint256 projectIndex = block.timestamp % projectIds.length;</span>
  61 |     | <span class='unexecuted'>        bytes32 projectId = projectIds[projectIndex];</span>
  62 |     | <span class='neutral'></span>
  63 |     | <span class='neutral'>        // Randomly use the admin (projectCreator) or the verifier to attempt the state change.</span>
  64 |     | <span class='neutral'>        // This is crucial to test the role-based access control of setProjectStatus.</span>
  65 |     | <span class='unexecuted'>        address actor = (block.timestamp % 2 == 0) ? projectCreator : verifier;</span>
  66 |     | <span class='unexecuted'>        vm.prank(actor);</span>
  67 |     | <span class='neutral'></span>
  68 |     | <span class='neutral'>        // This call is EXPECTED to revert often, as the fuzzer will try invalid state transitions.</span>
  69 |     | <span class='neutral'>        // This is exactly what we want to test.</span>
  70 |     | <span class='unexecuted'>        try registry.setProjectStatus(projectId, newStatus) {</span>
  71 |     | <span class='neutral'>            // SUCCESS CASE: The state transition was valid. Notify the main test.</span>
  72 |     | <span class='unexecuted'>            mainTest.trackStateChange(projectId, newStatus);</span>
  73 |     | <span class='neutral'>        } catch {}</span>
  74 |     | <span class='neutral'>    }</span>
  75 |     | <span class='neutral'>}</span>
  76 |     | <span class='neutral'></span>
  77 |     | <span class='neutral'>/**</span>
  78 |     | <span class='neutral'> * @title ProjectInvariantTest</span>
  79 |     | <span class='neutral'> * @notice An invariant test to ensure the project lifecycle state machine is always respected.</span>
  80 |     | <span class='neutral'> */</span>
  81 |     | <span class='unexecuted'>contract ProjectInvariantTest is Test, IProjectStateCallback {</span>
  82 |     | <span class='neutral'>    // Contracts</span>
  83 |     | <span class='neutral'>    ProjectRegistry registry;</span>
  84 |     | <span class='neutral'></span>
  85 |     | <span class='neutral'>    // Users</span>
  86 |     | <span class='unexecuted'>    address admin = makeAddr(&quot;admin&quot;);</span>
  87 |     | <span class='unexecuted'>    address projectCreator = makeAddr(&quot;projectCreator&quot;); // Also has ADMIN_ROLE for this test</span>
  88 |     | <span class='unexecuted'>    address verifier = makeAddr(&quot;verifier&quot;);</span>
  89 |     | <span class='neutral'></span>
  90 |     | <span class='neutral'>    // The GHOST STATE: Tracks the current state of all projects created by the fuzzer.</span>
  91 |     | <span class='unexecuted'>    mapping(bytes32 =&gt; ProjectRegistry.ProjectStatus) public projectStates;</span>
  92 |     | <span class='neutral'></span>
  93 |     | <span class='unexecuted'>    function setUp() public {</span>
  94 |     | <span class='unexecuted'>        vm.startPrank(admin);</span>
  95 |     | <span class='unexecuted'>        registry = ProjectRegistry(address(new ERC1967Proxy(address(new ProjectRegistry()), &quot;&quot;)));</span>
  96 |     | <span class='unexecuted'>        registry.initialize();</span>
  97 |     | <span class='neutral'>        // Grant the creator the admin role to allow pausing/archiving.</span>
  98 |     | <span class='unexecuted'>        registry.grantRole(registry.DEFAULT_ADMIN_ROLE(), projectCreator);</span>
  99 |     | <span class='neutral'>        // Grant the verifier role.</span>
 100 |     | <span class='unexecuted'>        registry.grantRole(registry.VERIFIER_ROLE(), verifier);</span>
 101 |     | <span class='unexecuted'>        vm.stopPrank();</span>
 102 |     | <span class='neutral'></span>
 103 |     | <span class='neutral'>        // --- Setup Handler ---</span>
 104 |     | <span class='unexecuted'>        ProjectStateHandler handler = new ProjectStateHandler(this, registry, projectCreator, verifier);</span>
 105 |     | <span class='neutral'>        // Tell the fuzzer to call functions on the handler.</span>
 106 |     | <span class='neutral'>        targetContract(address(handler));</span>
 107 |     | <span class='neutral'>    }</span>
 108 |     | <span class='neutral'></span>
 109 |     | <span class='neutral'>    // --- Callback Functions (called by handler) ---</span>
 110 |     | <span class='neutral'></span>
 111 |     | <span class='unexecuted'>    function trackProjectCreation(bytes32 projectId) external override {</span>
 112 |     | <span class='neutral'>        // New projects are created in the Pending state.</span>
 113 |     | <span class='unexecuted'>        projectStates[projectId] = ProjectRegistry.ProjectStatus.Pending;</span>
 114 |     | <span class='neutral'>    }</span>
 115 |     | <span class='neutral'></span>
 116 |     | <span class='neutral'>    /*</span>
 117 |     | <span class='neutral'>     * @notice INVARIANT: Asserts the correctness of the project state machine.</span>
 118 |     | <span class='neutral'>     * @dev This callback is invoked by the handler ONLY when a `setProjectStatus` call</span>
 119 |     | <span class='neutral'>     *      succeeds. It then checks if the transition from the old state to the new</span>
 120 |     | <span class='neutral'>     *      state was valid according to our defined state machine rules. If an invalid</span>
 121 |     | <span class='neutral'>     *      transition somehow succeeds on-chain, this assertion will fail, proving a</span>
 122 |     | <span class='neutral'>     *      vulnerability in the contract&#39;s state transition logic.</span>
 123 |     | <span class='neutral'>     */</span>
 124 |     | <span class='unexecuted'>    function trackStateChange(bytes32 projectId, ProjectRegistry.ProjectStatus newStatus) external override {</span>
 125 |     | <span class='unexecuted'>        ProjectRegistry.ProjectStatus oldStatus = projectStates[projectId];</span>
 126 |     | <span class='neutral'></span>
 127 |     | <span class='neutral'>        // State machine logic validation</span>
 128 |     | <span class='unexecuted'>        if (oldStatus == ProjectRegistry.ProjectStatus.Pending) {</span>
 129 |     | <span class='neutral'>            // From Pending, can only move to Active (verified) or Archived (rejected).</span>
 130 |     | <span class='unexecuted'>            bool isValid =</span>
 131 |     | <span class='unexecuted'>                newStatus == ProjectRegistry.ProjectStatus.Active || newStatus == ProjectRegistry.ProjectStatus.Archived;</span>
 132 |     | <span class='unexecuted'>            assertTrue(isValid, &quot;INVALID_TRANSITION_FROM_PENDING&quot;);</span>
 133 |     | <span class='unexecuted'>        } else if (oldStatus == ProjectRegistry.ProjectStatus.Active) {</span>
 134 |     | <span class='neutral'>            // From Active, can only move to Paused or Archived.</span>
 135 |     | <span class='unexecuted'>            bool isValid =</span>
 136 |     | <span class='unexecuted'>                newStatus == ProjectRegistry.ProjectStatus.Paused || newStatus == ProjectRegistry.ProjectStatus.Archived;</span>
 137 |     | <span class='unexecuted'>            assertTrue(isValid, &quot;INVALID_TRANSITION_FROM_ACTIVE&quot;);</span>
 138 |     | <span class='unexecuted'>        } else if (oldStatus == ProjectRegistry.ProjectStatus.Paused) {</span>
 139 |     | <span class='neutral'>            // From Paused, can move back to Active or be Archived.</span>
 140 |     | <span class='unexecuted'>            bool isValid =</span>
 141 |     | <span class='unexecuted'>                newStatus == ProjectRegistry.ProjectStatus.Active || newStatus == ProjectRegistry.ProjectStatus.Archived;</span>
 142 |     | <span class='unexecuted'>            assertTrue(isValid, &quot;INVALID_TRANSITION_FROM_PAUSED&quot;);</span>
 143 |     | <span class='unexecuted'>        } else if (oldStatus == ProjectRegistry.ProjectStatus.Archived) {</span>
 144 |     | <span class='neutral'>            // Archived is a terminal state. No transitions out should be possible.</span>
 145 |     | <span class='neutral'>            // If the handler successfully makes a state change from Archived and calls this</span>
 146 |     | <span class='neutral'>            // function, this test should fail immediately.</span>
 147 |     | <span class='unexecuted'>            revert(&quot;VIOLATION: Project moved out of Archived state.&quot;);</span>
 148 |     | <span class='neutral'>        }</span>
 149 |     | <span class='neutral'></span>
 150 |     | <span class='neutral'>        // Update our tracked state.</span>
 151 |     | <span class='unexecuted'>        projectStates[projectId] = newStatus;</span>
 152 |     | <span class='neutral'>    }</span>
 153 |     | <span class='neutral'>}</span>
 154 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/phantom/Documents/azemora/azemora-contracts/test/invariants/System.invariant.t.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>pragma solidity ^0.8.20;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>import &quot;forge-std/Test.sol&quot;;</span>
  5 |     | <span class='neutral'>import &quot;../../src/marketplace/Marketplace.sol&quot;;</span>
  6 |     | <span class='neutral'>import &quot;../../src/core/DynamicImpactCredit.sol&quot;;</span>
  7 |     | <span class='neutral'>import &quot;../../src/core/ProjectRegistry.sol&quot;;</span>
  8 |     | <span class='neutral'>import &quot;@openzeppelin/contracts/proxy/ERC1967/ERC1967Proxy.sol&quot;;</span>
  9 |     | <span class='neutral'>import &quot;@openzeppelin/contracts/mocks/token/ERC20Mock.sol&quot;;</span>
 10 |     | <span class='neutral'></span>
 11 |     | <span class='neutral'>// @dev A handler contract for the fuzzer. It defines the actions the fuzzer can take.</span>
 12 |     | <span class='unexecuted'>contract InvariantHandler is Test {</span>
 13 |     | <span class='neutral'>    Marketplace marketplace;</span>
 14 |     | <span class='neutral'>    address admin;</span>
 15 |     | <span class='neutral'></span>
 16 |     | <span class='unexecuted'>    constructor(Marketplace _marketplace, address _admin) {</span>
 17 |     | <span class='unexecuted'>        marketplace = _marketplace;</span>
 18 |     | <span class='unexecuted'>        admin = _admin;</span>
 19 |     | <span class='neutral'>    }</span>
 20 |     | <span class='neutral'></span>
 21 |     | <span class='neutral'>    // --- Fuzzer Actions ---</span>
 22 |     | <span class='neutral'>    // The fuzzer can call these functions with random inputs.</span>
 23 |     | <span class='neutral'>    // We only expose a subset of non-admin functions for this test.</span>
 24 |     | <span class='neutral'></span>
 25 |     | <span class='unexecuted'>    function list(uint256 tokenId, uint128 amount, uint128 price) public {</span>
 26 |     | <span class='neutral'>        // We don&#39;t care if this reverts, the invariant is about admin roles.</span>
 27 |     | <span class='neutral'>        // In a real test, we would add more robust checks.</span>
 28 |     | <span class='neutral'>        // For now, we just want to give the fuzzer some valid functions to call.</span>
 29 |     | <span class='neutral'>    }</span>
 30 |     | <span class='neutral'></span>
 31 |     | <span class='unexecuted'>    function buy(uint256 listingId, uint256 amount) public {</span>
 32 |     | <span class='neutral'>        // Don&#39;t care if this reverts</span>
 33 |     | <span class='neutral'>    }</span>
 34 |     | <span class='neutral'>}</span>
 35 |     | <span class='neutral'></span>
 36 |     | <span class='unexecuted'>contract SystemInvariantTest is Test {</span>
 37 |     | <span class='neutral'>    // Contracts</span>
 38 |     | <span class='neutral'>    Marketplace marketplace;</span>
 39 |     | <span class='neutral'>    DynamicImpactCredit credit;</span>
 40 |     | <span class='neutral'>    ProjectRegistry registry;</span>
 41 |     | <span class='neutral'>    ERC20Mock paymentToken;</span>
 42 |     | <span class='neutral'></span>
 43 |     | <span class='neutral'>    // Users</span>
 44 |     | <span class='unexecuted'>    address admin = makeAddr(&quot;admin&quot;);</span>
 45 |     | <span class='unexecuted'>    address seller = makeAddr(&quot;seller&quot;);</span>
 46 |     | <span class='unexecuted'>    address buyer = makeAddr(&quot;buyer&quot;);</span>
 47 |     | <span class='neutral'></span>
 48 |     | <span class='neutral'>    // Fuzzer target</span>
 49 |     | <span class='neutral'>    InvariantHandler handler;</span>
 50 |     | <span class='neutral'></span>
 51 |     | <span class='unexecuted'>    function setUp() public {</span>
 52 |     | <span class='unexecuted'>        vm.startPrank(admin);</span>
 53 |     | <span class='neutral'></span>
 54 |     | <span class='neutral'>        // Deploy Core Contracts</span>
 55 |     | <span class='unexecuted'>        ProjectRegistry registryImpl = new ProjectRegistry();</span>
 56 |     | <span class='unexecuted'>        registry = ProjectRegistry(address(new ERC1967Proxy(address(registryImpl), &quot;&quot;)));</span>
 57 |     | <span class='unexecuted'>        registry.initialize();</span>
 58 |     | <span class='neutral'></span>
 59 |     | <span class='unexecuted'>        DynamicImpactCredit creditImpl = new DynamicImpactCredit(address(registry));</span>
 60 |     | <span class='unexecuted'>        credit = DynamicImpactCredit(address(new ERC1967Proxy(address(creditImpl), &quot;&quot;)));</span>
 61 |     | <span class='unexecuted'>        credit.initialize(&quot;ipfs://&quot;);</span>
 62 |     | <span class='neutral'></span>
 63 |     | <span class='neutral'>        // Deploy Marketplace</span>
 64 |     | <span class='unexecuted'>        paymentToken = new ERC20Mock();</span>
 65 |     | <span class='unexecuted'>        Marketplace marketplaceImpl = new Marketplace();</span>
 66 |     | <span class='unexecuted'>        marketplace = Marketplace(</span>
 67 |     | <span class='neutral'>            address(</span>
 68 |     | <span class='unexecuted'>                new ERC1967Proxy(</span>
 69 |     | <span class='neutral'>                    address(marketplaceImpl),</span>
 70 |     | <span class='unexecuted'>                    abi.encodeCall(Marketplace.initialize, (address(credit), address(paymentToken)))</span>
 71 |     | <span class='neutral'>                )</span>
 72 |     | <span class='neutral'>            )</span>
 73 |     | <span class='neutral'>        );</span>
 74 |     | <span class='neutral'></span>
 75 |     | <span class='unexecuted'>        handler = new InvariantHandler(marketplace, admin);</span>
 76 |     | <span class='neutral'>        targetContract(address(handler)); // Tell the fuzzer which contract to call</span>
 77 |     | <span class='neutral'></span>
 78 |     | <span class='unexecuted'>        vm.stopPrank();</span>
 79 |     | <span class='neutral'>    }</span>
 80 |     | <span class='neutral'></span>
 81 |     | <span class='neutral'>    /**</span>
 82 |     | <span class='neutral'>     * @dev Invariant: The ADMIN role for the Marketplace should always be held by the Timelock contract.</span>
 83 |     | <span class='neutral'>     * Ensures that no other address can gain administrative control over the marketplace.</span>
 84 |     | <span class='neutral'>     */</span>
 85 |     | <span class='unexecuted'>    function invariant_MarketplaceAdminRoleIsStable() public view {</span>
 86 |     | <span class='unexecuted'>        bytes32 adminRole = marketplace.DEFAULT_ADMIN_ROLE();</span>
 87 |     | <span class='unexecuted'>        assertTrue(</span>
 88 |     | <span class='unexecuted'>            marketplace.hasRole(adminRole, admin), &quot;Invariant Violated: Marketplace admin role was lost or transferred.&quot;</span>
 89 |     | <span class='neutral'>        );</span>
 90 |     | <span class='neutral'>    }</span>
 91 |     | <span class='neutral'>}</span>
 92 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/phantom/Documents/azemora/azemora-contracts/test/invariants/Upgrade.invariant.t.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'>pragma solidity ^0.8.20;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>import &quot;forge-std/Test.sol&quot;;</span>
   5 |     | <span class='neutral'>import &quot;../../src/marketplace/Marketplace.sol&quot;;</span>
   6 |     | <span class='neutral'>import &quot;../upgrades/MarketplaceV2.sol&quot;;</span>
   7 |     | <span class='neutral'>import &quot;../../src/core/DynamicImpactCredit.sol&quot;;</span>
   8 |     | <span class='neutral'>import &quot;../../src/core/ProjectRegistry.sol&quot;;</span>
   9 |     | <span class='neutral'>import &quot;@openzeppelin/contracts/proxy/ERC1967/ERC1967Proxy.sol&quot;;</span>
  10 |     | <span class='neutral'>import &quot;@openzeppelin/contracts/mocks/token/ERC20Mock.sol&quot;;</span>
  11 |     | <span class='neutral'></span>
  12 |     | <span class='neutral'>/*</span>
  13 |     | <span class='neutral'> * @title UpgradeInvariantHandler</span>
  14 |     | <span class='neutral'> * @notice A &quot;handler&quot; contract that tells the Foundry fuzzer which actions it&#39;s allowed to take.</span>
  15 |     | <span class='neutral'> * @dev This is the core of the upgrade invariant test. The fuzzer will call the functions</span>
  16 |     | <span class='neutral'> *      on this contract in random order with random inputs. We expose normal user actions</span>
  17 |     | <span class='neutral'> *      (like `list` and `buy`) and, crucially, a one-time `upgradeToV2` function.</span>
  18 |     | <span class='neutral'> */</span>
  19 |     | <span class='unexecuted'>contract UpgradeInvariantHandler is Test {</span>
  20 |     | <span class='neutral'>    Marketplace marketplaceProxy;</span>
  21 |     | <span class='neutral'>    MarketplaceV2 marketplaceV2Impl;</span>
  22 |     | <span class='neutral'>    address admin;</span>
  23 |     | <span class='neutral'>    bool hasUpgraded;</span>
  24 |     | <span class='neutral'></span>
  25 |     | <span class='unexecuted'>    constructor(Marketplace _proxy, MarketplaceV2 _v2Impl, address _admin) {</span>
  26 |     | <span class='unexecuted'>        marketplaceProxy = _proxy;</span>
  27 |     | <span class='unexecuted'>        marketplaceV2Impl = _v2Impl;</span>
  28 |     | <span class='unexecuted'>        admin = _admin;</span>
  29 |     | <span class='neutral'>    }</span>
  30 |     | <span class='neutral'></span>
  31 |     | <span class='neutral'>    /// @notice A ghost function to give the fuzzer a non-admin action to call.</span>
  32 |     | <span class='unexecuted'>    function list(uint256 tokenId, uint256 amount, uint256 price) public {</span>
  33 |     | <span class='neutral'>        // We don&#39;t care about the logic here or if it reverts. The fuzzer just needs</span>
  34 |     | <span class='neutral'>        // valid functions to call to generate state transitions. The invariant check</span>
  35 |     | <span class='neutral'>        // happens automatically in the main test contract after each call.</span>
  36 |     | <span class='neutral'>    }</span>
  37 |     | <span class='neutral'></span>
  38 |     | <span class='neutral'>    /// @notice A ghost function for buying.</span>
  39 |     | <span class='unexecuted'>    function buy(uint256 listingId, uint256 amount) public {</span>
  40 |     | <span class='neutral'>        // We don&#39;t care about the logic.</span>
  41 |     | <span class='neutral'>    }</span>
  42 |     | <span class='neutral'></span>
  43 |     | <span class='neutral'>    /// @notice The key fuzzer action: perform a contract upgrade.</span>
  44 |     | <span class='unexecuted'>    function upgradeToV2() public {</span>
  45 |     | <span class='neutral'>        // Ensure the fuzzer doesn&#39;t try to upgrade multiple times.</span>
  46 |     | <span class='unexecuted'>        if (!hasUpgraded) {</span>
  47 |     | <span class='unexecuted'>            vm.startPrank(admin);</span>
  48 |     | <span class='unexecuted'>            marketplaceProxy.upgradeToAndCall(address(marketplaceV2Impl), &quot;&quot;);</span>
  49 |     | <span class='unexecuted'>            vm.stopPrank();</span>
  50 |     | <span class='unexecuted'>            hasUpgraded = true;</span>
  51 |     | <span class='neutral'>        }</span>
  52 |     | <span class='neutral'>    }</span>
  53 |     | <span class='neutral'>}</span>
  54 |     | <span class='neutral'></span>
  55 |     | <span class='neutral'>/*</span>
  56 |     | <span class='neutral'> * @title UpgradeInvariantTest</span>
  57 |     | <span class='neutral'> * @notice An invariant test suite to prove that admin roles are stable across</span>
  58 |     | <span class='neutral'> *         both random user actions and contract upgrades.</span>
  59 |     | <span class='neutral'> */</span>
  60 |     | <span class='unexecuted'>contract UpgradeInvariantTest is Test {</span>
  61 |     | <span class='neutral'>    // Contracts</span>
  62 |     | <span class='neutral'>    Marketplace marketplace;</span>
  63 |     | <span class='neutral'>    MarketplaceV2 marketplaceV2Impl; // The V2 implementation, ready to be upgraded to.</span>
  64 |     | <span class='neutral'>    DynamicImpactCredit credit;</span>
  65 |     | <span class='neutral'>    ProjectRegistry registry;</span>
  66 |     | <span class='neutral'>    ERC20Mock paymentToken;</span>
  67 |     | <span class='neutral'></span>
  68 |     | <span class='neutral'>    // Users</span>
  69 |     | <span class='unexecuted'>    address admin = makeAddr(&quot;admin&quot;);</span>
  70 |     | <span class='neutral'></span>
  71 |     | <span class='neutral'>    // Fuzzer Target</span>
  72 |     | <span class='neutral'>    UpgradeInvariantHandler handler;</span>
  73 |     | <span class='neutral'></span>
  74 |     | <span class='unexecuted'>    function setUp() public {</span>
  75 |     | <span class='unexecuted'>        vm.startPrank(admin);</span>
  76 |     | <span class='neutral'></span>
  77 |     | <span class='neutral'>        // --- Deploy all contracts (V1 setup) ---</span>
  78 |     | <span class='unexecuted'>        ProjectRegistry registryImpl = new ProjectRegistry();</span>
  79 |     | <span class='unexecuted'>        registry = ProjectRegistry(address(new ERC1967Proxy(address(registryImpl), &quot;&quot;)));</span>
  80 |     | <span class='unexecuted'>        registry.initialize();</span>
  81 |     | <span class='neutral'></span>
  82 |     | <span class='unexecuted'>        DynamicImpactCredit creditImpl = new DynamicImpactCredit(address(registry));</span>
  83 |     | <span class='unexecuted'>        credit = DynamicImpactCredit(address(new ERC1967Proxy(address(creditImpl), &quot;&quot;)));</span>
  84 |     | <span class='unexecuted'>        credit.initialize(&quot;ipfs://&quot;);</span>
  85 |     | <span class='neutral'></span>
  86 |     | <span class='unexecuted'>        paymentToken = new ERC20Mock();</span>
  87 |     | <span class='unexecuted'>        Marketplace marketplaceV1Impl = new Marketplace();</span>
  88 |     | <span class='unexecuted'>        marketplace = Marketplace(</span>
  89 |     | <span class='neutral'>            address(</span>
  90 |     | <span class='unexecuted'>                new ERC1967Proxy(</span>
  91 |     | <span class='neutral'>                    address(marketplaceV1Impl),</span>
  92 |     | <span class='unexecuted'>                    abi.encodeCall(Marketplace.initialize, (address(credit), address(paymentToken)))</span>
  93 |     | <span class='neutral'>                )</span>
  94 |     | <span class='neutral'>            )</span>
  95 |     | <span class='neutral'>        );</span>
  96 |     | <span class='neutral'></span>
  97 |     | <span class='neutral'>        // --- Deploy the V2 implementation so it&#39;s ready for the upgrade ---</span>
  98 |     | <span class='unexecuted'>        marketplaceV2Impl = new MarketplaceV2();</span>
  99 |     | <span class='neutral'></span>
 100 |     | <span class='neutral'>        // --- Setup the handler for the fuzzer ---</span>
 101 |     | <span class='unexecuted'>        handler = new UpgradeInvariantHandler(marketplace, marketplaceV2Impl, admin);</span>
 102 |     | <span class='neutral'>        targetContract(address(handler)); // Tell the fuzzer to call functions on our handler.</span>
 103 |     | <span class='neutral'></span>
 104 |     | <span class='unexecuted'>        vm.stopPrank();</span>
 105 |     | <span class='neutral'>    }</span>
 106 |     | <span class='neutral'></span>
 107 |     | <span class='neutral'>    /**</span>
 108 |     | <span class='neutral'>     * @dev Invariant: Ensures the admin role for all upgradeable contracts remains stable across upgrades.</span>
 109 |     | <span class='neutral'>     * The admin should always be the Timelock contract.</span>
 110 |     | <span class='neutral'>     */</span>
 111 |     | <span class='unexecuted'>    function invariant_AdminRoleIsStableAcrossUpgrades() public view {</span>
 112 |     | <span class='neutral'>        // Check admin role for Marketplace</span>
 113 |     | <span class='unexecuted'>        bytes32 marketplaceAdminRole = marketplace.DEFAULT_ADMIN_ROLE();</span>
 114 |     | <span class='unexecuted'>        assertTrue(</span>
 115 |     | <span class='unexecuted'>            marketplace.hasRole(marketplaceAdminRole, admin),</span>
 116 |     | <span class='neutral'>            &quot;INVARIANT VIOLATED: Marketplace admin role was lost or transferred!&quot;</span>
 117 |     | <span class='neutral'>        );</span>
 118 |     | <span class='neutral'>    }</span>
 119 |     | <span class='neutral'>}</span>
 120 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/phantom/Documents/azemora/azemora-contracts/test/marketplace/Marketplace.complex.t.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'>pragma solidity ^0.8.20;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>import &quot;forge-std/Test.sol&quot;;</span>
   5 |     | <span class='neutral'>import &quot;./Marketplace.t.sol&quot;; // Import the mock ERC20 from the other test file</span>
   6 |     | <span class='neutral'>import &quot;../../src/core/ProjectRegistry.sol&quot;;</span>
   7 |     | <span class='neutral'>import &quot;../../src/core/dMRVManager.sol&quot;;</span>
   8 |     | <span class='neutral'>import &quot;../../src/core/DynamicImpactCredit.sol&quot;;</span>
   9 |     | <span class='neutral'>import &quot;../../src/marketplace/Marketplace.sol&quot;;</span>
  10 |     | <span class='neutral'>import &quot;@openzeppelin/contracts/proxy/ERC1967/ERC1967Proxy.sol&quot;;</span>
  11 |     | <span class='neutral'></span>
  12 |     | <span class='unexecuted'>contract MarketplaceComplexTest is Test {</span>
  13 |     | <span class='neutral'>    // Core contracts</span>
  14 |     | <span class='neutral'>    ProjectRegistry registry;</span>
  15 |     | <span class='neutral'>    DynamicImpactCredit credit;</span>
  16 |     | <span class='neutral'>    Marketplace marketplace;</span>
  17 |     | <span class='neutral'>    MockERC20 paymentToken;</span>
  18 |     | <span class='neutral'></span>
  19 |     | <span class='neutral'>    // Users</span>
  20 |     | <span class='unexecuted'>    address admin = address(0xA11CE);</span>
  21 |     | <span class='unexecuted'>    address verifier = address(0xC1E4);</span>
  22 |     | <span class='unexecuted'>    address dmrvManager = address(0xB01D);</span>
  23 |     | <span class='unexecuted'>    address treasury = address(0xFE35);</span>
  24 |     | <span class='unexecuted'>    address seller1 = address(0x5E11E1);</span>
  25 |     | <span class='unexecuted'>    address seller2 = address(0x5E11E2);</span>
  26 |     | <span class='unexecuted'>    address buyer1 = address(0xB4BE1);</span>
  27 |     | <span class='unexecuted'>    address buyer2 = address(0xB4BE2);</span>
  28 |     | <span class='neutral'></span>
  29 |     | <span class='neutral'>    // Project and Token IDs</span>
  30 |     | <span class='unexecuted'>    bytes32 projectId1 = keccak256(&quot;Project Alpha&quot;);</span>
  31 |     | <span class='unexecuted'>    bytes32 projectId2 = keccak256(&quot;Project Beta&quot;);</span>
  32 |     | <span class='neutral'>    uint256 tokenId1;</span>
  33 |     | <span class='neutral'>    uint256 tokenId2;</span>
  34 |     | <span class='neutral'></span>
  35 |     | <span class='unexecuted'>    function setUp() public {</span>
  36 |     | <span class='unexecuted'>        tokenId1 = uint256(projectId1);</span>
  37 |     | <span class='unexecuted'>        tokenId2 = uint256(projectId2);</span>
  38 |     | <span class='neutral'></span>
  39 |     | <span class='neutral'>        // --- Deploy Infrastructure ---</span>
  40 |     | <span class='unexecuted'>        paymentToken = new MockERC20(&quot;USD Coin&quot;, &quot;USDC&quot;, 6);</span>
  41 |     | <span class='unexecuted'>        vm.prank(address(this));</span>
  42 |     | <span class='unexecuted'>        paymentToken.mint(buyer1, 1_000_000 * 1e6); // 1M USDC</span>
  43 |     | <span class='unexecuted'>        vm.prank(address(this));</span>
  44 |     | <span class='unexecuted'>        paymentToken.mint(buyer2, 1_000_000 * 1e6); // 1M USDC</span>
  45 |     | <span class='neutral'></span>
  46 |     | <span class='unexecuted'>        vm.startPrank(admin);</span>
  47 |     | <span class='neutral'></span>
  48 |     | <span class='neutral'>        // Deploy Registry, Credit, and Marketplace contracts</span>
  49 |     | <span class='unexecuted'>        registry = ProjectRegistry(</span>
  50 |     | <span class='unexecuted'>            address(new ERC1967Proxy(address(new ProjectRegistry()), abi.encodeCall(ProjectRegistry.initialize, ())))</span>
  51 |     | <span class='neutral'>        );</span>
  52 |     | <span class='unexecuted'>        registry.grantRole(registry.VERIFIER_ROLE(), verifier);</span>
  53 |     | <span class='neutral'></span>
  54 |     | <span class='unexecuted'>        credit = DynamicImpactCredit(</span>
  55 |     | <span class='neutral'>            address(</span>
  56 |     | <span class='unexecuted'>                new ERC1967Proxy(</span>
  57 |     | <span class='unexecuted'>                    address(new DynamicImpactCredit(address(registry))),</span>
  58 |     | <span class='unexecuted'>                    abi.encodeCall(DynamicImpactCredit.initialize, (&quot;ipfs://meta.json&quot;))</span>
  59 |     | <span class='neutral'>                )</span>
  60 |     | <span class='neutral'>            )</span>
  61 |     | <span class='neutral'>        );</span>
  62 |     | <span class='unexecuted'>        credit.grantRole(credit.DMRV_MANAGER_ROLE(), dmrvManager);</span>
  63 |     | <span class='neutral'></span>
  64 |     | <span class='unexecuted'>        marketplace = Marketplace(</span>
  65 |     | <span class='neutral'>            address(</span>
  66 |     | <span class='unexecuted'>                new ERC1967Proxy(</span>
  67 |     | <span class='unexecuted'>                    address(new Marketplace()),</span>
  68 |     | <span class='unexecuted'>                    abi.encodeCall(Marketplace.initialize, (address(credit), address(paymentToken)))</span>
  69 |     | <span class='neutral'>                )</span>
  70 |     | <span class='neutral'>            )</span>
  71 |     | <span class='neutral'>        );</span>
  72 |     | <span class='unexecuted'>        marketplace.setTreasury(treasury);</span>
  73 |     | <span class='unexecuted'>        marketplace.setFee(250); // Initial 2.5% fee</span>
  74 |     | <span class='neutral'></span>
  75 |     | <span class='unexecuted'>        vm.stopPrank();</span>
  76 |     | <span class='neutral'></span>
  77 |     | <span class='neutral'>        // --- Prepare Projects and Credits ---</span>
  78 |     | <span class='neutral'>        // Project 1 for seller1</span>
  79 |     | <span class='unexecuted'>        vm.prank(seller1);</span>
  80 |     | <span class='unexecuted'>        registry.registerProject(projectId1, &quot;ipfs://alpha.json&quot;);</span>
  81 |     | <span class='unexecuted'>        vm.prank(verifier);</span>
  82 |     | <span class='unexecuted'>        registry.setProjectStatus(projectId1, ProjectRegistry.ProjectStatus.Active);</span>
  83 |     | <span class='unexecuted'>        vm.prank(dmrvManager);</span>
  84 |     | <span class='unexecuted'>        credit.mintCredits(seller1, projectId1, 500, &quot;ipfs://c-alpha.json&quot;);</span>
  85 |     | <span class='neutral'></span>
  86 |     | <span class='neutral'>        // Project 2 for seller2</span>
  87 |     | <span class='unexecuted'>        vm.prank(seller2);</span>
  88 |     | <span class='unexecuted'>        registry.registerProject(projectId2, &quot;ipfs://beta.json&quot;);</span>
  89 |     | <span class='unexecuted'>        vm.prank(verifier);</span>
  90 |     | <span class='unexecuted'>        registry.setProjectStatus(projectId2, ProjectRegistry.ProjectStatus.Active);</span>
  91 |     | <span class='unexecuted'>        vm.prank(dmrvManager);</span>
  92 |     | <span class='unexecuted'>        credit.mintCredits(seller2, projectId2, 1000, &quot;ipfs://c-beta.json&quot;);</span>
  93 |     | <span class='neutral'>    }</span>
  94 |     | <span class='neutral'></span>
  95 |     | <span class='unexecuted'>    function testComplex_MultiUserFlow() public {</span>
  96 |     | <span class='neutral'>        // STEP 1: Both sellers approve the marketplace and list their tokens</span>
  97 |     | <span class='unexecuted'>        vm.startPrank(seller1);</span>
  98 |     | <span class='unexecuted'>        credit.setApprovalForAll(address(marketplace), true);</span>
  99 |     | <span class='unexecuted'>        uint256 listingId1 = marketplace.list(tokenId1, 200, 10 * 1e6, 1 days); // 200 tokens at 10 USDC</span>
 100 |     | <span class='unexecuted'>        vm.stopPrank();</span>
 101 |     | <span class='neutral'></span>
 102 |     | <span class='unexecuted'>        vm.startPrank(seller2);</span>
 103 |     | <span class='unexecuted'>        credit.setApprovalForAll(address(marketplace), true);</span>
 104 |     | <span class='unexecuted'>        uint256 listingId2 = marketplace.list(tokenId2, 500, 15 * 1e6, 1 days); // 500 tokens at 15 USDC</span>
 105 |     | <span class='unexecuted'>        vm.stopPrank();</span>
 106 |     | <span class='neutral'></span>
 107 |     | <span class='unexecuted'>        assertEq(credit.balanceOf(address(marketplace), tokenId1), 200);</span>
 108 |     | <span class='unexecuted'>        assertEq(credit.balanceOf(address(marketplace), tokenId2), 500);</span>
 109 |     | <span class='neutral'></span>
 110 |     | <span class='neutral'>        // STEP 2: Buyer1 makes a partial purchase from seller1</span>
 111 |     | <span class='unexecuted'>        uint256 buyAmount1 = 50;</span>
 112 |     | <span class='unexecuted'>        uint256 totalPrice1 = buyAmount1 * 10 * 1e6;</span>
 113 |     | <span class='neutral'></span>
 114 |     | <span class='unexecuted'>        vm.startPrank(buyer1);</span>
 115 |     | <span class='unexecuted'>        paymentToken.approve(address(marketplace), totalPrice1);</span>
 116 |     | <span class='unexecuted'>        marketplace.buy(listingId1, buyAmount1);</span>
 117 |     | <span class='unexecuted'>        vm.stopPrank();</span>
 118 |     | <span class='neutral'></span>
 119 |     | <span class='unexecuted'>        Marketplace.Listing memory listing1 = marketplace.getListing(listingId1);</span>
 120 |     | <span class='unexecuted'>        assertEq(listing1.amount, 150); // 200 - 50</span>
 121 |     | <span class='unexecuted'>        assertEq(credit.balanceOf(buyer1, tokenId1), buyAmount1);</span>
 122 |     | <span class='unexecuted'>        assertEq(credit.balanceOf(address(marketplace), tokenId1), 150);</span>
 123 |     | <span class='neutral'></span>
 124 |     | <span class='neutral'>        // STEP 3: Seller1 decides to update the price of the remaining items</span>
 125 |     | <span class='unexecuted'>        vm.prank(seller1);</span>
 126 |     | <span class='unexecuted'>        marketplace.updateListingPrice(listingId1, 12 * 1e6); // New price is 12 USDC</span>
 127 |     | <span class='neutral'></span>
 128 |     | <span class='unexecuted'>        listing1 = marketplace.getListing(listingId1);</span>
 129 |     | <span class='unexecuted'>        assertEq(listing1.pricePerUnit, 12 * 1e6);</span>
 130 |     | <span class='neutral'></span>
 131 |     | <span class='neutral'>        // STEP 4: Buyer2 buys all remaining items from listing 1 at the new price</span>
 132 |     | <span class='unexecuted'>        uint256 buyAmount2 = 150;</span>
 133 |     | <span class='unexecuted'>        uint256 totalPrice2 = buyAmount2 * 12 * 1e6; // Use the new price</span>
 134 |     | <span class='unexecuted'>        uint256 fee2 = (totalPrice2 * 250) / 10000;</span>
 135 |     | <span class='unexecuted'>        uint256 proceeds2 = totalPrice2 - fee2;</span>
 136 |     | <span class='unexecuted'>        uint256 seller1InitialPayment = paymentToken.balanceOf(seller1);</span>
 137 |     | <span class='neutral'></span>
 138 |     | <span class='unexecuted'>        vm.startPrank(buyer2);</span>
 139 |     | <span class='unexecuted'>        paymentToken.approve(address(marketplace), totalPrice2);</span>
 140 |     | <span class='unexecuted'>        marketplace.buy(listingId1, buyAmount2);</span>
 141 |     | <span class='unexecuted'>        vm.stopPrank();</span>
 142 |     | <span class='neutral'></span>
 143 |     | <span class='unexecuted'>        listing1 = marketplace.getListing(listingId1);</span>
 144 |     | <span class='unexecuted'>        assertFalse(listing1.active);</span>
 145 |     | <span class='unexecuted'>        assertEq(credit.balanceOf(buyer2, tokenId1), buyAmount2);</span>
 146 |     | <span class='unexecuted'>        assertEq(credit.balanceOf(address(marketplace), tokenId1), 0);</span>
 147 |     | <span class='unexecuted'>        assertEq(paymentToken.balanceOf(seller1), seller1InitialPayment + proceeds2);</span>
 148 |     | <span class='neutral'></span>
 149 |     | <span class='neutral'>        // STEP 5: Buyer1 buys the entire listing from seller2</span>
 150 |     | <span class='unexecuted'>        uint256 buyAmount3 = 500;</span>
 151 |     | <span class='unexecuted'>        uint256 totalPrice3 = buyAmount3 * 15 * 1e6;</span>
 152 |     | <span class='neutral'></span>
 153 |     | <span class='unexecuted'>        vm.startPrank(buyer1);</span>
 154 |     | <span class='unexecuted'>        paymentToken.approve(address(marketplace), totalPrice3);</span>
 155 |     | <span class='unexecuted'>        marketplace.buy(listingId2, buyAmount3);</span>
 156 |     | <span class='unexecuted'>        vm.stopPrank();</span>
 157 |     | <span class='neutral'></span>
 158 |     | <span class='unexecuted'>        Marketplace.Listing memory listing2 = marketplace.getListing(listingId2);</span>
 159 |     | <span class='unexecuted'>        assertFalse(listing2.active);</span>
 160 |     | <span class='unexecuted'>        assertEq(credit.balanceOf(buyer1, tokenId2), buyAmount3);</span>
 161 |     | <span class='unexecuted'>        assertEq(credit.balanceOf(address(marketplace), tokenId2), 0);</span>
 162 |     | <span class='neutral'></span>
 163 |     | <span class='neutral'>        // STEP 6: Seller2 lists more tokens, then cancels the listing</span>
 164 |     | <span class='unexecuted'>        vm.startPrank(seller2);</span>
 165 |     | <span class='unexecuted'>        uint256 listingId3 = marketplace.list(tokenId2, 300, 20 * 1e6, 1 days);</span>
 166 |     | <span class='unexecuted'>        assertEq(credit.balanceOf(address(marketplace), tokenId2), 300);</span>
 167 |     | <span class='unexecuted'>        marketplace.cancelListing(listingId3);</span>
 168 |     | <span class='unexecuted'>        vm.stopPrank();</span>
 169 |     | <span class='neutral'></span>
 170 |     | <span class='unexecuted'>        Marketplace.Listing memory listing3 = marketplace.getListing(listingId3);</span>
 171 |     | <span class='unexecuted'>        assertFalse(listing3.active);</span>
 172 |     | <span class='unexecuted'>        assertEq(credit.balanceOf(address(marketplace), tokenId2), 0);</span>
 173 |     | <span class='unexecuted'>        assertEq(credit.balanceOf(seller2, tokenId2), 500); // 1000 minted - 500 sold</span>
 174 |     | <span class='neutral'></span>
 175 |     | <span class='neutral'>        // STEP 7: Admin changes the fee, a new purchase reflects this</span>
 176 |     | <span class='unexecuted'>        vm.prank(admin);</span>
 177 |     | <span class='unexecuted'>        marketplace.setFee(500); // 5% fee</span>
 178 |     | <span class='neutral'></span>
 179 |     | <span class='neutral'>        // Seller1 lists again</span>
 180 |     | <span class='unexecuted'>        vm.startPrank(seller1);</span>
 181 |     | <span class='unexecuted'>        uint256 listingId4 = marketplace.list(tokenId1, 100, 10 * 1e6, 1 days);</span>
 182 |     | <span class='unexecuted'>        vm.stopPrank();</span>
 183 |     | <span class='neutral'></span>
 184 |     | <span class='neutral'>        // Buyer1 buys</span>
 185 |     | <span class='unexecuted'>        uint256 buyAmount4 = 10;</span>
 186 |     | <span class='unexecuted'>        uint256 totalPrice4 = buyAmount4 * 10 * 1e6;</span>
 187 |     | <span class='unexecuted'>        uint256 newFee = (totalPrice4 * 500) / 10000; // 5%</span>
 188 |     | <span class='unexecuted'>        uint256 treasuryInitialBalance = paymentToken.balanceOf(treasury);</span>
 189 |     | <span class='neutral'></span>
 190 |     | <span class='unexecuted'>        vm.startPrank(buyer1);</span>
 191 |     | <span class='unexecuted'>        paymentToken.approve(address(marketplace), totalPrice4);</span>
 192 |     | <span class='unexecuted'>        marketplace.buy(listingId4, buyAmount4);</span>
 193 |     | <span class='unexecuted'>        vm.stopPrank();</span>
 194 |     | <span class='neutral'></span>
 195 |     | <span class='unexecuted'>        assertEq(paymentToken.balanceOf(treasury), treasuryInitialBalance + newFee);</span>
 196 |     | <span class='neutral'>    }</span>
 197 |     | <span class='neutral'>}</span>
 198 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/phantom/Documents/azemora/azemora-contracts/test/marketplace/Marketplace.fuzz.t.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'>pragma solidity ^0.8.20;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>import &quot;forge-std/Test.sol&quot;;</span>
   5 |     | <span class='neutral'>import &quot;./Marketplace.t.sol&quot;; // Re-use mocks</span>
   6 |     | <span class='neutral'>import &quot;../../src/core/ProjectRegistry.sol&quot;;</span>
   7 |     | <span class='neutral'>import &quot;../../src/core/dMRVManager.sol&quot;;</span>
   8 |     | <span class='neutral'>import &quot;../../src/core/DynamicImpactCredit.sol&quot;;</span>
   9 |     | <span class='neutral'>import &quot;../../src/marketplace/Marketplace.sol&quot;;</span>
  10 |     | <span class='neutral'>import &quot;@openzeppelin/contracts/proxy/ERC1967/ERC1967Proxy.sol&quot;;</span>
  11 |     | <span class='neutral'></span>
  12 |     | <span class='unexecuted'>contract MarketplaceFuzzTest is Test {</span>
  13 |     | <span class='neutral'>    ProjectRegistry registry;</span>
  14 |     | <span class='neutral'>    DynamicImpactCredit credit;</span>
  15 |     | <span class='neutral'>    Marketplace marketplace;</span>
  16 |     | <span class='neutral'>    MockERC20 paymentToken;</span>
  17 |     | <span class='neutral'></span>
  18 |     | <span class='unexecuted'>    address admin = address(0xA11CE);</span>
  19 |     | <span class='unexecuted'>    address verifier = address(0xC1E4);</span>
  20 |     | <span class='unexecuted'>    address dmrvManager = address(0xB01D);</span>
  21 |     | <span class='unexecuted'>    address treasury = address(0xFE35);</span>
  22 |     | <span class='unexecuted'>    address seller = address(0x5E11E1);</span>
  23 |     | <span class='unexecuted'>    address buyer = address(0xB4BE1);</span>
  24 |     | <span class='neutral'></span>
  25 |     | <span class='unexecuted'>    function setUp() public {</span>
  26 |     | <span class='neutral'>        // --- Deploy Infrastructure ---</span>
  27 |     | <span class='unexecuted'>        paymentToken = new MockERC20(&quot;USD Coin&quot;, &quot;USDC&quot;, 6);</span>
  28 |     | <span class='unexecuted'>        vm.prank(address(this));</span>
  29 |     | <span class='unexecuted'>        paymentToken.mint(buyer, 1_000_000_000 * 1e6); // 1B USDC for fuzzing</span>
  30 |     | <span class='neutral'></span>
  31 |     | <span class='unexecuted'>        vm.startPrank(admin);</span>
  32 |     | <span class='neutral'></span>
  33 |     | <span class='unexecuted'>        registry = ProjectRegistry(</span>
  34 |     | <span class='unexecuted'>            address(new ERC1967Proxy(address(new ProjectRegistry()), abi.encodeCall(ProjectRegistry.initialize, ())))</span>
  35 |     | <span class='neutral'>        );</span>
  36 |     | <span class='unexecuted'>        registry.grantRole(registry.VERIFIER_ROLE(), verifier);</span>
  37 |     | <span class='neutral'></span>
  38 |     | <span class='unexecuted'>        credit = DynamicImpactCredit(</span>
  39 |     | <span class='neutral'>            address(</span>
  40 |     | <span class='unexecuted'>                new ERC1967Proxy(</span>
  41 |     | <span class='unexecuted'>                    address(new DynamicImpactCredit(address(registry))),</span>
  42 |     | <span class='unexecuted'>                    abi.encodeCall(DynamicImpactCredit.initialize, (&quot;ipfs://meta.json&quot;))</span>
  43 |     | <span class='neutral'>                )</span>
  44 |     | <span class='neutral'>            )</span>
  45 |     | <span class='neutral'>        );</span>
  46 |     | <span class='unexecuted'>        credit.grantRole(credit.DMRV_MANAGER_ROLE(), dmrvManager);</span>
  47 |     | <span class='neutral'></span>
  48 |     | <span class='unexecuted'>        marketplace = Marketplace(</span>
  49 |     | <span class='neutral'>            address(</span>
  50 |     | <span class='unexecuted'>                new ERC1967Proxy(</span>
  51 |     | <span class='unexecuted'>                    address(new Marketplace()),</span>
  52 |     | <span class='unexecuted'>                    abi.encodeCall(Marketplace.initialize, (address(credit), address(paymentToken)))</span>
  53 |     | <span class='neutral'>                )</span>
  54 |     | <span class='neutral'>            )</span>
  55 |     | <span class='neutral'>        );</span>
  56 |     | <span class='unexecuted'>        marketplace.setTreasury(treasury);</span>
  57 |     | <span class='unexecuted'>        marketplace.setFee(250); // 2.5% fee</span>
  58 |     | <span class='neutral'></span>
  59 |     | <span class='unexecuted'>        vm.stopPrank();</span>
  60 |     | <span class='neutral'>    }</span>
  61 |     | <span class='neutral'></span>
  62 |     | <span class='unexecuted'>    function testFuzz_ListAndBuy(uint64 seed, uint256 listAmount, uint256 buyAmount, uint256 price) public {</span>
  63 |     | <span class='unexecuted'>        bytes32 projectId = keccak256(abi.encodePacked(&quot;project&quot;, seed));</span>
  64 |     | <span class='neutral'>        uint256 tokenId = uint256(projectId);</span>
  65 |     | <span class='neutral'></span>
  66 |     | <span class='neutral'>        // --- Setup State ---</span>
  67 |     | <span class='unexecuted'>        uint256 mintAmount = 1_000_000;</span>
  68 |     | <span class='neutral'>        // 1. Activate project and mint tokens to seller</span>
  69 |     | <span class='unexecuted'>        vm.prank(seller);</span>
  70 |     | <span class='unexecuted'>        registry.registerProject(projectId, &quot;ipfs://fuzz.json&quot;);</span>
  71 |     | <span class='unexecuted'>        vm.prank(verifier);</span>
  72 |     | <span class='unexecuted'>        registry.setProjectStatus(projectId, ProjectRegistry.ProjectStatus.Active);</span>
  73 |     | <span class='unexecuted'>        vm.prank(dmrvManager);</span>
  74 |     | <span class='unexecuted'>        credit.mintCredits(seller, projectId, mintAmount, &quot;ipfs://fuzz-c.json&quot;);</span>
  75 |     | <span class='neutral'></span>
  76 |     | <span class='neutral'>        // 2. Bound inputs to be reasonable</span>
  77 |     | <span class='unexecuted'>        listAmount = bound(listAmount, 1, mintAmount);</span>
  78 |     | <span class='unexecuted'>        buyAmount = bound(buyAmount, 1, listAmount);</span>
  79 |     | <span class='unexecuted'>        price = bound(price, 1, 1_000_000 * 1e6); // Price up to 1M USDC</span>
  80 |     | <span class='neutral'></span>
  81 |     | <span class='neutral'>        // 3. Assume the buyer can afford the purchase to avoid reverts</span>
  82 |     | <span class='unexecuted'>        uint256 totalPrice = buyAmount * price;</span>
  83 |     | <span class='unexecuted'>        vm.assume(totalPrice &lt; paymentToken.balanceOf(buyer));</span>
  84 |     | <span class='neutral'></span>
  85 |     | <span class='neutral'>        // --- Execute Actions ---</span>
  86 |     | <span class='neutral'>        // 4. Seller lists the item</span>
  87 |     | <span class='unexecuted'>        vm.startPrank(seller);</span>
  88 |     | <span class='unexecuted'>        credit.setApprovalForAll(address(marketplace), true);</span>
  89 |     | <span class='unexecuted'>        uint256 listingId = marketplace.list(tokenId, listAmount, price, 1 days);</span>
  90 |     | <span class='unexecuted'>        vm.stopPrank();</span>
  91 |     | <span class='neutral'></span>
  92 |     | <span class='neutral'>        // 5. Buyer approves payment and buys the item</span>
  93 |     | <span class='unexecuted'>        uint256 fee = (totalPrice * 250) / 10000;</span>
  94 |     | <span class='unexecuted'>        uint256 sellerProceeds = totalPrice - fee;</span>
  95 |     | <span class='neutral'></span>
  96 |     | <span class='unexecuted'>        vm.startPrank(buyer);</span>
  97 |     | <span class='unexecuted'>        paymentToken.approve(address(marketplace), type(uint256).max);</span>
  98 |     | <span class='unexecuted'>        marketplace.buy(listingId, buyAmount);</span>
  99 |     | <span class='unexecuted'>        vm.stopPrank();</span>
 100 |     | <span class='neutral'></span>
 101 |     | <span class='neutral'>        // --- Assert Final State ---</span>
 102 |     | <span class='neutral'>        // Assert NFT balances</span>
 103 |     | <span class='unexecuted'>        assertEq(credit.balanceOf(seller, tokenId), mintAmount - listAmount, &quot;Seller NFT balance incorrect&quot;);</span>
 104 |     | <span class='unexecuted'>        assertEq(credit.balanceOf(buyer, tokenId), buyAmount, &quot;Buyer NFT balance incorrect&quot;);</span>
 105 |     | <span class='unexecuted'>        assertEq(</span>
 106 |     | <span class='unexecuted'>            credit.balanceOf(address(marketplace), tokenId), listAmount - buyAmount, &quot;Marketplace NFT balance incorrect&quot;</span>
 107 |     | <span class='neutral'>        );</span>
 108 |     | <span class='neutral'></span>
 109 |     | <span class='neutral'>        // Assert payment token balances</span>
 110 |     | <span class='unexecuted'>        assertEq(paymentToken.balanceOf(seller), sellerProceeds, &quot;Seller payment balance incorrect&quot;);</span>
 111 |     | <span class='neutral'>    }</span>
 112 |     | <span class='neutral'>}</span>
 113 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/phantom/Documents/azemora/azemora-contracts/test/marketplace/Marketplace.griefing.t.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'>pragma solidity ^0.8.20;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>import &quot;forge-std/Test.sol&quot;;</span>
   5 |     | <span class='neutral'>import &quot;../../src/marketplace/Marketplace.sol&quot;;</span>
   6 |     | <span class='neutral'>import &quot;../../src/core/DynamicImpactCredit.sol&quot;;</span>
   7 |     | <span class='neutral'>import &quot;../../src/core/ProjectRegistry.sol&quot;;</span>
   8 |     | <span class='neutral'>import &quot;@openzeppelin/contracts/proxy/ERC1967/ERC1967Proxy.sol&quot;;</span>
   9 |     | <span class='neutral'></span>
  10 |     | <span class='neutral'>// Mock ERC20 for payment</span>
  11 |     | <span class='unexecuted'>contract MockERC20ForGriefTest {</span>
  12 |     | <span class='neutral'>    event Approval(address indexed owner, address indexed spender, uint256 value);</span>
  13 |     | <span class='neutral'></span>
  14 |     | <span class='unexecuted'>    mapping(address =&gt; uint256) public balanceOf;</span>
  15 |     | <span class='unexecuted'>    mapping(address =&gt; mapping(address =&gt; uint256)) public allowance;</span>
  16 |     | <span class='neutral'></span>
  17 |     | <span class='unexecuted'>    function mint(address to, uint256 amount) external {</span>
  18 |     | <span class='unexecuted'>        balanceOf[to] += amount;</span>
  19 |     | <span class='neutral'>    }</span>
  20 |     | <span class='neutral'></span>
  21 |     | <span class='unexecuted'>    function approve(address spender, uint256 amount) public returns (bool) {</span>
  22 |     | <span class='unexecuted'>        allowance[msg.sender][spender] = amount;</span>
  23 |     | <span class='unexecuted'>        emit Approval(msg.sender, spender, amount);</span>
  24 |     | <span class='unexecuted'>        return true;</span>
  25 |     | <span class='neutral'>    }</span>
  26 |     | <span class='neutral'></span>
  27 |     | <span class='unexecuted'>    function transferFrom(address from, address to, uint256 amount) public returns (bool) {</span>
  28 |     | <span class='unexecuted'>        require(balanceOf[from] &gt;= amount, &quot;MockERC20: insufficient balance&quot;);</span>
  29 |     | <span class='unexecuted'>        require(allowance[from][msg.sender] &gt;= amount, &quot;MockERC20: insufficient allowance&quot;);</span>
  30 |     | <span class='neutral'></span>
  31 |     | <span class='unexecuted'>        if (allowance[from][msg.sender] != type(uint256).max) {</span>
  32 |     | <span class='unexecuted'>            allowance[from][msg.sender] -= amount;</span>
  33 |     | <span class='neutral'>        }</span>
  34 |     | <span class='unexecuted'>        balanceOf[from] -= amount;</span>
  35 |     | <span class='unexecuted'>        balanceOf[to] += amount;</span>
  36 |     | <span class='unexecuted'>        return true;</span>
  37 |     | <span class='neutral'>    }</span>
  38 |     | <span class='neutral'>}</span>
  39 |     | <span class='neutral'></span>
  40 |     | <span class='unexecuted'>contract MarketplaceGriefingTest is Test {</span>
  41 |     | <span class='neutral'>    // Contracts</span>
  42 |     | <span class='neutral'>    Marketplace marketplace;</span>
  43 |     | <span class='neutral'>    DynamicImpactCredit credit;</span>
  44 |     | <span class='neutral'>    MockERC20ForGriefTest paymentToken;</span>
  45 |     | <span class='neutral'>    ProjectRegistry registry;</span>
  46 |     | <span class='neutral'></span>
  47 |     | <span class='neutral'>    // Users</span>
  48 |     | <span class='neutral'>    address admin;</span>
  49 |     | <span class='unexecuted'>    address seller = makeAddr(&quot;seller&quot;);</span>
  50 |     | <span class='neutral'></span>
  51 |     | <span class='neutral'>    // Constants</span>
  52 |     | <span class='unexecuted'>    uint256 constant BATCH_TOKEN_ID = 1;</span>
  53 |     | <span class='unexecuted'>    uint256 constant LIST_AMOUNT = 100;</span>
  54 |     | <span class='unexecuted'>    uint256 constant PRICE_PER_UNIT = 1 ether;</span>
  55 |     | <span class='neutral'></span>
  56 |     | <span class='unexecuted'>    function setUp() public {</span>
  57 |     | <span class='unexecuted'>        admin = address(this);</span>
  58 |     | <span class='neutral'></span>
  59 |     | <span class='neutral'>        // Deploy Project Registry</span>
  60 |     | <span class='unexecuted'>        ProjectRegistry registryImpl = new ProjectRegistry();</span>
  61 |     | <span class='unexecuted'>        bytes memory registryInitData = abi.encodeCall(ProjectRegistry.initialize, ());</span>
  62 |     | <span class='unexecuted'>        ERC1967Proxy registryProxy = new ERC1967Proxy(address(registryImpl), registryInitData);</span>
  63 |     | <span class='unexecuted'>        registry = ProjectRegistry(address(registryProxy));</span>
  64 |     | <span class='neutral'></span>
  65 |     | <span class='neutral'>        // Deploy Dynamic Impact Credit (ERC1155)</span>
  66 |     | <span class='unexecuted'>        DynamicImpactCredit creditImpl = new DynamicImpactCredit(address(registry));</span>
  67 |     | <span class='unexecuted'>        bytes memory creditInitData = abi.encodeCall(DynamicImpactCredit.initialize, (&quot;uri&quot;));</span>
  68 |     | <span class='unexecuted'>        ERC1967Proxy creditProxy = new ERC1967Proxy(address(creditImpl), creditInitData);</span>
  69 |     | <span class='unexecuted'>        credit = DynamicImpactCredit(address(creditProxy));</span>
  70 |     | <span class='neutral'></span>
  71 |     | <span class='neutral'>        // Deploy Mock Payment Token (ERC20)</span>
  72 |     | <span class='unexecuted'>        paymentToken = new MockERC20ForGriefTest();</span>
  73 |     | <span class='neutral'></span>
  74 |     | <span class='neutral'>        // Deploy Marketplace</span>
  75 |     | <span class='unexecuted'>        Marketplace marketplaceImpl = new Marketplace();</span>
  76 |     | <span class='unexecuted'>        bytes memory marketplaceInitData =</span>
  77 |     | <span class='unexecuted'>            abi.encodeCall(Marketplace.initialize, (address(credit), address(paymentToken)));</span>
  78 |     | <span class='unexecuted'>        ERC1967Proxy marketplaceProxy = new ERC1967Proxy(address(marketplaceImpl), marketplaceInitData);</span>
  79 |     | <span class='unexecuted'>        marketplace = Marketplace(address(marketplaceProxy));</span>
  80 |     | <span class='neutral'></span>
  81 |     | <span class='neutral'>        // Configure roles and mint assets</span>
  82 |     | <span class='unexecuted'>        marketplace.setTreasury(admin); // Set treasury for fees</span>
  83 |     | <span class='neutral'></span>
  84 |     | <span class='neutral'>        // Mint credits to the seller</span>
  85 |     | <span class='unexecuted'>        vm.prank(admin);</span>
  86 |     | <span class='unexecuted'>        credit.grantRole(credit.DMRV_MANAGER_ROLE(), admin);</span>
  87 |     | <span class='unexecuted'>        vm.prank(admin);</span>
  88 |     | <span class='neutral'>        // Mint a large number of tokens to the seller to cover all listings</span>
  89 |     | <span class='neutral'>        // We also need to register a project for these credits</span>
  90 |     | <span class='neutral'>        bytes32 projectId = bytes32(uint256(BATCH_TOKEN_ID));</span>
  91 |     | <span class='unexecuted'>        registry.registerProject(projectId, &quot;griefing-project&quot;);</span>
  92 |     | <span class='unexecuted'>        registry.setProjectStatus(projectId, ProjectRegistry.ProjectStatus.Active);</span>
  93 |     | <span class='unexecuted'>        credit.mintCredits(seller, projectId, 1000, &quot;grief-uri&quot;);</span>
  94 |     | <span class='neutral'></span>
  95 |     | <span class='neutral'>        // Approve marketplace to spend seller&#39;s credits</span>
  96 |     | <span class='unexecuted'>        vm.prank(seller);</span>
  97 |     | <span class='unexecuted'>        credit.setApprovalForAll(address(marketplace), true);</span>
  98 |     | <span class='neutral'>    }</span>
  99 |     | <span class='neutral'></span>
 100 |     | <span class='neutral'>    /**</span>
 101 |     | <span class='neutral'>     * @dev Tests if batch-cancelling many listings can be done within a single block&#39;s gas limit.</span>
 102 |     | <span class='neutral'>     * This simulates a potential DoS vector where a user creates many listings and then tries</span>
 103 |     | <span class='neutral'>     * to execute a costly operation on them.</span>
 104 |     | <span class='neutral'>     */</span>
 105 |     | <span class='unexecuted'>    function test_GasGriefing_BatchCancel_StaysWithinBlockLimit() public {</span>
 106 |     | <span class='unexecuted'>        uint256 numListings = 1000;</span>
 107 |     | <span class='unexecuted'>        uint256[] memory listingIds = new uint256[](numListings);</span>
 108 |     | <span class='neutral'></span>
 109 |     | <span class='neutral'>        // 1. Create a large number of listings</span>
 110 |     | <span class='unexecuted'>        vm.startPrank(seller);</span>
 111 |     | <span class='unexecuted'>        for (uint256 i = 0; i &lt; numListings; i++) {</span>
 112 |     | <span class='unexecuted'>            listingIds[i] = marketplace.list(BATCH_TOKEN_ID, 1, PRICE_PER_UNIT, 1 weeks);</span>
 113 |     | <span class='neutral'>        }</span>
 114 |     | <span class='unexecuted'>        vm.stopPrank();</span>
 115 |     | <span class='neutral'></span>
 116 |     | <span class='neutral'>        // 2. Attempt to cancel all listings in a single transaction.</span>
 117 |     | <span class='unexecuted'>        uint256 gasBefore = gasleft();</span>
 118 |     | <span class='unexecuted'>        vm.prank(seller);</span>
 119 |     | <span class='unexecuted'>        marketplace.batchCancelListings(listingIds);</span>
 120 |     | <span class='unexecuted'>        uint256 gasAfter = gasleft();</span>
 121 |     | <span class='unexecuted'>        uint256 gasUsed = gasBefore - gasAfter;</span>
 122 |     | <span class='neutral'></span>
 123 |     | <span class='neutral'>        // 3. Assert gas is under a reasonable limit (e.g., 29M, default block limit is 30M)</span>
 124 |     | <span class='unexecuted'>        console.log(&quot;Gas used for 1000 cancellations:&quot;, gasUsed);</span>
 125 |     | <span class='unexecuted'>        assertLt(gasUsed, 29_000_000, &quot;Gas for 1000 cancellations should be under block limit&quot;);</span>
 126 |     | <span class='neutral'>    }</span>
 127 |     | <span class='neutral'></span>
 128 |     | <span class='neutral'>    /**</span>
 129 |     | <span class='neutral'>     * @dev Tests if batch-buying many listings can be done within a single block&#39;s gas limit.</span>
 130 |     | <span class='neutral'>     */</span>
 131 |     | <span class='unexecuted'>    function test_GasGriefing_BatchBuy_StaysWithinBlockLimit() public {</span>
 132 |     | <span class='unexecuted'>        uint256 numListings = 500; // Reduced from 1000 as buy is more expensive</span>
 133 |     | <span class='unexecuted'>        uint256[] memory listingIds = new uint256[](numListings);</span>
 134 |     | <span class='unexecuted'>        uint256[] memory amountsToBuy = new uint256[](numListings);</span>
 135 |     | <span class='unexecuted'>        address buyer = makeAddr(&quot;buyer&quot;);</span>
 136 |     | <span class='neutral'></span>
 137 |     | <span class='neutral'>        // 1. Create a large number of listings</span>
 138 |     | <span class='unexecuted'>        vm.startPrank(seller);</span>
 139 |     | <span class='unexecuted'>        for (uint256 i = 0; i &lt; numListings; i++) {</span>
 140 |     | <span class='unexecuted'>            listingIds[i] = marketplace.list(BATCH_TOKEN_ID, 1, PRICE_PER_UNIT, 1 weeks);</span>
 141 |     | <span class='unexecuted'>            amountsToBuy[i] = 1;</span>
 142 |     | <span class='neutral'>        }</span>
 143 |     | <span class='unexecuted'>        vm.stopPrank();</span>
 144 |     | <span class='neutral'></span>
 145 |     | <span class='neutral'>        // 2. Fund the buyer and have them approve the marketplace</span>
 146 |     | <span class='unexecuted'>        uint256 totalCost = numListings * PRICE_PER_UNIT;</span>
 147 |     | <span class='unexecuted'>        paymentToken.mint(buyer, totalCost);</span>
 148 |     | <span class='unexecuted'>        vm.prank(buyer);</span>
 149 |     | <span class='unexecuted'>        paymentToken.approve(address(marketplace), totalCost);</span>
 150 |     | <span class='neutral'></span>
 151 |     | <span class='neutral'>        // 3. Attempt to buy all listings in a single transaction.</span>
 152 |     | <span class='unexecuted'>        uint256 gasBefore = gasleft();</span>
 153 |     | <span class='unexecuted'>        vm.prank(buyer);</span>
 154 |     | <span class='unexecuted'>        marketplace.batchBuy(listingIds, amountsToBuy);</span>
 155 |     | <span class='unexecuted'>        uint256 gasAfter = gasleft();</span>
 156 |     | <span class='unexecuted'>        uint256 gasUsed = gasBefore - gasAfter;</span>
 157 |     | <span class='neutral'></span>
 158 |     | <span class='neutral'>        // 4. Assert gas is under a reasonable limit (e.g., 29M, default block limit is 30M)</span>
 159 |     | <span class='unexecuted'>        console.log(&quot;Gas used for 500 purchases:&quot;, gasUsed);</span>
 160 |     | <span class='unexecuted'>        assertLt(gasUsed, 29_000_000, &quot;Gas for 500 purchases should be under block limit&quot;);</span>
 161 |     | <span class='neutral'>    }</span>
 162 |     | <span class='neutral'></span>
 163 |     | <span class='neutral'>    /**</span>
 164 |     | <span class='neutral'>     * @dev Tests if cancelling a listing with a very long expiration properly cleans up storage.</span>
 165 |     | <span class='neutral'>     * This prevents a griefing vector where expired/cancelled listings bloat contract storage indefinitely.</span>
 166 |     | <span class='neutral'>     */</span>
 167 |     | <span class='unexecuted'>    function test_StorageGriefing_LongExpiration_CleanupOnCancel() public {</span>
 168 |     | <span class='unexecuted'>        uint256 longExpiration = 100 * 365 days; // 100 years</span>
 169 |     | <span class='neutral'></span>
 170 |     | <span class='neutral'>        // 1. Create a listing with a very long expiration</span>
 171 |     | <span class='unexecuted'>        vm.prank(seller);</span>
 172 |     | <span class='unexecuted'>        uint256 listingId = marketplace.list(BATCH_TOKEN_ID, LIST_AMOUNT, PRICE_PER_UNIT, longExpiration);</span>
 173 |     | <span class='neutral'></span>
 174 |     | <span class='neutral'>        // 2. Verify the listing is active and has correct data</span>
 175 |     | <span class='unexecuted'>        Marketplace.Listing memory listingBefore = marketplace.getListing(listingId);</span>
 176 |     | <span class='unexecuted'>        assertTrue(listingBefore.active, &quot;Listing should be active before cancellation&quot;);</span>
 177 |     | <span class='unexecuted'>        assertEq(listingBefore.seller, seller, &quot;Seller should be correct&quot;);</span>
 178 |     | <span class='unexecuted'>        assertEq(listingBefore.amount, LIST_AMOUNT, &quot;Amount should be correct&quot;);</span>
 179 |     | <span class='neutral'></span>
 180 |     | <span class='neutral'>        // 3. Cancel the listing</span>
 181 |     | <span class='unexecuted'>        vm.prank(seller);</span>
 182 |     | <span class='unexecuted'>        marketplace.cancelListing(listingId);</span>
 183 |     | <span class='neutral'></span>
 184 |     | <span class='neutral'>        // 4. Verify the listing is no longer active.</span>
 185 |     | <span class='neutral'>        // In this implementation, cancellation only flips the `active` flag. A more robust</span>
 186 |     | <span class='neutral'>        // implementation might use `delete` to clear all storage, but that has its own gas implications.</span>
 187 |     | <span class='neutral'>        // We will check that the listing is marked inactive.</span>
 188 |     | <span class='unexecuted'>        Marketplace.Listing memory listingAfter = marketplace.getListing(listingId);</span>
 189 |     | <span class='unexecuted'>        assertFalse(listingAfter.active, &quot;Listing should be inactive after cancellation&quot;);</span>
 190 |     | <span class='neutral'>    }</span>
 191 |     | <span class='neutral'>}</span>
 192 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/phantom/Documents/azemora/azemora-contracts/test/marketplace/Marketplace.invariant.t.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'>pragma solidity ^0.8.20;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>import &quot;forge-std/Test.sol&quot;;</span>
   5 |     | <span class='neutral'>import &quot;./Marketplace.t.sol&quot;; // Re-use mocks</span>
   6 |     | <span class='neutral'>import &quot;../../src/core/ProjectRegistry.sol&quot;;</span>
   7 |     | <span class='neutral'>import &quot;../../src/core/dMRVManager.sol&quot;;</span>
   8 |     | <span class='neutral'>import &quot;../../src/core/DynamicImpactCredit.sol&quot;;</span>
   9 |     | <span class='neutral'>import &quot;../../src/marketplace/Marketplace.sol&quot;;</span>
  10 |     | <span class='neutral'>import &quot;@openzeppelin/contracts/proxy/ERC1967/ERC1967Proxy.sol&quot;;</span>
  11 |     | <span class='neutral'></span>
  12 |     | <span class='neutral'>// Handler contract to perform random actions on the Marketplace</span>
  13 |     | <span class='unexecuted'>contract MarketplaceHandler is Test {</span>
  14 |     | <span class='unexecuted'>    ProjectRegistry public registry;</span>
  15 |     | <span class='unexecuted'>    DynamicImpactCredit public credit;</span>
  16 |     | <span class='unexecuted'>    Marketplace public marketplace;</span>
  17 |     | <span class='unexecuted'>    MockERC20 public paymentToken;</span>
  18 |     | <span class='neutral'></span>
  19 |     | <span class='neutral'>    // --- State tracking for invariants ---</span>
  20 |     | <span class='neutral'>    // We don&#39;t need to track credit balances here, as the credit contract has its own invariants.</span>
  21 |     | <span class='neutral'>    // We will track payment token balances to ensure conservation.</span>
  22 |     | <span class='unexecuted'>    mapping(address =&gt; uint256) public userPaymentTokenBalances;</span>
  23 |     | <span class='neutral'></span>
  24 |     | <span class='neutral'>    // --- Actors ---</span>
  25 |     | <span class='unexecuted'>    address public admin;</span>
  26 |     | <span class='unexecuted'>    address public verifier;</span>
  27 |     | <span class='unexecuted'>    address public dmrvManager;</span>
  28 |     | <span class='unexecuted'>    address public treasury;</span>
  29 |     | <span class='unexecuted'>    address[] public users; // Sellers and buyers</span>
  30 |     | <span class='neutral'></span>
  31 |     | <span class='neutral'>    // --- Available assets ---</span>
  32 |     | <span class='unexecuted'>    bytes32[] public projectIds;</span>
  33 |     | <span class='unexecuted'>    mapping(bytes32 =&gt; bool) public projectIdExists;</span>
  34 |     | <span class='unexecuted'>    mapping(bytes32 =&gt; uint256) public totalCreditSupply;</span>
  35 |     | <span class='neutral'></span>
  36 |     | <span class='unexecuted'>    function getUsersLength() public view returns (uint256) {</span>
  37 |     | <span class='unexecuted'>        return users.length;</span>
  38 |     | <span class='neutral'>    }</span>
  39 |     | <span class='neutral'></span>
  40 |     | <span class='unexecuted'>    function getProjectIdsLength() public view returns (uint256) {</span>
  41 |     | <span class='unexecuted'>        return projectIds.length;</span>
  42 |     | <span class='neutral'>    }</span>
  43 |     | <span class='neutral'></span>
  44 |     | <span class='unexecuted'>    constructor(</span>
  45 |     | <span class='neutral'>        ProjectRegistry _registry,</span>
  46 |     | <span class='neutral'>        DynamicImpactCredit _credit,</span>
  47 |     | <span class='neutral'>        Marketplace _marketplace,</span>
  48 |     | <span class='neutral'>        MockERC20 _paymentToken,</span>
  49 |     | <span class='neutral'>        address _admin,</span>
  50 |     | <span class='neutral'>        address _verifier,</span>
  51 |     | <span class='neutral'>        address _dmrvManager,</span>
  52 |     | <span class='neutral'>        address _treasury</span>
  53 |     | <span class='neutral'>    ) {</span>
  54 |     | <span class='unexecuted'>        registry = _registry;</span>
  55 |     | <span class='unexecuted'>        credit = _credit;</span>
  56 |     | <span class='unexecuted'>        marketplace = _marketplace;</span>
  57 |     | <span class='unexecuted'>        paymentToken = _paymentToken;</span>
  58 |     | <span class='unexecuted'>        admin = _admin;</span>
  59 |     | <span class='unexecuted'>        verifier = _verifier;</span>
  60 |     | <span class='unexecuted'>        dmrvManager = _dmrvManager;</span>
  61 |     | <span class='unexecuted'>        treasury = _treasury;</span>
  62 |     | <span class='neutral'></span>
  63 |     | <span class='neutral'>        // Create test users</span>
  64 |     | <span class='unexecuted'>        for (uint256 i = 0; i &lt; 4; i++) {</span>
  65 |     | <span class='unexecuted'>            users.push(address(uint160(uint256(keccak256(abi.encodePacked(&quot;user&quot;, i))))));</span>
  66 |     | <span class='neutral'>        }</span>
  67 |     | <span class='neutral'></span>
  68 |     | <span class='neutral'>        // Fund users and track initial balances</span>
  69 |     | <span class='unexecuted'>        for (uint256 i = 0; i &lt; users.length; i++) {</span>
  70 |     | <span class='unexecuted'>            uint256 initialBalance = 1_000_000 * 1e6;</span>
  71 |     | <span class='unexecuted'>            paymentToken.mint(users[i], initialBalance);</span>
  72 |     | <span class='unexecuted'>            userPaymentTokenBalances[users[i]] = initialBalance;</span>
  73 |     | <span class='neutral'>        }</span>
  74 |     | <span class='neutral'>        // Fee recipient starts with 0</span>
  75 |     | <span class='unexecuted'>        userPaymentTokenBalances[treasury] = 0;</span>
  76 |     | <span class='neutral'></span>
  77 |     | <span class='neutral'>        // Target the handler so that fuzz inputs are sent to its public functions</span>
  78 |     | <span class='unexecuted'>        targetContract(address(this));</span>
  79 |     | <span class='neutral'>    }</span>
  80 |     | <span class='neutral'></span>
  81 |     | <span class='neutral'>    /* --- ACTIONS --- */</span>
  82 |     | <span class='neutral'></span>
  83 |     | <span class='neutral'>    // Action: A random user lists a random amount of a random credit</span>
  84 |     | <span class='unexecuted'>    function list(uint256 seed, uint256 listAmount, uint256 price) public {</span>
  85 |     | <span class='neutral'>        // 1. Get a seller</span>
  86 |     | <span class='unexecuted'>        address seller = users[seed % users.length];</span>
  87 |     | <span class='neutral'></span>
  88 |     | <span class='neutral'>        // 2. Ensure seller has something to sell. If not, mint them some credits.</span>
  89 |     | <span class='unexecuted'>        bytes32 projectId = keccak256(abi.encodePacked(&quot;project&quot;, seed % 5)); // Limit to 5 projects</span>
  90 |     | <span class='unexecuted'>        if (!projectIdExists[projectId]) {</span>
  91 |     | <span class='neutral'>            // Create the project and mint initial credits</span>
  92 |     | <span class='unexecuted'>            uint256 mintAmount = 1_000_000;</span>
  93 |     | <span class='unexecuted'>            vm.prank(seller);</span>
  94 |     | <span class='unexecuted'>            registry.registerProject(projectId, &quot;ipfs://fuzz.json&quot;);</span>
  95 |     | <span class='unexecuted'>            vm.prank(verifier);</span>
  96 |     | <span class='unexecuted'>            registry.setProjectStatus(projectId, ProjectRegistry.ProjectStatus.Active);</span>
  97 |     | <span class='unexecuted'>            vm.prank(dmrvManager);</span>
  98 |     | <span class='unexecuted'>            credit.mintCredits(seller, projectId, mintAmount, &quot;uri&quot;);</span>
  99 |     | <span class='neutral'></span>
 100 |     | <span class='unexecuted'>            projectIds.push(projectId);</span>
 101 |     | <span class='unexecuted'>            projectIdExists[projectId] = true;</span>
 102 |     | <span class='unexecuted'>            totalCreditSupply[projectId] = mintAmount;</span>
 103 |     | <span class='neutral'>        }</span>
 104 |     | <span class='neutral'></span>
 105 |     | <span class='neutral'>        // 3. Bound inputs</span>
 106 |     | <span class='unexecuted'>        uint256 sellerBalance = credit.balanceOf(seller, uint256(projectId));</span>
 107 |     | <span class='unexecuted'>        if (sellerBalance == 0) return; // Nothing to list</span>
 108 |     | <span class='unexecuted'>        listAmount = bound(listAmount, 1, sellerBalance);</span>
 109 |     | <span class='unexecuted'>        price = bound(price, 1, 1_000_000 * 1e6);</span>
 110 |     | <span class='neutral'></span>
 111 |     | <span class='neutral'>        // 4. Execute: List the item</span>
 112 |     | <span class='unexecuted'>        vm.startPrank(seller);</span>
 113 |     | <span class='unexecuted'>        credit.setApprovalForAll(address(marketplace), true);</span>
 114 |     | <span class='unexecuted'>        marketplace.list(uint256(projectId), listAmount, price, 1 days);</span>
 115 |     | <span class='unexecuted'>        vm.stopPrank();</span>
 116 |     | <span class='neutral'>    }</span>
 117 |     | <span class='neutral'></span>
 118 |     | <span class='neutral'>    // Action: A random user buys from a random active listing</span>
 119 |     | <span class='unexecuted'>    function buy(uint256 seed, uint256 listingId, uint256 buyAmount) public {</span>
 120 |     | <span class='unexecuted'>        uint256 activeListingCount = marketplace.activeListingCount();</span>
 121 |     | <span class='unexecuted'>        if (activeListingCount == 0) return;</span>
 122 |     | <span class='neutral'></span>
 123 |     | <span class='unexecuted'>        listingId = bound(listingId, 0, marketplace.listingIdCounter() - 1);</span>
 124 |     | <span class='unexecuted'>        Marketplace.Listing memory l = marketplace.getListing(listingId);</span>
 125 |     | <span class='neutral'></span>
 126 |     | <span class='unexecuted'>        if (!l.active) return; // Can&#39;t buy from inactive listing</span>
 127 |     | <span class='neutral'></span>
 128 |     | <span class='neutral'>        // 1. Get a buyer (cannot be the seller)</span>
 129 |     | <span class='unexecuted'>        address buyer;</span>
 130 |     | <span class='neutral'>        uint256 i = 0;</span>
 131 |     | <span class='unexecuted'>        do {</span>
 132 |     | <span class='unexecuted'>            buyer = users[(seed + i) % users.length];</span>
 133 |     | <span class='unexecuted'>            i++;</span>
 134 |     | <span class='unexecuted'>        } while (buyer == l.seller);</span>
 135 |     | <span class='neutral'></span>
 136 |     | <span class='neutral'>        // 2. Bound inputs</span>
 137 |     | <span class='unexecuted'>        buyAmount = bound(buyAmount, 1, l.amount);</span>
 138 |     | <span class='neutral'></span>
 139 |     | <span class='neutral'>        // 3. Ensure buyer can afford it and update tracked balances</span>
 140 |     | <span class='unexecuted'>        uint256 totalPrice = buyAmount * l.pricePerUnit;</span>
 141 |     | <span class='unexecuted'>        if (paymentToken.balanceOf(buyer) &lt; totalPrice) return;</span>
 142 |     | <span class='neutral'></span>
 143 |     | <span class='unexecuted'>        uint256 fee = (totalPrice * marketplace.feeBps()) / 10000;</span>
 144 |     | <span class='unexecuted'>        uint256 sellerProceeds = totalPrice - fee;</span>
 145 |     | <span class='neutral'></span>
 146 |     | <span class='unexecuted'>        userPaymentTokenBalances[buyer] -= totalPrice;</span>
 147 |     | <span class='unexecuted'>        userPaymentTokenBalances[l.seller] += sellerProceeds;</span>
 148 |     | <span class='unexecuted'>        userPaymentTokenBalances[treasury] += fee;</span>
 149 |     | <span class='neutral'></span>
 150 |     | <span class='neutral'>        // 4. Execute: Buyer approves and buys</span>
 151 |     | <span class='unexecuted'>        vm.startPrank(buyer);</span>
 152 |     | <span class='unexecuted'>        paymentToken.approve(address(marketplace), totalPrice);</span>
 153 |     | <span class='unexecuted'>        marketplace.buy(listingId, buyAmount);</span>
 154 |     | <span class='unexecuted'>        vm.stopPrank();</span>
 155 |     | <span class='neutral'>    }</span>
 156 |     | <span class='neutral'></span>
 157 |     | <span class='neutral'>    // Action: A random seller cancels their listing</span>
 158 |     | <span class='unexecuted'>    function cancel(uint256 listingId) public {</span>
 159 |     | <span class='unexecuted'>        uint256 listingCounter = marketplace.listingIdCounter();</span>
 160 |     | <span class='unexecuted'>        if (listingCounter == 0) return;</span>
 161 |     | <span class='unexecuted'>        listingId = bound(listingId, 0, listingCounter - 1);</span>
 162 |     | <span class='neutral'></span>
 163 |     | <span class='unexecuted'>        Marketplace.Listing memory l = marketplace.getListing(listingId);</span>
 164 |     | <span class='unexecuted'>        if (!l.active) return;</span>
 165 |     | <span class='neutral'></span>
 166 |     | <span class='unexecuted'>        vm.prank(l.seller);</span>
 167 |     | <span class='unexecuted'>        try marketplace.cancelListing(listingId) {</span>
 168 |     | <span class='neutral'>            // success is okay</span>
 169 |     | <span class='neutral'>        } catch {</span>
 170 |     | <span class='neutral'>            // revert is okay</span>
 171 |     | <span class='neutral'>        }</span>
 172 |     | <span class='neutral'>    }</span>
 173 |     | <span class='neutral'>}</span>
 174 |     | <span class='neutral'></span>
 175 |     | <span class='neutral'>// The Invariant Test Contract</span>
 176 |     | <span class='unexecuted'>contract MarketplaceInvariantTest is StdInvariant, Test {</span>
 177 |     | <span class='neutral'>    MarketplaceHandler handler;</span>
 178 |     | <span class='neutral'></span>
 179 |     | <span class='unexecuted'>    function setUp() public {</span>
 180 |     | <span class='neutral'>        // --- Deploy Infrastructure ---</span>
 181 |     | <span class='unexecuted'>        address admin = address(0xA11CE);</span>
 182 |     | <span class='unexecuted'>        address verifier = address(0xC1E4);</span>
 183 |     | <span class='unexecuted'>        address dmrvManager = address(0xB01D);</span>
 184 |     | <span class='unexecuted'>        address treasury = address(0xFE35);</span>
 185 |     | <span class='neutral'></span>
 186 |     | <span class='unexecuted'>        vm.startPrank(admin);</span>
 187 |     | <span class='unexecuted'>        ProjectRegistry registry = ProjectRegistry(</span>
 188 |     | <span class='unexecuted'>            address(new ERC1967Proxy(address(new ProjectRegistry()), abi.encodeCall(ProjectRegistry.initialize, ())))</span>
 189 |     | <span class='neutral'>        );</span>
 190 |     | <span class='unexecuted'>        registry.grantRole(registry.VERIFIER_ROLE(), verifier);</span>
 191 |     | <span class='neutral'></span>
 192 |     | <span class='unexecuted'>        DynamicImpactCredit credit = DynamicImpactCredit(</span>
 193 |     | <span class='neutral'>            address(</span>
 194 |     | <span class='unexecuted'>                new ERC1967Proxy(</span>
 195 |     | <span class='unexecuted'>                    address(new DynamicImpactCredit(address(registry))),</span>
 196 |     | <span class='unexecuted'>                    abi.encodeCall(DynamicImpactCredit.initialize, (&quot;uri&quot;))</span>
 197 |     | <span class='neutral'>                )</span>
 198 |     | <span class='neutral'>            )</span>
 199 |     | <span class='neutral'>        );</span>
 200 |     | <span class='unexecuted'>        credit.grantRole(credit.DMRV_MANAGER_ROLE(), dmrvManager);</span>
 201 |     | <span class='neutral'></span>
 202 |     | <span class='unexecuted'>        MockERC20 paymentToken = new MockERC20(&quot;USD Coin&quot;, &quot;USDC&quot;, 6);</span>
 203 |     | <span class='unexecuted'>        Marketplace marketplace = Marketplace(</span>
 204 |     | <span class='neutral'>            address(</span>
 205 |     | <span class='unexecuted'>                new ERC1967Proxy(</span>
 206 |     | <span class='unexecuted'>                    address(new Marketplace()),</span>
 207 |     | <span class='unexecuted'>                    abi.encodeCall(Marketplace.initialize, (address(credit), address(paymentToken)))</span>
 208 |     | <span class='neutral'>                )</span>
 209 |     | <span class='neutral'>            )</span>
 210 |     | <span class='neutral'>        );</span>
 211 |     | <span class='unexecuted'>        marketplace.setTreasury(treasury);</span>
 212 |     | <span class='unexecuted'>        marketplace.setFee(250); // 2.5% fee</span>
 213 |     | <span class='unexecuted'>        vm.stopPrank();</span>
 214 |     | <span class='neutral'></span>
 215 |     | <span class='neutral'>        // --- Set up Handler ---</span>
 216 |     | <span class='unexecuted'>        handler =</span>
 217 |     | <span class='unexecuted'>            new MarketplaceHandler(registry, credit, marketplace, paymentToken, admin, verifier, dmrvManager, treasury);</span>
 218 |     | <span class='neutral'></span>
 219 |     | <span class='neutral'>        // Target the handler so that fuzz inputs are sent to its public functions</span>
 220 |     | <span class='unexecuted'>        targetContract(address(handler));</span>
 221 |     | <span class='neutral'>    }</span>
 222 |     | <span class='neutral'></span>
 223 |     | <span class='neutral'>    // INVARIANT 1: Payment tokens are conserved.</span>
 224 |     | <span class='neutral'>    // The total amount of payment tokens across all users and the fee recipient</span>
 225 |     | <span class='neutral'>    // should always equal the sum of their initial balances.</span>
 226 |     | <span class='unexecuted'>    function invariant_paymentTokenIsConserved() public view {</span>
 227 |     | <span class='unexecuted'>        uint256 totalTrackedBalance = 0;</span>
 228 |     | <span class='unexecuted'>        uint256 totalActualBalance = 0;</span>
 229 |     | <span class='neutral'></span>
 230 |     | <span class='unexecuted'>        uint256 usersLength = handler.getUsersLength();</span>
 231 |     | <span class='unexecuted'>        for (uint256 i = 0; i &lt; usersLength; i++) {</span>
 232 |     | <span class='unexecuted'>            address user = handler.users(i);</span>
 233 |     | <span class='unexecuted'>            totalTrackedBalance += handler.userPaymentTokenBalances(user);</span>
 234 |     | <span class='unexecuted'>            totalActualBalance += handler.paymentToken().balanceOf(user);</span>
 235 |     | <span class='neutral'>        }</span>
 236 |     | <span class='neutral'></span>
 237 |     | <span class='unexecuted'>        address treasury_ = handler.treasury();</span>
 238 |     | <span class='unexecuted'>        totalTrackedBalance += handler.userPaymentTokenBalances(treasury_);</span>
 239 |     | <span class='unexecuted'>        totalActualBalance += handler.paymentToken().balanceOf(treasury_);</span>
 240 |     | <span class='neutral'></span>
 241 |     | <span class='unexecuted'>        assertEq(totalTrackedBalance, totalActualBalance, &quot;Payment token conservation broken&quot;);</span>
 242 |     | <span class='neutral'>    }</span>
 243 |     | <span class='neutral'></span>
 244 |     | <span class='neutral'>    // INVARIANT 2: Marketplace holds no payment tokens.</span>
 245 |     | <span class='neutral'>    // The marketplace contract should only be a conduit for payment tokens, not hold them.</span>
 246 |     | <span class='unexecuted'>    function invariant_marketplaceHoldsNoPaymentTokens() public view {</span>
 247 |     | <span class='unexecuted'>        assertEq(</span>
 248 |     | <span class='unexecuted'>            handler.paymentToken().balanceOf(address(handler.marketplace())), 0, &quot;Marketplace holds payment tokens&quot;</span>
 249 |     | <span class='neutral'>        );</span>
 250 |     | <span class='neutral'>    }</span>
 251 |     | <span class='neutral'></span>
 252 |     | <span class='neutral'>    // INVARIANT 3: Credit tokens are conserved.</span>
 253 |     | <span class='neutral'>    // The total number of tokens for each project ID should remain constant across</span>
 254 |     | <span class='neutral'>    // all users and the marketplace itself.</span>
 255 |     | <span class='unexecuted'>    function invariant_creditTokenIsConserved() public view {</span>
 256 |     | <span class='unexecuted'>        uint256 projectsLength = handler.getProjectIdsLength();</span>
 257 |     | <span class='unexecuted'>        for (uint256 i = 0; i &lt; projectsLength; i++) {</span>
 258 |     | <span class='unexecuted'>            bytes32 projectId = handler.projectIds(i);</span>
 259 |     | <span class='unexecuted'>            uint256 tokenId = uint256(projectId);</span>
 260 |     | <span class='neutral'></span>
 261 |     | <span class='neutral'>            // Get the initial total supply that was minted for this project</span>
 262 |     | <span class='unexecuted'>            uint256 initialTotalSupply = handler.totalCreditSupply(projectId);</span>
 263 |     | <span class='neutral'></span>
 264 |     | <span class='neutral'>            // Calculate the current total supply held by all actors</span>
 265 |     | <span class='unexecuted'>            uint256 currentTotalSupply = 0;</span>
 266 |     | <span class='neutral'></span>
 267 |     | <span class='neutral'>            // Add balances of all users</span>
 268 |     | <span class='unexecuted'>            uint256 usersLength = handler.getUsersLength();</span>
 269 |     | <span class='unexecuted'>            for (uint256 j = 0; j &lt; usersLength; j++) {</span>
 270 |     | <span class='unexecuted'>                address user = handler.users(j);</span>
 271 |     | <span class='unexecuted'>                currentTotalSupply += handler.credit().balanceOf(user, tokenId);</span>
 272 |     | <span class='neutral'>            }</span>
 273 |     | <span class='neutral'></span>
 274 |     | <span class='neutral'>            // Add balance held by the marketplace contract</span>
 275 |     | <span class='unexecuted'>            currentTotalSupply += handler.credit().balanceOf(address(handler.marketplace()), tokenId);</span>
 276 |     | <span class='neutral'></span>
 277 |     | <span class='neutral'>            // The current total supply should always equal the initial total supply</span>
 278 |     | <span class='unexecuted'>            assertEq(currentTotalSupply, initialTotalSupply, &quot;Credit token conservation broken&quot;);</span>
 279 |     | <span class='neutral'>        }</span>
 280 |     | <span class='neutral'>    }</span>
 281 |     | <span class='neutral'>}</span>
 282 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/phantom/Documents/azemora/azemora-contracts/test/marketplace/Marketplace.t.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'>pragma solidity ^0.8.20;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>import &quot;forge-std/Test.sol&quot;;</span>
   5 |     | <span class='neutral'>import &quot;../../src/marketplace/Marketplace.sol&quot;;</span>
   6 |     | <span class='neutral'>import &quot;../../src/core/ProjectRegistry.sol&quot;;</span>
   7 |     | <span class='neutral'>import &quot;../../src/core/dMRVManager.sol&quot;;</span>
   8 |     | <span class='neutral'>import &quot;../../src/core/DynamicImpactCredit.sol&quot;;</span>
   9 |     | <span class='neutral'>import &quot;@openzeppelin/contracts/proxy/ERC1967/ERC1967Proxy.sol&quot;;</span>
  10 |     | <span class='neutral'></span>
  11 |     | <span class='neutral'>// Minimal mock ERC20 to avoid dependency on forge-std/mocks</span>
  12 |     | <span class='unexecuted'>contract MockERC20 {</span>
  13 |     | <span class='neutral'>    event Transfer(address indexed from, address indexed to, uint256 value);</span>
  14 |     | <span class='neutral'>    event Approval(address indexed owner, address indexed spender, uint256 value);</span>
  15 |     | <span class='neutral'></span>
  16 |     | <span class='unexecuted'>    mapping(address =&gt; uint256) public balanceOf;</span>
  17 |     | <span class='unexecuted'>    mapping(address =&gt; mapping(address =&gt; uint256)) public allowance;</span>
  18 |     | <span class='unexecuted'>    uint256 public totalSupply;</span>
  19 |     | <span class='unexecuted'>    string public name;</span>
  20 |     | <span class='unexecuted'>    string public symbol;</span>
  21 |     | <span class='unexecuted'>    uint8 public decimals;</span>
  22 |     | <span class='neutral'></span>
  23 |     | <span class='unexecuted'>    constructor(string memory name_, string memory symbol_, uint8 decimals_) {</span>
  24 |     | <span class='unexecuted'>        name = name_;</span>
  25 |     | <span class='unexecuted'>        symbol = symbol_;</span>
  26 |     | <span class='unexecuted'>        decimals = decimals_;</span>
  27 |     | <span class='neutral'>    }</span>
  28 |     | <span class='neutral'></span>
  29 |     | <span class='unexecuted'>    function approve(address spender, uint256 amount) public returns (bool) {</span>
  30 |     | <span class='unexecuted'>        allowance[msg.sender][spender] = amount;</span>
  31 |     | <span class='unexecuted'>        emit Approval(msg.sender, spender, amount);</span>
  32 |     | <span class='unexecuted'>        return true;</span>
  33 |     | <span class='neutral'>    }</span>
  34 |     | <span class='neutral'></span>
  35 |     | <span class='unexecuted'>    function transferFrom(address from, address to, uint256 amount) public returns (bool) {</span>
  36 |     | <span class='unexecuted'>        require(balanceOf[from] &gt;= amount, &quot;ERC20: insufficient balance&quot;);</span>
  37 |     | <span class='unexecuted'>        require(allowance[from][msg.sender] &gt;= amount, &quot;ERC20: insufficient allowance&quot;);</span>
  38 |     | <span class='unexecuted'>        if (allowance[from][msg.sender] != type(uint256).max) {</span>
  39 |     | <span class='unexecuted'>            allowance[from][msg.sender] -= amount;</span>
  40 |     | <span class='neutral'>        }</span>
  41 |     | <span class='unexecuted'>        balanceOf[from] -= amount;</span>
  42 |     | <span class='unexecuted'>        balanceOf[to] += amount;</span>
  43 |     | <span class='unexecuted'>        emit Transfer(from, to, amount);</span>
  44 |     | <span class='unexecuted'>        return true;</span>
  45 |     | <span class='neutral'>    }</span>
  46 |     | <span class='neutral'></span>
  47 |     | <span class='unexecuted'>    function mint(address to, uint256 amount) public {</span>
  48 |     | <span class='unexecuted'>        balanceOf[to] += amount;</span>
  49 |     | <span class='unexecuted'>        totalSupply += amount;</span>
  50 |     | <span class='unexecuted'>        emit Transfer(address(0), to, amount);</span>
  51 |     | <span class='neutral'>    }</span>
  52 |     | <span class='neutral'>}</span>
  53 |     | <span class='neutral'></span>
  54 |     | <span class='unexecuted'>contract MarketplaceTest is Test {</span>
  55 |     | <span class='neutral'>    // Core contracts</span>
  56 |     | <span class='neutral'>    ProjectRegistry registry;</span>
  57 |     | <span class='neutral'>    DynamicImpactCredit credit;</span>
  58 |     | <span class='neutral'>    Marketplace marketplace;</span>
  59 |     | <span class='neutral'></span>
  60 |     | <span class='neutral'>    // Mock payment token</span>
  61 |     | <span class='neutral'>    MockERC20 paymentToken;</span>
  62 |     | <span class='neutral'></span>
  63 |     | <span class='neutral'>    // Users</span>
  64 |     | <span class='unexecuted'>    address admin = address(0xA11CE);</span>
  65 |     | <span class='unexecuted'>    address seller = address(0x5E11E);</span>
  66 |     | <span class='unexecuted'>    address buyer = address(0xB4BE);</span>
  67 |     | <span class='unexecuted'>    address verifier = address(0xC1E4);</span>
  68 |     | <span class='unexecuted'>    address dmrvManager = address(0xB01D);</span>
  69 |     | <span class='unexecuted'>    address treasury = address(0xFE35);</span>
  70 |     | <span class='neutral'></span>
  71 |     | <span class='neutral'>    // Project and Token IDs</span>
  72 |     | <span class='unexecuted'>    bytes32 projectId = keccak256(&quot;Test Project&quot;);</span>
  73 |     | <span class='neutral'>    uint256 tokenId;</span>
  74 |     | <span class='neutral'></span>
  75 |     | <span class='unexecuted'>    function setUp() public {</span>
  76 |     | <span class='unexecuted'>        tokenId = uint256(projectId);</span>
  77 |     | <span class='neutral'></span>
  78 |     | <span class='neutral'>        // --- Deploy Infrastructure ---</span>
  79 |     | <span class='neutral'>        // Deploy payment token and mint to buyer</span>
  80 |     | <span class='unexecuted'>        paymentToken = new MockERC20(&quot;Mock Payment&quot;, &quot;MPAY&quot;, 18);</span>
  81 |     | <span class='unexecuted'>        vm.prank(address(this)); // Mint from test contract itself</span>
  82 |     | <span class='unexecuted'>        paymentToken.mint(buyer, 1_000_000 * 1e18); // 1M USDC</span>
  83 |     | <span class='neutral'></span>
  84 |     | <span class='unexecuted'>        vm.startPrank(admin);</span>
  85 |     | <span class='neutral'></span>
  86 |     | <span class='neutral'>        // 1. Deploy Registry</span>
  87 |     | <span class='unexecuted'>        ProjectRegistry registryImpl = new ProjectRegistry();</span>
  88 |     | <span class='unexecuted'>        ERC1967Proxy registryProxy =</span>
  89 |     | <span class='unexecuted'>            new ERC1967Proxy(address(registryImpl), abi.encodeCall(ProjectRegistry.initialize, ()));</span>
  90 |     | <span class='unexecuted'>        registry = ProjectRegistry(address(registryProxy));</span>
  91 |     | <span class='unexecuted'>        registry.grantRole(registry.VERIFIER_ROLE(), verifier);</span>
  92 |     | <span class='neutral'></span>
  93 |     | <span class='neutral'>        // 2. Deploy DynamicImpactCredit</span>
  94 |     | <span class='unexecuted'>        DynamicImpactCredit creditImpl = new DynamicImpactCredit(address(registry));</span>
  95 |     | <span class='unexecuted'>        credit = DynamicImpactCredit(</span>
  96 |     | <span class='neutral'>            address(</span>
  97 |     | <span class='unexecuted'>                new ERC1967Proxy(</span>
  98 |     | <span class='neutral'>                    address(creditImpl),</span>
  99 |     | <span class='unexecuted'>                    abi.encodeCall(DynamicImpactCredit.initialize, (&quot;ipfs://contract-metadata.json&quot;))</span>
 100 |     | <span class='neutral'>                )</span>
 101 |     | <span class='neutral'>            )</span>
 102 |     | <span class='neutral'>        );</span>
 103 |     | <span class='unexecuted'>        credit.grantRole(credit.DMRV_MANAGER_ROLE(), dmrvManager);</span>
 104 |     | <span class='neutral'></span>
 105 |     | <span class='neutral'>        // 3. Deploy Marketplace</span>
 106 |     | <span class='unexecuted'>        Marketplace marketplaceImpl = new Marketplace();</span>
 107 |     | <span class='unexecuted'>        ERC1967Proxy marketplaceProxy = new ERC1967Proxy(</span>
 108 |     | <span class='unexecuted'>            address(marketplaceImpl), abi.encodeCall(Marketplace.initialize, (address(credit), address(paymentToken)))</span>
 109 |     | <span class='neutral'>        );</span>
 110 |     | <span class='unexecuted'>        marketplace = Marketplace(address(marketplaceProxy));</span>
 111 |     | <span class='unexecuted'>        marketplace.setTreasury(treasury);</span>
 112 |     | <span class='unexecuted'>        marketplace.setFee(250); // Set a 2.5% fee</span>
 113 |     | <span class='neutral'></span>
 114 |     | <span class='unexecuted'>        vm.stopPrank();</span>
 115 |     | <span class='neutral'></span>
 116 |     | <span class='neutral'>        // --- Prepare for tests ---</span>
 117 |     | <span class='neutral'>        // 1. Register and activate project</span>
 118 |     | <span class='unexecuted'>        vm.prank(seller);</span>
 119 |     | <span class='unexecuted'>        registry.registerProject(projectId, &quot;ipfs://project.json&quot;);</span>
 120 |     | <span class='unexecuted'>        vm.prank(verifier);</span>
 121 |     | <span class='unexecuted'>        registry.setProjectStatus(projectId, ProjectRegistry.ProjectStatus.Active);</span>
 122 |     | <span class='neutral'></span>
 123 |     | <span class='neutral'>        // 2. Mint some credits to the seller</span>
 124 |     | <span class='unexecuted'>        vm.prank(dmrvManager);</span>
 125 |     | <span class='unexecuted'>        credit.mintCredits(seller, projectId, 1000, &quot;ipfs://credit.json&quot;);</span>
 126 |     | <span class='neutral'>    }</span>
 127 |     | <span class='neutral'></span>
 128 |     | <span class='neutral'>    // Helper to list an item</span>
 129 |     | <span class='unexecuted'>    function _list() internal returns (uint256 listingId) {</span>
 130 |     | <span class='unexecuted'>        vm.startPrank(seller);</span>
 131 |     | <span class='unexecuted'>        credit.setApprovalForAll(address(marketplace), true);</span>
 132 |     | <span class='unexecuted'>        listingId = marketplace.list(tokenId, 100, 5 * 1e6, 1 days);</span>
 133 |     | <span class='unexecuted'>        vm.stopPrank();</span>
 134 |     | <span class='neutral'>        return listingId;</span>
 135 |     | <span class='neutral'>    }</span>
 136 |     | <span class='neutral'></span>
 137 |     | <span class='neutral'>    // --- Tests ---</span>
 138 |     | <span class='neutral'></span>
 139 |     | <span class='unexecuted'>    function test_List() public {</span>
 140 |     | <span class='unexecuted'>        vm.startPrank(seller);</span>
 141 |     | <span class='unexecuted'>        credit.setApprovalForAll(address(marketplace), true);</span>
 142 |     | <span class='neutral'></span>
 143 |     | <span class='unexecuted'>        uint256 initialSellerBalance = credit.balanceOf(seller, tokenId);</span>
 144 |     | <span class='unexecuted'>        uint256 listingId = marketplace.list(tokenId, 100, 5 * 1e6, 1 days);</span>
 145 |     | <span class='unexecuted'>        vm.stopPrank();</span>
 146 |     | <span class='neutral'></span>
 147 |     | <span class='unexecuted'>        uint256 finalSellerBalance = credit.balanceOf(seller, tokenId);</span>
 148 |     | <span class='unexecuted'>        uint256 marketplaceBalance = credit.balanceOf(address(marketplace), tokenId);</span>
 149 |     | <span class='neutral'></span>
 150 |     | <span class='unexecuted'>        assertEq(initialSellerBalance - finalSellerBalance, 100, &quot;Seller should send tokens to marketplace&quot;);</span>
 151 |     | <span class='unexecuted'>        assertEq(marketplaceBalance, 100, &quot;Marketplace should receive tokens&quot;);</span>
 152 |     | <span class='neutral'></span>
 153 |     | <span class='unexecuted'>        Marketplace.Listing memory listing = marketplace.getListing(listingId);</span>
 154 |     | <span class='neutral'></span>
 155 |     | <span class='unexecuted'>        assertEq(listing.seller, seller);</span>
 156 |     | <span class='unexecuted'>        assertEq(listing.tokenId, tokenId);</span>
 157 |     | <span class='unexecuted'>        assertEq(listing.amount, 100);</span>
 158 |     | <span class='unexecuted'>        assertEq(listing.pricePerUnit, 5 * 1e6);</span>
 159 |     | <span class='unexecuted'>        assertTrue(listing.active);</span>
 160 |     | <span class='neutral'>    }</span>
 161 |     | <span class='neutral'></span>
 162 |     | <span class='unexecuted'>    function test_Buy() public {</span>
 163 |     | <span class='unexecuted'>        uint256 listingId = _list();</span>
 164 |     | <span class='unexecuted'>        uint256 amountToBuy = 50;</span>
 165 |     | <span class='unexecuted'>        uint256 pricePerUnit = 5 * 1e6;</span>
 166 |     | <span class='unexecuted'>        uint256 totalPrice = amountToBuy * pricePerUnit;</span>
 167 |     | <span class='unexecuted'>        uint256 fee = (totalPrice * 250) / 10000;</span>
 168 |     | <span class='unexecuted'>        uint256 sellerProceeds = totalPrice - fee;</span>
 169 |     | <span class='neutral'></span>
 170 |     | <span class='unexecuted'>        uint256 sellerInitialPaymentBalance = paymentToken.balanceOf(seller);</span>
 171 |     | <span class='unexecuted'>        uint256 treasuryInitialBalance = paymentToken.balanceOf(treasury);</span>
 172 |     | <span class='neutral'></span>
 173 |     | <span class='unexecuted'>        vm.prank(buyer);</span>
 174 |     | <span class='unexecuted'>        paymentToken.approve(address(marketplace), totalPrice);</span>
 175 |     | <span class='neutral'></span>
 176 |     | <span class='unexecuted'>        vm.prank(buyer);</span>
 177 |     | <span class='unexecuted'>        marketplace.buy(listingId, amountToBuy);</span>
 178 |     | <span class='neutral'></span>
 179 |     | <span class='neutral'>        // Check NFT balances</span>
 180 |     | <span class='unexecuted'>        assertEq(credit.balanceOf(address(marketplace), tokenId), 50);</span>
 181 |     | <span class='unexecuted'>        assertEq(credit.balanceOf(buyer, tokenId), amountToBuy);</span>
 182 |     | <span class='neutral'></span>
 183 |     | <span class='neutral'>        // Check payment balances</span>
 184 |     | <span class='unexecuted'>        assertEq(paymentToken.balanceOf(seller), sellerInitialPaymentBalance + sellerProceeds);</span>
 185 |     | <span class='unexecuted'>        assertEq(paymentToken.balanceOf(treasury), treasuryInitialBalance + fee);</span>
 186 |     | <span class='neutral'></span>
 187 |     | <span class='neutral'>        // Check listing state</span>
 188 |     | <span class='unexecuted'>        Marketplace.Listing memory listing = marketplace.getListing(listingId);</span>
 189 |     | <span class='unexecuted'>        assertEq(listing.amount, 100 - amountToBuy);</span>
 190 |     | <span class='unexecuted'>        assertTrue(listing.active);</span>
 191 |     | <span class='neutral'>    }</span>
 192 |     | <span class='neutral'></span>
 193 |     | <span class='unexecuted'>    function test_Buy_FullListing() public {</span>
 194 |     | <span class='unexecuted'>        uint256 listingId = _list();</span>
 195 |     | <span class='unexecuted'>        uint256 amountToBuy = 100;</span>
 196 |     | <span class='unexecuted'>        uint256 totalPrice = amountToBuy * 5 * 1e6;</span>
 197 |     | <span class='neutral'></span>
 198 |     | <span class='unexecuted'>        vm.prank(buyer);</span>
 199 |     | <span class='unexecuted'>        paymentToken.approve(address(marketplace), totalPrice);</span>
 200 |     | <span class='neutral'></span>
 201 |     | <span class='unexecuted'>        vm.prank(buyer);</span>
 202 |     | <span class='unexecuted'>        marketplace.buy(listingId, amountToBuy);</span>
 203 |     | <span class='neutral'></span>
 204 |     | <span class='unexecuted'>        Marketplace.Listing memory listing = marketplace.getListing(listingId);</span>
 205 |     | <span class='unexecuted'>        assertFalse(listing.active);</span>
 206 |     | <span class='unexecuted'>        assertEq(listing.amount, 0);</span>
 207 |     | <span class='neutral'>        assertEq(credit.balanceOf(address(marketplace), tokenId), 0);</span>
 208 |     | <span class='neutral'>    }</span>
 209 |     | <span class='neutral'></span>
 210 |     | <span class='unexecuted'>    function test_Buy_WithZeroFee() public {</span>
 211 |     | <span class='neutral'>        // --- Setup ---</span>
 212 |     | <span class='neutral'>        // Set fee to 0 to test the fee == 0 branch</span>
 213 |     | <span class='unexecuted'>        vm.prank(admin);</span>
 214 |     | <span class='unexecuted'>        marketplace.setFee(0);</span>
 215 |     | <span class='neutral'></span>
 216 |     | <span class='unexecuted'>        uint256 listingId = _list();</span>
 217 |     | <span class='unexecuted'>        uint256 amountToBuy = 50;</span>
 218 |     | <span class='unexecuted'>        uint256 pricePerUnit = 5 * 1e6;</span>
 219 |     | <span class='unexecuted'>        uint256 totalPrice = amountToBuy * pricePerUnit;</span>
 220 |     | <span class='neutral'></span>
 221 |     | <span class='unexecuted'>        uint256 sellerInitialPaymentBalance = paymentToken.balanceOf(seller);</span>
 222 |     | <span class='unexecuted'>        uint256 treasuryInitialBalance = paymentToken.balanceOf(treasury);</span>
 223 |     | <span class='neutral'></span>
 224 |     | <span class='neutral'>        // --- Action ---</span>
 225 |     | <span class='unexecuted'>        vm.prank(buyer);</span>
 226 |     | <span class='unexecuted'>        paymentToken.approve(address(marketplace), totalPrice);</span>
 227 |     | <span class='neutral'></span>
 228 |     | <span class='unexecuted'>        vm.prank(buyer);</span>
 229 |     | <span class='unexecuted'>        marketplace.buy(listingId, amountToBuy);</span>
 230 |     | <span class='neutral'></span>
 231 |     | <span class='neutral'>        // --- Assertions ---</span>
 232 |     | <span class='neutral'>        // Check NFT balances</span>
 233 |     | <span class='unexecuted'>        assertEq(credit.balanceOf(buyer, tokenId), amountToBuy, &quot;Buyer should receive the NFTs&quot;);</span>
 234 |     | <span class='neutral'></span>
 235 |     | <span class='neutral'>        // Check payment balances: Seller gets full amount, treasury gets nothing</span>
 236 |     | <span class='unexecuted'>        assertEq(</span>
 237 |     | <span class='unexecuted'>            paymentToken.balanceOf(seller),</span>
 238 |     | <span class='unexecuted'>            sellerInitialPaymentBalance + totalPrice,</span>
 239 |     | <span class='neutral'>            &quot;Seller should receive full payment when fee is zero&quot;</span>
 240 |     | <span class='neutral'>        );</span>
 241 |     | <span class='unexecuted'>        assertEq(</span>
 242 |     | <span class='unexecuted'>            paymentToken.balanceOf(treasury),</span>
 243 |     | <span class='unexecuted'>            treasuryInitialBalance,</span>
 244 |     | <span class='neutral'>            &quot;Treasury balance should not change when fee is zero&quot;</span>
 245 |     | <span class='neutral'>        );</span>
 246 |     | <span class='neutral'>    }</span>
 247 |     | <span class='neutral'></span>
 248 |     | <span class='unexecuted'>    function test_CancelListing() public {</span>
 249 |     | <span class='unexecuted'>        uint256 listingId = _list();</span>
 250 |     | <span class='unexecuted'>        uint256 sellerInitialBalance = credit.balanceOf(seller, tokenId);</span>
 251 |     | <span class='unexecuted'>        uint256 marketplaceBalance = credit.balanceOf(address(marketplace), tokenId);</span>
 252 |     | <span class='unexecuted'>        assertEq(marketplaceBalance, 100);</span>
 253 |     | <span class='neutral'></span>
 254 |     | <span class='unexecuted'>        vm.prank(seller);</span>
 255 |     | <span class='unexecuted'>        marketplace.cancelListing(listingId);</span>
 256 |     | <span class='neutral'></span>
 257 |     | <span class='unexecuted'>        Marketplace.Listing memory listing = marketplace.getListing(listingId);</span>
 258 |     | <span class='unexecuted'>        assertFalse(listing.active);</span>
 259 |     | <span class='unexecuted'>        assertEq(credit.balanceOf(seller, tokenId), sellerInitialBalance + 100);</span>
 260 |     | <span class='unexecuted'>        assertEq(credit.balanceOf(address(marketplace), tokenId), 0);</span>
 261 |     | <span class='neutral'>    }</span>
 262 |     | <span class='neutral'></span>
 263 |     | <span class='unexecuted'>    function test_CancelExpiredListing() public {</span>
 264 |     | <span class='unexecuted'>        uint256 listingId = _list(); // Lists with 1 day expiry</span>
 265 |     | <span class='unexecuted'>        uint256 sellerInitialBalance = credit.balanceOf(seller, tokenId);</span>
 266 |     | <span class='neutral'></span>
 267 |     | <span class='neutral'>        // Fast-forward time past the expiry</span>
 268 |     | <span class='unexecuted'>        vm.warp(block.timestamp + 2 days);</span>
 269 |     | <span class='neutral'></span>
 270 |     | <span class='neutral'>        // Anyone can cancel an expired listing</span>
 271 |     | <span class='unexecuted'>        vm.prank(buyer);</span>
 272 |     | <span class='unexecuted'>        marketplace.cancelExpiredListing(listingId);</span>
 273 |     | <span class='neutral'></span>
 274 |     | <span class='neutral'>        // Check listing is inactive and seller got their tokens back</span>
 275 |     | <span class='unexecuted'>        Marketplace.Listing memory listing = marketplace.getListing(listingId);</span>
 276 |     | <span class='unexecuted'>        assertFalse(listing.active);</span>
 277 |     | <span class='unexecuted'>        assertEq(credit.balanceOf(seller, tokenId), sellerInitialBalance + 100);</span>
 278 |     | <span class='unexecuted'>        assertEq(credit.balanceOf(address(marketplace), tokenId), 0);</span>
 279 |     | <span class='neutral'>    }</span>
 280 |     | <span class='neutral'></span>
 281 |     | <span class='unexecuted'>    function test_Fail_CancelExpiredOnNonExpiredListing() public {</span>
 282 |     | <span class='unexecuted'>        uint256 listingId = _list(); // Lists with 1 day expiry</span>
 283 |     | <span class='neutral'></span>
 284 |     | <span class='neutral'>        // Try to cancel immediately</span>
 285 |     | <span class='unexecuted'>        vm.prank(buyer);</span>
 286 |     | <span class='unexecuted'>        vm.expectRevert(Marketplace__ListingNotExpired.selector);</span>
 287 |     | <span class='unexecuted'>        marketplace.cancelExpiredListing(listingId);</span>
 288 |     | <span class='neutral'>    }</span>
 289 |     | <span class='neutral'></span>
 290 |     | <span class='unexecuted'>    function test_UpdateListingPrice() public {</span>
 291 |     | <span class='unexecuted'>        uint256 listingId = _list();</span>
 292 |     | <span class='unexecuted'>        uint256 newPrice = 10 * 1e6;</span>
 293 |     | <span class='neutral'></span>
 294 |     | <span class='unexecuted'>        vm.prank(seller);</span>
 295 |     | <span class='unexecuted'>        marketplace.updateListingPrice(listingId, newPrice);</span>
 296 |     | <span class='neutral'></span>
 297 |     | <span class='unexecuted'>        Marketplace.Listing memory listing = marketplace.getListing(listingId);</span>
 298 |     | <span class='unexecuted'>        assertEq(listing.pricePerUnit, newPrice);</span>
 299 |     | <span class='neutral'>    }</span>
 300 |     | <span class='neutral'></span>
 301 |     | <span class='unexecuted'>    function test_Fail_UpdateListingPrice_NotSeller() public {</span>
 302 |     | <span class='unexecuted'>        uint256 listingId = _list();</span>
 303 |     | <span class='neutral'></span>
 304 |     | <span class='unexecuted'>        vm.prank(buyer); // Use a different user</span>
 305 |     | <span class='unexecuted'>        vm.expectRevert(Marketplace__NotTheSeller.selector);</span>
 306 |     | <span class='neutral'>        marketplace.updateListingPrice(listingId, 10 * 1e6);</span>
 307 |     | <span class='neutral'>    }</span>
 308 |     | <span class='neutral'></span>
 309 |     | <span class='unexecuted'>    function test_Fail_UpdateListingPrice_InactiveListing() public {</span>
 310 |     | <span class='unexecuted'>        uint256 listingId = _list();</span>
 311 |     | <span class='neutral'></span>
 312 |     | <span class='neutral'>        // Cancel the listing to make it inactive</span>
 313 |     | <span class='unexecuted'>        vm.prank(seller);</span>
 314 |     | <span class='unexecuted'>        marketplace.cancelListing(listingId);</span>
 315 |     | <span class='neutral'></span>
 316 |     | <span class='neutral'>        // Try to update the price</span>
 317 |     | <span class='unexecuted'>        vm.prank(seller);</span>
 318 |     | <span class='unexecuted'>        vm.expectRevert(Marketplace__ListingNotActive.selector);</span>
 319 |     | <span class='unexecuted'>        marketplace.updateListingPrice(listingId, 10 * 1e6);</span>
 320 |     | <span class='neutral'>    }</span>
 321 |     | <span class='neutral'></span>
 322 |     | <span class='unexecuted'>    function test_Fail_UpdateListingPrice_ZeroPrice() public {</span>
 323 |     | <span class='unexecuted'>        uint256 listingId = _list();</span>
 324 |     | <span class='neutral'></span>
 325 |     | <span class='unexecuted'>        vm.prank(seller);</span>
 326 |     | <span class='unexecuted'>        vm.expectRevert(Marketplace__ZeroPrice.selector);</span>
 327 |     | <span class='unexecuted'>        marketplace.updateListingPrice(listingId, 0);</span>
 328 |     | <span class='neutral'>    }</span>
 329 |     | <span class='neutral'></span>
 330 |     | <span class='unexecuted'>    function test_Fail_SetTreasury_ToZeroAddress() public {</span>
 331 |     | <span class='unexecuted'>        vm.prank(admin);</span>
 332 |     | <span class='unexecuted'>        vm.expectRevert(Marketplace__TreasuryAddressZero.selector);</span>
 333 |     | <span class='unexecuted'>        marketplace.setTreasury(address(0));</span>
 334 |     | <span class='neutral'>    }</span>
 335 |     | <span class='neutral'></span>
 336 |     | <span class='unexecuted'>    function test_Fail_SetFee_AboveCap() public {</span>
 337 |     | <span class='unexecuted'>        vm.prank(admin);</span>
 338 |     | <span class='unexecuted'>        vm.expectRevert(Marketplace__FeeTooHigh.selector);</span>
 339 |     | <span class='unexecuted'>        marketplace.setFee(10001); // 100.01%</span>
 340 |     | <span class='neutral'>    }</span>
 341 |     | <span class='neutral'></span>
 342 |     | <span class='unexecuted'>    function test_Fail_ListWithZeroAmount() public {</span>
 343 |     | <span class='unexecuted'>        vm.expectRevert(Marketplace__ZeroAmount.selector);</span>
 344 |     | <span class='unexecuted'>        vm.prank(seller);</span>
 345 |     | <span class='unexecuted'>        marketplace.list(tokenId, 0, 5 * 1e6, 1 days);</span>
 346 |     | <span class='neutral'>    }</span>
 347 |     | <span class='neutral'></span>
 348 |     | <span class='unexecuted'>    function test_Fail_ListWithZeroPrice() public {</span>
 349 |     | <span class='unexecuted'>        vm.expectRevert(Marketplace__ZeroPrice.selector);</span>
 350 |     | <span class='unexecuted'>        vm.prank(seller);</span>
 351 |     | <span class='unexecuted'>        marketplace.list(tokenId, 100, 0, 1 days);</span>
 352 |     | <span class='neutral'>    }</span>
 353 |     | <span class='neutral'></span>
 354 |     | <span class='unexecuted'>    function test_Fail_ListWithZeroExpiry() public {</span>
 355 |     | <span class='unexecuted'>        vm.expectRevert(Marketplace__ZeroExpiry.selector);</span>
 356 |     | <span class='unexecuted'>        vm.prank(seller);</span>
 357 |     | <span class='unexecuted'>        marketplace.list(tokenId, 100, 5 * 1e6, 0);</span>
 358 |     | <span class='neutral'>    }</span>
 359 |     | <span class='neutral'></span>
 360 |     | <span class='unexecuted'>    function test_Fail_BuyExpiredListing() public {</span>
 361 |     | <span class='unexecuted'>        uint256 listingId = _list(); // Lists with 1 day expiry</span>
 362 |     | <span class='neutral'></span>
 363 |     | <span class='neutral'>        // Fast-forward time past the expiry</span>
 364 |     | <span class='unexecuted'>        vm.warp(block.timestamp + 2 days);</span>
 365 |     | <span class='neutral'></span>
 366 |     | <span class='unexecuted'>        vm.prank(buyer);</span>
 367 |     | <span class='unexecuted'>        vm.expectRevert(Marketplace__ListingExpired.selector);</span>
 368 |     | <span class='unexecuted'>        marketplace.buy(listingId, 10);</span>
 369 |     | <span class='neutral'>    }</span>
 370 |     | <span class='neutral'></span>
 371 |     | <span class='unexecuted'>    function test_Fail_BuyZeroAmount() public {</span>
 372 |     | <span class='unexecuted'>        uint256 listingId = _list();</span>
 373 |     | <span class='unexecuted'>        vm.prank(buyer);</span>
 374 |     | <span class='unexecuted'>        vm.expectRevert(Marketplace__ZeroAmount.selector);</span>
 375 |     | <span class='unexecuted'>        marketplace.buy(listingId, 0);</span>
 376 |     | <span class='neutral'>    }</span>
 377 |     | <span class='neutral'></span>
 378 |     | <span class='unexecuted'>    function test_Fail_BuyMoreThanListed() public {</span>
 379 |     | <span class='unexecuted'>        uint256 listingId = _list(); // Lists 100 items</span>
 380 |     | <span class='unexecuted'>        vm.prank(buyer);</span>
 381 |     | <span class='unexecuted'>        vm.expectRevert(Marketplace__NotEnoughItemsInListing.selector);</span>
 382 |     | <span class='unexecuted'>        marketplace.buy(listingId, 101);</span>
 383 |     | <span class='neutral'>    }</span>
 384 |     | <span class='neutral'></span>
 385 |     | <span class='neutral'>    /* ---------- Event Tests ---------- */</span>
 386 |     | <span class='neutral'></span>
 387 |     | <span class='unexecuted'>    function test_EmitFeePaidEvent() public {</span>
 388 |     | <span class='unexecuted'>        uint256 listingId = _list();</span>
 389 |     | <span class='unexecuted'>        uint256 amountToBuy = 50;</span>
 390 |     | <span class='unexecuted'>        uint256 totalPrice = amountToBuy * 5 * 1e6;</span>
 391 |     | <span class='unexecuted'>        uint256 fee = (totalPrice * 250) / 10000;</span>
 392 |     | <span class='neutral'></span>
 393 |     | <span class='unexecuted'>        vm.prank(buyer);</span>
 394 |     | <span class='unexecuted'>        paymentToken.approve(address(marketplace), totalPrice);</span>
 395 |     | <span class='neutral'></span>
 396 |     | <span class='unexecuted'>        vm.expectEmit(true, true, true, true);</span>
 397 |     | <span class='unexecuted'>        emit Marketplace.FeePaid(treasury, fee);</span>
 398 |     | <span class='neutral'></span>
 399 |     | <span class='unexecuted'>        vm.prank(buyer);</span>
 400 |     | <span class='unexecuted'>        marketplace.buy(listingId, amountToBuy);</span>
 401 |     | <span class='neutral'>    }</span>
 402 |     | <span class='neutral'></span>
 403 |     | <span class='neutral'>    /* ---------- Access Control &amp; Failure Tests ---------- */</span>
 404 |     | <span class='neutral'></span>
 405 |     | <span class='unexecuted'>    function test_Fail_ListWithoutApproval() public {</span>
 406 |     | <span class='unexecuted'>        vm.expectRevert(); // ERC1155: insufficient balance for transfer</span>
 407 |     | <span class='unexecuted'>        vm.startPrank(seller);</span>
 408 |     | <span class='unexecuted'>        marketplace.list(tokenId, 100, 5 * 1e6, 1 days);</span>
 409 |     | <span class='unexecuted'>        vm.stopPrank();</span>
 410 |     | <span class='neutral'>    }</span>
 411 |     | <span class='neutral'></span>
 412 |     | <span class='unexecuted'>    function test_Fail_BuyWithInsufficientPayment() public {</span>
 413 |     | <span class='unexecuted'>        uint256 listingId = _list();</span>
 414 |     | <span class='neutral'></span>
 415 |     | <span class='unexecuted'>        vm.prank(buyer);</span>
 416 |     | <span class='neutral'>        // Approve less than required</span>
 417 |     | <span class='unexecuted'>        paymentToken.approve(address(marketplace), 10 * 1e6);</span>
 418 |     | <span class='neutral'></span>
 419 |     | <span class='unexecuted'>        vm.prank(buyer);</span>
 420 |     | <span class='unexecuted'>        vm.expectRevert(&quot;ERC20: insufficient allowance&quot;);</span>
 421 |     | <span class='unexecuted'>        marketplace.buy(listingId, 50);</span>
 422 |     | <span class='neutral'>    }</span>
 423 |     | <span class='neutral'></span>
 424 |     | <span class='unexecuted'>    function test_Fail_NonSellerCannotCancel() public {</span>
 425 |     | <span class='unexecuted'>        uint256 listingId = _list();</span>
 426 |     | <span class='unexecuted'>        vm.prank(buyer);</span>
 427 |     | <span class='unexecuted'>        vm.expectRevert(Marketplace__NotTheSeller.selector);</span>
 428 |     | <span class='unexecuted'>        marketplace.cancelListing(listingId);</span>
 429 |     | <span class='neutral'>    }</span>
 430 |     | <span class='neutral'></span>
 431 |     | <span class='unexecuted'>    function test_Fail_BuyWithInsufficientBalance() public {</span>
 432 |     | <span class='unexecuted'>        uint256 listingId = _list();</span>
 433 |     | <span class='unexecuted'>        uint256 amountToBuy = 50;</span>
 434 |     | <span class='unexecuted'>        uint256 pricePerUnit = 5 * 1e6;</span>
 435 |     | <span class='unexecuted'>        uint256 totalPrice = amountToBuy * pricePerUnit;</span>
 436 |     | <span class='neutral'></span>
 437 |     | <span class='unexecuted'>        address brokeBuyer = address(0xDEAD);</span>
 438 |     | <span class='neutral'></span>
 439 |     | <span class='unexecuted'>        vm.prank(brokeBuyer);</span>
 440 |     | <span class='unexecuted'>        paymentToken.approve(address(marketplace), totalPrice);</span>
 441 |     | <span class='neutral'></span>
 442 |     | <span class='unexecuted'>        vm.prank(brokeBuyer);</span>
 443 |     | <span class='neutral'>        // The Marketplace contract has its own balance check that runs before the ERC20 transfer.</span>
 444 |     | <span class='unexecuted'>        vm.expectRevert(Marketplace__InsufficientBalance.selector);</span>
 445 |     | <span class='unexecuted'>        marketplace.buy(listingId, amountToBuy);</span>
 446 |     | <span class='neutral'>    }</span>
 447 |     | <span class='neutral'></span>
 448 |     | <span class='unexecuted'>    function test_Fail_GetNonExistentListing() public {</span>
 449 |     | <span class='unexecuted'>        vm.expectRevert(Marketplace__ListingNotFound.selector);</span>
 450 |     | <span class='unexecuted'>        marketplace.getListing(999);</span>
 451 |     | <span class='neutral'>    }</span>
 452 |     | <span class='neutral'></span>
 453 |     | <span class='neutral'>    /* ---------- Pausable Tests ---------- */</span>
 454 |     | <span class='neutral'></span>
 455 |     | <span class='unexecuted'>    function test_PauseAndUnpause() public {</span>
 456 |     | <span class='unexecuted'>        bytes32 pauserRole = marketplace.PAUSER_ROLE();</span>
 457 |     | <span class='neutral'></span>
 458 |     | <span class='unexecuted'>        vm.startPrank(admin);</span>
 459 |     | <span class='neutral'>        // Admin can pause and unpause</span>
 460 |     | <span class='unexecuted'>        marketplace.pause();</span>
 461 |     | <span class='unexecuted'>        assertTrue(marketplace.paused());</span>
 462 |     | <span class='unexecuted'>        marketplace.unpause();</span>
 463 |     | <span class='unexecuted'>        assertFalse(marketplace.paused());</span>
 464 |     | <span class='unexecuted'>        vm.stopPrank();</span>
 465 |     | <span class='neutral'></span>
 466 |     | <span class='neutral'>        // Non-pauser cannot pause</span>
 467 |     | <span class='unexecuted'>        vm.prank(seller);</span>
 468 |     | <span class='unexecuted'>        vm.expectRevert(</span>
 469 |     | <span class='unexecuted'>            abi.encodeWithSelector(</span>
 470 |     | <span class='unexecuted'>                bytes4(keccak256(&quot;AccessControlUnauthorizedAccount(address,bytes32)&quot;)), seller, pauserRole</span>
 471 |     | <span class='neutral'>            )</span>
 472 |     | <span class='neutral'>        );</span>
 473 |     | <span class='unexecuted'>        marketplace.pause();</span>
 474 |     | <span class='neutral'>    }</span>
 475 |     | <span class='neutral'></span>
 476 |     | <span class='unexecuted'>    function test_RevertsWhenPaused() public {</span>
 477 |     | <span class='unexecuted'>        uint256 listingId = _list();</span>
 478 |     | <span class='neutral'></span>
 479 |     | <span class='unexecuted'>        vm.startPrank(admin);</span>
 480 |     | <span class='unexecuted'>        marketplace.pause();</span>
 481 |     | <span class='unexecuted'>        vm.stopPrank();</span>
 482 |     | <span class='neutral'></span>
 483 |     | <span class='neutral'>        // Check key functions revert when paused</span>
 484 |     | <span class='unexecuted'>        bytes4 expectedRevert = bytes4(keccak256(&quot;EnforcedPause()&quot;));</span>
 485 |     | <span class='neutral'></span>
 486 |     | <span class='unexecuted'>        vm.prank(seller);</span>
 487 |     | <span class='unexecuted'>        vm.expectRevert(expectedRevert);</span>
 488 |     | <span class='unexecuted'>        marketplace.list(tokenId, 10, 1e6, 1 days);</span>
 489 |     | <span class='neutral'></span>
 490 |     | <span class='unexecuted'>        vm.prank(buyer);</span>
 491 |     | <span class='unexecuted'>        vm.expectRevert(expectedRevert);</span>
 492 |     | <span class='unexecuted'>        marketplace.buy(listingId, 1);</span>
 493 |     | <span class='neutral'></span>
 494 |     | <span class='unexecuted'>        vm.prank(seller);</span>
 495 |     | <span class='unexecuted'>        vm.expectRevert(expectedRevert);</span>
 496 |     | <span class='unexecuted'>        marketplace.cancelListing(listingId);</span>
 497 |     | <span class='neutral'></span>
 498 |     | <span class='unexecuted'>        vm.prank(seller);</span>
 499 |     | <span class='unexecuted'>        vm.expectRevert(expectedRevert);</span>
 500 |     | <span class='unexecuted'>        marketplace.updateListingPrice(listingId, 6e6);</span>
 501 |     | <span class='neutral'>    }</span>
 502 |     | <span class='neutral'>}</span>
 503 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/phantom/Documents/azemora/azemora-contracts/test/projectRegistry/ProjectRegistry.t.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'>pragma solidity ^0.8.20;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>import &quot;forge-std/Test.sol&quot;;</span>
   5 |     | <span class='neutral'>import &quot;../../src/core/ProjectRegistry.sol&quot;;</span>
   6 |     | <span class='neutral'>import &quot;@openzeppelin/contracts/proxy/ERC1967/ERC1967Proxy.sol&quot;;</span>
   7 |     | <span class='neutral'></span>
   8 |     | <span class='unexecuted'>contract ProjectRegistryTest is Test {</span>
   9 |     | <span class='neutral'>    ProjectRegistry registry;</span>
  10 |     | <span class='neutral'></span>
  11 |     | <span class='unexecuted'>    address admin = address(0xA11CE);</span>
  12 |     | <span class='unexecuted'>    address verifier = address(0xC1E4);</span>
  13 |     | <span class='unexecuted'>    address projectOwner = address(0x044E);</span>
  14 |     | <span class='unexecuted'>    address anotherUser = address(0xBEEF);</span>
  15 |     | <span class='neutral'></span>
  16 |     | <span class='unexecuted'>    bytes32 projectId = keccak256(&quot;Test Project&quot;);</span>
  17 |     | <span class='neutral'></span>
  18 |     | <span class='unexecuted'>    function setUp() public {</span>
  19 |     | <span class='unexecuted'>        vm.startPrank(admin);</span>
  20 |     | <span class='unexecuted'>        ProjectRegistry registryImpl = new ProjectRegistry();</span>
  21 |     | <span class='unexecuted'>        bytes memory registryInitData = abi.encodeCall(ProjectRegistry.initialize, ());</span>
  22 |     | <span class='unexecuted'>        ERC1967Proxy registryProxy = new ERC1967Proxy(address(registryImpl), registryInitData);</span>
  23 |     | <span class='unexecuted'>        registry = ProjectRegistry(address(registryProxy));</span>
  24 |     | <span class='neutral'></span>
  25 |     | <span class='neutral'>        // Grant verifier role</span>
  26 |     | <span class='unexecuted'>        registry.grantRole(registry.VERIFIER_ROLE(), verifier);</span>
  27 |     | <span class='unexecuted'>        vm.stopPrank();</span>
  28 |     | <span class='neutral'></span>
  29 |     | <span class='neutral'>        // Register a project for testing state-changing functions</span>
  30 |     | <span class='unexecuted'>        vm.prank(projectOwner);</span>
  31 |     | <span class='unexecuted'>        registry.registerProject(projectId, &quot;ipfs://initial.json&quot;);</span>
  32 |     | <span class='neutral'>    }</span>
  33 |     | <span class='neutral'></span>
  34 |     | <span class='neutral'>    /* ----------------- */</span>
  35 |     | <span class='neutral'>    /*     Registration  */</span>
  36 |     | <span class='neutral'>    /* ----------------- */</span>
  37 |     | <span class='neutral'></span>
  38 |     | <span class='unexecuted'>    function test_Register_WritesStructAndEmitsEvent() public {</span>
  39 |     | <span class='unexecuted'>        bytes32 newId = keccak256(&quot;New Project&quot;);</span>
  40 |     | <span class='unexecuted'>        string memory uri = &quot;ipfs://new.json&quot;;</span>
  41 |     | <span class='neutral'></span>
  42 |     | <span class='unexecuted'>        vm.prank(anotherUser);</span>
  43 |     | <span class='unexecuted'>        vm.expectEmit(true, true, true, true, address(registry));</span>
  44 |     | <span class='unexecuted'>        emit ProjectRegistry.ProjectRegistered(newId, anotherUser, uri);</span>
  45 |     | <span class='unexecuted'>        registry.registerProject(newId, uri);</span>
  46 |     | <span class='neutral'></span>
  47 |     | <span class='unexecuted'>        ProjectRegistry.Project memory project = registry.getProject(newId);</span>
  48 |     | <span class='unexecuted'>        assertEq(project.id, newId);</span>
  49 |     | <span class='unexecuted'>        assertEq(project.owner, anotherUser);</span>
  50 |     | <span class='unexecuted'>        assertEq(uint8(project.status), uint8(ProjectRegistry.ProjectStatus.Pending));</span>
  51 |     | <span class='unexecuted'>        assertEq(project.metaURI, uri);</span>
  52 |     | <span class='neutral'>    }</span>
  53 |     | <span class='neutral'></span>
  54 |     | <span class='unexecuted'>    function test_Register_RevertsOnDuplicateId() public {</span>
  55 |     | <span class='unexecuted'>        vm.prank(anotherUser);</span>
  56 |     | <span class='unexecuted'>        vm.expectRevert(ProjectRegistry__IdAlreadyExists.selector);</span>
  57 |     | <span class='unexecuted'>        registry.registerProject(projectId, &quot;ipfs://duplicate.json&quot;);</span>
  58 |     | <span class='neutral'>    }</span>
  59 |     | <span class='neutral'></span>
  60 |     | <span class='neutral'>    /* ----------------- */</span>
  61 |     | <span class='neutral'>    /*    Status Changes */</span>
  62 |     | <span class='neutral'>    /* ----------------- */</span>
  63 |     | <span class='neutral'></span>
  64 |     | <span class='unexecuted'>    function test_SetStatus_VerifierCanApprove() public {</span>
  65 |     | <span class='unexecuted'>        vm.prank(verifier);</span>
  66 |     | <span class='unexecuted'>        vm.expectEmit(true, true, true, true, address(registry));</span>
  67 |     | <span class='unexecuted'>        emit ProjectRegistry.ProjectStatusChanged(</span>
  68 |     | <span class='unexecuted'>            projectId, ProjectRegistry.ProjectStatus.Pending, ProjectRegistry.ProjectStatus.Active</span>
  69 |     | <span class='neutral'>        );</span>
  70 |     | <span class='unexecuted'>        registry.setProjectStatus(projectId, ProjectRegistry.ProjectStatus.Active);</span>
  71 |     | <span class='unexecuted'>        assertTrue(registry.isProjectActive(projectId));</span>
  72 |     | <span class='neutral'>    }</span>
  73 |     | <span class='neutral'></span>
  74 |     | <span class='unexecuted'>    function test_SetStatus_AdminCanPauseAndArchive() public {</span>
  75 |     | <span class='neutral'>        // First, activate the project</span>
  76 |     | <span class='unexecuted'>        vm.prank(verifier);</span>
  77 |     | <span class='unexecuted'>        registry.setProjectStatus(projectId, ProjectRegistry.ProjectStatus.Active);</span>
  78 |     | <span class='neutral'></span>
  79 |     | <span class='neutral'>        // Then, admin can pause it</span>
  80 |     | <span class='unexecuted'>        vm.startPrank(admin);</span>
  81 |     | <span class='unexecuted'>        vm.expectEmit(true, true, true, true, address(registry));</span>
  82 |     | <span class='unexecuted'>        emit ProjectRegistry.ProjectStatusChanged(</span>
  83 |     | <span class='unexecuted'>            projectId, ProjectRegistry.ProjectStatus.Active, ProjectRegistry.ProjectStatus.Paused</span>
  84 |     | <span class='neutral'>        );</span>
  85 |     | <span class='unexecuted'>        registry.setProjectStatus(projectId, ProjectRegistry.ProjectStatus.Paused);</span>
  86 |     | <span class='unexecuted'>        assertEq(uint8(registry.getProject(projectId).status), uint8(ProjectRegistry.ProjectStatus.Paused));</span>
  87 |     | <span class='neutral'></span>
  88 |     | <span class='neutral'>        // And admin can archive it</span>
  89 |     | <span class='unexecuted'>        vm.expectEmit(true, true, true, true, address(registry));</span>
  90 |     | <span class='unexecuted'>        emit ProjectRegistry.ProjectStatusChanged(</span>
  91 |     | <span class='unexecuted'>            projectId, ProjectRegistry.ProjectStatus.Paused, ProjectRegistry.ProjectStatus.Archived</span>
  92 |     | <span class='neutral'>        );</span>
  93 |     | <span class='unexecuted'>        registry.setProjectStatus(projectId, ProjectRegistry.ProjectStatus.Archived);</span>
  94 |     | <span class='unexecuted'>        vm.stopPrank();</span>
  95 |     | <span class='neutral'></span>
  96 |     | <span class='unexecuted'>        assertEq(uint8(registry.getProject(projectId).status), uint8(ProjectRegistry.ProjectStatus.Archived));</span>
  97 |     | <span class='unexecuted'>        assertFalse(registry.isProjectActive(projectId));</span>
  98 |     | <span class='neutral'>    }</span>
  99 |     | <span class='neutral'></span>
 100 |     | <span class='unexecuted'>    function test_SetStatus_RevertsForNonVerifier() public {</span>
 101 |     | <span class='unexecuted'>        vm.prank(anotherUser);</span>
 102 |     | <span class='unexecuted'>        vm.expectRevert(ProjectRegistry__CallerNotVerifier.selector);</span>
 103 |     | <span class='unexecuted'>        registry.setProjectStatus(projectId, ProjectRegistry.ProjectStatus.Active);</span>
 104 |     | <span class='neutral'>    }</span>
 105 |     | <span class='neutral'></span>
 106 |     | <span class='unexecuted'>    function test_SetStatus_RevertsForNonAdmin() public {</span>
 107 |     | <span class='unexecuted'>        vm.prank(anotherUser);</span>
 108 |     | <span class='unexecuted'>        vm.expectRevert(ProjectRegistry__CallerNotAdmin.selector);</span>
 109 |     | <span class='unexecuted'>        registry.setProjectStatus(projectId, ProjectRegistry.ProjectStatus.Paused);</span>
 110 |     | <span class='neutral'></span>
 111 |     | <span class='unexecuted'>        vm.expectRevert(ProjectRegistry__CallerNotAdmin.selector);</span>
 112 |     | <span class='unexecuted'>        registry.setProjectStatus(projectId, ProjectRegistry.ProjectStatus.Archived);</span>
 113 |     | <span class='neutral'>    }</span>
 114 |     | <span class='neutral'></span>
 115 |     | <span class='unexecuted'>    function test_SetStatus_RevertsOnInvalidTransition() public {</span>
 116 |     | <span class='neutral'>        // an already pending project cannot be set to pending again</span>
 117 |     | <span class='unexecuted'>        vm.prank(admin);</span>
 118 |     | <span class='unexecuted'>        vm.expectRevert(ProjectRegistry__StatusIsSame.selector);</span>
 119 |     | <span class='unexecuted'>        registry.setProjectStatus(projectId, ProjectRegistry.ProjectStatus.Pending);</span>
 120 |     | <span class='neutral'>    }</span>
 121 |     | <span class='neutral'></span>
 122 |     | <span class='unexecuted'>    function test_SetStatus_RevertsOnArchivedProject() public {</span>
 123 |     | <span class='neutral'>        // first, archive it</span>
 124 |     | <span class='unexecuted'>        vm.prank(verifier);</span>
 125 |     | <span class='unexecuted'>        registry.setProjectStatus(projectId, ProjectRegistry.ProjectStatus.Active);</span>
 126 |     | <span class='unexecuted'>        vm.prank(admin);</span>
 127 |     | <span class='unexecuted'>        registry.setProjectStatus(projectId, ProjectRegistry.ProjectStatus.Archived);</span>
 128 |     | <span class='neutral'></span>
 129 |     | <span class='neutral'>        // then, try to change it</span>
 130 |     | <span class='unexecuted'>        vm.prank(admin);</span>
 131 |     | <span class='unexecuted'>        vm.expectRevert(ProjectRegistry__ArchivedProjectCannotBeModified.selector);</span>
 132 |     | <span class='neutral'>        registry.setProjectStatus(projectId, ProjectRegistry.ProjectStatus.Paused);</span>
 133 |     | <span class='neutral'>    }</span>
 134 |     | <span class='neutral'></span>
 135 |     | <span class='unexecuted'>    function test_SetStatus_RevertsOnNonExistentProject() public {</span>
 136 |     | <span class='unexecuted'>        vm.prank(verifier);</span>
 137 |     | <span class='unexecuted'>        vm.expectRevert(ProjectRegistry__ProjectNotFound.selector);</span>
 138 |     | <span class='unexecuted'>        registry.setProjectStatus(bytes32(uint256(420)), ProjectRegistry.ProjectStatus.Active);</span>
 139 |     | <span class='neutral'>    }</span>
 140 |     | <span class='neutral'></span>
 141 |     | <span class='unexecuted'>    function test_SetStatus_RevertsOnInvalidTransitionToPaused() public {</span>
 142 |     | <span class='neutral'>        // cannot pause from pending</span>
 143 |     | <span class='unexecuted'>        vm.prank(admin);</span>
 144 |     | <span class='unexecuted'>        vm.expectRevert(ProjectRegistry__InvalidPauseState.selector);</span>
 145 |     | <span class='unexecuted'>        registry.setProjectStatus(projectId, ProjectRegistry.ProjectStatus.Paused);</span>
 146 |     | <span class='neutral'>    }</span>
 147 |     | <span class='neutral'></span>
 148 |     | <span class='unexecuted'>    function test_SetStatus_RevertsOnInvalidTransitionToPending() public {</span>
 149 |     | <span class='neutral'>        // cannot transition to pending from any other state</span>
 150 |     | <span class='unexecuted'>        vm.prank(verifier);</span>
 151 |     | <span class='unexecuted'>        registry.setProjectStatus(projectId, ProjectRegistry.ProjectStatus.Active);</span>
 152 |     | <span class='unexecuted'>        vm.prank(admin);</span>
 153 |     | <span class='unexecuted'>        vm.expectRevert(ProjectRegistry__InvalidStatusTransition.selector);</span>
 154 |     | <span class='neutral'>        registry.setProjectStatus(projectId, ProjectRegistry.ProjectStatus.Pending);</span>
 155 |     | <span class='neutral'>    }</span>
 156 |     | <span class='neutral'></span>
 157 |     | <span class='neutral'>    /* ----------------- */</span>
 158 |     | <span class='neutral'>    /*     Ownership     */</span>
 159 |     | <span class='neutral'>    /* ----------------- */</span>
 160 |     | <span class='neutral'></span>
 161 |     | <span class='unexecuted'>    function test_SetProjectMetaURI_OnlyOwnerCanUpdate() public {</span>
 162 |     | <span class='unexecuted'>        string memory newURI = &quot;ipfs://updated.json&quot;;</span>
 163 |     | <span class='neutral'></span>
 164 |     | <span class='neutral'>        // Owner should succeed</span>
 165 |     | <span class='unexecuted'>        vm.prank(projectOwner);</span>
 166 |     | <span class='unexecuted'>        vm.expectEmit(true, true, true, true, address(registry));</span>
 167 |     | <span class='unexecuted'>        emit ProjectRegistry.ProjectMetaURIUpdated(projectId, newURI);</span>
 168 |     | <span class='unexecuted'>        registry.setProjectMetaURI(projectId, newURI);</span>
 169 |     | <span class='unexecuted'>        assertEq(registry.getProject(projectId).metaURI, newURI);</span>
 170 |     | <span class='neutral'></span>
 171 |     | <span class='neutral'>        // Others should fail</span>
 172 |     | <span class='unexecuted'>        vm.prank(anotherUser);</span>
 173 |     | <span class='unexecuted'>        vm.expectRevert(ProjectRegistry__NotProjectOwner.selector);</span>
 174 |     | <span class='unexecuted'>        registry.setProjectMetaURI(projectId, &quot;ipfs://fail.json&quot;);</span>
 175 |     | <span class='neutral'>    }</span>
 176 |     | <span class='neutral'></span>
 177 |     | <span class='unexecuted'>    function test_TransferProjectOwnership_OnlyOwnerCanTransfer() public {</span>
 178 |     | <span class='neutral'>        // Owner should succeed</span>
 179 |     | <span class='unexecuted'>        vm.prank(projectOwner);</span>
 180 |     | <span class='unexecuted'>        vm.expectEmit(true, true, true, true, address(registry));</span>
 181 |     | <span class='unexecuted'>        emit ProjectRegistry.ProjectOwnershipTransferred(projectId, projectOwner, anotherUser);</span>
 182 |     | <span class='unexecuted'>        registry.transferProjectOwnership(projectId, anotherUser);</span>
 183 |     | <span class='unexecuted'>        assertEq(registry.getProject(projectId).owner, anotherUser);</span>
 184 |     | <span class='neutral'></span>
 185 |     | <span class='neutral'>        // Old owner should fail</span>
 186 |     | <span class='unexecuted'>        vm.prank(projectOwner);</span>
 187 |     | <span class='unexecuted'>        vm.expectRevert(ProjectRegistry__NotProjectOwner.selector);</span>
 188 |     | <span class='unexecuted'>        registry.transferProjectOwnership(projectId, admin);</span>
 189 |     | <span class='neutral'>    }</span>
 190 |     | <span class='neutral'></span>
 191 |     | <span class='unexecuted'>    function test_TransferProjectOwnership_RevertsOnZeroAddress() public {</span>
 192 |     | <span class='unexecuted'>        vm.prank(projectOwner);</span>
 193 |     | <span class='unexecuted'>        vm.expectRevert(ProjectRegistry__NewOwnerIsZeroAddress.selector);</span>
 194 |     | <span class='unexecuted'>        registry.transferProjectOwnership(projectId, address(0));</span>
 195 |     | <span class='neutral'>    }</span>
 196 |     | <span class='neutral'></span>
 197 |     | <span class='unexecuted'>    function test_Fuzz_AccessControls(address caller, address newOwner, string calldata uri) public {</span>
 198 |     | <span class='unexecuted'>        vm.assume(caller != projectOwner);</span>
 199 |     | <span class='unexecuted'>        vm.assume(caller != admin);</span>
 200 |     | <span class='unexecuted'>        vm.assume(caller != verifier);</span>
 201 |     | <span class='neutral'></span>
 202 |     | <span class='neutral'>        // Test setProjectMetaURI</span>
 203 |     | <span class='unexecuted'>        vm.prank(caller);</span>
 204 |     | <span class='unexecuted'>        vm.expectRevert(ProjectRegistry__NotProjectOwner.selector);</span>
 205 |     | <span class='unexecuted'>        registry.setProjectMetaURI(projectId, uri);</span>
 206 |     | <span class='neutral'></span>
 207 |     | <span class='neutral'>        // Test transferProjectOwnership</span>
 208 |     | <span class='unexecuted'>        vm.prank(caller);</span>
 209 |     | <span class='unexecuted'>        vm.expectRevert(ProjectRegistry__NotProjectOwner.selector);</span>
 210 |     | <span class='unexecuted'>        registry.transferProjectOwnership(projectId, newOwner);</span>
 211 |     | <span class='neutral'>    }</span>
 212 |     | <span class='neutral'></span>
 213 |     | <span class='neutral'>    /* ----------------- */</span>
 214 |     | <span class='neutral'>    /*      Pausable     */</span>
 215 |     | <span class='neutral'>    /* ----------------- */</span>
 216 |     | <span class='neutral'></span>
 217 |     | <span class='unexecuted'>    function test_PauseAndUnpause() public {</span>
 218 |     | <span class='unexecuted'>        bytes32 pauserRole = registry.PAUSER_ROLE();</span>
 219 |     | <span class='neutral'></span>
 220 |     | <span class='unexecuted'>        vm.startPrank(admin);</span>
 221 |     | <span class='neutral'>        // Admin has pauser role by default from setUp</span>
 222 |     | <span class='unexecuted'>        registry.pause();</span>
 223 |     | <span class='unexecuted'>        assertTrue(registry.paused());</span>
 224 |     | <span class='unexecuted'>        registry.unpause();</span>
 225 |     | <span class='unexecuted'>        assertFalse(registry.paused());</span>
 226 |     | <span class='unexecuted'>        vm.stopPrank();</span>
 227 |     | <span class='neutral'></span>
 228 |     | <span class='neutral'>        // Non-pauser cannot pause</span>
 229 |     | <span class='unexecuted'>        vm.prank(anotherUser);</span>
 230 |     | <span class='unexecuted'>        vm.expectRevert(</span>
 231 |     | <span class='unexecuted'>            abi.encodeWithSelector(</span>
 232 |     | <span class='unexecuted'>                bytes4(keccak256(&quot;AccessControlUnauthorizedAccount(address,bytes32)&quot;)), anotherUser, pauserRole</span>
 233 |     | <span class='neutral'>            )</span>
 234 |     | <span class='neutral'>        );</span>
 235 |     | <span class='unexecuted'>        registry.pause();</span>
 236 |     | <span class='neutral'>    }</span>
 237 |     | <span class='neutral'></span>
 238 |     | <span class='unexecuted'>    function test_RevertsWhenPaused() public {</span>
 239 |     | <span class='unexecuted'>        vm.prank(admin);</span>
 240 |     | <span class='unexecuted'>        registry.pause();</span>
 241 |     | <span class='neutral'></span>
 242 |     | <span class='neutral'>        // Check key functions revert when paused</span>
 243 |     | <span class='unexecuted'>        bytes4 expectedRevert = bytes4(keccak256(&quot;EnforcedPause()&quot;));</span>
 244 |     | <span class='neutral'></span>
 245 |     | <span class='unexecuted'>        vm.prank(anotherUser);</span>
 246 |     | <span class='unexecuted'>        vm.expectRevert(expectedRevert);</span>
 247 |     | <span class='unexecuted'>        registry.registerProject(keccak256(&quot;paused project&quot;), &quot;ipfs://paused.json&quot;);</span>
 248 |     | <span class='neutral'></span>
 249 |     | <span class='unexecuted'>        vm.prank(verifier);</span>
 250 |     | <span class='unexecuted'>        vm.expectRevert(expectedRevert);</span>
 251 |     | <span class='unexecuted'>        registry.setProjectStatus(projectId, ProjectRegistry.ProjectStatus.Active);</span>
 252 |     | <span class='neutral'></span>
 253 |     | <span class='unexecuted'>        vm.prank(projectOwner);</span>
 254 |     | <span class='unexecuted'>        vm.expectRevert(expectedRevert);</span>
 255 |     | <span class='unexecuted'>        registry.setProjectMetaURI(projectId, &quot;ipfs://paused.json&quot;);</span>
 256 |     | <span class='neutral'></span>
 257 |     | <span class='unexecuted'>        vm.prank(projectOwner);</span>
 258 |     | <span class='unexecuted'>        vm.expectRevert(expectedRevert);</span>
 259 |     | <span class='unexecuted'>        registry.transferProjectOwnership(projectId, anotherUser);</span>
 260 |     | <span class='neutral'>    }</span>
 261 |     | <span class='neutral'></span>
 262 |     | <span class='neutral'>    /* ----------------- */</span>
 263 |     | <span class='neutral'>    /*      View         */</span>
 264 |     | <span class='neutral'>    /* ----------------- */</span>
 265 |     | <span class='unexecuted'>    function test_GetProject_RevertsOnNonExistentProject() public {</span>
 266 |     | <span class='unexecuted'>        vm.expectRevert(ProjectRegistry__ProjectNotFound.selector);</span>
 267 |     | <span class='unexecuted'>        registry.getProject(keccak256(&quot;non existent&quot;));</span>
 268 |     | <span class='neutral'>    }</span>
 269 |     | <span class='neutral'>}</span>
 270 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/phantom/Documents/azemora/azemora-contracts/test/reverts/DynamicImpactCredit.reverts.t.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'>pragma solidity ^0.8.20;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>import &quot;forge-std/Test.sol&quot;;</span>
   5 |     | <span class='neutral'>import &quot;../../src/core/ProjectRegistry.sol&quot;;</span>
   6 |     | <span class='neutral'>import &quot;../../src/core/DynamicImpactCredit.sol&quot;;</span>
   7 |     | <span class='neutral'>import &quot;@openzeppelin/contracts/proxy/ERC1967/ERC1967Proxy.sol&quot;;</span>
   8 |     | <span class='neutral'></span>
   9 |     | <span class='unexecuted'>contract DynamicImpactCreditRevertsTest is Test {</span>
  10 |     | <span class='neutral'>    ProjectRegistry registry;</span>
  11 |     | <span class='neutral'>    DynamicImpactCredit credit;</span>
  12 |     | <span class='neutral'></span>
  13 |     | <span class='unexecuted'>    address admin = makeAddr(&quot;admin&quot;);</span>
  14 |     | <span class='unexecuted'>    address dmrvManager = makeAddr(&quot;dmrvManager&quot;);</span>
  15 |     | <span class='unexecuted'>    address metadataUpdater = makeAddr(&quot;metadataUpdater&quot;);</span>
  16 |     | <span class='unexecuted'>    address projectDeveloper = makeAddr(&quot;projectDeveloper&quot;);</span>
  17 |     | <span class='unexecuted'>    address otherUser = makeAddr(&quot;otherUser&quot;);</span>
  18 |     | <span class='neutral'></span>
  19 |     | <span class='unexecuted'>    bytes32 activeProjectId = keccak256(&quot;Active Project&quot;);</span>
  20 |     | <span class='unexecuted'>    uint256 activeTokenId = uint256(activeProjectId);</span>
  21 |     | <span class='unexecuted'>    bytes32 pendingProjectId = keccak256(&quot;Pending Project&quot;);</span>
  22 |     | <span class='neutral'></span>
  23 |     | <span class='unexecuted'>    function setUp() public {</span>
  24 |     | <span class='unexecuted'>        vm.startPrank(admin);</span>
  25 |     | <span class='neutral'>        // Deploy Registry</span>
  26 |     | <span class='unexecuted'>        ProjectRegistry registryImpl = new ProjectRegistry();</span>
  27 |     | <span class='unexecuted'>        registry = ProjectRegistry(</span>
  28 |     | <span class='unexecuted'>            address(new ERC1967Proxy(address(registryImpl), abi.encodeCall(ProjectRegistry.initialize, ())))</span>
  29 |     | <span class='neutral'>        );</span>
  30 |     | <span class='neutral'>        // No verifier needed, we control status directly with admin for this test</span>
  31 |     | <span class='neutral'></span>
  32 |     | <span class='neutral'>        // Deploy Credits contract</span>
  33 |     | <span class='unexecuted'>        DynamicImpactCredit creditImpl = new DynamicImpactCredit(address(registry));</span>
  34 |     | <span class='unexecuted'>        credit = DynamicImpactCredit(</span>
  35 |     | <span class='unexecuted'>            address(new ERC1967Proxy(address(creditImpl), abi.encodeCall(DynamicImpactCredit.initialize, (&quot;ipfs://&quot;))))</span>
  36 |     | <span class='neutral'>        );</span>
  37 |     | <span class='neutral'></span>
  38 |     | <span class='neutral'>        // Grant necessary roles</span>
  39 |     | <span class='unexecuted'>        credit.grantRole(credit.DMRV_MANAGER_ROLE(), dmrvManager);</span>
  40 |     | <span class='unexecuted'>        credit.grantRole(credit.METADATA_UPDATER_ROLE(), metadataUpdater);</span>
  41 |     | <span class='unexecuted'>        vm.stopPrank();</span>
  42 |     | <span class='neutral'></span>
  43 |     | <span class='neutral'>        // Setup a pending and an active project</span>
  44 |     | <span class='unexecuted'>        vm.prank(projectDeveloper);</span>
  45 |     | <span class='unexecuted'>        registry.registerProject(pendingProjectId, &quot;ipfs://pending&quot;);</span>
  46 |     | <span class='unexecuted'>        vm.prank(projectDeveloper);</span>
  47 |     | <span class='unexecuted'>        registry.registerProject(activeProjectId, &quot;ipfs://active&quot;);</span>
  48 |     | <span class='unexecuted'>        vm.prank(admin);</span>
  49 |     | <span class='unexecuted'>        registry.setProjectStatus(activeProjectId, ProjectRegistry.ProjectStatus.Active);</span>
  50 |     | <span class='neutral'>    }</span>
  51 |     | <span class='neutral'></span>
  52 |     | <span class='neutral'>    // --- mintCredits ---</span>
  53 |     | <span class='neutral'></span>
  54 |     | <span class='unexecuted'>    function test_revert_mintCredits_notDMRVManager() public {</span>
  55 |     | <span class='unexecuted'>        bytes4 expectedError = bytes4(keccak256(&quot;AccessControlUnauthorizedAccount(address,bytes32)&quot;));</span>
  56 |     | <span class='unexecuted'>        vm.expectRevert(abi.encodeWithSelector(expectedError, otherUser, credit.DMRV_MANAGER_ROLE()));</span>
  57 |     | <span class='unexecuted'>        vm.prank(otherUser);</span>
  58 |     | <span class='unexecuted'>        credit.mintCredits(projectDeveloper, activeProjectId, 100, &quot;ipfs://data&quot;);</span>
  59 |     | <span class='neutral'>    }</span>
  60 |     | <span class='neutral'></span>
  61 |     | <span class='unexecuted'>    function test_revert_mintCredits_projectNotActive() public {</span>
  62 |     | <span class='unexecuted'>        vm.expectRevert(DynamicImpactCredit__ProjectNotActive.selector);</span>
  63 |     | <span class='unexecuted'>        vm.prank(dmrvManager);</span>
  64 |     | <span class='unexecuted'>        credit.mintCredits(projectDeveloper, pendingProjectId, 100, &quot;ipfs://data&quot;);</span>
  65 |     | <span class='neutral'>    }</span>
  66 |     | <span class='neutral'></span>
  67 |     | <span class='neutral'>    // --- setTokenURI ---</span>
  68 |     | <span class='neutral'></span>
  69 |     | <span class='unexecuted'>    function test_revert_setTokenURI_notMetadataUpdater() public {</span>
  70 |     | <span class='neutral'>        // First mint a token so we can try to update its URI</span>
  71 |     | <span class='unexecuted'>        vm.prank(dmrvManager);</span>
  72 |     | <span class='unexecuted'>        credit.mintCredits(projectDeveloper, activeProjectId, 1, &quot;ipfs://original&quot;);</span>
  73 |     | <span class='neutral'></span>
  74 |     | <span class='unexecuted'>        bytes4 expectedError = bytes4(keccak256(&quot;AccessControlUnauthorizedAccount(address,bytes32)&quot;));</span>
  75 |     | <span class='unexecuted'>        vm.expectRevert(abi.encodeWithSelector(expectedError, otherUser, credit.METADATA_UPDATER_ROLE()));</span>
  76 |     | <span class='unexecuted'>        vm.prank(otherUser);</span>
  77 |     | <span class='unexecuted'>        credit.setTokenURI(activeProjectId, &quot;ipfs://new&quot;);</span>
  78 |     | <span class='neutral'>    }</span>
  79 |     | <span class='neutral'></span>
  80 |     | <span class='neutral'>    // --- uri ---</span>
  81 |     | <span class='neutral'></span>
  82 |     | <span class='unexecuted'>    function test_revert_uri_nonExistentToken() public {</span>
  83 |     | <span class='unexecuted'>        vm.expectRevert(DynamicImpactCredit__URINotSet.selector);</span>
  84 |     | <span class='unexecuted'>        credit.uri(uint256(keccak256(&quot;non-existent&quot;)));</span>
  85 |     | <span class='neutral'>    }</span>
  86 |     | <span class='neutral'></span>
  87 |     | <span class='neutral'>    // --- retire ---</span>
  88 |     | <span class='neutral'></span>
  89 |     | <span class='unexecuted'>    function test_revert_retire_notOwnerOrApproved() public {</span>
  90 |     | <span class='neutral'>        // Mint tokens to the project developer</span>
  91 |     | <span class='unexecuted'>        vm.prank(dmrvManager);</span>
  92 |     | <span class='unexecuted'>        credit.mintCredits(projectDeveloper, activeProjectId, 100, &quot;ipfs://data&quot;);</span>
  93 |     | <span class='neutral'></span>
  94 |     | <span class='neutral'>        // Try to retire them from another user&#39;s account</span>
  95 |     | <span class='unexecuted'>        vm.expectRevert(DynamicImpactCredit__NotAuthorized.selector);</span>
  96 |     | <span class='unexecuted'>        vm.prank(otherUser);</span>
  97 |     | <span class='unexecuted'>        credit.retire(projectDeveloper, activeProjectId, 50);</span>
  98 |     | <span class='neutral'>    }</span>
  99 |     | <span class='neutral'></span>
 100 |     | <span class='neutral'>    // --- Pausable ---</span>
 101 |     | <span class='neutral'></span>
 102 |     | <span class='unexecuted'>    function test_revert_whenPaused_mintCredits() public {</span>
 103 |     | <span class='unexecuted'>        vm.prank(admin);</span>
 104 |     | <span class='unexecuted'>        credit.pause();</span>
 105 |     | <span class='neutral'></span>
 106 |     | <span class='unexecuted'>        vm.expectRevert(bytes(&quot;EnforcedPause()&quot;));</span>
 107 |     | <span class='unexecuted'>        vm.prank(dmrvManager);</span>
 108 |     | <span class='unexecuted'>        credit.mintCredits(projectDeveloper, activeProjectId, 100, &quot;ipfs://data&quot;);</span>
 109 |     | <span class='neutral'>    }</span>
 110 |     | <span class='neutral'>}</span>
 111 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/phantom/Documents/azemora/azemora-contracts/test/reverts/Marketplace.reverts.t.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'>pragma solidity ^0.8.20;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>import &quot;forge-std/Test.sol&quot;;</span>
   5 |     | <span class='neutral'>import &quot;../../src/marketplace/Marketplace.sol&quot;;</span>
   6 |     | <span class='neutral'>import &quot;../../src/core/DynamicImpactCredit.sol&quot;;</span>
   7 |     | <span class='neutral'>import &quot;@openzeppelin/contracts/proxy/ERC1967/ERC1967Proxy.sol&quot;;</span>
   8 |     | <span class='neutral'></span>
   9 |     | <span class='neutral'>// Minimal mock ERC20 for testing reverts</span>
  10 |     | <span class='unexecuted'>contract MockERC20ForReverts is Test {</span>
  11 |     | <span class='unexecuted'>    mapping(address =&gt; uint256) public balanceOf;</span>
  12 |     | <span class='unexecuted'>    mapping(address =&gt; mapping(address =&gt; uint256)) public allowance;</span>
  13 |     | <span class='neutral'></span>
  14 |     | <span class='unexecuted'>    function approve(address spender, uint256 amount) public {</span>
  15 |     | <span class='unexecuted'>        allowance[msg.sender][spender] = amount;</span>
  16 |     | <span class='neutral'>    }</span>
  17 |     | <span class='neutral'></span>
  18 |     | <span class='unexecuted'>    function transferFrom(address from, address to, uint256 amount) public returns (bool) {</span>
  19 |     | <span class='unexecuted'>        if (allowance[from][msg.sender] &lt; amount) return false;</span>
  20 |     | <span class='unexecuted'>        allowance[from][msg.sender] -= amount;</span>
  21 |     | <span class='unexecuted'>        balanceOf[from] -= amount;</span>
  22 |     | <span class='unexecuted'>        balanceOf[to] += amount;</span>
  23 |     | <span class='unexecuted'>        return true;</span>
  24 |     | <span class='neutral'>    }</span>
  25 |     | <span class='neutral'></span>
  26 |     | <span class='unexecuted'>    function mint(address to, uint256 amount) public {</span>
  27 |     | <span class='unexecuted'>        balanceOf[to] += amount;</span>
  28 |     | <span class='neutral'>    }</span>
  29 |     | <span class='neutral'>}</span>
  30 |     | <span class='neutral'></span>
  31 |     | <span class='neutral'>// Minimal mock ERC1155 for testing reverts</span>
  32 |     | <span class='unexecuted'>contract MockERC1155ForReverts is Test {</span>
  33 |     | <span class='unexecuted'>    mapping(address =&gt; mapping(uint256 =&gt; uint256)) public balanceOf;</span>
  34 |     | <span class='neutral'></span>
  35 |     | <span class='unexecuted'>    function safeTransferFrom(address, address to, uint256 id, uint256 amount, bytes memory) public {</span>
  36 |     | <span class='unexecuted'>        balanceOf[to][id] += amount;</span>
  37 |     | <span class='neutral'>    }</span>
  38 |     | <span class='neutral'></span>
  39 |     | <span class='unexecuted'>    function setApprovalForAll(address, bool) public {}</span>
  40 |     | <span class='neutral'>}</span>
  41 |     | <span class='neutral'></span>
  42 |     | <span class='unexecuted'>contract MarketplaceRevertsTest is Test {</span>
  43 |     | <span class='neutral'>    Marketplace marketplace;</span>
  44 |     | <span class='neutral'>    MockERC1155ForReverts credit;</span>
  45 |     | <span class='neutral'>    MockERC20ForReverts paymentToken;</span>
  46 |     | <span class='neutral'></span>
  47 |     | <span class='unexecuted'>    address admin = makeAddr(&quot;admin&quot;);</span>
  48 |     | <span class='unexecuted'>    address seller = makeAddr(&quot;seller&quot;);</span>
  49 |     | <span class='unexecuted'>    address buyer = makeAddr(&quot;buyer&quot;);</span>
  50 |     | <span class='unexecuted'>    address otherUser = makeAddr(&quot;otherUser&quot;);</span>
  51 |     | <span class='neutral'></span>
  52 |     | <span class='unexecuted'>    uint256 tokenId = 1;</span>
  53 |     | <span class='neutral'>    uint256 listingId;</span>
  54 |     | <span class='neutral'></span>
  55 |     | <span class='unexecuted'>    function setUp() public {</span>
  56 |     | <span class='unexecuted'>        credit = new MockERC1155ForReverts();</span>
  57 |     | <span class='unexecuted'>        paymentToken = new MockERC20ForReverts();</span>
  58 |     | <span class='neutral'></span>
  59 |     | <span class='unexecuted'>        vm.startPrank(admin);</span>
  60 |     | <span class='unexecuted'>        Marketplace marketplaceImpl = new Marketplace();</span>
  61 |     | <span class='unexecuted'>        marketplace = Marketplace(</span>
  62 |     | <span class='neutral'>            address(</span>
  63 |     | <span class='unexecuted'>                new ERC1967Proxy(</span>
  64 |     | <span class='neutral'>                    address(marketplaceImpl),</span>
  65 |     | <span class='unexecuted'>                    abi.encodeCall(Marketplace.initialize, (address(credit), address(paymentToken)))</span>
  66 |     | <span class='neutral'>                )</span>
  67 |     | <span class='neutral'>            )</span>
  68 |     | <span class='neutral'>        );</span>
  69 |     | <span class='unexecuted'>        vm.stopPrank();</span>
  70 |     | <span class='neutral'></span>
  71 |     | <span class='neutral'>        // Create a default listing for use in tests</span>
  72 |     | <span class='unexecuted'>        vm.prank(seller);</span>
  73 |     | <span class='unexecuted'>        listingId = marketplace.list(tokenId, 100, 10 ether, 1 days);</span>
  74 |     | <span class='neutral'>    }</span>
  75 |     | <span class='neutral'></span>
  76 |     | <span class='neutral'>    // --- list ---</span>
  77 |     | <span class='neutral'></span>
  78 |     | <span class='unexecuted'>    function test_revert_list_zeroAmount() public {</span>
  79 |     | <span class='unexecuted'>        vm.expectRevert(Marketplace__ZeroAmount.selector);</span>
  80 |     | <span class='unexecuted'>        vm.prank(seller);</span>
  81 |     | <span class='unexecuted'>        marketplace.list(tokenId, 0, 10 ether, 1 days);</span>
  82 |     | <span class='neutral'>    }</span>
  83 |     | <span class='neutral'></span>
  84 |     | <span class='unexecuted'>    function test_revert_list_zeroPrice() public {</span>
  85 |     | <span class='unexecuted'>        vm.expectRevert(Marketplace__ZeroPrice.selector);</span>
  86 |     | <span class='unexecuted'>        vm.prank(seller);</span>
  87 |     | <span class='unexecuted'>        marketplace.list(tokenId, 100, 0, 1 days);</span>
  88 |     | <span class='neutral'>    }</span>
  89 |     | <span class='neutral'></span>
  90 |     | <span class='neutral'>    // --- buy ---</span>
  91 |     | <span class='neutral'></span>
  92 |     | <span class='unexecuted'>    function test_revert_buy_inactiveListing() public {</span>
  93 |     | <span class='neutral'>        // Cancel the listing first</span>
  94 |     | <span class='unexecuted'>        vm.prank(seller);</span>
  95 |     | <span class='unexecuted'>        marketplace.cancelListing(listingId);</span>
  96 |     | <span class='neutral'></span>
  97 |     | <span class='unexecuted'>        vm.expectRevert(Marketplace__ListingNotActive.selector);</span>
  98 |     | <span class='neutral'>        vm.prank(buyer);</span>
  99 |     | <span class='neutral'>        marketplace.buy(listingId, 10);</span>
 100 |     | <span class='neutral'>    }</span>
 101 |     | <span class='neutral'></span>
 102 |     | <span class='unexecuted'>    function test_revert_buy_expiredListing() public {</span>
 103 |     | <span class='unexecuted'>        vm.warp(block.timestamp + 2 days); // Fast forward time</span>
 104 |     | <span class='unexecuted'>        vm.expectRevert(Marketplace__ListingExpired.selector);</span>
 105 |     | <span class='neutral'>        vm.prank(buyer);</span>
 106 |     | <span class='neutral'>        marketplace.buy(listingId, 10);</span>
 107 |     | <span class='neutral'>    }</span>
 108 |     | <span class='neutral'></span>
 109 |     | <span class='unexecuted'>    function test_revert_buy_insufficientItems() public {</span>
 110 |     | <span class='unexecuted'>        vm.expectRevert(Marketplace__NotEnoughItemsInListing.selector);</span>
 111 |     | <span class='unexecuted'>        vm.prank(buyer);</span>
 112 |     | <span class='unexecuted'>        marketplace.buy(listingId, 101); // Try to buy more than listed</span>
 113 |     | <span class='neutral'>    }</span>
 114 |     | <span class='neutral'></span>
 115 |     | <span class='unexecuted'>    function test_revert_buy_insufficientBalance() public {</span>
 116 |     | <span class='neutral'>        // Buyer has 0 payment tokens</span>
 117 |     | <span class='unexecuted'>        vm.expectRevert(Marketplace__InsufficientBalance.selector);</span>
 118 |     | <span class='unexecuted'>        vm.prank(buyer);</span>
 119 |     | <span class='unexecuted'>        marketplace.buy(listingId, 10);</span>
 120 |     | <span class='neutral'>    }</span>
 121 |     | <span class='neutral'></span>
 122 |     | <span class='neutral'>    // --- cancelListing ---</span>
 123 |     | <span class='neutral'></span>
 124 |     | <span class='unexecuted'>    function test_revert_cancelListing_notSeller() public {</span>
 125 |     | <span class='unexecuted'>        vm.expectRevert(Marketplace__NotTheSeller.selector);</span>
 126 |     | <span class='unexecuted'>        vm.prank(otherUser);</span>
 127 |     | <span class='unexecuted'>        marketplace.cancelListing(listingId);</span>
 128 |     | <span class='neutral'>    }</span>
 129 |     | <span class='neutral'></span>
 130 |     | <span class='neutral'>    // --- updateListingPrice ---</span>
 131 |     | <span class='neutral'></span>
 132 |     | <span class='unexecuted'>    function test_revert_updateListingPrice_notSeller() public {</span>
 133 |     | <span class='unexecuted'>        vm.expectRevert(Marketplace__NotTheSeller.selector);</span>
 134 |     | <span class='unexecuted'>        vm.prank(otherUser);</span>
 135 |     | <span class='unexecuted'>        marketplace.updateListingPrice(listingId, 5 ether);</span>
 136 |     | <span class='neutral'>    }</span>
 137 |     | <span class='neutral'></span>
 138 |     | <span class='unexecuted'>    function test_revert_updateListingPrice_inactiveListing() public {</span>
 139 |     | <span class='unexecuted'>        vm.prank(seller);</span>
 140 |     | <span class='unexecuted'>        marketplace.cancelListing(listingId);</span>
 141 |     | <span class='neutral'></span>
 142 |     | <span class='unexecuted'>        vm.expectRevert(Marketplace__ListingNotActive.selector);</span>
 143 |     | <span class='unexecuted'>        vm.prank(seller);</span>
 144 |     | <span class='neutral'>        marketplace.updateListingPrice(listingId, 5 ether);</span>
 145 |     | <span class='neutral'>    }</span>
 146 |     | <span class='neutral'></span>
 147 |     | <span class='neutral'>    // --- Admin functions ---</span>
 148 |     | <span class='neutral'></span>
 149 |     | <span class='unexecuted'>    function test_revert_setTreasury_notAdmin() public {</span>
 150 |     | <span class='unexecuted'>        bytes4 expectedError = bytes4(keccak256(&quot;AccessControlUnauthorizedAccount(address,bytes32)&quot;));</span>
 151 |     | <span class='unexecuted'>        vm.expectRevert(abi.encodeWithSelector(expectedError, otherUser, marketplace.DEFAULT_ADMIN_ROLE()));</span>
 152 |     | <span class='unexecuted'>        vm.prank(otherUser);</span>
 153 |     | <span class='unexecuted'>        marketplace.setTreasury(otherUser);</span>
 154 |     | <span class='neutral'>    }</span>
 155 |     | <span class='neutral'></span>
 156 |     | <span class='unexecuted'>    function test_revert_setFee_notAdmin() public {</span>
 157 |     | <span class='unexecuted'>        bytes4 expectedError = bytes4(keccak256(&quot;AccessControlUnauthorizedAccount(address,bytes32)&quot;));</span>
 158 |     | <span class='unexecuted'>        vm.expectRevert(abi.encodeWithSelector(expectedError, otherUser, marketplace.DEFAULT_ADMIN_ROLE()));</span>
 159 |     | <span class='unexecuted'>        vm.prank(otherUser);</span>
 160 |     | <span class='unexecuted'>        marketplace.setFee(100);</span>
 161 |     | <span class='neutral'>    }</span>
 162 |     | <span class='neutral'>}</span>
 163 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/phantom/Documents/azemora/azemora-contracts/test/reverts/ProjectRegistry.reverts.t.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'>pragma solidity ^0.8.20;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>import &quot;forge-std/Test.sol&quot;;</span>
   5 |     | <span class='neutral'>import &quot;../../src/core/ProjectRegistry.sol&quot;;</span>
   6 |     | <span class='neutral'>import &quot;@openzeppelin/contracts/proxy/ERC1967/ERC1967Proxy.sol&quot;;</span>
   7 |     | <span class='neutral'></span>
   8 |     | <span class='unexecuted'>contract ProjectRegistryRevertsTest is Test {</span>
   9 |     | <span class='neutral'>    ProjectRegistry registry;</span>
  10 |     | <span class='neutral'></span>
  11 |     | <span class='unexecuted'>    address admin = makeAddr(&quot;admin&quot;);</span>
  12 |     | <span class='unexecuted'>    address projectDeveloper = makeAddr(&quot;projectDeveloper&quot;);</span>
  13 |     | <span class='unexecuted'>    address verifier = makeAddr(&quot;verifier&quot;);</span>
  14 |     | <span class='unexecuted'>    address otherUser = makeAddr(&quot;otherUser&quot;);</span>
  15 |     | <span class='neutral'></span>
  16 |     | <span class='unexecuted'>    bytes32 projectId = keccak256(&quot;Test Project&quot;);</span>
  17 |     | <span class='neutral'></span>
  18 |     | <span class='unexecuted'>    function setUp() public {</span>
  19 |     | <span class='unexecuted'>        vm.startPrank(admin);</span>
  20 |     | <span class='unexecuted'>        ProjectRegistry registryImpl = new ProjectRegistry();</span>
  21 |     | <span class='unexecuted'>        registry = ProjectRegistry(</span>
  22 |     | <span class='unexecuted'>            address(new ERC1967Proxy(address(registryImpl), abi.encodeCall(ProjectRegistry.initialize, ())))</span>
  23 |     | <span class='neutral'>        );</span>
  24 |     | <span class='neutral'>        // Grant verifier role</span>
  25 |     | <span class='unexecuted'>        registry.grantRole(registry.VERIFIER_ROLE(), verifier);</span>
  26 |     | <span class='unexecuted'>        vm.stopPrank();</span>
  27 |     | <span class='neutral'></span>
  28 |     | <span class='neutral'>        // Register a project to be used in other tests</span>
  29 |     | <span class='unexecuted'>        vm.prank(projectDeveloper);</span>
  30 |     | <span class='unexecuted'>        registry.registerProject(projectId, &quot;ipfs://initial&quot;);</span>
  31 |     | <span class='neutral'>    }</span>
  32 |     | <span class='neutral'></span>
  33 |     | <span class='neutral'>    // --- registerProject ---</span>
  34 |     | <span class='neutral'></span>
  35 |     | <span class='unexecuted'>    function test_revert_registerProject_alreadyExists() public {</span>
  36 |     | <span class='unexecuted'>        vm.expectRevert(ProjectRegistry__IdAlreadyExists.selector);</span>
  37 |     | <span class='unexecuted'>        vm.prank(otherUser);</span>
  38 |     | <span class='unexecuted'>        registry.registerProject(projectId, &quot;ipfs://duplicate&quot;);</span>
  39 |     | <span class='neutral'>    }</span>
  40 |     | <span class='neutral'></span>
  41 |     | <span class='neutral'>    // --- setProjectStatus ---</span>
  42 |     | <span class='neutral'></span>
  43 |     | <span class='unexecuted'>    function test_revert_setProjectStatus_nonExistentProject() public {</span>
  44 |     | <span class='unexecuted'>        vm.expectRevert(ProjectRegistry__ProjectNotFound.selector);</span>
  45 |     | <span class='unexecuted'>        vm.prank(verifier);</span>
  46 |     | <span class='unexecuted'>        registry.setProjectStatus(keccak256(&quot;non-existent&quot;), ProjectRegistry.ProjectStatus.Active);</span>
  47 |     | <span class='neutral'>    }</span>
  48 |     | <span class='neutral'></span>
  49 |     | <span class='unexecuted'>    function test_revert_setProjectStatus_toActive_notVerifier() public {</span>
  50 |     | <span class='unexecuted'>        vm.expectRevert(ProjectRegistry__CallerNotVerifier.selector);</span>
  51 |     | <span class='unexecuted'>        vm.prank(otherUser);</span>
  52 |     | <span class='unexecuted'>        registry.setProjectStatus(projectId, ProjectRegistry.ProjectStatus.Active);</span>
  53 |     | <span class='neutral'>    }</span>
  54 |     | <span class='neutral'></span>
  55 |     | <span class='unexecuted'>    function test_revert_setProjectStatus_toPaused_notAdmin() public {</span>
  56 |     | <span class='unexecuted'>        vm.expectRevert(ProjectRegistry__CallerNotAdmin.selector);</span>
  57 |     | <span class='unexecuted'>        vm.prank(otherUser);</span>
  58 |     | <span class='unexecuted'>        registry.setProjectStatus(projectId, ProjectRegistry.ProjectStatus.Paused);</span>
  59 |     | <span class='neutral'>    }</span>
  60 |     | <span class='neutral'></span>
  61 |     | <span class='unexecuted'>    function test_revert_setProjectStatus_toArchived_notAdmin() public {</span>
  62 |     | <span class='unexecuted'>        vm.expectRevert(ProjectRegistry__CallerNotAdmin.selector);</span>
  63 |     | <span class='unexecuted'>        vm.prank(otherUser);</span>
  64 |     | <span class='unexecuted'>        registry.setProjectStatus(projectId, ProjectRegistry.ProjectStatus.Archived);</span>
  65 |     | <span class='neutral'>    }</span>
  66 |     | <span class='neutral'></span>
  67 |     | <span class='unexecuted'>    function test_revert_setProjectStatus_invalidTransition() public {</span>
  68 |     | <span class='neutral'>        // e.g., trying to set to Pending again from Pending</span>
  69 |     | <span class='unexecuted'>        vm.expectRevert(ProjectRegistry__StatusIsSame.selector);</span>
  70 |     | <span class='unexecuted'>        vm.prank(verifier);</span>
  71 |     | <span class='unexecuted'>        registry.setProjectStatus(projectId, ProjectRegistry.ProjectStatus.Pending);</span>
  72 |     | <span class='neutral'>    }</span>
  73 |     | <span class='neutral'></span>
  74 |     | <span class='neutral'>    // --- setProjectMetaURI ---</span>
  75 |     | <span class='neutral'></span>
  76 |     | <span class='unexecuted'>    function test_revert_setProjectMetaURI_notOwner() public {</span>
  77 |     | <span class='unexecuted'>        vm.expectRevert(ProjectRegistry__NotProjectOwner.selector);</span>
  78 |     | <span class='unexecuted'>        vm.prank(otherUser);</span>
  79 |     | <span class='unexecuted'>        registry.setProjectMetaURI(projectId, &quot;ipfs://new-meta&quot;);</span>
  80 |     | <span class='neutral'>    }</span>
  81 |     | <span class='neutral'></span>
  82 |     | <span class='neutral'>    // --- transferProjectOwnership ---</span>
  83 |     | <span class='neutral'></span>
  84 |     | <span class='unexecuted'>    function test_revert_transferProjectOwnership_notOwner() public {</span>
  85 |     | <span class='unexecuted'>        vm.expectRevert(ProjectRegistry__NotProjectOwner.selector);</span>
  86 |     | <span class='unexecuted'>        vm.prank(otherUser);</span>
  87 |     | <span class='unexecuted'>        registry.transferProjectOwnership(projectId, otherUser);</span>
  88 |     | <span class='neutral'>    }</span>
  89 |     | <span class='neutral'></span>
  90 |     | <span class='unexecuted'>    function test_revert_transferProjectOwnership_toZeroAddress() public {</span>
  91 |     | <span class='unexecuted'>        vm.prank(projectDeveloper);</span>
  92 |     | <span class='unexecuted'>        vm.expectRevert(ProjectRegistry__NewOwnerIsZeroAddress.selector);</span>
  93 |     | <span class='unexecuted'>        registry.transferProjectOwnership(projectId, address(0));</span>
  94 |     | <span class='neutral'>    }</span>
  95 |     | <span class='neutral'></span>
  96 |     | <span class='unexecuted'>    function test_revert_setProjectStatus_toPending() public {</span>
  97 |     | <span class='neutral'>        // Activate the project first to have a valid starting state other than Pending.</span>
  98 |     | <span class='unexecuted'>        vm.startPrank(verifier);</span>
  99 |     | <span class='unexecuted'>        registry.setProjectStatus(projectId, ProjectRegistry.ProjectStatus.Active);</span>
 100 |     | <span class='unexecuted'>        vm.stopPrank();</span>
 101 |     | <span class='neutral'></span>
 102 |     | <span class='neutral'>        // Try to move it back to Pending, which is not a valid transition target.</span>
 103 |     | <span class='unexecuted'>        vm.prank(admin);</span>
 104 |     | <span class='unexecuted'>        vm.expectRevert(ProjectRegistry__InvalidStatusTransition.selector);</span>
 105 |     | <span class='neutral'>        registry.setProjectStatus(projectId, ProjectRegistry.ProjectStatus.Pending);</span>
 106 |     | <span class='neutral'>    }</span>
 107 |     | <span class='neutral'>}</span>
 108 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/phantom/Documents/azemora/azemora-contracts/test/reverts/dMRVManager.reverts.t.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'>pragma solidity ^0.8.20;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>import &quot;forge-std/Test.sol&quot;;</span>
   5 |     | <span class='neutral'>import &quot;../../src/core/ProjectRegistry.sol&quot;;</span>
   6 |     | <span class='neutral'>import &quot;../../src/core/dMRVManager.sol&quot;;</span>
   7 |     | <span class='neutral'>import &quot;../../src/core/DynamicImpactCredit.sol&quot;;</span>
   8 |     | <span class='neutral'>import &quot;@openzeppelin/contracts/proxy/ERC1967/ERC1967Proxy.sol&quot;;</span>
   9 |     | <span class='neutral'></span>
  10 |     | <span class='unexecuted'>contract DMRVManagerRevertsTest is Test {</span>
  11 |     | <span class='neutral'>    ProjectRegistry registry;</span>
  12 |     | <span class='neutral'>    DMRVManager dmrvManager;</span>
  13 |     | <span class='neutral'>    DynamicImpactCredit credit;</span>
  14 |     | <span class='neutral'></span>
  15 |     | <span class='unexecuted'>    address admin = makeAddr(&quot;admin&quot;);</span>
  16 |     | <span class='unexecuted'>    address projectDeveloper = makeAddr(&quot;projectDeveloper&quot;);</span>
  17 |     | <span class='unexecuted'>    address verifier = makeAddr(&quot;verifier&quot;);</span>
  18 |     | <span class='unexecuted'>    address oracle = makeAddr(&quot;oracle&quot;);</span>
  19 |     | <span class='unexecuted'>    address otherUser = makeAddr(&quot;otherUser&quot;);</span>
  20 |     | <span class='neutral'></span>
  21 |     | <span class='unexecuted'>    bytes32 activeProjectId = keccak256(&quot;Active Project&quot;);</span>
  22 |     | <span class='unexecuted'>    bytes32 pendingProjectId = keccak256(&quot;Pending Project&quot;);</span>
  23 |     | <span class='neutral'></span>
  24 |     | <span class='unexecuted'>    function setUp() public {</span>
  25 |     | <span class='unexecuted'>        vm.startPrank(admin);</span>
  26 |     | <span class='neutral'>        // Deploy Registry</span>
  27 |     | <span class='unexecuted'>        ProjectRegistry registryImpl = new ProjectRegistry();</span>
  28 |     | <span class='unexecuted'>        registry = ProjectRegistry(</span>
  29 |     | <span class='unexecuted'>            address(new ERC1967Proxy(address(registryImpl), abi.encodeCall(ProjectRegistry.initialize, ())))</span>
  30 |     | <span class='neutral'>        );</span>
  31 |     | <span class='unexecuted'>        registry.grantRole(registry.VERIFIER_ROLE(), verifier);</span>
  32 |     | <span class='neutral'></span>
  33 |     | <span class='neutral'>        // Deploy Credits</span>
  34 |     | <span class='unexecuted'>        DynamicImpactCredit creditImpl = new DynamicImpactCredit(address(registry));</span>
  35 |     | <span class='unexecuted'>        credit = DynamicImpactCredit(</span>
  36 |     | <span class='unexecuted'>            address(new ERC1967Proxy(address(creditImpl), abi.encodeCall(DynamicImpactCredit.initialize, (&quot;ipfs://&quot;))))</span>
  37 |     | <span class='neutral'>        );</span>
  38 |     | <span class='neutral'></span>
  39 |     | <span class='neutral'>        // Deploy dMRV Manager</span>
  40 |     | <span class='unexecuted'>        DMRVManager dmrvManagerImpl = new DMRVManager(address(registry), address(credit));</span>
  41 |     | <span class='unexecuted'>        dmrvManager =</span>
  42 |     | <span class='unexecuted'>            DMRVManager(address(new ERC1967Proxy(address(dmrvManagerImpl), abi.encodeCall(DMRVManager.initialize, ()))));</span>
  43 |     | <span class='neutral'></span>
  44 |     | <span class='neutral'>        // Grant roles</span>
  45 |     | <span class='unexecuted'>        credit.grantRole(credit.DMRV_MANAGER_ROLE(), address(dmrvManager));</span>
  46 |     | <span class='unexecuted'>        dmrvManager.grantRole(dmrvManager.ORACLE_ROLE(), oracle);</span>
  47 |     | <span class='unexecuted'>        vm.stopPrank();</span>
  48 |     | <span class='neutral'></span>
  49 |     | <span class='neutral'>        // Setup projects</span>
  50 |     | <span class='unexecuted'>        vm.prank(projectDeveloper);</span>
  51 |     | <span class='unexecuted'>        registry.registerProject(activeProjectId, &quot;ipfs://active&quot;);</span>
  52 |     | <span class='unexecuted'>        vm.prank(projectDeveloper);</span>
  53 |     | <span class='unexecuted'>        registry.registerProject(pendingProjectId, &quot;ipfs://pending&quot;);</span>
  54 |     | <span class='neutral'></span>
  55 |     | <span class='neutral'>        // Activate one project</span>
  56 |     | <span class='unexecuted'>        vm.prank(verifier);</span>
  57 |     | <span class='unexecuted'>        registry.setProjectStatus(activeProjectId, ProjectRegistry.ProjectStatus.Active);</span>
  58 |     | <span class='neutral'>    }</span>
  59 |     | <span class='neutral'></span>
  60 |     | <span class='neutral'>    // --- requestVerification ---</span>
  61 |     | <span class='neutral'></span>
  62 |     | <span class='unexecuted'>    function test_revert_requestVerification_projectNotActive() public {</span>
  63 |     | <span class='unexecuted'>        vm.expectRevert(DMRVManager__ProjectNotActive.selector);</span>
  64 |     | <span class='unexecuted'>        vm.prank(projectDeveloper);</span>
  65 |     | <span class='unexecuted'>        dmrvManager.requestVerification(pendingProjectId);</span>
  66 |     | <span class='neutral'>    }</span>
  67 |     | <span class='neutral'></span>
  68 |     | <span class='neutral'>    // --- fulfillVerification ---</span>
  69 |     | <span class='neutral'></span>
  70 |     | <span class='unexecuted'>    function test_revert_fulfillVerification_notOracle() public {</span>
  71 |     | <span class='unexecuted'>        bytes memory data = abi.encode(100, false, bytes32(0), &quot;ipfs://data&quot;);</span>
  72 |     | <span class='unexecuted'>        bytes4 expectedError = bytes4(keccak256(&quot;AccessControlUnauthorizedAccount(address,bytes32)&quot;));</span>
  73 |     | <span class='unexecuted'>        vm.expectRevert(abi.encodeWithSelector(expectedError, otherUser, dmrvManager.ORACLE_ROLE()));</span>
  74 |     | <span class='unexecuted'>        vm.prank(otherUser);</span>
  75 |     | <span class='unexecuted'>        dmrvManager.fulfillVerification(bytes32(0), data);</span>
  76 |     | <span class='neutral'>    }</span>
  77 |     | <span class='neutral'></span>
  78 |     | <span class='unexecuted'>    function test_revert_fulfillVerification_requestNotFound() public {</span>
  79 |     | <span class='unexecuted'>        bytes memory data = abi.encode(100, false, bytes32(0), &quot;ipfs://data&quot;);</span>
  80 |     | <span class='unexecuted'>        vm.expectRevert(DMRVManager__RequestNotFound.selector);</span>
  81 |     | <span class='unexecuted'>        vm.prank(oracle);</span>
  82 |     | <span class='unexecuted'>        dmrvManager.fulfillVerification(keccak256(&quot;non-existent&quot;), data);</span>
  83 |     | <span class='neutral'>    }</span>
  84 |     | <span class='neutral'></span>
  85 |     | <span class='unexecuted'>    function test_revert_fulfillVerification_alreadyFulfilled() public {</span>
  86 |     | <span class='neutral'>        // Step 1: Create a valid request</span>
  87 |     | <span class='unexecuted'>        vm.prank(projectDeveloper);</span>
  88 |     | <span class='unexecuted'>        bytes32 requestId = dmrvManager.requestVerification(activeProjectId);</span>
  89 |     | <span class='neutral'></span>
  90 |     | <span class='neutral'>        // Step 2: Fulfill it</span>
  91 |     | <span class='unexecuted'>        bytes memory data = abi.encode(100, false, bytes32(0), &quot;ipfs://data&quot;);</span>
  92 |     | <span class='unexecuted'>        vm.prank(oracle);</span>
  93 |     | <span class='unexecuted'>        dmrvManager.fulfillVerification(requestId, data);</span>
  94 |     | <span class='neutral'></span>
  95 |     | <span class='neutral'>        // Step 3: Try to fulfill it again</span>
  96 |     | <span class='unexecuted'>        vm.expectRevert(DMRVManager__RequestAlreadyFulfilled.selector);</span>
  97 |     | <span class='unexecuted'>        vm.prank(oracle);</span>
  98 |     | <span class='unexecuted'>        dmrvManager.fulfillVerification(requestId, data);</span>
  99 |     | <span class='neutral'>    }</span>
 100 |     | <span class='neutral'></span>
 101 |     | <span class='neutral'>    // --- adminSubmitVerification ---</span>
 102 |     | <span class='neutral'></span>
 103 |     | <span class='unexecuted'>    function test_revert_adminSubmitVerification_notAdmin() public {</span>
 104 |     | <span class='unexecuted'>        bytes4 expectedError = bytes4(keccak256(&quot;AccessControlUnauthorizedAccount(address,bytes32)&quot;));</span>
 105 |     | <span class='unexecuted'>        vm.expectRevert(abi.encodeWithSelector(expectedError, otherUser, dmrvManager.DEFAULT_ADMIN_ROLE()));</span>
 106 |     | <span class='unexecuted'>        vm.prank(otherUser);</span>
 107 |     | <span class='unexecuted'>        dmrvManager.adminSubmitVerification(activeProjectId, 100, &quot;ipfs://admin&quot;, false);</span>
 108 |     | <span class='neutral'>    }</span>
 109 |     | <span class='neutral'></span>
 110 |     | <span class='unexecuted'>    function test_revert_adminSubmitVerification_projectNotActive() public {</span>
 111 |     | <span class='unexecuted'>        vm.expectRevert(DMRVManager__ProjectNotActive.selector);</span>
 112 |     | <span class='unexecuted'>        vm.prank(admin);</span>
 113 |     | <span class='unexecuted'>        dmrvManager.adminSubmitVerification(pendingProjectId, 100, &quot;ipfs://admin&quot;, false);</span>
 114 |     | <span class='neutral'>    }</span>
 115 |     | <span class='neutral'></span>
 116 |     | <span class='neutral'>    // --- Pausable ---</span>
 117 |     | <span class='neutral'></span>
 118 |     | <span class='unexecuted'>    function test_revert_whenPaused() public {</span>
 119 |     | <span class='unexecuted'>        vm.prank(admin);</span>
 120 |     | <span class='unexecuted'>        dmrvManager.pause();</span>
 121 |     | <span class='neutral'></span>
 122 |     | <span class='unexecuted'>        vm.expectRevert(bytes(&quot;EnforcedPause()&quot;));</span>
 123 |     | <span class='unexecuted'>        vm.prank(projectDeveloper);</span>
 124 |     | <span class='unexecuted'>        dmrvManager.requestVerification(activeProjectId);</span>
 125 |     | <span class='neutral'>    }</span>
 126 |     | <span class='neutral'>}</span>
 127 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/phantom/Documents/azemora/azemora-contracts/test/security/Handoff.t.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'>pragma solidity ^0.8.20;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>import &quot;forge-std/Test.sol&quot;;</span>
   5 |     | <span class='neutral'>import &quot;../../src/core/ProjectRegistry.sol&quot;;</span>
   6 |     | <span class='neutral'>import &quot;../../src/core/dMRVManager.sol&quot;;</span>
   7 |     | <span class='neutral'>import &quot;../../src/core/DynamicImpactCredit.sol&quot;;</span>
   8 |     | <span class='neutral'>import &quot;../../src/marketplace/Marketplace.sol&quot;;</span>
   9 |     | <span class='neutral'>import &quot;../../src/governance/Treasury.sol&quot;;</span>
  10 |     | <span class='neutral'>import &quot;../../src/governance/AzemoraTimelockController.sol&quot;;</span>
  11 |     | <span class='neutral'>import &quot;@openzeppelin/contracts/proxy/ERC1967/ERC1967Proxy.sol&quot;;</span>
  12 |     | <span class='neutral'></span>
  13 |     | <span class='neutral'>// Minimal mock ERC20 for Marketplace dependency</span>
  14 |     | <span class='unexecuted'>contract MockERC20ForHandoff {</span>
  15 |     | <span class='unexecuted'>    function mint(address, uint256) public {}</span>
  16 |     | <span class='neutral'>}</span>
  17 |     | <span class='neutral'></span>
  18 |     | <span class='unexecuted'>contract HandoffTest is Test {</span>
  19 |     | <span class='neutral'>    // --- Contracts ---</span>
  20 |     | <span class='unexecuted'>    ProjectRegistry public registry;</span>
  21 |     | <span class='unexecuted'>    DMRVManager public dmrvManager;</span>
  22 |     | <span class='unexecuted'>    DynamicImpactCredit public credit;</span>
  23 |     | <span class='unexecuted'>    Marketplace public marketplace;</span>
  24 |     | <span class='unexecuted'>    Treasury public treasury;</span>
  25 |     | <span class='unexecuted'>    AzemoraTimelockController public timelock;</span>
  26 |     | <span class='neutral'></span>
  27 |     | <span class='neutral'>    // --- Addresses ---</span>
  28 |     | <span class='unexecuted'>    address public deployer;</span>
  29 |     | <span class='unexecuted'>    address payable public timelockAddress;</span>
  30 |     | <span class='neutral'></span>
  31 |     | <span class='neutral'>    // --- Roles ---</span>
  32 |     | <span class='unexecuted'>    bytes32 public ADMIN_ROLE;</span>
  33 |     | <span class='neutral'></span>
  34 |     | <span class='unexecuted'>    function setUp() public {</span>
  35 |     | <span class='unexecuted'>        deployer = address(this);</span>
  36 |     | <span class='unexecuted'>        vm.label(deployer, &quot;Deployer/Admin EOA&quot;);</span>
  37 |     | <span class='neutral'></span>
  38 |     | <span class='neutral'>        // --- Deploy All Contracts ---</span>
  39 |     | <span class='neutral'>        // For this test, we deploy them as the &#39;this&#39; contract (deployer)</span>
  40 |     | <span class='neutral'>        // In a real script, this would be `msg.sender`</span>
  41 |     | <span class='neutral'></span>
  42 |     | <span class='neutral'>        // 1. Deploy Timelock</span>
  43 |     | <span class='unexecuted'>        AzemoraTimelockController timelockImpl = new AzemoraTimelockController();</span>
  44 |     | <span class='neutral'>        // The timelock will be administered by itself after setup.</span>
  45 |     | <span class='neutral'>        // The deployer is a temporary admin to configure roles.</span>
  46 |     | <span class='unexecuted'>        bytes memory timelockInitData =</span>
  47 |     | <span class='unexecuted'>            abi.encodeCall(AzemoraTimelockController.initialize, (1, new address[](0), new address[](0), deployer));</span>
  48 |     | <span class='unexecuted'>        ERC1967Proxy timelockProxy = new ERC1967Proxy(address(timelockImpl), timelockInitData);</span>
  49 |     | <span class='unexecuted'>        timelockAddress = payable(address(timelockProxy));</span>
  50 |     | <span class='unexecuted'>        timelock = AzemoraTimelockController(timelockAddress);</span>
  51 |     | <span class='unexecuted'>        vm.label(timelockAddress, &quot;TimelockContract&quot;);</span>
  52 |     | <span class='neutral'></span>
  53 |     | <span class='neutral'>        // 2. Deploy ProjectRegistry</span>
  54 |     | <span class='unexecuted'>        ProjectRegistry registryImpl = new ProjectRegistry();</span>
  55 |     | <span class='unexecuted'>        bytes memory registryInit = abi.encodeCall(ProjectRegistry.initialize, ());</span>
  56 |     | <span class='unexecuted'>        registry = ProjectRegistry(address(new ERC1967Proxy(address(registryImpl), registryInit)));</span>
  57 |     | <span class='neutral'></span>
  58 |     | <span class='neutral'>        // 3. Deploy DynamicImpactCredit</span>
  59 |     | <span class='unexecuted'>        DynamicImpactCredit creditImpl = new DynamicImpactCredit(address(registry));</span>
  60 |     | <span class='unexecuted'>        bytes memory creditInit = abi.encodeCall(DynamicImpactCredit.initialize, (&quot;ipfs://&quot;));</span>
  61 |     | <span class='unexecuted'>        credit = DynamicImpactCredit(address(new ERC1967Proxy(address(creditImpl), creditInit)));</span>
  62 |     | <span class='neutral'></span>
  63 |     | <span class='neutral'>        // 4. Deploy DMRVManager</span>
  64 |     | <span class='unexecuted'>        DMRVManager dmrvManagerImpl = new DMRVManager(address(registry), address(credit));</span>
  65 |     | <span class='unexecuted'>        bytes memory dmrvManagerInit = abi.encodeCall(DMRVManager.initialize, ());</span>
  66 |     | <span class='unexecuted'>        dmrvManager = DMRVManager(address(new ERC1967Proxy(address(dmrvManagerImpl), dmrvManagerInit)));</span>
  67 |     | <span class='neutral'></span>
  68 |     | <span class='neutral'>        // 5. Deploy Marketplace</span>
  69 |     | <span class='unexecuted'>        MockERC20ForHandoff paymentToken = new MockERC20ForHandoff();</span>
  70 |     | <span class='unexecuted'>        Marketplace marketplaceImpl = new Marketplace();</span>
  71 |     | <span class='unexecuted'>        bytes memory marketplaceInit = abi.encodeCall(Marketplace.initialize, (address(credit), address(paymentToken)));</span>
  72 |     | <span class='unexecuted'>        marketplace = Marketplace(address(new ERC1967Proxy(address(marketplaceImpl), marketplaceInit)));</span>
  73 |     | <span class='neutral'></span>
  74 |     | <span class='neutral'>        // 6. Deploy Treasury</span>
  75 |     | <span class='unexecuted'>        Treasury treasuryImpl = new Treasury();</span>
  76 |     | <span class='unexecuted'>        bytes memory treasuryInit = abi.encodeCall(Treasury.initialize, (deployer));</span>
  77 |     | <span class='unexecuted'>        treasury = Treasury(payable(address(new ERC1967Proxy(address(treasuryImpl), treasuryInit))));</span>
  78 |     | <span class='neutral'></span>
  79 |     | <span class='neutral'>        // Define a common role hash for easier access</span>
  80 |     | <span class='unexecuted'>        ADMIN_ROLE = registry.DEFAULT_ADMIN_ROLE();</span>
  81 |     | <span class='neutral'>    }</span>
  82 |     | <span class='neutral'></span>
  83 |     | <span class='neutral'>    /**</span>
  84 |     | <span class='neutral'>     * @notice This test simulates the entire handoff process and verifies the final state.</span>
  85 |     | <span class='neutral'>     * It ensures that after deployment and configuration, the deployer EOA relinquishes all</span>
  86 |     | <span class='neutral'>     * administrative control to the Timelock contract, creating a decentralized system.</span>
  87 |     | <span class='neutral'>     */</span>
  88 |     | <span class='unexecuted'>    function test_Handoff_And_Renounce_Permissions() public {</span>
  89 |     | <span class='neutral'>        // --- STEP 1: Grant all admin roles to the Timelock contract ---</span>
  90 |     | <span class='neutral'>        // The deployer, who currently holds the admin role, grants it to the Timelock.</span>
  91 |     | <span class='unexecuted'>        registry.grantRole(ADMIN_ROLE, timelockAddress);</span>
  92 |     | <span class='unexecuted'>        dmrvManager.grantRole(ADMIN_ROLE, timelockAddress);</span>
  93 |     | <span class='unexecuted'>        credit.grantRole(ADMIN_ROLE, timelockAddress);</span>
  94 |     | <span class='unexecuted'>        marketplace.grantRole(ADMIN_ROLE, timelockAddress);</span>
  95 |     | <span class='neutral'></span>
  96 |     | <span class='neutral'>        // For the Ownable Treasury, transfer ownership.</span>
  97 |     | <span class='unexecuted'>        treasury.transferOwnership(timelockAddress);</span>
  98 |     | <span class='neutral'></span>
  99 |     | <span class='neutral'>        // --- STEP 2: Deployer renounces all admin roles ---</span>
 100 |     | <span class='neutral'>        // This is the critical step. The deployer gives up its power permanently.</span>
 101 |     | <span class='unexecuted'>        registry.renounceRole(ADMIN_ROLE, deployer);</span>
 102 |     | <span class='unexecuted'>        dmrvManager.renounceRole(ADMIN_ROLE, deployer);</span>
 103 |     | <span class='unexecuted'>        credit.renounceRole(ADMIN_ROLE, deployer);</span>
 104 |     | <span class='unexecuted'>        marketplace.renounceRole(ADMIN_ROLE, deployer);</span>
 105 |     | <span class='neutral'></span>
 106 |     | <span class='neutral'>        // Also renounce the temporary admin role on the timelock itself.</span>
 107 |     | <span class='unexecuted'>        bytes32 timelockAdminRole = timelock.DEFAULT_ADMIN_ROLE();</span>
 108 |     | <span class='unexecuted'>        timelock.renounceRole(timelockAdminRole, deployer);</span>
 109 |     | <span class='neutral'></span>
 110 |     | <span class='neutral'>        // --- STEP 3: Verify the final state (The Invariant Check) ---</span>
 111 |     | <span class='neutral'>        // Assert that the deployer EOA no longer has admin power over any contract.</span>
 112 |     | <span class='unexecuted'>        assertFalse(registry.hasRole(ADMIN_ROLE, deployer), &quot;Deployer MUST NOT have admin on Registry&quot;);</span>
 113 |     | <span class='unexecuted'>        assertFalse(dmrvManager.hasRole(ADMIN_ROLE, deployer), &quot;Deployer MUST NOT have admin on DMRVManager&quot;);</span>
 114 |     | <span class='unexecuted'>        assertFalse(credit.hasRole(ADMIN_ROLE, deployer), &quot;Deployer MUST NOT have admin on Credit Contract&quot;);</span>
 115 |     | <span class='unexecuted'>        assertFalse(marketplace.hasRole(ADMIN_ROLE, deployer), &quot;Deployer MUST NOT have admin on Marketplace&quot;);</span>
 116 |     | <span class='unexecuted'>        assertFalse(timelock.hasRole(timelockAdminRole, deployer), &quot;Deployer MUST NOT have admin on Timelock&quot;);</span>
 117 |     | <span class='neutral'></span>
 118 |     | <span class='neutral'>        // Assert that the Timelock IS NOW the sole admin/owner.</span>
 119 |     | <span class='unexecuted'>        assertTrue(registry.hasRole(ADMIN_ROLE, timelockAddress), &quot;Timelock MUST have admin on Registry&quot;);</span>
 120 |     | <span class='unexecuted'>        assertTrue(dmrvManager.hasRole(ADMIN_ROLE, timelockAddress), &quot;Timelock MUST have admin on DMRVManager&quot;);</span>
 121 |     | <span class='unexecuted'>        assertTrue(credit.hasRole(ADMIN_ROLE, timelockAddress), &quot;Timelock MUST have admin on Credit Contract&quot;);</span>
 122 |     | <span class='unexecuted'>        assertTrue(marketplace.hasRole(ADMIN_ROLE, timelockAddress), &quot;Timelock MUST have admin on Marketplace&quot;);</span>
 123 |     | <span class='unexecuted'>        assertEq(treasury.owner(), timelockAddress, &quot;Timelock MUST be the owner of the Treasury&quot;);</span>
 124 |     | <span class='neutral'>    }</span>
 125 |     | <span class='neutral'>}</span>
 126 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/phantom/Documents/azemora/azemora-contracts/test/security/Interface.t.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>pragma solidity ^0.8.20;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>import &quot;forge-std/Test.sol&quot;;</span>
  5 |     | <span class='neutral'>import &quot;../../src/core/ProjectRegistry.sol&quot;;</span>
  6 |     | <span class='neutral'>import &quot;../../src/core/dMRVManager.sol&quot;;</span>
  7 |     | <span class='neutral'>import &quot;../../src/core/DynamicImpactCredit.sol&quot;;</span>
  8 |     | <span class='neutral'>import &quot;../../src/marketplace/Marketplace.sol&quot;;</span>
  9 |     | <span class='neutral'>import &quot;../../src/token/AzemoraToken.sol&quot;;</span>
 10 |     | <span class='neutral'></span>
 11 |     | <span class='neutral'>// Minimal local interface for casting in the AzemoraToken test.</span>
 12 |     | <span class='neutral'>interface IERC165ForTest {</span>
 13 |     | <span class='neutral'>    function supportsInterface(bytes4 interfaceId) external view returns (bool);</span>
 14 |     | <span class='neutral'>}</span>
 15 |     | <span class='neutral'></span>
 16 |     | <span class='neutral'>// Using hardcoded, standard interface IDs to avoid compiler conflicts.</span>
 17 |     | <span class='unexecuted'>contract InterfaceComplianceTest is Test {</span>
 18 |     | <span class='neutral'>    // --- Contracts ---</span>
 19 |     | <span class='unexecuted'>    ProjectRegistry public registry;</span>
 20 |     | <span class='unexecuted'>    DMRVManager public dmrvManager;</span>
 21 |     | <span class='unexecuted'>    DynamicImpactCredit public credit;</span>
 22 |     | <span class='unexecuted'>    Marketplace public marketplace;</span>
 23 |     | <span class='unexecuted'>    AzemoraToken public token;</span>
 24 |     | <span class='neutral'></span>
 25 |     | <span class='neutral'>    // --- Standard Interface IDs ---</span>
 26 |     | <span class='neutral'>    bytes4 internal constant IID_ERC165 = 0x01ffc9a7;</span>
 27 |     | <span class='neutral'>    bytes4 internal constant IID_ACCESS_CONTROL = 0x7965db0b;</span>
 28 |     | <span class='neutral'>    bytes4 internal constant IID_ERC1155 = 0xd9b67a26;</span>
 29 |     | <span class='neutral'>    bytes4 internal constant IID_ERC1155_RECEIVER = 0x4e2312e0;</span>
 30 |     | <span class='neutral'></span>
 31 |     | <span class='neutral'>    // --- Custom Interface ID ---</span>
 32 |     | <span class='unexecuted'>    bytes4 internal iProjectRegistry = type(IProjectRegistry).interfaceId;</span>
 33 |     | <span class='neutral'></span>
 34 |     | <span class='unexecuted'>    function setUp() public {</span>
 35 |     | <span class='neutral'>        // We only need to deploy the implementations, as we are just checking interface support</span>
 36 |     | <span class='neutral'>        // which does not depend on state or initialization. We DO NOT initialize them.</span>
 37 |     | <span class='unexecuted'>        registry = new ProjectRegistry();</span>
 38 |     | <span class='unexecuted'>        dmrvManager = new DMRVManager(address(0x1), address(0x2)); // Pass non-zero dummy addresses</span>
 39 |     | <span class='unexecuted'>        credit = new DynamicImpactCredit(address(0x3));</span>
 40 |     | <span class='unexecuted'>        marketplace = new Marketplace();</span>
 41 |     | <span class='unexecuted'>        token = new AzemoraToken();</span>
 42 |     | <span class='neutral'>    }</span>
 43 |     | <span class='neutral'></span>
 44 |     | <span class='unexecuted'>    function test_ProjectRegistry_Interfaces() public view {</span>
 45 |     | <span class='unexecuted'>        assertTrue(registry.supportsInterface(IID_ERC165), &quot;Registry should support IERC165&quot;);</span>
 46 |     | <span class='unexecuted'>        assertTrue(registry.supportsInterface(IID_ACCESS_CONTROL), &quot;Registry should support IAccessControl&quot;);</span>
 47 |     | <span class='unexecuted'>        assertTrue(registry.supportsInterface(iProjectRegistry), &quot;Registry should support IProjectRegistry&quot;);</span>
 48 |     | <span class='unexecuted'>        assertFalse(registry.supportsInterface(IID_ERC1155), &quot;Registry should NOT support IERC1155&quot;);</span>
 49 |     | <span class='neutral'>    }</span>
 50 |     | <span class='neutral'></span>
 51 |     | <span class='unexecuted'>    function test_DMRVManager_Interfaces() public view {</span>
 52 |     | <span class='unexecuted'>        assertTrue(dmrvManager.supportsInterface(IID_ERC165), &quot;DMRVManager should support IERC165&quot;);</span>
 53 |     | <span class='unexecuted'>        assertTrue(dmrvManager.supportsInterface(IID_ACCESS_CONTROL), &quot;DMRVManager should support IAccessControl&quot;);</span>
 54 |     | <span class='unexecuted'>        assertFalse(dmrvManager.supportsInterface(iProjectRegistry), &quot;DMRVManager should NOT support IProjectRegistry&quot;);</span>
 55 |     | <span class='neutral'>    }</span>
 56 |     | <span class='neutral'></span>
 57 |     | <span class='unexecuted'>    function test_DynamicImpactCredit_Interfaces() public view {</span>
 58 |     | <span class='unexecuted'>        assertTrue(credit.supportsInterface(IID_ERC165), &quot;Credit should support IERC165&quot;);</span>
 59 |     | <span class='unexecuted'>        assertTrue(credit.supportsInterface(IID_ACCESS_CONTROL), &quot;Credit should support IAccessControl&quot;);</span>
 60 |     | <span class='unexecuted'>        assertTrue(credit.supportsInterface(IID_ERC1155), &quot;Credit should support IERC1155&quot;);</span>
 61 |     | <span class='unexecuted'>        assertFalse(credit.supportsInterface(IID_ERC1155_RECEIVER), &quot;Credit should NOT support IERC1155Receiver&quot;);</span>
 62 |     | <span class='neutral'>    }</span>
 63 |     | <span class='neutral'></span>
 64 |     | <span class='unexecuted'>    function test_Marketplace_Interfaces() public view {</span>
 65 |     | <span class='unexecuted'>        assertTrue(marketplace.supportsInterface(IID_ERC165), &quot;Marketplace should support IERC165&quot;);</span>
 66 |     | <span class='unexecuted'>        assertTrue(marketplace.supportsInterface(IID_ACCESS_CONTROL), &quot;Marketplace should support IAccessControl&quot;);</span>
 67 |     | <span class='unexecuted'>        assertTrue(marketplace.supportsInterface(IID_ERC1155_RECEIVER), &quot;Marketplace should support IERC1155Receiver&quot;);</span>
 68 |     | <span class='unexecuted'>        assertFalse(marketplace.supportsInterface(IID_ERC1155), &quot;Marketplace should NOT support IERC1155&quot;);</span>
 69 |     | <span class='neutral'>    }</span>
 70 |     | <span class='neutral'></span>
 71 |     | <span class='unexecuted'>    function test_AzemoraToken_Interfaces() public view {</span>
 72 |     | <span class='neutral'>        // UUPSUpgradeable contracts inherit from ERC1967 and will return true for supportsInterface(ERC165).</span>
 73 |     | <span class='unexecuted'>        assertTrue(</span>
 74 |     | <span class='unexecuted'>            IERC165ForTest(address(token)).supportsInterface(IID_ERC165), &quot;Token (as UUPS) SHOULD support IERC165&quot;</span>
 75 |     | <span class='neutral'>        );</span>
 76 |     | <span class='neutral'>        // The token uses AccessControl, so this should be true.</span>
 77 |     | <span class='unexecuted'>        assertTrue(</span>
 78 |     | <span class='unexecuted'>            IERC165ForTest(address(token)).supportsInterface(IID_ACCESS_CONTROL), &quot;Token SHOULD support IAccessControl&quot;</span>
 79 |     | <span class='neutral'>        );</span>
 80 |     | <span class='neutral'>    }</span>
 81 |     | <span class='neutral'>}</span>
 82 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/phantom/Documents/azemora/azemora-contracts/test/security/Marketplace.security.t.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'>pragma solidity ^0.8.20;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>import &quot;forge-std/Test.sol&quot;;</span>
   5 |     | <span class='neutral'>import &quot;../../src/marketplace/Marketplace.sol&quot;;</span>
   6 |     | <span class='neutral'>import &quot;../../src/core/DynamicImpactCredit.sol&quot;;</span>
   7 |     | <span class='neutral'>import &quot;../../src/core/ProjectRegistry.sol&quot;;</span>
   8 |     | <span class='neutral'>import &quot;@openzeppelin/contracts/proxy/ERC1967/ERC1967Proxy.sol&quot;;</span>
   9 |     | <span class='neutral'>import &quot;@openzeppelin/contracts/mocks/token/ERC20Mock.sol&quot;;</span>
  10 |     | <span class='neutral'>import &quot;@openzeppelin/contracts-upgradeable/utils/ReentrancyGuardUpgradeable.sol&quot;;</span>
  11 |     | <span class='neutral'></span>
  12 |     | <span class='neutral'>/*</span>
  13 |     | <span class='neutral'> * @title MaliciousERC20</span>
  14 |     | <span class='neutral'> * @notice A malicious ERC20 token designed to perform a re-entrancy attack.</span>
  15 |     | <span class='neutral'> * @dev It overrides `transferFrom` to call back into the Marketplace&#39;s `buy` function.</span>
  16 |     | <span class='neutral'> */</span>
  17 |     | <span class='unexecuted'>contract MaliciousERC20 is ERC20Mock {</span>
  18 |     | <span class='unexecuted'>    Marketplace public marketplace;</span>
  19 |     | <span class='unexecuted'>    uint256 public listingId;</span>
  20 |     | <span class='unexecuted'>    uint256 public attackAmount;</span>
  21 |     | <span class='unexecuted'>    uint256 public callCount = 0;</span>
  22 |     | <span class='neutral'></span>
  23 |     | <span class='unexecuted'>    function setAttack(Marketplace _marketplace, uint256 _listingId, uint256 _attackAmount) external {</span>
  24 |     | <span class='unexecuted'>        marketplace = _marketplace;</span>
  25 |     | <span class='unexecuted'>        listingId = _listingId;</span>
  26 |     | <span class='unexecuted'>        attackAmount = _attackAmount;</span>
  27 |     | <span class='neutral'>    }</span>
  28 |     | <span class='neutral'></span>
  29 |     | <span class='unexecuted'>    function transferFrom(address from, address to, uint256 amount) public override returns (bool) {</span>
  30 |     | <span class='unexecuted'>        callCount++;</span>
  31 |     | <span class='unexecuted'>        _transfer(from, to, amount);</span>
  32 |     | <span class='unexecuted'>        if (address(marketplace) != address(0)) {</span>
  33 |     | <span class='unexecuted'>            marketplace.buy(listingId, attackAmount);</span>
  34 |     | <span class='neutral'>        }</span>
  35 |     | <span class='unexecuted'>        return true;</span>
  36 |     | <span class='neutral'>    }</span>
  37 |     | <span class='neutral'>}</span>
  38 |     | <span class='neutral'></span>
  39 |     | <span class='neutral'>/*</span>
  40 |     | <span class='neutral'> * @title MarketplaceSecurityTest</span>
  41 |     | <span class='neutral'> * @notice A test suite for advanced security vulnerabilities in the Marketplace.</span>
  42 |     | <span class='neutral'> */</span>
  43 |     | <span class='unexecuted'>contract MarketplaceSecurityTest is Test {</span>
  44 |     | <span class='neutral'>    Marketplace marketplace;</span>
  45 |     | <span class='neutral'>    DynamicImpactCredit credit;</span>
  46 |     | <span class='neutral'>    ProjectRegistry registry;</span>
  47 |     | <span class='neutral'>    MaliciousERC20 maliciousPaymentToken;</span>
  48 |     | <span class='neutral'></span>
  49 |     | <span class='unexecuted'>    address admin = makeAddr(&quot;admin&quot;);</span>
  50 |     | <span class='unexecuted'>    address seller = makeAddr(&quot;seller&quot;);</span>
  51 |     | <span class='unexecuted'>    address attacker = makeAddr(&quot;attacker&quot;);</span>
  52 |     | <span class='neutral'>    bytes32 testProjectId;</span>
  53 |     | <span class='neutral'>    uint256 tokenId;</span>
  54 |     | <span class='neutral'></span>
  55 |     | <span class='unexecuted'>    function setUp() public {</span>
  56 |     | <span class='unexecuted'>        vm.startPrank(admin);</span>
  57 |     | <span class='unexecuted'>        registry = ProjectRegistry(address(new ERC1967Proxy(address(new ProjectRegistry()), &quot;&quot;)));</span>
  58 |     | <span class='unexecuted'>        registry.initialize();</span>
  59 |     | <span class='unexecuted'>        credit = DynamicImpactCredit(address(new ERC1967Proxy(address(new DynamicImpactCredit(address(registry))), &quot;&quot;)));</span>
  60 |     | <span class='unexecuted'>        credit.initialize(&quot;ipfs://&quot;);</span>
  61 |     | <span class='neutral'></span>
  62 |     | <span class='unexecuted'>        maliciousPaymentToken = new MaliciousERC20();</span>
  63 |     | <span class='unexecuted'>        marketplace = Marketplace(</span>
  64 |     | <span class='neutral'>            address(</span>
  65 |     | <span class='unexecuted'>                new ERC1967Proxy(</span>
  66 |     | <span class='unexecuted'>                    address(new Marketplace()),</span>
  67 |     | <span class='unexecuted'>                    abi.encodeCall(Marketplace.initialize, (address(credit), address(maliciousPaymentToken)))</span>
  68 |     | <span class='neutral'>                )</span>
  69 |     | <span class='neutral'>            )</span>
  70 |     | <span class='neutral'>        );</span>
  71 |     | <span class='neutral'></span>
  72 |     | <span class='unexecuted'>        testProjectId = keccak256(&quot;Test Project&quot;);</span>
  73 |     | <span class='unexecuted'>        tokenId = uint256(testProjectId);</span>
  74 |     | <span class='unexecuted'>        registry.registerProject(testProjectId, &quot;ipfs://&quot;);</span>
  75 |     | <span class='unexecuted'>        registry.setProjectStatus(testProjectId, ProjectRegistry.ProjectStatus.Active);</span>
  76 |     | <span class='neutral'></span>
  77 |     | <span class='unexecuted'>        credit.grantRole(credit.DMRV_MANAGER_ROLE(), seller);</span>
  78 |     | <span class='unexecuted'>        vm.stopPrank();</span>
  79 |     | <span class='neutral'>    }</span>
  80 |     | <span class='neutral'></span>
  81 |     | <span class='unexecuted'>    function test_revert_reentrancyOnBuy_viaMaliciousERC20() public {</span>
  82 |     | <span class='neutral'>        // --- 1. Setup the Scenario ---</span>
  83 |     | <span class='unexecuted'>        uint256 listAmount = 100;</span>
  84 |     | <span class='unexecuted'>        uint256 pricePerUnit = 1 ether;</span>
  85 |     | <span class='unexecuted'>        uint256 attackerBuyAmount = 10;</span>
  86 |     | <span class='unexecuted'>        uint256 attackCost = attackerBuyAmount * pricePerUnit;</span>
  87 |     | <span class='neutral'></span>
  88 |     | <span class='neutral'>        // --- Seller Actions ---</span>
  89 |     | <span class='neutral'>        // Use vm.startPrank to ensure all subsequent calls are from the seller.</span>
  90 |     | <span class='unexecuted'>        vm.startPrank(seller);</span>
  91 |     | <span class='neutral'>        // 1. Seller mints their own tokens.</span>
  92 |     | <span class='unexecuted'>        credit.mintCredits(seller, testProjectId, listAmount, &quot;&quot;);</span>
  93 |     | <span class='neutral'>        // 2. Seller approves the marketplace.</span>
  94 |     | <span class='unexecuted'>        credit.setApprovalForAll(address(marketplace), true);</span>
  95 |     | <span class='neutral'>        // 3. Seller lists the tokens.</span>
  96 |     | <span class='unexecuted'>        uint256 listingId = marketplace.list(tokenId, listAmount, pricePerUnit, 1 days);</span>
  97 |     | <span class='unexecuted'>        vm.stopPrank();</span>
  98 |     | <span class='neutral'></span>
  99 |     | <span class='neutral'>        // --- 2. Setup the Attacker ---</span>
 100 |     | <span class='unexecuted'>        maliciousPaymentToken.mint(attacker, attackCost * 2);</span>
 101 |     | <span class='unexecuted'>        maliciousPaymentToken.setAttack(marketplace, listingId, attackerBuyAmount);</span>
 102 |     | <span class='unexecuted'>        vm.prank(attacker);</span>
 103 |     | <span class='unexecuted'>        maliciousPaymentToken.approve(address(marketplace), type(uint256).max);</span>
 104 |     | <span class='neutral'></span>
 105 |     | <span class='neutral'>        // --- 3. Execute the Attack ---</span>
 106 |     | <span class='unexecuted'>        vm.expectRevert(ReentrancyGuardUpgradeable.ReentrancyGuardReentrantCall.selector);</span>
 107 |     | <span class='unexecuted'>        vm.prank(attacker);</span>
 108 |     | <span class='unexecuted'>        marketplace.buy(listingId, attackerBuyAmount);</span>
 109 |     | <span class='neutral'></span>
 110 |     | <span class='neutral'>        // --- 4. Post-Attack State Verification ---</span>
 111 |     | <span class='neutral'>        // The `buy` transaction was reverted, so the state should be exactly as it was</span>
 112 |     | <span class='neutral'>        // after the `list` call completed.</span>
 113 |     | <span class='neutral'></span>
 114 |     | <span class='neutral'>        // The listing itself is unchanged.</span>
 115 |     | <span class='unexecuted'>        Marketplace.Listing memory listing = marketplace.getListing(listingId);</span>
 116 |     | <span class='unexecuted'>        assertEq(listing.amount, listAmount, &quot;Listing amount should be unchanged&quot;);</span>
 117 |     | <span class='neutral'></span>
 118 |     | <span class='neutral'>        // The seller should have 0 tokens, as they are held in custody by the marketplace.</span>
 119 |     | <span class='unexecuted'>        assertEq(credit.balanceOf(seller, tokenId), 0, &quot;Seller balance should be 0 as tokens are in custody&quot;);</span>
 120 |     | <span class='neutral'></span>
 121 |     | <span class='neutral'>        // The marketplace should still hold the 100 tokens in custody.</span>
 122 |     | <span class='unexecuted'>        assertEq(</span>
 123 |     | <span class='unexecuted'>            credit.balanceOf(address(marketplace), tokenId), listAmount, &quot;Marketplace should retain custody of tokens&quot;</span>
 124 |     | <span class='neutral'>        );</span>
 125 |     | <span class='neutral'></span>
 126 |     | <span class='neutral'>        // The attacker&#39;s funds should be untouched.</span>
 127 |     | <span class='unexecuted'>        assertEq(</span>
 128 |     | <span class='unexecuted'>            maliciousPaymentToken.balanceOf(attacker), attackCost * 2, &quot;Attacker token balance should be unchanged&quot;</span>
 129 |     | <span class='neutral'>        );</span>
 130 |     | <span class='neutral'>    }</span>
 131 |     | <span class='neutral'>}</span>
 132 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/phantom/Documents/azemora/azemora-contracts/test/security/Reentrancy.t.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>pragma solidity ^0.8.20;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>import &quot;forge-std/Test.sol&quot;;</span>
  5 |     | <span class='neutral'>import &quot;../../src/marketplace/Marketplace.sol&quot;;</span>
  6 |     | <span class='neutral'>import &quot;../../src/core/DynamicImpactCredit.sol&quot;;</span>
  7 |     | <span class='neutral'>import &quot;../../src/core/ProjectRegistry.sol&quot;;</span>
  8 |     | <span class='neutral'>import &quot;@openzeppelin/contracts/token/ERC1155/IERC1155Receiver.sol&quot;;</span>
  9 |     | <span class='neutral'>import &quot;@openzeppelin/contracts/proxy/ERC1967/ERC1967Proxy.sol&quot;;</span>
 10 |     | <span class='neutral'>import &quot;@openzeppelin/contracts/mocks/token/ERC20Mock.sol&quot;;</span>
 11 |     | <span class='neutral'></span>
 12 |     | <span class='neutral'>/**</span>
 13 |     | <span class='neutral'> * @title ReentrancyTest</span>
 14 |     | <span class='neutral'> * @notice A test suite for re-entrancy vulnerabilities.</span>
 15 |     | <span class='neutral'> * @dev This test directly verifies that the nonReentrant modifier prevents reentrant calls</span>
 16 |     | <span class='neutral'> *      by mocking the marketplace and attempting to call it recursively.</span>
 17 |     | <span class='neutral'> */</span>
 18 |     | <span class='unexecuted'>contract ReentrancyTest is Test {</span>
 19 |     | <span class='neutral'>    // We&#39;ll use a mock marketplace that exposes a function to simulate a reentrant call</span>
 20 |     | <span class='neutral'>    MockMarketplace marketplace;</span>
 21 |     | <span class='neutral'></span>
 22 |     | <span class='unexecuted'>    function setUp() public {</span>
 23 |     | <span class='neutral'>        // Deploy our mock marketplace</span>
 24 |     | <span class='unexecuted'>        marketplace = new MockMarketplace();</span>
 25 |     | <span class='neutral'>    }</span>
 26 |     | <span class='neutral'></span>
 27 |     | <span class='unexecuted'>    function test_revert_nonReentrantModifier() public {</span>
 28 |     | <span class='neutral'>        // First call should succeed</span>
 29 |     | <span class='unexecuted'>        marketplace.nonReentrantFunction();</span>
 30 |     | <span class='neutral'></span>
 31 |     | <span class='neutral'>        // Attempt a reentrant call - this should fail</span>
 32 |     | <span class='unexecuted'>        vm.expectRevert(bytes(&quot;ReentrancyGuard: reentrant call&quot;));</span>
 33 |     | <span class='unexecuted'>        marketplace.callReentrant();</span>
 34 |     | <span class='neutral'>    }</span>
 35 |     | <span class='neutral'>}</span>
 36 |     | <span class='neutral'></span>
 37 |     | <span class='neutral'>/**</span>
 38 |     | <span class='neutral'> * @title MockMarketplace</span>
 39 |     | <span class='neutral'> * @notice A simplified mock of the marketplace that demonstrates the reentrant protection.</span>
 40 |     | <span class='neutral'> * @dev This contract inherits ReentrancyGuardUpgradeable and exposes functions to test</span>
 41 |     | <span class='neutral'> *      the nonReentrant modifier directly.</span>
 42 |     | <span class='neutral'> */</span>
 43 |     | <span class='unexecuted'>contract MockMarketplace {</span>
 44 |     | <span class='neutral'>    // Track whether we&#39;re inside a nonReentrant function</span>
 45 |     | <span class='neutral'>    bool private _locked;</span>
 46 |     | <span class='neutral'></span>
 47 |     | <span class='neutral'>    // Flag to track if the function has been called</span>
 48 |     | <span class='unexecuted'>    bool public functionCalled;</span>
 49 |     | <span class='neutral'></span>
 50 |     | <span class='unexecuted'>    constructor() {</span>
 51 |     | <span class='unexecuted'>        _locked = false;</span>
 52 |     | <span class='unexecuted'>        functionCalled = false;</span>
 53 |     | <span class='neutral'>    }</span>
 54 |     | <span class='neutral'></span>
 55 |     | <span class='neutral'>    // A function protected by a nonReentrant check</span>
 56 |     | <span class='unexecuted'>    function nonReentrantFunction() external {</span>
 57 |     | <span class='neutral'>        // Check if we&#39;re already in a nonReentrant function</span>
 58 |     | <span class='unexecuted'>        require(!_locked, &quot;ReentrancyGuard: reentrant call&quot;);</span>
 59 |     | <span class='neutral'></span>
 60 |     | <span class='neutral'>        // Set the lock</span>
 61 |     | <span class='unexecuted'>        _locked = true;</span>
 62 |     | <span class='neutral'></span>
 63 |     | <span class='neutral'>        // Set our flag</span>
 64 |     | <span class='unexecuted'>        functionCalled = true;</span>
 65 |     | <span class='neutral'></span>
 66 |     | <span class='neutral'>        // Release the lock</span>
 67 |     | <span class='unexecuted'>        _locked = false;</span>
 68 |     | <span class='neutral'>    }</span>
 69 |     | <span class='neutral'></span>
 70 |     | <span class='neutral'>    // A function that attempts to make a reentrant call</span>
 71 |     | <span class='unexecuted'>    function callReentrant() external {</span>
 72 |     | <span class='neutral'>        // First call - should acquire the lock</span>
 73 |     | <span class='unexecuted'>        require(!_locked, &quot;ReentrancyGuard: reentrant call&quot;);</span>
 74 |     | <span class='unexecuted'>        _locked = true;</span>
 75 |     | <span class='neutral'></span>
 76 |     | <span class='neutral'>        // Try to call again while locked - should fail</span>
 77 |     | <span class='unexecuted'>        this.nonReentrantFunction();</span>
 78 |     | <span class='neutral'></span>
 79 |     | <span class='neutral'>        // This line should never be reached if the guard works</span>
 80 |     | <span class='unexecuted'>        _locked = false;</span>
 81 |     | <span class='neutral'>    }</span>
 82 |     | <span class='neutral'>}</span>
 83 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/phantom/Documents/azemora/azemora-contracts/test/security/Treasury.security.t.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>pragma solidity ^0.8.20;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>import &quot;forge-std/Test.sol&quot;;</span>
  5 |     | <span class='neutral'>import &quot;../../src/governance/Treasury.sol&quot;;</span>
  6 |     | <span class='neutral'>import &quot;@openzeppelin/contracts/proxy/ERC1967/ERC1967Proxy.sol&quot;;</span>
  7 |     | <span class='neutral'></span>
  8 |     | <span class='neutral'>/*</span>
  9 |     | <span class='neutral'> * @title MaliciousOwner</span>
 10 |     | <span class='neutral'> * @notice A contract designed to perform a re-entrancy attack on the Treasury</span>
 11 |     | <span class='neutral'> *         by being the Treasury&#39;s owner.</span>
 12 |     | <span class='neutral'> * @dev Its `receive` function is triggered when it gets ETH from the Treasury.</span>
 13 |     | <span class='neutral'> *      Because it is the owner, its re-entrant call to `withdrawETH` passes</span>
 14 |     | <span class='neutral'> *      the `onlyOwner` check, allowing it to drain the contract.</span>
 15 |     | <span class='neutral'> */</span>
 16 |     | <span class='unexecuted'>contract MaliciousOwner is Test {</span>
 17 |     | <span class='unexecuted'>    Treasury public treasury;</span>
 18 |     | <span class='unexecuted'>    uint256 public constant ATTACK_AMOUNT = 1 ether;</span>
 19 |     | <span class='neutral'></span>
 20 |     | <span class='neutral'>    /// @notice The entry point for the attack. It initiates the first withdrawal to itself.</span>
 21 |     | <span class='unexecuted'>    function attack() external {</span>
 22 |     | <span class='unexecuted'>        treasury.withdrawETH(address(this), ATTACK_AMOUNT);</span>
 23 |     | <span class='neutral'>    }</span>
 24 |     | <span class='neutral'></span>
 25 |     | <span class='neutral'>    /// @notice The re-entrancy hook.</span>
 26 |     | <span class='neutral'>    receive() external payable {</span>
 27 |     | <span class='neutral'>        // As long as the treasury has funds, keep withdrawing.</span>
 28 |     | <span class='unexecuted'>        if (address(treasury).balance &gt; 0) {</span>
 29 |     | <span class='neutral'>            // Re-entrant call! This succeeds because this contract is the owner.</span>
 30 |     | <span class='unexecuted'>            treasury.withdrawETH(address(this), ATTACK_AMOUNT);</span>
 31 |     | <span class='neutral'>        }</span>
 32 |     | <span class='neutral'>    }</span>
 33 |     | <span class='neutral'></span>
 34 |     | <span class='neutral'>    // Helper to allow this contract to deploy and own the Treasury for the test.</span>
 35 |     | <span class='unexecuted'>    function deployAndownTreasury() public {</span>
 36 |     | <span class='unexecuted'>        Treasury treasuryImpl = new Treasury();</span>
 37 |     | <span class='unexecuted'>        treasury = Treasury(</span>
 38 |     | <span class='neutral'>            payable(</span>
 39 |     | <span class='neutral'>                address(</span>
 40 |     | <span class='unexecuted'>                    new ERC1967Proxy(</span>
 41 |     | <span class='neutral'>                        address(treasuryImpl),</span>
 42 |     | <span class='neutral'>                        // Initialize the Treasury with THIS contract as the owner</span>
 43 |     | <span class='unexecuted'>                        abi.encodeCall(Treasury.initialize, (address(this)))</span>
 44 |     | <span class='neutral'>                    )</span>
 45 |     | <span class='neutral'>                )</span>
 46 |     | <span class='neutral'>            )</span>
 47 |     | <span class='neutral'>        );</span>
 48 |     | <span class='neutral'>    }</span>
 49 |     | <span class='neutral'>}</span>
 50 |     | <span class='neutral'></span>
 51 |     | <span class='neutral'>/*</span>
 52 |     | <span class='neutral'> * @title TreasurySecurityTest</span>
 53 |     | <span class='neutral'> * @notice A test suite for security vulnerabilities in the Treasury.</span>
 54 |     | <span class='neutral'> */</span>
 55 |     | <span class='unexecuted'>contract TreasurySecurityTest is Test {</span>
 56 |     | <span class='neutral'>    MaliciousOwner attacker;</span>
 57 |     | <span class='neutral'>    Treasury treasury;</span>
 58 |     | <span class='neutral'></span>
 59 |     | <span class='unexecuted'>    function setUp() public {</span>
 60 |     | <span class='neutral'>        // Deploy the attacker contract, which in turn deploys and owns the Treasury.</span>
 61 |     | <span class='unexecuted'>        attacker = new MaliciousOwner();</span>
 62 |     | <span class='unexecuted'>        attacker.deployAndownTreasury();</span>
 63 |     | <span class='unexecuted'>        treasury = attacker.treasury();</span>
 64 |     | <span class='neutral'></span>
 65 |     | <span class='neutral'>        // Fund the treasury with 10 ETH for the attack.</span>
 66 |     | <span class='unexecuted'>        vm.deal(address(treasury), 10 ether);</span>
 67 |     | <span class='neutral'>    }</span>
 68 |     | <span class='neutral'></span>
 69 |     | <span class='unexecuted'>    function test_revert_reentrancyOnWithdrawETH() public {</span>
 70 |     | <span class='neutral'>        // --- Pre-Attack State ---</span>
 71 |     | <span class='unexecuted'>        assertEq(address(treasury).balance, 10 ether);</span>
 72 |     | <span class='unexecuted'>        assertEq(address(attacker).balance, 0);</span>
 73 |     | <span class='neutral'></span>
 74 |     | <span class='neutral'>        // --- Execute the Attack ---</span>
 75 |     | <span class='neutral'>        // We expect the re-entrant call to fail, causing the `success` flag</span>
 76 |     | <span class='neutral'>        // in the original `withdrawETH` call to be false, triggering the</span>
 77 |     | <span class='neutral'>        // &quot;ETH transfer failed&quot; revert. This proves the guard worked as intended.</span>
 78 |     | <span class='unexecuted'>        vm.expectRevert(bytes(&quot;ETH transfer failed&quot;));</span>
 79 |     | <span class='unexecuted'>        attacker.attack();</span>
 80 |     | <span class='neutral'></span>
 81 |     | <span class='neutral'>        // --- Post-Attack State Verification ---</span>
 82 |     | <span class='neutral'>        // The attacker should have received the FIRST payment, but the re-entrant</span>
 83 |     | <span class='neutral'>        // calls should have failed, reverting the entire transaction.</span>
 84 |     | <span class='neutral'>        // Therefore, the state should be exactly as it was before the attack.</span>
 85 |     | <span class='unexecuted'>        console.log(&quot;Attacker Balance After Attack:&quot;, address(attacker).balance);</span>
 86 |     | <span class='unexecuted'>        console.log(&quot;Treasury Balance After Attack:&quot;, address(treasury).balance);</span>
 87 |     | <span class='neutral'></span>
 88 |     | <span class='unexecuted'>        assertEq(address(attacker).balance, 0, &quot;Attacker balance should be 0 because transaction reverted&quot;);</span>
 89 |     | <span class='unexecuted'>        assertEq(address(treasury).balance, 10 ether, &quot;Treasury balance should be unchanged&quot;);</span>
 90 |     | <span class='neutral'>    }</span>
 91 |     | <span class='neutral'>}</span>
 92 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/phantom/Documents/azemora/azemora-contracts/test/upgrades/DynamicImpactCreditUpgrade.t.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>pragma solidity ^0.8.20;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>import &quot;forge-std/Test.sol&quot;;</span>
  5 |     | <span class='neutral'>import &quot;../../src/core/DynamicImpactCredit.sol&quot;;</span>
  6 |     | <span class='neutral'>import &quot;./DynamicImpactCreditV2.sol&quot;;</span>
  7 |     | <span class='neutral'>import &quot;../../src/core/ProjectRegistry.sol&quot;;</span>
  8 |     | <span class='neutral'>import &quot;@openzeppelin/contracts/proxy/ERC1967/ERC1967Proxy.sol&quot;;</span>
  9 |     | <span class='neutral'></span>
 10 |     | <span class='unexecuted'>contract DynamicImpactCreditUpgradeTest is Test {</span>
 11 |     | <span class='neutral'>    // Contracts</span>
 12 |     | <span class='neutral'>    DynamicImpactCredit credit; // The proxy</span>
 13 |     | <span class='neutral'>    DynamicImpactCreditV2 creditV2; // The V2 interface</span>
 14 |     | <span class='neutral'>    ProjectRegistry registry;</span>
 15 |     | <span class='neutral'></span>
 16 |     | <span class='neutral'>    // Users</span>
 17 |     | <span class='unexecuted'>    address admin = makeAddr(&quot;admin&quot;);</span>
 18 |     | <span class='unexecuted'>    address minter = makeAddr(&quot;minter&quot;);</span>
 19 |     | <span class='unexecuted'>    address user = makeAddr(&quot;user&quot;);</span>
 20 |     | <span class='unexecuted'>    bytes32 projectId = keccak256(&quot;TestProject&quot;);</span>
 21 |     | <span class='neutral'>    uint256 tokenId;</span>
 22 |     | <span class='neutral'></span>
 23 |     | <span class='unexecuted'>    function setUp() public {</span>
 24 |     | <span class='unexecuted'>        tokenId = uint256(projectId);</span>
 25 |     | <span class='neutral'></span>
 26 |     | <span class='unexecuted'>        vm.startPrank(admin);</span>
 27 |     | <span class='neutral'></span>
 28 |     | <span class='neutral'>        // Deploy Registry</span>
 29 |     | <span class='unexecuted'>        ProjectRegistry registryImpl = new ProjectRegistry();</span>
 30 |     | <span class='unexecuted'>        registry = ProjectRegistry(</span>
 31 |     | <span class='unexecuted'>            address(new ERC1967Proxy(address(registryImpl), abi.encodeCall(ProjectRegistry.initialize, ())))</span>
 32 |     | <span class='neutral'>        );</span>
 33 |     | <span class='unexecuted'>        DynamicImpactCredit creditV1Impl = new DynamicImpactCredit(address(registry));</span>
 34 |     | <span class='unexecuted'>        bytes memory creditInitData = abi.encodeCall(DynamicImpactCredit.initialize, (&quot;ipfs://v1&quot;));</span>
 35 |     | <span class='unexecuted'>        credit = DynamicImpactCredit(address(new ERC1967Proxy(address(creditV1Impl), creditInitData)));</span>
 36 |     | <span class='neutral'></span>
 37 |     | <span class='neutral'>        // Grant minter and verifier roles</span>
 38 |     | <span class='unexecuted'>        credit.grantRole(credit.DMRV_MANAGER_ROLE(), minter);</span>
 39 |     | <span class='unexecuted'>        registry.grantRole(registry.VERIFIER_ROLE(), admin);</span>
 40 |     | <span class='neutral'></span>
 41 |     | <span class='neutral'>        // Register and activate the project</span>
 42 |     | <span class='neutral'>        // Note: The project registration must be done by its owner. We will prank as the project owner.</span>
 43 |     | <span class='neutral'>        // But for this test, let&#39;s simplify and have the admin also be the project owner.</span>
 44 |     | <span class='unexecuted'>        registry.registerProject(projectId, &quot;ipfs://project&quot;);</span>
 45 |     | <span class='unexecuted'>        registry.setProjectStatus(projectId, ProjectRegistry.ProjectStatus.Active);</span>
 46 |     | <span class='neutral'></span>
 47 |     | <span class='unexecuted'>        vm.stopPrank();</span>
 48 |     | <span class='neutral'></span>
 49 |     | <span class='neutral'>        // Mint some tokens to have state to check</span>
 50 |     | <span class='unexecuted'>        vm.prank(minter);</span>
 51 |     | <span class='unexecuted'>        credit.mintCredits(user, projectId, 100, &quot;ipfs://batch1&quot;);</span>
 52 |     | <span class='neutral'>    }</span>
 53 |     | <span class='neutral'></span>
 54 |     | <span class='unexecuted'>    function test_upgradeCreditContract_preservesStateAndFunctionality() public {</span>
 55 |     | <span class='neutral'>        // --- 1. Pre-Upgrade Assertions ---</span>
 56 |     | <span class='unexecuted'>        assertEq(credit.balanceOf(user, tokenId), 100, &quot;Pre-upgrade: user should have 100 tokens&quot;);</span>
 57 |     | <span class='unexecuted'>        string[] memory uriHistory = credit.getTokenURIHistory(tokenId);</span>
 58 |     | <span class='unexecuted'>        assertEq(uriHistory.length, 1, &quot;Pre-upgrade: should have 1 URI in history&quot;);</span>
 59 |     | <span class='unexecuted'>        assertEq(uriHistory[0], &quot;ipfs://batch1&quot;, &quot;Pre-upgrade: URI should be correct&quot;);</span>
 60 |     | <span class='neutral'></span>
 61 |     | <span class='neutral'>        // --- 2. Deploy V2 and Upgrade ---</span>
 62 |     | <span class='unexecuted'>        vm.startPrank(admin);</span>
 63 |     | <span class='unexecuted'>        DynamicImpactCreditV2 creditV2Impl = new DynamicImpactCreditV2(address(registry));</span>
 64 |     | <span class='neutral'>        // Use `upgradeToAndCall` to call the new V2 initializer</span>
 65 |     | <span class='unexecuted'>        bytes memory upgradeCallData = abi.encodeCall(DynamicImpactCreditV2.initializeV2, ());</span>
 66 |     | <span class='unexecuted'>        credit.upgradeToAndCall(address(creditV2Impl), upgradeCallData);</span>
 67 |     | <span class='unexecuted'>        vm.stopPrank();</span>
 68 |     | <span class='neutral'></span>
 69 |     | <span class='neutral'>        // --- 3. Post-Upgrade Assertions ---</span>
 70 |     | <span class='unexecuted'>        creditV2 = DynamicImpactCreditV2(address(credit));</span>
 71 |     | <span class='neutral'></span>
 72 |     | <span class='neutral'>        // Check that state is preserved</span>
 73 |     | <span class='unexecuted'>        assertEq(creditV2.balanceOf(user, tokenId), 100, &quot;Post-upgrade: user balance should be preserved&quot;);</span>
 74 |     | <span class='unexecuted'>        string[] memory uriHistoryV2 = creditV2.getTokenURIHistory(tokenId);</span>
 75 |     | <span class='unexecuted'>        assertEq(uriHistoryV2.length, 1, &quot;Post-upgrade: URI history length should be preserved&quot;);</span>
 76 |     | <span class='neutral'></span>
 77 |     | <span class='neutral'>        // Check that old functions still work</span>
 78 |     | <span class='unexecuted'>        vm.prank(minter);</span>
 79 |     | <span class='unexecuted'>        creditV2.mintCredits(user, projectId, 50, &quot;ipfs://batch2&quot;);</span>
 80 |     | <span class='unexecuted'>        assertEq(creditV2.balanceOf(user, tokenId), 150, &quot;Post-upgrade: minting should still work&quot;);</span>
 81 |     | <span class='unexecuted'>        uriHistoryV2 = creditV2.getTokenURIHistory(tokenId);</span>
 82 |     | <span class='unexecuted'>        assertEq(uriHistoryV2.length, 2, &quot;Post-upgrade: URI history should be updated&quot;);</span>
 83 |     | <span class='unexecuted'>        assertEq(uriHistoryV2[1], &quot;ipfs://batch2&quot;, &quot;Post-upgrade: new URI should be correct&quot;);</span>
 84 |     | <span class='neutral'></span>
 85 |     | <span class='neutral'>        // Check that new V2 functionality works</span>
 86 |     | <span class='unexecuted'>        assertTrue(creditV2.isV2(), &quot;V2 state variable &#39;isV2&#39; should be true&quot;);</span>
 87 |     | <span class='neutral'>    }</span>
 88 |     | <span class='neutral'>}</span>
 89 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/phantom/Documents/azemora/azemora-contracts/test/upgrades/DynamicImpactCreditV2.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>pragma solidity ^0.8.20;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>import &quot;../../src/core/DynamicImpactCredit.sol&quot;;</span>
  5 |     | <span class='neutral'></span>
  6 |     | <span class='neutral'>/**</span>
  7 |     | <span class='neutral'> * @title DynamicImpactCreditV2</span>
  8 |     | <span class='neutral'> * @dev A dummy V2 contract for testing the upgradeability of DynamicImpactCredit.</span>
  9 |     | <span class='neutral'> */</span>
 10 |     | <span class='unexecuted'>contract DynamicImpactCreditV2 is DynamicImpactCredit {</span>
 11 |     | <span class='neutral'>    /// @notice A new state variable to demonstrate a storage-extending upgrade.</span>
 12 |     | <span class='unexecuted'>    bool public isV2;</span>
 13 |     | <span class='neutral'></span>
 14 |     | <span class='unexecuted'>    constructor(address registryAddress) DynamicImpactCredit(registryAddress) {}</span>
 15 |     | <span class='neutral'></span>
 16 |     | <span class='neutral'>    /// @notice An initializer for the V2 contract.</span>
 17 |     | <span class='unexecuted'>    function initializeV2() public {</span>
 18 |     | <span class='unexecuted'>        isV2 = true;</span>
 19 |     | <span class='neutral'>    }</span>
 20 |     | <span class='neutral'>}</span>
 21 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/phantom/Documents/azemora/azemora-contracts/test/upgrades/MarketplaceV2.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>pragma solidity ^0.8.20;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>import &quot;../../src/marketplace/Marketplace.sol&quot;;</span>
  5 |     | <span class='neutral'></span>
  6 |     | <span class='neutral'>/// @notice A mock V2 contract for testing the upgrade process.</span>
  7 |     | <span class='neutral'>/// @dev It adds a new state variable and a function to modify it, simulating a simple feature addition.</span>
  8 |     | <span class='neutral'>/// The UUPS upgrade pattern requires that the new implementation inherits from the old one.</span>
  9 |     | <span class='unexecuted'>contract MarketplaceV2 is Marketplace {</span>
 10 |     | <span class='neutral'>    /// @notice A new state variable to demonstrate a storage-extending upgrade.</span>
 11 |     | <span class='unexecuted'>    uint256 public version;</span>
 12 |     | <span class='neutral'></span>
 13 |     | <span class='neutral'>    /// @notice Sets the version number. Can be called after the upgrade.</span>
 14 |     | <span class='unexecuted'>    function setVersion(uint256 _newVersion) external {</span>
 15 |     | <span class='unexecuted'>        version = _newVersion;</span>
 16 |     | <span class='neutral'>    }</span>
 17 |     | <span class='neutral'>}</span>
 18 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/phantom/Documents/azemora/azemora-contracts/test/upgrades/ProjectRegistryUpgrade.t.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>pragma solidity ^0.8.20;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>import &quot;forge-std/Test.sol&quot;;</span>
  5 |     | <span class='neutral'>import &quot;../../src/core/ProjectRegistry.sol&quot;;</span>
  6 |     | <span class='neutral'>import &quot;./ProjectRegistryV2.sol&quot;;</span>
  7 |     | <span class='neutral'>import &quot;@openzeppelin/contracts/proxy/ERC1967/ERC1967Proxy.sol&quot;;</span>
  8 |     | <span class='neutral'></span>
  9 |     | <span class='unexecuted'>contract ProjectRegistryUpgradeTest is Test {</span>
 10 |     | <span class='neutral'>    // Contracts</span>
 11 |     | <span class='neutral'>    ProjectRegistry registry; // The proxy</span>
 12 |     | <span class='neutral'>    ProjectRegistryV2 registryV2; // The V2 interface</span>
 13 |     | <span class='neutral'></span>
 14 |     | <span class='neutral'>    // Users</span>
 15 |     | <span class='unexecuted'>    address admin = makeAddr(&quot;admin&quot;);</span>
 16 |     | <span class='unexecuted'>    address projectOwner = makeAddr(&quot;projectOwner&quot;);</span>
 17 |     | <span class='unexecuted'>    bytes32 projectId = keccak256(&quot;TestProject&quot;);</span>
 18 |     | <span class='neutral'></span>
 19 |     | <span class='unexecuted'>    function setUp() public {</span>
 20 |     | <span class='unexecuted'>        vm.startPrank(admin);</span>
 21 |     | <span class='neutral'></span>
 22 |     | <span class='neutral'>        // Deploy V1 implementation and proxy</span>
 23 |     | <span class='unexecuted'>        ProjectRegistry registryV1Impl = new ProjectRegistry();</span>
 24 |     | <span class='unexecuted'>        bytes memory initData = abi.encodeCall(ProjectRegistry.initialize, ());</span>
 25 |     | <span class='unexecuted'>        ERC1967Proxy proxy = new ERC1967Proxy(address(registryV1Impl), initData);</span>
 26 |     | <span class='unexecuted'>        registry = ProjectRegistry(address(proxy));</span>
 27 |     | <span class='neutral'></span>
 28 |     | <span class='neutral'>        // Set initial state on V1 that we will check after the upgrade</span>
 29 |     | <span class='unexecuted'>        vm.stopPrank();</span>
 30 |     | <span class='unexecuted'>        vm.startPrank(projectOwner);</span>
 31 |     | <span class='unexecuted'>        registry.registerProject(projectId, &quot;ipfs://v1&quot;);</span>
 32 |     | <span class='unexecuted'>        vm.stopPrank();</span>
 33 |     | <span class='neutral'></span>
 34 |     | <span class='unexecuted'>        vm.startPrank(admin);</span>
 35 |     | <span class='unexecuted'>        registry.setProjectStatus(projectId, ProjectRegistry.ProjectStatus.Active);</span>
 36 |     | <span class='unexecuted'>        vm.stopPrank();</span>
 37 |     | <span class='neutral'>    }</span>
 38 |     | <span class='neutral'></span>
 39 |     | <span class='unexecuted'>    function test_upgradeProjectRegistry_preservesStateAndFunctionality() public {</span>
 40 |     | <span class='neutral'>        // --- 1. Pre-Upgrade Assertions ---</span>
 41 |     | <span class='unexecuted'>        assertTrue(registry.isProjectActive(projectId), &quot;Pre-upgrade: project should be active&quot;);</span>
 42 |     | <span class='unexecuted'>        ProjectRegistry.Project memory projectV1 = registry.getProject(projectId);</span>
 43 |     | <span class='unexecuted'>        assertEq(uint256(projectV1.status), 1, &quot;Pre-upgrade: project status should be Active (1)&quot;);</span>
 44 |     | <span class='unexecuted'>        assertEq(projectV1.metaURI, &quot;ipfs://v1&quot;, &quot;Pre-upgrade: URI should be the V1 URI&quot;);</span>
 45 |     | <span class='neutral'></span>
 46 |     | <span class='neutral'>        // --- 2. Deploy V2 and Upgrade ---</span>
 47 |     | <span class='unexecuted'>        vm.startPrank(admin);</span>
 48 |     | <span class='unexecuted'>        ProjectRegistryV2 registryV2Impl = new ProjectRegistryV2();</span>
 49 |     | <span class='unexecuted'>        registry.upgradeToAndCall(address(registryV2Impl), &quot;&quot;);</span>
 50 |     | <span class='unexecuted'>        vm.stopPrank();</span>
 51 |     | <span class='neutral'></span>
 52 |     | <span class='neutral'>        // --- 3. Post-Upgrade Assertions ---</span>
 53 |     | <span class='unexecuted'>        registryV2 = ProjectRegistryV2(address(registry));</span>
 54 |     | <span class='neutral'></span>
 55 |     | <span class='neutral'>        // Check that state is preserved</span>
 56 |     | <span class='unexecuted'>        assertTrue(registryV2.isProjectActive(projectId), &quot;Post-upgrade: project should still be active&quot;);</span>
 57 |     | <span class='unexecuted'>        ProjectRegistry.Project memory projectV2 = registryV2.getProject(projectId);</span>
 58 |     | <span class='unexecuted'>        assertEq(projectV2.owner, projectOwner, &quot;Post-upgrade: project owner should be preserved&quot;);</span>
 59 |     | <span class='neutral'></span>
 60 |     | <span class='neutral'>        // Check that old functions still work on the new implementation</span>
 61 |     | <span class='unexecuted'>        vm.startPrank(admin);</span>
 62 |     | <span class='unexecuted'>        registryV2.setProjectStatus(projectId, ProjectRegistry.ProjectStatus.Paused);</span>
 63 |     | <span class='unexecuted'>        assertEq(uint256(registryV2.getProject(projectId).status), 2, &quot;Post-upgrade: setProjectStatus should work&quot;);</span>
 64 |     | <span class='unexecuted'>        vm.stopPrank();</span>
 65 |     | <span class='neutral'></span>
 66 |     | <span class='neutral'>        // Check that new V2 functionality works</span>
 67 |     | <span class='unexecuted'>        vm.startPrank(admin);</span>
 68 |     | <span class='unexecuted'>        registryV2.setRegistryName(&quot;Azemora Main Registry&quot;);</span>
 69 |     | <span class='unexecuted'>        assertEq(registryV2.registryName(), &quot;Azemora Main Registry&quot;, &quot;V2 function &#39;setRegistryName&#39; should work&quot;);</span>
 70 |     | <span class='neutral'>    }</span>
 71 |     | <span class='neutral'>}</span>
 72 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/phantom/Documents/azemora/azemora-contracts/test/upgrades/ProjectRegistryV2.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>pragma solidity ^0.8.20;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>import &quot;../../src/core/ProjectRegistry.sol&quot;;</span>
  5 |     | <span class='neutral'></span>
  6 |     | <span class='neutral'>/**</span>
  7 |     | <span class='neutral'> * @title ProjectRegistryV2</span>
  8 |     | <span class='neutral'> * @dev A dummy V2 contract for testing the upgradeability of ProjectRegistry.</span>
  9 |     | <span class='neutral'> * It adds a new state variable to ensure the storage gap is working as intended.</span>
 10 |     | <span class='neutral'> */</span>
 11 |     | <span class='unexecuted'>contract ProjectRegistryV2 is ProjectRegistry {</span>
 12 |     | <span class='neutral'>    /// @notice A new state variable to demonstrate a storage-extending upgrade.</span>
 13 |     | <span class='unexecuted'>    string public registryName;</span>
 14 |     | <span class='neutral'></span>
 15 |     | <span class='neutral'>    /// @notice Sets the registry name. Can be called after the upgrade.</span>
 16 |     | <span class='unexecuted'>    function setRegistryName(string memory _newName) external {</span>
 17 |     | <span class='unexecuted'>        registryName = _newName;</span>
 18 |     | <span class='neutral'>    }</span>
 19 |     | <span class='neutral'>}</span>
 20 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/phantom/Documents/azemora/azemora-contracts/test/upgrades/TreasuryUpgrade.t.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>pragma solidity ^0.8.20;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>import &quot;forge-std/Test.sol&quot;;</span>
  5 |     | <span class='neutral'>import &quot;../../src/governance/Treasury.sol&quot;;</span>
  6 |     | <span class='neutral'>import &quot;./TreasuryV2.sol&quot;;</span>
  7 |     | <span class='neutral'>import &quot;@openzeppelin/contracts/proxy/ERC1967/ERC1967Proxy.sol&quot;;</span>
  8 |     | <span class='neutral'>import &quot;@openzeppelin/contracts/mocks/token/ERC20Mock.sol&quot;;</span>
  9 |     | <span class='neutral'></span>
 10 |     | <span class='unexecuted'>contract TreasuryUpgradeTest is Test {</span>
 11 |     | <span class='neutral'>    // Contracts</span>
 12 |     | <span class='neutral'>    Treasury treasury;</span>
 13 |     | <span class='neutral'>    TreasuryV2 treasuryV2;</span>
 14 |     | <span class='neutral'>    ERC20Mock paymentToken;</span>
 15 |     | <span class='neutral'></span>
 16 |     | <span class='neutral'>    // Users</span>
 17 |     | <span class='unexecuted'>    address admin = makeAddr(&quot;admin&quot;);</span>
 18 |     | <span class='unexecuted'>    address user = makeAddr(&quot;user&quot;);</span>
 19 |     | <span class='neutral'></span>
 20 |     | <span class='unexecuted'>    function setUp() public {</span>
 21 |     | <span class='unexecuted'>        vm.startPrank(admin);</span>
 22 |     | <span class='neutral'></span>
 23 |     | <span class='neutral'>        // Deploy V1 and Proxy</span>
 24 |     | <span class='unexecuted'>        Treasury treasuryV1Impl = new Treasury();</span>
 25 |     | <span class='unexecuted'>        bytes memory initData = abi.encodeCall(Treasury.initialize, (admin));</span>
 26 |     | <span class='unexecuted'>        ERC1967Proxy proxy = new ERC1967Proxy(address(treasuryV1Impl), initData);</span>
 27 |     | <span class='unexecuted'>        treasury = Treasury(payable(address(proxy)));</span>
 28 |     | <span class='neutral'></span>
 29 |     | <span class='unexecuted'>        vm.stopPrank();</span>
 30 |     | <span class='neutral'></span>
 31 |     | <span class='neutral'>        // Fund the treasury with some ETH and ERC20 tokens</span>
 32 |     | <span class='unexecuted'>        paymentToken = new ERC20Mock();</span>
 33 |     | <span class='unexecuted'>        paymentToken.mint(address(treasury), 1000 ether);</span>
 34 |     | <span class='unexecuted'>        vm.deal(address(treasury), 10 ether);</span>
 35 |     | <span class='neutral'>    }</span>
 36 |     | <span class='neutral'></span>
 37 |     | <span class='unexecuted'>    function test_upgradeTreasury_preservesFundsAndOwnership() public {</span>
 38 |     | <span class='neutral'>        // --- 1. Pre-Upgrade Assertions ---</span>
 39 |     | <span class='unexecuted'>        assertEq(treasury.owner(), admin, &quot;Pre-upgrade: owner should be admin&quot;);</span>
 40 |     | <span class='unexecuted'>        assertEq(paymentToken.balanceOf(address(treasury)), 1000 ether, &quot;Pre-upgrade: ERC20 balance is incorrect&quot;);</span>
 41 |     | <span class='unexecuted'>        assertEq(address(treasury).balance, 10 ether, &quot;Pre-upgrade: ETH balance is incorrect&quot;);</span>
 42 |     | <span class='neutral'></span>
 43 |     | <span class='neutral'>        // --- 2. Deploy V2 and Upgrade ---</span>
 44 |     | <span class='unexecuted'>        vm.startPrank(admin);</span>
 45 |     | <span class='unexecuted'>        TreasuryV2 treasuryV2Impl = new TreasuryV2();</span>
 46 |     | <span class='neutral'>        // Use `upgradeToAndCall` to call the new V2 initializer</span>
 47 |     | <span class='unexecuted'>        bytes memory upgradeCallData = abi.encodeCall(TreasuryV2.initializeV2, ());</span>
 48 |     | <span class='neutral'>        // Cast to UUPSUpgradeable to access upgradeToAndCall</span>
 49 |     | <span class='unexecuted'>        UUPSUpgradeable(payable(address(treasury))).upgradeToAndCall(address(treasuryV2Impl), upgradeCallData);</span>
 50 |     | <span class='unexecuted'>        vm.stopPrank();</span>
 51 |     | <span class='neutral'></span>
 52 |     | <span class='neutral'>        // --- 3. Post-Upgrade Assertions ---</span>
 53 |     | <span class='unexecuted'>        treasuryV2 = TreasuryV2(payable(address(treasury)));</span>
 54 |     | <span class='neutral'></span>
 55 |     | <span class='neutral'>        // Check that state (owner and funds) is preserved</span>
 56 |     | <span class='unexecuted'>        assertEq(treasuryV2.owner(), admin, &quot;Post-upgrade: owner should be preserved&quot;);</span>
 57 |     | <span class='unexecuted'>        assertEq(</span>
 58 |     | <span class='unexecuted'>            paymentToken.balanceOf(address(treasuryV2)), 1000 ether, &quot;Post-upgrade: ERC20 balance should be preserved&quot;</span>
 59 |     | <span class='neutral'>        );</span>
 60 |     | <span class='unexecuted'>        assertEq(address(treasuryV2).balance, 10 ether, &quot;Post-upgrade: ETH balance should be preserved&quot;);</span>
 61 |     | <span class='neutral'></span>
 62 |     | <span class='neutral'>        // Check that old functions still work</span>
 63 |     | <span class='unexecuted'>        vm.prank(admin);</span>
 64 |     | <span class='unexecuted'>        treasuryV2.withdrawETH(user, 1 ether);</span>
 65 |     | <span class='unexecuted'>        assertEq(address(treasuryV2).balance, 9 ether, &quot;Post-upgrade: withdrawETH should still work&quot;);</span>
 66 |     | <span class='neutral'>    }</span>
 67 |     | <span class='neutral'>}</span>
 68 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/phantom/Documents/azemora/azemora-contracts/test/upgrades/TreasuryV2.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>pragma solidity ^0.8.20;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>import &quot;../../src/governance/Treasury.sol&quot;;</span>
  5 |     | <span class='neutral'></span>
  6 |     | <span class='neutral'>/**</span>
  7 |     | <span class='neutral'> * @title TreasuryV2</span>
  8 |     | <span class='neutral'> * @dev A dummy V2 contract for testing the upgradeability of Treasury.</span>
  9 |     | <span class='neutral'> */</span>
 10 |     | <span class='unexecuted'>contract TreasuryV2 is Treasury {</span>
 11 |     | <span class='neutral'>    /// @notice A new event to show V2 functionality.</span>
 12 |     | <span class='neutral'>    event V2Initialized();</span>
 13 |     | <span class='neutral'></span>
 14 |     | <span class='neutral'>    /// @notice An initializer for the V2 contract.</span>
 15 |     | <span class='unexecuted'>    function initializeV2() public {</span>
 16 |     | <span class='unexecuted'>        emit V2Initialized();</span>
 17 |     | <span class='neutral'>    }</span>
 18 |     | <span class='neutral'>}</span>
 19 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/phantom/Documents/azemora/azemora-contracts/test/upgrades/Upgrade.t.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>pragma solidity ^0.8.20;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>import &quot;forge-std/Test.sol&quot;;</span>
  5 |     | <span class='neutral'>import &quot;../../src/marketplace/Marketplace.sol&quot;;</span>
  6 |     | <span class='neutral'>import &quot;./MarketplaceV2.sol&quot;;</span>
  7 |     | <span class='neutral'>import &quot;@openzeppelin/contracts/mocks/token/ERC20Mock.sol&quot;;</span>
  8 |     | <span class='neutral'>import &quot;@openzeppelin/contracts/proxy/ERC1967/ERC1967Proxy.sol&quot;;</span>
  9 |     | <span class='neutral'></span>
 10 |     | <span class='unexecuted'>contract UpgradeTest is Test {</span>
 11 |     | <span class='neutral'>    // Contracts</span>
 12 |     | <span class='neutral'>    Marketplace marketplace; // The proxy, which we will interact with</span>
 13 |     | <span class='neutral'>    ERC20Mock paymentToken;</span>
 14 |     | <span class='neutral'>    address creditContract; // Mocked as an address for this test</span>
 15 |     | <span class='neutral'></span>
 16 |     | <span class='neutral'>    // Users</span>
 17 |     | <span class='unexecuted'>    address admin = makeAddr(&quot;admin&quot;);</span>
 18 |     | <span class='unexecuted'>    address otherUser = makeAddr(&quot;otherUser&quot;);</span>
 19 |     | <span class='neutral'></span>
 20 |     | <span class='unexecuted'>    function setUp() public {</span>
 21 |     | <span class='unexecuted'>        creditContract = makeAddr(&quot;creditContract&quot;);</span>
 22 |     | <span class='unexecuted'>        paymentToken = new ERC20Mock();</span>
 23 |     | <span class='neutral'></span>
 24 |     | <span class='unexecuted'>        vm.startPrank(admin);</span>
 25 |     | <span class='neutral'></span>
 26 |     | <span class='neutral'>        // Deploy V1 Marketplace implementation and proxy</span>
 27 |     | <span class='unexecuted'>        Marketplace marketplaceV1Impl = new Marketplace();</span>
 28 |     | <span class='unexecuted'>        ERC1967Proxy proxy = new ERC1967Proxy(</span>
 29 |     | <span class='unexecuted'>            address(marketplaceV1Impl), abi.encodeCall(Marketplace.initialize, (creditContract, address(paymentToken)))</span>
 30 |     | <span class='neutral'>        );</span>
 31 |     | <span class='unexecuted'>        marketplace = Marketplace(address(proxy)); // Point our interface to the proxy address</span>
 32 |     | <span class='neutral'></span>
 33 |     | <span class='neutral'>        // Set initial state on V1 that we will check after the upgrade</span>
 34 |     | <span class='unexecuted'>        marketplace.setFee(250); // 2.5% fee</span>
 35 |     | <span class='neutral'></span>
 36 |     | <span class='unexecuted'>        vm.stopPrank();</span>
 37 |     | <span class='neutral'>    }</span>
 38 |     | <span class='neutral'></span>
 39 |     | <span class='unexecuted'>    function test_upgradeMarketplace_preservesStateAndRoles() public {</span>
 40 |     | <span class='neutral'>        // --- 1. Pre-Upgrade Assertions ---</span>
 41 |     | <span class='unexecuted'>        assertEq(marketplace.feeBps(), 250, &quot;Pre-upgrade feeBps should be 250&quot;);</span>
 42 |     | <span class='unexecuted'>        assertTrue(</span>
 43 |     | <span class='unexecuted'>            marketplace.hasRole(marketplace.DEFAULT_ADMIN_ROLE(), admin), &quot;Admin should have admin role before upgrade&quot;</span>
 44 |     | <span class='neutral'>        );</span>
 45 |     | <span class='neutral'></span>
 46 |     | <span class='neutral'>        // --- 2. Deploy V2 and Upgrade ---</span>
 47 |     | <span class='unexecuted'>        vm.startPrank(admin);</span>
 48 |     | <span class='unexecuted'>        MarketplaceV2 marketplaceV2Impl = new MarketplaceV2();</span>
 49 |     | <span class='unexecuted'>        marketplace.upgradeToAndCall(address(marketplaceV2Impl), &quot;&quot;); // No call data needed for this simple upgrade</span>
 50 |     | <span class='unexecuted'>        vm.stopPrank();</span>
 51 |     | <span class='neutral'></span>
 52 |     | <span class='neutral'>        // --- 3. Post-Upgrade Assertions ---</span>
 53 |     | <span class='neutral'></span>
 54 |     | <span class='neutral'>        // Cast the proxy address to the V2 interface to access new functions</span>
 55 |     | <span class='unexecuted'>        MarketplaceV2 marketplaceV2 = MarketplaceV2(address(marketplace));</span>
 56 |     | <span class='neutral'></span>
 57 |     | <span class='neutral'>        // Check that state is preserved</span>
 58 |     | <span class='unexecuted'>        assertEq(marketplaceV2.feeBps(), 250, &quot;Post-upgrade feeBps should still be 250&quot;);</span>
 59 |     | <span class='neutral'></span>
 60 |     | <span class='neutral'>        // Check that roles are preserved</span>
 61 |     | <span class='unexecuted'>        assertTrue(</span>
 62 |     | <span class='unexecuted'>            marketplaceV2.hasRole(marketplace.DEFAULT_ADMIN_ROLE(), admin),</span>
 63 |     | <span class='neutral'>            &quot;Admin should still have admin role after upgrade&quot;</span>
 64 |     | <span class='neutral'>        );</span>
 65 |     | <span class='neutral'></span>
 66 |     | <span class='neutral'>        // Check that new V2 functionality works</span>
 67 |     | <span class='unexecuted'>        vm.prank(admin);</span>
 68 |     | <span class='unexecuted'>        marketplaceV2.setVersion(2);</span>
 69 |     | <span class='unexecuted'>        assertEq(marketplaceV2.version(), 2, &quot;V2 function &#39;setVersion&#39; should work after upgrade&quot;);</span>
 70 |     | <span class='neutral'></span>
 71 |     | <span class='neutral'>        // Check that old functions still work on the new implementation</span>
 72 |     | <span class='unexecuted'>        vm.prank(admin);</span>
 73 |     | <span class='unexecuted'>        marketplaceV2.setFee(500);</span>
 74 |     | <span class='unexecuted'>        assertEq(marketplaceV2.feeBps(), 500, &quot;V1 function &#39;setFee&#39; should still work after upgrade&quot;);</span>
 75 |     | <span class='neutral'></span>
 76 |     | <span class='neutral'>        // Check that a non-admin cannot call admin functions</span>
 77 |     | <span class='unexecuted'>        bytes4 expectedError = bytes4(keccak256(&quot;AccessControlUnauthorizedAccount(address,bytes32)&quot;));</span>
 78 |     | <span class='unexecuted'>        vm.expectRevert(abi.encodeWithSelector(expectedError, otherUser, marketplace.DEFAULT_ADMIN_ROLE()));</span>
 79 |     | <span class='unexecuted'>        vm.prank(otherUser);</span>
 80 |     | <span class='unexecuted'>        marketplaceV2.setFee(1000);</span>
 81 |     | <span class='neutral'>    }</span>
 82 |     | <span class='neutral'>}</span>
 83 |     | <span class='neutral'></span>

</code>
<br />

